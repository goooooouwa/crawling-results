<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Matrix67: The Aha Moments</title>
<description></description>
<link>http://www.matrix67.com/blog</link>
<pubDate>2021-11-20T14:45:25+08:00</pubDate>
<!-- other elements omitted from this example -->
<item>
<title><![CDATA[ Möbius版Hex游戏：第一个以Möbius环为棋盘的游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/1107</link>
<content><![CDATA[ 
		<p>  <img alt="image placeholder" >
<p>    把上面这张图想象成一张透明的纸条，然后把下端拧一转再和上端粘在一起，使得相同的字母对接，对应的一对半圆拼合成一个完整的圆。这就形成了一个Möbius环。这个环的边缘有红色区域和蓝色区域各三块（注意当我们提到纸带“边缘”上的色区时，我们不区分它们在哪一边，因为我们不能区分它们在哪一边）。两个玩家分别着红色笔和蓝色笔，轮流在圆圈内涂色。假如你是红色玩家，你的目标就是连通三块红色的区域，或者连通两块红色区域和一个绕纸带一周的“圈”。因此，下面三种情况下红色都能获胜。</p>
<p>   <img alt="image placeholder" >
<p><span id="more-1107"></span><br>
只需要注意到红蓝各三块区域实际上全部分布在一条边上，你会很容易看出，游戏最终一定能产生并且只能产生一个获胜者。</p>
<p>更多请见：<a href="http://www.marksteeregames.com/Mobius_rules.pdf">http://www.marksteeregames.com/Mobius_rules.pdf</a><br>
消息来源：<a href="http://www.mathpuzzle.com">http://www.mathpuzzle.com</a> 为什么这个网站我不能裸上了？</p>
			 ]]></content>
<pubDate>2008-12-06T20:27:48+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1107</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 强大的遗传算法：用50个半透明多边形重现蒙娜丽莎 ]]></title>
<link>http://www.matrix67.com/blog/archives/1113</link>
<content><![CDATA[ 
		<p>通过不断的杂交、变异并与原作比较确定适应度，经过904314代后，终于得到了一个满意的结果。<br>
来源：<a href="http://rogeralsing.com/2008/12/07/genetic-programming-evolution-of-mona-lisa/">http://rogeralsing.com/2008/12/07/genetic-programming-evolution-of-mona-lisa/</a><br>
Update: 给一个JavaScript实现的地址，可在线测试 <a href="http://alteredqualia.com/visualization/evolve/">http://alteredqualia.com/visualization/evolve/</a></p>
<p> <br>
<img alt="image placeholder" >
<span id="more-1113"></span><br>
<img alt="image placeholder" >
			 ]]></content>
<pubDate>2008-12-09T13:18:32+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1113</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 身份验证、中间人攻击和数字签名：浅谈密码学（上） ]]></title>
<link>http://www.matrix67.com/blog/archives/1120</link>
<content><![CDATA[ 
		<p>    说到“密码学”，大多数人的第一念头或许是Morse电码、Ceasar移位密码、同音替换密码之类的东西。这些东西在各类小说中都已是老面孔了，“字母e在英文中出现频率最高”这一最基本的破密码方法已经是耳熟能详了。几天前和网易的<a href="http://blog.codingnow.com/">云风</a>聊了一下，突然体会到了密码学的真谛。密码学关注更多的并不是加密解密的各种数学算法，而是在已有数学算法上如何实现各种安全需求。防止消息泄露只是众多安全问题中的冰山一角，而这个问题本身又有很多复杂的变化。</p>
<p>    当我们谈到“消息泄露”时，我们头脑中想到的往往是，在信息传输过程中如何防止第三方截获。当然，小偷防是防不住的，不过我能保证他偷到东西也没用。双方只需要事先约定一套加密函数和解密函数，以密文的方式进行传输，这样便能很好地防止消息泄露。但有时候，“消息泄露”的内涵复杂得多，加密解密的传统方法并不适用。考虑这么一个问题：10个人坐在一起谈天，突然他们想知道他们的平均年薪，但又都不愿意透露自己的工资数额。有没有什么办法让他们能够得出答案，并且不用担心自己的年薪被曝光？事实上，最简单的解决办法不需要依赖任何密码学知识：第一个人随便想一个大数，比如880516。然后他在纸条上写下这个数与自己的年薪之和，传给第二个人；第二个人再在这个数上加上他的年薪数额，写在另一张纸条上传给第三个人；直到最后一个人把纸条传回第一个人后，第一个人把纸条上的数减去只有自己知道的那个880516，便得到了全部10个人的工资和。</p>
<p><span id="more-1120"></span><br>
    这样的智力题还有很多很多。另一种关于防止信息泄露的场景则是，我不告诉你某样事情，却又要让你相信我知道这件事情。我曾经介绍过<a href="http://www.matrix67.com/blog/archives/424">这么一个问题</a>：给定一个图，假如我找到了一条Hamilton回路，我如何才能让你相信我确实知道答案，而又不告诉你答案是什么？一个基于概率的算法是，我随意构造一个同构图，然后由你来发问：要么让我证明这的确是一个同构图（给出顶点的对应关系），要么叫我指出这个同构图上的Hamilton回路。充分多次测试后，你有充足的理由相信我的确找到了Hamilton回路，但你依旧不知道具体的答案。<br>
    可以看到，密码学不仅仅研究加密解密的数学算法。更多的时候，密码学研究保护信息安全的策略，我们可以称之为“协议”。在已有的数学模型基础上，我们往往忽略具体的数学实现方法，转而专注地研究借助这些数学工具能够构建的安全措施。除了消息保密性以外，密码学还研究一些更加有趣的问题。下面我们看另外三种常见的信息安全问题。</p>
<p> <br>
 <br>
    首先是关于身份验证的问题：我如何才能知道你真的是你。身份验证是密码学关注的一个大问题。接头暗号、帐号密码都是解决身份鉴别问题的办法。在互联网上，“用户名/密码”模式是最常见的用户身份鉴别模式。但这里出现了一个前面没有出现过的严峻问题：如何防止第三方截获？有人可能会脱口而出：为何不像前面一样，把密码加个密发出去？现在的网站一般都用md5的方法对密码进行“单向加密”：客户端计算密码的md5值并发送出去，服务器接收到该md5值并与自己机器上预先算出来的md5结果进行比较。数据以md5的形式进行传输，即使被第三方截获也能保证密码安全。其实，这种方法仍然是不可靠的，原因在于，鉴别问题和消息泄露问题有着本质的区别。在前面的消息传输一例中，为了防止第三方截取者，我们采用了消息加密的方法，避免第三者获取原始信息；而这里，第三方截取者根本就不需要知道你的原始信息是什么，只要照着你发的信息发就是了。如果我想假冒你，只要知道了密码的md5值就可以模拟发送相同的数据包；这个md5值就已经成为了开门的钥匙，你的真实密码是什么对我根本不重要。<br>
    这样一来，身份验证似乎永远不可能做到了——第三者一旦截获你发送的信息就可以完全模拟你。解决这个问题的小技巧就是，让用户每次发送的验证信息都不一样。例如，每次需要身份验证时，服务器随机生成一个字符串，发送给客户端；然后客户端把输入的密码和该字符串连接起来一起md5，再传回去看这个md5值与服务器端的计算结果是否相符。那为什么各大网站没有这么做呢？主要原因估计是因为，每次身份验证都要算一次md5会大大增加服务器的压力。</p>
<p>    留心你周围的事物，你会发现，这种“一次性密码”是经常使用的。我有两张银行卡，一张农行的，一张交行的。交行的网银需要绑定手机，每次网上消费时系统会给你手机发送一段随机代码叫你输入，因此除非你倒霉到卡号、密码和手机同时丢失，否则你的网银账户永远是安全的。农行使用的是“口令卡”，每个人的口令卡都不相同。卡片背后有几十个小格子，每一个格子刮开来就是一个代码。网上交易时，系统会叫你输入某行某列的格子中的数，你便把那一格刮开来看。这些“活动密码”手段有效地防止了网络窃听。<br>
    我编了一个记日记的软件给自己用。进入这个软件时需要输入密码，密码是年份模23加上月份的平方的三倍，再乘以日期的自然对数小数点后第三位，减去小时数的倒数的余切值的最高两位。瞟到我密码的人会发现，等我离开后偷偷打开日记软件，刚才的密码不管用了。</p>
<p> <br>
 <br>
    信息安全这档子事永远是防不胜防。上面这个“活动密码”协议就安全了吗？可以看到，除非你是真的知道用户名密码，否则你不可能骗过主机；同时，数据传输用的md5算法，这是不可逆的，窃听者无法恢复原数据。但是，再往前一追溯，漏洞就出来了：用户注册时提交的那个密码又是怎样传输的呢？显然，这时再用md5来传输是不行的，因为md5不可逆，主机算不出你的真实密码是多少，“活动密码”方案就用不成了；直接用明文传输呢，被第三者窃听的危险又出来了，哪天账户被盗了后打死你也想不出密码在最开始商定的时候就被泄露了。这样看来，用户设定密码时只能进行加密传输了。然而，加密传输必然又要事先约定加密方式，而这个加密方式的商定过程本身又有泄露的风险，这就又回到了原来的问题上。有可能避免密钥的交换么？如果是朋友之间的通信，把两人已知的小秘密用作密钥（例如约定密钥为甲方的生日乘以乙方的手机号）或许能让人放心许多，但在网络中，特别是用户与主机的会话中，这显然是不现实的。这样看来，信息安全问题似乎是没法解决了。<br>
    为了解决这个“圈”，我们需要想一个绝对邪的办法……如果我不告诉任何人解密的算法不就行了么？这就需要一种全新的加密方法，知道密钥的人可以加密，但却不能解密，密文只有在我这儿才能解密。这样的话，就连给我发消息的那个人也只会加密不会解密，安全性得到了极大的提高；即使密钥被窃听了，第三者也读不出原始消息。</p>
<p>    是否有可能告诉一个人加密算法，但他却无从获知解密算法呢？乍看之下这貌似是不可能的。对于一种加密方法，似乎总会存在一种对应的解密算法：你加我就减，你左移我就右移，你替换过去我就替换回来，加密解密步骤正好互逆。虽然难以置信，但这种不可逆的“不对称密码”的确是存在的。RSA算法就是这样一种算法，任何人都可以知道该怎么加密，但让你知道了怎么加密你也不会进行解密，密文只有到了我手里才解得开。也就是说，这种算法有一个可以公开的“公开加密钥匙”，和一个只有自己才有的“私人解密钥匙”。这种神奇的“公钥加密术”的基本思想其实很简单：构造公钥只需要把两个大质数相乘，但要想获得私钥必须进行大数分解，而后者目前还没有什么有效的算法。这一“正行容易逆行难”的思想就是RSA算法的核心。网上对RSA算法的描述太多了，但在这里我还是想简单的描述一下。<br>
    选取两个大质数p和q。算出n=pq。算出φ(n)=(p-1)(q-1)。找一个数小于φ(n)的数e，使得e与φ(n)互质。n和e就可以作为公钥公开了。假设明文m是一个小于n的数。只要拥有公钥n和e，任何人都可以根据公式c=m^e mod n算出密文c（可以二分加速）。但是呢，你会发现你解不回去了……因为只知道n、e和c，你是不能反过来求出m的。<br>
    那我们该怎么算m的值呢？只需要求出一个满足ed≡1 (mod φ(n))的d后，我们就可以直接用公式m=c^d mod n求得明文。利用扩展的辗转相除，我们可以很容易求出满足要求的d。但是φ(n)的值只有我才知道，别人是不知道的（如果想要破解出来必须得把n分解成p和q），因此这个d值就是一个只有我自己才知道的解密钥匙。下面我们来说明上述解密算法的正确性。由于ed-1能被(p-1)(q-1)整除，它必然也能被(p-1)整除，因此m^ed可以表示成m^(k(p-1)+1)，其中k是某个适当的整数。现在，假设m是p的倍数，那直接就有m^(ed)≡0^(ed)≡0≡m (mod p)；否则，m和p一定互质，根据<a href="http://www.matrix67.com/blog/archives/234">Fermat小定理</a>有m^(p-1)≡1(mod p)，于是m^(ed) = m^(k(p-1)+1) = [m^(p-1)]^k * m ≡ 1^k * m ≡ m (mod p)。同理，当模数为q时也总有m^(ed)≡m。既然p整除m^(ed)-m，q也整除m^(ed)-m，并且p和q都是质数，那么一定有m^(ed)≡m (mod pq)，即m^(ed)≡m (mod n)。这个m^(ed)就等于我们前面的c^d。</p>
<p>    现在我们得到了两个函数F和G，其中F(m)=c，而G(c)=m。大家都知道函数F是什么，但是却求不出函数G，这个函数G就是只有我自己知道的私人钥匙，函数F则是公之于众的公共钥匙。<br>
    这一套算法最大的意义就是省去了隐患多多的“密钥交换”这一步。以后大家发送加密消息前再也不需要暗中约定密码算法了。每个人都自己找两个几十几百位长的质数，生成公钥n和e公布到网上去。如果A要和B通信，A直接用B的公钥进行加密，然后把密文传给B；A不会害怕第三者截获消息，因为这个密码只有B才能解得开。同样地，B想要回复A的话，只需要用A的公钥加密，然后把消息发送给A即可。在服务端与客户端的信息交流中更适合使用公钥加密术，因为服务端向所有客户端公告其公共钥匙更加方便，更加合理。用户需要设定密码时，传输请求前只需要把要提交的数据用服务端的公开密钥进行加密即可，这样既不用交换密钥，又不必担心第三者的窃听，因为这个数据只有服务端才能解开。</p>
			 ]]></content>
<pubDate>2008-12-11T23:53:54+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1120</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 据说可以用来测试智力的几张图片 ]]></title>
<link>http://www.matrix67.com/blog/archives/1128</link>
<content><![CDATA[ 
		<p>    下面这几张图片来源于某个心理学实验，据说可以用来测试人的智力。要想看出每张图片上画的是什么，你需要充分发挥你的想象力和观察力。每张图片都描绘了一个明确的东西，因此答案应该是唯一的。如果你真的找出了正确答案，你会非常确信这个答案是正确的。</p>
<p><img alt="image placeholder" >
<p><span id="more-1128"></span><br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
来源：<a href="http://www.moillusions.com/2008/12/some-psychological-test-cards.html">http://www.moillusions.com/2008/12/some-psychological-test-cards.html</a></p>
			 ]]></content>
<pubDate>2008-12-13T00:22:07+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1128</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 身份验证、中间人攻击和数字签名：浅谈密码学（中） ]]></title>
<link>http://www.matrix67.com/blog/archives/1136</link>
<content><![CDATA[ 
		<p>    事情还没有结束呢！我们前面假设，大家公开公钥的方式是“发布在一个众人可信的网站上”，这种假设是有原因的。需要临时交换双方公钥的通话协议是不安全的，这里面存在一个戏剧性的漏洞。举个例子，假如A和B认为，任何网站都是不可靠的，他们从未并且今后也不会在网上公布自己的公钥。为了加密通信，A需要亲自告诉B他的公钥，B也需要亲自告诉A自己的公钥。收到公钥后，双方便用对方的公钥加密进行数据传输。因为用这个公钥加密后，只有对方才能解开密码，因此双方都认为这条通信线路是安全的。其实，他俩的麻烦大了。这条线路并不是安全的，第三者可以用一种很搞笑的方式来窃听消息。假设有一个人C知道A和B之间将有一次加密通话。C劫持了A和B之间的通讯线路。现在，A把他的公钥发给B，这个公钥传到一半时被C拦截下来，于是C获得了A的公钥；C再把他自己的公钥发给B，让B把C的公钥错当成A的公钥。同样地，B把他自己的公钥发给A，被C拦截下来。C把自己的公钥发给A，让A以为那是B的公钥。以后，每当A给B发加密消息时，A其实是用C的公钥在加密；C把A的消息解密后，再用B的公钥加密后传给B。类似地，一旦B给A发送消息，C都可以将消息解密，并用A的公钥进行加密后传过去。此时，A和B都以为自己在用对方的公钥加密，并都能用自己的私有钥匙解开对方传来的密文；殊不知，这中间有人仅仅用了一点雕虫小技，无声无息地窃走了所有的信息。C正是利用了公钥加密术“谁都可以加密”的性质，结结实实地玩弄了A和B。这种攻击方法叫做“中间人攻击”。<br>
    这让我想起了经典的国际象棋骗术。一个象棋白痴宣称自己是个大牛。为了证实这一点，他将要与两位大师同时对弈。他说，我先下后下都能赢。于是，在与大师A的对弈中他为白方，与大师B对战则执黑。结果呢，两盘比赛下来居然都打成了平手。怎么回事呢？其实那个象棋白痴耍了个小伎俩，他把大师A走的棋记了下来，跑到另一边去下给B看，又把B的应着原封不动地搬到了和A的棋局上。来来回回搞了半天，他自己只起了个传递信息的作用，真正在对弈的是两个大师。</p>
<p><span id="more-1136"></span><br>
    怎样防止这种中间人攻击呢？中间人之所以能够得逞，关键就是，无论是网络通话还是国际象棋，双方总是一先一后地发送信息。不过，在网络通讯中，我们有一种很特别的办法，他可以迫使中间人无法再扮演“即时翻译”的角色。首先，A把想说的话（最好是能够证明自己身份的话）进行加密，同时B也完成相同的工作。然后，A把他的加密消息的前面一半传给B，B收到后也把他的密文的一半传给A；A再把剩下的部份传给B，之后B也把他的密文的另一半回传给A。此时，A和B分别用自己的私钥进行解密，查看对方发来的消息。这带给中间人C一个不可逾越的障碍：两段密文要合在一起才能解开，中间人拿着其中一半密文，那是一点办法都没有。此时，中间人陷入了一个非常窘迫的境地，他只有两条路可选：要么硬着头皮把这半截密文发给B，当B得到全部密文后会发现用他自己的私钥根本解不开，从而意识到中间有人捣乱；要么就忽略这半截密文，自己编几句A想跟B说的话，用B的公钥加密并发一半给B。如此一来，中间人需要编造所有A和B之间的对话，这需要相当厚的脸皮，风险异常之大，要不了多久便会露出马脚。</p>
<p> <br>
 <br>
    RSA算法还有一个特别的应用。注意到公钥和私钥所对应的两个函数是互逆的，因此如果我用私钥来加密，用公钥同样可以恢复原来的数据。但是，用我自己的密钥加密，然后大家都可解密，这有什么用处呢？不妨来看看这样“加密”后的效果吧：第一，貌似是最荒谬的，大家都可以看到源文件；第二，很关键的，大家只能够看源文件，但不能改动它；第三，满足上述两个要求的文件别人是做不出来的。<br>
    这些性质正好完美地描述出“签名”的实质。为了防止钓鱼网站骗取你的账户和密码，正牌的那个服务器需要发送一条消息，以证明自己确实是唯一的服务提供商。为此，你可以发送一个随机字符串过去，要求服务器用它的私钥加密。服务器传回他加密过的字符串后，若你用他的公钥解密能恢复出原来的字符串，则说明对方一定是正宗的服务提供商。只有拥有私钥的人才能做到这一点，别人是无法伪造这个“签名”的。<br>
    数字签名还有一些其它的特殊变化。考虑这样一种情况，我有一份秘密文件需要签名，但我不希望签名者看到这份文件的内容。这种看似很不合理的情况确有发生。例如在证人保护计划中，我是一个特工，我需要保护一个非常可爱的无辜小MM。为了把她安置到一个偏远的安全地，我需要让上级签署各种通行证明文件；但为了安全起见，我不希望把安全地的位置泄露给任何人。为此，我希望我的上级对文件进行签名，但保证他们完全不知道文件内容是什么。满足这种要求的签名协议叫做“盲签名”。为了得到一种“盲签名”算法，考虑用RSA进行签名的本质：假设待签名的文本为（不超过模数n的）t，则我们实质上希望得到t^d mod n，其中n是模数，d是签名者的私人钥匙。我们的目的是，对文本t进行干扰（例如在t上面加一个大数，或者乘一个大数，或者取t的倒数的正弦值的-π次方的自然对数），让签名者不知道t是什么；但签名者签名之后，我们还能除去刚才的干扰因子，还原为t^d mod n。因此，我们需要想一个奇妙的办法，让被干扰的文本签名后，干扰因子头上的“d”正好消失了。回忆之前讲过的结论m^(ed)≡m (mod n)，我们立即想到了盲签名算法：我把明文t乘上一个随机数k的e次方（e是公开钥匙），把t*(k^e)传给签名人。注意我们选取的k一定要与n互质，否则k是大质数p或q的倍数，“干扰”的结果必然为0。这下，签名人当然不可能知道t是什么，因为他不知道随机数k是多少。他对t*(k^e)进行签名，传回来的结果即为t^d * k^(ed) mod n。但k^(ed)模n就等于k，于是这个签名结果实际上就是t^d * k mod n。现在，我只需要把该结果除以只有我才知道的k（即乘以它在模n剩余类环中的逆元，这个逆元保证存在，因为k和n互质），即得到了我需要的签名文件t^d mod n。<br>
    盲签名协议并不是只有特工才可能用到的东西，它的应用范围其实相当广。在生活中，我们每个人都可能用到过盲签名。一个最常用的例子就是投票协议——中央机构需要确定每张选票都来自合格的选举人，并且每个人最多投了一次票；但同时选举人又不希望在投票过程中泄露自己的选票内容。但是，为了检查选票的来源是否可靠，中央机构必然要鉴别每张选票所属的投票人。怎么办呢？此时，盲签名协议就派上用场了。每个选举人在自己的选票前面加上一个随机字符串作为前缀（防止以后被暴力破解），然后乘上随机数k的e次方，再连同一份（未被干扰的）身份证明，一同递交给中央机构。中央机构检查身份证明，确认这张（被干扰过的）选票来自合格的选举人。然后中央机构给这张选票签名，回传给选举人。选举人将签名结果除以k，用中央机构的公钥检查看签名是否有效，随机字符串是否和自己当初设定的一样。接着投票人匿名提交这份由中央机构签过名的（且不带干扰因子的）选票。中央机构收到选票，用公钥解密看签名是否有效。这样，中央机构既可以确信每张选票都来自合格的投票人，严格实行一人一票制度，又不能追查出任何一个投票者的选票内容。</p>
<p>    更复杂的盲签名协议来源于这样一种特殊情况：恐怖分子答应供出炸弹的位置，前提条件是需要得到一系列保证无罪逃脱的签名文件，包括新身份、新护照，以及总统亲自签署的免起诉书和安全离境的通行证。同时，恐怖分子又需要确信政府不能知道他的新身份和潜逃地。这需要政府在不知道文件内容的情况下签署协议。这与刚才所谈的盲签名有什么区别呢？一个巨大的区别就是，要求盲签名的不是特工，而是坏蛋，政府在没有看到文件之前不能随意签名。万一恐怖分子要求盲签名的文件实际上是一份要求政府保护全体恐怖分子的安全，保证所有人永不被通缉永不被起诉，并无偿提供恐怖组织基地和巨额资助等不平等条约该咋办？因此，这里需要一种比盲签名要求更高的协议：签名者不能看到文件内容，但要相信文件的内容是什么。<br>
    看起来这似乎是办不到的，但事实上这是有可能的。我们有一个非常简单的办法，它是一个基于概率的协议。恐怖分子可以起草十份文件，每份文件里都包含了一个不同的新身份和潜逃地。然后恐怖分子用十个不同的随机数对这十份文件进行干扰，传给政府。政府选取其中的九份文件，向恐怖分子索要干扰因子。恐怖分子把对应的那九个k值传过去，政府对其进行解密，从而看到这九份文件都是符合要求的文件（只是文件中具体的身份名字和潜逃地点不一样）。政府对最后一个文件进行签名，并把签名结果回递给恐怖分子。恐怖分子除去干扰因子，得到他需要的签名文件。这样，恐怖分子可以保证政府不知道他的新身份和潜逃地，同时政府也能保证恐怖分子不会耍诈。恐怖分子只有1/10的概率可以骗到政府，显然不值得恐怖分子去冒这个险。为安全起见，“10”这个数字还可以任意加大。</p>
			 ]]></content>
<pubDate>2008-12-16T04:12:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1136</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 多功能大厅的椅子应该是什么样子的？ ]]></title>
<link>http://www.matrix67.com/blog/archives/1141</link>
<content><![CDATA[ 
		<p>    严格地说，《牛奶可乐经济学》并不是一本经济学读物。这本书更多地是在解释各种奇怪的生活现象。书里的第一章就是很多关于产品设计的趣闻。例如，为什么装可乐的瓶子都是圆的，但是装牛奶的都是方盒子呢？原因在于，在商场里，可乐是摆在货架上的，但牛奶必须要放在专门的冰柜里。货架很便宜，可乐摆不下了再买一个货架就是了；但是，冰柜的价格很昂贵，我们必须要充分利用冰柜的空间。牛奶的方形容器设计可以让它们紧密地排列在冰柜中，节约了不少的空间。而货架上的可乐就没有必要做成方的了。人们往往拿着可乐瓶直接饮用，圆筒形容器显然更称手一些。比起在货架上节省出来的空间，增加产品易用性的收益显然更高。<br>
    产品设计是一个很有意思的话题。昨天玩NDS上的一个很纯粹的解密游戏。很多题目都是火星题了。第一个让我眼前一亮，知道答案后让我会心一笑的题目是下面这个。</p>
<p>  <img alt="image placeholder" >
<p><span id="more-1141"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
答案：多功能大厅经常要按需求增减椅子数量或清出大片场地，因此需要椅子能够很好的收纳堆放起来。<br>
 <br>
  <img alt="image placeholder" >
			 ]]></content>
<pubDate>2008-12-18T01:18:56+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1141</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：椭圆焦点到两切线交点的连线平分焦点对两切点的张角 ]]></title>
<link>http://www.matrix67.com/blog/archives/1148</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>   如图，椭圆上A、B两点处的切线相交于S，E是椭圆的一个焦点。求证，线段ES平分∠AEB。</p>
<p><span id="more-1148"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p><img alt="image placeholder" >
<p>    椭圆有一个<a href="http://www.matrix67.com/blog/archives/470">神奇的性质</a>：从一个焦点射出的光线，经过椭圆曲线的反射后，总会到达另一个焦点。换句话说，两个焦点分别与切点相连，这两条连线与切线夹角相等。再换句话说，将F沿切线AS反射，对称点M恰好落在EA的延长线上；同样地，令N为F关于BS的对称点，则N、B、E三点共线。又由椭圆的定义，EA+FA=EB+FB。于是，我们有：</p>
<p>EM = EA + AM<br>
    = EA + FA<br>
    = EB + FB<br>
    = EB + BN<br>
    = EN</p>
<p>    这说明△EMN是等腰三角形。为了说明ES为角平分线，只需说明点S也在MN的垂直平分线上即可。这是显然的，因为S是FN和FM的垂直平分线的交点，这立即说明S是△FMN的外心，它当然也应该在MN的垂直平分线上。</p>
<p>    几何画板画椭圆及其上的切线很不方便，因此改用GeoGebra了。一个很好的软件，自变/应变元素管理得很好，属性界面用起来非常舒适，命令行操作功能很强大。以后这个Blog讲到几何问题时就靠它来画图了。</p>
<p>题目来源：<a href="http://www.cut-the-knot.org/Curriculum/Geometry/AngleBisectorsInEllipse.shtml">http://www.cut-the-knot.org/Curriculum/Geometry/AngleBisectorsInEllipse.shtml</a></p>
			 ]]></content>
<pubDate>2008-12-20T03:06:18+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1148</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 猜猜看这是什么地方？ ]]></title>
<link>http://www.matrix67.com/blog/archives/1153</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>有人觉得眼熟吗？</p>
<p><span id="more-1153"></span></p>
<p><iframe width="425" height="350" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="http://maps.google.com/?ie=UTF8&amp;t=k&amp;ll=54.704838,20.512676&amp;spn=0.024498,0.055275&amp;z=14&amp;output=embed&amp;s=AARTsJqzARj-Z8VnW5pkPMLMmZbqrJcYpw"></iframe><br><small><a href="http://maps.google.com/?ie=UTF8&amp;t=k&amp;ll=54.704838,20.512676&amp;spn=0.024498,0.055275&amp;z=14&amp;source=embed" style="color:#0000FF;text-align:left">View Larger Map</a></small></p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>答案：<br>
<a href="http://en.wikipedia.org/wiki/File:Konigsberg_bridges.png">http://en.wikipedia.org/wiki/File:Konigsberg_bridges.png</a><br>
<a href="http://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg#Present_state_of_the_bridges">http://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg#Present_state_of_the_bridges</a></p>
			 ]]></content>
<pubDate>2008-12-21T09:33:00+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1153</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：匿名的消息广播 ]]></title>
<link>http://www.matrix67.com/blog/archives/1160</link>
<content><![CDATA[ 
		<p>    三个好朋友到一家餐厅吃饭。饭快吃完的时候，一个服务员过来告诉他们说，他们的账单已被匿名支付了。三个人都尊重他人匿名付款的权利，但同时他们也想知道，这个匿名支付者是他们三位中的一个，还是他们三人之外的一个第四者。有没有什么办法能够让他们知道在他们之间是否有人付账，但又保证任何人都推测不出究竟是谁付的账？利用三枚硬币可以轻易做到这一点。你能想到这个办法吗？</p>
<p><span id="more-1160"></span><br>
    假设这三个人围着一张圆桌坐成一圈。每个人都在自己和右手边那个人中间抛掷一枚硬币，并用另一只手挡住硬币，使得这枚硬币只有他俩才看得见。这样的话，每个人都只能看见他左右的两枚硬币（但看不见桌子对面的第三枚硬币）。每个人都大声报出，自己身边的两枚硬币的正反面是否相同。如果他们之间有人付账，则这个人报出与实际情况相反的词，相同的话说“不同”，不同的话则说“相同”。显然，如果大家说的都是真话，则报“不同”的次数一定是偶数次。如果有奇数个人说的“不同”，那么一定有一个人说的假话，这表明匿名支付账单的人就在他们之间。</p>
<p> <br>
    注意到这个算法可以扩展到n个人。我们只需要证明，假如有n个人坐成一圈，如果大家都说真话，则说“不同”的次数一定是偶数次。证明很简单：假设所有硬币都是正面，则“不同”次数为0；另外，每把一个正面变成反面，则“不同”的次数要么不变，要么加2或者减2。<br>
    这个算法还可以用于匿名的消息广播。假如一群人围坐成一圈开会，会议过程中需要在场的一个不愿透露自己身份的人进行匿名发言（一个实际例子是，四叶集团高层开会，死亡笔记的持有者想发言）。为此，大家可以统一采用上面的投硬币协议。发言人将信息编码为01串。硬币投掷分若干轮进行。第i轮中，其他人都严格按照实际情况报是否相同，发言人则根据编码信息的第i位的值来通报：若第i位为0，则按照实际情况通报；若第i位为1，则说与实际情况相反的词。这样，实际的信息就应该是每轮叫“不同”的次数模2后的序列。这个协议过程看似很复杂，但在计算机通信中则非常实用。</p>
			 ]]></content>
<pubDate>2008-12-26T01:40:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1160</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 绝对牛B！由多联骨牌拼出的钟表盘面 ]]></title>
<link>http://www.matrix67.com/blog/archives/1163</link>
<content><![CDATA[ 
		<p>    由n个单位正方形拼接而成的图形叫做n联骨牌。一联骨牌和二联骨牌显然都只有一种。三联的有两种（长条形和拐角形）。四联、五联、六联和七联骨牌则分别有5种、12种、35种、108种。<a href="http://www.gamepuzzles.com/polystar7.htm#clock">有牛人</a>竟然把所有这些多联骨牌拼成了一个圆形，更神的是12个五联骨牌的位置让整个圆盘变成了一个钟表的盘面！这12个五联骨牌正好分布在圆盘周围12个间距相当的地方，其中5和10的位置分别用罗马数字V和X表示，9和12则用英文首字母N和T表示。圆盘中间是一联、二联、三联、四联骨牌，外围是35个六联骨牌，再外面则是107个七联骨牌。第108个七联骨牌——中间有一个空洞的特殊骨牌——则被放在了整个圆盘的正中间。</p>
<p> <img alt="image placeholder" >
<p><span id="more-1163"></span></p>
<p> <br>
 <br>
 <br>
 <br>
牛就牛在，这玩意儿居然还有个加强版：</p>
<p> <br>
<img alt="image placeholder" >
			 ]]></content>
<pubDate>2008-12-26T14:28:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1163</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 酷图分享：The Eye of i ]]></title>
<link>http://www.matrix67.com/blog/archives/1177</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>来源：<a href="http://rhythrealmz3.deviantart.com/art/the-Eye-of-i-107581226">http://rhythrealmz3.deviantart.com/art/the-Eye-of-i-107581226</a></p>
			 ]]></content>
<pubDate>2008-12-30T22:35:50+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1177</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 身份验证、中间人攻击和数字签名：浅谈密码学（下） ]]></title>
<link>http://www.matrix67.com/blog/archives/1179</link>
<content><![CDATA[ 
		<p>    前面我们看到，签名具有不可伪造性，因此签名者可以很好的证明自己的身份。事实上，由于签名是不可伪造的，因此签名还有一个重要的功用。当一个人对某份文件进行签名后，这份文件便具有了法律效应：你今后无法再否认你签过这份文件，因为别人是不能伪造签名文件的。签名的这种性质叫做“抗抵赖性”。<br>
    在实际生活中，签名的抗抵赖性用的最多的场合就是签合同了。为了防止一方今后毁约，双方可以要求对方在合同上签名。此后，合同签署人的行为将受到这个签名文件的限制。一旦签名者想毁约，利益受到侵害的人便可以拿着这份合同大闹法庭，高举这份文件大叫“当初他签过名的”。<br>
    当签名用于抗抵赖时，新的问题产生了。签名的法律效应是如此之高，以至于人们往往不敢随意签名。一份合同往往同时规定了双方的权利和义务，并需要双方都在上面签名。第一个在上面签字的人就会觉得很亏：万一我签了字后对方突然翻脸耍赖不签了咋办？即使合同上规定“合同仅在双方均签署之后才有效”，这个问题仍然存在，因为后签名者将具有绝对的主动权，他想什么时候签就什么时候签，而只有他的签名才具有决定意义。因此很多时候，双方都希望能够在对方签名之后自己再签名，从而获得一些安全感。这里我们来探讨一个有趣的问题：有没有什么办法能够让双方同时签约，使得双方签名时都能确保自己的利益安全？<br>
    如果我们谈论的是传统意义上的签名，同时签名当然是有可能办到的：双方只需要拿起各自的笔，同时在文件上写下自己的名字即可。当然，事实上肯定不会有人这么做。试想这样一个荒唐的画面：两个西装笔挺的人挤在一起，两只手臂磕磕碰碰地交错在一起，然后双方同时喊“三、二、一”并一起开始写字……比起自己丢掉的脸面，自己先签名所带来的忧虑还算个屁啊。<br>
    有没有体面一些的，不那么荒唐的同时签字法呢？这里有一个很有启发性的办法。合同双方面对面地坐在桌子的两端。其中一个人在合同上写下自己姓名的第一个字母，然后传给坐在对面的第二个人；第二个人写下他自己名字的第一个字母，然后又回递给第一个人；第一个人签下自己名字的第二个字母，又交给对方要求对方写下自己的第二个字母……以此类推，直到双方都签署完自己的名字为止。为了让双方能够“同时”签完，名字较长的人偶尔可能需要连续写下两三个字母。<br>
    双方都愿意履行这一协议，因为在这个协议下双方是一点一点地签完整个文件的。第一个写字的人不会觉得自己很亏，因为写下一个字母是远不具备法律效应的；如果对方拒绝签他的第一个字母，我可以当即撕毁合同。虽然他们都不知道，究竟要写多少个字母才算签字，但大家都保持自己签下的名字长度与对方基本相当，因此不会担心对方突然放弃协议。就在这种互动的心理过程中，签名的法律效应一点一点地增强，直到最后双方写完自己的名字。</p>
<p><span id="more-1179"></span><br>
    但是，这个办法不能用于数字签名。利用RSA算法进行签名是一个整体的过程，不能分成一部分一部分地进行。能不能把合同拆成若干份，然后双方一份一份地逐个签名呢？当然不行。如果某一份合同里有一个至关重要的义务性条款，后签名的人等对方签到这里后便可以立即终止签名，从而谋取利益。那么，能不能规定“仅当你把所有n个部份的文件都签过了才算签”呢？这意味着最后一次签名才具有最终的决定意义，说穿了不过是把安全问题转移到了“谁签最后这一下”，问题实质上并未改变。其实，我们的解决办法相当简单。我们可以耍一个小花招，从本质上模拟上面的“逐字母签名法”。<br>
    首先，第一个人签署这样一份文件：“我愿意以1%的概率接受该合同”。第二个人检查第一个人的签名，然后在上面附加一句“我愿意以2%的概率接受这份合同”，并进行签名，回交给第一个人。第一个人检查对方已经签名，然后继续将这个条文升级为“我愿意以3%的概率签署该合同”并签名。双方来来回回签100次，直到最后第一个人签“我愿意以99%的概率签署这份合同”，然后轮到第二个人签署“我接受该合同”，最后再轮到第一个人签署“我接受该合同”。<br>
    注意，这个“接受概率”是有实际意义的。如果在第一个人第一次签完文件后，第二个人立即放弃继续签署，法官可能会要求双方进行一次公开抽签测试，选取一个不超过100的正整数。如果这个数恰好为1，那么签署这句话的人就相当于签署了这份合同。类似地，我们也可以约定，当一人声称将以百分之p-1的概率接受此合同，另一人声明以百分之p的概率接受时，法官可以要求双方共同生成一个1至100的整数：如果它不超过p-1则双方都接受，如果它的值比p大则双方都不接受，若它的值正好等于p则合同仅被后者接受。因此，这种协议实质上是用概率法再现了“逐字母签名法”的核心思想，将法律效应的问题进行量化，使得率先签名的潜在危险减小到了原来的百分之一。</p>
<p>    这个协议看似有些可笑，但实际上是可行的。0.01是一个很小的数，双方都能接受，心理上都有保障。况且，签合同的双方通常并没有抵赖的企图，他们只是希望双方能够同时签署协议罢了。但是从密码学协议的角度来看，利用概率进行声明签署的做法确实不那么美观，它让人感觉有些跳出了密码学的理论范围，无法用密码学的语言符号进行规范。有人可能希望我们利用一些密码学手段来实现这种“小步进签名”。比如，双方可以把自己签名后的文件加一个密，然后两人一位一位地轮流宣读自己的密钥。具体地说，A可以想一个大数a，把自己签名后的文件异或a之后传给B；B也可以生成一个同样长的数b，异或自己签名后的合同后传给A。然后，A把a的第一位告诉给B，B把b的第一位告诉A；A再把a的第二位告诉B，同时B宣布b的第二位……直到A、B两人获得对方的全部密钥。事实上，即使你不知道对方的密钥，你也可以枚举对方的密钥进行暴力破解，只不过这个难度是密钥长度的指数级别。双方逐位交换密钥，目的就在于同步减小暴力破解所需的人力、物力和时间。这样，如果中途有人退出协议，两人枚举出对方签名后的文件的难度是相当的，这对双方都很公平。不过，这个协议并不能阻止某人撒谎。其中一方发送的可能根本就不是自己的合同签名，或者宣布自己的密钥时是随便乱叫的；但在整个协议完成之前，对方完全无法察觉出来。协议的思路是好的，不过在我们进一步完善这个协议之前，该协议没有任何使用价值。<br>
    回想起前面提到的恐怖分子一例。那个例子是很有启发性的，其思想可以广泛用于实现各种“反作弊”协议。我们可以把上面的协议稍作修改：A把合同拆成两份，然后分别进行签名，并声明“仅当某人可以同时提供签名合同的两部份才能证明我签署了这份合同”。然后，A生成两个大随机数a1和a2，把前一半签名合同异或a1，把后一半签名合同异或a2。A把两份干扰后的签名合同都传给B。B随机要求查看其中一部分合同的内容，向A索取a1或a2。A把B索要的密钥传给B，向B证明他之前传过去的是真实的合同内容。类似地，B也把自己的合同拆成前后两半并分别签名，然后异或两个不同的大数传给A，并按照A的要求宣布其中一个大数。此时，双方都只拥有对方一半的签名合同，并相信另一半（自己无法解开的）合同是真实的。但根据声明，只有一半合同是不算数的，对方必须同时拥有两部份签名合同才行。接下来，双方又像刚才那样逐位报出剩下那一半合同所对应的大随机数，直到对方获得全部密钥为止。<br>
    合同内容的真实性是保证了，但这仍然不能防止某个人在协议后期虚报自己的密钥。因此，我们还需要想一个办法，让双方在逐位报数阶段中不能作假。为此，我们希望双方都能知道对方密钥的其中一部分信息，以便验证对方宣读的密钥的真实性。上述协议中，我们之所以会被对方欺骗，原因就在于对方知道我现在知道了什么不知道什么。要是有办法能够收到对方的其中一个大数，却不让对方知道我收到了哪个大数的话就好了。这样的话，对方不得不老老实实地宣布这两个大数各是多少，因为他不知道我手里有哪一个数。</p>
<p>    我们称这种特殊的数据传送方式叫做“不经意传输”(oblivious transfer)，意即我自己也不知道传过去了什么。上面这种传输需求有一个更确切的名字，叫做“1-2不经意传输”。在1-2不经意传输中，信息发送者可以准备两个不同的消息m1和m2（比方说，签名合同的前一半和后一半），接收人可以索要并获取m1和m2中的其中一个，但信息发送者不知道他要的是哪一个。实现不经意传输的方式非常巧妙。算法需要再一次用到RSA公钥加密术。首先，发送者生成两对不同的公私钥，并公开两个公钥。不妨称这两个公钥分别为公钥1和公钥2。假设接收人希望知道m1，但不希望发送人知道他想要的是m1。接收人生成一个随机数k，再用公钥1对k进行加密，传给发送者。发送者用他的两个私钥对这个加密后的k进行解密，用私钥1解密得到k1，用私钥2解密得到k2。显然，只有k1是和k相等的，k2则是一串毫无意义的数。但发送者不知道接收人加密时用的哪个公钥，因此他不知道他算出来的哪个k才是真的k。发送人把m1和k1进行异或，把m2和k2进行异或，把两个异或值传给接收人。显然，接收人只能算出m1而无法推测出m2（因为他不知道私钥2，从而推不出k2的值），同时发送人也不知道他能算出哪一个。发送人有一种办法可以作弊：他可以只发送其中一个真实的异或值（而编造另一个异或值），或者用k1和k2对同一个消息进行异或。不过这需要发送者能够猜出信息接收者最初选的是公钥1还是公钥2。如果接收人用公钥1对k加密，但最后得到的却是m2（或者什么都没得到），那发送人的企图就被识破了。</p>
<p>    有了1-2不经意传输协议，我们之前的同步签名问题就彻底解决了。为了让协议更安全，我们还可以让双方各生成n份合同的拷贝，使得成功欺骗的概率仅为1/2^n。一个完整的同步签名协议如下：<br>
    A、B双方各生成带编号的n份一模一样的合同，把每份合同拆成前后两半并分别签名。约定仅当对方同时获得了同一编号的两部分签名合同，合同才算被签署。A生成2n个大数，对他的2n份文件进行异或，然后全部传给B。B也做相同的事情。接下来，借助不经意传输，A向B索取其中的n个大数（对每个文件索要其中一个大数），类似地B也向A索取其中n个大数。此时，双方都能确定对方发来的文件是真实的，并且双方都不知道对方拥有了自己的每份文件的哪一半。接下来，A报出他自己的2n个大数中每一个数的第一位，然后B也报出他的每个数的第一位；然后，A报出每个数的第二位，B也报出每个数的第二位……直到双方报完所有数为止。<br>
    在上述协议的任一阶段里，A和B都不敢作假。发送虚假文件会在不经意传输完成后立即被发现，被欺骗者可以立即终止协议。虚报自己的大数也会穿帮，因为对方有其中一半的大数可用于核对，而你不知道他有哪一些大数。双方逐渐获得越来越多的大数位数，推测对方签名文件的难度同步减小，直到完全获得对方的签名文件。</p>
<p> <br>
 <br>
    我们以这个比较复杂的密码学协议来结束这篇一万多字的文章，目的是想展示一下密码学的科学性和复杂性。我们从身份验证说到了RSA算法，再谈到中间人攻击及其解决办法，最后讲了数字签名和两种特殊的签名方式——盲签名和同步签名。但这还远不到我想说的东西的一半。云风给我推荐了《应用密码学》，我当天晚上就在网上买了，第二天就抱到了文学史课上去看。从这本书里面我学到了好多好多科学的东西。还是那句话，密码学并不专注于数字层面的加密解密方法，而是专注于解决各种安全问题的方法。就像信息学中的算法一样，密码学协议中的算法也相当有趣，有些算法简洁实用，巧妙得有如神来之笔。信息传输的算法，其牛B性不亚于信息处理的算法。接下来我还想更新一些有趣好玩的密码学协议，相信大家会感兴趣的。</p>
			 ]]></content>
<pubDate>2009-01-01T10:14:47+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1179</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 根号2是无理数的又一个精彩证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/1187</link>
<content><![CDATA[ 
		<p>The American Mathematical Monthly新年第一期中有一段精彩的根号2无理性证明。</p>
<p>假设√<span style="text-decoration:overline;">2</span>等于p/q，那么对于任意自然数n都有：</p>
<p>(√<span style="text-decoration:overline;">2</span>)<sup>n</sup> q = 2<sup>n/2</sup> q    当n是偶数时<br>
               2<sup>(n-1)/2</sup> p 当n是奇数时</p>
<p>无论哪种情况，(√<span style="text-decoration:overline;">2</span>)<sup>n</sup> q都是一个自然数。由二项式定理，对任意大的n都有：</p>
<p><img alt="image placeholder" >
<p>但这显然是不可能的，因为序列(√<span style="text-decoration:overline;">2</span> – 1)<sup>n</sup> q是收敛到0的。</p>
<p>参考资料：<a href="http://www.cut-the-knot.org/proofs/sq_root.shtml#proof16">http://www.cut-the-knot.org/proofs/sq_root.shtml#proof16</a><br>
相关文章：<a href="http://www.matrix67.com/blog/archives/156">五种方法证明根号2是无理数</a>，<a href="http://www.matrix67.com/blog/archives/206">又一种证明根号2是无理数的方法</a></p>
			 ]]></content>
<pubDate>2009-01-03T00:01:39+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1187</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一个难看的证明和一个漂亮的证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/1201</link>
<content><![CDATA[ 
		<p>    正逢考试周，抱歉这几天更新很慢。最近6天天天都有考试，今天上午考完英语后，终于有机会喘一口气了。下一次考试是后天下午的古代文学史，打算从明天开始借别人的笔记来背。今天下午先稍微休息一下。<br>
    前几天准备考离散数学时，烦躁得真想把课本撕了。北大出的那本《离散数学教程》是我所见过的最破的教材，里面频繁出现一些诸如假设m和n怎么怎么样结果推出了p和q怎么怎么样的印刷错误；在短短三页纸中，“Peano”被拼写错了四次，而且每次错的都不一样。<br>
    离散数学本身是相当科学的。离散数学中的证明，特别是图论证明，都是相当有趣的。但是，课本上的证明写得太丑了，符号和语言晦涩难懂，思维缺乏直观性和启发性。于是呢，我深刻体会到了这个Blog存在的必要性。我非常反对缺乏直观思维方式的证明过程。一个合格的教科书需要在严格的形式证明之外附上一段证明思路的直观描述。大家或许注意到了，我在写Blog时很不愿意定义变量，能用自然语言描述的地方就尽可能用自然语言来说。在介绍种种精妙的趣题和证明时，我往往会改变证明步骤的顺序和语言表述的方式，以顺应人的直观思维方式；否则，证明的巧妙性和启发性很难被表现出来。</p>
<p><span id="more-1201"></span><br>
    有趣的是，证明的美观性很可能与实际采用的证明方法完全无关。本质相同的两种证明方法，用不同的思维去考察，用不同的文字去讲述，效果可能完全不一样。不妨让我们来看一看《离散数学教程》是如何证明完全图K_5和完全二分图K_3,3不是平面图的。</p>
<blockquote><p>定理：设G是连通平面图，顶点数为v，边数为e，G的各面的边数至少是l，则e≤(v-2)l/(l-2)<br>
证明：用F_i表示第i个面的边数。由<a href="http://www.matrix67.com/blog/archives/1006">Euler公式</a>，面数f=e-v+2，而2e=Σ(F_i) ≥ l·f = l·(e-v+2)，可得e≤(v-2)l/(l-2)<br>
 <br>
推论：完全图K_5和完全二分图K_3,3都不是平面图<br>
证明：(1)由于K_5是简单图，所以l=3，于是10=e≤(v-2)l/(l-2)=(5-2)·3/(3-2)=9，矛盾；<br>
       (2)由于K_3,3没有奇数环，所以l=4，于是9=e≤(v-2)l/(l-2)=(6-2)·4/(4-2)=8，矛盾。</p></blockquote>
<p> <br>
    再来看一看来自Proofs from THE BOOK第11章中的证明：</p>
<blockquote><p>显然，所有面所拥有的平均边数为2e/f。<br>
 <br>
K_5中有5个顶点、10条边。若它是平面图，则它应该有10-5+2=7个面，于是每个面平均拥有20/7条边。这说明该图中至少存在一个边数小于3的面，但对于一个简单图来说这是不可能的。<br>
 <br>
类似地，K_3,3中有6个顶点、9条边。若它是平面图，则它应该有9-6+2=5个面，于是每个面平均拥有18/5条边。这说明该图中至少存在一个边数小于4的面，但对于一个二分图来说这是不可能的。</p></blockquote>
			 ]]></content>
<pubDate>2009-01-07T14:31:50+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1201</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：理想模型下的排序算法（上） ]]></title>
<link>http://www.matrix67.com/blog/archives/1209</link>
<content><![CDATA[ 
		<p>    当我们研究复杂度时，我们往往会将现实机器进行理想化。例如，我们说冒泡排序是O(n^2)的，这其实是不准确的。这个论断假设整数之间的比较运算是O(1)的，而事实上它们是O(log(min(|a|,|b|)))的。多数时候我们都认为这种机器模型的理想化是合理的，毕竟这让问题简化了不少，并且也能反映出算法的本质。但大家有想过吗，这个“大整数随便算”的假设其实是一个超级大漏洞，我们可以利用理想模型中的这一漏洞来作弊，获得时间复杂度更低的算法。上个月，Michael Brand在他的<a href="http://www.brand.site.co.il/riddles/">UyHiP</a>里就提出了<a href="http://www.brand.site.co.il/riddles/200812q.html">这样一个问题</a>：假设计算机对任意大整数的赋值、四则运算、取余运算、比较运算、位运算（包括左移右移）的复杂度都是常数级别，你能否设计出一个O(n)的排序算法来？</p>
<p>    我非常喜欢这个题目。月初的时候我就提交了一个正确的算法。我们将用左移和加法运算把整数序列编码成一个超大整数，然后利用排序网络进行并行排序。这个算法比较复杂，你可以按照下面的思路一步一步得到这个算法。</p>
<blockquote>
<p>1. 如何<a href="http://www.matrix67.com/blog/archives/264">用位运算来取绝对值</a>？</p>
<p>2. 给出两个正整数a, b，不用比较运算和判断语句如何把小数赋给a，大数赋给b？<br>
    提示：和加差除以2等于大数，和减差除以2等于小数</p>
<p>3. 如何利用位运算把整数序列编码成一个超大整数？<br>
    例如把（二进制数）11, 1011, 1110, 1编码为一个数00011 01011 01110 00001</p>
<p>4. 如何用位运算给超大整数中的所有数同时取绝对值？</p>
<p>5. 给出两个超大整数a, b，不用比较运算和判断语句如何把对应位置上的小数赋给a的对应位置，大数赋给b的对应位置？ 例如把<br>
      a = 000010 000111 000100 001001<br>
      b = 000001 001011 000011 011111<br>
    变成<br>
      a = 000001 000111 000011 001001<br>
      b = 000010 001011 000100 011111</p>
<p>6. 如何实现<a href="http://www.matrix67.com/blog/archives/185">奇偶移项排序</a>？</p>
</blockquote>
<p>    最后，由于奇偶移项排序只有O(n)层，因此整个算法是O(n)的。</p>
<p>    但是，这个算法太繁琐了，不具有美观性。虽然这个算法是我自己想出来的，但我仍然很不满意。待我看了这个月Michael Brand发布的答案后，我一拍大腿，哎呀，还有一个如此简单巧妙的算法我没想到！相比之下，我的算法太复杂了，原因就在于我还没有充分挖掘到“大整数的常数级运算”的潜力。这个理想模型的假设太强大了。打开思路，放宽思维，大胆想象，从更大的尺度上来思考，我们可以得到一个简单得出奇的线性排序算法来。</p>
<p><span id="more-1209"></span><br>
    这个理想模型牛B就牛B在，我可以用大整数实现任意长度的数组的常数级别存取！比如，我们假设数组a的“单位宽度”为w，那么让a[i]自加一就相当于让一个超大二进制整数a加上1&lt;&lt;(i*w)。想要取出a[i]的值，也就相当于让a&gt;&gt;(i*w)再模1&lt;&lt;w。再<a href="http://www.matrix67.com/blog/archives/263">回想</a>位运算的一个妙用：x and (x xor (x-1))，或者写成x and -x，可以取出（二进制数）x的最右边那个1。此时，问题立刻迎刃而解。维护一个超级超级长的二进制数a，再维护一个超级超级长的数组b。只要读到一个数x，如果b[1&lt;&lt;x]为0，我们就让a加上1&lt;&lt;x。然后，令b[1&lt;&lt;x]自加一。输出时，只需要不断取a中位置最低的那个“1”，然后按照b数组的值输出相应多个数即可。一个问题是，我们这样输出的是1&lt;&lt;x啊，要想输出原来的数x该咋办？是不是还要想办法用常数时间实现log运算呢？哈哈，你又想复杂了！只需要再维护一个数组c，每次读到x时，令c[1&lt;&lt;x]=x即可。到时候呢，直接输出c数组里面的值就可以了。因此，整个算法流程如下：</p>
<p><code>for (i=0; i&lt;n; i++)<br>
{<br>
    read(x);<br>
    a = a | (1&lt;&lt;x);<br>
    b[1&lt;&lt;x]++;<br>
    c[1&lt;&lt;x] = x;<br>
}<br>
 <br>
while (a &gt; 0)<br>
{<br>
    x = a &amp; (-a);<br>
    for (i=0; i&lt;b[x]; i++) output(c[x]);<br>
    a = a - x;<br>
}</code></p>
<p> <br>
    其中，b的“单位宽度”为n的长度，c的“单位宽度”为数据中最大数的长度。这两个数组本身都能用超大整数直接实现。<br>
    另一个问题是，要是输入数据中有负数该咋办？也很简单，只需要在初始时把每个数都加上一个充分大的数，排序完成后再减掉它就行了。</p>
			 ]]></content>
<pubDate>2009-01-10T14:45:28+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1209</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Mandelbrot the Fractal Bear 可爱的分形熊熊 ]]></title>
<link>http://www.matrix67.com/blog/archives/1227</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>这只熊熊的名字叫做Mandelbrot~~</p>
<p>来源：<a href="http://buttonsformouse.blogspot.com/2008/12/mandelbrot-fractal-bear.html">http://buttonsformouse.blogspot.com/2008/12/mandelbrot-fractal-bear.html</a></p>
<p><span id="more-1227"></span><br>
<img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-01-11T10:28:50+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1227</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 密码学协议举例（一）：带有防欺骗的承诺 ]]></title>
<link>http://www.matrix67.com/blog/archives/1230</link>
<content><![CDATA[ 
		<p>    我们常常在电视上看到这样的一幕：一位老太太兴冲冲地走上台去，翻过三个商标牌，发现上面尽是5块钱、10块钱的小奖，垂头丧气地回到观众席；然后马脸李咏会跑出来，边翻着另外几个牌子边说，1000块的大奖在这个后面，800块的在这里，之类的。或许有人会纳闷了，为什么主持人要演出“事后揭大奖”这一幕呢？道理很简单，节目组想通过这一个“验证过程”告诉观众，这个环节不是骗人的，大奖真的就在这后面，只是刚才那家伙运气背了没摸到而已。摸奖前宣称有大奖，摸完奖之后还能证实大奖真的存在，这就是带有防欺骗的承诺。<br>
    但是，同样的事情在网络上似乎是办不到的。一个典型的例子就是QQ原来弄的那个恶心的砸金蛋砸银蛋。屏幕左边那个是银蛋，屏幕右边那个是金蛋，你鼠标选一个敲下去，看能否砸出QQ宠物来。大量测试表明砸出宠物的概率远远低于50%，让人质疑游戏的真实性。鬼知道它那个程序是不是真的预先指定了一个有宠物的蛋蛋，很可能不管你点了哪个蛋蛋结果都一样，系统按照概率直接显示出抽奖结果来。当然，怀疑游戏的公平性也没办法，要想在网络上实现带防欺骗的承诺是比较困难的，毕竟让你看一段从另一个蛋蛋里跳出一个宠物的Flash动画不能让你相信刚才你是真的“选错”了吧。<br>
    我们的问题就是：如何设计一个协议，用以保证一个二选一的网络互动抽奖游戏的真实性？换句话说，假如你选择了金蛋，结果没有中奖，那么系统如何能够令你相信奖品刚才真的在银蛋里？</p>
<p><span id="more-1230"></span><br>
 <br>
    md5一类的单向散列函数提供了一个不错的方案。系统首先随机选择一个蛋（比如银蛋），在蛋里面藏好奖品，然后把单词“silver”连同一个随机字符串（比如“jq548s”）进行md5。在你抽奖之前，把这个md5值先告诉你。然后你砸蛋，发现金蛋里没有奖品。此时，系统宣布字符串“silverjq548s”，你计算它的md5值，发现和之前系统告诉你的一模一样。此时，你便相信系统刚才是真的把奖品藏在银蛋里了。若你刚才真的砸了银蛋，那系统就没办法抵赖了，因为md5函数是一个单向的、不可逆的、不可预测的函数，想要构造一个“golden某某某”形式的，且md5值和刚才一样的字符串，那比登天还难。另外，注意到在单词后面添加随机字符串这一步骤是必须的，否则你可以尝试计算“silver”和“golden”各自的md5值，从而获知哪个蛋里面有奖品。<br>
    不过，现在看来，这个协议也不可靠了。系统有一个办法可以耍赖：字符串“jq548s”有可能根本不是随机生成的，而是经过一系列精心构造的。我们不能排除这样一种情况，即我们可以通过某种算法构造出一对字符串xxx和yyy，使得“silverxxx”和“goldenyyy”的md5值是一样的。<a href="http://www.matrix67.com/blog/archives/371">md5被破解</a>后，造成这种“碰撞”更是轻松，并且同一对碰撞还可以反复用于欺骗不同的用户。其中一个解决办法是，你可以在协议最初时生成一个自己的随机字符串发给系统，并要求系统传回 “silver/golden” + 系统生成的随机串 + 你自己传过去的随机串 三者并在一起后的md5值。用户一旦参与了字符串的构造，系统作弊就变得真正棘手了。</p>
<p>    还有没有什么其它办法呢？我在《应用密码学》里看到了一个颇有意思的协议，它用伪随机序列来代替单向散列函数。不妨把银蛋标为数字“0”，金蛋标为“1”。在砸蛋之前，你给系统发一个足够长（比方说100位吧）的随机01串A。然后，系统把奖品藏在标号为X的蛋里。下面，系统选择一个随机种子，通过伪随机数列发生器生成100个随机数，并全部模2得到一个100位的随机01串B。然后系统计算01串C，其中</p>
<p>C[i] = B[i] 当A[i]为0<br>
C[i] = B[i] xor X 当A[i]为1</p>
<p>    系统把C传给你，并宣布准备完毕，开始抽奖。事后，系统公开自己选取的随机种子的值，你便能还原序列B，验证序列C是否和系统之前所给的一样。<br>
    如果系统想作弊的话，这要求系统能寻找两个不同的随机种子s1和s2，使得在由它们生成的随机01串（的前100位）中，A中等于“0”的位置上它们的值全部相等，A中等于“1”的位置上它们的值正好相反。但伪随机数列发生器的行为是不可预测，找到这样的s1和s2相当困难，目前看来该协议仍然是安全的。即使找出了这样的碰撞，这样的努力也是一次性的，因为当别的人来抽奖时，随机串A又不一样了，刚才的碰撞就完全没用了。</p>
			 ]]></content>
<pubDate>2009-01-15T23:28:33+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1230</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 这个图形有什么牛B的地方？ ]]></title>
<link>http://www.matrix67.com/blog/archives/1233</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>这是一个由“L”形三联骨牌拼成的图形。你能看出这个图形有什么神奇的地方吗？<br>
答案：<span style="color:#E5E5E5">每一个“L”形板块都与另外四个“L”相邻。这是目前已知的满足这种性质的最小构造。“中心对称”并不是我们想要的答案。我们能用“L”形骨牌轻易构造出大量满足中心对称的简单图形来。</span></p>
<p>来源：<a href="http://www.stetson.edu/~efriedma/xmas/2008/puzzle.html">http://www.stetson.edu/~efriedma/xmas/2008/puzzle.html</a></p>
			 ]]></content>
<pubDate>2009-01-15T23:31:48+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1233</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：在双向有序链表中查找指定的数 ]]></title>
<link>http://www.matrix67.com/blog/archives/1241</link>
<content><![CDATA[ 
		<p>    大家都知道，在一个有序数组里查找指定的数可以做到O(logn)的复杂度。但是大家想过没，在一个有序链表中又怎么样呢？让我们假设有这样一个链表，每个元素都严格小于它的后继元素。每个元素都能访问到自己的前驱元素和后继元素（如果有的话）。另外，我们知道每个元素在内存中的地址，因此可以进行随机存取。或者可以说，这个有序链表中的所有元素都是储存在一个数组中的，但数组本身并不有序。<br>
    现在，我们需要在这个链表中寻找一个指定的数x。你能否设计出一个平均复杂度低于O(n)的算法来？</p>
<p><span id="more-1241"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    下面是一个平均复杂度为O(√<span style="text-decoration:overline;">n</span>)的算法。在数组中随机选取Θ(√<span style="text-decoration:overline;">n</span>)个数，然后通过不断地比较更新，找出这些数当中比x小的最大的数（不妨记作p），以及比x大的最小的数（记作q）。从p所在的位置出发，沿着链表往下走，直到找到x或者走到q（表明x不在链表中）为止。<br>
    可以证明，O(√<span style="text-decoration:overline;">n</span>)已经是最优的了。</p>
			 ]]></content>
<pubDate>2009-01-16T13:15:40+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1241</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一个简单而有用的数据结构 ]]></title>
<link>http://www.matrix67.com/blog/archives/1255</link>
<content><![CDATA[ 
		<p>    Hash表是一个很有用的数据结构，它用O(N)的空间描述一个元素在0到N-1范围内的集合，支持常数级别的添加、删除和查询。遗憾的是，Hash表不能在常数时间内批量删除元素，返回全部元素也需要O(N)的时间，而理论上说这几个操作可以做的更好。现在，你能否设计一个数据结构，它同样占用O(N)的空间，支持常数时间的添加、删除、查询、清空（删除所有元素）、势查询（返回元素个数），以及O(n)时间的元素遍历（其中n表示集合中的元素个数）。</p>
<p><span id="more-1255"></span><br>
    这个数据结构包含一个整型变量n（表示当前元素个数），以及两个数组members和position，前者用来储存当前集合中的元素，后者是一个长度为N的数组，用来记录每个数在members数组中的什么位置（换句话说position[members[i]] == i总成立）。<br>
    想要查询m是否在当前集合内，只需要看看position[m]是不是在0到n-1的范围内，并且members[position[m]]是否也确实等于m。添加一个元素只需要把新元素放进members[n++]，并更新position的相应数据。删除一个元素只需要把该元素移到members队列末尾（让这个元素和members数组的第n个数对换一下位置），同时更新position的相应数据，然后n自减一。清空集合只需要直接令n等于0即可。遍历元素只需要扫描members数组中当前有效的那一段，这显然是O(n)的。变量n就是元素个数，需要查询元素个数时直接返回n就行了。</p>
<p>参考资料：<a href="http://www.onebadseed.com/blog/?p=80">http://www.onebadseed.com/blog/?p=80</a></p>
			 ]]></content>
<pubDate>2009-01-21T18:56:48+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1255</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 密码学协议举例（二）：秘密共享的门限方案 ]]></title>
<link>http://www.matrix67.com/blog/archives/1261</link>
<content><![CDATA[ 
		<p>    电影中经常出现这样的情节：有一份绝密文件需要交给5位特工，为了防止某个特工被捕或者叛变，5名特工各自只持有其中1/5的文件（更好的做法是只持有其中1/5的密钥），这5名特工需要同时在场才能获取文件全文。但这也有一个隐患：如果真的有特工被抓了，当坏人们发现只拿到其中一份文件没有任何用处的同时，特工们也会因为少一份文件无法解开全文而烦恼。此时，你或许会想，是否有什么办法能够让特工们仍然能够恢复原文，即使一部分特工被抓住了？换句话说，有没有什么密文发布方式使得，只要5个人中半数以上的人在场就可以解开绝密文件？这样的话，侵入者必须要能操纵半数以上的特工才可能对秘密文件造成实质性的影响。这种秘密共享方式被称为(3,5)门限方案，意即5个人中至少3人在场才能解开密文。</p>
<p>    实现(m,n)门限方案的一个传统办法是，把这份文件的密钥拆成C(n,m-1)份，每个人持有C(n-1,m-1)份密钥。在(3,5)门限方案中，我们需要C(5,2)=10个密钥，不妨分别用0到9编号；5个特工各持有6个密钥，密钥的分配如下：</p>
<p><code>特工#1: 012345<br>
特工#2: 012   678<br>
特工#3: 0  34 67 9<br>
特工#4:  1 3 56 89<br>
特工#5:   2 45 789</code></p>
<p>    上述分配表的构造其实很简单：为特工的每一种5选3组合分配一个密钥，例如把密钥0分给特工1、2、3，把密钥1分给特工1、2、4，把密钥9分给特工3、4、5。这样的话，任意两个人在场都无法打开文件，因为他们始终缺少一把钥匙（这把钥匙分给了其余三个人）。而任意三个人在场都足以打开文件，因为根据鸽笼原理，任何一个5选3组合中总有一个人落在这三个人当中。这样，我们便利用组合数学巧妙地解决了这一问题。</p>
<p><span id="more-1261"></span><br>
    在密码学中，我们有一些更精妙的方案。最巧妙的方法是，把秘密文件编码为三维空间中的一个点，然后生成5个过该点的平面，每个特工持有其中一个平面方程。显然，两个特工在一起是无法获得原文件的，因为两个平面的公共点有无穷多个；但三个平面的交点是唯一的，因此任意三个人在一起都能解开原文件。<br>
    另一个有趣的办法利用了下面这个事实：知道m-1次多项式函数上的任意m个点就能恢复出整个多项式。因此，我们可以把文件编码为一个二次多项式f，然后把f(1)、f(2)、f(3)、f(4)和f(5)的值告诉对应的特工。任意三个特工碰头之后，只需要解一个三元线性方程即可恢复原文件。多项式的这一性质还曾用于<a href="http://www.matrix67.com/blog/archives/600">数据备份</a>当中。<br>
    利用数论知识我们还能得到一个简单的协议。中国剩余定理告诉我们，给出m个两两互质的整数，它们的乘积为P；假设有一个大整数M，如果我们已知M分别除以这m个数所得的余数，那么在0到P-1的范围内可以唯一地确定这个M。我们可以想办法构造这样一种情况，n个数之中任意m个的乘积都比M大，但是任意m-1个数的乘积就比M小。这样，任意m个模数就能唯一地确定M，但m-1个数就不足以求出M来。 Mignotte门限方案就用到了这样一个思路。我们选取n个两两互质的数，使得最小的m个数的乘积比最大的m-1个数的乘积还大。例如，在(3,5)门限方案中，我们可以取53、59、64、67、71这五个数，前面三个数乘起来得200128，而后面两个数相乘才4757。我们把秘密文件编码为一个4757和200128之间的整数，比如123456。分别算出123456模上面那五个数的结果，得到19、28、0、42、58。显然，知道任意三个同余方程就可以唯一地确定出123456，但仅知道两个方程只能得到成百上千个不定解。例如，假设我们知道了x模59等于28，也知道了x模67得42，那么我们只能确定在0到59*67-1内的解913，并且只能断定M是一个形如59 * 67 * k + 913的数，其中k的数量级和当初选的那五个数一样大。</p>
			 ]]></content>
<pubDate>2009-01-21T21:28:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1261</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 刷屏新工具：史上最壮观的生命游戏构造图 ]]></title>
<link>http://www.matrix67.com/blog/archives/1270</link>
<content><![CDATA[ 
		<p>    这个名叫<a href="http://www.yucs.org/~gnivasch/life/article_cat/">Caterpillar飞船</a>的图形是有史以来最大的<a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">生命游戏</a>构造，它的宽度为4195，高度为330721，要想完整地显示出整个图案需要2000多个显示屏。整个图像即使压缩成RLE文件也有29MB，多数生命游戏模拟软件都无法成功处理。它的周期为270代，每过270代之后整个飞船将竖直移动102个单位，也就是说整个飞船以17c/45的速度向前飞行（c是生命游戏世界中的光速，即一格每代，任何物体都不能超过这个速度）。<br>
    下图以1:40的比例展示了整个构造图。</p>
<p><span id="more-1270"></span><br>
<img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-01-23T15:29:59+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1270</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 预告：几个有趣的编程比赛 ]]></title>
<link>http://www.matrix67.com/blog/archives/1278</link>
<content><![CDATA[ 
		<p>刚过完年回到家，也跟大家说一声新年快乐。<br>
今天莫名其妙地收到一封邮件，邀请我参加<a href="http://felicity.iiit.ac.in">felicity.iiit.ac.in</a>举办的几个编程比赛。我看了一下介绍，这些比赛还是挺有意思的，这里向大家推荐一下。</p>
<p><a href="http://felicity.iiit.ac.in/codecraft/">http://felicity.iiit.ac.in/codecraft/</a><br>
CodeCraft，举办了两三年了，一个传统方式的编程比赛。<br>
测试赛：14th Feb, 6pm – 8pm IST (GMT +5:30).<br>
正式比赛：15th Feb, 2pm – 10pm IST (GMT +5:30).</p>
<p><a href="http://felicity.iiit.ac.in/~math/">http://felicity.iiit.ac.in/~math/</a><br>
MathematiKa，已经举办过一年了，这是第二年的比赛。比赛共12道数学题，你只需要提交答案即可。例如，去年的第四题叫你计算前30个正整数x使得F(x) = 5x^2 + 14x + 1是一个完全平方数。提交时，把所有30个数从小到大连接在一起即可。最大的那个x有十几位，因此这题硬算是不行的。<br>
测试赛：12th Feb, 6pm – 9pm IST (GMT +5:30).<br>
正式比赛：13th Feb, 2pm – 10pm IST (GMT +5:30)</p>
<p><span id="more-1278"></span><br>
<a href="http://felicity.iiit.ac.in/tle/">http://felicity.iiit.ac.in/tle/</a><br>
Time Limit Exceeded是一个另类的C/C++编程挑战赛，得分的依据千奇百怪，源码的长度、分号的个数、空格的个数都有可能算到得分公式里。例如，写一个Hello World程序，得分是100/(1 + 分号个数 + 空格个数)。下面两段代码中，第一个代码用了四个空格和一个分号，因此只能得16.67分；第二个代码只用到一个空格，因此可以得到50分。</p>
<p><code>#include&lt;stdio.h&gt;<br>
int main()<br>
{<br>
puts("Helloworld");<br>
}</code></p>
<p><code>#include&lt;stdio.h&gt;<br>
main(){if(puts("HelloWorld")){}}</code></p>
<p>测试赛：9th Feb, 6pm – 9pm IST (UTC +5:30).<br>
正式比赛：10th Feb 2pm – 13th Feb 2pm (72 hours [3 days]) IST (UTC +5:30).</p>
			 ]]></content>
<pubDate>2009-01-27T21:29:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1278</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 密码学协议举例（三）：另类的密钥交换协议 ]]></title>
<link>http://www.matrix67.com/blog/archives/1289</link>
<content><![CDATA[ 
		<p>    密钥是密码的命根，一切不安全的秘密交换都源于不安全的密钥交换。目前，绝大多数协议采取RSA算法进行密钥交换，但在RSA算法出现之前，人们又是怎么做的呢？据说，第一个密钥交换算法是一个名叫Ralph Merkel的人在1974年发明的，算法叫做Merkle’s Puzzles。这是一个非常奇特、非常邪恶的密钥交换协议。<br>
    假设A和B想进行秘密通信，他们需要选取一个密钥。A准备好很多很多个形如“密钥编号为X_i，密钥是Y_i”的消息，其中X_i是一个随机标识符，Y_i是一个随机密钥。消息的个数越多越好，起码要有几十万几百万条。然后，A把这些消息都编码为一个个难题，比方说对第i条消息异或一个大质数P_i，并宣称P_i是某个数N_i最小的那个质因子。A把所有编码后的消息全部发给B。B收到这些消息之后，随便选择一条消息进行暴力破解（在上例中就是暴力分解某个N_i），得到某一对对应的x和y。B用明文给A发一个消息，说“我们就用编号为x的密钥吧”。由于A知道这个x对应的是哪个y，因此A知道B说的密钥是哪个。<br>
    这个协议的核心就是，第三者不知道B当时选的是哪条消息。如果有第三者截获了他们之间的通信，要想获得密钥y，他必须一一破解所有的难题，直至解开了那个编号为x的密钥消息。由于这样的难题数量大得惊人，第三者要花费的努力是B的上百万倍。假如用计算机暴力破解一个难题需要一个小时的时间，那么第三者即使有百倍于B的计算能力，他也需要平均一年多才能解到正确的x和y。</p>
			 ]]></content>
<pubDate>2009-01-29T02:42:54+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1289</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 假如人类生活在1000维空间里…… ]]></title>
<link>http://www.matrix67.com/blog/archives/1293</link>
<content><![CDATA[ 
		<p>    偶然看到<a href="http://blog.plover.com/2009/01/27/#1000-dimensions">这个网页</a>，很是受启发，然后自己也没事干，一个人躺在床上想了很多。</p>
<p> <br>
<strong>昂贵而奢侈的房间</strong><br>
    制造一个房间将变得非常的昂贵，也将变得非常非常奢侈。为了建造一个1000维的立方体空间，你需要在2000个方向上各修建一个999维的墙，即使墙的“厚度”很小很小，这也需要耗费大量的人力、物力和财力。同时，这样的房间也将非常非常非常大。假设1000维空间中的人是一个边长一米的超立方体，边长两米的超立方体房间里可以容纳10^300个人。当然，也许有人会问，为什么不把房间边长定小一些呢？如果房间边长仅有1.01米，容量也超过20000了啊？其实，房间容量大了没有任何意义，人多了照样挤不下。正如把一个单位大小的三维立方体放进边长为1.5米的三维立方体盒子中一样，虽然余下的空间超过了两立方米，但这点空间仍然不可能挤下哪怕再多一个的单位立方体。</p>
<p> <br>
<strong>死一般的世界</strong><br>
    不要对高维世界抱有任何美好的幻想。1000维世界里是一片黑暗的。在1000维世界中，发光体再也牛B不起来了。半径为2的超球体，体积是单位超球体的10^300倍；因此随着与光源的距离的增加，照度以难以想象的恐怖速度垂直递减。类似地，1000维世界也是无声的。要想让声音传到10米外的地方，需要耗费的能量是一个天文数字。<br>
    在这样的世界中，生物将无法进行远程交流，甚至不会进化出视觉和听觉能力。一切社交行为都是以直接接触的形式发生的。另外一种可能是，当被动接收外界能量不可能实现时，生物将进化出一种主动探测外部世界的能力。生物可以发出一种集中程度高、不易向四周弥散的能量束，该能量束能够沿原路返回，使得生物能定向地获取外部信息。<br>
    正如宇宙射线、暗物质、反物质等一些我们（或许是因为缺少某种感觉器官而）感受不到，但事实上确实存在的东西一样，1000维世界中的科学家猜想有光源、声源等自然能量产生。他们投入了大量精力，耗尽了身边可用的资源，企图创造出一个可测量的尺度下的能量源。发现自然的光源和声源将成为物理学界的前沿科学，或者被宗教利用，成为一种具有蛊惑性的仪式。</p>
<p><span id="more-1293"></span><br>
<strong>更强大的几何学</strong><br>
    不过，1000维世界也不尽是坏事。科学家们有值得欣喜的事情：通过观察低维空间的结构，他们能够更深入的理解空间与维度，更早地发现宇宙的本质。空间的弯曲、维度的扩展等概念扎根于每一个人的思想中。平面几何和立体几何将失去意义，针对某一特殊维度上的几何学研究也将毫无价值。几何试卷上的每一道题开头都是“在一个n维空间中…”。<br>
    1000维世界还有很多有趣的地方。在1000维世界中，生物使用的进制数可能非常非常大，语言文字系统也会变得精确而复杂。这是因为，1000维世界中图形的几何形式变换十分丰富，因此可区别意义的符号个数将远远超过平面上的10个阿拉伯数字和26个拉丁字母；同时，由于高维世界中脑容量的增大，丰富的符号、复杂的语言、大规模的乘法口诀表也将被轻易接受。另外，在如此广大的1000维世界中，事物的种类数量都将出奇庞大，拥有与之适应的语言文字和算术系统也是很有必要的。<br>
    另一方面，1000维结构的复杂性也给生活带来了很多不便。假如你想用投影图的方式在纸上描绘一个三维图形，你可以分别画出物体的正视图、侧视图和俯视图。类似地，如果你想在999维的“纸”上作图的话，你需要1000张图片才能展示一个立体图。</p>
<p> <br>
    还有没有什么好玩的呢？欢迎在下面留言与大家分享，写得精彩的我会一一在这后面更新。</p>
			 ]]></content>
<pubDate>2009-01-29T02:56:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1293</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 关于0.9999….=1的证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/1301</link>
<content><![CDATA[ 
		<p>    某日凌晨4点多，网友<a href="http://bonistall.spaces.live.com">Superwyh</a>发来短信说，他梦到了这样一个颇具启发性的问题：如果我们能够证明两个数之间不存在其它的数，这是否足以说明这两个数是相等的？正好当时我还没睡，稍微想了一下，发现这个命题是成立的，因为它的逆否命题显然成立。倘若两个数不相等，那它们之间一定能够插入其它的数（例如这两个数的算术平均值）；反过来，如果两个数之间无法插入别的数，这两个数自然就应该相等了。<br>
    这个命题是相当具有启发性的。或许有人会想，能不能用这一思路去证明两个数相等呢？<br>
    关于两数是否相等的争论，最著名的就是那个关于0.9999….和1是否相等的问题了。这一问题理解起来简单，细想起来争议颇大，真可谓是一个全民化的数学争论，与著名的<a href="http://www.matrix67.com/blog/archives/73">Monty Hall问题</a>有得一拼。不了解极限概念的人可能会说，不管你在后面写多少个9，它都不能达到1的，量变和质变存在本质上的区别。因此，当高中数学课上老师明确指出0.9999….精确地等于1时，还是有不少人瞠目结舌，甚至高声反对。</p>
<p><span id="more-1301"></span><br>
    如何让不懂极限的人相信这一等式呢？这是一个有趣的话题。我们可以用类比法来说服这些“保守派”的人。注意到1/9等于0.1111….，2/9=0.2222….，一直到8/9=0.8888….，我们很容易联想到9/9应该等于0.9999….。但是，9/9等于1，这就说明了两个数是相等的。<br>
    下面这个说法更具有说服力一些。令x=0.9999….，于是10x就等于9.9999….，两者相减可得9x=9，我们立即看出x实际上就等于1。<br>
    有没有什么更加严格一些的证明呢？Superwyh在短信中提到，直觉上看，0.9999….和1之间似乎无法插入其它数字，这很能令人信服两个数是相等的。事实上，我们可以严格地说明不存在x使得0.9999…. &lt; x &lt; 1。倘若有某个x小于1，这说明1-x是一个正数，虽然它可能很小很小。比方说1-x=0.0000000001，那么就有0.9999…. &gt; 0.99999999999 &gt; x；不管1-x有多小，只需要比到x的第一个非0位，0.9999….就已经超过了x。这样看来，任何一个比1小的数，也一定小于0.9999….，因此1和0.9999….之间不存在第三个数。根据前面的结论，我们立即得到，1和0.9999….其实是同一个数。</p>
			 ]]></content>
<pubDate>2009-01-31T18:42:36+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1301</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 主观不可见 一个非常有创意的动作解谜Flash小游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/1305</link>
<content><![CDATA[ 
		<p><a href="http://www.newgrounds.com/portal/view/480006">http://www.newgrounds.com/portal/view/480006</a><br>
<a href="http://www.deadwhale.com/play.php?game=874">http://www.deadwhale.com/play.php?game=874</a></p>
<p>    今天玩到了一个超级有意思的Flash小游戏“Closure”，在这里跟大家推荐一下。游戏画面效果独特，规则简单而有新意，谜题设置巧妙，是难得一见的好游戏。这个游戏世界是一个唯心的世界，物质依赖于人的认识而存在。游戏世界遵从“主观不可见”的物理定律：凡是没被灯光照亮的地方，实际上都是不存在。<br>
    上面两个地址里的内容是一样的。这个游戏本来在newgrounds.com上，但是这个网站被那个掉了，大家上不了的话可以用后面那个链接。游戏有点大，要载入很久，左边那颗心脏是载入的进度条。游戏需要Flash Player 10。</p>
			 ]]></content>
<pubDate>2009-01-31T23:37:25+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1305</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 这些序列都是自相似序列…… ]]></title>
<link>http://www.matrix67.com/blog/archives/1312</link>
<content><![CDATA[ 
		<p>    如果说数学家是魔术师的话，无穷就是一根最强大的魔杖。在Manfred Schröder的一篇题为Fractals in Music的论文里，作者提到，把每个正整数对应的二进制数中“1”的个数依次写下来，得到的数列有一个很神奇的性质：划掉所有的奇数项，得到的序列仍然是整个序列本身。</p>
<p><code>十进制数  1   2   3    4    5    6    7     8     9    10    11    12    13    14<br>
二进制数  1  10  11   100  101  110  111  1000  1001  1010  1011  1100  1101  1110<br>
1的个数   1   1   2    1    2    2    3     1     2     2     3     2     3     3<br>
取偶数项      1        1         2          1           2           2           3</code></p>
<p>    最初我是在《算法艺术与信息学竞赛》里见到这个东西的，当时硬是被震撼住了。这样的序列叫做“自相似序列”，意思是说自己的一部分等于本身。注意到，这个“自相似”可以无限制地进行下去。再次取出所得的序列中的偶数项，结果还是与最初的序列一样；再这样做下去做无数次，每一次的结果都会与原始序列相同。也就是说，无穷里面包含了无穷多个规模不同的无穷，并且所有这些无穷都和原来完全相同。不过呢，仔细一想你会发现这个一点也不奇怪，奥妙就在于，n和2n的二进制表达中唯一的差别就是末尾的那个“0”。</p>
<p><span id="more-1312"></span><br>
    类似的序列还有很多。今天偶然踩进了<a href="http://www.research.att.com/~njas/sequences/selfsimilar.html">这个网页</a>，发现能叫出名字的自相似序列起码还有几十个。仅在二进制上面做文章的就有好几个，有趣的如：</p>
<p><a href="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A030101">A030101</a> 1, 1, 3, 1, 5, 3, 7, 1, 9, 5, 13, 3, 11, 7, 15, 1, 17, 9, 25 … n的二进制表达逆序之后的值<br>
<a href="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A038189">A038189</a> 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0 … n的二进制表达中，最右边的数字“1”左边的数字<br>
<a href="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A020987">A020987</a> 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0 … Golay-Rudin-Shapiro序列，n的二进制中“11”出现次数的奇偶性</p>
<p>    另一些比较神奇的还有：</p>
<p><a href="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A000161">A000161</a> 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1 … 将n表示为两个数的平方和的方案数<br>
<a href="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A001316">A001316</a> 2, 2, 4, 2, 4, 4, 8, 2, 4, 4, 8, 4, 8, 8, 16, 2, 4, 4, 8, 4 … Gould序列，杨辉三角第n行的奇数项个数<br>
<a href="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A016725">A016725</a> 6, 6, 30, 6, 30, 30, 54, 6, 102, 30, 78, 30, 78, 54, 150 … x^2+y^2+z^2 = n^2的非负整数解的个数<br>
<a href="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A046109">A046109</a> 4, 4, 4, 4, 12, 4, 4, 4, 4, 12, 4, 4, 12, 4, 12, 4, 12, 4 … 以原点为圆心半径为n的圆所经过的整数格点的个数<br>
<a href="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A053866">A053866</a> 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0 … n的约数和的奇偶性</p>
			 ]]></content>
<pubDate>2009-02-02T04:29:44+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1312</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 不同维度的对话：带你进入四维世界 ]]></title>
<link>http://www.matrix67.com/blog/archives/1323</link>
<content><![CDATA[ 
		<p>    上次说到维度时，有人提到了如何理解四维空间的问题。这是一个非常有趣的话题，可是我一直没有用心写一下。前段时间网上出了一部片子叫做<a href="http://www.dimensions-math.org/Dim_E.htm">Dimensions: a walk through mathematics</a>，据称里面详细介绍了四维空间。我本以为推荐一下这个片子就能少写一篇又臭又长的日志了的，没想到下下来看了之后发现该片奇差，不了解四维空间的人看了半天估计还是不了解四维空间。最近放假比较闲，打算慢慢来扯一下。如果你以前从来没细想过四维空间的话，相信今天你会有一种超凡脱俗的感觉。<br>
    现在，假设我是一个二维世界的人，我不能理解什么是“高度”，什么是“体”，什么是“空间”。你想向我描述三维世界中的立方体。你该怎么说呢？你或许会从立方体的展开图开始谈起：图(a)就是一个立方体的展开图，如果我们剪一个这种形状的纸板，我们可以把它折成一个正方体。我开始好奇了。</p>
<p><img alt="image placeholder" >
<p><span id="more-1323"></span><br>
    <span style="color:#6180B5">– 你说说该怎么做呢？</span><br>
    <span style="color:#7046AA">– 先把上面几个正方形折起来，把对应的边粘在一起……</span><br>
    <span style="color:#6180B5">– 等会儿呢等会儿呢，这几个正方形是稳定的形状呀，它们的边怎么可能挨到一起呢？</span><br>
    <span style="color:#7046AA">– 傻了吧！在二维世界中它们不是活动的，但是它们可以向第三维度弯折啊！给你画一个图(b)吧，这就是把上面那几个正方形粘合起来的样子，这就成了一个没有封顶、还差一面的正方体……</span><br>
    <span style="color:#6180B5">– 你耍赖！你这样弯折了之后正方形都不是正方形了，都变成梯形了！</span><br>
    <span style="color:#7046AA">– 不对，它们仍然是正方形。图(b)的六块区域其实都是正方形，只是由于透视作用，它们看上去好像变“斜”了。</span><br>
    <span style="color:#6180B5">– 嗯，好吧，你继续。</span><br>
    <span style="color:#7046AA">– 现在我们得到的是一个有盖的盒子。上面五个正方形（其中有四个由于处于第三维度而变了形）的“内部”已经形成了“空间”了，可以往里面放东西了。要想做成一个封闭的正方体，只需要把剩下的那个正方形合上去就行了，最终结果就像图(c)那样。</span><br>
    <span style="color:#6180B5">– 咦？图(c)里面，刚才最后要合上去的那个正方形到哪儿去了？</span><br>
    <span style="color:#7046AA">– 它就是最大的那个正方形。</span><br>
    <span style="color:#6180B5">– 胡说！那个大正方形是五个小正方形拼成的！这个大正方形刚才在图(b)里也有！</span><br>
    <span style="color:#7046AA">– 不是的。图(b)里的大正方形的确是五个小正方形拼成的轮廓，但图(c)里的那个大正方形是真实存在的，它就是最后合上去的那一块。这个大正方形也并不是和那五个小正方形重叠在一起，它们在第三维中的层次是不同的。图(c)就是你梦想的那个正方体了，它由六个正方形组成。你在图(c)中看到的一个小正方形，一个大正方形，四个梯形事实上都是正方形，而且它们都一样大。这六个正方形围成了中间的那个“空间”。</span><br>
    <span style="color:#6180B5">– 我还是不明白。那个大正方形也是在第三维度的，为什么它没变形呢？</span><br>
    <span style="color:#7046AA">– 这是因为，这个正方形所在的方向不是第三个维度，因此看上去和原来一样。</span><br>
    <span style="color:#6180B5">– 那同一个方向上为什么又有一大一小两个正方形呢？</span><br>
    <span style="color:#7046AA">– 唉，真麻烦。这是因为，它们的朝向虽然一样，但在第三维度上的位置不一样。小的那个正方形在第三个维度离我们远一些，看起来就要小一些。</span><br>
    <span style="color:#6180B5">– 哦！我有点明白了。是不是说，旁边一圈那四个“正方形”是跨越了第三维的，因此在第三维空间中一部分离我们近，一部分离我们远，于是看上去就是由大到小渐变过去的，就像是变形了。</span><br>
    <span style="color:#7046AA">– 对！你理解得很好！说真的，平时生活在三维空间中，我都还没仔细想过这一点呢。</span><br>
    <span style="color:#6180B5">– 我好像真的明白了，说错了不要笑我哦。那个“空间”啊，说穿了就是大正方形擦着四个变形正方形在第三维度上向远处的小正方形移动所产生的“轨迹”。</span><br>
    <span style="color:#7046AA">– 正是正是！</span><br>
    <span style="color:#6180B5">– 哎呀我彻底明白了。怪不得我们说n维立方体有2^n个点呢，其实道理很简单。其实只需要把n-1维立方体复制一份，然后对应的顶点相连就可以了。这就是n-1维立方体在第n维发生位移的结果，新增的那2^(n-1)条边就是点的轨迹。</span><br>
    <span style="color:#7046AA">– 哎呀，你太他妈牛B了，读中文系真他妈可惜了。我还给你看一个好玩的东西，让你看看三维立方体是如何旋转的。睁大眼睛仔细看好每个正方形都变到哪儿去了。</span></p>
<p><img alt="image placeholder" >
<p>    <span style="color:#6180B5">– 我又糊涂了。为什么从第三幅图变成第四幅图时，远处的小正方形能够穿越左边界，让其中一小半跑到边界左边来？</span><br>
    <span style="color:#7046AA">– 这个确实不好理解。小正方形并没有“穿过”那条竖直的边，那条边在第三维上离我们更近，而它在我们这个方向上的投影又与小正方形重合了。其实你可以看到，它们之间的拓扑关系仍然是不变的。</span><br>
    <span style="color:#6180B5">– 哦，于是乎远处的小正方形就转到侧面去了，然后又转到离我们近的位置来了，替代了原先大正方形的位置……</span><br>
    <span style="color:#7046AA">– 回去没事多想想吧。期待你睡觉时能够做出一个三维的梦。</span><br>
    <span style="color:#6180B5">– 好的。谢了。</span></p>
<p> <br>
    好了，现在呢，告诉大家一个秘密，其实我是来自四维空间的人，很多人问我四维立方体是啥样子的，烦死我了，于是写下了今天的这篇日志。</p>
<p><img alt="image placeholder" >
    现在我告诉你，四维立方体是由8个大小相同的三维立方体组成，其展开图如图(a)。图(b)是粘合出来的四维盒子，还差一个盖子没有盖。这些看起来像棱台的东西其实都是根正苗红的正方体，只是由于它们在四维空间中位置不同，发生了透视。</p>
<p><img alt="image placeholder" >
    把盖子盖上后，我们就看到了传说中的四维立方体，这个图形相信很多网友已经很熟悉了。图上有一大一小两个标准模样的立方体，这是第四维度上位置不同但都正对我们的两个“三维面”。其它棱台其实都是正方体，只是看上去因透视而变形。四维立方体可以看作是三维立方体的移动轨迹，因此画一个四维立方体很简单：画两个三维立方体，然后连接对应顶点即可。观察四维立方体的旋转，你会看到里面的小立方体穿过一个面跑到了外面，而后又变成了最外面的大立方体。这一切都和二维向三维的推广是类似的。仔细观察思考，你还会发现更多可以类比的地方。</p>
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-02-03T04:12:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1323</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 纸币的秘密：世界各国纸币上的统一记号 ]]></title>
<link>http://www.matrix67.com/blog/archives/1337</link>
<content><![CDATA[ 
		<p>    你知道么？全世界各国的纸币图案上都隐藏有一种相同的、固定的、精确的、用于计算机检测的“标记”或者“签名”。在这篇日志里我将首先给出各大国发行的纸币，你能找出这个隐藏的模式吗？</p>
<p>中国：<br>
<img alt="image placeholder" >
<p> <br>
加拿大：<br>
<img alt="image placeholder" >
<p><span id="more-1337"></span><br>
埃及：<br>
<img alt="image placeholder" >
<p> <br>
欧盟：<br>
<img alt="image placeholder" >
<p> <br>
日本：<br>
<img alt="image placeholder" >
<p> <br>
挪威：<br>
<img alt="image placeholder" >
<p> <br>
墨西哥：<br>
<img alt="image placeholder" >
<p> <br>
新加坡：<br>
<img alt="image placeholder" >
<p> <br>
南非：<br>
<img alt="image placeholder" >
<p> <br>
 <br>
    网友<a href="http://wandsea.com/">wandsea</a>在twitter上分享了一个<a href="http://shizhao.org/2009/02/printing-fake-currency-notes-is-disallowed-in-photoshop/">有趣的东西</a>：如果你想扫描一张百元大钞然后用Photoshop打印出来的话，Photoshop会弹出一个警告，说你正试图打印钞票，老子不让你打印。问题是，这个软件怎么知道你在印钞票呢？最先发现这个秘密的人是德国计算机科学家Markus Kuhn，一次他试图使用Xerox复印机印钞票时发现机器拒绝复印，经过一系列研究之后他终于发现了纸币上的秘密。原来，世界各国的新版纸币都统一使用了一种不容易察觉的记号，即下图所示的五个圆环：</p>
<p><img alt="image placeholder" >
<p>    这五个圆环按照猎户星座(Orion)排列，而它最早是在10欧元(EUR)纸币上发现的，因此这种记号被命名为“EURion星座”。机器一旦发现待印刷的图片含有这种记号，便立即拒绝打印。对全世界范围内的假钞防范工作，这种记号起了很大的作用。<br>
    一个有趣的问题是，哪国钞票把EURion星座隐藏得最好？显然，上面这些钞票都还不足以被提名。澳大利亚的纸币显然要略胜一筹：</p>
<p><img alt="image placeholder" >
<p> <br>
但是，它们都输给了美元：</p>
<p><img alt="image placeholder" >
<p>图片来自：<a href="http://www.worldpapermoney.org/">http://www.worldpapermoney.org/</a><br>
阅读更多：<a href="http://en.wikipedia.org/wiki/EURion_constellation">http://en.wikipedia.org/wiki/EURion_constellation</a></p>
			 ]]></content>
<pubDate>2009-02-06T22:26:28+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1337</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 拥有多个A的概率：又一个条件概率悖论 ]]></title>
<link>http://www.matrix67.com/blog/archives/1344</link>
<content><![CDATA[ 
		<p>    概率论给我们带来了很多匪夷所思的反常结果，条件概率尤其如此。网络上每一次有人发帖提出与条件概率有关的悖论时，总会引来无数人的围观和争论，哪怕这些问题的实质都是相同的。<br>
    来看两道简单的组合数学问题：</p>
<p>       1. 四个人打桥牌。其中一个人说，我手上有一个A。请问他手上有不止一个A的概率是多少？<br>
       2. 四个人打桥牌。其中一个人说，我手上有一个黑桃A。请问他手上有不止一个A的概率是多少？</p>
<p>    这两个问题看起来很像，实际算法大不相同。在第一题问题中，</p>
<p>       手上一个A也没有 有 C(48,13) 种情况<br>
       手上有至少一个A 有 C(52,13) – C(48,13) 种情况<br>
       手上恰好有一个A 有 C(48,12) * 4 种情况<br>
       手上有至少两个A 有 C(52,13) – C(48,13) – C(48,12) * 4 种情况</p>
<p>    根据条件概率公式，手上有超过一个A的概率为(C(52,13) – C(48,13) – C(48,12) * 4) / (C(52,13) – C(48,13)) = 5359/14498 ≈ 37%</p>
<p><span id="more-1344"></span><br>
    在第二个问题中，</p>
<p>       手上有黑桃A  有 C(51,12) 种情况<br>
       手上没有其它花色的A 有 C(48,12) 种情况<br>
       手上还有其它花色的A 有 C(51,12) – C(48,12) 种情况</p>
<p>    根据条件概率公式，手上有超过一个A的概率为(C(51,12) – C(48,12)) / C(51,12) = 11686/20825 ≈ 56%</p>
<p> <br>
    有趣的事情出来了：如果这个人宣布了手中A的花色，他手中有一个以上A的概率竟然会大大增加。<br>
    这怎么可能呢？难道我们上面的计算结果是错误的？事实上，上面的计算并没有错：</p>
<p>   <img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-02-08T22:17:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1344</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Alice and Bob ]]></title>
<link>http://www.matrix67.com/blog/archives/1358</link>
<content><![CDATA[ 
		<p>  <img alt="image placeholder" >
<p>  来源：<a href="http://abstrusegoose.com/113">http://abstrusegoose.com/113</a></p>
			 ]]></content>
<pubDate>2009-02-09T08:16:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1358</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 密码学协议举例（四）：秘密数字的比较 ]]></title>
<link>http://www.matrix67.com/blog/archives/1362</link>
<content><![CDATA[ 
		<p>    让我们来看一个很实用的问题：A和B两位女士希望知道她们俩哪个年龄大，但又都不愿意透露自己的年龄。有什么方法能够让她们在不泄露年龄的情况下比较出年龄大小呢？我们假设双方都是诚实可信的。她们会严格遵守协议并且不会撒谎。她们唯一不希望做的仅仅是泄露自己的年龄。<br>
    不妨设A的年龄为a，B的年龄为b。为简便起见，假设这两个数都是21到30之间的整数。下面这个协议可以让双方比较出a和b的大小，而不透露a和b的实际值。这个协议也不需要第三方的参与。<br>
    协议开始前，B生成一对RSA钥匙，例如n=3233, e=17, d=2753。首先，A选取一个大随机数x，比方说1117。A用B的公开钥匙给随机数1117加密，得到密文1652。A把1652减a的值发给B。如果A是一个22岁的漂亮MM，那么B实际接收到的数就是1630。<br>
    接下来，B尝试用私人密钥来恢复x。由于B不知道a是多少，于是B枚举所有21到30之间的整数，用私钥对</p>
<p>1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660</p>
<p>    这10个数分别解密，得到的结果分别为</p>
<p>527, 1117, 1499, 2606, 3026, 3169, 3043, 1353, 1053, 1633</p>
<p><span id="more-1362"></span><br>
    当然，解出来的10个数里面，只有一个恰好等于x，其余的数其实都没啥意义。不过，B也不知道哪个数等于x。接下来B选取一个素数p，这个素数p应该比x小几个数量级（B不知道x是什么，但A可以透露出x大致的数量级）。假设B选的素数等于97，B把解密得到的10个数全部模p，得到</p>
<p>42, 50, 44, 84, 19, 65, 36, 92, 83, 81</p>
<p>    假设B的年龄是25岁，那么B把后面5项全部加一，然后把下面这10个数和素数p=97传给A：</p>
<p>42, 50, 44, 84, 19, 66, 37, 93, 84, 82</p>
<p>    A只需要（也只能够）算一算1117模p是否等于序列中的第2个数。由于1117≡50 (mod 97)，这就说明被加了一的那些项还在后面，换句话说a≤b。另外，如果说B的年龄是21岁，那么B发送的序列中后面9项都是加了一的，A发现1117和51模97不同余，便可知a&gt;b。<br>
    A不可能知道b是多少，因为A收到的序列是模了p的，A不能把序列还原成模p前的序列，自然也就不能用B的公钥返回去计算并与序列1651, 1652, …, 1660作比较了。</p>
			 ]]></content>
<pubDate>2009-02-09T19:19:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1362</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 比比谁的代码短：TLE测试赛结束 ]]></title>
<link>http://www.matrix67.com/blog/archives/1366</link>
<content><![CDATA[ 
		<p>    <a href="http://www.matrix67.com/blog/archives/1278">上次提到</a>，我非常关注一个即将举办的另类编程挑战赛<a href="http://felicity.iiit.ac.in/tle/">Time Limit Exceeded</a>，这个比赛的得分算法很另类，它将根据你代码的总长度和特定字符的多少而定。在刚刚结束的测试赛中，有几个题目非常具有挑战性，参赛者提交的代码也是牛气冲天。</p>
<p> <br>
<strong>Power of 2</strong><br>
问题：<br>
    输入数据含有多行，每行一个正整数。对每个数，检查看它是否是2的幂，是则输出yes，不是则输出no。<br>
    你的程序不允许使用分号。<br>
    规定0也是2的幂。</p>
<p>得分：<br>
    S= length of code + number of whitespaces;<br>
    score = (250000)/(S^2);</p>
<p><span id="more-1366"></span><br>
样例输入：<br>
2<br>
3<br>
4<br>
5<br>
0</p>
<p>样例输出：<br>
yes<br>
no<br>
yes<br>
no<br>
yes</p>
<p>目前的最好结果为76分：<br>
<code>main(t){while(~scanf("%d",&amp;t)&amp;&amp;puts(t&amp;t-1?"no":"yes")){}}</code></p>
<p> <br>
<strong>Count 1 2 3</strong><br>
问题：<br>
    写一个程序，该程序运行后打印出从1到50 000的整数。<br>
    你不允许使用循环语句和跳转语句（for、while、goto）。<br>
    你不允许使用#define 。</p>
<p>得分：<br>
    S= length of code – number of whitespaces;<br>
    score = 11 + (500*400)/(S^2);</p>
<p>目前的最好结果为124分，仔细体会这段代码，非常的牛：<br>
<code>n;main(){n&lt;5e4&amp;&amp;main(printf("%dn",++n));}</code></p>
<p> <br>
<strong>Segmentation Fault</strong><br>
问题：<br>
    写一个程序，该程序运行后打印出从1到5 000 000的整数。<br>
    你不允许使用循环语句和跳转语句（for、while、goto）。<br>
    你不允许使用#define 。</p>
<p>得分：<br>
    S= length of code - numer of whitespaces;<br>
    score = 51 + (500*1600)/(S^2);</p>
<p>这道题和上道题的区别就是：不加改进的递归会导致堆栈溢出。<br>
目前的最好结果为234分，仔细观察这段代码，看他是怎样避免堆栈溢出的：<br>
<code>j;main(i){i&gt;1e5||printf("%dn",++j)+main(i+1);i&lt;2&amp;j&lt;5e6&amp;&amp;main(1);}</code></p>
			 ]]></content>
<pubDate>2009-02-10T04:03:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1366</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 迟到的情人节祝福 Sierpinski Valentine ]]></title>
<link>http://www.matrix67.com/blog/archives/1377</link>
<content><![CDATA[ 
		<p>    这几天都和MM在外面，一直没有上网，于是今天一回来就开始恶补欠了好几天的网络信息。看到了<a href="http://xkcd.com/543/">xkcd</a>的这个图，很是喜欢，和大家分享一下。</p>
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-02-16T19:44:59+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1377</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ TLE比赛结束 经典题目回顾 ]]></title>
<link>http://www.matrix67.com/blog/archives/1381</link>
<content><![CDATA[ 
		<p>    创意C/C++编程挑战赛<a href="http://felicity.iiit.ac.in/tle/">Time Limit Exceeded</a>结束，题目果然非常有创意。大家可以在<a href="http://felicity.iiit.ac.in/tle/judge/problem">这里</a>看到比赛题目和获胜选手的代码。其中两道题很有意思，我特别喜欢。</p>
<p>    一道叫做<a href="http://felicity.iiit.ac.in/tle/judge/CLASS.html">Compile Error</a>的题目要求你写一个叫做multiply的类，里面包含一个mult(int a,int b)的函数，该函数用于打印出a和b的乘积。代码中不允许出现空格、“/”和“#define”。</p>
<p>    第一个问题就是，定义一个类的语句是class multiply{…}，这个空格要怎么避免？只要你知道typedef int foo也可以写成int typedef foo，我们就可以利用typedef来消除空格，把类的定义写成class{…}typedef multiply。但这下后面又冒出一个空格来，这个空格怎么消呢？一个巧妙的方法就是利用int typedef foo,bar的语句，把类定义语句写成class{…}typedef*foo,multiply，其中*foo是一个不会用到的类型，但是它帮助我们奇迹般地消除了一个空格。巧妙利用星号可以消除很多空格，例如我们在定义mult函数时就可以写成void*mult(…){…}。最后一个难题就是，定义函数mult(int a,int b)，参数表里面的两个空格怎么办？其实办法依然很多。不少网友都用到了<a href="http://en.wikipedia.org/wiki/Typeof">typeof</a>，这样便可以把int a写成typeof(int)a了。完整的类定义如下：</p>
<p><code>class{public:void*mult(typeof(int)a,typeof(int)b){cout&lt;&lt;a*b&lt;&lt;endl;return(0);}}typedef*m,multiply;</code></p>
<p>    在gcc下，即使警告全开，下面这个程序编译时也一声不吱。</p>
<p><code>#include &lt;iostream&gt;<br>
using namespace std;<br>
 <br>
class{public:void*mult(typeof(int)a,typeof(int)b){cout&lt;&lt;a*b&lt;&lt;endl;return(0);}}typedef*m,multiply;<br>
 <br>
int main()<br>
{<br>
    multiply foo;<br>
    foo.mult(23,67);<br>
}</code></p>
<p><span id="more-1381"></span><br>
    另一个牛题目是<a href="http://felicity.iiit.ac.in/tle/judge/PENGUIN.html">Print ‘D Penguin</a>，要求你写一个打印企鹅ASCII Art的程序，程序的输出结果必须和<a href="http://felicity.iiit.ac.in/tle/Penguin.txt">这个文件</a>一模一样，代码越短越好。最牛的代码有点让人摸不着头脑：</p>
<p><code>main(i,z,n){for(;z="_���?��T���G�T��J��T��N�T��P�T�Qp�T�:�?�@�T��9��T��9��9�;�Č9��?T�9��9�Ď?T�9�����?T��8�����@�T��9�먎AT��9�稐�A�T��9��㨓�A�T��;��@�T��;��@�T�����⩗��C�T�=���CT��;ਗ�C�T����T���N��T���N��T����=��A���T����騣���T"[i++]&amp;255;)for(n=z%28;putchar("	`xnX '.:_"[z/28]),n--;);}</code></p>
<p>    这个代码实质上是将整个图片压缩为了一个字符串。由于图片中连续字符出奇的多，我们便想到把“n个字符c”编码为一个字节。字符串的每一个字节取值都是0到255，而图片中只有10种字符（用0到9编号），因此一个字节最多可以表示出255/9=28个连续的相同字符。对于每一个0到255的数，令字符c等于它除以28的商所对应的字符，令n等于它除以28的余数，然后程序打印出n个连续的字符c出来。例如，106=3*28+22，它就代表了22个连续的3号字符。一个麻烦问题是，9*28已经等于252了，因此你最多只能处理连续的三个9号字符。不过没关系，令9号字符为“_”就行了，这是该图片中出现次数最少的字符，而且每次它都是单独出现的。</p>
			 ]]></content>
<pubDate>2009-02-16T21:26:52+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1381</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 绝对是有史以来最酷的计算器！ ]]></title>
<link>http://www.matrix67.com/blog/archives/1386</link>
<content><![CDATA[ 
		<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/GcDshWmhF4A&amp;hl=zh_CN&amp;fs=1">
<param name="allowFullScreen" value="true">
<param name="allowscriptaccess" value="always">
<embed src="http://www.youtube.com/v/GcDshWmhF4A&amp;hl=zh_CN&amp;fs=1" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="425" height="344"></embed></object></p>
<p><a href="http://woodgears.ca/marbleadd/">http://woodgears.ca/marbleadd/</a></p>
			 ]]></content>
<pubDate>2009-02-17T12:23:31+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1386</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：Chaitin定理 不可能编程判断代码的最简性 ]]></title>
<link>http://www.matrix67.com/blog/archives/1392</link>
<content><![CDATA[ 
		<p>    今天学到一个好玩的东西。仿照<a href="http://www.matrix67.com/blog/archives/55">停机问题</a>的研究方法，我们可以想出很多有趣的不可解问题。Gregory Chaitin曾经提出过下面这个问题。如果两段代码运行之后能够输出相同的结果，我们就称较短的代码比长一点的那个更简洁（注意，如果程序需要读入数据，读入的数据也算进代码长度）。对于一个指定的输出，一定存在一个“最简的”代码，它是所有能输出此内容的程序代码中最短的一个。在刚刚结束的<a href="http://www.matrix67.com/blog/archives/1381">TLE比赛</a>中，参数选手拼了命地缩减每一个字符，写出来的代码一个比一个短。有人或许在想，这些代码究竟能短到什么程度？你如何才能知道你的代码已经不再有改进的空间了？受此启发，我们的问题出来了：你能否编写一个程序，使得该程序能够判断任意一段代码是否是最简的？<br>
    Chaitin定理指出，上述问题是一个不可解问题，再牛的人也不可能编写出这样的程序。证明方式与大多数此类问题一样，都是采用反证加构造的方法证明的。你能想到这个证明方法吗？</p>
<p><span id="more-1392"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    假设我们有一个程序A，该程序能读入一段代码并且判断该代码是否最简。写一个程序B，该程序读入一个自然数N，然后枚举出所有长度大于N的程序代码并用程序A进行检测，直到找到一个最简的代码；然后运行这个最简代码，输出和这个最简代码一样的输出内容。现在，运行程序B，输入一个比程序B的代码长度更大的数，让程序B去找一个比它自身更长的最简代码。但是，程序B比这个最简代码要短，输出内容却和它相同，于是矛盾就产生了。<br>
    但是，有没有可能程序B没有输出呢？换句话说，程序B会不会根本找不到一个比它长的最简代码呢？当然不会，因为最简代码显然有无穷多个。</p>
<p style="color:#B88A00">    补充一下：有人没明白这里“最简代码有无穷多个”是什么意思？其实我也很不想说穿它……由于输出结果不同的程序有无穷多种，最简的程序代码显然也有无穷多个；但长度不超过N的代码只有有限多个，因此必然存在长度大于N的最简代码。</p>
<p style="color:#B88A00">    再补充一下：有人问到，B程序如何模拟运行一段别的代码？这个问题问的好！事实上，一个程序语言是可以<a href="http://en.wikipedia.org/wiki/Self-interpreter">自我解释</a>的；换句话说，你完全可以写出一个C语言解释器，而它本身就是用C语言来写的。因此，B程序能够“运行”其它代码，并保证跟它的输出结果一样（即使输出结果有无穷多）。显然，即使这样停机问题仍然没有解决，因为你能模拟它运行了也不知道它会不会停机。<br>
    “自我解释”听起来很不可思议，但事实上是千真万确的。C语言的自我解释器我不知道有没有，不过<a href="http://en.wikipedia.org/wiki/Narcissus_(JavaScript_engine)">用JavaScript写的JavaScript引擎</a>倒是有一个。你甚至能瞻仰到<a href="http://mxr.mozilla.org/mozilla/source/js/narcissus/">它的源码</a>。</p>
<p style="color:#B88A00">    补充3：还有人问到，既然输入也要算进代码长度，那会不会出现纯粹的代码长度没超过N，但把N一输进去代码长度就超过N了？其实，当N取到一定大时，纯代码长度加输入长度必然会超过N，因为数字N本身的长度是以log(n)的级别增长的，总有某个时候会有纯代码长度+log(N)&lt;N。</p>
<p>参考资料：<a href="http://www.flownet.com/gat/chaitin.html">http://www.flownet.com/gat/chaitin.html</a></p>
			 ]]></content>
<pubDate>2009-02-17T23:16:52+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1392</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 密码学协议举例（五）：两个人能够在电话上打牌吗？ ]]></title>
<link>http://www.matrix67.com/blog/archives/1407</link>
<content><![CDATA[ 
		<p>    密码学的应用范围非常广泛。每一样简单的社交活动里都有很大的学问。考虑这样一个问题，两个人想通过一部电话打牌，但他们都不信任对方。有没有可能仅通过一部电话实现扑克牌协议，并且保证游戏的公正性呢？<br>
    扑克牌的信息隐蔽性带来了很多与密码学协议相关的有趣问题。两个象棋大师可以在洗澡间一边冲澡一边大喊“炮八平五”、“马八进七”，一对围棋情侣可以在床上一边亲热一边呻吟“点三三”、“拆二”。等事情办完了，一盘精彩的棋局或许也就结束了。这些棋类游戏之所以可以“盲下”，就是因为在棋类游戏中，双方的局面信息都是完全公开的。不过，打牌就是另外一码事了。你说你出方片7，我怎么知道你有一个方片7？事先发牌？那谁来负责发牌呢？怎样发牌呢？难道我告诉你“发到你手中的是两张3一张5一张8一张9”？这样一看，两个人“盲打扑克牌”似乎是不可能的了，要么需要借助道具，要么需要第三者的帮助。不过，运用密码学知识，我们可以设计一套扑克牌协议，该协议能够实现随机的、隐蔽的、公平的发牌，并且不需要其它东西的帮助。我们以一手五张牌为例，说明如何实现“两人各摸五张牌”的程序。</p>
<p><span id="more-1407"></span><br>
    我们首先来看<a href="http://www.matrix67.com/blog/archives/501">这里面</a>的一个趣题。</p>
<blockquote><p>    10. A、B两人分别在两座岛上。B生病了，A有B所需要的药。C有一艘小船和一个可以上锁的箱子。C愿意在A和B之间运东西，但东西只能放在箱子里。只要箱子没被上锁，C都会偷走箱子里的东西，不管箱子里有什么。如果A和B各自有一把锁和只能开自己那把锁的钥匙，A应该如何把东西安全递交给B？<br>
    答案：A把药放进箱子，用自己的锁把箱子锁上。B拿到箱子后，再在箱子上加一把自己的锁。箱子运回A后，A取下自己的锁。箱子再运到B手中时，B取下自己的锁，获得药物。</p></blockquote>
<p>    我们的基本思路就是这样。不妨用数字1到54来表示54张牌。发牌前，A在每个数字前附着一个随机字符串前缀，然后给每个字符串都加上一把锁，把54张加密的扑克牌传给B。B收到了扑克牌一看，傻了，这些牌他一张也不认识，每张牌上面都有A的锁。B从里面挑选5张牌出来。他自己不知道这5张牌是什么，但是他也不能让A知道，于是他在这5张牌上再各加一把锁，传给A。A可以解开自己当初上的那把锁，但牌上还有一把锁，A拿它没办法，只能原封不动地传回去。B把剩下的锁解开，得到自己的5张牌。然后呢，B手上不是还剩了49张牌吗？B从中随便挑5张出来给A，由A解开上面的锁，得到A的5张牌。<br>
    听起来很完美，但实现起来并不简单。上锁开锁和加密解密并不完全相同：两把锁的地位是相同的，但两次加密则有先后的问题。要想把上述协议转换为密码学协议的话，我们需要采用这样一种加密方式：明文首先由A加密，B在这个密文的基础上再进行加密，此时A还能够把里面那一层密码解开，而保持B的那一层密码不动。如果用Ea(x)表示A的加密函数，用Da(x)表示A的解密函数的话，我们需要一种加密系统使得Db(Da(Eb(Ea(x))))=x。有这样的加密系统吗？有！模数相同的<a href="http://www.matrix67.com/blog/archives/1120">RSA算法</a>就满足这样的“交换律”。<br>
    RSA算法之所以起作用，原因就在于你能找到这么一对e和d，使得ed≡1 (mod φ(n))。假如存在两对钥匙(e1, d1)和(e2, d2)，容易想到(e1*e2)(d1*d2)=(e1*d1)(e2*d2)，它仍然同余于1。因此，计算密文c=m^(e1*e2)之后，再计算c^(d1*d2)一定能恢复明文m，不管你是先算c的d1次方还是d2次方。<br>
    有了RSA算法，我们的协议也就出来了。A、B两人各生成一对RSA公私匙（公钥不必也不能公开，我们这里只用到了RSA的可交换性，没用到RSA的加密钥匙可公开性）。A把54个加了随机字符串前缀的扑克牌分别用公钥加密并发给B，B从中选5张牌并再用自己的公钥加密，然后A用私钥解开B的这5张牌中里面一层的密码，B再用自己的私钥解密以得到自己的一手牌。同时，B在剩余的49张牌中挑选5张发给A，A用自己的私钥解密以获得自己的一手牌。这样下来，每个人都得到了自己的一手牌，而都不知道对方手里捏的是啥牌。以后如果还需要摸牌的话，则可以重复刚才的协议。游戏结束后，双方公开自己的钥匙，你可以验证看对方的钥匙与游戏中的数据是否吻合，以确定对方在游戏过程中没有作弊。这个协议可以轻易扩展到多个人的情况，也可以适用于更复杂的扑克牌游戏。</p>
			 ]]></content>
<pubDate>2009-02-20T14:20:08+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1407</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 平面上处处稠密但在平行于坐标轴的直线上无处稠密的点集 ]]></title>
<link>http://www.matrix67.com/blog/archives/1414</link>
<content><![CDATA[ 
		<p>    我一直很喜欢有各种惊异性质的奇怪函数，比如<a href="http://www.matrix67.com/blog/archives/137">阶梯状的连续函数</a>、<a href="http://www.matrix67.com/blog/archives/720">只在一点连续的函数</a>、<a href="http://www.matrix67.com/blog/archives/978">任意小的区间所对应的值域都是整个实数域的函数</a>等等。在这里面，最令人吃惊的是恐怕要数<a href="http://www.matrix67.com/blog/archives/448">在平面上处处稠密的单值函数</a>（其实前面那个函数显然也有这样的性质）。这样的函数打破了一维和二维之间的界线，启发人们重新思考稠密性的意义。不过，有人提到，这两个函数之所以在平面上稠密，是因为它们在平行于x轴的直线上都是稠密的。我们自然开始设想，有不有可能在平面上找到这样一个点集，它在平面上处处稠密，但在任意一条平行于坐标轴的直线上都无处稠密呢？<br>
    这是可以办到的。为了简便起见，我们只考虑平面区域[0,1]×[0,1]上的点集。让我们考虑由所有满足以下条件的点(x,y)所组成的点集：x和y都是有限小数，并且小数位数是相同的。例如，点(0.0516, 0.1025)就属于这个点集，但(0.23, 0.1001)就不属于这个点集，(1/3, π/6)就更不属于该点集了。显然，对于任何一个有限小数x’，直线x=x’上都只有有限多个点；类似地，对于任意一个有限小数y’，直线y=y’上都只有有限多个点。因此，该点集在所有平行于坐标轴的直线上都无处稠密。有趣的是，该点集在整个平面区域内却处处稠密。在任意小的区间x’-ε≤x≤x’+ε，y’-ε≤y≤y’+ε中，总存在一对小数位数相同的x和y。我们只需要写出一个比ε更小的有限小数λ，然后取(x’+λ, y’+λ)（只保留和λ相同的位数），则该点必然在前面所说的范围内。</p>
<p><span id="more-1414"></span><br>
    还有更牛B的。上面的构造中，直线上的点确实有限，但数量大得惊人。我们继续想象，有没有可能找出这样一个点集，在每个平行于坐标轴的直线上最多只存在一个点，但在整个平面区域上仍然处处稠密呢？这仍然是有可能的。考虑(0,1]×(0,1]上的所有有理点(x,y)（即x和y都是有理数），注意到可数个可数集仍然是可数的，因此我们可以把所有这些点排成一个序列(x1, y1), (x2, y2), ……。下面我们来构造点集S。首先把(x1, y1)放进S里面，然后把x1列为以后禁选的x坐标，把y1列为以后禁选的y坐标。然后把平面区域分成(0, 1/2]×(0, 1/2]、(0, 1/2]×(1/2, 1]、(1/2, 1]×(0, 1/2]、(1/2, 1]×(1/2, 1]四个小正方形。找出有理点序列中第一个还可以选的落在第一块正方形区域(0, 1/2]×(0, 1/2]内的点，比方说(x5, y5)，把它放进点集S，并标记以后x坐标不能再选x5，y坐标不能再选y5；接下来找出有理点序列中第一个落在第二块小正方形内的还能选的点，比方说(x4, y4)，然后把(x4, y4)放进点集S，并标记x4和y4以后禁选。继续找出序列中最早出现的落在第三个、第四个子正方形内的还能选的点并做类似的操作。这一步完成后，把平面区域分成4×4=16块相等的小正方形区域，并分别找出第一个落在每个小区域内、x不属于x坐标禁选列表、y不属于y坐标禁选列表的点，加进点集S并更新两个禁选列表。在第三阶段，把正方形划分为8×8=64个小正方形，并继续这样无限进行下去。这个操作的极限所得到的点集显然满足我们的条件：在平面区域内任意小的范围内均存在一点，但每条平行于坐标轴的直线上最多只有一点。</p>
			 ]]></content>
<pubDate>2009-02-23T14:16:55+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1414</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 学了拓扑学，我猛然领悟到了儿时游戏的真谛…… ]]></title>
<link>http://www.matrix67.com/blog/archives/1433</link>
<content><![CDATA[ 
		<p>小时候曾想，为什么一个人从屏幕左边跑出去，立即就从屏幕右端钻进来……<br>
现在我们知道了，因为游戏是在一个柱面上进行的……</p>
<p style="color:#E5E5E5">我有预感此日志又要火了</p>
<p><img alt="image placeholder" >
<p><span id="more-1433"></span><br>
<img alt="image placeholder" >
<p><img alt="image placeholder" >
<p><img alt="image placeholder" >
<p><img alt="image placeholder" >
<p><img alt="image placeholder" >
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-02-24T15:21:04+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1433</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：构造无穷长的字符串序列使每一项都不包含它前面的项 ]]></title>
<link>http://www.matrix67.com/blog/archives/1438</link>
<content><![CDATA[ 
		<p>    如果删除字符串A中的若干字母可以得到字符串B，我们就说A包含B（熟悉相关概念的网友可能知道，有一个准确的说法叫做“B是A的子序列”，但为了避免和后面的“序列”混淆，我们不用这种说法）。例如，字符串“matrix”包含了“mix”，也包含“ati”，但不包含“it”。字符串序列aaaaa, ab, bbaa, baaaa, aa, bbacc, cbcacc, bb中的每个字符串都不包含它前面的任何一个字符串，我们称这样的字符串序列为“非生成序列”（我自己取的名字，意思是说任一字符串都不能由前面的项通过添加字母生成出来）。我们可以构造出任意长的非生成序列，例如字符串长度严格递减的序列，或者所有不同的长度为n的字符串。现在的问题是，你能构造出一个无穷长的非生成序列吗？当然，你不能使用无穷多种字母来达到这一点。</p>
<p><span id="more-1438"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    你被骗了！事实上，虽然我们能构造出任意长的非生成序列，但我们永远不能构造出无穷长的非生成序列。我们有一个很简单的证明。<br>
    假设存在非生成序列，不妨找出所有非生成序列中最“小”的（位于前面的字符串尽可能短的）那一个。换句话说，在所有非生成序列中筛选出第一项最短的，再从中选择出那些第二项最短的，再在剩下的结果中选择序列第三项最短的……由此得到按各项字符串长度来看最靠前的那一个非生成序列。这个序列中有无数多个字符串，但所用到的字母却是有限的；考察所有字符串的首字母，必然有某一个字母出现了无穷多次。不妨设这个字母是“b”，且以b开头的字符串最早出现在第x项。把所有以字母b打头的字符串取出来形成一个临时序列（因此这个临时序列是一个无限长的、每个字符串都以b开头的序列）。删去临时序列中所有字符串的首字母。用这个临时序列替换掉原序列中第x项及其以后的部分。得到的新序列仍是一个无穷多项的非生成序列（倘若新序列中有字符串A可以生成字符串B，则B前面补回一个字母b，或者A和B前面都补上一个“b”，可知原序列中的A也能生成B），但按各项字符串长度来看，它的次序比原来更靠前，矛盾。</p>
<p><img alt="image placeholder" >
<p>    有觉得这个证明有些别扭吗？这是因为，这个证明用到了<a href="http://www.matrix67.com/blog/archives/444">选择公理</a>。</p>
			 ]]></content>
<pubDate>2009-02-26T11:46:51+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1438</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 用布制成的“山寨Klein瓶” ]]></title>
<link>http://www.matrix67.com/blog/archives/1452</link>
<content><![CDATA[ 
		<p> <img alt="image placeholder" >
<p>    <a href="http://en.wikipedia.org/wiki/Klein_bottle">Klein瓶</a>是拓扑学中最神奇的几何体之一，以至于谁家里要是有一个Klein瓶的话我愿意花500块钱把它买下来。不过呢，瞻仰不到Klein瓶也没关系，不要忘记Geek始终是一种富有创造力、喜欢自娱自乐的生物。做不出玻璃瓶子不要紧，做一个“山寨Klein瓶”可谓是出奇的简单。你只需要截取长袖T恤的两条袖子，在其中一个的表面上打一个洞，让另外一个袖子穿过去，然后把对应的口子缝起来即可。然后呢，以后无聊时你就又多了一件事情可以干了：把这个玩意儿拿出来，不停地、没完没了地把“里面”翻出来。</p>
<p><span id="more-1452"></span><br>
<img alt="image placeholder" >
<p> <br>
 <br>
当然，这样的“布制Klein瓶”是不能穿在身上的。做成围巾挂在脖子上还比较可行，不知道有没有人敢试一试。值得膜拜的是，已经有人把它做成帽子，开发出了可能是世界上首个可以穿戴的Klein瓶织物……</p>
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p>来源：<br>
<a href="http://www.evilmadscientist.com/article.php/kleinfabric">http://www.evilmadscientist.com/article.php/kleinfabric</a><br>
<a href="http://www.kleinbottle.com/klein_bottle_hats.htm">http://www.kleinbottle.com/klein_bottle_hats.htm</a></p>
			 ]]></content>
<pubDate>2009-02-27T01:10:07+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1452</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Cursor*10竟然出续集了！ ]]></title>
<link>http://www.matrix67.com/blog/archives/1460</link>
<content><![CDATA[ 
		<p><object width="550" height="400" data="http://www.matrix67.com/data/cursor2.swf" type="application/x-shockwave-flash"><param name="src" value="http://www.matrix67.com/data/cursor2.swf"></object></p>
<p>来源：<a href="http://www.nekogames.jp/mt/2009/02/cursor10_2s.html">http://www.nekogames.jp/mt/2009/02/cursor10_2s.html</a><br>
大家慢慢玩吧~</p>
			 ]]></content>
<pubDate>2009-02-28T12:33:12+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1460</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 随记：普遍性验证、数学思维、代数基本定理及其它 ]]></title>
<link>http://www.matrix67.com/blog/archives/1466</link>
<content><![CDATA[ 
		<p>    大学生活的乐趣不光体现在吃喝玩乐上，更重要的是它所提供的自由学习的场所。你可以在网上搜索课表，看看什么时候什么教室有什么牛B课，记在手机中的待办事项中，到时候到那个教室去旁听。旁听的乐趣就在于，你可以去学任何你想学的东西，不用交作业，不用怕点你名，不用记笔记，不用考试，只需要挂个耳朵在那儿听牛B东西就行了。前天一大早就被兔子叫起来，跟着一起去旁听了一节数理逻辑。<br>
    课程内容很简单，毕竟也才只讲了两周，一切都是很基础的。老师讲得很好，对联结词、命题公式、真值表等概念都说得很细致，即使完全没接触过这方面东西的人也能弄明白。作为信科的专业课，老师也简单提到了SAT问题：给定一串由AND, OR, NOT, 逻辑变量和括号组成的表达式，是否能给变量取值使得整个表达式为真？如果存在这样的“成真赋值”，我们就称表达式是一个“可满足式”。最简单的例子，p∧q就是可满足的，把p、q都取真即可；p∧(¬p)就不可满足，该式无论如何都为假。判断一个逻辑表达式是否可满足是一个经典的NPC问题，目前除了枚举之外还没有更好的算法。<br>
    还有一种逻辑表达式，不管初始值是什么，整个式子恒为真。例如，p∨(¬p)就是永真式。看起来，判定一个式子永真比判定一个式子可满足似乎要困难得多，因为前者比后者要强得多。而事实却是，这两个问题可以（在多项式的时间内）相互转化，它们在复杂程度上并无区别。如果你找到了一种可满足式判定算法，你便立即拥有了永真式判定算法。换句话说，你的算法若能找出一个成真赋值，你就能利用该算法立即得出该式所有赋值结果是否都为真。这个问题的问法很有艺术性，它有意屏蔽掉了永假式判定这一桥梁。事实上，一个表达式要么可满足要么永假，而从永假到永真只有一步之遥——只需要在最前面加一个“非”即可。也就是说，如果有一个程序，它能告诉我逻辑表达式A是否可满足，那么我就把¬A输进去：如果它说¬A不可满足，意即¬A的任何赋值结果均为假，反过来A就是永真的；如果它说¬A可以满足，意即程序找到了¬A的一个成真赋值，反过来便成为了A永真的一个反例。</p>
<p><span id="more-1466"></span><br>
    这个例子极具启发性。这不是一个题目，而是一种思想。我一年半的大学学习中遇到的最好的老师是大一上的高数老师雷功炎教授。他的作业有一个特点：你可以不断使用你已经得到的结论去解决新的问题，新问题的解决又给后面的题目打通了捷径。在完成作业的过程中保持这样的思想，所有的题目都可以顺水推舟，一气呵成。他在课堂上反复强调，这种事半功倍的偷懒办法正是数学最吸引人的地方。<br>
    这种思想是所有数学家和数学爱好者引以为傲的思想！以至于任何一个喜欢数学的人看完下面这段文字都会哈哈大笑：</p>
<blockquote><p>    一天，数学家觉得自己已受够了数学，于是他跑到消防队去宣布他想当消防员。消防队长说：“您看上去不错，可是我得先给您一个测试。” 消防队长带数学家到消防队后院小巷，巷子里有一个货栈，一只消防栓和一卷软管。消防队长问：“假设货栈起火，您怎么办？”数学家回答：“我把消防栓接到软管上，打开水龙，把火浇灭。” 消防队长说：“完全正确！最后一个问题：假设您走进小巷，而货栈没有起火，您怎么办？”数学家疑惑地思索了半天，终于答道：“我就把货栈点着。” 消防队长大叫起来：“什么？太可怕了！您为什么要把货栈点着？” 数学家回答：“这样我就把问题化简为一个我已经解决过的问题了。”</p></blockquote>
<p> <br>
    “利用已有结果”的意义是广泛的。将已证结论作为引理来搭建数学大厦是其中一方面，这里我们还看到了另外一方面：结论适用范围的扩展。在面对一些具体的新问题时，把问题的形式稍作变换，我们便可以直接套用老问题的解法，从而扩大了已有解法的适用范围。特别地，对于一个判定性问题来说，如果有一个很强大操作因子能够让每一种可能的结果取反，那么存在性验证就可以直接转化为普遍性验证。类似的例子还有很多。下课之后我便开始思考，马上就想到一个：图中从点A到点B的路径长的奇偶性。如果我有算法能判断从A到B是否存在长度为奇数的路径，那么我就能直接套用该算法验证该图中从A到B的所有路径是否都是奇数步。方法和上面的一样：在点A前面加一个超级源点A’，让A’和A相连。于是，每一条从A到B的路径都对应了一条从A’到B的路径，其中后者恰好比前者多一步。询问程序A’和B之间是否存在奇数步的路径，如果存在，表明从A到B有长为偶数的路径，否则便可说明从A到B的所有路径长度都为奇数。另一个有趣的例子是，假如我能判断一个含变量的代数式等于0是否有解，我就能判断该式子是否恒等于0。这又是怎么做的呢？不妨把原来的式子记作E，构造一个新的式子E/E – 1。那么，新的式子等于0当且仅当原式E不等于0。接下来的事情就又和刚才一样了。</p>
<p>    记得有一年我搞了一次NOIp普及组的模拟赛，里面有一道题是这样的：给你一个带实数边权的无向图，所有权值都大于1，然后叫你求一条从A到B的权值乘积最小的路径。只要了解Dijkstra算法原理的人都能想明白，该算法同样适用于权值乘积最小问题。但不出我所料，还是有很多人问我，为什么Dijkstra算法在这里仍然可以用？我的回答很简单。你根本不需要明白Dijkstra算法的原理你也能想到，这道题目依然可以用Dijkstra算法。只需要把所有权值全部取对数，权值乘积的问题立即转变为了权值和的问题；求出了最短路之后，再把所得结果当作指数还原回去即可。</p>
<p> <br>
 <br>
    这学期我还选了一门叫做“古今数学思想”的通选课，那天下午是整个学期的第二节课。超越“数学问题”，站在“数学思想”的高度上，你会有一种全新的体验。在随后的两个小时中，这一点得到了完美的印证。印象最深的是课件上的一句话，短短几个字一针见血地点破了Taylor展开的真谛，让我顿时领悟到Taylor展开的真正价值，我一瞬间觉得当时学高数简直是白学了。课件上说，Taylor公式把函数展开为级数，其伟大意义就是“把不可数个数据简化为了可数个数据”。原本是一个连续统上的函数，上面记录了不可数个点的位置信息；用Taylor公式一变，只需要可数个系数就把所有东西都描述了出来，并且可以在一个宏观的角度上取得近似。牛！学了那么久的高数都没体会到这句话，做了那么多Taylor展开的题目真是全白做了！</p>
<p> <br>
    前天最牛B的收获是这门课上，老师讲到的代数基本定理的拓扑学证明。代数基本定理告诉我们，每个（次数不少于1的）复系数多项式在复数域中至少有一根。按照老师的原话，用拓扑学证明代数基本定理简单得令人难以置信。老师讲得飞快，课堂上我的确没怎么听明白，但恍惚记得《什么是数学》后面的章节里有这个东西。回去一翻，果然是一个精采绝伦的证明，命题本身的重要意义和证明过程之简洁造成了一种出人意料的华丽的不对称效果。随便写一个函数，比如</p>
<p>f(z) = (2+11i)z^4 + (7+3i)z^3 + (12-7i)z^2 + (-8+3i)z + (-2-i)</p>
<p>    想想看，对于某个r，如果我们取遍所有满足|z|=r的点，对应的f(z)将画出一个什么样的轨迹？z点的轨迹说穿了就是从某个离原点距离为r的位置上出发，绕原点一周后又回到原来的位置；由于函数f显然是一个连续函数，因此f(z)描绘的轨迹显然也应该是从某一点开始连续地运动，最后返回原位，形成一个封闭的曲线。r的大小决定了封闭曲线f(z)的大小。当|z|=0时，f(z)也就是一个点，若函数有常数项的话这个点应该异于原点；当|z|充分大时，最高次项将远远超过其它项，因此封闭曲线可以近似认为是z^n，它是一个绕原点走了n圈的圆（因为此时z^n = r^n * (cos(nθ)+i*sin(nθ)) ）。</p>
<p><img alt="image placeholder" >
<p>    对于一些不大不小的r，情况将介于两种极端情形之间。例如，当|z|=1时，f(z)形成了一个绕原点两圈的封闭曲线（如图蓝色曲线所示，紫色圆圈则是所有的z点）。可见，随着r的扩大，f(z)从一条内部不含原点的封闭曲线变成了一条绕原点整整n圈的曲线。但是，f(z)是一个连续函数，当r值增大时曲线也应该是连续变化，绕原点的圈数怎么会变呢？这只有一种可能：曲线在连续运动的过程中经过了原点。嘿！这就是我们要证明的结论啦！</p>
<p><img alt="image placeholder" >
<p>    似乎是对数学证明有一种通感。一想到f(z)一脸无奈地耸耸肩说“没法子了，只能过原点了”时，我就会大笑起来。“滑稽的证明”、、“让人会心一笑的证明”、“简单得富有喜剧效果的证明”可能是我对证明的最高评价了。能获得这个评价的证明不多，我目前一下子能想到的如此精彩的证明只有下面这两个：</p>
<p><a href="http://www.matrix67.com/blog/archives/33">http://www.matrix67.com/blog/archives/33</a><br>
<a href="http://www.matrix67.com/blog/archives/1006">http://www.matrix67.com/blog/archives/1006</a></p>
			 ]]></content>
<pubDate>2009-02-28T14:24:38+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1466</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 再谈稠密性：令人吃惊的稠密集及其交集 ]]></title>
<link>http://www.matrix67.com/blog/archives/1480</link>
<content><![CDATA[ 
		<p>    对于数轴上的一个点集，如果说在集合中任意两点之间都能够找到该集合中的另一个点，我们就说该点集处处稠密。例如，全体有理数集合就是稠密的，任意接近的两个有理数之间都存在其它的有理数（比如它们的算术平均值）。这样看来，两个处处稠密的点集似乎是不能共存的，但实际情况并非如此。我们将会看到越来越牛B的例子，它们将让我们对稠密性有一个全新的认识。</p>
<p>    1. 在数轴上找出两个处处稠密的点集，它们互不相交。<br>
<span style="color:#E5E5E5;">    很简单。全体有理数和全体无理数就是满足条件的两个集合。</span></p>
<p> <br>
    2. 在数轴上找出两个处处稠密的不可数点集，它们互不相交。<br>
<span style="color:#E5E5E5;">    很狡猾。集合A取全体正有理数和全体负无理数的并集，集合B取全体正无理数和全体负有理数的并集，这两个集合即可满足条件。</span></p>
<p> <br>
    3. 在数轴上找出无穷多个处处稠密的点集，它们两两不相交。<br>
<span style="color:#E5E5E5;">    令P_i表示第i个素数。则集合S_i := { √<span style="text-decoration:overline;">P_i</span> + r| r为有理数 }满足条件。为了证明它们两两不相交，假设r_1 + √<span style="text-decoration:overline;">P_m</span> = r_2 + √<span style="text-decoration:overline;">P_n</span>，于是(r_1 – r_2)^2 = (√<span style="text-decoration:overline;">P_n</span> – √<span style="text-decoration:overline;">P_m</span>)^2，可得√<span style="text-decoration:overline;">P_m * P_n</span> = ( P_m + P_n – ((r_1 – r_2)^2) )/2。两个素数的乘积的平方根是一个有理数，这显然是荒谬的（很多证明根号2是无理数的方法都可以证实这一点，例如这里的证法http://www.matrix67.com/blog/archives/206）。</span></p>
<p><span id="more-1480"></span><br>
 <br>
    4. 在数轴上找出无穷多个处处稠密的不可数点集，它们两两不相交。（原答案有误，已更新）<br>
<span style="color:#E5E5E5;">    <s>把上例中的集合S_i并上实数区间(i-1, i)即可，换句话说S_1∪(0,1), S_2∪(1,2), S_3∪(2,3), …即满足条件。</s>谢谢网友永远的魔灵提醒。我写错了。我们把上例中的集合S_i并上实数区间(i-1,i)挖掉所有形如√p + r的数后剩余的部分，换句话说令E=R∪S_i，则S_1∪(E∩(0,1)), S_2∪(E∩(1,2)), S_3∪(E∩(2,3)), …即满足条件。为什么这些集合都是不可数的呢？这是因为，∪S_i是可数的（可数个可数集仍然可数），因此R∪S_i就是不可数的，它的每一个子区间也是不可数的。</span></p>
<p> <br>
    现在呢，两两不相交的稠密集已经不牛B了。让我们再看另一个极端：随便多少个集合交起来仍然处处稠密。</p>
<p> <br>
    5. 在数轴上找出无穷多个两两相异的处处稠密的点集，其中任意多个集合的交仍然处处稠密。<br>
<span style="color:#E5E5E5;">    很简单。集合T_i = R{i}即满足要求。它们的交集相当于在实数集中挖去正整数点，这不影响其稠密性。</span></p>
<p> <br>
    6. 在数轴上找出无穷多个处处稠密的点集，其中任意多个集合的交仍然处处稠密，但所有集合的交集为空。<br>
<span style="color:#E5E5E5;">    由于有理数集是可数的，把全体有理数排成一个序列r_1, r_2, r_3, …。记实数集为Q，则T_i = Q{r_i}满足条件。换句话说，想象有无穷多个有理数集排成一列，然后在第i个集合中挖去第i个有理数。这样，任意多个集合的交集就相当于在稠密集中挖掉有限个元素，它仍然是处处稠密的；但全体集合的交集显然为空，因为对于每一个有理数，都有一个不包含它的集合。</span></p>
<p> <br>
    7. 在数轴上找出无穷多个处处稠密的点集形成的序列，每一个集合都是前一个集合的真子集，并且所有集合都是处处稠密的，但它们的交集为空。<br>
<span style="color:#E5E5E5;">    这个就更加不可思议了……无穷多个越来越小的集合，还能保证每一个集合都是稠密的。虽然这个例子要比前面那一个强得多，但原理和前面的基本上一样。还是把全体有理数排成一个序列r_1, r_2, r_3, …，然后令T_i = Q{r_1, r_2, …, r_i}，即T_1 = {r_2, r_3, r_4, …}, T_2 = {r_3, r_4, r_5, …}, T_3 = {r_4, r_5, …}, ……。和上面的讨论类似，所有集合都是处处稠密的，任意多个集合的交集也是处处稠密的，但所有集合的交集为空。</span></p>
			 ]]></content>
<pubDate>2009-03-03T13:16:16+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1480</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：扫雷定理 互补棋盘上的数字和相等 ]]></title>
<link>http://www.matrix67.com/blog/archives/1493</link>
<content><![CDATA[ 
		<p>    这是一个与扫雷游戏有关的非常好玩的问题。给定一个扫雷布局，定义它的“补集棋盘”为这样一个新布局，原来有雷的地方现在是空地，原来没有雷的地方现在都是雷。在棋盘的每块空地上都标有一个数字，它表示周围的8个方块中有多少颗雷。一个美妙的结论是，两个互补棋盘布局上的数字和是相等的。乍看之下似乎不可思议，但仔细一想便豁然开朗。你能想到这是为什么吗？</p>
<p>  <img alt="image placeholder" >
<p><span id="more-1493"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>  <img alt="image placeholder" >
<p>    对于棋盘上的每个空地，在它和它周围的每个雷之间连接一条短线。显然线条的总数目就是棋盘上的数字和。在互补棋盘中，原来的线条现在仍然存在（线条两端原先是一雷一空地，现在仍然是一雷一空地），原来没有线条的地方现在仍然没有（两个邻格或者都有雷或者都是空地，则互补棋盘中依旧如此）。因此，互补棋盘中的线条和原来一模一样，线条总数不变，也即数字和不变。</p>
<p>来源：<a href="http://www.cut-the-knot.org/arithmetic/combinatorics/Minesweeper.shtml">http://www.cut-the-knot.org/arithmetic/combinatorics/Minesweeper.shtml</a></p>
			 ]]></content>
<pubDate>2009-03-04T14:54:37+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1493</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 史上最牛诗歌：一个停机问题不可判定的证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/1497</link>
<content><![CDATA[ 
		<div style="text-align:center;">
<p style="font-size:42px;margin-top:30px;">SCOOPING THE LOOP SNOOPER</p>
<p style="font-size:24px;margin-top:24px;">A proof that the Halting Problem is undecidable</p>
<p><b>Geoffrey K. Pullum</b><br>
(<i>School of Philosophy, Psychology and Language Sciences, University of Edinburgh</i>)
</p>
</div>
<p> </p>
<div style="text-align:center;">
<i>No general procedure for bug checks succeeds.</i><br>
Now, I won’t just assert that, I’ll show where it leads:<br>
I will prove that although you might work till you drop,<br>
you cannot tell if computation will stop.<br>
 <br>
For imagine we have a procedure called <i>P</i><br>
that for specified input permits you to see<br>
whether specified source code, with all of its faults,<br>
defines a routine that eventually halts.</div>
<p><span id="more-1497"></span></p>
<div style="text-align:center;">
You feed in your program, with suitable data,<br>
and <i>P</i> gets to work, and a little while later<br>
(in finite compute time) correctly infers<br>
whether infinite looping behavior occurs.<br>
 <br>
If there will be no looping, then <i>P</i> prints out `Good.’<br>
That means work on this input will halt, as it should.<br>
But if it detects an unstoppable loop,<br>
then <i>P</i> reports `Bad!’ — which means you’re in the soup.<br>
 <br>
Well, the truth is that <i>P</i> cannot possibly be,<br>
because if you wrote it and gave it to me,<br>
I could use it to set up a logical bind<br>
that would shatter your reason and scramble your mind.<br>
 <br>
Here’s the trick that I’ll use — and it’s simple to do.<br>
I’ll define a procedure, which I will call <i>Q</i>,<br>
that will use <i>P</i>‘s predictions of halting success<br>
to stir up a terrible logical mess.<br>
 <br>
For a specified program, say <i>A</i>, one supplies,<br>
the first step of this program called <i>Q</i> I devise<br>
is to find out from <i>P</i> what’s the right thing to say<br>
of the looping behavior of <i>A</i> run on <i>A</i>.<br>
 <br>
If <i>P</i>‘s answer is `Bad!’, <i>Q</i> will suddenly stop.<br>
But otherwise, <i>Q</i> will go back to the top,<br>
and start off again, looping endlessly back,<br>
till the universe dies and turns frozen and black.<br>
 <br>
And this program called <i>Q</i> wouldn’t stay on the shelf;<br>
I would ask it to forecast its run on <i>itself</i>.<br>
When it reads its own source code, just what will it do?<br>
What’s the looping behavior of <i>Q</i> run on <i>Q</i>?<br>
 <br>
If <i>P</i> warns of infinite loops, <i>Q</i> will quit;<br>
yet <i>P</i> is supposed to speak truly of it!<br>
And if <i>Q</i>‘s going to quit, then <i>P</i> should say `Good’<br>
— which makes <i>Q</i> start to loop!  (<i>P</i> denied that it would.)<br>
 <br>
No matter how <i>P</i> might perform, <i>Q</i> will scoop it:<br>
<i>Q</i> uses <i>P</i>‘s output to make <i>P</i> look stupid.<br>
Whatever <i>P</i> says, it cannot predict <i>Q</i>:<br>
<i>P</i> is right when it’s wrong, and is false when it’s true!<br>
 <br>
I’ve created a paradox, neat as can be —<br>
and simply by using your putative <i>P</i>.<br>
When you posited <i>P</i> you stepped into a snare;<br>
Your assumption has led you right into my lair.<br>
 <br>
So where can this argument possibly go?<br>
I don’t have to tell you; I’m sure you must know.<br>
By <i>reductio</i>, there cannot possibly be<br>
a procedure that acts like the mythical <i>P</i>.<br>
 <br>
You can never find general mechanical means<br>
for predicting the acts of computing machines.<br>
It’s something that cannot be done.  So we users<br>
must find our own bugs.  Our computers are losers!
</div>
<p> <br>
来源：<a href="http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html">http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html</a></p>
			 ]]></content>
<pubDate>2009-03-05T11:44:36+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1497</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：理想模型下的排序算法（下） ]]></title>
<link>http://www.matrix67.com/blog/archives/1523</link>
<content><![CDATA[ 
		<p>    <a href="http://www.matrix67.com/blog/archives/1209">上次</a>我们谈到，我们考虑时间复杂度时往往假设任意大的整数运算（赋值、四则运算、取余运算、比较运算、位运算包括左移右移）都可以在常数时间内完成，殊不知这留下了一个非常具有研究价值的漏洞：能否利用计算机理想模型中的整数运算，把问题打包成超大整数后并行计算，从而办到一些在普通计算机上无法办到的事情？我们在上一次的文章中介绍了利用“大整数随便算”的漏洞“耍赖”得到了一个线性时间的排序算法。这个漏洞真的已经被充分利用了吗？我们还能从里面榨出多少汁水来？令人无法想象的是，线性时间的排序算法远远没有挖掘到理想大整数运算的巨大潜力，事实上我们能做到常数时间的排序！问题和解答仍然来自<a href="http://www.brand.site.co.il/riddles/200901a.html">Using your Head is Permitted</a>，在这里向Michael Brand表示深深的膜拜。<br>
    自然，说“常数时间排序”是有前提条件的，否则即使读入输出也得耗费线性的时间。不过，我们可以假设所有待排序的数都已经打包进一个大整数里，输出时也无需解包，直接返回另一个大整数即可。在这样的情况下，我们完全可以用常数时间完成排序。换句话说，我可以用O(1)的时间，“一下子”就把0100 0111 0001 0010变成0001 0010 0100 0111，不管这个大整数里面装了多少个数。为了方便大家阅读和思考，我们再取一些名字，方便描述。我们把由多个数构成的大整数叫做“整数串”。整数串中所含的数都是二进制，它们用空格隔开。整数串中每个数的位数都必须相等，位数不够用零补足。我们把这个位数叫做“定宽”，本文例子的定宽都是4。</p>
<p><span id="more-1523"></span><br>
    为了能够实现常数时间的排序，我们首先应该想想，怎样才能“一下子”比较出所有数两两之间的大小。想到我们的整数串可以要有多大就有多大，我们萌生了一个大胆的想法：把本来就装了n个数的整数串继续扩展，让每个整数串里面都扩展到n^2个数，为n^2对数的比较做好准备。我们希望有一个操作能够让0100 0111 0001 0010变成下面两个更大的整数串；</p>
<p>0100 0111 0001 0010 0100 0111 0001 0010 0100 0111 0001 0010 0100 0111 0001 0010    …. (大整数串A)<br>
0100 0100 0100 0100 0111 0111 0111 0111 0001 0001 0001 0001 0010 0010 0010 0010    …. (大整数串B)</p>
<p>    这为以后并行比较n^2个数对创造了条件。大整数串A很好构造，让0100 0111 0001 0010乘以</p>
<p>0000 0000 0000 0001 0000 0000 0000 0001 0000 0000 0000 0001 0000 0000 0000 0001    …. (基本掩码)</p>
<p>    即可。上面这个数又是怎么在常数时间内生成的呢？很简单，只需要用64个1除以16个1即可，正如十进制中999999/99 = 010101一样。而连续的1又可以通过左移后减一得到，因此整个数可以在常数时间内算出。我们把这样的串叫做“基本掩码”，以后将多次用到。<br>
    难就难在大整数串B。大整数串B又可以看作是</p>
<p>0000 0000 0000 0100 0000 0000 0000 0111 0000 0000 0000 0001 0000 0000 0000 0010    …. (1)</p>
<p>    乘以0001 0001 0001 0001得到的结果。后面这个0001 0001 0001 0001的生成办法和前面一样，关键是前面这个等价于“加大定宽”的操作(1)该怎么做。我当初思考这个问题时就卡在这一步了。Michael Brand就是牛，他想到了这关键性的一步：要是“定宽”再大一点就好了。如果需要生成的大整数串是</p>
<p>0000 0000 0000 0000 0100 0000 0000 0000 0000 0111 0000 0000 0000 0000 0001 0000 0000 0000 0000 0010    …. (2)</p>
<p>    的话就好办了，只需要把大整数串A</p>
<p>0000 0000 0000 0000 0100 0111 0001 0010 0100 0111 0001 0010 0100 0111 0001 0010 0100 0111 0001 0010</p>
<p>    与</p>
<p>0000 0000 0000 0000 1111 0000 0000 0000 0000 1111 0000 0000 0000 0000 1111 0000 0000 0000 0000 1111    …. (3)</p>
<p>    进行and运算即可。上面的序列(3)可由基本掩码乘以1111获得。我们甚至可以实现“缩小定宽”的操作，只要新定宽和原定宽相差足够多（具体的说，新定宽×数的个数≤原定宽）。把(2)式对1111 1111 1111 1111取模，我们就可以重新得到0100 0111 0001 0010（这个取余操作相当于把原来的64位数截成4个16位数后求和，正如十进制中23000067 mod 9999 = 2367 = 2300 + 0067一样）。<br>
    有了“定宽扩展到充分大”和“定宽缩小到充分小”的操作，我们立即得到了大整数B的常数时间生成方法：先把原始整数串0100 0111 0001 0010的定宽加到足够大，然后再缩小到原定宽的n倍（例子中为4×4=16）。这两个操作都是常数级别的，因此总的操作也是常数级别的。乘以0001 0001 0001 0001后，我们就得到了大整数串B。</p>
<p>    接下来，我们着手构造比较函数。我们希望能够同时比较两个整数串对应的16个数，并且返回新的大整数串来表明每一对数中哪个大哪个小。我们比较时采用的基本方法就是，如果a比b小，那么~a+b一定会越界。考虑一个中间情况就是，如果a=b话，~a+b正好就等于111…11，是该定宽下所能表示的最大数。如果a的值减小一些，~a的值就会增大一些，~a+b就溢出了；反之，如果a的值变大一些，~a的值反而会减小，~a+b就应该小于该定宽下的最大数。熟悉补码的朋友可能想到，这是受到了计算机做减法的办法的启发。为了能够让大整数串顺利接受溢出并返回结果，在最初取定宽时应该让定宽大小比最大数位数还多一位（相当于符号位）。即使当初没想到这一点，把整数串排的紧紧的，现在后悔也来得及——我们已经有了常数时间修改定宽的办法。整个大整数串取反后，我们用一个and运算把多出来的符号位归零。相加后再用and运算把符号位提取出来，通过右移获得比较结果。</p>
<p>0100 0111 0001 0010 0100 0111 0001 0010 0100 0111 0001 0010 0100 0111 0001 0010    …. (大整数串A)<br>
0100 0100 0100 0100 0111 0111 0111 0111 0001 0001 0001 0001 0010 0010 0010 0010    …. (大整数串B)<br>
1011 1011 1011 1011 1000 1000 1000 1000 1110 1110 1110 1110 1101 1101 1101 1101    …. (大整数串B取反)<br>
0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111    …. (掩码，可在常数时间里生成)<br>
0011 0011 0011 0011 0000 0000 0000 0000 0110 0110 0110 0110 0101 0101 0101 0101    …. (上面两序列and后的结果)<br>
0111 1010 0100 0101 0100 0111 0001 0010 1010 1101 0111 1000 1001 1100 0110 0111    …. (大整数串A与上一序列相加)<br>
1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000    …. (掩码，可在常数时间里生成)<br>
0000 1000 0000 0000 0000 0000 0000 0000 1000 1000 0000 1000 1000 1000 0000 0000    …. (上面两序列and后的结果)<br>
0000 0001 0000 0000 0000 0000 0000 0000 0001 0001 0000 0001 0001 0001 0000 0000    …. (上一序列右移3位)</p>
<p>    最后这个整数串中只有0和1两个数，1表示对应位置上B串的数比A串的小，0的意义则正好相反。如果最初读入的n个数没有重复的话，这里面应该恰好有n(n-1)/2个数字1（本例中则是6个）。<br>
    到这里，我们已经看到胜利的希望了。如果您真能一个字一个字的读到这里来，我向您表示深深的崇敬和膜拜。剩下的事情已经不多了，主要是统计和还原两个操作。<br>
    我们得到了一个表示出16个大小关系的整数串，现在我们想把它们合并回去，算出对于每一个给定的数，有多少个数比它小。换句话说，我们希望将比较结果中的每第四个数加起来，得到0010 0011 0000 0001，其中0010就是0000、0000、0001、0001四个数相加的结果，它表示输入数据中有两个数比输入的第一个数0100小，类似地其余的数也是由对应的四个值相加得到。实现这一点并不困难，只需要让比较结果对1111 1111 1111 1111取模即可，其原理与前面的缩小定宽操作是相同的。我们把这个序列叫做索引序列。<br>
    最后一个步骤便是按照索引0010 0011 0000 0001将0100 0111 0001 0010重新排列，使得Input[i] = Result[Index[i]]。这一步又是一大难关，我想即使我当初想到了改变定宽的方法，最终也会卡在这最后一步。为了实现顺序排列，我们需要强行建立一个有序索引。我们希望在常数时间内得到“计数序列”0000 0001 0010 0011，它将用于进一步的操作。计数序列的生成并不难，要想生成一个有n项的定宽为w的计数序列，我们仅仅需要找出一个等价于</p>
<p>0·2^(w(n-1)) + 1·2^(w(n-2)) + 2·2^(w(n-3)) + … + (n-1)·2^0</p>
<p>    的公式来就行了。我们不用把时间浪费在寻找公式上，用Mathematica就可以得到我们想要的结果。从下图中可以看到一个好消息：公式是O(1)的，其复杂度不随变量增大而增大，并且所有计算都可以在O(1)的时间内完成。稍作验证可知，这个公式是正确的。</p>
<p>  <img alt="image placeholder" >
<p>    接下来我们要做的是，将索引序列与计数序列进行比较，比较的方法将再次套用上述从生成大整数串到并行比较n^2个数对的所有步骤。</p>
<p>0000 0000 0000 0000 0001 0001 0001 0001 0010 0010 0010 0010 0011 0011 0011 0011  …. (扩展的计数序列)<br>
0010 0011 0000 0001 0010 0011 0000 0001 0010 0011 0000 0001 0010 0011 0000 0001  …. (扩展的索引序列)</p>
<p>0001 0001 0000 0001 0001 0001 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000  …. (对应位置上计数序列较小)<br>
0000 0000 0000 0000 0000 0000 0001 0000 0000 0000 0001 0001 0001 0000 0001 0001  …. (对应位置上索引序列较小)</p>
<p>    同样地，上面两个比较结果中数字1各有6个，一共12个。另外还有4个位置，你也不比我小，我也不比你小，两次比较的结果都是“0”。显然，这4个位置所对应的数从左至右分别是前4个自然数。用or运算和xor运算提取出这四个位置，然后与最初的大整数串B进行and运算：</p>
<p>0001 0001 0000 0001 0001 0001 0001 0000 0000 0001 0001 0001 0001 0000 0001 0001  …. (上述两比较结果的or运算)<br>
0000 0000 0001 0000 0000 0000 0000 0001 0001 0000 0000 0000 0000 0001 0000 0000  …. (上一序列与基本掩码进行异或)<br>
0000 0000 1111 0000 0000 0000 0000 1111 1111 0000 0000 0000 0000 1111 0000 0000  …. (上一序列乘以1111)<br>
0100 0100 0100 0100 0111 0111 0111 0111 0001 0001 0001 0001 0010 0010 0010 0010  …. (大整数串B)<br>
0000 0000 0100 0000 0000 0000 0000 0111 0001 0000 0000 0000 0000 0010 0000 0000  …. (上面两个序列and后的结果)</p>
<p>    最后这个序列满足这样的性质：数的出现顺序和输入数据相同，并且当你把它从左至右划分为n个n元组之后，输入数据中第i小的数恰好在它所在的n元组中的第i个位置。和上面一样，我们需要把每第四个元素合并在一起。将最后这个结果模1111 1111 1111 1111后，即得到0001 0010 0100 0111。这样，我们就在常数时间里完成了n个数的排序。</p>
<p>    嗯，你真强大，竟然一路看到这里来了。不知道大伙儿看明白没，麻烦大家在下面留句话。或许大家会想，O(1)的排序算法……总算不能再牛B了吧？呵呵，你又错了，我们现在所看到的仍然太表层，真正牛B的还远没有挖掘出来呢！接下来，我们还会利用大整数的理想运算做一些更加牛B的事情。</p>
			 ]]></content>
<pubDate>2009-03-06T17:31:47+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1523</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 数学小游戏：原创字谜几则 ]]></title>
<link>http://www.matrix67.com/blog/archives/1541</link>
<content><![CDATA[ 
		<p>昨天晚上躺在床上发呆，想了几则数学字谜。下面每个式子都对应一个英文单词，例如<img alt="image placeholder" >
你能猜出多少个来呢？</p>
<p>1. <img alt="image placeholder" >
<p>2. <img alt="image placeholder" >
<p>3. <img alt="image placeholder" >
<p>4. <img alt="image placeholder" >
<p>5. <img alt="image placeholder" >
<p><span id="more-1541"></span><br>
6. <img alt="image placeholder" >
<p>7. <img alt="image placeholder" >
<p>8. <img alt="image placeholder" >
<p>9. <img alt="image placeholder" >
<p>10. <img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-03-08T22:07:38+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1541</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 实分析中的反例（上） ]]></title>
<link>http://www.matrix67.com/blog/archives/1547</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>    我对各种违背直觉的函数构造特别有兴趣，看看<a href="http://www.matrix67.com/blog/archives/tag/%E6%83%8A%E5%A5%87%E6%95%B0%E5%AD%A6%E4%BA%8B%E5%AE%9E%20%E5%87%BD%E6%95%B0">这里</a>你就知道我对这些特殊函数有多痴迷了。因此，当我发现竟然有专门收集各种特殊函数的数学书时，可以想象我的心情有多激动。我试着以“反例”为关键字在图书馆进行检索，借了一大堆实分析数学书。这些书都已经很老了，封皮烂了又烂，已经修修补补重装了两三次封皮。翻翻这些老书，不由得对老一辈的学者和作家表示由衷的崇敬；虽然文字、排版都不出彩，但书的容量极大，内容也很实在。<br>
    废话不多说了，让我们来欣赏一下书里的一些精彩篇章吧。</p>
<p><span id="more-1547"></span><br>
<strong>实数域上一个单调递增的有界可微函数f，但lim(x→±∞)f ‘(x)≠0</strong></p>
<p>    直觉上，一个单调递增的有界函数走到无穷远的地方一定是“平”的，而事实上却并非如此。我们能构造这样一个函数，它是R上的递增有界函数，但无穷远处的导数并不等于0。<br>
    对所有非负整数n，定义f(n)=1 – 1/2^n。接下来，用下面的方式把函数扩张到全体非负实数：对区间(n, n+1)，用一条光滑的、递增的、导数由0变成1再变成0的函数来连接f(n)和f(n+1)（例如正弦函数的一个完整递增区间缩小至原大小的1/2^(n+2)再加上两根分别等于f(n)和f(n+1)的常函数）。</p>
<p><img alt="image placeholder" >
<p>    再令f(-x)=-f(x)。则这个函数是R上的一个单调递增的有界函数，但导数的极限显然不为0。事实上，这个函数的导数在无穷远处根本就没有极限，因为不管走到多远导数总能取满从0到1的所有值。<br>
    如果把问题的条件改为“严格递增”呢？对于严格递增的有界函数，无穷远处的导数也不见得为0，构造一个反例很简单，只需要在刚才那个函数上面加上一个严格单增的有界函数即可，如令g(x)=f(x)+1-1/2^n。显然，g(x)仍然单调有界，且g'(x)=f'(x) + ln(2)/2^n，其极限仍然不为0。</p>
<p> <br>
<strong>函数f在x0的任意小的邻域内都无界，但x→x0时f(x)并不趋于无穷大</strong></p>
<p>    f(x)=|cos(1/x) / x|满足要求。无论对于多大的正数N，总存在一个充分接近0的点使得f(x)&gt;N。例如，取x=1/(nπ)，则f(x)=|1/x|=nπ，上述结论显然。</p>
<p><img alt="image placeholder" >
<p>    有趣的是，如果取x=1/((n+1/2) π)，则当n→∞时x→0，且f(x)→0。这说明，x趋于0时f(x)并不趋于无穷大。</p>
<p> <br>
<strong>f(x)→∞，不见得有f ‘(x)→∞</strong></p>
<p>    与上例比较类似。考虑(0,1)上的函数f(x)=1/x + cos(1/x)，显然lim(x→0+) f(x)=+∞ 。但f ‘(x)=(sin(1/x)-1)/x^2，若令x=1/(2n+1/2)π，当n→∞时f ‘(x)=0，这说明f ‘(x)→∞是不成立的。</p>
<p> <br>
<strong>处处有限而又处处局部无界的函数</strong></p>
<p>    定义函数f(x)=0 (当x为无理数)， f(x)=n (当x为有理数且可表示为既约分数m/n)。这个函数在每一点上都有意义，每一个f(x)都是有限的；但在任意小的区间内，你能找到分母任意大的既约分数，因此函数在任意小的一个区间上都是无界的。</p>
<p> <br>
<strong>二元函数f(x,y)在原点处不连续，但在任意一条通过原点的直线上都是连续的</strong></p>
<p>    定义函数f(x,y)=x^2/y，当y&gt;0且x^2/y≤1时；f(x,y)=y/x^2，当y&gt;0且x^2/y≥1时；当y=0时f(x,y)=0。再令f(x,-y)=f(x,y)。</p>
<p><img alt="image placeholder" >
<p>    任意接近(0,0)的地方都存在形如(a, a^2)的点，相应的函数值为1，因此函数在原点间断；可是，取任意一条过原点的直线y=mx，当|x|充分小时必有x^2/y≤1，此时|f(x,y)|=|x^2/y|=|x/m|，函数在原点处连续。</p>
			 ]]></content>
<pubDate>2009-03-10T01:42:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1547</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用一副七巧板拼出带有三个洞的图形 ]]></title>
<link>http://www.matrix67.com/blog/archives/1555</link>
<content><![CDATA[ 
		<p>    我为最新一期的《博物》杂志写了一篇关于七巧板的文章。文章中我提到了一个有趣的问题：一副七巧板拼出的图形里最多可以有多少个中空的“洞”？Martin Gardner认为，一<del datetime="2009-03-11T02:29:48+00:00">块</del>副七巧板最多能拼出有三个洞的图形，并且他自己给出了一个非常漂亮的构造。如果你手中有七巧板的话，不妨也来试试看；没有七巧板也不必觉得遗憾，网上遍地都是七巧板Flash游戏。觉得困难的话，不妨先从两个洞开始做起。<br>
    注意，一个中空的洞必须完全被七巧板的内部空间所包围，仅仅是端点相触由七巧板边界围成的洞是不算的。因此下面的图形中其实只有一个洞，另外两个都不符合规范。</p>
<p>  <img alt="image placeholder" >
<p><span id="more-1555"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <img alt="image placeholder" >
<p>    构造有两个洞的图形相对比较容易（如左图）。构造带有三个洞的图形则相当困难。右图是一个非常精彩的构造，注意顶部大三角形的斜边长为2√<span style="text-decoration:overline;">2</span>，它所覆盖住的“缺口”长度为2 + 1/√<span style="text-decoration:overline;">2</span>，前者仅仅比后者多出0.12个单位长度，几乎是刚好把这个缺口封住。</p>
			 ]]></content>
<pubDate>2009-03-10T19:55:31+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1555</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ （组图）模式、分形与混沌：数学无处不在 ]]></title>
<link>http://www.matrix67.com/blog/archives/1561</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p><span id="more-1561"></span><br>
 <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
以上图片来自<a href="http://www.flickr.com/groups/emergence/">http://www.flickr.com/groups/emergence/</a></p>
<p> <br>
附几张我最近照的照片：</p>
<p> <br>
<img alt="image placeholder" >
Mr.G餐厅的餐具边沿是一个<a href="http://en.wikipedia.org/wiki/Curve_of_constant_width">定宽曲线</a></p>
<p> <br>
<img alt="image placeholder" >
麦当劳的墙上印有网络上广为流传的<a href="http://en.wikipedia.org/wiki/Romanesco_broccoli">分形蔬菜</a>图片</p>
<p> <br>
<img alt="image placeholder" >
学校附近的一个雕塑，由两个Möbius环组成</p>
<p> <br>
<img alt="image placeholder" >
今天在交行ATM机上捕捉到的画面。注意两个数字0的样子。</p>
<p> <br>
<img alt="image placeholder" >
《苏菲的世界》中最精彩的一段自我指涉。</p>
			 ]]></content>
<pubDate>2009-03-13T00:46:55+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1561</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Happy pi day! 祝所有网友节日快乐 ]]></title>
<link>http://www.matrix67.com/blog/archives/1569</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>图片来源：原创</p>
			 ]]></content>
<pubDate>2009-03-14T01:02:07+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1569</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 从“迷失的8”到生成函数：小数展开的秘密 ]]></title>
<link>http://www.matrix67.com/blog/archives/1574</link>
<content><![CDATA[ 
		<p>    小学时经常在计算器上面按12345679这个神秘的8位数。这个数牛就牛在，它乘以9的结果正好等于111111111。你可以在计算器上输好12345679，然后问MM“你的幸运数字是多少”；如果她说“7”，你就在计算器上按“乘以63”，计算器上将会显示出清一色的7字，看上去无比壮观。<br>
    假如123456789×9=1111111111的话，我倒不会觉得奇怪。网上流行过一个火星帖子，写了一大堆诸如111111111 * 111111111 = 12345678987654321的式子来展示数学之美，以至于大家会认为123456789×9的结果也一定是一串很有规律的数字。因此，如果我不在这里说一句123456789×9其实并不等于1111111111的话，估计很多人都发现不了问题。事实上，123456789×9=1111111101，偏偏就差一个“1”。而怪就怪在，去掉被除数中的数字“8”，偏偏又有了12345679×9=111111111，一个极其别扭的算式反而得到了完美的结果。不要让你的直觉被数学之美所蒙蔽，数学上有大量出人意料的、看上去很不对称的结论。<br>
    为什么偏偏要少一个“8”呢？难道这真的是算术中的一个不可抹去的疤痕？我们急需要寻求一个解释，填补上算术中的这个不和谐的“漏洞”。一种解释是，我们看到了123456789×9=1111111101并不美观，想要对其进行改造，进而得到(123456789+1)*9 = 1111111101+9 = 1111111110，于是(123456789+1)*9/10 = 12345679*9 = 111111111。用这种办法的确可以解释“迷失的8”，不过这个解释并不漂亮。为了寻求一个更好的解释，我们来看一看111111111和9的关系。</p>
<p><span id="more-1574"></span><br>
    或许大家都知道，利用等比数列求和，我们可以把任一循环小数还原为分数。111…11和9之间有一个非常精妙的联系：1/9 = 0.111… 。换句话说，1000000000/9取整之后就应该等于111111111。而这个神秘的12345679，就应该是1000000000/81取整后的结果了。1/81到底等于多少呢？拿精度稍微高一点的计算器一算，我们发现1/81 = 0.01234567901234… 。原来，12345679的秘密全在1/81里面，12345679*9=111111111其实相当于是拿1/81乘以9，取得了1/9的小数部分。<br>
    现在余留的问题就是，为什么1/81的前面几位是.012345679呢？仔细观察这个小数，你会发现整个小数的循环节就是012345679，偏偏就少一个“8”。这到底是为什么呢？<br>
    为了解释一种反常的数学现象，一个有趣的思路就是，“如果不是这样，你觉得又该是怎样呢？”理想中，这种有悖于数学之美的事情是不应该发生的，1/81要是等于0.01234567890123456789…就好了，或者更牛B一点的，有没有可能等于0.0123456789101112131415…？哦，这个好像太夸张了，后面这个小数明显是一个无限不循环小数，不可能和一个有理数相等。不过呢，Σn/10^(n+1)倒是有可能的。想到这一点，我们最初的谜题迎刃而解！</p>
<p><img alt="image placeholder" >
<p>    原来，“迷失的8”并不是一个算术上的瑕疵。或许1/81的小数部分本来就应该是123456789..，接下去的一个数应该是10，但它应该占据两个数的位置，而留给它的原本只有一个数位。于是乎，数字10中的个位“0”与“9”的后面一位对齐，而十位“1”则加到了“9”身上并产生了进位，得到了123456790的结果，产生了“迷失的8”这一错觉。而后，刚才10的个位“0”又加上了紧随其后的11的十位，11的个位又和12的十位拼成了“2”，如此反复，使得整个小数部分不断地重复012345679这一循环。</p>
<p>    <img alt="image placeholder" >
<p>    1/81=Σn/10^(n+1)这一猜测似乎很合理，究竟对不对呢？这和81又有什么关系呢？只需要注意到1/81=(1/9)*(1/9)，联想前面我们讲过的东西，我们就得到了一个虽然不严密但是颇有启发性的推理。111*111=12321，是因为111*111相当于把111错位写成三行后加起来；类似地，前面提到的极端情形111111111 * 111111111 = 12345678987654321也是如此。那么，如果10个1乘以10个1呢？如果无穷个“1”乘以无穷个“1”呢？当我们计算1/9的平方时，我们实际上在做的正是用无穷多个1去乘以无穷多个1，而乘式的第n+1列里恰有n个“1”，它们加起来并产生适当的进位后就得到了0.0123456790123… 。</p>
<p>    循环小数与整数之间存在着许多微妙的关系。很多时候，利用小数展开我们能解决一些无从下手的算术题目。小学奥数中有一道题目我印象极深：一个位数小于30的、以“15”打头的整数，把这个“15”移到数的末尾后，新数正好是原数的5倍。问原数是多少。很少有人能想到，解开这道题的钥匙竟然是分数和小数。假设有某个小数x的循环节就等于我们要求的数，那么</p>
<p><img alt="image placeholder" >
<p>    可知100x-5x=15，解得x=15/95=3/19。把3/19还原成小数，发现它的循环节是157894736842105263，问题就如此简单的解决了。<br>
    且慢，我还准备了更加精彩的数学魔术！让我们来看一看下面这套把戏：</p>
<p>100/9899 = 0.0101020305081321345590463 …</p>
<p>    牛B吧！两位两位的看，前面几个数正好形成Fibonacci数列！不过，再往后走，位数的限制迫使进位产生，打乱了原有的秩序。能让每个数的位数更长一些吗？能！请看：</p>
<p>1000/998999 = 0.001001002003005008013021034055089144233377610…<br>
10000/99989999 = 0.000100010002000300050008001300210034005500890144…<br>
100000/9999899999 = 0.00001000010000200003000050000800013000210003400055000890014400233…</p>
<p>    这个就更加奇怪了。为什么一个简简单单的分数展开之后竟然出现了Fibonacci数列？其实，道理和前面所讲的很相似。100/9899显然是由100/(10000-100-1)得到的，让我们来看一下0.0101020305081321…乘以(10000-100-1)是否能还原成100：</p>
<p><img alt="image placeholder" >
<p>    可以看到，这个“Fibonacci小数”的10000倍，减去它的100倍，再减去它自身，得到的结果正好是100，究其原因则是Fibonacci数列的递归性质。熟悉生成函数的读者猛地一拍大腿，唉呀！这不就是生成函数么！我在<a href="http://www.matrix67.com/blog/archives/120">讲解生成函数的日志</a>里曾经写道：</p>
<blockquote><p>    接下来我们要演示如何使用生成函数求出Fibonacci数列的通项公式。<br>
    Fibonacci数列是这样一个递推数列：f(n)=f(n-1)+f(n-2)。现在我们需要求出它的生成函数g(x)。g(x)应该是一个这样的函数：<br>
    g(x)=x+x^2+2x^3+3x^4+5x^5+8x^6+13x^7+…<br>
    等式两边同时乘以x，我们得到：<br>
    x*g(x)=x^2+x^3+2x^4+3x^5+5x^6+8x^7+…<br>
    就像我们前面说过的一样，这相当于等式右边的所有系数向右移动了一位。<br>
    现在我们把前面的式子和后面的式子相加，我们得到：<br>
    g(x)+x*g(x)=x+2x^2+3x^3+5x^4+8x^5+…<br>
    把这最后一个式子和第一个式子好好对比一下。如果第一个式子的系数往左边移动一位，然后把多余的“1”去掉，就变成了最后一个式子了。由于递推函数的性质，我们神奇地得到了：g(x)+x*g(x)=g(x)/x-1。也就是说，g(x)*x^2+g(x)*x-g(x)=-x。把左边的g(x)提出来，我们有：g(x)(x^2+x-1)=-x。于是，我们得到了g(x)=x/(1-x-x^2)。</p></blockquote>
<p>    原来，100/9899说穿了就是把x=1/100代入生成函数g(x)。<br>
    这下子就热闹了。考虑数列1, 4, 9, 16, 25, 36, …的生成函数g(x)=x(1+x)/(1-x)^3，代入x=1/100得到g(1/100)=10100/970299，于是出现了：</p>
<p>10100/970299 = 0.0104091625364964 …</p>
<p>    当然，想要更牛B的也不难：</p>
<p>g(1/1000) = 1001000/997002999 = 0.001004009016025036049064081100121144169 …</p>
<p>    再来看看数列2, 4, 8, 16, 32, …的生成函数g(x)=2x/(1-2x)，利用它可以产生出</p>
<p>g(1/100) = 1/49 = 0.0204081632 …</p>
<p>    或许有人会恍然大悟，原来，1/7=0.142857…也不是一个巧合。14是7的两倍，28是7的四倍，57是7的八倍加一，这都是因为它们是7乘以“2的幂序列”并产生适当进位后得到的。<br>
    重新回到我们先前讨论的话题，我们惊奇地发现，数列0, 1, 2, 3, 4, …的生成函数为g(x)=x^2/(1-x)^2。于是：</p>
<p>g(1/10) = 1/81 = 0.0123456790123…</p>
			 ]]></content>
<pubDate>2009-03-17T02:09:23+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1574</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 分形生活之Koch雪花小蛋糕 ]]></title>
<link>http://www.matrix67.com/blog/archives/1585</link>
<content><![CDATA[ 
		<p>    还记得我们曾经介绍过的<a href="http://www.matrix67.com/blog/archives/378">Sierpinski三角形挂饰</a>和<a href="http://www.matrix67.com/blog/archives/491">Sierpinski饼干</a>吗？iceberg曾经<a href="http://www.matrix67.com/blog/archives/378/comment-page-1#comment-2250">留言</a>说，做一个分形点心会比较有趣，因为你可以宣称“我吃掉了一条无限长的曲线”。这并不是没有可能，<a href="http://www.matrix67.com/blog/archives/243">Koch雪花</a>就是一个面积有限但边界无穷长的图形。牛B就牛B在，同一个网站今天又更新了，它真的给我们带来了一块<a href="http://www.evilmadscientist.com/article.php/fractalsnowflake">Koch雪花小蛋糕</a>：</p>
<p><img alt="image placeholder" >
<p><span id="more-1585"></span><br>
制作过程中的几张照片：</p>
<p><img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-03-19T16:16:59+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1585</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Harvard-MIT Mathematics Tournament 2009: Guts Round ]]></title>
<link>http://www.matrix67.com/blog/archives/1591</link>
<content><![CDATA[ 
		<p>摘录几道题目。</p>
<p>计算1·2^2 + 2·3^2 + 3·4^2 + … + 19·20^2<br>
<span style="color:#E5E5E5">原式 = (1^3 + 2^3 + … + 20^3) – (1^2 + 2^2 + … + 20^2) = 44100 – 2870 = 41230</span></p>
<p>求2^x = 3^y – 1的所有正整数解<br>
<span style="color:#E5E5E5">x=1时(1,1)是一个解；当x&gt;1时，方程模4后左边永远等于0，右边则是(-1)^y – 1，可知y为偶数。令y=2z，那么有2^x = (3^z – 1)(3^z + 1)，这就要求3^z-1和3^z+1都是2的幂；但它们只相差2，因此它们只有可能是2和4，于是z=1，即原方程的另一个解为(3,2)。</span></p>
<p>圆周上有2008个点。选择两个点连成一条线，再选另外两点连一条线，这两条线段相交的概率为多少？<br>
<span style="color:#E5E5E5">给定四个点，在三种连接方案中恰有一种会发生相交。取遍所有C(2008,4)种组合，相交的总情况数总是占了1/3，因此所求的概率就是1/3。</span></p>
<p><span id="more-1591"></span><br>
我们称一个正整数为“吉祥数”，如果它的二进制表达中有偶数个“1”。第2009个吉祥数是多少？<br>
<span style="color:#E5E5E5">注意到两个正整数2k和2k+1的二进制表达中就只有最后一位不同（一个是“0”一个是“1”）。因此，2和3里面恰有一个吉祥数，4和5里面恰有一个吉祥数……以此类推，第2009个吉祥数必然是4018和4019中的一个。验证可知，4018=(111110110010)2，它有偶数个“1”，因此4018即为答案。</span></p>
<p>在R^n的井字棋游戏中有多少种取胜的方式？换句话说，在3*3*…*3的n维立方体棋盘中，选取三个排成一条线的小立方体有多少种可能？<br>
<span style="color:#E5E5E5">给出一个我自己的解法：想象给这个立方体套一个边长为5的“外壳”，则原棋盘的每一条直线延长后都对应了外壳上的两个小立方体，外壳上的每一对位置相对的小立方体反过来也都对应着里面的棋盘中的一条直线。因此，答案为外壳上的立方体个数除以2，即(5^n-3^n)/2。</span></p>
<p>汗……图片隐藏不了……</p>
<p><img alt="image placeholder" >
<p>来源：<a href="http://web.mit.edu/hmmt/www/datafiles/solutions/2009/solutions-guts-2009.pdf">http://web.mit.edu/hmmt/www/datafiles/solutions/2009/solutions-guts-2009.pdf</a>,</p>
			 ]]></content>
<pubDate>2009-03-20T19:03:35+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1591</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 追Geek MM小工具：IOCCC情书生成器v0.1 ]]></title>
<link>http://www.matrix67.com/blog/archives/1598</link>
<content><![CDATA[ 
		<div style="margin:10px 0 0 10px">
<input id="t1" style="font-family:tahoma;font-size:12px; width:480px;" value="I love you to death! You are the cutest and sweetest girl I've ever met."><input type="button" style="margin-left:18px;" value="Say it!" onclick="convert(document.getElementById('t1').value)">
<p><textarea id="t2" cols="48" rows="17" readonly style="font-family:'Courier New';font-size:12px;"></textarea><script type="text/javascript" src="http://www.matrix67.com/data/scripts/ioccc.js"></script></p>
</div>
			 ]]></content>
<pubDate>2009-03-22T00:58:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1598</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 晒论文：表示重复意义的虚词比较 ]]></title>
<link>http://www.matrix67.com/blog/archives/1611</link>
<content><![CDATA[ 
		<p>    其实，中文系并不轻松。我们有人曾经仔细算过，我们的学分（特别是我们专业的学分）远远高过好几个理科大系。理科院系看上去作业很多，但期中期末的任务并不重；文科院系就惨了，平时没啥作业，一到期中期末就牛B，写了论文还要背东西应考，逼着我们天天熬夜。<br>
    这几天实在是累，加之空间续费后IP地址变了，DNS刷了半天都没刷过来，于是又是好久没有更新。晒一晒这几天的劳动成果——汉语虚词研究的一次大作业。如果感兴趣的话，不要错过这两篇日志：</p>
<p><a href="http://www.matrix67.com/blog/archives/477">http://www.matrix67.com/blog/archives/477</a><br>
<a href="http://www.matrix67.com/blog/archives/508">http://www.matrix67.com/blog/archives/508</a></p>
<p> <br>
 </p>
<p style="text-align:center">“又”、“还”、“再”、“重/重新”表示重复意义时的区别</p>
<p><strong>一、对“重/重新”的语用分析</strong></p>
<p>    “重/重新”在语义上与其他三个词有较大的差别，因此这里首先单独讨论“重/重新”的意义，以便在以后的讨论中排除单由“重/重新”的语用条件引起的混淆。<br>
    在《现代汉语词典》中，“重”释义为重新、再，而“重新”则释义为再一次。但事实情况远远没有那样简单。请看下例：</p>
<blockquote style="font-family:SimSun"><p>  在去年的比赛中，他再次名落孙山<br>
* 在去年的比赛中，他重新名落孙山</p></blockquote>
<p><span id="more-1611"></span><br>
    可见，“重/重新”并不完全等于“再一次”，在使用时会有一些限制。试对比以下两组词语：</p>
<blockquote style="font-family:SimSun"><p>  重生                       * 重死<br>
  重见光明                   * 重陷黑暗<br>
  重新就业                   * 重新失业<br>
  重新爬了起来               * 重新摔了一跤<br>
  重新占据了领先地位         * 重新回到了落后地位<br>
? 使对手重新占据了领先地位     使对手重新回到了落后地位</p></blockquote>
<p>    可见,“重/重新”不用于不如意的事情。对于一些中性的、不区分好坏的事情,“重/重新”在使用上也受到一些限制。例如：</p>
<p><!--more--></p>
<blockquote style="font-family:SimSun"><p>  重写           * 重睡<br>
  重新注册       * 重新取消<br>
  重新输入       * 重新删除</p></blockquote>
<p>    可以看出,“重/重新”并不适用于毫不费力即可实现的动作。综上所述，我认为，“重/重新”通常用于需要经过一定劳作才能实现的事情，并且结果理想而又来之不易。</p>
<p>    使用“重/重新”时往往还带有其他意思。看看下面两句话:</p>
<blockquote style="font-family:SimSun"><p>  再做一个样品。<br>
  重做一个样品。</p></blockquote>
<p>    这两句话都可以说，但是表达的意思似乎不尽相同。为了区别这两句话，我们添加适当的语境：</p>
<blockquote style="font-family:SimSun"><p>  这个样品很不错，麻烦你再做一个。<br>
* 这个样品很不错，麻烦你重做一个。<br>
  这个样品有缺陷，麻烦你再做一个。<br>
  这个样品有缺陷，麻烦你重做一个。</p></blockquote>
<p>    这样看来，能否使用“重/重新”似乎应取决于被重复的动作的结果是否如意。但是，添加更多的语境后，我们又看到了不同的情况：</p>
<blockquote style="font-family:SimSun"><p>  这个样品很不错，但是被摔坏了，只好再做一个。<br>
  这个样品很不错，但是被摔坏了，只好重做一个。<br>
  这个样品有些缺陷，麻烦你再做一个更好的。<br>
? 这个样品有些缺陷，麻烦你重做一个更好的。</p></blockquote>
<p>    可见，我们之前的猜想是错误的。如果加上“样品被摔毁”的语境，“重做”又可以说了；但同样是前一次动作的结果不满意，“重做一个更好的”似乎比“重做一个”别扭得多。因此，看是否能够使用“重/重新”，关键在于前一次的动作是否徒劳。若被重复的那个动作不可取，需要颠覆过去重起炉灶，我们才使用“重/重新”。一些类似的用法诸如：</p>
<blockquote style="font-family:SimSun"><p>  各单位重新调整了整党计划。<br>
  他细心地对每一个数据重新进行了计算。</p></blockquote>
<p>    “重新开始”是一个很有意思的说法。按照上述理论，重新开始是指原来已经开始并持续了一段时间，但效果并不好；于是放弃原来的计划，从头再开辟一个新的进程。这一用法引伸出了一种更广的意义：重复的阶段起点。试着比较下面四个句子：</p>
<blockquote style="font-family:SimSun"><p>  在前几届比赛中他包揽了全部冠军，今年他又再次夺冠。<br>
? 在前几届比赛中他一直未能获得冠军，今年他又再次夺冠。<br>
* 在前几届比赛中他包揽了全部冠军，今年他又重新夺冠。<br>
  在前几届比赛中他一直未能获得冠军，今年他又重新夺冠。</p></blockquote>
<p>    可以看到，“重新夺冠”具有这样的意义：他以前曾经得过冠军，但“获得冠军”这一状态并未持续，直到今年再次获得冠军的称号，结束了得不到冠军的阶段，开始了新的时间区间。在这种情况下如果用“再次夺冠”，读来反而不太通顺了。<br>
    类似的用法也有很多。这里我们再举几例：</p>
<blockquote style="font-family:SimSun"><p>  几十名有旧怨的同志解开了疙瘩，重归于好。<br>
  时隔22年后他又重新挑起了副市长的重担。<br>
  一些个体户同乡镇企业合作，创出了自己的名牌产品，重新打入了国营商场。</p></blockquote>
<p> <br>
<strong>二、完全重复</strong></p>
<p>    所谓完全重复，是指前后两个动作的主体、客体和动作本身完全一样，仅仅是时间不同而已。“又”、“还”、“再”、“重/重新”四个词均可以用于完全重复。在下面这个例句中，四个词是可以互换的（说第一句话时我们通常会加一个“要”字，原因后文讲解）：</p>
<blockquote style="font-family:SimSun"><p>  如果明天还(要)考试，我可就受不了了。<br>
  如果明天再考试，我可就受不了了。<br>
  如果明天又考试，我可就受不了了。<br>
  如果明天重新考试，我可就受不了了。</p></blockquote>
<p>    但是，更多的时候，它们是不能互相替换的。为了研究四个词语的出现规律，我们把完全重复分为两类，一类是重复事件已经发生了的，一类是重复事件还未做的。</p>
<blockquote style="font-family:SimSun"><p>  1977年，中国又恢复了高考制度<br>
* 1977年，中国还恢复了高考制度<br>
* 1977年，中国再恢复了高考制度<br>
  1977年，中国重新恢复了高考制度</p></blockquote>
<blockquote style="font-family:SimSun"><p>* 科学家计划又做一次实验<br>
  科学家计划再做一次实验<br>
? 科学家计划还做一次实验<br>
  科学家计划重做一次实验</p></blockquote>
<p>    从上面两组例句中我们看到了差别。“重/重新”在两种场合下都能使用；“又”只用于已完成的事件，不用于未完成的事件；“再”则正好相反，它只用于未做的事，不用于已经做过的事。“还”则比较奇怪，在这两个例子中都不大能说。下文还会继续讨论用“还”表示未来将要重复的事情时的一些特殊情况。<br>
    我们为什么不区分“过去时”和“将来时”，而要采用“是否做过”这一标准呢？因为同样是过去时，重复事件是否发生过对副词搭配也有影响。看下一组例句：</p>
<blockquote style="font-family:SimSun"><p>* 当时我又看一遍的话就好了！<br>
  当时我再看一遍的话就好了！<br>
* 当时我还看一遍的话就好了！<br>
  当时我重新看一遍的话就好了！</p></blockquote>
<p>    “看一遍”这个动作并未重复，事实上也从未重复过。虽然整个时态属于过去时，但副词搭配的表现与前两组例句中的后面一例相像。因此，我们用“重复事件是否已经发生”来区分两种情况是有道理的。<br>
    回顾本节最初的例子，为什么在那一组句子里四个副词都能使用呢？在讨论这几个副词的特殊用法时，我们将再次回到这个问题上来。</p>
<p> <br>
<strong>三、非完全重复</strong></p>
<p>    非完全重复是指新事件并非和被重复事件完全相同。前后两个动作的宾语可能不一样，例如：</p>
<blockquote style="font-family:SimSun"><p>  出了办公室后，我们又走进了列宁的起居室。</p></blockquote>
<p>    这句话中，“走进起居室”这一动作并未发生实质性重复。事实上，说话人并未去过列宁的起居室，被重复的仅仅是“进入房间”这一动作。有时候，不完全重复的前后两个动作可能也不一致，仅有主体是相同的：</p>
<blockquote style="font-family:SimSun"><p>  吃完了面包，我又喝了一口水。</p></blockquote>
<p>    事实上，非完全重复的动作主体也不一定一致：</p>
<blockquote style="font-family:SimSun"><p>  同样的事情又被小李撞见了。</p></blockquote>
<p>    但是，非完全重复的主语必需保持一致，否则不能用表示重复的副词，而应该用“也”：</p>
<blockquote style="font-family:SimSun"><p>* 两年后，美国科学家又给出了相同的答案。<br>
  两年后，美国科学家也给出了相同的答案。</p></blockquote>
<p>    上面的例子说明，非完全重复的应用是非常广泛的。它与完全重复的区别不单是语义上的，它们的副词搭配也有所不同。例如：</p>
<blockquote style="font-family:SimSun"><p>  出了办公室后，我们又走进了列宁的起居室。<br>
  出了办公室后，我们还走进了列宁的起居室。<br>
* 出了办公室后，我们再走进了列宁的起居室。<br>
* 出了办公室后，我们重走进了列宁的起居室。</p></blockquote>
<p>    可以看到，此时的副词搭配和完全重复的相应例子是有区别的。一个明显的差异是，“重/重新”不再适用了。事实上，由于其固有的语用条件，“重/重新”不可能用于非完全的重复。只有“再”、“又”、“还”能够表达出非完全重复的含义。<br>
    “再”、“又”、“还”在表达非完全重复时也有一些差别。我们对事情已发生、事情未发生两种情况各举一个例子：</p>
<blockquote style="font-family:SimSun"><p>  去年在新加坡输了球，亚运会上又输给了泰国队。<br>
* 去年在新加坡输了球，亚运会上再输给了泰国队。<br>
  去年在新加坡输了球，亚运会上还输给了泰国队。</p></blockquote>
<blockquote style="font-family:SimSun"><p>* 明年他又将访问北京、大连、沈阳和哈尔滨。<br>
* 明年他将再访问北京、大连、沈阳和哈尔滨。<br>
  明年他还将访问北京、大连、沈阳和哈尔滨。</p></blockquote>
<p>    过去未发生的事件依旧与前一种情况类似，这再次表明过去未发生的情形与将来未发生的情形的一致性：</p>
<blockquote style="font-family:SimSun"><p>* 如果当年又输给了泰国队，我们就不可能出线。<br>
* 如果当年再输给了泰国队，我们就不可能出线。<br>
  如果当年还输给了泰国队，我们就不可能出线。</p></blockquote>
<p>    我们发现，“再”可以用于将来的完全重复，却不能用于将来的非完全重复。但是在日常生活中，</p>
<blockquote style="font-family:SimSun"><p>  下面我再强调两点。<br>
  做完实验后，科学家们计划再核对一下数据。</p></blockquote>
<p>    似乎又可以说。这涉及到“再”字的另一个特殊用法。我们仍然留到第五节来细谈。</p>
<p>    其实，非完全重复与完全重复差别最大的还体现在“还”字上。在表示完全重复时，“还”很少使用；但在表示非完全重复时，所有情况它都可以用。事实上，在表示非完全重复，我们用得最多的词就是“还”，这个意义是“还”的语境意义之一。<br>
    有时，对句子稍作变换，我们可以让未然的完全重复中也用上“还”。“还”表示完全重复的意义时往往不单独出现，而是附着了适当的能愿动词。通过添加能愿动词，我们能够用事实和意愿将前后两件事区分开来，把完全重复变成一种特殊的非完全重复，发挥副词“还”的补充说明功能，使得句子更加顺畅。</p>
<blockquote style="font-family:SimSun"><p>? 这部电影太好看了，明天我还去看。<br>
  这部电影太好看了，明天我还想去看。<br>
  这部电影太好看了，明天我还要去看。</p></blockquote>
<blockquote style="font-family:SimSun"><p>* 昨天事情没办成，今天我还去。<br>
  昨天事情没办成，今天我还得去。<br>
  昨天事情没办成，今天我还要去。</p></blockquote>
<p>    类似地，上文中提到的一组未发生的完全重复的例子，使用“还”字时最好加上一个“要”字：</p>
<blockquote style="font-family:SimSun"><p>? 如果明天还考试，我可就受不了了。<br>
  如果明天还要考试，我可就受不了了。</p></blockquote>
<p>    事实上，很多谓宾动词都具有这一功能。例如我们上面曾经提到过的例子：</p>
<blockquote style="font-family:SimSun"><p>? 科学家计划还做一次实验</p></blockquote>
<p>    如果要让“计划”和“做”同时出现，应该将“还”置于谓宾动词前，保留“再”原来的位置。因此，最顺口的表达其实应该如下：</p>
<blockquote style="font-family:SimSun"><p>  科学家还计划再做一次实验</p></blockquote>
<p>    我们可以用另一些体宾动词来替换：</p>
<blockquote style="font-family:SimSun"><p>  科学家还提议再做一次实验<br>
  科学家还希望再做一次实验</p></blockquote>
<p> <br>
<strong>四、延续性重复</strong></p>
<p>    延续性重复并不是真正意义上的重复，它表示一种状态的不间断的持续。下面的例子均表示延续性重复，其中的“还”字可以替换为“一直”：</p>
<blockquote style="font-family:SimSun"><p>  大雨还在下。<br>
  十年没见了，她还这么年轻。<br>
  都两点了，他还没睡。<br>
  我们还会继续帮助你。</p></blockquote>
<p>    “又”和“重/重新”都不能表示延续性重复。例如，下面这几句话明显不能讲：</p>
<blockquote style="font-family:SimSun"><p>* 大雨又在下。<br>
* 大雨重在下。<br>
* 十年没见了，她又这么年轻<br>
* 十年没见了，她重这么年轻</p></blockquote>
<p>    “再”也可以表示延续性重复。由于“再”不用于叙述发生过的事情，因此“再”表示延续性重复时只能用于假设。下面几个句子用“还”和“再”都是可以的：</p>
<blockquote style="font-family:SimSun"><p>  再不走就来不及了。<br>
  还不走就来不及了。</p></blockquote>
<blockquote style="font-family:SimSun"><p>  学习再不努力的话，就得留级了。<br>
  学习还不努力的话，就得留级了。</p></blockquote>
<blockquote style="font-family:SimSun"><p>  雨要是再这样下下去，明天的春游可就泡汤了。<br>
  雨要是还这样下下去，明天的春游可就泡汤了。</p></blockquote>
<p>    注意，虽然“走”、“努力”都不是延续性的，但“不走”、“不努力”可以是延续的，因此这里应该看作是延续性的重复。</p>
<p> <br>
<strong>五、一些特殊语用和特殊句式</strong></p>
<p>    最后，我们来考察四个副词各自的一些特殊用法，利用前面的结论解释一些现象，并且解决前文残留的一些问题。</p>
<p>    1. “再”可以用于“虚重复”<br>
    “再”可以用于非实指的重复，即被重复的事情事实上并不存在。这是副词“再”独有的功能，其它副词均不能表达：例如：</p>
<blockquote style="font-family:SimSun"><p>  今天没看成，明天再看<br>
* 今天没看成，明天又看<br>
* 今天没看成，明天还看<br>
* 今天没看成，明天重看</p></blockquote>
<blockquote style="font-family:SimSun"><p>  今天就到这儿，其余的明天再说吧<br>
* 今天就到这儿，其余的明天又说吧<br>
* 今天就到这儿，其余的明天还说吧<br>
* 今天就到这儿，其余的明天重说吧</p></blockquote>
<p>    2. “再”可以表示动作的顺承<br>
    “再”可以用来表示一个动作紧接着另一个动作，这也是该副词独有的功能。这需要与非完全重复区别开来。例如，下面两组句子中，第一个句子是动作的顺承，只能用“再”；后两个句子是不完全重复，不能用“再”，只能用“还”和“又”。</p>
<blockquote style="font-family:SimSun"><p>  想好了再写。       想好了，还写了一点。          * 想好了，再写了一点。<br>
  打好地基再盖楼。   打好了地基，又盖起了高楼。    * 打好了地基，再盖起了高楼。</p></blockquote>
<p>    我们前面留下了一个问题：为什么“下面我再强调两点”、“做完实验后，科学家们计划再核对一下数据”是非完全重复，却又能用“再”呢？事实上，这两句话更强调动作的顺承，而非两个事件的重复。</p>
<p>    3. 祈使句中的“再”<br>
    “再”还有一类很特殊的用法：用于祈使句中，表示反复尝试的意义。其它副词同样不具有这一功能。</p>
<blockquote style="font-family:SimSun"><p>  你再仔细看看。<br>
* 你还仔细看看。<br>
* 你又仔细看看。<br>
* 你重仔细看看。</p></blockquote>
<p>    4. 疑问句中的副词选择</p>
<p>    既然是疑问句，被问及的事件显然还未发生。但加入了疑问语气后，新事件所处的地位与原事件不再相同，产生了附加、不确定的色彩。因此我们猜测，疑问句中的副词搭配应该与未发生的非完全重复情形相同。实际情况与我们所想象的完全一致：</p>
<blockquote style="font-family:SimSun"><p>  他明天还来不来？<br>
* 他明天再来不来？<br>
* 他明天又来不来？<br>
* 他明天重来不来？</p></blockquote>
<p>    5. 动词“是”的搭配与“又一”的说法。<br>
    “是”是一个非常特殊的副词，在考察副词用法异同时要特别注意。在“是”前面出现表重复的副词时，我们通常都用“又”，有时也用“还”：</p>
<blockquote style="font-family:SimSun"><p>  又是       还是     * 再是     * 重是</p></blockquote>
<p>    究其原因，还是由于动词“是”的特殊性造成的。“是”字通常不用于表示未发生的事，一旦出现往往都含有延续性的意义，只用“还”。例如：</p>
<blockquote style="font-family:SimSun"><p>  明天还是我值日。<br>
  如果没有他，我可能现在还是一个没见过世面的农村孩子。</p></blockquote>
<p>    表示完全重复时，“是”字大都用在既定的事物，而根据前面的结论，在这种场合之下我们只能用“又”。久而久之，“又是”逐渐凝固成了一个词，并产生一些其它的特殊用法。例如，人们常常将“又是一个”省略为“又一”，进而演变出了下面这样的句子：</p>
<blockquote style="font-family:SimSun"><p>  这是双色球人为控制的又一罪证。<br>
  在他们的身边，又一场惊心动魄的大变革来临了。</p></blockquote>
<p>    其它几个词语显然没有这样的用法。</p>
<p>    6. “又”可以表示动作接连出现<br>
    “又”还有一个其它词所不具有的用法。看例子：</p>
<blockquote style="font-family:SimSun"><p>  掌声一阵又一阵地响起。<br>
  我想了又想，最终还是决定放弃。</p></blockquote>
<p>    这里，“又”并不是表示重复，而是表示反复。前文我们留下了一个疑问，即为何“如果明天又考试”说得过去，这其实是因为这里“又”表示的是“考了又考”的意思，这种意义与完全重复有一些微妙的差别：</p>
<blockquote style="font-family:SimSun"><p>* 明天又考一次。<br>
  今天刚考完明天又要考。</p></blockquote>
<p>    7. “又”表示动作周期性出现<br>
    “又”出现在未发生的重复事件里还有一种可能的情况。当表示某个循环往复的事物再度出现时，我们可以用“又”，即使这件事尚未发生。请看：</p>
<blockquote style="font-family:SimSun"><p>  春天又快到了。<br>
  明天又是星期天。<br>
  又轮到他站岗了。</p></blockquote>
<p>    这种意义很可能是由动作接连出现的意思演变过来的，因为它暗含了时间快，周期短的主观感受。注意区别“明天又是我值日”和“明天还是我值日”的区别。前者是完全重复，而后者是延续性重复。因此，说“明天又是我值日”时，前一天不一定是“我”值日；但说“明天还是我值日”时，今天一定也是“我”在值日。</p>
<p> <br>
<strong>六、总结</strong></p>
<p>    文章最后，我们总结一下四个词在表示重复时的用法：</p>
<p>  1. 又：<br>
    通常用于陈述已经发生的重复事件<br>
    有时可用于未发生的重复事件，例如表示动作接连不断、周期性重复时。<br>
    绝对不用于延续性重复</p>
<p>  2. 还：<br>
    用于非完全重复，表示附加<br>
    常用于疑问句<br>
    倾向于在后面附着时间副词和谓宾动词<br>
    附着时间副词和能愿动词后可以以表示非完全重复的身份进入完全重复格式<br>
    可用于延续性重复</p>
<p>  3. 再：<br>
    只用于未发生的完全重复事件<br>
    可以表示动作顺承，进入不完全重复的格式<br>
    有表示虚重复、进入祈使句等多种特殊用法<br>
    可用于未发生的（假设的）延续性重复</p>
<p>  4. 重/重新：<br>
    可用于所有形式的完全重复<br>
    语义限制很强，含有前次动作徒劳或前一阶段结束的意义，常为辛勤劳作所得<br>
    绝对不用于不完全重复<br>
    绝对不用于延续性重复</p>
			 ]]></content>
<pubDate>2009-03-26T00:36:29+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1611</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ “周末不工作”周期函数 ]]></title>
<link>http://www.matrix67.com/blog/archives/1625</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>来源：<a href="http://tinyurl.com/ct43t9">http://tinyurl.com/ct43t9</a></p>
			 ]]></content>
<pubDate>2009-03-26T00:50:02+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1625</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：几个利用概率法进行证明的例子 ]]></title>
<link>http://www.matrix67.com/blog/archives/1629</link>
<content><![CDATA[ 
		<p>    概率论并不仅仅是用来算算概率的。有些时候，概率论远比我们想象中的更强大。</p>
<p>    考虑这样一个问题。考虑集合X上的一个集合族，集合族中的所有集合大小均为d。我们说这个集合族是可以二染色的，如果对X的元素进行适当的红蓝二着色之后，每个集合里面都包含了两种颜色的元素。例如，当d=3时，{1,2,3}, {1,2,4}, {1,3,4}, {2,3,5}就是可二染色的，把1、2染成红色，把3、4、5染成蓝色，则每个集合里都含有两种颜色。是否存在d=3的不可二染色集族呢？这样的集族当然是存在的，例如取集合{1,2,3,4,5}的全部C(5,3)个元素个数为3的子集，则无论如何染色，总会有一个集合里面的元素全是一种颜色。上述推理立即告诉我们，对于一个给定的d，一定存在一个集合个数为C(2d-1, d)的不可二染色集族。这个数目还能再少吗？我们想知道，不可二染色集族中的集合个数最少可以少到什么地步。一个极其简单的证明给出了一个下界：集族的大小一定大于2^(d-1)。当d=3时，你一辈子也不能构造一个不可二染色集族，里面只含4个集合。<br>
    为了证明这一点，不妨对X中的所有元素进行随机着色，每个元素取成红色和蓝色的概率均等。那么，一个元素个数为d的集合中，所有元素均为一种颜色的概率就应该是1/2^(d-1)。如果集族内的集合个数只有不到2^(d-1)个，那么即使“集合中是否只有一种颜色”是互相独立的，这些事件的并（至少有一个集合内只有一种颜色）的概率也不超过2^(d-1) * 1/2^(d-1) = 1，何况这些事件还不是独立的，因此存在单色集合的概率必然小于1。这个概率值小于1说明什么？这说明，“至少有一个单色集合”并不是必然事件，一定有一种染色方案使得每个元素里都含两种颜色，换句话说该集族可以被二染色。</p>
<p><span id="more-1629"></span><br>
 <br>
    这种证明方法奇就奇在，利用概率论进行推理得到的结果居然是一个确定的结论。<a href="http://en.wikipedia.org/wiki/Probabilistic_combinatorics">Wikipedia</a>上给出了另一个经典的概率法证明，问题仍然与染色有关。<br>
    或许大家经常听到这样一个结论：六个人在会议上握手，则存在三个两两之间都握过手，或者两两之间都没握手的人。一种更夸张的说法是，假设好友关系是双向的，那么世界上任何六个人之间或者存在三个两两都是好友的人，或者存在三个两两都不是好友的人。用图论的话说，对完全图K_6的边进行红蓝二着色，则图中一定存在一个单色的（所有边都是一种颜色的）同构于K_3的子图。K_6已经是能够满足此要求的最小完全图了，你可以尝试构造一个K_5的边二着色，使得图中不含单色的K_3子图。1930年，Frank P. Ramsey证明了，对于一个给定的r，总存在一个足够大的n，使得K_n的边二着色一定含有单色的K_r子图。这就是著名的Ramsey定理。Ramsey定理给出了n的一个上界，不过n的下界又是多少呢？1947年，Erdős的一个经典证明告诉我们，随着r的增加，n至少是指数级的增长。<br>
    为了证明这一点，我们随机给完全图K_n进行着色，每条边都有1/2的概率取红色，1/2的概率取蓝色。一个K_r子图的所有边都为红色或者都为蓝色，其概率为2·(1/2)^C(r,2)。那么对于所有C(n,r)个不同的K_r子图，单色子图个数的期望值即为C(n,r) · 2·(1/2)^C(r,2)。想想看，如果上面这个期望值小于1的话说明什么？这表明，不是所有着色方案都含有单色K_r子图，至少存在一种着色方案，它的单色K_r子图个数为0。因此，为了保证所有着色方案中都存在至少一个单色K_r子图，我们必须保证这个期望值大于等于1，也即2 · C(n,r) ≥ 2^C(r,2)。不等式右边是r(r-1)/2个2相乘的结果，不等式左边却还不及n^r，满足上述不等式至少得先保证n^r &gt; 2^(r(r-1)/2)，这里n至少得有2^((r-1)/2)，这就足以说明n是指数级别增长的了。<br>
    很多存在性问题的证明方法都不是构造性的，它虽然证明了满足某种性质的数学对象是存在的，但并没有得出构造该数学对象的方法。利用概率进行证明往往都是非构造的，虽然证到了结论，究竟该如何寻找一个不含单色K_r子图的着色方案，这个问题直到今天仍然没有解决。</p>
<p> <br>
    Erdős似乎是很喜欢概率法证明，最经典的一些概率证明都来源于Erdős。我们再来看一个比较复杂的例子。<br>
 <img alt="image placeholder" >
    空间中的n个点确定了3·C(n,3)个角。随着n的增加，这些角不可能永远都只有锐角，总会有一个直角或者钝角冒出来。在平面上，只确定锐角的点集最多只能有三个点，摆放四个点将不可避免地产生直角或钝角。在三维空间中，五个点已经是最好的结果了（上图），可以证明六个点里无论如何都含有直角或钝角。Danzer和Grünbaum猜想：在d维空间中只含锐角的最大点集为2d-1。这个猜想始终未被证明。21年后，Paul Erdős和Zoltán Füredi推翻了这个猜想。他们用一个非构造性的证明说明，你可以从34维立方体的顶点中选取72个点，使得它们只确定出锐角。事实上，他们利用概率论证明了这样一个非概率性的事实：在d维空间中，存在一个大小为2 · [(√<span style="text-decoration:overline;">6</span>/9) · (2/√<span style="text-decoration:overline;">3</span>)^d]点集S⊆{0,1}^d，使得该点集所确定的角都是锐角（[x]是取x的下整的意思）。<br>
    令m=[(√<span style="text-decoration:overline;">6</span>/9) · (2/√<span style="text-decoration:overline;">3</span>)^d]，然后随机选取3m个0/1向量</p>
<p>x(1), x(2), …, x(3m) ∈ {0,1}^d</p>
<p>    显然，这些点所构成的角只可能是锐角或直角。向量x(i), x(j), x(k)确定一个以x(j)为顶点的直角当且仅当x(i)-x(j)与x(k)-x(j)的点积为0，换句话说对所有的坐标维l≤d都满足要么x(i)和x(j)的第l个坐标相等，要么x(k)和x(j)的第l个坐标相等。不妨把x(i)的第l个坐标记为x(i)[l]，则上述条件就可以写成x(i)[l]=x(j)[l]或x(k)[l]=x(j)[l]。我们把满足该条件的三元组(i,j,k)叫做一个“问题组”。注意，我们随机取向量时有可能取到重复的，当发生x(i)=x(j)或者x(k)=x(j)时，对应的角并不存在，但它显然也属于一个问题组。<br>
    在某一坐标l上，x(j)[l]既不等于x(i)[l]也不等于x(k)[l]只有两种情况，既x(i)[l]=x(k)[l]=0且x(j)[l]=1，以及x(i)[l]=x(k)[l]=1且x(j)[l]=0。这占了所有8种情况的1/4。由于所有向量的所有坐标都是独立选取的，因此三个向量形成问题组的概率就应该是(3/4)^d。空间中的n个点确定了3 · C(n,3)个角，因此问题组个数的期望值就应该是3 · C(3m,3) · (3/4)^d。既然期望值是这么多，这说明至少存在一种向量的取法，使得问题组的个数最多只有3 · C(3m,3) · (3/4)^d。然而</p>
<p>  3 · C(3m,3) · (3/4)^d<br>
&lt; 3 · (3m)^3 · (3/4)^d / 6
= m^3 · (81/6) · (3/4)^d
= m^3 · (9/√<span style="text-decoration:overline;">6</span>)^2 · (√<span style="text-decoration:overline;">3</span>/2)^(2d) ≤ m</p>
<p>    也就是说，问题组的数目不超过m个。既然这样，我们就可以去掉每个三元组中的其中一个向量（一共去掉了m个向量），破坏掉仅有的问题组，使得剩下的2m个向量中不含任一问题组。这就是一个大小为2 · [(√<span style="text-decoration:overline;">6</span>/9) · (2/√<span style="text-decoration:overline;">3</span>)^d]的只确定了锐角的点集。</p>
			 ]]></content>
<pubDate>2009-03-29T03:54:55+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1629</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：制作一个可以循环播放的磁带 ]]></title>
<link>http://www.matrix67.com/blog/archives/1650</link>
<content><![CDATA[ 
		<p> <img alt="image placeholder" >
<p>    有时候，我们需要一个不用倒带即可实现无限循环播放的特殊磁带。这并不是不可能，只需要打开磁带外壳，把基带进行适当的剪切粘贴后重新绕上去即可。上图便是一个简单的循环播放磁带设计图，磁带的基带非常短，只能录制大约4.9秒。可循环播放的磁带与传统磁带不同的就是，如果基带是一个“圈”的话，它无法再在转轴上一圈一圈地缠绕，否则将会产生自相交，而这在卡带中是不允许的。在这种情况下，基带不可能设计得太长，任何一个小小的改动，哪怕是从4.9秒提升到5秒，也是一个不小的胜利。<br>
    下图是另一种设计方案，录制时间从4.9秒一下子提升到了7.8秒。</p>
<p> <img alt="image placeholder" >
<p>    有网友可能敏锐地发现，这个设计似乎有问题——两个转轴的旋转方向不一致。事实上，在卡带中，转轴的转动方向不一致是允许的。显然，卡带的两个转轴中只能有一个是主动旋转，另一个则是被动旋转；这是因为在播放普通卡带时，由于两个转轴各自最外圈的基带半径不同，两个转轴的转速是不一样的，播放卡带必然只能是用一轴带动另一轴。</p>
<p>    现在，我们的问题是，有一种循环播放磁带设计方案，可以将录制时间增加到9.3秒。你能想到这个方法吗？</p>
<p><span id="more-1650"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    答案：把基带做成Möbius环，使得基带的两个面均可被利用。为了让磁带播放更顺畅，我们为基带的拧转提供了充足的空间，避免因自由空间不足而导致基带打结。</p>
<p> <img alt="image placeholder" >
<p>    
</p>
<p style="color:blue">Update: 地下室楼层的网友提到了磁带原理的问题。这里说的“两个面”指的磁带的AB面。磁带的基带可以录制四个音轨，因此同一段基带可以并存两段不同的立体声信息，它们各占基带的半边（这也就是为什么把磁带翻个身插进去放出来就是不同的声音的原因）。Möbius环只有一个边界，它把磁带的AB面连成了一片。</p>
<p>来源：<a href="http://en.wikibooks.org/wiki/Making_Cassette_Tape_Loops">http://en.wikibooks.org/wiki/Making_Cassette_Tape_Loops</a></p>
			 ]]></content>
<pubDate>2009-03-30T23:30:08+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1650</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ （愚人节玩笑）史上最牛充分条件分析器测试版发布 ]]></title>
<link>http://www.matrix67.com/blog/archives/1657</link>
<content><![CDATA[ 
		<p><script type="text/javascript" src="http://www.matrix67.com/data/scripts/fool.js"></script>
</p>
<p>    在数学研究中，我们经常需要寻找一个命题的充分条件。有时候，我们在解题过程中会不自觉地思考结论的充分条件。例如，等底等高便是两个三角形面积相等的充分条件，这就为我们证明三角形面积相等指明了一条道路，接下来我们只需要说明那两个三角形的确是等底等高的就行了。又如，“任意顶点的度数大于等于n/2”是“无向图存在Hamilton回路”的充分条件，它经常被用来说明一个图有Hamilton回路。不过，与寻找必要条件不同的是，寻找一个命题“可以由什么推出来”是一个逆向思维，构造一个充分条件并不容易。有没有一种寻找充分条件的系统方法呢？我最近几天加班加点地研究，终于完成了一个充分条件分析器。你可以在输入框中属于一个与变量x相关的命题，系统将自动给出一个命题的充分条件。这个系统虽然是测试版，但它已经十分强大了。它不仅支持三角函数、对数函数、指数函数、阶乘等各类函数，还支持极限、微分、积分运算，甚至能够处理包括中文在内的自然语言。如果你不知道该输入什么，你可以先点击下面的几个样例试一试。</p>
<p>
</p>
<p><input id="inputBox" size="50" value="" style="font-family:tahoma;font-size:12px;"> <input type="button" value="Compute!" onclick="doCompute(this.value)"></p>
<p><input id="resultBox" size="65" readonly value="" style="font-family:tahoma;font-size:12px;"></p>
<p><a href="javascript:inputText('x%5E2%20-%202x%20+%201%20=%200')">Example 1</a>   <a href="javascript:inputText('x%20&lt;%2010%20&amp;&amp;%20sin(x)cos(x)ln(x)%20&gt;%20pi/4%E2%80%B2)%E2%80%9D&gt;Example%202&lt;/a&gt;%C2%A0%C2%A0%C2%A0&lt;a%20href=" javascript:inputtext is a prime and x also palindrome>Example 3</a>   <a href="javascript:inputText('x%E6%98%AF%E8%8D%89%E6%B3%A5%E9%A9%AC%E6%89%80%E5%9C%A8%E7%94%9F%E7%89%A9%E5%9C%88%E4%B8%AD%E7%9A%84%E7%89%A9%E7%A7%8D%E4%B8%AA%E6%95%B0')">Example 4</a>   <a href="javascript:inputText('x%E5%A4%A7%E4%BA%8E%E4%BD%A0%E4%BB%8A%E5%A4%A9%E7%82%B9%E5%87%BB%E2%80%9CCompute!%E2%80%9D%E6%8C%89%E9%92%AE%E7%9A%84%E6%AC%A1%E6%95%B0')">Example 5</a></p>
			 ]]></content>
<pubDate>2009-04-01T01:19:18+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1657</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一道智力题：世上最毒的毒药 ]]></title>
<link>http://www.matrix67.com/blog/archives/1671</link>
<content><![CDATA[ 
		<p>    故事发生在一个遥远的神秘世界。在那里，人们可以制造出不同等级的毒药。这种毒药是致命的，唯一的解药则是更强的毒药。若不幸中毒后，只要及时喝下更强的毒药就没事了，否则不管是谁都会在10分钟之内死亡。<br>
    一天，恶魔向国王发起挑战，看谁拥有最毒的毒药。这是一场死亡竞赛，比赛规则很简单：双方各带一瓶毒药，先把对方瓶中的毒药喝掉一半，然后再把毒药换回来，把自己的毒药喝完。10分钟后，活下来的人便赢得这次比赛。恶魔藏有世上已知的最毒的毒药。国王知道，他无论如何也造不出比那更强的毒药来，并且也知道比赛时恶魔用的就是他那瓶绝无仅有的毒药。国王有办法赢得比赛吗？</p>
<p>    答案：<span style="color:#E5E5E5">国王有办法赢得比赛。在比赛开始前，国王先制造一个药性很弱的毒药，把它喝掉，然后拿着一瓶白开水去比赛。比赛时，国王喝掉恶魔手中的牛B毒药，反而没事了；恶魔喝的则是白开水。然后，国王喝掉自己的白开水，恶魔喝掉自己的牛B毒药；结果呢，即使他还想找解药都找不着了……因为他那瓶毒药已经是世上最牛B的了。</span></p>
<p>    不知道这个题目火星了没，反正今天我还是头一次见到。</p>
<p><span id="more-1671"></span><br>
    故事并没有结束。我还多想了一些其它的。如果恶魔在国王身边安插了间谍，知道了国王的伎俩，事情就又开始变得有意思起来了。恶魔是可以破解这个伎俩的。一个简单的办法是，在上战场前他也喝点弱毒药。这样下来，两个人最终都能活下来，谁也弄不死谁。恶魔还有一个更绝的办法：赛前什么都不喝，比赛时也带着一瓶白开水上去，于是双方在比赛过程中都喝不到半点毒药，国王将被他比赛前喝掉的那点毒药害死。<br>
    呵呵，你猜对了！我接下来确实想说：如果恶魔的“反欺诈”计划又被国王知道了呢？国王有没有一种“反反欺诈”呢？在这种局势下，我们不妨认为，这一折腾下来国王成功地骗恶魔两手空空上战场，于是他赛前喝点弱毒药，再带个稍微强点的去就能击垮恶魔了，成功地实现三重圈套。当然，当恶魔意识到这一点后，他又会重新带着无敌毒药上战场，整个局势转了一个大圈又回来了。<br>
    结论呢就是，这个博弈问题没有Nash均衡点。即使游戏双方都聪明绝顶也无用，递归思维深入到的层数唯一地决定了最终决策，整个游戏就像石头剪子布一样无限循环下去，最后倒还不如随机选择一种决策了事。</p>
			 ]]></content>
<pubDate>2009-04-02T22:47:27+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1671</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：素数无穷多的拓扑学证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/1678</link>
<content><![CDATA[ 
		<p>    去年就看过Proofs from THE BOOK第一章中的素数无穷多的拓扑学证明，不过当时似乎并没有看懂。今天看到<a href="http://www.cut-the-knot.org/proofs/Mercer.shtml">cut-the-knot</a>的一篇新文章，又把Proofs from THE BOOK拿出来翻了一下，终于看明白了，果然是一个令人拍案叫绝的经典证明，可谓又一神来之笔。</p>
<p>    定义N(a,b) = {a + nb| n∈Z}，例如N(1,3)就等于{…, -5, -2, 1, 4, 7, …}。每一个N(a,b)实质上都是一个以b为公差的“双向无限等差数列”。我们说整数集Z上的一个子集S是开的，如果集合S为空，或者对于任意一个a∈S，总能找到一个b&gt;0使得N(a,b)⊆S。形象地说，开集的意思就是，集合中的每一个元素都能在集合内扩展出一个无限长的双向等差数列。我们又称一个集合S是闭的，如果它是某个开集的补集。<br>
    显然，有限个开集的并集仍然是开集。<br>
    假设S_1和S_2都是开集，如果a∈S_1∩S_2，并且N(a,b1)⊆S_1，N(a,b2)⊆S_2，那么S_1∩S_2中有一个公差为b1*b2的含a的双向无限等差数列，也即a∈N(a, b1*b2)⊆S_1∩S_2。这说明，有限个开集的交集仍然是开集。<br>
    再假设C_1和C_2都是闭集。由De Morgan定律，C_1和C_2的并集就相等于它们各自的补集相交后再取补集，由定义可知它们的补集都是开集，而由上面的结论可知开集的交集仍是开集。于是，C_1和C_2的并集是某个开集的补集，这说明闭集的并仍然是闭集。类似地，闭集的交集相当于补集的并集的补集，它也仍然是闭的。</p>
<p>    还有两点值得引起我们注意：<br>
    1. 任意非空开集都是无穷的。这由定义可以直接看出来。<br>
    2. 任一双向无限等差数列N(a,b)既是开集又是闭集。由定义可知N(a,b)是开集，而同时N(a,b)又可以看作是N(a+1,b)∪N(a+2,b)∪N(a+3,b)∪…∪N(a+b-1,b)的补集，这是有限个开集的并集的补集，说明N(a,b)也是闭集。</p>
<p><span id="more-1678"></span><br>
    好了，准备工作完成，下面我们开始证明素数是无穷多的。除了1和-1以外，每一个整数都有至少一个素因子，因此它们都包含在∪N(0,p)中（其中p取遍所有的素数）。把全体素数的集合记为P，于是我们有：</p>
<p>    Z  {1, -1} = ∪N(0,p), p∈P</p>
<p>    现在，假如素数集合P是有限的，那么等式右边就是有限个闭集的并，它仍然是闭集；这样的话，它的补集{1, -1}就应该一个开集。然而，一个开集要么是空的，要么就是无穷的，这与{1, -1}是开集矛盾。</p>
<p>    除去最经典的Euclid证明，我们还讲了至少四种证明素数无穷多的办法（见<a href="http://www.matrix67.com/blog/archives/282">282</a>、<a href="http://www.matrix67.com/blog/archives/539">539</a>）。但是，本文介绍的证明感觉非常奇怪，和其它几个证明方法都不太一样。我也说不出是哪点不太一样。估计是因为这个证明给人这样一种感觉：素数的定义和性质还没被挖掘充分，结论就已经被证到了。大家有这样的感觉吗？</p>
			 ]]></content>
<pubDate>2009-04-05T01:53:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1678</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：对全体正整数红蓝二着色使之不含单色无穷等差数列 ]]></title>
<link>http://www.matrix67.com/blog/archives/1684</link>
<content><![CDATA[ 
		<p>    你认为，是否有可能把全体正整数染成红蓝二色，使得不存在无穷等差数列，数列中的所有数都是一种颜色？如果你认为存在这样的染色方案，请给出一个构造方法；如果你认为不存在，证明之。在看下面的答案之前，不妨先仔细思考一下。</p>
<p>    事实上，满足题意的染色方案是存在的，构造方法非常简单，非常直接，非常暴力。显然，无穷等差数列只有可数个，不妨把它们分别叫做A_1, A_2, A_3, …。现在，如果我们能够构造两个数列r_1, r_2, r_3, …和b_1, b_2, b_3…，使得对于每一个i，r_i和b_i都在数列A_i中，并且r数列中的每个数都和b数列中的所有数都不相同。这样，把r数列中的所有数染成红色，把b数列中的所有数染成蓝色（其它未出现的数随意染色），就能保证每个无穷等差数列都包含了至少两种颜色。<br>
    而这样的r数列和b数列显然存在，因为每一次选择新的r_i和b_i时，无穷数列A_i中都只有有限个数不能选，因此r_i和b_i永远都有选的。</p>
<p style="color:blue">    Update: 地基层网友给出了一个更巧妙、更简单的构造方法：对全体正整数倍长间隔染色，即把1染成红色，2和3染成蓝色，4到7染成红色，8到15染成蓝色……。显然，当染色区间的长度大于公差时，等差数列最终都将一截一截地落在不同的染色区间中。</p>
<p><span id="more-1684"></span><br>
    大家可能还记得，这个Blog之前还讲了一个<a href="http://www.matrix67.com/blog/archives/1414">关于稠密点集构造的问题</a>。那篇日志中提到，在平面中存在一个处处稠密的点集，在每个平行于坐标轴的直线上最多只存在一点。该点集的构造方法非常直接，与上面介绍的问题如出一辙。两个例子对照着看看，一种数学思想逐渐开始成形。<br>
    昨天看到一个很好的数学网站<a href="http://prelive.tricki.org/">Tricki</a>，它是一个正在开发中的、介绍各种数学思维方法的、类似Wiki的系统。我随便点开<a href="http://prelive.tricki.org/article/Just-do-it_proofs">一篇文章</a>，立即被震撼到了。这些文章的质量相当高，多个经典例子的对照把内在的数学思想赤裸裸地展示出来。在所谓的“just-do-it proofs”里，我们还看到了一个更绝的例子，它把这种暴力构造法发展到了一个相当牛B的境界。题目很简单：每个竖直或水平的直线上最多只有一点的稠密点集也不再牛B了，现在你能构造出一个平面上处处稠密的，并且任意三点不共线的点集吗？</p>
<p>    要想再次套用上述暴力构造法，困难就在于，此时我们讨论的东西不是可数的，我们需要把它们“离散化”。我们需要回到一些根本性的问题上。究竟什么是稠密性？我们说，平面上一个点集是稠密的，如果对于平面上任意一点p和任意小的正实数ε，总能在点集中找到一点q使得p和q的距离小于ε，那么我们就是该点集在平面上稠密。为了实现离散化，我们需要尽可能用有理数来代替实数。受此启发，我们想到用1/n来代替ε，同时由于有理点（两个坐标均为有理数的点）在平面上已经是处处稠密的了，我们可以只考虑所有的有理数点。下面以每一个有理点为圆心的、分别以1, 1/2, 1/3, …为半径作圆，这就在平面上形成了无穷多个圆盘。由于可数个可数集仍然可数，因此圆盘的数目是可数的，我们可以把圆盘编号为D_1, D_2, D_3, …。只需要保证每个圆盘中都有至少一个点，我们就能保证该点集在平面上处处稠密了。下面，我们在D_1中选择一点p_1，在D_2中选择一点p_2，在D_3中选择与p_1, p_2不共线的一点p_3，在D_4中选择位于前三个点的两两连线之外的一点p_4……注意到有限条直线永远不能覆盖住一个圆盘上的所有点，因此每一次在圆盘中选点时，我们总有点可以选。因此这个过程显然能无限进行下去，最终得到的点集即满足我们的要求。</p>
			 ]]></content>
<pubDate>2009-04-06T16:06:44+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1684</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ IBM Ponder This史上最难谜题：给出谜底猜谜面 ]]></title>
<link>http://www.matrix67.com/blog/archives/1696</link>
<content><![CDATA[ 
		<p>    2009年2月份<a href="http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/pages/index.html">IBM Ponder This</a>的谜题可能是从98年谜题月赛开办以来最难的谜题。谜题发布一个月之后仍然没有任何人答对，主办人不得不宣布延迟一个月，并再三增加提示。最终，答对此题的仍然只有7个人。很久没有看到如此精彩的谜题了，有兴趣的网友不妨试一试。<br>
    题目非常有趣。传统的谜题是给出谜面求解谜底，但这个谜题则恰恰相反：下面这一串数字是某个问题的答案，你能猜出这个问题是什么吗？这串数字里有一个错误在哪里？</p>
<p><code>900F 80F0 8F00 80CA BE12 AA90 9400 0048 3E5B 8AC0<br>
3400 00CB BC81 8A08 3C00 0050 BE43 00C0 3E00 A019<br>
8059 BE13 2000 0092 BE9B 2A0B 2A00 8052 8841 04C0<br>
3E00 840B 084B 0098 E000 8819 845A 8012 0300 0050<br>
826F 0500 0600 846E 8264 0900 0A00 8065 0C00 0072<br>
A054 8368 8569 4800 4400 8573 4200 4100 8349 8542<br>
2800 2400 854D 2200 2100 9F00 E000 8888 8444 8000<br>
0030 0DED 8222 0050 0060 8444 8222 0090 00A0 8000<br>
00C0 0DED A000 8333 8555 4080 4040 8555 4020 4010<br>
8333 8555 2080 2040 8555 2020 2010 8300 8500 8030<br>
8050 0880 0840 8050 0820 0810 8030 8050 0480 0440<br>
8050 0420 0410 8500 8030 8050 0280 0240 8050 0220<br>
0210 8030 8050 0180 0140 8050 0120 0110 90F0 9F00<br>
E000 8888 8444 8000 0003 0DED 8222 0005 0006 8444<br>
8222 0009 000A 8000 000C 0DED A000 8333 8555 4008<br>
4004 8555 4002 4001 8333 8555 2008 2004 8555 2002<br>
2001 8300 8500 8003 8005 0808 0804 8005 0802 0801<br>
8003 8005 0408 0404 8005 0402 0401 8500 8003 8005<br>
0208 0204 8005 0202 0201 8003 8005 0108 0104 8005<br>
0102 0101 9F00 8030 8050 8003 8005 0088 0084 8005<br>
0082 0081 8003 8005 0048 0044 8005 0042 0041 8050<br>
8003 8005 0028 0024 8005 0022 0021 8003 8005 0018<br>
0014 8005 0012 0011 80FF 8F0F A333 8000 5000 0DED<br>
8000 3000 0DED A333 C555 1800 1400 C555 1200 1100<br>
8F0F A333 A555 1080 1040 A555 1020 1010 A333 A555<br>
1008 1004 A555 1002 1001</code></p>
<p><span id="more-1696"></span></p>
<p> <br>
 <br>
    答案：首先我们需要把它转成二进制，并绘制一张宽为16像素、高为255像素的位图。在Mathematica里，只需要四句话就可以完成这一系列工作：</p>
<p><code>st = "900F 80F0 8F00 80CA BE12 AA90 9400 0048 3E5B 8AC0<br>
   3400 00CB BC81 8A08 3C00 0050 BE43 00C0 3E00 A019<br>
   8059 BE13 2000 0092 BE9B 2A0B 2A00 8052 8841 04C0<br>
   3E00 840B 084B 0098 E000 8819 845A 8012 0300 0050<br>
   826F 0500 0600 846E 8264 0900 0A00 8065 0C00 0072<br>
   A054 8368 8569 4800 4400 8573 4200 4100 8349 8542<br>
   2800 2400 854D 2200 2100 9F00 E000 8888 8444 8000<br>
   0030 0DED 8222 0050 0060 8444 8222 0090 00A0 8000<br>
   00C0 0DED A000 8333 8555 4080 4040 8555 4020 4010<br>
   8333 8555 2080 2040 8555 2020 2010 8300 8500 8030<br>
   8050 0880 0840 8050 0820 0810 8030 8050 0480 0440<br>
   8050 0420 0410 8500 8030 8050 0280 0240 8050 0220<br>
   0210 8030 8050 0180 0140 8050 0120 0110 90F0 9F00<br>
   E000 8888 8444 8000 0003 0DED 8222 0005 0006 8444<br>
   8222 0009 000A 8000 000C 0DED A000 8333 8555 4008<br>
   4004 8555 4002 4001 8333 8555 2008 2004 8555 2002<br>
   2001 8300 8500 8003 8005 0808 0804 8005 0802 0801<br>
   8003 8005 0408 0404 8005 0402 0401 8500 8003 8005<br>
   0208 0204 8005 0202 0201 8003 8005 0108 0104 8005<br>
   0102 0101 9F00 8030 8050 8003 8005 0088 0084 8005<br>
   0082 0081 8003 8005 0048 0044 8005 0042 0041 8050<br>
   8003 8005 0028 0024 8005 0022 0021 8003 8005 0018<br>
   0014 8005 0012 0011 80FF 8F0F A333 8000 5000 0DED<br>
   8000 3000 0DED A333 C555 1800 1400 C555 1200 1100<br>
   8F0F A333 A555 1080 1040 A555 1020 1010 A333 A555<br>
   1008 1004 A555 1002 1001";<br>
st = StringReplace[st, {" " -&gt; "", "n" -&gt; ""}];<br>
st = IntegerString[FromDigits[st, 16], 2];<br>
ArrayPlot[Map[FromDigits, Partition[Characters[st], 16], {2}]]</code></p>
<p> <img alt="image placeholder" >
<p>    “BRAILLE”是什么？长期订阅本Blog的网友应该不会陌生，<a href="http://en.wikipedia.org/wiki/Braille">Braille点字法</a>是供盲人阅读的凸点文字，我们曾经在<a href="http://www.matrix67.com/blog/archives/560">另一个谜题</a>中提到过它。Braille点字法比我们想象中的更常用，我有一次就在北京地铁站的扶手上发现了Braille点字。顺着箭头方向看过去，图形右边整齐地分布着一大堆2*3小矩形。这里用到了二级点字，涉及到很多简拼规则，读起来并不容易。</p>
<p><img alt="image placeholder" >
<p>    谜题中隐藏的提示是“msb 0:found 1:question 2 out of 15 in 7 questions”。这句话是什么意思呢？google一下可知，“msb”是“Most Significant Bit”的缩写，表示最高位。根据冒号的位置，我们可以这样理解：当最高位为0时，表示“found”；当最高位为1时，表示“question 2 out of 15 in 7 questions”。用7个问题从15个里面问出两个？这让我们想到一大堆交互式问题。<br>
    事实上，包括上述Braille点字提示在内的所有255个16位整数都是一个交互式问题的解答方案。假设我们有15个球，其中两个有放射性。你需要利用一种放射性检测仪器找出这两个球。每次你可以选取若干个球放入仪器中，仪器会告诉你这些球中有没有具有放射性的球。由于这个仪器十分昂贵，因此你需要用最少的次数来找到这两个球。最少需要多少次操作呢？信息论告诉我们，15个球中有两个放射性球共C(15, 2)=105种情况，7次“是非反馈”能区别2^7=128种情况，因此询问7次已经足够了。这255个16位整数告诉我们应该如何进行询问。这些数按照先序遍历的顺序对所有情况进行编码，例如第一行中1001000000001111表示把第1、2、3、4、13个球放入仪器，余下的所有行中，前一半表示仪器显示没有放射性的情况，后一半就表示有放射性的情况。最高位为0的数都是叶子结点，表示放射性的球已经找到，例如最后一行0001000000000001就表示第1个球和第13个球是放射性的。7次询问只是最坏情况，很多时候我们并不需要7次询问；这就提供了一些插入“废询问”的机会，而这些“废询问”恰好可以用于编写一些提示信息（就是我们先前看到的Braille点字）。不幸的是这个提示信息太长，它所占据的空间超出了“废询问”区间——例如第19个数3E00其实应该是6000，这是为了显示出字母“L”而改的。这就是题目中所说的那一个错误。</p>
			 ]]></content>
<pubDate>2009-04-09T14:49:40+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1696</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ （号外）两个期待已久的创意动作解密游戏已发布 ]]></title>
<link>http://www.matrix67.com/blog/archives/1705</link>
<content><![CDATA[ 
		<p><object width="600" height="345"><param name="allowfullscreen" value="true">
<param name="allowscriptaccess" value="always">
<param name="movie" value="http://vimeo.com/moogaloop.swf?clip_id=4083982&amp;server=vimeo.com&amp;show_title=1&amp;show_byline=1&amp;show_portrait=0&amp;color=00ADEF&amp;fullscreen=1">
<embed src="http://vimeo.com/moogaloop.swf?clip_id=4083982&amp;server=vimeo.com&amp;show_title=1&amp;show_byline=1&amp;show_portrait=0&amp;color=00ADEF&amp;fullscreen=1" type="application/x-shockwave-flash" allowfullscreen="true" allowscriptaccess="always" width="600" height="345"></embed></object></p>
<p><a href="http://braid-game.com/">Braid</a>是一个时空解谜类游戏，画面和音乐都很赞，本Blog之前曾经<a href="http://www.matrix67.com/blog/archives/644">特别介绍过</a>。游戏的Xbox版本早已发布，最近发布了PC版。<br>
先给出两个下载地址，我正在下，测试完毕后再来更新。<br>
<a href="http://verycd.com/topics/2740778/">http://verycd.com/topics/2740778/</a><br>
<a href="http://www.mininova.org/tor/2474081">http://www.mininova.org/tor/2474081</a></p>
<p style="color:blue">Update: mininova的那个装不上，因为bat文件里面有些命令不认识，什么原因我还没仔细研究；现在在玩VeryCD的那个，是RAS压制小组的，不喜勿下。游戏画面非常独特，内涵相当丰富，即使是中文版（官方的）也不失原味，因此这个游戏很适合和MM一起玩。我的机器上玩起来巨慢，到了世界3要稍微好一些。这个游戏有希望与Portal、World of Goo一道，成为我最爱的三大动作解谜游戏。</p>
<p><span id="more-1705"></span><br>
<a href="http://www.andyetitmoves.net/">And Yet It Moves</a>是一个独特的Jump ‘n’ Run游戏——你可以旋转整个场景以改变重力。最近该游戏发布了正式版，可惜目前我找到的唯一一个下载的地方似乎是<a href="http://hx.hxgame.net/showdown.asp?ID=2593">hxgame</a>。我就不当小白鼠了，希望有网友能挖出一个纯净一点的版本来。</p>
			 ]]></content>
<pubDate>2009-04-11T22:00:50+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1705</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 数学无处不在：语言、文字与数学 ]]></title>
<link>http://www.matrix67.com/blog/archives/1727</link>
<content><![CDATA[ 
		<p style="color:red; font-weight:bold">（拜托转载时请用红色加粗字体标明，这是我古今数学思想课的期中论文，免得老师以为我是反过来抄的网上的文章。这门通选课的期中论文要求写数学与自己所在专业之间的联系。）</p>
<p>    我们每天都在说话，每天都在用语言进行交流。语言文字对我们是如此的平常，以至于绝大多数人都不会注意到语言中一些非常难以解释的现象。昨天的汉语虚词研究课上，我们就谈到了这样一个有趣的问题：在表示“仅仅”的含义时，什么时候能够用“只”，什么时候能够用“光”？若不细想的话，大家或许会认为两者的用法完全一样。“我只吃苹果”可以说成“我光吃苹果”，“光有知识还不行”也可以说成是“只有知识还不行”。我们还可以举出更多的例子来，如“别光坐着”/“别只坐着”，“光说不做”/“只说不做”等等。凭借天生的归纳性思维，一个正常人有充分的理由猜想，在表示“仅仅”的含义时，“只”和“光”是通用的。而事实上，现代汉语词典中正是把“光”字解释为“只”。有趣的是，在我们质疑只找了四个例子是否足以说明二者等价时，殊不知这句质疑本身就成了一个反例：“只找了四个例子”不能换成“光找了四个例子”。类似地，“大会只来了748个人”也不能说“大会光来了748个人”。我们继续猜想，是不是“光”不能用在数量词前面呢？也不见得。当数量词不是实指而是虚指时，我们有时也能用“光”来修饰带有数量词的名词。例如，在表示“只吃几个苹果”、“只吃一些苹果”的意义时，“光吃两个苹果”的说法是很顺口的。另一些例子则表明，“光”的用法似乎与它所修饰的名词无关。“我只当到团长”不能说成是“我光当到团长”，但怪就怪在“我只认识团长”却又偏偏可以说成是“我光认识团长”。“当到团长”和“认识团长”有什么不同呢？仔细揣摩两者的意思，我们似乎体会到了一些微妙的差别：“当到团长”是一个阶段性的、进度性的、里程碑性的概念，它必须事先经过“当到连长”、“当到营长”等事件；但“认识团长”就不一样了，没有任何规定限制我们在“认识团长”之前必须“认识连长”。同样的，“找出四个例子”是以“找了三个例子”为前提的，“来了748个人”也不是一下子就能实现的。</p>
<p>    问题算是想通了，但怎么来阐述它呢？在这个问题上，语言学陷入了一个困境。此时，引入数理逻辑语言对于解释这种语言现象出乎意料的方便。我们说，在副词“只”修饰的事件所处的“域”中如果存在蕴含关系，则这里的“只”不能用“光”来替代。例如，提起“吃两个苹果”，我们脑海中形成的事件集合一定是“吃一个苹果”、“吃两个苹果”、“吃三个苹果”等等，而后者必然蕴含前者，因此“只吃两个苹果”不能说成“光吃两个苹果”。类似的，“当到团长”必然推出“当到连长”，但有“认识团长”不见得有“认识连长”，因此两者与“只”和“光”的搭配情况是不同的。</p>
<p><span id="more-1727"></span><br>
    有人或许会说，为什么不直接说这是由“事件发生有无必然的先后顺序”所引起的？事实上，不仅仅是事件先后顺序，在更抽象的领域里，上述理论同样起作用。例如，我们可以说“x只是一个有理数”，但绝不会说“x光是一个有理数”，原因就在于，“x是整数”、“x是有理数”、“x是实数”等事件是有蕴含关系的，虽然它们之间并没有时间先后的联系。</p>
<p>    在研究语言学，特别是语义学时，数理逻辑符号能够如此有效地解决问题，以至于语言学家们完全借用了整个数理逻辑体系，开创了一个语言学分支叫做“形式语义学”。形式语义学不但把自然语言中的个体、行为、联结词、谓词进行符号化，还引入了一些新的符号来表示会话中一些更加复杂的情形。例如，“明天可能要下雨”是真的，但“昨天可能要下雨”就不见得为真了。但由于数理逻辑中没有“可能算子”，这种普遍的会话将得不到数理逻辑形式。至于一些的确存在真假但却很可能永远无法判定其真假的命题，如何确定其语义形式就更加困难了，例如“Goldbach猜想可能是真的”、“当初Fermat可能根本就没有证到Fermat大定理”。还有一种更特殊的情况：假如一个人说“微积分的创立完全有可能提前100年”，虽然与事实相悖，但从会话目的上看这句话确实为真。为了解决这些问题，形式语义学引入了模态算子，将命题的“真值”扩充为可能的、必然的、偶然的（可能但不必然的）三种，这种可能性通常解释为“所有逻辑上可能的平行世界中是否成立”。如果在某些世界中命题成立，我们称之为“可能的”；如果在所有的世界中命题均成立，我们称之为“必然的”；如果命题在我们所处的世界中碰巧为真，但在其它世界中不见得为真，这就被归为“偶然的”。模态算子有两个，□算子（必然算子）和◇算子（可能算子），它们之间存在关系□p↔¬◇¬p和◇p↔¬□¬p。另一些常用的公理有□p→p、□(p→q)→(□p→□q)、p→□◇p等等。有了这些符号，数理逻辑便可以用于解释各种会话场合中的语句。</p>
<p>    利用形式语义学，自然语言中的含混和歧义能够被非常有效地消除，便于深入研究语义关系，也便于将其转化为计算机能够理解的语言。语言学家甚至借用数学中的公理化方法，构建了公理语义学体系，将语义推导的过程彻底地程序化。</p>
<p>    学科之间的促进作用永远是相互作用的。上个世纪初，在语言学迅猛发展之时，语言学家借用并且发展了数理逻辑符号，促使数理逻辑模态算子的产生。但是，估计语言学家们再怎么也不会想到，随着计算机的发展，数学科学反过来解决了语言学中的一些大问题。</p>
<p>    随着网络的高速发展，搜索引擎系统急需要开发出一套中文分词技术。如何用计算机将一句话中的词语切分出来？建立一个词典并不难，难就难在当划分方案不止一种时该如何取舍。上世纪末，不少人都在这个课题上做过尝试。一种比较好想的算法是，从前往后不断匹配最长的单词。很多场合下这种方案都是可行的，但算法的反例也有不少，例如“北京大学/生活/动/中心”显然错了，这句话其实应该划分为“北京/大学生/活动/中心”。还有人曾经提出过“最少词语切分方案”，即当一句话有多种切分方案时，取词语数最少的方案。这种方案的效果也不好，例如“我/也/考虑/过去/北京”显然不对，正确的应该是“我/也/考虑/过/去/北京”。</p>
<p>    统计语言模型出奇简单地解决了这个问题。假设x_1, x_2, …, x_n是一个分词结果，我们想要计算该序列是一个合法句子的概率P(x_1, x_2, …, x_n)，它相当于P(x_1)·P(x_2|x_1)·P(x_3|x_1,x_2)·……·P(x_n|x_1,x_2,…,x_n-1)。为了使问题变得更加简单，我们采用Markov假设，认为一个词出现的概率仅仅与它前面那个词有关。于是有P(x_1, x_2, …, x_n) = P(x_1)·P(x_2|x_1)·P(x_3|x_2)·……·P(x_n|x_n-1)，而每个P(x_i|x_i-1)的值（词语x_i出现在x_i-1之后的概率）都可以在分析了大量语料之后统计得出。接下来，我们只需要在众多切分方案中选择成句概率最高的那一个即可（这一最优化问题还可以利用动态规划进行加速）。</p>
<p>    这一个模型异常简单，但实际效果出人意料的好。事实上，这一模型不但解决了分词问题，连语音识别、多音字注音、输入法智能成句输入等问题都一并解决了，识别准确率提升了一个数量级。</p>
<p>    数学思维已经不止一次帮助人们设计语言文字的机器处理算法了。这里我们还可以再看看拓扑学在文字识别方面的贡献。OCR是一种能够把以图片方式储存的文字信息转换为文本的技术，它可以用于将打印稿成批地扫描并还原回文本文件。设计OCR系统的一大难点是，即使图形近似匹配算法能够非常准确地识别出文字，若每处理一字就要与字库中的上万个字一一匹配，其处理速度无论如何也不能投入实际应用。一种容易想到的权宜之计便是首先匹配字库中的常用字，若匹配成功则继续处理下一个字。这种办法并不能从根本上解决问题。另一种颇具启发性的想法便是将字库中的字形按照所占平面空间的多少进行排序分类。这可以在一定程度上缩小匹配检索的范围，速度有了一些提升。此时，拓扑学再一次显示出了它强大的力量。我们可以从拓扑不变量出发，寻找字形的本质特征，把字库中的每个字进行编码分类。例如，“估”字就是一个有两个连通分量、一个环、两个度为三的点、一个度为四的点组成；或者通俗地说，“估”字有两个相互分离的部份，有一个“洞”，有两个三叉路口，有一个四叉路口。我们就把“估”字编码为2121。对于一些模棱两可的字形，不妨允许它存在多个编码，同属于几个不同的组。识别文字时，我们只需要计算出该字的编码，然后尝试和字库中有相同编码的字形进行匹配即可。这种算法简洁、美观而有效，并且更加神奇的是，这种算法能够直接用于各种不同的字体，甚至当图片上的文字倾斜、颠倒、大小不一甚至扭曲时该算法仍然能够有效地分析出文字的结构。拓扑思想又一次向人们展示出了它那独特的魅力。</p>
			 ]]></content>
<pubDate>2009-04-16T15:59:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1727</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：任何正整数着色方案中都含任意长的单色等差数列 ]]></title>
<link>http://www.matrix67.com/blog/archives/1738</link>
<content><![CDATA[ 
		<p>    我们知道，存在这样一种全体正整数的红蓝二着色方案，其中没有任何无穷长的等差数列满足数列中的所有数颜色都一样。<a href="http://www.matrix67.com/blog/archives/1684">它的构造</a>非常暴力。有趣的是，把上述命题中的“无穷长”换成“任意长”，命题就不见得仍然正确了。事实上，<a href="http://en.wikipedia.org/wiki/Van_der_Waerden%27s_theorem">Van der Waerden定理</a>告诉我们，对于任意大的k，总存在一个N，使得对从1到N的正整数进行红蓝二染色后，里面总存在一个单色的长为k的等差数列。当命题扩展到任意c着色时，该命题竟然也都成立。证明主要用了鸽笼原理和数学归纳法，证明过程直观而又有趣。</p>
<p>    我们首先来证明k=3的情况：存在某个N使得对N个连续自然数进行二染色后里面总有长为3的单色等差数列。我们把全体正整数5个5个地分组，1..5为第一组，6..10为第二组，以此类推。每一组里总共有2^5种不同的染色方案，因此在前2^5+1组里面必然有两个组的染色一模一样，比方说第7组和第23组吧。把第7组里的数记作A_1, A_2, …, A_5，由鸽笼原理，A_1, A_2, A_3里面一定存在两个颜色相同的数，不妨设A_1和A_3都是红色吧。考虑A_5的颜色：如果它是红色，我们的问题就解决了，A_1, A_3, A_5已经是一个长度为3的等差数列。下面考虑A_5是蓝色的情况。别忘了第7组和第23组的染色完全相同，因此在第23组中，B_1, B_3也是红色，B_5也是蓝色。下面我们来考虑全体正整数的第39组（7,23,39是等差数列），我们把它记为C_1, C_2, …, C_5。考虑C_5的颜色：如果它是红色，那A_1, B_3, C_5就是一个全为红色的等差数列，否则A_5, B_5, C_5就是一个全为蓝色的等差数列。显然，上述证明中的“最坏情况”就是，第1组和第33组的染色相同，且第1组的第1个数和第33组的第3个数是红色，则下一个数最远可以是第65组的第5个数，即全体正整数的第325个数。换句话说，k=3时N=325即满足条件。</p>
<p><span id="more-1738"></span><br>
    有意思的是，上述证明不但对“二着色”成立，对所有“c着色”上述证明都适用。比方说，对于c=3时，取n=7(2·3^7 + 1)，把全体正整数n个n个分为大组，在头3^n+1组中必然存在两个染色一样的组，记作大组A和大组B。把这两个大组里的数分别都7个7个地分成2·3^7 + 1个小组，在头3^7+1组中，必然有两个小组的染色方案一模一样，比如小组a和小组b。</p>
<p><img alt="image placeholder" >
<p>    在每一个小组的前4个数中，必然有2个数的颜色是相同的，比如说第1个数和第4个数是红色吧。那这个小组里面的第7个数要么是红色（问题已解决），要么是另一种颜色（比如蓝色）。那么，与前两个小组构成等差序列的第三个小组（记作小组c，由于一个大组中有2·3^7+1个小组，因此小组c一定还在该大组中）中的第7个数要么是红色（问题已解决），要么是蓝色（问题已解决），要么是剩下的那种颜色（比如黄色）。那么，与两个大组构成等差序列的第三个大组（记作大组C）中，对于相应的小组c位置上的第7个数的颜色就没有任何选择了，它或者和每个大组的那个染黄色的数成等差数列，或者和大组A的小组a的蓝色数、大组B的小组b的蓝色数构成等差数列，或者最牛B的，和大组A的小组a的第1个红色数、大组B的小组b的第2个红色数构成等差数列。</p>
<p>    类似地，对于更大的颜色数c，我们都可以归纳证明，只不过递归分组的层数更多，底数也相应的变大。因此，我们解决了k=3且c任意大的情形。</p>
<p> <br>
    真正牛B的是对k的归纳证明。我们下面尝试证明k=4、c=2的情况。由于当k=3时每325个数里面必然有一个等差数列，因此我们按每487个数一组进行分组。这样可以保证每一组里面的前325个数中总存在长为3的单色等差数列，并且该数列的第4个数也在该组内。注意，一个487元组共有2^487种染色方案，如果我们把它们看作2^487种不同的“广义颜色”，由k=3、c=2^487的情况知，必然存在3个组，这3个组的编号形成等差数列，并且它们的染色方案完全相同。于是我们考虑每一组中前325个数所形成的长为3的等差数列，并考虑该数列中第4个数的颜色：如果颜色相同，问题解决，否则便考察顺推下去的第4个组的相应位置上的数的颜色，它将别无选择。<br>
    类似地情况，我们可以归纳出任意大的k和任意大的c的情形。可想而知（或者说难以想象），用这种做法得出的N是何等的巨大，它将很快超出整个宇宙中任何具有实际意义的数字，其大小已经<a href="http://www.matrix67.com/blog/archives/925">不能用通常的方式来记录</a>了。不过，再大的N也是有限的。这个证明牛就牛在他的气势之宏大，以至于很多人都不敢想……当我读到2^487种颜色时，视野一瞬间广大得难以描述；并且当我向着k更大的方向看去时，不禁对数字表示深深的膜拜。</p>
			 ]]></content>
<pubDate>2009-04-17T16:31:15+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1738</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 我目前所见过的最难的IQ测试题 ]]></title>
<link>http://www.matrix67.com/blog/archives/1749</link>
<content><![CDATA[ 
		<p>    网友Qian Yongchao发来邮件说，他在阅读当前正大红大紫的一本书叫做Outliers。书中谈到IQ测试时，作者提到了Raven’s Progressive Matrices测试法。这是一系列从易到难的题目，一般有48道题。为了说明这种测试可以有多难，作者给出了整个测试的最后一道题，这道题目即使作者自己也不知道该怎么做。我在网上搜索了一下，确信书上印的题目是错误的。其实，那道题就是<a href="http://iqtest.dk">iqtest.dk</a>上的那个火星IQ测试的最后一题。这个题确实很难，无数人都卡在这上面死活想不明白。</p>
<p><img alt="image placeholder" >
<p><span id="more-1749"></span><br>
    答案是B。原因：<span style="color:#e5e5e5">每一个正方形通过三个步骤变成它右边那个正方形。首先，循环右移所有的列；然后，循环下移第一列；最后，循环替换所有的形状（×变○、○变▲、▲变×）。另外，从一行末到下一行头也是有规律的，即整个正方形顺时针旋转90度。</span></p>
<p>    然而，这并不是我见过的最难的IQ测试题。很早以前，我见过一个叫做Haselbauer-Dickheiser Test的测试，这是我目前所见到的最难的IQ测试题目。它是专门供智商超过180的人进行测试的，官方仅建议全世界IQ最高的那1%的人进行挑战。奇怪的是，这个测试现在居然找不着了，官方网站上似乎已经删掉了测试页面。所幸当年我自己保存过一份全部题目，现在发出来与大家分享。大家可以直接上<a href="http://www.matrix67.com/iqtest/">www.matrix67.com/iqtest</a>看到全部25个题目。</p>
			 ]]></content>
<pubDate>2009-04-18T01:50:06+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1749</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 漂亮的排序算法：7种排序算法的内存状态演示 ]]></title>
<link>http://www.matrix67.com/blog/archives/1763</link>
<content><![CDATA[ 
		<p>昨天我突发奇想，写了几段Mathematica代码，生成了各种排序算法的内存变化图。图中每一个新的横行都表示数组的一次更新，数字大小用颜色来表示。你可以直观地看到这些算法是如何把乱序数组一点一点变为有序的。效果还是很令人满意的，不少算法的内存轨迹都相当美观，相当有艺术性。</p>
<p>图很大，我就不在首页上显示了，大家点“查看更多”看图吧。</p>
<p><span id="more-1763"></span></p>
<p> <br>
<img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-04-20T16:27:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1763</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：寻找策略使得总有一人猜出他背上的数 ]]></title>
<link>http://www.matrix67.com/blog/archives/1768</link>
<content><![CDATA[ 
		<p>正在上虚词研究课，好友Chain发来短信说，北大BBS化学学院版上发了一道<a href="http://bdwm.net/bbs/bbstcon.php?board=CCME&amp;threadid=2334788">很有趣的谜题</a>，已经上十大热门话题第三了。我也是第一次看到这个题目，和大家分享一下。</p>
<blockquote><p>话说周一某实验室有16名同学，有一天*老师把大家叫到一起说：下周来做实验的时候，我会给你们每个人背后贴一张纸，纸上的数字从1到16都有可能，不同同学背后的数字可以重复。你们每个人可以看到别人背上的数字，但不能看到自己的数字。贴纸之后你们之间不允许进行任何形式的沟通交流。之后你们排队依次来D***，告诉我你自己背后的数字是多少；由于D***室隔音效果很好，室外的人不能听到室内的同学的说话声（更好的说法是，每个人独自在一张小纸条上写下猜测结果，这就避免了可能由排队猜数的时间和顺序带来的“交流”）。等到16名同学都猜完之后公布结果。只要你们16个人中间能有一个人猜对自己背后的数字，我会让大家都得满分；但如果你们都没有猜对自己背后的数字的话，则你们全部都要重修有机实验。那么你要怎样做才能避免挂科的命运呢？</p></blockquote>
<p>这道题目很有意思，看答案之前不妨自己先想一下。<br>
提示：<span style="color: #E5E5E5;">先从两个人的情况开始想起。</span></p>
<p><span id="more-1768"></span></p>
<p>答案：<span style="color: #E5E5E5;">为了下面叙述的简便，我们把数字1到16简单地替换为0到15。游戏前，大家按某种顺序给所有人从0到15依次编号。游戏开始后，每个人把自己能看到的15个数与自己的编号一起异或起来（按位异或），在猜数时报出这个异或的结果。这个方案能保证总有一个人恰好报出自己的数。假设这16个数异或起来的结果为X（显然0 ≤ X ≤ 15），第i个人身上的数记为A_i，那么他猜的数其实就是X xor A_i xor i。那么，编号为X的人（此时i=X）报出的数恰好就是他背上的那个数。对于数字1到16的情况，只需要在计算前后减一加一即可。</span><br>
<span style="color: #E5E5E5;">这个问题可以从n=2的情形很快入手。当n=2时，只需其中一个人报和对方一样的数，另一个人报和对方不一样的数即可。</span></p>
<p>一些类似的趣题：<br>
<a href="http://www.matrix67.com/blog/archives/456">http://www.matrix67.com/blog/archives/456</a><br>
<a href="http://www.matrix67.com/blog/archives/511">http://www.matrix67.com/blog/archives/511</a></p>
			 ]]></content>
<pubDate>2009-04-21T17:15:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1768</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 漫话科学哲学：什么是科学解释？ ]]></title>
<link>http://www.matrix67.com/blog/archives/1788</link>
<content><![CDATA[ 
		<p>    小时候我就很喜欢思考一些科学之外的东西。数学家发现新定理，物理学家提出新理论，发明家创造新事物，自以为无所不能的科学似乎已经统领了整个人类历史的发展。但是，谁又来思考科学本身呢？于是我常常幻想，如果当初科学没有战胜宗教，世界又将怎样？人类依旧停留在穷困的黑暗社会？还是与大自然和睦相处过着无忧无虑的幸福生活？甚至是凭借直觉和信仰建立了一套能够自圆其说的物理体系，虽然这套体系和我们现有理论大相径庭？无论怎样，如果我们当真生活在宗教胜出的那个平行世界中，我们不但不会质疑这个问题，相反还会问自己如果科学战胜了宗教的话生活会变得多么不可思议。因为“科学”的定义变了。<br>
    我们到底应该如何获取知识，如何探索世界，在这个根本问题上的分歧形成了不同的“科学范式”。一个科学范式下理所当然的东西在另一个科学范式下可能变得无比荒谬，因为它们在科学发展的最底层就已经有了矛盾。当宗教统治人类历史时，宗教便是“科学”；外人看来再不合理的事情，只要是在自己圈子里发展出来的，怎么看都再正常不过。宗教与科学之争其实是两个科学范式之间的战争，它们的争端永远没有办法解决，因为各自的理论在各自的研究方法之下都是正确的，它们本身并无对错之分，谁也说服不了谁。我们或许期待着有那么一套“算法”作为法官来评判哪个科学范式更好，不幸的是这个法官本身所代表的就是第三种科学范式，争端不但没有任何缓和，反而扩大了。<br>
    前几天刚看完《科学哲学》这本书。科学哲学很有意思。这里我举一个有趣例子来说明，科学哲学问题相当值得思考。</p>
<p><span id="more-1788"></span><br>
    究竟什么才算科学呢？科学究竟是拿来干什么的呢？稍作思考，我想一定有不少人会说，科学是一套可以对我们周围所发生的事情做出解释的系统。不妨把这个系统的每一次应用都叫做一个“科学解释”。究竟什么又是“科学解释”呢？有数学思维，特别是学过数理逻辑的人会想到公理化体系。科学哲学家Carl G. Hempel也是这么想的。他认为，科学解释就是回答一个现象为何发生，这个“回答”必须满足三个条件：一、前提保证可以推出结论，即论证应该是演绎推理；二、前提应该全部为真；三、前提应该至少包含一个普适定律。通俗地说，普适定律就是形如“所有的什么什么都怎么怎么样”的命题，它就像公理一样，是所有人普遍接受的事实。Hempel对科学解释所做出的诠释似乎无懈可击，环视周围正在发生的现象，套用Hempel的理论屡试不爽。书桌上的花为什么死了？因为我的书桌位置太偏僻，无法接收充足的阳光照射；而阳光是植物进行光合作用所必需的；并且没有光合作用，植物将无法制造碳水化合物；而植物缺少碳水化合物将致使其死掉。不小心把手机碰出桌面，为什么会掉在地上？因为地球上所有物体都会受到一个垂直向下的重力，而我的手机失去了桌面的支撑力，因此手机的合力不为0；而不为0的合力将给予物体一个与力的大小成正比的加速度，并且我的手机原本是静止的，因此我的手机将沿重力方向加速运动。<br>
    有趣的是，这个模型是有问题的。在继续读下去之前，不妨先稍作思考。你能想出一些不符合该模型的例子吗？</p>
<p> <br>
    假设我的桌子上直立着一把尺子，我想知道为什么桌面上的影子有20厘米长。这是可以用科学来解释的：因为尺子的长度是20厘米，而桌上的台灯以45度角照射着尺子；由于tan(45°)=1，利用三角学知识可以计算出桌子上会留下一个20厘米长的影子。在这个例子中，“20厘米长的尺子”是一个前提，“45度角的灯光”也是一个前提，三角学知识和45度角的正切值都是普适原理，通过演绎推理可以得到我们的结论。一切都很符合Hempel的科学解释模型。有意思的事情出来了。让我们换一个问法：为什么我的尺子有20厘米长？我们可以说，因为桌上有一个20厘米长的影子，而灯光正以45度角照射着，根据三角学知识和45度角的正切值可知尺子的长度也是20厘米。注意到，用“20厘米长的影子”、“45度角的灯光”、三角学知识和tan(45°)=1确实可以推出我的尺子有20厘米长，所有前提都为真并包含了普适原理。不过，这并不是“我的尺子有20厘米长”的科学解释。这个问题的真正科学解释是——文具制造机器把它做成了20厘米长。可想而知，手机跌落也不能反过来解释手机没有了支撑力，花儿死了也并没有导致书桌上照射不到阳光。A解释了B，B自然不能反过来解释A，即使A和B是等价的、相辅相成的。<br>
    另一个更荒谬的、更能体现问题实质的例子是，我为什么连续30多天都没来月经（不知在以后的日子里会有多少人因为搜“没来月经”访问到这个页面）？我可以说，这几天正值期中，我要应付很多论文和考试，精神持续紧张，压力非常大；而精神压力会抑制脑下垂体的功能，可能会推迟月经，因此我有可能连续30天以上没来月经。上面的例子中，“我的精神压力大”是前提，“精神压力影响脑下垂体功能”和“脑下垂体影响月经”都是普适定律。由这些前提和定律确实可以推出我们所要的结论。事实上，这几天真的是期中，我真的在忙着赶论文，Blog又是三天没更新了，因此前提也确实都是真的。不过，这一套推理并不是“我30多天无月经”的科学解释。这个问题真正的科学解释是——我是男的，而男人是没有大姨妈的。</p>
<p>    可见，科学解释并不仅仅是一个公理化体系能够说明得了的。上面两个例子的问题到底出在哪儿呢？大家可能很快想到，演绎逻辑与现实生活的差别就是：A确实可以推出B，但并不是A导致的B。问题的本质就在于我上文竭力想避免的一个词：因果联系。我们试图用数理手段给科学解释下定义，不料最终又回到了古老的哲学问题上。究竟什么是“原因”呢？这个世界是由因果关系支撑的吗？当量子理论发展到今天时，我们很难再用平常的眼光来看待因果律。于是，我们再一次回到了起点。没有一个能够判断哪个范式更科学的法官，即便以对现象的解释为标准来衡量科学范式，这个标准本身是什么也存在问题，不同的科学范式之间不可能统一出一个“科学解释”的标准来。<br>
    科学究竟是什么？我们或许还是了解得太少。</p>
			 ]]></content>
<pubDate>2009-04-25T00:36:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1788</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：列表染色与可选择数（上） ]]></title>
<link>http://www.matrix67.com/blog/archives/1798</link>
<content><![CDATA[ 
		<p>    四色定理告诉我们，给地图上的每个区域涂一种颜色，为了使相邻的区域有不同的颜色，我们总共只需要4种颜色就够了。不过，万一有些省装怪，偏不喜欢分配给它的颜色该咋办？这下问题就变得有意思起来了。为了满足不同省市的要求，国家测绘局可以在为地图染色前先让每个省市列出自己能够接受的几种颜色，染色时就只从每个省市给出的候选颜色中取色。我们把每一个使得相邻区域的颜色互不相同的染色方案叫做一种列表染色(list coloring)。现在的问题是，至少要求每个省市列出多少个候选颜色才能使合法的列表染色总是存在，不管这些颜色列表是什么？如果每个省市列出k种颜色就足够了，我们就称该地图是可k选择的(k-choosable)。或许大家会想，k=4就够了吧，毕竟四色定理保证了只使用4种颜色一定能实现合法的染色，而在列表染色问题里总的颜色很可能还不止4种，同时相邻区域的公共颜色数量也将减少。但是，数学家们早就注意到，能够k着色的平面图不见得就一定可以k选择。例如，下面这个图显然可以二着色，但它就不是二选择的——如果每个区域的颜色列表如图中所示，则不存在满足要求的列表染色。因此，人们普遍认为，并不是每个平面图都是可4选择的。</p>
<p><img alt="image placeholder" >
<p>    不过，数学家们一直没能找到不可4选择的平面图。1993年，Voigt发现了第一个不能4选择的平面图，它有238块区域。构造方法非常具有启发性，从里面能看到不少数学思维方法。</p>
<p><span id="more-1798"></span><br>
<img alt="image placeholder" >
<p>    来看看这个图是怎么构造的。整个图是建立在图1的基础上的，它有10个区域，每个区域的颜色列表都是(1,2,3,4)。图中有12个顶点打了一个小圆圈标记，这12个顶点都是两块白色区域和一块阴影区域的交界处。在每个这样的交界处“挤”进去一块新的区域，如图2。新区域的颜色列表也是(1,2,3,4)。</p>
<p><img alt="image placeholder" >
<p>    我们以A、B、F三块区域的交界处为例。挤进去一个区域P后，图形中又产生了两个阴影部分与白色部分的交界点，我们也用小圆圈来标记。再在区域A、P、F间挤进去9块区域，如图3所示；在区域B、P、F的交界处插入图3的镜像，即让图3的F和P等于图2的F和P，图3的A则相当于图2的B。对图1的那12个交界点中的每一个都进行这样的操作，我们便得到了一个有10+12*19=238块区域的图形。</p>
<p><img alt="image placeholder" >
<p>    下面我们说明，这个地图没有合法的列表染色方案。这个构造的核心就在于，我能强制某个区域涂上指定的颜色，从而制造一些冲突。在图1中，区域A、B、C、D两两相邻，因此一定有一个区域涂了颜色1。如果A是颜色1，注意A、B、D、E也是两两相邻的四块区域，则B、D、E只能分别着颜色2、3、4，那么区域L一定染颜色1；如果B是颜色1，类似地可知M一定是颜色1；如果D是颜色1，同样区域F一定是颜色1；最后，如果C是颜色1，由于C、B、D、T两两相邻，因此B、D、T分别涂颜色2、3、4，区域N只能是颜色1。总之，图中的4个阴影部分中必然有一个涂了颜色1。无妨假设F染了颜色1。注意它周围一圈三块区域分别是颜色2、3、4，这三块区域两两相邻。标出颜色2和颜色3所属的区域，无妨假设是A和B（即A=2、B=3，或者A=3、B=2）。无论如何，A、B、F中间的区域P的颜色都是4。</p>
<p>    假设A=2、B=3。如图3，A、F、P的颜色都已经固定了，并且T1、T2、T3都只剩下(3,5)两种颜色可选，X、Y和四块斜线区域都只剩下(3,5,6)可选。考虑X的颜色，若它选了6，则周围一圈区域R1到R4只能分别是3、5、3、5或者5、3、5、3，无论如何T1都没有颜色可选；若X选了5，则R1到R4只能是6、3、6、3（此时T3无从选择）或者3、6、3、6（此时Y只能选5，T2将无从选择）；最后，若X选择颜色3，类似地要么T3没有可选的颜色，要么T2没有可选的颜色。该图没有合法的列表染色。<br>
    再考虑A=3、B=2的情况。于是B、F、P的颜色都固定了，并且它内部的情况与图3（的左右镜像）完全一样。于是我们证明了，整个图都是不能4选择的。</p>
			 ]]></content>
<pubDate>2009-04-27T19:28:57+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1798</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：均匀分布且和为常数的n个变量 ]]></title>
<link>http://www.matrix67.com/blog/archives/1810</link>
<content><![CDATA[ 
		<p>    不知道大家有没有幻想过，数学中是否存在这样一个牛B的问题，发表出来后十几年硬是没有一个人解开；后来某人惊奇地发现，它有一个极其精妙的解答，整个解决过程只需要几句话就能说清楚，但它实在是太巧妙了，这么多年就没有任何人想到。最近我就遇到了这样的事情。<a href="http://www.brand.site.co.il/riddles/200903q.html">3月份UyHiP的题目</a>非常有趣，整个证明几句话就完了，但想到解法的却只有一人。<br>
    题目描述也极其简单。对于哪些n，存在一种生成n个随机变量的算法，使得它们在0和1之间均匀分布，且它们的和是一个常数？更进一步，如果这n个变量中任意k个都相互独立，满足要求的k最大是多少（表示成关于n的函数）？</p>
<p>    当然，这道题目我也没想出来。答案公布前，我思考了很久，最后还是放弃了。显然n是偶数时这样的算法是存在的，例如当n=6时，只需要先独立地选取3个随机变量X_1, X_2, X_3，然后令X_4 = 1 – X_1，X_5 = 1 – X_2，X_6 = 1 – X_3即可。这可以保证6个变量之和总为3，且它们均匀地分布在[0,1]区间里。但是当n是奇数时，满足要求的算法就未必存在了。例如当n=3时，不妨让X_1和X_2随机取，X_3等于1.5 – X_1 – X_2。这种算法似乎很和谐，问题就出在X_3有可能不在0和1之间。那么，重复执行该操作直到返回一个落在[0,1]里的X_3呢？这样的话变量又不是均匀分布的了，这将让变量更容易取到中间去，因为X_1和X_2太小或太大往往算不出合法的X_3（下图是Mathematica模拟的结果）。我试图从“n个变量的和的期望值是n/2”出发，证明和为1.5的3个变量不可能均匀分布在0到1之间。不过，最终还是没有找到突破口。</p>
<p><span id="more-1810"></span><br>
<img alt="image placeholder" >
<p>    在上面n为偶数的情况下，有n/2对不独立的变量。是否有可能每一对变量都互相独立呢？很多人估计想，这怎么可能，既然总和要求相等，各个变量之间必然会相互依赖、相互限制。而事实上，如果这些变量可以由第三方变量同时生成出来，上述矛盾很可能解决。一个经典例子就是，投掷一颗骰子，设结果为d，则变量x = d mod 2，变量y = d mod 3，虽然它们看似“有联系”，但显然它们是独立的，不管x等于多少，y=0、y=1、y=2的几率都是相等的，它的取值与x没有任何关系。从概念上说，有P(x)·P(y) = P(x∩y)，这足以说明两者是独立的。巧妙利用这种关系，题目要求很可能达到。<br>
    从题目上看来，不单是变量“两两”独立，即使任意三个变量互相独立、任意四个变量互相独立也是有可能的。我猜想k &lt; n/2，不过也没有能证明到。

    今天我看到答案，一下子就傻了……这么简单的解法，两个月了我居然一直没想到。


    事实上，我的整个大方向都完全错了。除了n=1显然不行，其它情况下都存在均匀分布且和为常数的随机变量。当n=2时，取随机变量X_1，再令X_2 = 1 - X_1，这两个变量显然符合要求。当n=3时这个办法虽然行不通，但我们有很多别的办法。最巧妙的一种办法就是选取3个三进制小数使得它们同一位上的数各不相同。具体地说，从1开始枚举i，每次把0、1、2三个数字随机分配给X_1, X_2, X_3，作为它们各自小数点后的第i位。三个变量显然都均匀分布在[0,1]上，且它们的和总为1.1111111...，即十进制中的1.5。那么，当n&gt;3时这个办法还管用么？其实我们根本不必考虑这个，因为对于更大的n，我们只需要把变量两个两个分成一组，并分别套用n=2的算法；若最后还剩了3个变量，再套用n=3的算法就是了。这样，对所有n&gt;1的情况我们都给出了一种生成满足要求的变量的算法。<br>
    更令人抓狂的是，对于后一个问题，事实上连k=2都办不到，其证明简单得实在是出人意料。考虑</p>
<p>X_1 + X_2 + X_3 + … + X_n = 常数</p>
<p>    等式右边的方差显然为0。假设变量两两独立，则和的方差就等于方差的和。单个变量的方差为<img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-05-03T01:50:03+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1810</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 三个关于数绵羊的故事…… ]]></title>
<link>http://www.matrix67.com/blog/archives/1821</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p><span id="more-1821"></span><br>
 <br>
<img alt="image placeholder" >
<p> <br>
<img alt="image placeholder" >
<p> <br>
 <br>
最近看到的三则关于数绵羊的漫画。来源：<br>
<a href="http://www.dmv.mathematik.de/images/cartoonpreis/marcelo_rampazzo.jpg">http://www.dmv.mathematik.de/images/cartoonpreis/marcelo_rampazzo.jpg</a><br>
<a href="http://ladysilverwood.deviantart.com/art/Counting-Sh33p-29862425">http://ladysilverwood.deviantart.com/art/Counting-Sh33p-29862425</a><br>
<a href="http://xkcd.com/571/">http://xkcd.com/571/</a></p>
			 ]]></content>
<pubDate>2009-05-04T19:42:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1821</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：列表染色与可选择数（下） ]]></title>
<link>http://www.matrix67.com/blog/archives/1825</link>
<content><![CDATA[ 
		<p>    我们<a href="http://www.matrix67.com/blog/archives/1798">上次</a>说到，不是所有的平面图都是可4选择的。于是人们接着猜想，是不是所有平面图都是可5选择的呢？1994年，Carsten Thomassen证明了，所有平面图都是可5选择的。这个证明极其简单，论文全文不足两页，证明过程仅十多行。证明对平面图中的区域数n施归纳。有趣的是，归纳的命题比我们待证明的命题要强得多，否则原命题反而证不到。<br>
    为简便起见，我们假设平面图是一般的，它没有同属于四块区域的交界点，也没有中空的“洞”。加入这些条件不会让问题变得更简单，因此这些假设都是合理的。下面再假设最外面那一圈区域（与“外部空间”相邻的区域）有s个，它们彼此相连构成了一个环，我们按逆时针顺序把它们分别记为P_1, P_2, P_3, …, P_s。无妨设P_1和P_2的颜色分别为1和2。下面我们证明一个比原命题更强的结论：若最外面那s个区域的颜色列表中至少有三个颜色，其余那些（被围在内部的）区域的颜色列表中有五个颜色，则一定存在合法的列表染色。当区域数n足够小时结论显然成立。</p>
<p><span id="more-1825"></span><br>
<img alt="image placeholder" >
<p>    考虑一般情况，如图1。我们标出P_s除了P_1和P_(s-1)以外的邻域，显然它们都是处于内部的、有五个候选颜色的区域。在图1中，s=11，P_11有三个处于内部的邻域T_1, T_2, T_3。现在，把P_11去掉，则剩下的图中P_1, P_2, …, P_10, T_3, T_2, T_1就是新的外围环。注意P_11本来有至少三个颜色可选，除去P_1的颜色，至少还有两种不同的颜色x和y。从T_1, T_2, T_3各自的颜色列表中去掉x和y（如果有的话），这样它们的候选颜色数仍然大于等于3。根据归纳假设，剩下的图存在合法的列表染色。最后，只需要把x或y分配给P_11，使得它和P_10的颜色不同就行了。</p>
<p><img alt="image placeholder" >
<p>    一种特殊情况是，万一哪一步我们得到的外围环不是一个单纯的环（如图2）该怎么办？这也很简单，因为我们总可以把它们分解成若干个小环，然后按顺序逐一套用归纳假设。例如在图2中，无妨设P_1和P_2的颜色是已知的，由归纳假设可知环P_1, P_2, …, P_5, P_10及其内部存在合法的列表染色。这样，P_5和P_10的颜色就是确定的了，我们可以把归纳假设再次用于P_10, P_5, P_6, …, P_9及其内部所组成的图形。</p>
<p>    可以注意到，我们证明了一个更强的命题其实是不得已而为之，如果直接拿待证命题进行归纳反而推不出结论，因为减少候选颜色必然会破坏掉“有五种颜色”的限制。</p>
			 ]]></content>
<pubDate>2009-05-06T05:57:01+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1825</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 递归与自我指涉标识牌Top 5 ]]></title>
<link>http://www.matrix67.com/blog/archives/1846</link>
<content><![CDATA[ 
		<p>网上搜集了一类搞笑标识牌。其中荣获<strong>第5名</strong>的是：</p>
<p><img alt="image placeholder" >
<p><span id="more-1846"></span><br>
 <br>
<strong>第4位：</strong></p>
<p><img alt="image placeholder" >
<p> <br>
 <br>
<strong>第3位：</strong></p>
<p><img alt="image placeholder" >
<p> <br>
 <br>
<strong>第2位：</strong></p>
<p><img alt="image placeholder" >
<p> <br>
 <br>
<strong>第1位：</strong></p>
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-05-09T08:26:04+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1846</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ （召集）你能想到的最奇妙的算法题是什么？ ]]></title>
<link>http://www.matrix67.com/blog/archives/1850</link>
<content><![CDATA[ 
		<p>    昨天和老朋友BY一起吃饭时又一次不可避免地谈到了算法问题。一个有趣的话题是：提起那些最巧妙的、最离奇的牛B算法时，你想到的第一个算法题是什么？</p>
<p>    我第一想到的算法题是那道经典问题：n个数中有且仅有一个数出现了奇数次（其它数都出现了偶数次），如何用线性时间常数空间找出这个数。解法也只有一句话：从头到尾异或一遍，结果就是要求的那个数。该问题的加强版也异常牛B，我曾经在<a href="http://www.matrix67.com/blog/archives/511">这里</a>介绍过。不过，这个算法我在茶余饭后已经聊过无数次了……</p>
<p>    脑海中出现的另一个牛B算法题则是<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3318">POJ3318</a>：给你三个n*n的矩阵A、B、C，问你A*B是不是等于C。数据保证O(n^3)铁定超时，因此你需要想一个不用把A和B乘起来就可以验证的算法。一个基于概率的算法是随机生成一个n乘1的矩阵R，然后判断A*B*R是否等于C*R，而前者相当于A*(B*R)，与后者一样都可以在O(n^2)的时间里算出来。如果算出来的结果相等，几乎可以肯定A*B和C也是相等的。</p>
<p><span id="more-1850"></span><br>
    还想起为高中参加省选的孩子们准备模拟题时挖到的一道可称之为“脑筋急转弯”的算法题：给你一个数列，一次操作是指将某个数移到数列中别的位置上去，然后问最少要几次操作才能让数列变得有序。例如，数列7,1,3,2,6,5就只需要三次移动，把3移到2后面，把5移到6前面，再把7移到最后面即可。当时居然只有一个人想到，这题其实就是一个最长上升子序列问题。因为整个操作过程实质上可以等价地看作是，把要移动的数先全部取出来，再挨个放回适当的位置。这就要求取出要移动的数后，剩下的那些数本身是有序的。若希望要移动的数越少越好，那也就等于说是剩下的不动的数要越多越好。</p>
<p> <br>
    最近准备一次演讲，翻出了一道旧题，觉得讲起来会相当有意思。当时和BY分享的就是这道题。问题从一个简化版开始：给定一个图，你有一次机会将某条边的权值减半，用O(n^2)的时间求最短路。很多人可能会在第一时间内开始思考，把这次权值减半的机会用到哪里最合适呢？一个明显有欠思考的猜想是，用在边权最小的地方，因为这可以让它更小。事实上，把它用在边权最大的地方显然赚得多，不过问题是，有可能这个边权又太大了，最短路根本就不经过它。一个折衷办法就是，把权值减半的机会用在原图的最短路中的最大边上。这下看上去似乎和谐了，但稍加思索不难发现反例：S到T有两条路径，一条要走99条长为1的边，另一条只需走一条长为100的边。把权值减半的机会用在那条大边上显然更好。<br>
    这题的正确算法呢，其实也不难，预处理S到所有点的最短路，以及T到所有点的最短路，然后枚举每条边，可以直接求出将这条边减半后必须经过该边的最短路（将这条边减半了又不走这条边的人肯定有毛病）。这样，枚举得出的最小值就是我们所求的最短路。<br>
    有趣就有趣在，如果你有k次选一条边令其权值减半的机会，还存在多项式的算法吗？注意，我甚至可以把这k次机会重复用在某些边上，让其权值不断折半。又一个有趣的讨论是，把上面的算法重复套用k次可行吗？换句话说，该题是否具有最优子结构？不见得。下图就是一个反例：k=1时走下面最好，k=2时反而走上面更好。原因就在于，在同一条边上反复减半会越来越亏，还不如把机会分散用在几个权值本来不大的边上。</p>
<p>  <img alt="image placeholder" >
<p>    到底该怎么办呢？其实这题有一个非常巧妙的O(n^2·k^2)的算法，真不知是谁想出来的：把原图分成k+1层，从0到k分别标号。上面的层到下面的层有很多单向边，每条边都和原图上的某条边相对应，跨越了几层权值就打几次对折，表示我“走了一条权值减过的边”。因此，你当前走在第几层，就表示你已经用掉了几次减半机会。在这个有O(nk)个顶点的图上做最短路，其结果就是我们所要求的。</p>
<p> <img alt="image placeholder" >
<p>    看来，除了<a href="http://www.matrix67.com/blog/archives/58%20">几何问题</a>以外，在算法中也有把2D扩展到3D的诡异的思想。图的分层思想很有用，在很多其它问题中也有类似的做法。</p>
<p> <br>
 <br>
    BY与我分享的则是这样一道题目：在1到n中选取若干个数，要求如果选了x就不能选2x和3x，问共有多少种选择方案。例如，n=3时答案为5，这5种选法分别为{}, {1}, {2}, {3}, {2,3}。我想了很久。BY提示，是动态规划。我又想了很久。BY再提示，是带状态压缩的动态规划。我又想了很久，并且觉得越来越不可思议。后来BY宣布答案，两人立即大笑起来：把数字1放在方阵最左下角，然后不断在一个数的右边填上它的两倍，在其上方填上它的三倍。问题就等价地转化为，在方阵中选取若干个格子使得任意两个不相邻，求有多少种选取方案。这是一个经典的带状态压缩的动态规划问题。另外，遇到尚未出现过的数（即除2和3以外的素数）就再开一张新的表，然后用乘法原理把它们各自对应的方案数乘起来就是了。例如当n=20时，最终答案就等于下面这7张表各自所对应的选取方案数的乘积。</p>
<p>  <img alt="image placeholder" >
<p>    这题也许还有组合数学方法，但下面这个加强版估计就只能这样做了：如果再给定一些不能选的数，则又有多少种选择方案。</p>
<p>    大家遇到的最神的算法题目又是什么呢？欢迎在下面留意与大家分享！</p>
			 ]]></content>
<pubDate>2009-05-10T12:25:32+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1850</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：图中哪里有问题？ ]]></title>
<link>http://www.matrix67.com/blog/archives/1866</link>
<content><![CDATA[ 
		<p>开始玩雷顿教授2（我落后了，大家鄙视我吧）。雷顿教授系列不但剧情很科学，而且有些谜题也能让人眼前一亮。第一个让我眼前一亮的谜题是雷顿教授1里面的那个<a href="http://www.matrix67.com/blog/archives/1141">关于椅子的问题</a>。我前不久碰到了本系列中第二个让我开怀大笑的谜题，我看出答案后旁若无人地大笑了半分钟。你需要多久才能反应过来？死活看不出来的人先用脑袋撞墙三分钟，然后Ctrl+A看答案。</p>
<p><img alt="image placeholder" >
<p>答案：<span style="color:#E5E5E5">图D有问题。杯子是三维的呀，你能像图D那样把一个杯子插进两个杯子之间么？</span></p>
<p><span id="more-1866"></span><br>
 <br>
另一个有趣的谜题是那道站台海报的问题：<br>
“车站就是离别的舞台。图上描绘着一对依依不舍的男女，不过总感觉有什么地方不大自然。是哪个地方呢？”</p>
<p><img alt="image placeholder" >
<p>答案：<span style="color:#E5E5E5">车窗有问题。如果那个窗子真的推到那个位置，它早已撑破车顶了。</span></p>
			 ]]></content>
<pubDate>2009-05-12T20:42:06+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1866</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 世界之大无奇不有：Situation Puzzle大合集（上） ]]></title>
<link>http://www.matrix67.com/blog/archives/1871</link>
<content><![CDATA[ 
		<p>    所谓情境谜题(Situation Puzzle)，又叫水平思考游戏(Lateral Thinking Puzzle)，是一种非常有趣的猜谜游戏。游戏主持人提出一个奇怪的、难以理解的事件，最先猜出事件背后原因的人获胜。每个人都可以向主持人无限制地询问问题，但主持人只能回答“是”或者“否”。例如，对于第一个问题，大家可以从“鲍鱼肉有毒吗”、“男人是否因事业问题自杀”、“男人是否因感情问题自杀”、“鲍鱼肉是否与男人的过去有关”、“男人是否吃过鲍鱼肉”等一系列问题慢慢接近答案。<br>
    游戏的关键在于主持人是否能想到一个有创意的、大家都没见过的情境。这里我们给出40个精彩的情境，它们几乎都是真实世界中发生的事情（可能有些许改动），真可谓是世界之大，无奇不有。所有情境谜题全部来源于<a href="http://www.kith.org/logos/things/sitpuz/answers.html">这里</a>。大家能从中找出不少熟悉的谜题，它们曾被一些标题党冠名为FBI某某测试来吸引人的目光。</p>
<p>1. 一个男人进了一家餐馆，点了一份鲍鱼，咬了一口，然后立即自杀了。<br>
答案：<span style="color:#E5E5E5;">这个男人曾经因轮船失事困在了荒岛上。在众人快饿死时，一名乘客为他带来了食物，并宣称它是鲍鱼肉，而事实上则是他已亡妻子身上的肉。当他吃到真正的鲍鱼肉时，意识到当初吃的其实是自己的妻子，于是自杀。</span></p>
<p>2. 一个男人住在12楼。每天早晨他去上班时都会乘坐电梯到一楼。晚上他乘电梯回房间时，如果电梯里有其它人或当天下了雨，他直接乘电梯到12楼；否则，他会乘坐到10楼后通过楼梯步行至12楼。<br>
答案：<span style="color:#E5E5E5;">这个男人是一个侏儒，他不能按到电梯上“12楼”的按钮，除非电梯里有其它人帮忙，或者他带了雨伞。</span></p>
<p><span id="more-1871"></span><br>
3. 一个男人放手抛出保龄球。不久，他被送往医院急诊。<br>
答案：<span style="color:#E5E5E5;">这个男人是一个物理教授。他在课堂上演示能量守恒定律。他用绳子把一个保龄球拴在天花板上，然后双手握球置于脸前并站在房间一侧。根据动能和重力势能的相互转化，松手后保龄球将荡到房间另一侧再荡回来，但其幅度不会超过初始位置。不幸的是，教授放手时稍微用了一点推力，这导致实验失败。</span></p>
<p>4. 一个男人走进一家酒吧点了一份饮料。酒保掏出一把枪对准他。他说了声“谢谢”，然后离开了酒吧。<br>
答案：<span style="color:#E5E5E5;">这个男人打嗝不停。酒保用枪吓他，治好了打嗝。</span></p>
<p>5. 他被自己做的早餐杀死了。<br>
答案：<span style="color:#E5E5E5;">这个男人在登雪山。他做早餐时放了些胡椒，这致使他大声地打了个喷嚏，从而引起雪崩。</span></p>
<p>6. 一个男人在一株仙人掌旁死去。仙人掌上贴着一张纸条。<br>
答案：<span style="color:#E5E5E5;">这个男人在荒漠中迷路了。他开始用纸条在仙人掌上做标记。又行走了几天后，他已经没有水喝了，此时突然看见面前那株仙人掌上已经贴了一张纸条，意识到自己在荒漠中绕了一大圈。绝望中他自杀了。</span></p>
<p>7. 你透过窗子看去，房间里有两具尸体、一把枪和一副牌。<br>
答案：<span style="color:#E5E5E5;">你是一个潜水者，你发现了一艘沉没的潜艇，在潜艇外透过窗子可以看见两具尸体。在潜艇沉没时这两个人都不愿意被淹死，但枪里只有一颗子弹。于是两人通过纸牌游戏一决胜负。败者射杀胜者，然后自己被痛苦地淹死。</span></p>
<p>8. 地上有一根胡萝卜、一小堆鹅卵石和一根水管。<br>
答案：<span style="color:#E5E5E5;">雪人化了。</span></p>
<p>9. 街道上停着两辆相隔很远的车，车上各有一具尸体。<br>
答案：<span style="color:#E5E5E5;">两车相向行驶，各行其道。雾很大，两名司机都探出头来想看清车道中心线的位置。他们的头高速相撞，两人立即死亡，车继续前行了一段距离。</span></p>
<p>10. 一个女人用微波炉热咖啡。她把咖啡放进微波炉里热了两分钟，打开微波炉，然后关上，又了加热两秒钟。<br>
答案：<span style="color:#E5E5E5;">打开微波炉后她发现杯子把手朝向里面，于是继续加热两秒钟，让转盘旋转180度。</span></p>
<p>11. 一个男人死在荒漠中，全身赤裸，脸朝下躺在地上，手的可及范围之外有一根火柴。<br>
答案：<span style="color:#E5E5E5;">他和他的好友们乘热气球横穿沙漠。热气球被风撕破，他们不得不丢掉所有物品以减轻重量，进而开始丢掉身上的衣物。当释重仍然不够时，他们决定用抽火柴的方式来决定谁跳下热气球以保全大家的性命。</span></p>
<p>12. 一个男人对他的上司说，“立即取消你今天的航班！我昨晚梦到那班飞机将要坠毁！”上司解雇了他。<br>
答案：<span style="color:#E5E5E5;">这个男人是一个看守。他晚上不应该睡觉。</span></p>
<p>13. 一个男人穿戴完毕，倒下，死亡。<br>
答案：<span style="color:#E5E5E5;">男人的鞋里有毒蜘蛛。着装最后一步是穿鞋。男人穿好鞋后脚指头被蜘蛛咬了一下，导致死亡。</span></p>
<p>14. 早上，他像往常一样洗漱，吃饭，着装，与妻子吻别，然后出门上班。乘电梯下楼的过程中，他突然意识到自己的妻子死了。<br>
答案：<span style="color:#E5E5E5;">他的妻子靠机器维持生命。男人乘坐电梯时遭遇了停电。</span></p>
<p>15. 四个人在孤岛上，岛上完全被草地覆盖。一场大火从岛的一侧向另一侧蔓延，但最后没有人严重烧伤。<br>
答案：<span style="color:#E5E5E5;">大火蔓延不快，四个人有时间在岛的另一侧实施“低烈度纵火”。他们在岛的另一侧引发一次小火，燃尽地面上的可燃物，从而得以生存。</span></p>
<p>16. 一道闪光过去，一个男人死了。<br>
答案：<span style="color:#E5E5E5;">这个男人是一名驯兽师。表演时正前方有人用相机拍照，闪光灯令狮子失控，同时驯兽师也被闪得看不见东西，而后被狮子咬死。</span></p>
<p>17. 一个男人走进电梯，脱下手套，按下了第10楼的按钮。第二天，同一个人走进了同一个电梯，戴上手套，按下了第10楼的按钮。<br>
答案：<span style="color:#E5E5E5;">这个男人是一个盲人。第一次进电梯时，他戴着手套。电梯按钮是触摸式的，采用人体皮肤导电原理，因而他必须取下手套。但他发现在寻找10楼按钮的过程中，他的手摸遍了几乎每个按钮，因此电梯每一层都停了一下。此后，他再乘坐该电梯总要事先准备好手套。他先用戴着手套的手寻找10楼的按钮，再用另一只手去按它。</span></p>
<p>18. 国王死后，有两个人同时声称自己是国王失散已久的儿子。一名顾问提议对两人的身份进行检测。其中一人同意接受测试，另一人拒绝接受测试。前者被逐出国家，后者最终被认定为国王真正的后继。<br>
答案：<span style="color:#E5E5E5;">顾问提议用血液测试辨别身份。由于血液测试并不准确，因此骗子决定去赌一把。而国王真正的后继有血友病，不能进行血液测试。</span></p>
<p>19. 盛夏，芝加哥一个公园里发现一具尸体。尸体头颅碎裂，全身多处骨折，但死因是体温过低。<br>
答案：<span style="color:#E5E5E5;">欧洲一位贫穷的民工渴望到美国。由于没有充足的钱，他想办法溜进了一架喷气飞机的起落架舱，进而在飞行过程中因过度寒冷而死，并在起落架舱再次打开时落至地面。</span></p>
<p>20. 在森林深处发现一具尸体，死因为溺水而亡。<br>
答案：<span style="color:#E5E5E5;">消防飞机在海上补水时不幸装入了一名潜水者。飞行过程中潜水者在水箱里因氧气瓶用尽而死，随后在飞机释放水箱扑灭森林火灾时落入森林中。</span></p>
			 ]]></content>
<pubDate>2009-05-15T03:02:56+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1871</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 世界之大无奇不有：Situation Puzzle大合集（下） ]]></title>
<link>http://www.matrix67.com/blog/archives/1875</link>
<content><![CDATA[ 
		<p>21. 一个男人杀死自己的妻子，然后回到自己的房间，而后自杀。<br>
答案：<span style="color:#E5E5E5;">为了庆祝自己50岁生日，男人计划杀死自己的妻子，然后拿走所有的钱，到一个新的城市去过一个崭新的生活。他的妻子带他出去晚餐，回家时男人在房前杀死了她。他打开家门，把妻子的尸体拖进房间，突然屋里的所有灯同时亮起，他的朋友们跳出来大叫“Surprise”。他自杀了。</span></p>
<p>22. 如果当时他开了灯，他就不会死了。<br>
答案：<span style="color:#E5E5E5;">在一次商店抢劫案中，店主被抢劫犯射伤。店主爬回里屋，拿起电话拨打自己家的号码。由于屋里没开灯，他只能凭感觉按键。电话通后，他低声说“我在商店，我被射中了，快来救我”。他挂断了电话，等待有人来救他，但没有人来。他把电话键盘错当成了收银机的键盘（这两种键盘的数字排列正好相反），因此拨错了电话。</span></p>
<p>23. 一个男人走进一家餐馆，大吃一顿，却没有支付任何费用。<br>
答案：<span style="color:#E5E5E5;">这个男人是一位知名艺术家。一个专门收集名人签名的女人看到了该艺术家正在用餐，于是待他用餐完毕并用支票支付费用后，从餐厅经理那儿买下了支票。该支票从未被兑现，因此男人并未为这顿大餐支付任何费用。</span></p>
<p><span id="more-1875"></span><br>
24. 一位美国海军水兵在巡洋舰甲板上发现船行方向正前方有一颗水雷。情况危机，他甚至没有时间与船长交流。他拯救了全体船员的性命。<br>
答案：<span style="color:#E5E5E5;">水兵利用甲板上的消防水龙带冲走了水雷。水压不会引爆水雷。二战时的水雷都是磁性水雷。</span></p>
<p>25. 一个女人在数百人面前被谋杀，但所有人都认为这是一次意外事故。<br>
答案：<span style="color:#E5E5E5;">这个女人是杂技表演人。她将表演一段蒙眼走钢丝。在表演过程中，负责弹奏背景音乐的钢琴家本应该用一段音乐来提示表演者已经到达终点可以安全着陆，但他故意提前弹奏这段提示音乐，从而杀死表演者。</span></p>
<p>26. 一个没有护照的普通美国公民，一天之内访问了30多个国家。在每个国家里他都受到热情招待，并且离开时也完全自由。<br>
答案：<span style="color:#E5E5E5;">他是一个送信人，负责将包裹送到各个大使馆。大使馆的领地为使馆国所有。</span></p>
<p>27. 一个男人坐在床上。他打了一个电话，没有说任何话，挂断电话，然后卧床睡觉。<br>
答案：<span style="color:#E5E5E5;">他在一家旅馆，由于隔壁房间的住客打鼾声太大而无法入睡。他拨通了隔壁房间的电话号码，把正在打鼾的住客吵醒，然后挂断电话并卧床入睡。</span></p>
<p>28. 一个男人在路上行走时，鞋里不小心进了一粒小石子。他双手扶在一根柱子上，不停地甩自己的脚，企图把小石子抖出来。另一个人走上前来，把前者的手臂打断。<br>
答案：<span style="color:#E5E5E5;">前者靠在电线杆上。后者以为前者触电了。</span></p>
<p>29. A和B在旅馆的酒吧里谈话。然后，两人离开酒吧开始上楼。半路中，B突然抓住自己的胸口，然后对着A的脸打了一拳。<br>
答案：<span style="color:#E5E5E5;">A和他的妻子度蜜月。到了旅馆，A的妻子先上楼休息，A在楼下的酒吧里喝酒。酒吧里A遇见了B，后者声称自己是催眠师。两人结识并谈论起来。A不相信自己能被催眠，于是B对A实施催眠术并令A杀死他的妻子。B本计划在A将要动手之前阻止并弄醒他。但在路上，B心脏病突发，于是在自己死之前给了A一拳，提前让A恢复神志，以免A犯下罪行。</span></p>
<p>30. 一个男人边开车边听广播。然后他将车停在路边，举枪自尽。<br>
答案：<span style="color:#E5E5E5;">这个男人是一名电台DJ。他计划在播音期间杀死他的妻子，并准备了一盘很长的录音带为自己制造不在场证明。开车返回时他打开车载收音机，调频到自己的节目，听到的却是录音带的跳带声。</span></p>
<p>31. 一艘轮船突然翻覆，几乎所有乘客都被淹死。<br>
答案：<span style="color:#E5E5E5;">船沿着印度的某条河前行。一条蛇落在甲板上，乘客全都吓跑到船的另一侧，致使船失去平衡。</span></p>
<p>32. 绳子断了。钟声响起。一个男人死去。<br>
答案：<span style="color:#E5E5E5;">一个酷爱冒险的盲人喜欢在悬崖边行走，靠浮标的钟声来判断自己离悬崖边的距离。某日浮标的锚索断了，浮标漂离了岸边，盲人错误地判断了他与悬崖边的距离，掉下了悬崖。</span></p>
<p>33. 一个女人买了一双新鞋，照常上班，死亡。<br>
答案：<span style="color:#E5E5E5;">这个女人是一位杂技表演人的助手。杂技表演人掷飞刀时，由于女人新鞋的鞋跟比之前高一些，因此飞刀直接刺中女人，在节目表演中当场死亡。</span></p>
<p>34. 两兄弟在酒吧喝酒。他们开始争吵。其中一人掏枪射杀了另一人。不久后他自己也不幸身亡。<br>
答案：<span style="color:#E5E5E5;">两兄弟是连体人。其中一人抱怨另一人不讲卫生，口臭难忍，并掏枪杀死了他。他自己也因失血过多而死。</span></p>
<p>35. Hans和Fritz是二战期间的两名德国间谍。他们声称自己是归国的旅游者，试图混进美国。Hans当场被捕。<br>
答案：<span style="color:#E5E5E5;">Hans和Fritz的行径始终没有任何疑点，直到他们开始填写表格上的个人信息。Fritz的生日是7月7日，因此他写下了“7/7/15”。Hans的生日是6月20日，因此他写下了“20/6/18”。而正确的美式书写方式应该是“6/20/18”。</span></p>
<p>36. 一个女人在马路上的一辆汽车旁死去。<br>
答案：<span style="color:#E5E5E5;">她骑摩托时，长发被汽车装饰天线缠住。这致使她的头皮被扯掉了一大块，流血过多致死。</span></p>
<p>37. 一个女人向窗外扔出一个物体，而后死亡。<br>
答案：<span style="color:#E5E5E5;">女人的头部被自己扔出的回旋镖砸中。</span></p>
<p>38. 一个男人搭成火车从瑞士回来。如果他在禁烟车厢的话，他可能就死了。<br>
答案：<span style="color:#E5E5E5;">这个男人曾一度失明。他花费了所有的积蓄做了眼科手术，恢复了视力。当火车进入隧道时，男人以为自己再度失明，决定自杀。幸运的是，黑暗中点燃的烟及时告诉他，他并未失去视力。</span></p>
<p>39. 一个男人小便，死亡。<br>
答案：<span style="color:#E5E5E5;">男人在纽约地铁对着铁轨小便。他因触电无法动弹，随后被列车撞死。</span></p>
<p>40. 一个男人在房间里死亡，屋子一角有很多木屑。<br>
答案：<span style="color:#E5E5E5;">这个男人是一个失明的侏儒，他是马戏团里最矮的人。另一个侏儒因为没有他矮而嫉妒他，于是半夜潜入他家把盲杖锯短。因此第二天他会以为自己一夜之间变高了。由于在马戏团的工作是他的唯一收入，因此他发现自己变高后决定自杀。</span></p>
			 ]]></content>
<pubDate>2009-05-15T20:53:32+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1875</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 最好的生日礼物：Wolfram|Alpha今日发布 ]]></title>
<link>http://www.matrix67.com/blog/archives/1882</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p><a href="http://www.wolframalpha.com">Wolfram|Alpha</a>是众人期待已久的新一代知识搜索引擎。它背后有一个强大的知识库，并借助Mathematica向人们展示出图文并茂的智能化搜索结果。巧的是，Wolfram|Alpha的发布日期正好是我21岁生日。不妨让我们用“21岁”为话题来测试一下Wolfram|Alpha吧。</p>
<p><span id="more-1882"></span><br>
<a href="http://www.wolframalpha.com/input/?i=born+on+1988-05-16">http://www.wolframalpha.com/input/?i=born+on+1988-05-16</a><br>
我21岁了</p>
<p><a href="http://www.wolframalpha.com/input/?i=21">http://www.wolframalpha.com/input/?i=21</a><br>
21可以唯一地表示为三个平方数的和<br>
21是一个奇数<br>
21是最小的有5种方法表示为3个素数和的数<br>
21是第8个Fibonacci数<br>
21是第5个Motzkin数<br>
21是第6个三角形数<br>
21的四进制表达中只含有一种数字</p>
<p><a href="http://www.wolframalpha.com/input/?i=1988-05-16">http://www.wolframalpha.com/input/?i=1988-05-16</a><br>
我出生在1988年的第137天，也就是第20周，当天正好是新月<br>
这一年的37.16%已经过去了，还剩下62.84%<br>
我活了7670天，也就是1095星期又5天，也就是整整21年</p>
<p><a href="http://www.wolframalpha.com/input/?i=man+aged+21">http://www.wolframalpha.com/input/?i=man+aged+21</a><br>
一个21岁的男人体重应该在40.1到104公斤之间，身体表面积应该在1.58到2.61平方米之间<br>
一个21岁的男人平均每天摄入1487到2505卡路里</p>
<p><a href="http://www.wolframalpha.com/input/?i=man+aged+21+180cm+71.4kg">http://www.wolframalpha.com/input/?i=man+aged+21+180cm+71.4kg</a><br>
一个身高180厘米，体重71.4公斤的21岁男子体内含有42升水，5升血液，3.1升血浆，2升红血球<br>
肺活量平均为4.3升，心脏容量760毫升，大脑重1.5千克，平均每天摄入1774卡路里<br>
理想体重应为73.9公斤，超过实际2.511公斤<br>
身高超过69%的人，体重只超过19%的人<br>
身体表面积约为1.89平方米</p>
<p><a href="http://www.wolframalpha.com/input/?i=man+aged+21+180cm+74.1kg+running">http://www.wolframalpha.com/input/?i=man+aged+21+180cm+74.1kg+running</a><br>
我以每分钟400米的速度跑30分钟将消耗982卡路里，燃烧0.12千克的脂肪<br>
心律最高可达每分钟194.5跳</p>
<p><a href="http://www.wolframalpha.com/input/?i=birthday&amp;a=*C.birthday-_*Word-">http://www.wolframalpha.com/input/?i=birthday&amp;a=*C.birthday-_*Word-</a><br>
单词birthday表示一个day of remembrance，它是an anniversary of the day on which a person was born (or the celebration of it)<br>
书面词频1/37000，排在第3614位；口语词频1/13000，排在第877位<br>
上位词有anniversary、date、day of remembrance、day of the month<br>
同义词为natal day</p>
			 ]]></content>
<pubDate>2009-05-16T14:38:21+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1882</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 记09年北大ACM校内赛 ]]></title>
<link>http://www.matrix67.com/blog/archives/1890</link>
<content><![CDATA[ 
		<p>    大学生活混起来很快，不知不觉又是一年过去了。<a href="http://www.matrix67.com/blog/archives/510">去年5月10日的ACM校内赛</a>给我留下了许多美好的回忆，因此今年我主动去报了名（上次是被人给拖去的）。今年有点装怪，题目数量不变，但时间缩短为4个小时。原计划是从8:00做到12:00，结果可能是因为我们所在的7号机房迟迟没有开门，时间临时改成了8:15到12:15。总的来说，今年的题目比去年要糟糕得多，但也不乏一些精彩的题目。</p>
<p>    和去年一样，第一题依旧是所有题目中最科学的一道。题目给定一个不超过2000*2000的网格，你在最左下角的位置（即(0,0)点），你的目的地在(x,y)。要求你的路线不得经过同一个交叉点两次，且不允许左转（题目背景让这个条件顺理成章：街道靠右行，左转不方便），问合法的路线共有多少种。题目难点就是你不一定要走最近的路，完全允许你绕上一大圈；这破坏了有序性，很难构造出递推公式或动态规划模型。稍微画一下图，我们发现了一些显然但很有启发性的规律：每一次右转后，你左手边方向的所有区域都不能再走了，这很可能产生出规模更小的子问题来。另外，所有合法路线必然是有如螺旋线一样的一圈一圈绕着终点走，这种隐藏的有序性也为动态规划提供了可能。但顺着这个思路想下去屡屡碰壁，我猜不少队伍都卡在这儿了吧。</p>
<p> <img alt="image placeholder" >
<p>    后来我完全打翻前面的全部思路，猛然想到了一个具有决定意义的想法：街道的选取唯一地决定了整个路线。例如，假设我想计算转弯恰好11次的路线有多少条。这样的路线一定含有三条向上走的路、三条向右走的路、三条向下走的路和三条向左走的路。除去第一条路和最后一条路的位置都是确定的，其它的路选在哪一行或者哪一列唯一地决定了整个路线。因此，我们可以用排列组合直接计算出答案来。向上走的路是五选二，向右走的路是七选三，向下走的路是四选三，向左走的路是三选二。把它们各自的选取方案数乘起来就得到了拐弯11次的合法路径。于是，计算所有的路线数只需要从小到大枚举拐弯的次数，每一次计算都是常数的，总复杂度是O(n)的；整个算法的瓶颈反倒是O(n^2)的组合数预处理，不过这个复杂度完全可以承受。</p>
<p><span id="more-1890"></span><br>
    另一道题也很不错。有n只猫猫排成一排，初始时每只猫猫都没有花生。定义三种操作：给第i只猫猫一颗花生，令第i只猫猫吃掉它所有的花生，交换猫猫i和猫猫j的花生。给出长度不超过k的操作序列，输出循环执行m次操作序列后的结果。数据规模n≤100，k≤100，m≤1 000 000 000。看到这道题我们立马会想到矩阵乘法。如果能为每种操作构造出一个矩阵，m再大二分下来也能承受。我们可以先把序列中的k个操作乘起来，再利用二分自乘m次就可以了。</p>
<p> <img alt="image placeholder" >
<p>    但这一思路碰到了一些困难：交换和清零操作都好办，但加一操作怎么弄？我们可以借用<a href="http://www.matrix67.com/blog/archives/276">这里</a>的第一题的思路，在猫猫向量的最后面加一个额外的“1”，从而解决了加一操作的难题。</p>
<p> <img alt="image placeholder" >
<p>    这道题最后TLE了，而我们没有充足的时间去优化它，最终残念离去。算法的瓶颈就是把k个操作乘起来的过程，它的复杂度是O(k·n^3)，也就是100的四次方，最坏情况下铁定会超时。不知道用O(n^2.81)的矩阵乘法是否可以AC。网上还有人提到，由于矩阵很稀疏，做乘法时写成if(a[i][k]&amp;&amp;b[k][j])c[i][j]+=a[i][k]*b[k][j]会大幅度提高效率。下来跟外校参赛选手<a href="http://hi.baidu.com/5l2_">512MM</a>交流了一下，她告诉我一个操作序列的最终结果可以用O(k·n)的复杂度直接构造出来，这样就可以保证AC。另外，同队的leimiaos还提出了一个完全不同的算法：把交换操作看作置换群，然后把单个操作序列的交换操作分解成若干个循环。每个循环都将在100次序列重复以内产生周期性状态，而不同循环之间又互不干扰，问题即迎刃而解。</p>
<p>    今年的题目确实没有去年的精彩。D题和G题都是很纯粹的数学题。D题是说有n个木块排成一行(n≤10^9)，你可以给每个木块涂红蓝绿黄中的一种颜色，要求最后红木块和绿木块都有偶数个，问染色方案共多少种。leimiaos用满满一页草稿纸推出来公式4^(n-1) + 2^(n-1)，大家也可以试试看。G题更干脆，题目描述压缩了就一句话，给定圆锥的表面积，求最大体积。作为根正苗红的理科生，同队的徐谷子MM和leimiaos都赶在我想出圆锥表面积怎样算并准备操键盘写二分之前飞快地算出了公式解。这两道题分别有108支队和160支队做出来，而走路题和猫猫题的AC数分别只有9和11。<br>
    其余的题目绝大多数都是比较复杂的模拟，几乎没人去做。这次比赛第一名AC了6道题，第二、三、四名AC了4道题，接下来有十几支队伍AC了3道题，然后就是不计其数的只搞出两道数学题的队伍。不管怎样，这次比赛再一次勾起了我做算法题的欲望。最近打算没事时稍微练练手，到时候大家在百度之星和有道难题上见！</p>
			 ]]></content>
<pubDate>2009-05-18T18:17:55+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1890</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：选取最多的子集使得任两子集恰有一个公共元素 ]]></title>
<link>http://www.matrix67.com/blog/archives/1900</link>
<content><![CDATA[ 
		<p>    这里有一个有趣的问题：在集合{1, 2, …, n}中选取尽可能多的子集，使得任意两个子集的交集有且仅有一个元素。例如，当n=7时，选取{1,2,3,4}、{4,5,6,7}、{1,7}这3个集合可以满足条件。子集数还可以更大一点吗？最大是多少？给出一种构造，然后证明这个数目不可能更大了。</p>
<p>    当n=7时，仅仅取3个子集实在是太弱了。一种最简单的办法就可以让子集数达到6，只需取{1,2}、{1,3}、{1,4}、{1,5}、{1,6}、{1,7}即可。再仔细观察，我们发现这个结果还可以进一步改进：我们还可以再往里面添加进一个子集{1}，使得这7个子集两两间仍然恰有一个公共元素。这下我们似乎不能再往里面添加任何新子集了。我们还可以做得更好吗？一个新的思路是在{1,2}、{1,3}、{1,4}、{1,5}、{1,6}、{1,7}里面加上{2,3,4,5,6,7}，这同样可以让子集数达到7个，可惜我们仍然无法再往里面添加新的子集了。经过若干次尝试后，我们逐渐开始确信，在集合{1, 2, …, n}里面最多只能选出n个两两恰有一个公共元素的子集，并且构造方法无外乎上面两种。这一猜想不但与直觉相符，而且貌似也很好证明。你或许会从一些看似很直观的结论出发开始证明：“显然不可能有两个大小为1的子集”，“选取多个元素个数大于2的子集显然不划算”……但牛B就牛B在，偏偏就有这样一种子集数为n的取法，每个子集里都有不止两个元素，但仍然保证任意两个子集间恰有一个公共元素：</p>
<p>{1,2,3}、{1,4,5}、{1,6,7}、{2,4,7}、{3,4,6}、{3,5,7}、{2,5,6}</p>
<p>    这一个例子对我们的猜想足以构成威胁：子集数为n真的已经到极限了吗？证明结论有那么容易吗？看来，情况貌似比我们想象中的要复杂得多。</p>
<p><span id="more-1900"></span></p>
<p> <br>
 <br>
    事实上，子集数最大为n，这个数目不可能再大了。其证明出人意料的简单。考虑每个子集所对应的n维01向量，例如n=7时集合{1,2,3}就对应向量{1,1,1,0,0,0,0}，而子集{1,4,5}则可以表示成{1,0,0,1,1,0,0}。可以看出，两个子集的交集的元素个数就等于它们的向量的点积。下面我们证明，满足要求的一组子集其对应的向量一定是线性无关的，从而直接得到向量个数不超过n的结论。<br>
    记m个向量分别为v_1, v_2, …, v_m，令s=Σa_i v_i，考虑点积&lt;s,s&gt;=Σ Σ a_i · a_j · &lt;v_i, v_j&gt;。注意对每一对不同的i和j都有&lt;v_i, v_j&gt;=1，而&lt;v_i, v_i&gt;就等于子集A_i的元素个数|A_i|。于是，&lt;s,s&gt;就等于(a_1 + a_2 + … + a_m)^2 + Σ(a_i)^2·(|A_i|-1)。当s=Σa_i v_i=0时，&lt;s,s&gt;也应该为0；而上面&lt;s,s&gt;表达式中的每一项都是非负整数，要让&lt;s,s&gt;为0只可能是所有a_i都取0，这就说明这m个向量是线性无关的。<br>
    这就是著名的de Bruijn-Erdős定理。</p>
<p>    线性代数理论不止一次帮助我们证明了看似与线性代数毫无关系的问题。如果你喜欢这个证明，千万不要错过这个<a href="http://www.matrix67.com/blog/archives/998">经典的图论问题</a>。</p>
<p>    <span style="color:blue">Update: “&lt;“符号被吃掉了，现在已经改过来了</span></p>
			 ]]></content>
<pubDate>2009-05-22T12:51:35+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1900</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 为什么把敌人打败了=打敌人，但把肚子笑疼了≠笑肚子？ ]]></title>
<link>http://www.matrix67.com/blog/archives/1914</link>
<content><![CDATA[ 
		<p>    转眼间又到期末了，各科的课程都差不多结束了。回顾这个学期的课程，音韵学毫无疑问成为了最不科学的课，而语义学和虚词研究则成为了本学期最具科学性的两门课。这学期我在沈阳老师的语义学课程中学到了不少东西，有几节课尤其精彩，以至于当时我就拍案叫绝，发誓一定要把它们写到Blog上。最精彩的一节课是关于“把”字句分析的专题讲解，其科学性、趣味性和大众性远远超过了<a href="http://www.matrix67.com/blog/archives/477">这里</a>和<a href="http://www.matrix67.com/blog/archives/508">这里</a>的例子，成为了我向别人介绍语言学时引入的最佳例子。从对“把”字句的分析中我们可以看到更多语言学研究方法，其论证思想绝不亚于数理学科。</p>
<p>    小学语文变“把”字句“被”字句时无外乎“风把小树刮倒了”、“解放军把敌人打败了”、“大水把铁牛冲走了”，这无形之中给人带来了这样一种错觉：“把”字后面的名词是动词的宾语。例如，“小树”就是“刮”的宾语，“敌人”就是“打”的对象，“水”冲走的当然也就是“铁牛”。事实上，确实也有很多学术文章指出，“把”后名词就是动词的宾语。“宾语说”的支持者们提出了一个直观的、强有力的证据：你可以把“把”字句重新还原回主动宾结构。例如，“风把小树刮倒了”的意思就是“风刮倒了小树”，“解放军把敌人打败了”就相当于“解放军打败了敌人”，“大水把铁牛冲走了”无异于“大水冲走了铁牛”。这种说法虽然适用于绝大多数“把”字句，但也并非毫无破绽。例如，“妈妈把钱存在银行里”怎么还原为主动宾结构？妈妈存钱在银行里？妈妈存在银行里钱？都不对。这一反例足以对“宾语说”构成威胁。事实上，我们能举出很多例子来驳斥“宾语说”。一种听来奇怪但我们日常生活里常常使用的句子就是“别把自己病倒了”，这里“自己”明显只能是“病”的主语。类似的句子不止一个，像“他把老伴儿死了”、“把犯人跑了”等等，感觉虽然奇怪，但实际生活中用得不少。另一类句子更奇怪，动词和“把”后名词间根本没有直接联系，像“把肚子笑疼了”，“肚子”一词既不是“笑”的主语，也不是“笑”的宾语，事实上它与“笑”没有任何关系。“把眼睛哭肿了”、“把手帕哭湿了”也是如此，“眼睛”和“手帕”与动作“哭”没有任何结构上的联系。“宾语说”至此已完全破产。</p>
<p><span id="more-1914"></span><br>
    那么“把”字句究竟该如何做解释呢？在众人尝试修补“宾语说”时，有人逆其道而行之，大胆提出了“主语说”，认为“把”后名词其实是动词的主语，原因很简单：把这些“把”字句中的“把”字去掉后，剩下的就是标准的主谓结构。例如，“把自己病倒了”就等于“自己病倒了”，“把肚子笑疼了”就等于“肚子笑疼了”，“把眼睛哭肿了”就等于“眼睛哭肿了”。这一派观点认为，“风把小树刮倒了”这个句子是这样来的：首先“小树”是“刮倒”的受事主语，形成“小树刮倒了”这个受事主语句（动作承受者做主语的特殊句式）；然后我们用“把”字引出这个小句的“致使者”，即告诉我们是“风”造成“小树刮倒了”的结果。这一说法得到了很多人的支持，因为上述论证可谓放之四海而皆准。“我把肚子笑疼了”就是“我”造成了“肚子笑疼了”这一受事主语小句，“妈妈把钱存在银行里”即表示“妈妈”致使“钱存在银行里”这一小句发生。不过，“主语说”有一个致命的缺陷：并不是所有的主谓结构都可以按此说变回“把”字句。“犯人跑了”可以说“把犯人跑了”，但“他俩离婚了”就明显不能说成“把他俩离婚了”。这样一来，“主语说”也不是完美的。</p>
<p> <br>
    在我给朋友们讲“把”字句的分析时，每次说到这里，我总能听见朋友们的一些新见解。<br>
    听得最多的一种意见是，“宾语说”是正确的，但对于不及物动词要特殊处理。例如，“风把小树刮倒了”，“刮”是及物的，它的宾语就是“小树”；但“把肚子笑疼了”需要另行处理，因为“笑”根本不及物，不存在宾语是谁的问题。而事实上，我还真能找出这样的例句，动词是及物的，但宾语不是“把”后的名词。例如“把他唱哭了”，“唱”显然是及物的，但“他”绝对不可能作“唱”的宾语。再比如，“两杯酒就把他喝醉了”，“喝”的宾语不是“把”后的他，反而是“把”字前面的“两杯酒”。<br>
    朋友们提出过另一种有趣的见解：“宾语说”虽然破产了，但其句式转换模型仍然可用。“风把小树刮倒了”是由“风刮倒了小树”变来的，同样“把肚子笑疼了”是由“笑疼了肚子”变来的，“把犯人跑了”是由“跑了犯人”而来，“把他唱哭了”最初也就是“唱哭了他”。这样一来，不是所有的特殊情况都解决了吗？其实，这种说法也不对，漏洞和“主语说”类似：并不是所有这类句式都能变回去。“笑疼了肚子”可以变成“把肚子笑疼了”，但“看傻了眼”就不能说成“把眼看傻了”。“他喝醉了酒”绝不能变成“他把酒喝醉了”，反而应该说成是“酒把他喝醉了”。对“把”字句的分析再次陷入了困境。</p>
<p> <br>
    本学期语义学课上介绍了一种比较完美的“把”字句解释，这种解释很符合我们的语感。可能有的读者已经想到了，我们应该完全跳出这个定势思维，不要把目光集中在名词和动词的关系上，而应该好好观察一下名词和补语的关系。想到这一点，我们兴奋地发现，前面举出的所有例子中，“把”后名词都是动词补语的主体。例如，“把肚子笑疼了”，“肚子”与“笑”没关系，它只和“疼”有关系——“肚子”是“疼”的主体。类似地，“把眼睛哭肿了”暗含了“眼睛肿”的关系，“把他唱哭了”则有“他哭”的意思。这很好地解释了为什么“看傻了眼”不能变成“把眼看傻了”，因为“眼”不是“傻”的主体。另外，“他把酒喝醉了”不能说，而只能说“酒把他喝醉了”，原因也是如此。<br>
    我们还有一个更妙的例子来证明这一点。看这个例句：“这孩子追得我直喘气”。多读几遍你会发现你越来越头大：这句话的歧义太严重了，不但是谁喘气看不出来，连究竟是谁追谁也有歧义。有趣的是，把这句话变成“这孩子把我追得直喘气”，虽然我们仍然不知道是谁追谁，不过喘气的人一定是“我”，原因就在于“把”字句中“把”后名词与动词补语的关系——根据我们刚才的理论，“追”的宾语是谁我们不能确定，不过“我”一定是“直喘气”的主体。<br>
    这一派观点在语义上的分析与我们的语感很相符：“风把小树刮倒了”是想强调“小树倒了”，这一结果是致使者“风”通过“刮”的动作造成的；“妈妈把钱存在银行里”意即“妈妈去存”导致了“钱在银行里”的结果。类似地，“我把肚子笑疼了”的意思事实上就是“我笑，肚子疼了”，而“我把他唱哭了”其实就相当于“我唱，他哭了”。这种理解方式不但符合我们的语感，也符合句式上的种种限制，似乎是一件很顺理成章的事情。</p>
<p>    可我们之前为什么走了这么多弯路呢？原因就在于本文开头提到的这类容易误导人的例句：“风把小树刮倒了”、“解放军把敌人打败了”、“大水把铁牛冲走了”。在这类例句里，补语的主体恰好也就是动词的宾语，这造成了很强的混淆，让我们错误地去关注动词和“把”后名词的关系。事实上，这类例句本来的意思是“风刮”导致“小树倒了”，而“小树”碰巧又成了“刮”的宾语，带给人一种“把”字句存在动宾联系的错觉。<br>
    补语的虚化也给我们的分析带来了很多困难。例如，“把自己病倒了”的意思应该是“病，自己倒了”，但由于“倒”一词在现代汉语中已经很“虚”，因此光说某某倒了非常别扭。“把坏人抓住了”、“把东西藏好”就更虚了，不过语感上我们仍然能够接受。我们甚至还有“把话说下去”、“把孩子吓着了”一类句子，其补语的虚化程度已经让我们无法从语义上进行理解。不过，我们仍然有办法来证明“把”后名词确实是这个补语的主体。首先，这个补语不能去掉，光说“把话说”、“把孩子吓”明显不成立；然后呢，我们可以把补语换成其它的词，例如“把话说清楚”、“把孩子吓呆了”，它们结构上是相同的，以此说明上述问题确实是由补语虚化造成的。<br>
    更具有误导性并且更难以解释的情况是“把犯人跑了”、“把房子卖了”、“把书看了”一类句子。相信大多数读者立刻想到，这是由于补语进一步虚化进而省略所造成的。比如，“把犯人跑了”原本应该是“把犯人跑掉了”，只不过“掉”字虚化太严重直接导致了脱落。“把房子卖了”最初也很可能是指“卖，房子掉了”，再省略“把房子卖掉了”中的“掉”而成。不需要其它的说明，我们能想到“把书看了”其实是“把书看完了”的省略。总之，我们总可以在动词后面加一个适当的补语。问题是，如何证明这种句式确实是由补语省略造成的呢？我们有好几种证明方法。比如，前面提到过“把他俩离婚了”不能说，现在我们知道，其原因很可能是因为“离婚”后面没有适当的补语；我们还可以从历史上各个时期的文字资料中寻找句式演变的证据，用统计数据来验证句式逐渐演变的说法。不过，最精妙的证明还是下面这个。<br>
    考虑短语“别卖了”。仔细体会你会发现它有两种意思。一种意思是停止卖东西的动作，比如“城管来了，别卖了，快走吧”；另一种意思则是不要卖给别人，例如大四毕业收拾东西时好朋友可能会说“这东西很有纪念意义，别卖了，留着吧”。不过，加上一个“把”字，句子变成“别把它卖了”，瞬间就没有歧义了，这就是因为“它”一定是那个未出现的补语“掉”的主体。因此，这些看似对“补语主体说”影响颇大的“反例”事实上根本不是反例，反而进一步强化了这种理论。</p>
<p> <br>
    说到反例，没有什么理论是天衣无缝的，我们也有很多真正的反例。还真有这么一些奇怪的“把”字句，上述理论都不能解释。例如，“把盘子一摔”、“把球一扔”这一类句子该怎么解释，“把桌子擦擦”、“把衣服洗洗”又该怎么解释，直到今天仍在争论。</p>
			 ]]></content>
<pubDate>2009-05-23T16:19:07+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1914</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 等分阴阳图的N种方法 ]]></title>
<link>http://www.matrix67.com/blog/archives/1923</link>
<content><![CDATA[ 
		<p>   <img alt="image placeholder" >
<p>    阴阳图是由两个半圆弧相接组成的曲线把整个圆平分为黑白二色而成。1958年，英国数学家Henry Dudeney在他的著作Amusements in Mathematics中曾经提出了这样一个问题：如何用尺规作出一条同时平分阴阳两部分的曲线？他给出了两种不同的答案。</p>
<p> <img alt="image placeholder" >
<p>    第一种方法是非常完美的，它不但同时平分了阴阳两部分的面积，连分出来的形状也完全相同。另一种办法也非常简单，仅用一条45度倾斜的直线即可同时平分阴阳两部分。为了证明这一点，我们只需要计算一下白色的半圆形和45度扇形的面积和即可。二者的面积恰好都等于πR^2/8，其总和为πR^2/4，恰为整个白色区域的一半。由对称性，黑色面积也被平分。除此之外，你还能想到多少种平分方法呢？</p>
<p><span id="more-1923"></span></p>
<p> <br>
 <br>
   <img alt="image placeholder" >
<p>    1960，Mathematics Magazine杂志编辑C. W. Trigg给出了另外三种解法。一种简单但却很不容易想到的解法是，做一个半径为R/√<span style="text-decoration:overline">2</span>的同心圆。这个同心圆的面积恰好是整个圆面积的一半，而由对称性，黑白两部分在小圆内各占一半，在圆环上也各占一半，这说明同心圆确实把两部分面积都平分了。</p>
<p> <img alt="image placeholder" >
<p>    另一个简单的分法如图4所示，每个小圆都是大圆面积的1/4，因此显然满足要求。图5所示的则是一个很复杂但同时也很具有研究和扩展价值的分法。两个半圆弧的半径分别为R·Φ/2和R·Φ/2 + 1/2，其中Φ为黄金分割(√<span style="text-decoration:overline">5</span>-1)/2。可以通过计算验证，这条线确实将黑白二色面积各自平分。注意这种分割法背后的一个重要思想：由于大圆弧的半径始终等于小圆弧半径加上1/2，因此小圆弧半径确定了整个曲线。随着这个半径值的增加，总有一个时候它会恰好平分每一部分的面积。只要这个半径值可以用尺规做出来，我们的问题也就解决了。利用这个思想我们还可以解决一些看似很难办的数学问题，我将在下一篇日志中谈到。</p>
<p>本文来源：<a href="http://www.cut-the-knot.org/pythagoras/YinYangBisection.shtml">http://www.cut-the-knot.org/pythagoras/YinYangBisection.shtml</a></p>
			 ]]></content>
<pubDate>2009-05-25T13:36:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1923</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：如何用尺规作图将圆面积N等分 ]]></title>
<link>http://www.matrix67.com/blog/archives/1928</link>
<content><![CDATA[ 
		<p>    一条直径可以把圆面积二等分。两条互相垂直的直径可以把圆面积四等分。不过，对于任意的N，将圆面积等分为N个部分并不容易，因为圆周上的N等分点并不总是能用圆规和直尺做出来。1801年，Gauss证明了当n为2的幂和若干Fermat素数的乘积时，正n边形可以用尺规作出图来，同时他猜想这也是必要条件。1837年，Pierre Wantzel证明了这个条件的必要性。第一个无法用尺规完成作图的正多边形是正七边形，也就是说你永远无法仅用直尺和圆规找出圆周上的七等分点。<br>
    不过，这并不意味着我们不能将圆面积分成面积相等的七份。事实上，有一种方法可以将圆分成N个面积相等的部分，其中N可以为任意正整数。你能想到这种方法吗？如果我们还要求各部分周长也相等呢？</p>
<p><span id="more-1928"></span></p>
<p> <br>
 <br>
  <img alt="image placeholder" >
<p>    上图就是一种将圆面积等分为七块的示意图。这些同心圆的半径分别为√<span style="text-decoration:overline">1/7</span>, √<span style="text-decoration:overline">2/7</span>, …, √<span style="text-decoration:overline">6/7</span>。注意这些值都是可以用尺规作出来的。注意两直角边分别为1和√<span style="text-decoration:overline">a</span>的直角三角形，斜边为√<span style="text-decoration:overline">a+1</span>。从a=1开始出发不断迭代，我们可以依次作出√<span style="text-decoration:overline">2</span>、√<span style="text-decoration:overline">3</span>、√<span style="text-decoration:overline">4</span>等值，再利用相似三角形即可完成除法操作。</p>
<p>  <img alt="image placeholder" >
<p> <br>
 <br>
    不过，这个分法并不算一个“正统”的分割方法。如果我们要求每个线条都必需从圆周上出发，并且落脚于圆周上的另一点呢？</p>
<p>  <img alt="image placeholder" >
<p>    存在很多等分圆面积的切分方案，但我们却不能用尺规作出来。例如，用N-1根平行的直线总能把圆面积等分为N份，可惜每根直线的位置在哪里需要用到微积分计算，其结果是一个超越方程，无法用尺规作图完成。当然，能用尺规作图完成的分割方法还是有的，不过要想到这种方法并不容易。我们首先作出直径上的七等分点（注意尺规N等分给定线段是可以办到的——可以利用前面的相似三角形做法得到1/N的长度），然后像图中那样依次作出12个半圆弧。做一些简单的计算就可以验证，这些半圆弧形成的七个区域的面积确实是相等的。<br>
    另外，值得一提的是，这个切分方法还有一个神奇的性质：它的每一部分的周长都是相等的。</p>
			 ]]></content>
<pubDate>2009-05-27T02:32:19+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1928</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 所有进制都是10进制 ]]></title>
<link>http://www.matrix67.com/blog/archives/1939</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>来源：<a href="http://cowbirdsinlove.com/43">http://cowbirdsinlove.com/43</a></p>
			 ]]></content>
<pubDate>2009-05-27T17:35:27+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1939</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 牛题：等边三角形内接圆上一点到三顶点距离平方和不变 ]]></title>
<link>http://www.matrix67.com/blog/archives/1947</link>
<content><![CDATA[ 
		<p> <img alt="image placeholder" >
<p>如图，等边三角形ABC，P为三角形内接圆上一点。求证，AP^2 + BP^2 + CP^2为常数。</p>
<p><span id="more-1947"></span></p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p> <img alt="image placeholder" >
<p>证明：把整个图形放在三维空间里，其中A=(1,0,0)，B=(0,1,0)，C=(0,0,1)。因此，三角形ABC位于平面x+y+z=1上。图中的内接圆即为某个以原点为球心的球x^2 + y^2 + z^2 = r与该平面相交所得（其中r是某个常数）。于是，我们有</p>
<p>   AP^2 + BP^2 + CP^2<br>
= (1-x)^2 + y^2 + z^2 +<br>
   x^2 + (1-y)^2 + z^2 +<br>
   x^2 + y^2 + (1-z)^2<br>
= 3·(x^2 + y^2 + z^2) – 2·(x + y + z) + 3<br>
= 3·r – 2 + 3<br>
= 常数</p>
<p>来源：<a href="http://www.cut-the-knot.org/pythagoras/EquiIn3D.shtml">http://www.cut-the-knot.org/pythagoras/EquiIn3D.shtml</a><br>
查看更多：<a href="http://www.matrix67.com/blog/archives/58">几个把平面几何问题的辅助线做到空间去的数学趣题</a></p>
			 ]]></content>
<pubDate>2009-05-28T20:34:39+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1947</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 我所见过的最酷的排序算法演示 ]]></title>
<link>http://www.matrix67.com/blog/archives/1942</link>
<content><![CDATA[ 
		<p>网上有各种直观的排序算法图形化演示（见<a href="http://www.hatfulofhollow.com/posts/code/visualisingsorting/index.html">这里</a>和<a href="http://home.westman.wave.ca/~rhenry/sort/">这里</a>），我自己也曾经<a href="http://www.matrix67.com/blog/archives/1763">做过一个</a>。<br>
今天我看到了一个我所见过的最酷的、最可爱的排序算法演示。<br>
某网站被干掉了后，大家会错过很多精彩的视频。我注册了一个土豆网的帐号，把一些精彩的视频搬过来与大家分享。</p>
<p><object width="420" height="363"><param name="movie" value="http://www.tudou.com/v/htKY1-Rj9ZE">
<param name="allowFullScreen" value="true">
<param name="allowscriptaccess" value="always">
<param name="wmode" value="opaque">
<embed src="http://www.tudou.com/v/htKY1-Rj9ZE" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="420" height="363"></embed></object></p>
<p>原地址：<a href="http://www.youtube.com/watch?v=vxENKlcs2Tw">http://www.youtube.com/watch?v=vxENKlcs2Tw</a></p>
			 ]]></content>
<pubDate>2009-05-30T01:49:55+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1942</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 网友来信：另类线段等分法与距离平方和问题的扩展 ]]></title>
<link>http://www.matrix67.com/blog/archives/1954</link>
<content><![CDATA[ 
		<p>    在介绍<a href="http://www.matrix67.com/blog/archives/1928">尺规作图等分圆面积</a>时，我提到了利用尺规作图将线段AB任意等分的问题。在初中课本上，这个问题的标准做法如下：</p>
<blockquote><p> <img alt="image placeholder" >
 <br>
  1. 过A点向另一方向做射线l；<br>
  2. 从A点开始，用圆规在射线l上截取n个等距的点X<sub>1</sub>, X<sub>2</sub>, …, X<sub>n</sub>；<br>
  3. 连接X<sub>n</sub>和B；<br>
  4. 分别过X<sub>1</sub>, X<sub>2</sub>, …, X<sub>n-1</sub>作直线平行于X<sub>n</sub>B。</p></blockquote>
<p>    那么，这些平行线与AB的交点即为AB的n等分点。</p>
<p><span id="more-1954"></span><!--more--><br>
    不过，这并不是等分给定线段的唯一做法。在讲解尺规作图时，<a href="http://en.wikipedia.org/wiki/Compass_and_straightedge_constructions">Wikipedia</a>上给出了一种另类的线段三等分做法：</p>
<blockquote><p> <img alt="image placeholder" >
 <br>
  1. 以AB为半径，分别以A、B为圆心作圆，两圆交于C、D；<br>
  2. 以C为圆心，AC为半径作圆；<br>
  3. 延长AC与圆C交于E；<br>
  4. 连接DE与线段AB交于F。</p></blockquote>
<p>    则点F就是AB的三等分点。</p>
<p>    网友<a href="mailto:liuqingwei#msn.com">Liu Qingwei</a>发来邮件说，以前他在某杂志上看到与上面所说方法都不相同的线段n等分法。</p>
<blockquote><p>
 <img alt="image placeholder" >
 <br>
  1. 作出矩形ABDC；<br>
  2. 作出BC和AD的交点，它在AB上的垂足P<sub>1</sub>就是AB的二等分点；<br>
  3. 作出P<sub>1</sub>C和AD的交点，它在AB上的垂足P<sub>2</sub>就是AB的三等分点；<br>
  4. 作出P<sub>2</sub>C和AD的交点，它在AB上的垂足P<sub>3</sub>就是AB的四等分点；<br>
   ………
</p></blockquote>
<p>    这样，我们就可以作出线段AB的任意等分点。这个做法的意义在于，我们可以抛弃圆规，只用矩尺便能实现线段的任意等分。</p>
<p> <br>
   ======================== 我的名字是分割线 ========================<br>
 </p>
<p>    写一个Blog最开心的事情就是能认识各种网友。一位<a href="http://hi.baidu.com/dj%BC%D3%B7%C6%D6%DA">电台DJ</a>留言说他将我前几天写的<a href="http://www.matrix67.com/blog/archives/1947">距离平方和问题</a>进行了<a href="http://hi.baidu.com/dj%BC%D3%B7%C6%D6%DA/blog/item/75b704f1d8df4fcb7831aa88.html">推广</a>。注意原问题中内切圆根本不是一个必要的条件，只要是以等边三角形中心为圆心作出的圆，结论都仍然成立。这给了我们很多推广的空间。我们不由得开始猜想，对于一般三角形还有类似的结论吗？可惜的是，用几何画板一画，不但以三角形内心为圆心作圆后原结论不再成立，就连根正苗红的内切圆也失去了原有的性质。为此，我们回到原问题中的证明过程上去。为什么那个证明只对等边三角形有效，对一般三角形就不管用了呢？我们照葫芦画瓢，把一般三角形也放到平面x+y+z=1上，不妨记三个顶点分别在(x1, y1, z1)、(x2, y2, z2)、(x3, y3, z3)，那么所求的距离平方和就应该是x-x1、x-x2、x-x3、y-y1、y-y2、y-y3、z-z1、z-z2、z-z3的平方和。展开后，x^2、y^2和z^2的系数是相同的，它们的和仍然是一个常数。常数项本身就是常数，我们也不必关心它。问题的关键就出在一次项上：式子展开后x、y、z的系数必需相同才能巧用x+y+z=1代换，但这在一般三角形中不一定成立。约去一个比例系数，三个一次项的系数分别为x1+x2+x3、y1+y2+y3、z1+z2+z3。因此，要想让原来的证明仍然适用，必需保证这三组和相等。注意到对每一组(x,y,z)我们都有x+y+z=1，因此9个变量之和应该为3，我们立即可知这三组和其实都等于1。有趣的事情来了，考虑该三角形的质心，(x1+x2+x3)/3、(y1+y2+y3)/3、(z1+z2+z3)/3都等于1/3，而(1/3, 1/3, 1/3)恰好又是平面x+y+z=1上离原点距离最近的位置（也即球x^2+y^2+z^2=r与其相交所成圆的圆心）。因此，我们立即得到这一结论：原题的结论仍然适用于一般三角形及其对应的质心。<br>
    进一步观察我们发现，上述推理过程对于任意多个点都是适用的。对于一个四边形来说，所有12个坐标值的和为4，因此x1+x2+x3+x4、y1+y2+y3+y4、z1+z2+z3+z4均为4/3，其对应的质心坐标依旧为(1/3, 1/3, 1/3)。我们甚至还可以大胆预言，该推理过程甚至能继续适用于更高维的情况……正是这种无穷无尽的推广空间才让数学充满了生机，让思考充满了惊喜和乐趣。</p>
			 ]]></content>
<pubDate>2009-06-02T19:08:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1954</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：构造整数域上的函数f使得f(f(n))等于-n ]]></title>
<link>http://www.matrix67.com/blog/archives/1972</link>
<content><![CDATA[ 
		<p>    <a href="http://stackoverflow.com">StackOverflow</a>最近<a href="http://stackoverflow.com/questions/731832/interview-question-ffn-n">有一个面试题</a>特别火爆：构造一个定义域和值域都是全体整数的函数f使得f(f(n)) = -n。如果你不能设计出函数对于所有n都成立，那就设计函数能够满足尽可能多的数。</p>
<p>    一些比较容易想到的解如：<br>
<code>if n &gt; 0:<br>
    return -n<br>
else:<br>
    return n</code><br>
    不过这个函数只适用于所有非负整数。当然，这并不是我们的最优解。你还能想到更好的办法吗？</p>
<p><span id="more-1972"></span><br>
    在思考这个问题时，我想到了一个奇妙的解：找一个非常非常大的素数p，然后定义函数f(n)为<br>
<code>if n % p == 0:<br>
    return - n / p<br>
else:<br>
    return n * p</code></p>
<p>    这个函数可以满足更多的数——只要n不含有因子p，函数总能使得f(f(n)) = -n。因此，取充分大的素数p，满足要求的整数可以任意多。</p>
<p>    StackOverflow上的网友给出了下面这个答案，它对所有整数均成立：<br>
<code>if n == 0: return 0<br>
if n &gt;= 0:<br>
    if n % 2 == 1:<br>
        return n + 1<br>
    else:<br>
        return -1 * (n - 1)<br>
else:<br>
    if n % 2 == 1:<br>
        return n - 1<br>
    else:<br>
        return -1 * (n + 1)</code></p>
<p>    其实基本思想很简单：考虑四个数(a, b, -a, -b)。令f(a)=b, f(b)=-a, f(-a)=-b, f(-b)=a，则该函数对这四个数都满足要求。然后呢，只需要注意到函数对这四个数封闭，因此不断取(1, 2, -1, -2)、(3, 4, -3, -4)、(5, 6, -5, -6)……并对它们分别做类似的定义就可以了。</p>
<p>  =================== 我是可爱的分割线 ===================</p>
<p>    另一个<a href="http://stackoverflow.com/questions/732485/interview-question-ffx-1-x">类似的题目</a>则是要求你设计函数f使得f(f(n)) = 1/n对所有实数都成立。解决办法也非常妙：<br>
<code>if n &gt;= 0<br>
    return -1/x<br>
else:<br>
    return -x</code></p>
<p> <br>
 <br>
来源：<a href="http://techblog.zellux.czm.cn/2009/06/two-function-related-interview-questions/">http://techblog.zellux.czm.cn/2009/06/two-function-related-interview-questions/</a></p>
			 ]]></content>
<pubDate>2009-06-08T03:46:38+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1972</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：存在三个Fibonacci数a,b,c使得a^2+b^2=c^2吗？ ]]></title>
<link>http://www.matrix67.com/blog/archives/1979</link>
<content><![CDATA[ 
		<p>问题1： 请找出所有满足a^2 + b^2 = c^2的三元组(a,b,c)，其中a、b、c三个数都是Fibonacci数。<br>
答案： <span style="color:#E5E5E5">你被忽悠了。注意到一组勾股数中绝对不可能有相等的数，而对于任意的m &lt; n &lt; p，以F<sub>m</sub>、F<sub>n</sub>、F<sub>p</sub>为边长的三角形都不存在，因为F<sub>m</sub> + F<sub>n</sub> ≤ F<sub>n-1</sub> + F<sub>n</sub> = F<sub>n+1</sub> ≤ F<sub>p</sub>始终成立。</span></p>
<p>问题2： 求以(F<sub>n</sub>, F<sub>n+1</sub>, F<sub>n+2</sub>)、(F<sub>n+3</sub>, F<sub>n+4</sub>, F<sub>n+5</sub>)、(F<sub>n+6</sub>, F<sub>n+7</sub>, F<sub>n+8</sub>)、(F<sub>n+9</sub>, F<sub>n+10</sub>, F<sub>n+11</sub>)为顶点的四面体的体积，其中F<sub>n</sub>表示第n个Fibonacci数。<br>
答案： <span style="color:#E5E5E5">你又被忽悠了。事实上，这个四面体根本就不存在。事实上，对任意m、n、p、q，以(F<sub>m</sub>, F<sub>m+1</sub>, F<sub>m+2</sub>)、(F<sub>n</sub>, F<sub>n+1</sub>, F<sub>n+2</sub>)、(F<sub>p</sub>, F<sub>p+1</sub>, F<sub>p+2</sub>)、(F<sub>q</sub>, F<sub>q+1</sub>, F<sub>q+2</sub>)为顶点的四面体都不存在，因为它们都落在平面x+y=z上，四个点共面，所构成的四面体体积总为0。</span></p>
<p>来源：<a href="http://www.cut-the-knot.org/blue/FibonacciQuickies.shtml">http://www.cut-the-knot.org/blue/FibonacciQuickies.shtml</a></p>
			 ]]></content>
<pubDate>2009-06-08T17:35:57+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1979</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Wolfram|Alpha彩蛋大合集 ]]></title>
<link>http://www.matrix67.com/blog/archives/1994</link>
<content><![CDATA[ 
		<p><a href="http://www.matrix67.com/blog/archives/1882">Wolfram|Alpha</a>发布后又经过了多次更新，现在已经是越来越强大了。不仅如此，Wolfram|Alpha的幽默感也越来越强，网上频频爆出各种搞笑的Wolfram|Alpha彩蛋。我专门收集了一下目前网上已知的Wolfram|Alpha彩蛋，在这里做一个合集。</p>
<p> <br>
<strong>关于Wolfram|Alpha自己</strong><br>
<a href="http://www.wolframalpha.com/input/?i=Hello!" target="_blank">Hello!</a><br>
<a href="http://www.wolframalpha.com/input/?i=Who%20are%20you?" target="_blank">Who are you?</a><br>
<a href="http://www.wolframalpha.com/input/?i=What's%20your%20name?" target="_blank">What’s your name?</a><br>
<a href="http://www.wolframalpha.com/input/?i=Where%20are%20you?" target="_blank">Where are you?</a><br>
<a href="http://www.wolframalpha.com/input/?i=How%20old%20are%20you?" target="_blank">How old are you?</a><br>
<a href="http://www.wolframalpha.com/input/?i=What%20will%20you%20do?" target="_blank">What will you do?</a><br>
<a href="http://www.wolframalpha.com/input/?i=What%20do%20you%20like?" target="_blank">What do you like?</a><br>
<a href="http://www.wolframalpha.com/input/?i=Do%20you%20eat?" target="_blank">Do you eat?</a><br>
<a href="http://www.wolframalpha.com/input/?i=Do%20you%20speak%20Chinese?" target="_blank">Do you speak Chinese?</a><br>
<a href="http://www.wolframalpha.com/input/?i=Can%20you%20help%20me?" target="_blank">Can you help me?</a><br>
<a href="http://www.wolframalpha.com/input/?i=I%20Love%20You" target="_blank">I Love You</a></p>
<p><a href="http://www.wolframalpha.com/input/?i=hello%20world" target="_blank">hello world</a><br>
<a href="http://www.wolframalpha.com/input/?i=WolframAlpha%20Logo" target="_blank">WolframAlpha Logo</a><br>
<a href="http://www.wolframalpha.com/input/?i=Can%20you%20pass%20the%20Turing%20Test?" target="_blank">Can you pass the Turing Test?</a><br>
<a href="http://www.wolframalpha.com/input/?i=What%20is%20the%20world's%20most%20powerful%20software?" target="_blank">What is the world’s most powerful software?</a></p>
<p><span id="more-1994"></span><br>
<strong>Wolfram|Alpha也会说人话</strong><br>
<a href="http://www.wolframalpha.com/input/?i=A%20penny%20saved" target="_blank">A penny saved</a><br>
<a href="http://www.wolframalpha.com/input/?i=A%20bird%20in%20the%20hand" target="_blank">A bird in the hand</a><br>
<a href="http://www.wolframalpha.com/input/?i=1%20apple/day" target="_blank">1 apple/day</a><br>
<a href="http://www.wolframalpha.com/input/?i=a%20man,%20a%20plan,%20a%20canal" target="_blank">a man, a plan, a canal</a></p>
<p> <br>
<strong>电影、小说和游戏</strong><br>
<a href="http://www.wolframalpha.com/input/?i=Who%20is%20Clark%20Kent?" target="_blank">Who is Clark Kent?</a><br>
<a href="http://www.wolframalpha.com/input/?i=Who%20is%20Bruce%20Wayne?" target="_blank">Who is Bruce Wayne?</a><br>
<a href="http://www.wolframalpha.com/input/?i=Who%20is%20Peter%20Parker?" target="_blank">Who is Peter Parker?</a><br>
<a href="http://www.wolframalpha.com/input/?i=Who%20is%20Bruce%20Banner?" target="_blank">Who is Bruce Banner?</a></p>
<p><a href="http://www.wolframalpha.com/input/?i=Are%20you%20Skynet?" target="_blank">Are you Skynet?</a><br>
<a href="http://www.wolframalpha.com/input/?i=When%20is%20Judgement%20Day?" target="_blank">When is Judgement Day?</a></p>
<p><a href="http://www.wolframalpha.com/input/?i=Open%20the%20pod%20bay%20doors,%20HAL" target="_blank">Open the pod bay doors, HAL</a><br>
<a href="http://www.wolframalpha.com/input/?i=What's%20the%20problem?" target="_blank">What’s the problem?</a></p>
<p><a href="http://www.wolframalpha.com/input/?i=88%20mph" target="_blank">88 mph</a> （仔细看Comparisons栏）<br>
<a href="http://www.wolframalpha.com/input/?i=To%20be%20or%20not%20to%20be" target="_blank">To be or not to be</a><br>
<a href="http://www.wolframalpha.com/input/?i=Answer%20to%20the%20life,%20the%20universe,%20and%20everything" target="_blank">Answer to the life, the universe, and everything</a><br>
<a href="http://www.wolframalpha.com/input/?i=limit%20(the%20meaning%20of%20life)%20as%20t%20-&gt;%20infinity%E2%80%9D%20target=%E2%80%9D_blank%E2%80%9D&gt;limit%20(the%20meaning%20of%20life)%20as%20t%20-&gt;%20infinity&lt;/a&gt;&lt;br%20/&gt;%0A&lt;a%20href=" http: in the world is carmen sandiego target="_blank">Where in the world is Carmen Sandiego?</a></p>
<p> <br>
<strong>不是问题的问题</strong><br>
<a href="http://www.wolframalpha.com/input/?i=Why%20did%20the%20chicken%20cross%20the%20road?" target="_blank">Why did the chicken cross the road?</a><br>
<a href="http://www.wolframalpha.com/input/?i=How%20much%20wood%20would%20a%20woodchuck%20chuck%20if%20a%20woodchuck%20could%20chuck%20wood?" target="_blank">How much wood would a woodchuck chuck if a woodchuck could chuck wood?</a><br>
<a href="http://www.wolframalpha.com/input/?i=How%20many%20angels%20can%20dance%20on%20the%20head%20of%20a%20pin?" target="_blank">How many angels can dance on the head of a pin?</a><br>
<a href="http://www.wolframalpha.com/input/?i=What%20came%20first,%20the%20chicken%20or%20the%20egg?" target="_blank">What came first, the chicken or the egg?</a><br>
<a href="http://www.wolframalpha.com/input/?i=Where%20do%20babies%20come%20from?" target="_blank">Where do babies come from?</a> （“从垃圾堆里捡来的”的境外版）</p>
<p> <br>
<strong>不该问Wolfram|Alpha的问题</strong><br>
<a href="http://www.wolframalpha.com/input/?i=How%20do%20I%20get%20a%20date?" target="_blank">How do I get a date?</a><br>
<a href="http://www.wolframalpha.com/input/?i=How%20do%20I%20win%20the%20lottery?" target="_blank">How do I win the lottery?</a><br>
<a href="http://www.wolframalpha.com/input/?i=Where's%20my%20car?" target="_blank">Where’s my car?</a> / <a href="http://www.wolframalpha.com/input/?i=Where%20did%20I%20put%20my%20keys?" target="_blank">Where did I put my keys?</a></p>
<p> <br>
<strong>真正的问题</strong><br>
<a href="http://www.wolframalpha.com/input/?i=Can%20entropy%20be%20reversed?" target="_blank">Can entropy be reversed?</a><br>
<a href="http://www.wolframalpha.com/input/?i=Why%20is%20the%20sky%20blue?" target="_blank">Why is the sky blue?</a><br>
<a href="http://www.wolframalpha.com/input/?i=P=NP?" target="_blank">P=NP?</a></p>
<p> <br>
<strong>河蟹在美国</strong><br>
<a href="http://www.wolframalpha.com/input/?i=f__k" target="_blank">f__k</a><br>
<a href="http://www.wolframalpha.com/input/?i=n_ggers" target="_blank">n_ggers</a> (People who annoy you…)<br>
<a href="http://www.wolframalpha.com/input/?i=what%20the%20fuck" target="_blank">what the fuck</a></p>
<p> <br>
<strong>最后，最佳彩蛋的得主是：</strong></p>
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2009-06-10T00:03:37+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1994</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ PSP上的两个时间类动作解谜游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/2031</link>
<content><![CDATA[ 
		<p><object width="420" height="363"><param name="movie" value="http://www.tudou.com/v/HxjQCCejM9s">
<param name="allowFullScreen" value="true">
<param name="allowscriptaccess" value="always">
<param name="wmode" value="opaque">
<embed src="http://www.tudou.com/v/HxjQCCejM9s" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="420" height="363"></embed></object></p>
<p>当众人都注目于E3上的大作时，我却偏偏热衷于寻找各种有创意的解谜小游戏。07年的E3上，Sony发布了一款独具创意的PSP游戏<a href="http://www.matrix67.com/blog/archives/254">Echochrome</a>，在该游戏里玩家需要通过空间错觉完成各种任务。时隔两年，在今年的E3大展上，Sony公布了一款Echochrome的续作——Echochrono。这款续作把焦点转移到了时间上，玩家需要利用时间变换来完成各种任务。游戏的基本思想很简单，既你现在的举动将和未来重叠起来，换句话说你需要凭借你过去的“影子”来帮你完成任务。去年年初的一个小小的Flash游戏<a href="http://www.matrix67.com/blog/archives/408">Cursor*10</a>为游戏界带来了巨大的影响，解密游戏领域中赫然出现了一块从来没有被挖掘过的空间。现在，PC上有了<a href="http://www.winterbottomgame.com/">The Misadventures of P.B. Winterbottom</a>（尚未发布），XBOX 360上有了<a href="http://www.matrix67.com/blog/archives/1705">Braid</a>。Echochrono填补了PSP上的这一块空白。</p>
<p><span id="more-2031"></span><br>
 <br>
<object width="420" height="363"><param name="movie" value="http://www.tudou.com/v/0wFJyyvRVV0">
<param name="allowFullScreen" value="true">
<param name="allowscriptaccess" value="always">
<param name="wmode" value="opaque">
<embed src="http://www.tudou.com/v/0wFJyyvRVV0" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="420" height="363"></embed></object></p>
<p>但是，这次Sony似乎晚了一步。一个名叫《走自己坚信之路》的游戏近日刚刚发行，它除了拥有时间解谜这一元素外，还拥有一个非常酷的背景——忍者分身。最近入手PSP3000，过足了动作解谜游戏的瘾；现在就等着《走自己坚信之路》了，不知道各大汉化组会不会做这个游戏。</p>
<p> <br>
 <br>
另附：我画图用的Paint.NET、Mathematica、GeoGebra和几何画板，大家不要再问了！<br>
欲知其它消息请移步<a href="http://www.matrix67.com/blog/faq">FAQ</a>，还有什么疑问大家可以在本日志评论里说说。</p>
			 ]]></content>
<pubDate>2009-06-13T00:55:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/2031</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣图一张：《几何原本》拓扑结构图 ]]></title>
<link>http://www.matrix67.com/blog/archives/2078</link>
<content><![CDATA[ 
		<p>上网闲逛时偶然看到这么一张图。这个图是作者用<a href="http://www.matrix67.com/blog/archives/160">Graphviz</a>生成的。</p>
<p><img alt="image placeholder" >
<p><span id="more-2078"></span></p>
<p>来源：<a href="http://joningram.org/blog/2008/09/exploring-euclids-elements/">http://joningram.org/blog/2008/09/exploring-euclids-elements/</a><br>
大家可以对照<a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/bookI.html">这里</a>来看。</p>
			 ]]></content>
<pubDate>2009-07-01T01:32:41+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/2078</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一个实际问题：如何放本本使得其占地面积最小？ ]]></title>
<link>http://www.matrix67.com/blog/archives/2085</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>    我的书桌已经乱到一定的程度了，以至于每次把笔记本从包包里拿出来，准备把它放到桌子上去时，我都要在桌子上非常下功夫地寻找一块能够放得下本本的空地。久而久之，我开始思考：怎样放置笔记本才能使得它占据桌面的面积最小，而又保证它不会掉下去呢？</p>
<p><span id="more-2085"></span></p>
<p> <br>
<img alt="image placeholder" >
<p>    直觉告诉我们，最优的放置法应该是让笔记本中心正好与桌角重合，且与桌面的直角边成45度角（如图1）。假设笔记本的宽度为1，则该方案占据了1/4个单位的面积。我们猜测这个解不可能更优了，毕竟这是最对称的一个解。证明这个结论很简单。我们先来考虑笔记本重心与桌角重合的情况。</p>
<p> <br>
 <br>
<img alt="image placeholder" >
<p>    假如我们的本本是正方形的话，问题就直接解了：不管以什么角度放在桌子一角，只要重心与桌角重合，所占的面积必然是1/4个单位（图2）。</p>
<p> <br>
 <br>
<img alt="image placeholder" >
<p>    对于长方形的本本，只需要考虑长方形内所含的正方形（如图3）。可以看到，1/4个单位的面积（蓝色区域）无论如何都不会消失；想要消除图3中多出来的那块红色区域，我们必需把本本像图4那样成45度角地放置。</p>
<p> <br>
 <br>
<img alt="image placeholder" >
<p>    至于重心不在桌角的情况，道理和上面一样：用沿桌子直角边平行的线把本本区域里的那个正方形分成四等份，则左上角那块区域一定在桌子内，因此，无论如何本本占地面积都不会小于1/4。</p>
<p> <br>
 </p>
<p><img alt="image placeholder" >
<p>    注意到，上面的这些证明都假设我的桌面足够大，或者说桌子有两条边靠墙。如果本本下面用的是床上小桌板呢？此时，如图6所示，上述的证明不再成立，因为桌面太小可能导致那1/4个正方形伸出桌面。下面我们说明，假设桌子的宽度至少也是1个单位，那么1/4这个解依然是最优的。</p>
<p> <br>
 <br>
<img alt="image placeholder" >
<p>    如果桌子宽度至少有1个单位，那么不管本本的重心在哪里，它到桌子四条边的距离中至少有两个超过了1/2。因此，桌面内必然能容得下一个半径为1/2的90度扇形。不过，这个扇形的面积只有大约0.2的面积，离我们的目标还有一定的距离。为此，让我们考虑在正方形的内接圆中作一块面积恰为1/4的图形，如图7。红色和绿色区域的面积均恰为1/4，据计算可知超出中心的那部分宽度大约为0.1。这样，不管本本怎么放，桌面上几乎总能容下一块红色区域或其旋转、翻转后的图形，除非本本的重心和离它最近的两条边的距离都小于0.1（图8.2中的蓝色区域）。而在这种特殊情况下，之前的那种老的证明方法又管用了，因为1/4个正方形的“高度”或者“宽度”不会超过根号2的一半，约为0.7，它不可能超出桌面的另一端。</p>
<p><img alt="image placeholder" >
<p>本文来源于<a href="http://arxiv.org/PS_cache/arxiv/pdf/0906/0906.0809v1.pdf">这篇论文</a>。原文中还有一些有趣的结论，感兴趣的话可以看看。</p>
			 ]]></content>
<pubDate>2009-07-02T17:30:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/2085</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：推箱子游戏所需步数可达指数级 ]]></title>
<link>http://www.matrix67.com/blog/archives/2095</link>
<content><![CDATA[ 
		<p>    今天在写一个稿件时又翻阅了一下<a href="http://www.stetson.edu/~efriedma/">Erich Friedman</a>的<a href="http://www.stetson.edu/~efriedma/mathmagic/archive.html">Math Magic</a>，发现了一个<a href="http://www.stetson.edu/~efriedma/mathmagic/0300.html">有趣的东西</a>——场地大小为n的推箱子游戏所需要的最少步数最坏情况是多少。下面这个构造说明，最坏情况至少也是指数级的。</p>
<p>    首先，让我们来看看该构造中的一个基本单元：</p>
<p>   <img alt="image placeholder" >
<p>    这个构造中共有6个箱子，且它们都已经在目的位置上了。不难看出：<br>
    1. 假如你人在这个区域之外，你只可能从右上角的出入口进入该区域，从其它地方进去都会导致死局<br>
    2. 从右上角进入后你只能往下走，进入1区；走左边的话直接导致死局<br>
    3. 你可以通过2区前往3区，但若从3区左上角的出口出去了，则2区动过的箱子将永远无法回到原位（除非你原路返回）<br>
    4. 你可以通过2区前往3区，并把3区左边的那个箱子左移一格，再返回2区；这样下次你再从右上角进入该区域时便可以直接经过3区从左上角出去<br>
    5. 最后你只能从4区离开</p>
<p><span id="more-2095"></span></p>
<p> <br>
 <br>
<img alt="image placeholder" >
<p>    把n个这样的构造串联起来，从右至左分别记作A_1, A_2, …, A_n。再在A_n左边附加一个只进不出的机关和一个需要移动一下的箱子。因此，整个图一共有6n+2个箱子，只有一个箱子不在目标位置。你的任务就是从A_1的最右边一直杀到A_n的最左边，并且保证此时A_1到A_n的所有箱子仍在原位上；然后进入A_n的左上角那块附加区域，把那个箱子推进去。<br>
    不难看出，这个构造的唯一解便是从A_1的右上角进去，经过A_1的1区和2区，把A_1左上角的那个箱子向左推一格，然后从A_1下方出来；再次从A_1右上角进入，直接左行并从左上角出去，来到A_2的右上角；然后绕行A_2的1区和2区，把A_2左上角的箱子向左推一格，再从A_2下端出来。但注意到，此时A_1的状态又被还原了，你又无法直接从A_1左上角出去了；为了进入A_3，你不得不又重复刚才做的事情，把A_1左上角的箱子左移，出去之后再进来一遍。而进入A_3后，A_1和A_2的状态又都被还原了，于是你又不得不递归地处理A_1和A_2。因此，整个棋局的移动的步数显然是指数级的。</p>
			 ]]></content>
<pubDate>2009-07-05T20:35:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/2095</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
</channel>
</rss>
