<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Matrix67: The Aha Moments</title>
<description></description>
<link>http://www.matrix67.com/blog</link>
<pubDate>2021-11-20T14:45:25+08:00</pubDate>
<!-- other elements omitted from this example -->
<item>
<title><![CDATA[ 分形生活之四：Kögra分形字体 ]]></title>
<link>http://www.matrix67.com/blog/archives/537</link>
<content><![CDATA[ 
		<p>  <img alt="image placeholder" >
<p><span id="more-537"></span><br>
  <img alt="image placeholder" >
<p>链接：<a href="http://www.siggiodds.com/kogra.html">http://www.siggiodds.com/kogra.html</a><br>
来源：<a href="http://ffffound.com/image/6cbb86cf91a2fda90c5aa73c315442826dc3a958">http://ffffound.com/image/6cbb86cf91a2fda90c5aa73c315442826dc3a958</a></p>
			 ]]></content>
<pubDate>2008-06-13T20:15:49+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/537</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：质数无穷多与两个更强的命题 ]]></title>
<link>http://www.matrix67.com/blog/archives/539</link>
<content><![CDATA[ 
		<p>    又回来更新啦！虽然还有两门课没考，但今天已经轻松了不少。梦魇般的现代文学史总算是结束了。抱了两天两夜的佛脚，结果考试时一看卷子，仍然没一道会的题目。不定项选择多选少选均不得分，都是些文学常识题，给四篇我从没见过的小说名字问哪些是第一人称叙事，或者给四个人名字问哪些是笔名之类的。天哪……以后的古代文学史咋办啊。<br>
    先强烈推荐一本好书。前几天在<a href="http://groups.google.com/group/pongba/browse_thread/thread/752a7af6f2306149#">TopLanguage</a>看到有牛人推荐Proofs from THE BOOK这本书，当即决定买了下来。这几天复习累了我都在看这本书，真的是很好很强大，里面汇集了很多著名问题的经典证明，包括很多我一直想找但没找到的证明。好了不多废话了，下面进入正题。</p>
<p>    很早以前，我们曾经研究过<a href="http://www.matrix67.com/blog/archives/234">质数</a>，证明了质数有无穷多个。后来，我们又学到了<a href="http://www.matrix67.com/blog/archives/282">另外两种证明质数无穷多的方法</a>。这两种方法的基本思路相同：寻找一个无穷大的集合，里面的数两两互质。只用有限个质数明显不能得到无穷多个两两互质的数，于是我们立即可知质数必然有无穷多个。今天，我们将证明两个比质数无穷多更强的定理。这两个证明都出自Proofs from THE BOOK的第一章。</p>
<p>    定义函数π(x)为“小于等于x的质数有多少个”。无妨规定x为一个正整数。我们将用初等微积分方法证明当x趋于无穷时π(x)也趋于无穷并给出π(x)的一个下界。我们将说明，对于所有x，π(x)&gt;=log(x)-1，即x以内的质数至少有log(x)-1个。<br>
    为了说明这一点，让我们考虑所有不超过x的质数的倒数的等比级数(1 + 1/p + 1/p^2 + ..)的乘积，即<img alt="image placeholder" >
    回忆等比级数的公式，则我们有：</p>
<p>  <img alt="image placeholder" >
<p>    第二行的一些变换非常巧妙。第二行中间的不等号是一个关键，用到了一个基本事实：第k个质数显然比k大。最后的连乘中前一项的分子和后一项的分母正好抵消，最后消完了就只剩了一个π(x)+1。<br>
    另一方面，想像一下把(1+1/2+1/4+…)(1+1/3+1/9+…)(1+1/5+1/25+…)…展开的样子，很显然展开后的每一项都是一个所有质因子都不大于x的数的倒数，即Σ(1/m)，其中m取所有仅含1..x范围内的质因子的数。显然，原本就比x小的数，其质因子当然不可能超过x，这就是说从1到x的所有正整数都是属于m的。利用一些微积分的基本知识，我们可以立即得出Σ(1/m) &gt;= 1+1/2+1/3+…+1/x &gt;= log(x)。地球人都知道，log(x)是没有上界的，于是质数的个数也没有上界。<br>
    <a href="http://www.matrix67.com/blog/archives/504">这里</a>还有一个类似的问题，大家可以对照着看看。</p>
<p><span id="more-539"></span><br>
    Proofs from THE BOOK中还提到了另一个更绝的定理及其证明。下面我们将说明，质数不但有无穷多个，而且它们的倒数和发散。我们将用反证法，先假设<img alt="image placeholder" >
    假设<img alt="image placeholder" >总成立。下面我们把不大于N的正整数分成两类：令N_b表示在1..N里面，至少能被一个大质数整除的数的个数；再令N_s表示1..N里面有多少个数的质因子全是小质数。下面我们将计算N_b和N_s的上界，并且将找出一个N满足这样一个可笑的不等式：N_b + N_s &lt; N。
    借助前面的结论，我们能很快给出N_b的一个很不错的上界。注意到N/p_i实际上表示1..N中有多少个数是p_i的倍数，于是显然有<img alt="image placeholder" >
    下面我们集中力量计算N_s。我们把所有不超过N的且质因子都是小质数的正整数写成A*B^2 = p_a1 · p_a2 ·…· p_an · (p_b1 · p_b2 ·…· p_bm)^2的形式，其中前面部分是互不相同的质数的乘积，共有2^k种可能的组合；后面部分是能配成对的质因子，它们的乘积不可能超过sqrt(N)，因此B的取值只能是从1到sqrt(N)的整数。根据乘法原理，N_s不可能超过2^k * sqrt(N)。由于我们的N是任意取的，当N足够大时必然会出现2^k * sqrt(N) &lt; N/2的情况，但N_b也小于N/2，这显然是不可能的。
</p>
			 ]]></content>
<pubDate>2008-06-18T02:07:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/539</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣闻两则：麦田圈之谜的重大突破 第五大道的神秘住宅 ]]></title>
<link>http://www.matrix67.com/blog/archives/540</link>
<content><![CDATA[ 
		<p>  <img alt="image placeholder" >
<p>    哈哈，我考完啦~~~非常happy地上来更新~~<br>
    上图是在Wiltshire的Wroughton附近出现的麦田圈，被称为是目前“最复杂的”麦田圈图形。天体物理学家Mike Reed最近发现，这个麦田圈的图案是一个十进制圆周率的图形编码。这对于麦田圈之谜的研究是一个重大的突破。</p>
<p><span id="more-540"></span><br>
  <img alt="image placeholder" >
<p> <br>
 <br>
    Klinsky-Sherry一家发现，他们那座落在第五大道的豪宅里面到处隐藏着谜题。设计师Eric Clough在设计他们的住宅时竟然悄悄地隐藏了一系列解谜寻宝的线索！</p>
<p>  <img alt="image placeholder" >
<p>  <img alt="image placeholder" >
<p>  <img alt="image placeholder" >
<p>  <img alt="image placeholder" >
<p>  <img alt="image placeholder" >
<p>消息来源：<br>
<a href="http://jandan.net/2008/06/18/pi-crop-circle.html">http://jandan.net/2008/06/18/pi-crop-circle.html</a><br>
<a href="http://www.nytimes.com/2008/06/12/garden/12puzzle.html">http://www.nytimes.com/2008/06/12/garden/12puzzle.html</a><br>
<a href="http://gizmodo.com/5015855/architect-secretly-builds-epic-scavenger-hunt-into-nyc-apartment">http://gizmodo.com/5015855/architect-secretly-builds-epic-scavenger-hunt-into-nyc-apartment</a></p>
			 ]]></content>
<pubDate>2008-06-21T00:07:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/540</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 网站推荐：20000道经典数学题！problemcorner.org ]]></title>
<link>http://www.matrix67.com/blog/archives/542</link>
<content><![CDATA[ 
		<p>    <a href="http://problemcorner.org">problemcorner.org</a>收集了来自38种数学期刊和21种数学竞赛的数学题，目前一共有20000道。网站首页有一个强大的题目检索系统，因此你可以很方便地找出在网上偶然看到的一道数学趣题最早出自哪里。你可以在每一个题目下面发表评论，也可以查看别人对这道题目的评论。我的生日是5月16日，因此我看了一下数据库里的第516题：</p>
<blockquote><p>    用字母a, b, c, …, k, l来代表模12的剩余类（但你不知道哪个字母代表哪个剩余类）。假设我们已经知道了一个模12的乘法表，其中乘法表里的每个数字也是用字母来表示（即我们知道任两个字母相乘模12后等于哪个字母）。证明你可以据此确定每个字母所代表的剩余类。当模数是16, 18和24时，上述结论是否仍然成立？</p></blockquote>
			 ]]></content>
<pubDate>2008-07-01T18:49:33+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/542</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 关于北大中文系应用语言学（下）：从科学到不科学 ]]></title>
<link>http://www.matrix67.com/blog/archives/543</link>
<content><![CDATA[ 
		<p><strong>古代汉语</strong></p>
<p>    古代汉语课没有现代汉语那么科学。古代汉语课的课程主要分为文选和古汉语常识两部分，两大部分交替进行。考试时主要考字形分析、名词解释、课内文选翻译、课外文选翻译、诗词格律分析等。对于我这样的人来说，文选课是从来没听进去过的，一些古汉语知识倒是比较有意思，在这里随便写几个。这些东西可以给大家一个对古汉课所学内容的初步印象。</p>
<p> <br>
1. 关于入声字。古有平上去入四声，今有阴平、阳平、上声、去声。古代的平声分化为今天的阴平和阳平，古代的上声和去声都保留了下来（有一部分上声字也变成了去声），古入声字消失，今天的四个声调里都分布有古入声字。在绝大多数方言中，入声字都有不同程度的保留。重庆话中，古入声字全部归入二声，因此<a href="http://blog.sina.com.cn/s/blog_4c977a0801000au0.html">入声字表</a>里的所有字用重庆方言读全都是阳平。“一”、“七”、“八”三字有变调，也是因为这三字是古入声字，部分语音残留了下来。</p>
<p>2. 古汉课上一个科学的东西是诗词的格律。现在我终于会分析一首诗的格律了。写一首近体诗比你想象中的更困难，你需要考虑到对仗、押韵、平仄等各种格式的约束。平仄的一个基本要求是，上下两句中的平声（既现在除入声字以外的阴平和阳平）和仄声（古代上、去、入三声并称仄声）应该相反，例如“平平仄仄平平仄，仄仄平平仄仄平”。在数词一二三四五六七八九中，只有“三”是平声，其余全是仄声。但诗要求对仗，数词必须和数词相对，也就是说用了一个仄声的数词必须还得用一个平声的数词。而“三”是唯一的平声数词，因此“三”字在近体诗中的使用频率特别高。“千”和“双”也是平声字，它们也经常在近体诗中出现。</p>
<p>3. 古代是没有f这个音的，声母f是后来从b、p中分化而来的。一些古代专有名词的读音原封不动地保留了下来，我们可以据此看出上古语音确实没有f。例如，“阿房宫”的“房”读pang，“番禺”的“番”读pan。有人想过吗，像“鸳鸯”、“仿佛”、“蜻蜓”、“彷徨”一类的联绵词不是双声（声母相同）就是叠韵（韵母相同），但“蝙蝠”两个字声母韵母都不相同。这是因为“蝠”字的读音发生了变化。古时“蝙”、“蝠”二字的声母是相同的。</p>
<p>4. 古时造的字在一定程度上反映了当时的社会背景。很多表示恶劣品行的字都是从“女”旁的，如“嫉妒”、“贪婪”的“婪”、“奸诈”的“奸”（古时“奸”字还没有强奸的意思），这反映了当时“男尊女卑”的落后思想。事实上，“偷”古时写作“媮”，“懒”古时写作“嬾”，“淫”古时写作“婬”。</p>
<p>5. 古代农业生活中，牛占据了相当重要的地位，因此古人造了很多“牛”旁的字来区分各种各样的牛，甚至给不同年龄、不同毛色的牛都分别造了字。“特”是公牛，“牸”是母牛，“犊”是小牛，“犍”表示被阉割的公牛，“牻”表示毛色黑白相杂的牛，“牭”表示四岁的牛……</p>
<p><span id="more-543"></span><br>
6. 解字几例。“寇”，会意字。甲骨文写作<img alt="image placeholder" >
会意字中，“又”字经常表示的是手，例如“驭”，会意字，从又从马，用手驾御马匹。又如，“取”，会意字，从又，从耳，本义是捕获到野兽或战俘时割下左耳以计数献功，引申为“拿”、“获取”。</p>
<p>7. 简体字很不科学。五十年代就有民间讥讽简体怪胎顺口溜：愛（爱）无心，親（亲）不见，厰（厂）空空，産（产）不生。</p>
<p>8. 解字一例。一些字的字形被简化了，已经看不出它的来源，分析时需要把它还原为繁体字。“后”，繁体字作“後”，本义是“迟到”、“走在后面”。《说文解字》：“後，迟也。从彳幺夊者，後也”。“彳”表示与行走有关，“幺”表示小的意思，“夊”是“足”的反写,有“行路迟缓”的意思。段玉裁《说文解字注》曰：“幺者小也，小而行迟，后可知矣。”</p>
<p>9. 古代汉语中个别字词的意思在现代汉语中有所保留。大家有发现吗？现代汉语中“被”字往往用来表示不如意的事情。我们可以说“自行车被偷了”，但通常不说“自行车被找到了”；我们可以说“大楼被拆了”，但通常不说“大楼被盖好了”。这是因为，古代汉语中“被”就是“遭受”的意思，这个意义一直保留至今。重庆话就经常使用“遭”字表示被动，而不用“被”字。但为什么我们可以说“某某某被评为三好学生”呢？因为这里“评”的动作发出者和承受者都是人，如果不加上“被”字的话就不知道到底是谁发出的动作了。“大楼拆了”、“大楼盖好了”显然都有被动的意义（虽然没有“被”字），因为大楼不可能主动发出动作；但“某某评为三好学生”就不知道是主动形式还是被动形式了，因此必须加上一个“被”字。</p>
<p>10. 古人写东西是不加标点的，这需要后人自己断句。因此，经常出现断句断错闹笑话的情况。李时珍《本草纲目》鳞部卷四十三《龙》有一段对龙的描述：</p>
<blockquote><p>王符言其形有九似头似驼角似鹿眼似兔耳似牛项似蛇腹似蜃鳞似鲤爪似鹰掌似虎是也。</p></blockquote>
<p>这句话是什么意思呢？有人认为，这句话是说：</p>
<blockquote><p>王符言其形有九：似头，似驼角，似鹿眼，似兔耳，似牛项，似蛇腹，似蜃鳞，似鲤爪，似鹰掌，似虎是也。</p></blockquote>
<p>“似驼角”，“似鹿眼”，“似兔耳”都还好说，但什么叫“似头”啊，什么又叫“似鲤爪”、“似鹰掌”啊？我们发现，“鹰爪”、“鲤鳞”似乎更恰当一些。事实上，正确的断句应该是：</p>
<blockquote><p>王符言其形有九似：头似驼，角似鹿，眼似兔，耳似牛，项似蛇，腹似蜃，鳞似鲤，爪似鹰，掌似虎，是也。</p></blockquote>
<p>这样一来就通顺多了，文字结构也合理得多。</p>
<p><strong>现代文学史</strong></p>
<p>    正如前面说的，我是一个对经典文学没有任何兴趣的人。如果你选择了这个专业，你很可能跟我一样，所有的文学史课程都采取“想去就去，不想去就不去，去了也不听”的应对策略。吴晓东老师是个好老师，讲课讲的很好，只可惜对我来说那个课是真的无聊，我一个字也听不进去。不过即使不听课这课也很容易混，两次论文就有40%的分，考前两三天再找个MM的笔记复印了抱一下佛脚几乎可以保证能过。考试内容大概是文学常识、文学鉴赏和小论文。文学常识估计能复习到个1/3吧，有些涉及到文学作品的题是真的没法复习得到，非要你看了那么多的经典著作才行；至于后面的大题，只要你把整个课程内容复习了个大概，保证有话可说就行。这学期我现文史才70分，目前还没见到分比我低的人；不过我觉得也没啥，毕竟文学史和我们这个专业的关系不大，我也不感兴趣。这学期唯一让我感觉很科学、很有趣的课就只有现代汉语和线性代数，考得都还不错，自己感觉学到了不少东西，我也就满足了。<br>
    我们还将学习一学期的当代文学史和整整两年的古代文学史，估计我也会像现文史一样混过去。从明年开始，应用语言学专业将酌情减少文学史课程，这是一个正确的决定，对今年和以后报考这个专业的同学都是有好处的。</p>
<p> <br>
 <br>
    其它的一些诸如高等数学（其实就是微积分）、计算概论（其实就是C语言）之类的理科专业课我就不再多解释了，大家都知道是啥。目前网上关于这个专业的介绍遍地都是，但很多人关心的课程内容网上却很少提及。这篇文章可以让你大致了解一下中文系的大一必修课程都学些什么。如果你高考成绩不是很理想，或者对文字有一些兴趣，或者想到一个学着轻松一点的院系（信科的人真的很忙很累），来这个专业是一个不错的选择。我就说到这里了，希望我们今年9月能相见。</p>
			 ]]></content>
<pubDate>2008-07-03T20:59:44+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/543</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：扫雷是NP完全问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/544</link>
<content><![CDATA[ 
		<p>    曾经看到过自动扫雷软件，当时我就在想，扫雷游戏是否有什么牛B的多项式算法。最近才看到，扫雷问题居然是一个NP完全问题，并且这个定理有一个简单、直观而又神奇的证明。在这里和大家分享一下整个证明过程。<br>
    首先，扫雷一定是NP问题，它显然可以在多项式的时间里验证一个解。接下来，我们需要把一个已知的NP完全问题归约到扫雷问题上去。我们将给出一种把逻辑电路问题归约到扫雷问题的方法，这样的话我们就可以利用扫雷问题解决逻辑电路问题，从而说明逻辑电路问题不比扫雷难。我们将把逻辑电路问题转换成一种对应的扫雷布局，就像画画一样把逻辑电路画在扫雷的棋盘上。如果你还不知道什么叫NP完全问题，什么叫逻辑电路问题，你可以看一看我的<a href="http://www.matrix67.com/blog/archives/105">这篇文章</a>。</p>
<p>   <img alt="image placeholder" >
    上图就是一条带有Boolean值的线路。注意到x和x’中有且仅有一个有雷。如果（沿线路方向）前一个格子有雷，我们就说这条线路状态为True；反之如果后一个格子有雷，那么这条线路所传递的Boolean值就是False。每条线路的起始端都如下图左所示，其中符号*表示该格里必然有雷，x和x’中同样是有且仅有一个有雷，但到底是哪一个里面有雷谁也说不清楚。线路是可以拐弯的，如下图右所示，这可以保证转角后Boolean值相同。<br>
   <img alt="image placeholder" >
<p><span id="more-544"></span> <br>
    我们需要构造一些特殊的扫雷布局来解释NOT门、AND门和OR门。构造NOT门最为简单，下图就是一个NOT门，注意经过了中间的NOT门后，x和x’的位置互换，True变成了False，False也将变成True。<br>
   <img alt="image placeholder" >
<p> <br>
    AND门和OR门的构造就比较复杂了。下面是AND门的构造，U和V是输入的两条线路，T是输出的线路。为了说明这确实是一个AND门，我们将说明：在下面的构造中，如果线路T是True（即最右边那个格子t有雷）的话，那么格子u和v必须都有雷才行。如果最右边的格子t有雷，我们可以很快推断出，图中所有其它的t格都是有雷的，所有t’都是无雷的。观察a3正上方的那个”3″，我们立即看出a2,a3都必须有雷，于是继续推得a1无雷，s有雷。类似地，我们可以知道r也是有雷的。在中间一行的*4t处，4的上下左右都已经有雷了，那么u’和v’必然无雷，于是继续往左推得u和v都有雷。<br>
   <img alt="image placeholder" >
<p> <br>
    OR门的构造比较类似，如下图。如果r无雷的话，可知a2,a3有雷，a1无雷，s’有雷，进而s无雷。观察”6″可知u’和v’都有雷，于是u和v均无雷。<br>
   <img alt="image placeholder" >
<p> <br>
    不断套用这几个逻辑门的构造图来连接电路，直到输出线路只剩下唯一的一条。把最后的输出线路从x或者x’处截断（相当于把最终输出的Boolean值定下来）后，整个布局就成了一个“扫雷版SAT问题”了。<br>
    最后还有一个容易忽略的问题：要是线路交叉了该咋办？下图的构造可以保证线路交叉后仍不改变原线路所带的Boolean值。至此，我们已经可以把任一逻辑电路布局到扫雷棋盘上，解决这个扫雷问题就相当于要解一个逻辑电路问题，因此扫雷问题至少和逻辑电路问题一样难。<br>
   <img alt="image placeholder" >
			 ]]></content>
<pubDate>2008-07-04T00:02:46+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/544</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：不断将各数替换为右侧比其小的数的个数，数列终将不再变化 ]]></title>
<link>http://www.matrix67.com/blog/archives/548</link>
<content><![CDATA[ 
		<p>    下面这个问题出自The American Mathematical Monthly (Vol.75, No.3.(Mar.,1968), pp.299-301)：<br>
    给定一个有限长的非负整数序列。一次操作是指把数列中的每个数替换为它右边比它小的数的个数。对该数列不断进行这个操作。证明总有一个时刻该数列将不再发生改变（即此时每个数都恰好等于它右边比它小的数的个数）。</p>
<p>    下面是一个实际的例子。这个数列在第四次操作之后进入循环，不再发生改变。<br>
     5, 44, 19,  6, 49,  1, 27, 19, 50, 20<br>
     1,  6,  2,  1,  4,  0,  2,  0,  1,  0<br>
     3,  8,  5,  3,  5,  0,  3,  0,  1,  0<br>
     4,  8,  6,  4,  5,  0,  3,  0,  1,  0<br>
     5,  8,  7,  5,  5,  0,  3,  0,  1,  0<br>
     5,  8,  7,  5,  5,  0,  3,  0,  1,  0<br>
     ………………..</p>
<p><span id="more-548"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    证明过程非常简单，你只需要注意到：前面的数永远不会影响到后面的序列的变化。因此我们想到了用数学归纳法。当序列长度n=1时，一次操作后这个数将永远变成0，因此n=1时结论显然成立。假设当n=k时结论成立，我们证明n=k+1时结论也成立。注意到序列的第一个数不影响后面的数的变化，由我们的假设，后面长度为k的子序列(A<sub>2</sub>, A<sub>3</sub>, …, A<sub>k+1</sub>)将在若干次操作后停止变化。假设此时整个序列为(A<sub>1</sub>‘, A<sub>2</sub>‘, …, A<sub>k+1</sub>‘)。对这个序列再做一次变换我们得到(A<sub>1</sub>”, A<sub>2</sub>‘, …, A<sub>k+1</sub>‘)。如果A<sub>1</sub>”=A<sub>1</sub>‘，则整个序列已经不再变化了，我们不必再多考虑。如果A<sub>1</sub>”&gt;A<sub>1</sub>‘，即最后这一次变换让第一个数变大了，这样的话后面比它小的数将增多，于是第一个数将越变越大；但第一个数再大也不可能超过k，因此它增大到一定时候必然会停下来，此时整个序列就不再变化了。类似地，如果A<sub>1</sub>”&lt;A<sub>1</sub>‘，那么第一个数将越变越小，但它的下界为0，因此总有一个时刻停下来，此时整个序列也就恒定了。</p>
<p>参考资料：<a href="http://www.cut-the-knot.org/Curriculum/Algebra/RightReplacement.shtml">http://www.cut-the-knot.org/Curriculum/Algebra/RightReplacement.shtml</a></p>
			 ]]></content>
<pubDate>2008-07-04T23:38:40+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/548</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 我是∂/∂x怪，我要吃掉你…… ]]></title>
<link>http://www.matrix67.com/blog/archives/549</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>来源：<a href="http://abstrusegoose.com/26">http://abstrusegoose.com/26</a></p>
			 ]]></content>
<pubDate>2008-07-08T00:29:21+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/549</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Valentine’s Day Maze 情人节迷宫 ]]></title>
<link>http://www.matrix67.com/blog/archives/550</link>
<content><![CDATA[ 
		<p>    <img alt="image placeholder" >
<p>    最近一期的Games杂志的封面用到了Robert Abbott的一个叫做Valentine’s Day Maze的迷宫类谜题。这个迷宫需要你用你的两只手来玩。用你的左手手指指着圆圈A，用你的右手手指指着圆圈B。你的左手就表示你真正的知己情人，右手代表的就是你。如果你可以通过一系列移动把两只手移动到同一个圆圈里，那么你将会遇到一个真正适合你的人。（像我这种没有MM的Geek只有靠这个来自我欺骗一下了）<br>
    一次“移动”是指你的其中一根手指沿着某条边移动到一个相邻的圆上。在任何时候你都可以移动任何一只手，条件只有一个：你所走的边的颜色必须和你另一只手所指向的圆圈的颜色相同。因此，你的第一步可以是“右手移到C”，也可以是“左手移到I”。这个迷宫没有你想象中的那么简单。多试几次吧，相信你能成功。</p>
<p>消息来源：<a href="http://www.mathpuzzle.com/">http://www.mathpuzzle.com/</a></p>
			 ]]></content>
<pubDate>2008-07-08T00:51:46+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/550</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 视频推荐：Dimensions – A walk through mathematics ]]></title>
<link>http://www.matrix67.com/blog/archives/551</link>
<content><![CDATA[ 
		<p>    刚在<a href="http://www.sdyynothing.cn/index.php/2008/06/27/314/">sdyy</a>那儿看到了这个好东西。影片<a href="http://www.dimensions-math.org/Dim_tour_E.htm">Dimensions</a>长约2个小时，共分为9章，谈论了维度、射影、复数等有趣的数学话题。下面是一个4分钟长的预告片。完整的视频可以在<a href="http://www.dimensions-math.org/Dim_download2_E.htm">这里</a>下载。</p>
<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/yeWx_pJpJ50&amp;hl=en&amp;fs=1">
<param name="allowFullScreen" value="true">
<embed src="http://www.youtube.com/v/yeWx_pJpJ50&amp;hl=en&amp;fs=1" type="application/x-shockwave-flash" allowfullscreen="true" width="425" height="344"></embed></object></p>
			 ]]></content>
<pubDate>2008-07-10T03:34:57+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/551</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣闻一则：Fermi实验室的神秘密码 ]]></title>
<link>http://www.matrix67.com/blog/archives/552</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
    不管他是什么玩意儿，第一个读到信件的人Judy Jackson对它产生了极大的兴趣。为了更快地破解密码，今年五月，Jackson的同事把这封信<a href="http://www.symmetrymagazine.org/breaking/2008/05/15/code-crackers-wanted/">发到了他们的Blog上</a>。他们得到了全球各地好几百人的回复，其中一些人甚至已经解开了密码的一部分。</p>
<p>    信件内容公布不久，很快就有人注意到，最上面的那部分密码实质上是一个三进制编码，最底下那部分实质上是一个二进制编码。有人甚至把两部分的编码都录入了下来：</p>
<p><code style="width:300px;">323233331112132<br>
33323132212331<br>
2111331132312233<br>
333212123213113<br>
311333313331111<br>
211333323232211<br>
232313331121231<br>
33231312</code></p>
<p><code style="width:300px;">111212112121212121121212121112121121<br>
1121121121211121211211121211211121111<br>
1111212121121121211121212121112111211<br>
2111212112112111211121112111211121112<br>
111211211121112121121112122211121211<br>
1212112111211121112112111212121112111<br>
211211211121121112112111212112111212<br>
112121211</code></p>
<p>    破译这样的密码并不容易，前段时间某MM写给我的一段密码我至今仍未破译。你需要从有限的密文中寻找各种形式的特征，从密码本身的规律中寻找提示。人们注意到，在后面的二进制编码中，连续的2仅仅出现了一次。这是为什么？人们更倾向于认为，连续的三个2是不应该出现的，这打破了这段编码的模式；很可能中间那个2仅仅是两个画得比较近的1罢了。后来，这一点得到了证实：人们渐渐意识到，数字2起到一个分隔符的作用。连续的1的个数最多不超过3个，这绝对不是一种巧合；如果把二进制编码中的2看成分隔符的话，下面一部分也是一个三进制编码。这样的话，后一部分的密码可以重新编码为：</p>
<p><code>312111121113123221312312333112213111332312233333332331231231312333231133223232312312112</code></p>
<p><span id="more-552"></span><br>
    接下来该怎么办？当然，不少人都走了很多弯路。来自加拿大的密码爱好者Milburn发现，两部分的密码长度分别为111和87，他们都可以被3整除。三位的三进制数共有27个，而英文字母一共有26个，如果加上一个空格字符则正好是27个。这两段密码渐渐地有了眉目。破解谜题时，“最好首先去想最简单的解法，如果不行，再继续尝试更复杂的解法”，Milburn说。Milburn把每种三进制组合用一个字母来代替，用000表示A，001表示B，222表示空格。但这样代出来的只是一段无意义的“乱码”。Milburn再尝试着用000来表示空格，用001来表示A，以此类推。但这样替换之后的文字仍然毫无意义。人们习惯性地认为，密码中的123应该顺序地看作三进制的三个数码。在意识到数字3实际上表示的是“0”（就像脉冲拨号用10表示0一样）之后，两段编码立即有了意义：</p>
<blockquote><p>Frank Shoemaker would call this noise<br>
employee number basse sixteen</p></blockquote>
<p>    这两句话和谜题本身一样费解。它到底是什么意思呢？仍然没人知道。另外，中间那一段“火星文密码”仍然没有被破解，也许这才是整封信最重要的部分。人们猜测，后一句话中的“basse sixteen”很可能是“base sixteen”，多出来的那个s是“衍文”；而中间那部分密码则很可能是一个16进制数，表示了一个员工的编号。</p>
<p>消息来源：<a href="http://digg.com/odd_stuff/Crack_this_secret_code">http://digg.com/odd_stuff/Crack_this_secret_code</a></p>
			 ]]></content>
<pubDate>2008-07-12T15:53:52+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/552</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：pi^2是无理数 ]]></title>
<link>http://www.matrix67.com/blog/archives/553</link>
<content><![CDATA[ 
		<p>    Proofs from THE BOOK的第六章相当精彩，这一章循序渐进地介绍了多个无理性证明。先证明e是无理数，证明方法和高数课本上的基本相同；试图用类似的办法证明e^2也是无理数时，这一章的内容开始牛B了起来，一些巧妙的变换就让原来的办法继续适用于e^2的证明；加上一些更有趣的技巧，我们还能继续证明e^4也是无理数；当证明对除0外的所有有理数r，e^r都是无理数时，全章达到了高潮。<br>
    这一章还提到了pi^2是无理数的证明方法。这个证明建立在Ivan Niven于1947年提出的“pi是无理数”的经典证明的基础上：仅仅是在原证明过程中加了一些微妙的变化就得到了pi^2也是无理数的结论。注意到，“pi^2是无理数”是一个比“pi是无理数”更强的结论。由于有理数的平方还是有理数，因此证到了pi^2是无理数也就说明了pi必然是无理数；但反过来却不行，因为无理数的平方不一定也是无理数，比如根号2的平方就不是无理数。</p>
<p>    证明过程用到了一个函数<img alt="image placeholder" >
<p><span id="more-553"></span><br>
    下面我们用反证法来证明，pi^2不是有理数。先假设pi^2=a/b，然后我们将推出一个荒谬的结论。定义函数<br>
      <img alt="image placeholder" >
<p>    这个函数有一个有趣的性质：<br>
      <img alt="image placeholder" >
<p>    由于<br>
      <img alt="image placeholder" >
<p>    定义一个数N，于是有<br>
      <img alt="image placeholder" >
<p>    而由前面的引理，F(0)和F(1)里的每一项都是整数（由于假设pi^2=a/b，所有的pi都和外面的b^n相乘化整了），因此N=F(0)+F(1)也是整数。<br>
    但是当x∈(0,1)时，被积函数是恒正的，并且根据前面的引理f(x)始终是小于1/n!的。于是有<br>
      <img alt="image placeholder" >
<p>    我们的n是可以任取的，显然n可以足够大以使得(pi*a^n)/n!&lt;1，此时0&lt;N&lt;1，这与N是整数矛盾。</p>
			 ]]></content>
<pubDate>2008-07-13T19:35:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/553</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：不用除法，如何求n个数的最小公倍数 ]]></title>
<link>http://www.matrix67.com/blog/archives/554</link>
<content><![CDATA[ 
		<p>    下面给出一种算法，该算法只需要使用加法运算和比较运算就可以求出n个数的最小公倍数：每一次操作都把当前最小的那个数加上它的初始值，直到所有数都相等为止。下面这个列表显示了用这个算法寻找30, 12, 18三个数的最小公倍数的全过程。初始时12是三个数中的最小数，于是该数加上12；接下来18成了最小的数，于是该数加上18变成了36；此时第二个数24又变成了最小数，于是再加上其对应的初始值12；以此类推直到三个数都变成相同的数180为止，这个180就是30, 12, 18的最小公倍数。</p>
<p>30 <span style="color:red;">12</span> 18<br>
30 24 <span style="color:red;">18</span><br>
30 <span style="color:red;">24</span> 36<br>
<span style="color:red;">30</span> 36 36<br>
60 <span style="color:red;">36</span> 36<br>
60 48 <span style="color:red;">36</span><br>
60 <span style="color:red;">48</span> 54<br>
60 60 <span style="color:red;">54</span><br>
<span style="color:red;">60</span> 60 72<br>
90 <span style="color:red;">60</span> 72<br>
90 <span style="color:red;">72</span> 72<br>
90 84 <span style="color:red;">72</span><br>
90 <span style="color:red;">84</span> 90<br>
<span style="color:red;">90</span> 96 90<br>
120 96 <span style="color:red;">90</span><br>
120 <span style="color:red;">96</span> 108<br>
120 <span style="color:red;">108</span> 108<br>
120 120 <span style="color:red;">108</span><br>
<span style="color:red;">120</span> 120 126<br>
150 <span style="color:red;">120</span> 126<br>
150 132 <span style="color:red;">126</span><br>
150 <span style="color:red;">132</span> 144<br>
150 <span style="color:red;">144</span> 144<br>
150 156 <span style="color:red;">144</span><br>
<span style="color:red;">150</span> 156 162<br>
180 <span style="color:red;">156</span> 162<br>
180 168 <span style="color:red;">162</span><br>
180 <span style="color:red;">168</span> 180<br>
180 180 180</p>
<p>    这个算法为什么是正确的呢？它有什么实际用途呢？</p>
<p><span id="more-554"></span><br>
 <br>
    当所有数相等，操作停止时，得到的数肯定是所有数公共的倍数；但如何保证它是最小的公倍数呢？下面我们证明，在整个算法过程中，每个数加到了它们的最小公倍数L后必然停止继续增加。试想，假如某一次操作后n个数的最大值超过了L（不妨设此时这个最大的数是第一个数），这就说明r·x1 &lt;= L &lt; (r+1)·x1，其中x1表示第一个数的初始值，r·x1和(r+1)·x1分别表示第一个数在本次操作前后的值；由于L是x1的倍数，不可能既大于r·x1又小于(r+1)·x1，我们立即知道r·x1就等于L；但r·x1是这一轮中的最小值（因为接下来它被操作了），而在这一轮中还没有超过L的数，于是我们立刻得知此时所有数都等于L，算法已经提前结束了。
    这个算法有一个很有趣的实际用途。假如我有3个MM，与她们各自约会一次的“来电指数”分别为30, 12和18。我希望同这3个MM保持相同的亲近度，最合理的策略就是在相同的时间内与第一个MM约会L/30次，与第二个MM约会L/12次，与第三个MM约会L/18次（L仍然表示最小公倍数）。但我不能表现出对MM忽冷忽热的态度，我想让我与每个（特定的）MM的约会频率尽量固定。我应该如何安排具体的约会时间以使得与各MM的约会尽可能平均地分布呢？一个好的做法就是对这三个“来电指数”做一次上述的最小公倍数算法，第i次被操作的是哪个数，第i天就和那个MM出去。
    同样的道理，这个算法经常用来实现一些多线程的任务。假如每个线程需要的刷新速度各不相同，各个线程又需要同步刷新，那么一个不错的办法就是用上述方法来确定每一次来处理哪个线程。

参考资料：<a href="http://www.cut-the-knot.org/Curriculum/Arithmetic/LCM.shtml">http://www.cut-the-knot.org/Curriculum/Arithmetic/LCM.shtml</a></p>
<p>Update: leimiaos想到了这个算法的另一个用途：按照入学成绩公平地把学生分到人数不等的班里。<br>
另外，我还想到了一个可能的用途：画一条指定斜率的单色直线。<br>
欢迎大家继续讨论。</p>
			 ]]></content>
<pubDate>2008-07-16T00:39:25+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/554</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 新一轮的小游戏推荐 ]]></title>
<link>http://www.matrix67.com/blog/archives/555</link>
<content><![CDATA[ 
		<p><a href="http://armorgames.com/play/1846/shift-3">http://armorgames.com/play/1846/shift-3</a><br>
Shift出3了！！这一次的Shift更加精彩了，出现了许多的新元素，以及metapuzzle和多结局的设置。</p>
<p><a href="http://www.arcadecabin.com/play/orbox_b.html">http://www.arcadecabin.com/play/orbox_b.html</a><br>
<a href="http://aifreedom.com/entertainment/75">Ai.Freedom</a>推荐的一个有趣的动作解谜游戏，一共有30关。挺好玩的。</p>
<p><a href="http://fantasticcontraption.com/">http://fantasticcontraption.com/</a><br>
最近的物理解谜游戏越来越多了，<a href="http://www.matrix67.com/blog/archives/534">上次</a>就推荐过一个叫做<a href="http://magic.pen.fizzlebot.com/">Magic Pen</a>的物理解谜游戏，这次再推荐一个有些不一样的物理解谜游戏Fantastic Contraption。</p>
<p><a href="http://lightforce.freestuff.gr">http://lightforce.freestuff.gr</a><br>
这里有十几二十个小巧而有趣的解谜游戏，强烈推荐。</p>
<p><a href="http://www.recenttoys.com/index.php?id=31">http://www.recenttoys.com/index.php?id=31</a> (shockwave)<br>
双人棋类对战游戏。你需要尽可能多的把自家颜色的方块分离出去。</p>
<p><a href="http://www.goproblems.com/">http://www.goproblems.com/</a><br>
估计大家和我一样吧，闲着没事干时很想做一些伤脑筋的事情。好玩的解谜游戏不好找，找数学题做也没意思。最近终于找到了一个杀脑细胞的绝好办法：做死活题！于是到上面这个网站，在“诘棋类型”那里选“死活”，选个中等难度，然后点“我要做题”。我们的口号是：死活题，天天练，保持头脑不断电。当然，你喜欢其它类型的题目也可以，或者干脆在右边选一个难度开始“限时闯关”。<br>
<a href="http://www.goproblems.com/startsearch.php">棋形搜索</a>功能相当强大。</p>
			 ]]></content>
<pubDate>2008-07-18T14:56:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/555</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 动作解谜游戏预告：CAPCOM神秘新作Flock! ]]></title>
<link>http://www.matrix67.com/blog/archives/556</link>
<content><![CDATA[ 
		<p>    每次E3上总会发布一些新颖别致的解谜游戏（还记得去年E3上的<a href="http://www.matrix67.com/blog/archives/254">Echochrome</a>吗）。今年E3上，CAPCOM新发布的一款动作解谜游戏引起了人们的关注。在游戏中，你需要操纵UFO把农场里的动物抓到飞船里。不同性质的地表和不同种类的动物对UFO的反应都不一样，玩家需要充分利用它们的特点，采取合适的策略才能完成任务。这个游戏将会登陆PS3、Xbox和PC三种平台。</p>
<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/1m0qEyc6ByA&amp;hl=en&amp;fs=1">
<param name="allowFullScreen" value="true">
<embed src="http://www.youtube.com/v/1m0qEyc6ByA&amp;hl=en&amp;fs=1" type="application/x-shockwave-flash" allowfullscreen="true" width="425" height="344"></embed></object></p>
			 ]]></content>
<pubDate>2008-07-18T15:15:02+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/556</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一些有创意的独立游戏 & 一个火星的3D动画短片 ]]></title>
<link>http://www.matrix67.com/blog/archives/557</link>
<content><![CDATA[ 
		<p>    每次推荐了创意小游戏后总会收到很多回复。网友<a href="http://tsounaiq.spaces.live.com/">浅海里的鱼</a>给我推荐了一个Blog：<a href="http://mabule.blogbus.com">mabule.blogbus.com</a>。博主看来是非常喜欢创意小游戏的了，特别是一些有趣的独立游戏。我在他那儿挖到了不少好玩的小游戏，并且在他那儿惊奇地发现，<a href="http://www.kloonigames.com/crayon/">Crayon Physics</a>的作者每个月都会在<a href="http://www.kloonigames.com/blog/">他的Blog</a>上发布新的原创小游戏（被他称作Monthly Experimental Games）。他的每个游戏都是那么小巧精致而有趣，最新的小游戏<a href="http://www.kloonigames.com/blog/games/tp">Jimmy’s Lost His Toilet Paper</a>的游戏创意真是令人拍案叫绝。<br>
    我要说的另一个（火星）东西来自<a href="http://mabule.blogbus.com/logs/22892115.html">这里</a>：一段原创3D动画短片<a href="http://www.isfat.com/happyjunk/kiwi.php">Kiwi!</a>，讲述一只Kiwi鸟（一种不会飞行的鸟）的故事。整个动画相当感人，有兴趣的朋友可以看看：</p>
<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/sdUUx5FdySs&amp;hl=en&amp;fs=1">
<param name="allowFullScreen" value="true">
<embed src="http://www.youtube.com/v/sdUUx5FdySs&amp;hl=en&amp;fs=1" type="application/x-shockwave-flash" allowfullscreen="true" width="425" height="344"></embed></object></p>
			 ]]></content>
<pubDate>2008-07-20T14:24:51+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/557</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一个与矩形剖分有关的命题（一）：巧妙的初等证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/559</link>
<content><![CDATA[ 
		<p>    今天才听说了这样一个有趣的命题：如果一个矩形可以分割为若干个小矩形，每个小矩形都有至少一边为整数长，则原矩形同样有至少一个长度为整数的边。换句话说，用至少有一边的长度是整数的小矩形拼成一个大矩形，大矩形也有至少一条整数长的边。这个命题看似简单但却很难证明，更准确地说应该是很难想到证明方法。而有趣就有趣在，这个命题的证明方法出奇的多，从图论方法到数论方法，每个证明都相当巧妙。</p>
<p>    <img alt="image placeholder" >
<p>    我们所要介绍的第一个证明是我觉得最巧妙的证明方法。证明的关键在于下面这个引理：像国际象棋棋盘一样对整个平面黑白染色，那么与两坐标轴平行放置且至少一边长为偶数的矩形一定覆盖了相同面积的黑色区域和白色区域。原因很简单，看上图，该矩形中的每一个（长度为偶数个单位的）横条显然都覆盖了相同面积的黑白两色区域。</p>
<p><span id="more-559"></span> <br>
    <img alt="image placeholder" >
    下面，我们把整个平面分成(1/2)*(1/2)大小的正方形，并且像上面那样黑白二染色，然后把那个大矩形对齐坐标轴放在平面上，左下角和原点对齐。这个矩形内的每个小矩形都有至少一个整数边，也即至少有一边的长度是1/2的偶数倍，因此每个小矩形都覆盖了相同面积的黑色区域和白色区域。这样，整个大矩形也就覆盖了同等面积的黑白区域。</p>
<p> <br>
 <img alt="image placeholder" >
    然而，对于一个左下角与原点对齐的矩形，如果右上角(x,y)两个坐标值都不是整数的话，那么这个矩形所覆盖的黑色区域一定大于白色区域：除去黑白相等的“整”的部分，最后剩下的就是最右上角的那个未填满的1×1正方形有待讨论。坐标(x,y)的位置只有三种可能，而第一种情况可以等价地转化为第二种情况，第二种情况也可以等价地变成第三种情况，在第三种情况中我们立即看到，矩形所覆盖的黑色面积一定大于白色面积。<br>
    如果要让整个矩形覆盖相同面积的黑色和白色，x和y至少有一个是整数才行，而这就是我们所要证明的结论了。</p>
			 ]]></content>
<pubDate>2008-07-23T18:50:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/559</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ FOX新剧Fringe & 官方网站上的一个小谜题 ]]></title>
<link>http://www.matrix67.com/blog/archives/560</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
    另一个让人期待的元素是，这部新剧又是来自J.J.Abrams的。一想到J.J.Abrams就想到解谜游戏，估计只有他才会在影视剧及其官网、预告甚至周边产品里到处放些怪异的图形和密码。这次J.J.Abrams似乎又开始玩起了在Lost里早已玩过的神秘数字游戏。下面是一段Fringe的预告片，你可以多次看到在黑屏的时候会闪出一些和Fibonacci数列有关的图形。</p>
<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/ZAu4L5_Fl84&amp;hl=en&amp;fs=1">
<param name="allowFullScreen" value="true">
<embed src="http://www.youtube.com/v/ZAu4L5_Fl84&amp;hl=en&amp;fs=1" type="application/x-shockwave-flash" allowfullscreen="true" width="425" height="344"></embed></object></p>
<p> <br>
    现在，有趣的事情来了。刚才去<a href="http://www.fox.com/fringe">Fringe主页</a>上看看，发现了一个奇怪的东西：这几个按钮是什么意思？（下面有答案）</p>
<p>   <img alt="image placeholder" >
<p><span id="more-560"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
答案：<a href="http://www.braillecards.co.uk/whats_braille/">Braille点字法</a>是一种常用的盲文点字方案。菜单上的几个图案分别读作：</p>
<blockquote><p>E, H, AC, BA, CD, EE, HI</p></blockquote>
<p>而这几个字母其实就是Fibonacci数列：</p>
<blockquote><p>E=5, H=8, AC=13, BA=21, CD=34, EE=55, HI=89</p></blockquote>
			 ]]></content>
<pubDate>2008-07-24T13:12:42+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/560</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ csdn上的一个数学猜想 ]]></title>
<link>http://www.matrix67.com/blog/archives/561</link>
<content><![CDATA[ 
		<p>jintianhu2000在<a href="http://topic.csdn.net/u/20080705/16/a9070b29-c658-47bc-8807-95b1d700a69f.html">这个帖子</a>里说：</p>
<blockquote><p>这是本人读高中时发现的一个数学猜想，一直不能证明或推翻<br>
 <br>
任何一个不能被3整除的偶数，如488，按下列步骤：<br>
若该数为偶数，则把它各位数之和的平方作为新数；若该数为奇数，则把它各位数之和的立方作为新数。再把那个新数重复以上步骤（偶数就各位数之和平方，奇数就各位数之和立方），一步步计算下去，肯定能在9步内变为1。<br>
如：<br>
  488(偶)    4+8+8=20      20*20=400<br>
  400(偶)    4+0+0=4       4*4=16<br>
  16(偶)     1+6=7         7*7=49<br>
  49(奇)     4+9=13        13*13*13=2197<br>
  2197(奇)   2+1+9+7=19    19*19*19=6859<br>
  6859(奇)   6+8+5+9=28    28*28*28=21952<br>
  21952(偶)  2+1+9+5+2=19  19*19=361<br>
  361(奇)    3+6+1=10      10*10*10=1000<br>
  1000(偶)   1+0+0+0=1     1*1=1   （共9步）<br>
 <br>
哪位高手能证明或推翻它？？ </p></blockquote>
<p><span id="more-561"></span><br>
    这个“9”步可是大有玄机。写一个小程序统计n&lt;=1 000 000的范围内需要k次变换才能变成1的有多少个数，程序运行结果如下：</p>
<blockquote><p>6, 1786, 31779, 58756, 57730, 55571, 83186, 25783, 18737, 0, 0, 0, …</p></blockquote>
<p>    可以看到，需要8步的有25783个数，需要9步的有18737个，但需要9步以上的硬是一个数都没有，这个“断裂”感觉有点不自然。为什么有5.6%的数都需要9步，却没有一个数需要9步以上？即使我们找到了一个（可能很大的）反例，这个现象仍然值得深究。<br>
    另外，很多人认为这个命题显然是错误的，这种说法是不正确的。虽然对于充分大的数其数字和也能达到足够大，但这个数字和是要平方（或者立方）的。你不能指望每次操作后新的数恰好又是99999…99这样令人满意的极端形式，很有可能按照这个算法来个两三次就变成10000…000了。寻找一个反例并不那么简单。</p>
<p>    40楼mathe指出了第一个反例，这个反例是一个各位数字和S＝70616022582298623212586706134294505827921361106736747909217704596951778822208的偶数。由于这个数字和S不能被3整除，因此原数也不能被3整除。数字和为S的偶数是一定存在的，例如S个“1”后面再加一个“0”。第一次变换后该数将变为</p>
<p>  70616022582298623212586706134294505827921361106736747909217704596951778822208^2<br>
= 49866226453437091137711536298477731014510413655235894003548957882878563978585<br>
   95386978574399462830249936249115434841097417814389990990179862339647673995264</p>
<p>    在Mathematica上用Total[IntegerDigits[%]]^(2 + Mod[%, 2])可以轻易验证，后面几步分别变为595984, 1600, 49, 2197, 6859, 21952, 361, 1000, 1，整个过程一共10步。原猜想被推翻。此后，命题的一些扩展形式成了人们关注的焦点。<br>
    一个有趣的问题是，该问题最小的反例是多少？这个“最小的反例”很有可能比著名的<a href="http://en.wikipedia.org/wiki/P%C3%B3lya_conjecture">Pólya猜想</a>要强得多。1919年，Pólya曾经猜想：小于等于n的正整数中，质因子个数为奇数的数不少于质因子个数为偶的数。1958年C.B.Haselgrove给出了第一个反例，这个反例有361位。1980年，Minoru Tanaka找出了Pólya猜想最小的反例n=906150257。</p>
			 ]]></content>
<pubDate>2008-07-24T18:26:11+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/561</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ （召集）你喜欢什么类型的数字？ ]]></title>
<link>http://www.matrix67.com/blog/archives/562</link>
<content><![CDATA[ 
		<p>    似乎大多数人都喜欢整十整百的数，或者偶数，或者一些因子很多的合数。但我却不一样。我反而讨厌那种整十整百的数。总的说来，我喜欢以下三类数字。<br>
    最喜欢的是质数，特别是以3和7结尾的。我的网名是matrix67。我的幸运数字是23。在家时我喜欢吃13个饺子。看电视时，喜欢把电视机音量调节到11、17、23（原来的老电视）或者47、53（新的那台电视）。选手机号时喜欢选奇数结尾的，最好末两位是质数。<br>
    第二喜欢的是36, 48, 96, 192一类的数，就是可以表示成两个2的幂之和的数，特别是2^(n-1) + 2^n一类的数（即质因子为n-1个2和一个3）。有时候，对这种数的喜爱甚至要多于2的幂，我也想不通是为什么。出OI题时我很喜欢拿这些数当数据。<br>
    第三喜欢的是奇数的幂，比如25、27、81、169、361、729等等。偶尔也把电视机的音量调到25或49。觉得361°的那个数字让人感觉很是亲切。<br>
    一直以为这是我独有的癖好，直到刚才看到了<a href="http://tsounaiq.spaces.live.com/blog/cns!1786E40E1B9FC536!1601.entry">这位同志的日志</a>后才猛然想到：难道所有Geek都有类似的癖好？故召集大家说一说自己对数字的一些偏好。</p>
<p>    P.S. 另一个很有意思的癖好：别人问我时间时，我把手机翻出来看看，但很多时候并不会照着上面显示的时间念，而是有意在它周围取一个很“特别”的近似告诉对方。比如，8:47我会告诉他8点三刻，14:20我会告诉他2:22，16:18我会告诉他16:16，12:35我会告诉他12:34。<br>
    不行了，我要睡了。大家下午见。</p>
			 ]]></content>
<pubDate>2008-07-25T06:49:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/562</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一个与矩形剖分有关的命题（二）：直观的图论证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/564</link>
<content><![CDATA[ 
		<p>  <img alt="image placeholder" >
    接下来，我们用图论方法来证明：一个由小矩形拼接而成的大矩形，若每个小矩形都有至少一条整数长的边，则大矩形也有至少一条整数长的边。考虑图中每个矩形的每个顶点，把它们作为图G的顶点集（相邻矩形重合的顶点并作一个点）；对于每一个小矩形，把它整数边方向的两对顶点分别用一条边连接起来（相邻矩形公共边上的重边<strong>不合并</strong>）。如果哪个小矩形四条边都是整数，无妨随意把它当作横向整数边的或者纵向整数边的，连接任一种方向上的边。这样的话，每个矩形恰好产生两条边。注意这个图的一些很显然的性质：度为1的点只有4个（大矩形的四个角），其余的顶点的度都是偶数（只能是2或者4）。下面，我们把这个矩形放在平面坐标系上，大矩形的左下角对齐原点(0,0)。从原点开始沿着图G的边走（每条边最多走一次，不走走过的边），显然走到的每个点都满足这个性质：它的两个坐标均为整数。但我们的出发点是一个度为1的点，在走到另一个度为1的点之前，我们遇到的所有顶点的度都是偶数。因此只要没走到另一个度为1的点，我们就不可能走死。但是，图G总的边数有限，总有一个时候我们将不能再走。因此，这次旅程的终点必然落在另一个度为1的点上。这个终点是大矩形的另一个角，它的两个坐标值均为整数。命题得证。</p>
<p>    以上两个证明均来自<a href="http://www.cs.toronto.edu/~mackay/rectangles/">http://www.cs.toronto.edu/~mackay/rectangles/</a></p>
<p><span id="more-564"></span><br>
    Andrei Gnepp曾给出一个更简单的证明：显然，一个小矩形的四个顶点中，两个坐标值均为整数的顶点只可能有0个、2个或者4个。把它们全部加起来，符合条件的总顶点数S仍然是偶数。但是，这S个顶点中有些点是重复算过的。假如我们有S1个（两坐标值均为整的）顶点只算过一次，有S2个这样的点被算过两次，有S4个这样的点被加了4次。则有S = S1 + 2*S2 + 4*S4。我们立即得出，S1也是偶数。但我们已经有一个满足条件的点只算过一次（最左下角的点(0,0) ），那么S1至少为2，也即至少还有一个点，它的两个坐标均为整数。它即是大矩形的另一个角。</p>
			 ]]></content>
<pubDate>2008-07-25T20:51:12+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/564</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 视频：用多米诺骨牌来解释逻辑门 ]]></title>
<link>http://www.matrix67.com/blog/archives/569</link>
<content><![CDATA[ 
		<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/SudixyugiX4&amp;hl=en&amp;fs=1">
<param name="allowFullScreen" value="true">
<embed src="http://www.youtube.com/v/SudixyugiX4&amp;hl=en&amp;fs=1" type="application/x-shockwave-flash" allowfullscreen="true" width="425" height="344"></embed></object></p>
<p>来源：<a href="http://jandan.net/2008/07/26/logic-gates-out-of-dominoes.html">http://jandan.net/2008/07/26/logic-gates-out-of-dominoes.html</a><br>
期待牛人用多米诺骨牌“写”一个程序。</p>
			 ]]></content>
<pubDate>2008-07-26T18:47:29+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/569</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 设计调查问卷的艺术：怎样才能绝对地保证个人隐私不被泄露 ]]></title>
<link>http://www.matrix67.com/blog/archives/572</link>
<content><![CDATA[ 
		<p>    我在学校时，时不时会有人闯进宿舍，给宿舍里的每个人发一张调查表邀请大家填写。如果我不是很忙的话，通常还是很乐意填写的。不过，有时我很悲哀的发现，很多调查表的设计都很缺乏科学性。设计一张合理的调查表并不是一件容易的事情，你需要综合考虑各方面的因素。例如，假如你需要在调查表中问一个极度隐私的问题，尽管你在调查表上再三强调你们的保密措施，但你真的指望所有人都能够如实地回答吗？你真的指望会有人在“我不是处男/处女”或“我有同性恋倾向”前面打一个勾然后把表递到问卷回收人的手中吗？<br>
    让我们考虑这样一个问题：你希望在调查表上问一个隐私问题。为了方便起见，假设这个问题只有“是”和“否”两个选项。有什么方案能够绝对地保证个人隐私完全不可能被泄露，让每个人都能够放心地填写，并且问卷回收之后能够得到一个准确的统计结果？<br>
<span id="more-572"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    在问卷上要求每个人准备一枚硬币（或者叫问卷发放人给每个人发一枚一块钱的硬币，顺便也当作酬谢）。对于指定的隐私题目，请填写人投掷一次硬币：如果正面朝上，则如实填写个人的真实情况；如果反面朝上，那么就再投掷一次硬币，正面就填“是”，反面就填“否”。当然，若第一次投掷硬币为正的话，填写人完全可以假装再投一次硬币来掩人耳目。这样，别人永远不知道你在“我不是处男/处女”前面打了勾是因为你真的不是还是因为那个答案是投掷出来的。<br>
    假设回收后有效问卷有M份，其中该问题答“是”的有N个人。如实填写了该问题的人平均有M/2个；在另外M/2人中，平均有M/4人答的“是”。因此，我们所需要的最终结果应该为(N-M/4)/(M/2)。<br>
    把这个算法写在问卷上，让大家知道问卷调查结果将如何统计，以便让大家严格遵守该问题的填写方法。</p>
<p>来源：<a href="http://www.cut-the-knot.org/Probability/EmbarrassingQuestion.shtml">http://www.cut-the-knot.org/Probability/EmbarrassingQuestion.shtml</a><br>
另：刚收到邮件，我最喜欢的数学谜题比赛站点<a href="http://www.puzzleup.com/">puzzleup</a>将在7月30日开始新一轮的比赛。<a href="http://www.matrix67.com/blog/archives/272">了解更多</a></p>
			 ]]></content>
<pubDate>2008-07-28T17:21:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/572</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一个与矩形剖分有关的命题（三）：诡异的微积分证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/576</link>
<content><![CDATA[ 
		<blockquote><p>如果一个矩形可以分割为若干个小矩形，每个小矩形都有至少一边为整数长，则原矩形同样有至少一个长度为整数的边。换句话说，用至少有一边的长度是整数的小矩形拼成一个大矩形，大矩形也有至少一条整数长的边。</p></blockquote>
<p>    在这个命题的所有常见的证明方法中，我总觉得这个证明是最诡异的。真不知道第一个想出这个证明方法的人是怎么思考出来的。把矩形放在平面直角坐标系上，左下角对齐原点(0,0)。考虑函数e^(2 · pi · i · (x+y))在每个小矩形上的积分（展开并分离变量分别积分）：<br>
    <img alt="image placeholder" >
<p>    显然，这个式子等于0当且仅当(x1-x0)和(y1-y0)中至少一个是整数（也即至少有一边的长度是整数）。考虑函数在整个大矩形上的积分，它可以拆成各个小矩形上的积分的和，因此结果仍然是0。这说明，大矩形至少有一条整数长的边。</p>
			 ]]></content>
<pubDate>2008-07-28T21:11:18+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/576</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 新发现的一些有趣的anagram ]]></title>
<link>http://www.matrix67.com/blog/archives/583</link>
<content><![CDATA[ 
		<p><a href="http://blog.wolfram.com/2008/07/25/word-combinatorics/">Wolfram Blog</a>最近提到了一些新发现的anagram (<a href="http://www.matrix67.com/blog/archives/289">?</a>)，比起那些经典的anagram毫不逊色。它们是：</p>
<p>Centenarian == Near ancient.   (Dan Fortier)<br>
Heel claims == me, Achilles.   (Paul Pan)<br>
Remains hot == in a Thermos.   (Adrian Hickford)<br>
True friends == endure rifts.   (Joe Fathallah)<br>
Homo sapiens == Ape’s son, IMHO.   (Noam D. Elkies)<br>
Internet spam == It’s permanent.   (Tom Myers)<br>
Rats and mice == in cat’s dream.   (Joe Fathallah)<br>
Metamorphosis == Promises a moth.   (Andrew Brehaut)<br>
A marble statue == Mute alabaster.   (Rosie Perera)<br>
Borderline case == Reconsiderable.   (David Bourke)<br>
Slices of bread == describes loaf.   (Dean Mayer)<br>
I’d do anything! == Had no dignity.   (Tony Crafter)<br>
Valentine amulets == Sentimental value.   (Allan Morley)<br>
Designated driver == Danger is diverted.   (Mick Tully)<br>
American education == An academic routine.   (Jesse Frankovich)<br>
Gone with the Wind? == Then weigh it down!   (Toby Gottfried)<br>
One thousand kilos == Oh, sounds like a ton!   (Hans-Peter Reich)<br>
Classified document == Found access limited.   (Adrian Hickford)<br>
A domestic housecat == Does it catch a mouse?   (David Bourke)<br>
An appointment diary == Pop in at any darn time.   (Larry Brash)<br>
Spaghetti &amp; meatballs == Best light pasta meal.   (Toby Gottfried)</p>
<p><span id="more-583"></span><br>
顺便把原来收藏的经典anagram也一起分享出来<br>
A Decimal Point == I’m a Dot in Place<br>
Clint Eastwood == Old West Action<br>
Desperation == A Rope Ends It<br>
Dormitory == Dirty Room<br>
Eleven plus two == Twelve plus one<br>
Friday Thirteen == Terrify Than Die<br>
Listen == Silent<br>
Mother-in-law == Woman Hitler<br>
Schoolmaster == The classroom<br>
Statue of Liberty == Built to Stay Free<br>
The Country Side == No City Dust Here<br>
The Morse Code == Here Come Dots<br>
Year two thousand == A year to shut down</p>
			 ]]></content>
<pubDate>2008-07-29T23:33:11+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/583</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 牛B的Mathematica：寻找开头和结尾都是字母y的形容词 ]]></title>
<link>http://www.matrix67.com/blog/archives/586</link>
<content><![CDATA[ 
		<p>    只有想不到，没有做不到。还是在<a href="http://blog.wolfram.com/2008/07/25/word-combinatorics/">这里</a>，我惊奇地发现Mathematica居然有DictionaryLookup和WordData这样的函数（我的6.0里就有，不知道5.x有没有）。于是，一连串牛B的Mathematica用法出现了：</p>
<p> <br>
包含ijk三个连续字母的单词：<br>
<code>In[1]:= DictionaryLookup["*" ~~ "ijk" ~~ "*"]<br>
Out[1]= {"Dijkstra"}</code></p>
<p> <br>
连续三次出现重复字母的单词：<br>
<code>In[2]:= DictionaryLookup[RegularExpression[".*(.)1(.)2(.)3.*"]]<br>
Out[2]= {"bookkeeper", "bookkeepers", "bookkeeping"}</code></p>
<p> <br>
首尾三个（及以上）的字母完全相同的单词：<br>
<code>In[3]:= DictionaryLookup[RegularExpression["([a-z]{3,})[a-z]*1"]]<br>
Out[3]= {"abracadabra", "anticoagulant", "antidepressant",<br>
"antioxidant", "antiperspirant", "bedaubed", "beriberi", "bonbon",<br>
"cancan", "chichi", "couscous", "dumdum", "entailment",<br>
"entanglement", "entertainment", "enthrallment", "enthronement",<br>
"enticement", "entitlement", "entombment", "entrainment",<br>
"entrancement", "entrapment", "entrenchment", "froufrou", "hotshot",<br>
"hotshots", "ingesting", "ingoing", "ingraining", "ingratiating",<br>
"ingrowing", "ionization", "mesdames", "microcosmic", "murmur",<br>
"muumuu", "outshout", "outshouts", "physiography", "pompom",<br>
"redelivered", "rediscovered", "respires", "restores",<br>
"restructures", "tartar", "tessellates", "testates", "testes",<br>
"tormentor", "tsetse", "underfund", "underground"}</code></p>
<p><span id="more-586"></span><br>
 <br>
最长的5个只用键盘最上面一排的字母就可以打出的单词：<br>
<code>In[4]:= Take[<br>
 Sort[DictionaryLookup[RegularExpression["[qwertyuiop]+"]],<br>
  StringLength[#1] &gt; StringLength[#2] &amp;], 5]<br>
Out[4]= {"typewriter", "repertoire", "proprietor", "perpetuity",<br>
"typewrote"}</code></p>
<p> <br>
最大的10个“16进制单词”：<br>
<code>In[5]:= Take[<br>
 Sort[DictionaryLookup[RegularExpression["[a-f]+"]],<br>
  FromDigits[#1, 16] &gt; FromDigits[#2, 16] &amp;], 10]<br>
Out[5]= {"effaced", "defaced", "acceded", "faffed", "facade",<br>
"efface", "deface", "deeded", "decaff", "decade"}</code></p>
<p> <br>
回文单词：<br>
<code>In[6]:= Select[DictionaryLookup["*"], # == StringReverse[#] &amp;]<br>
Out[6]= {"a", "aha", "aka", "bib", "bob", "boob", "bub", "CFC",<br>
"civic", "dad", "deed", "deified", "did", "dud", "DVD", "eke", "ere",<br>
"eve", "ewe", "eye", "gag", "gig", "huh", "I", "kayak", "kook",<br>
"level", "ma'am", "madam", "mam", "MGM", "minim", "mom", "mum",<br>
"nan", "non", "noon", "nun", "oho", "pap", "peep", "pep", "pip",<br>
"poop", "pop", "pup", "radar", "redder", "refer", "repaper",<br>
"reviver", "rotor", "sagas", "sees", "seres", "sexes", "shahs",<br>
"sis", "solos", "SOS", "stats", "stets", "tat", "tenet", "TNT",<br>
"toot", "tot", "tut", "wow", "WWW"}</code></p>
<p> <br>
最长的10个没有重复字母的单词：<br>
<code>In[7]:= Take[<br>
 Sort[Select[DictionaryLookup["*"],<br>
   Count[Characters[#], First[Commonest[Characters[#]]]] == 1 &amp;],<br>
  StringLength[#1] &gt; StringLength[#2] &amp;], 10]<br>
Out[7]= {"ambidextrously", "unproblematic", "unpredictably",<br>
"sharp-tongued", "hydromagnetic", "draughtswomen", "copyrightable",<br>
"upholstering", "unprofitably", "unprofitable"}</code></p>
<p> <br>
单词axiom是什么意思？<br>
<code>In[8]:= WordData["axiom", "Definitions"]<br>
Out[8]= {{"axiom", "Noun", "Proposition"} -&gt;<br>
 "(logic) a proposition that is not susceptible of proof or<br>
   disproof; its truth is assumed to be self-evident",<br>
{"axiom", "Noun", "Saying"} -&gt; "a saying that is widely accepted on its own merits"}</code></p>
<p> <br>
开头和结尾都是字母y的形容词：<br>
<code>In[9]:= Select[DictionaryLookup["y" ~~ "*" ~~ "y"],<br>
 MemberQ[WordData[#, "PartsOfSpeech"], "Adjective"] &amp;]<br>
Out[9]= {"yearly", "yeasty", "yucky", "yummy"}</code></p>
<p> <br>
某个人体部位，以字母x结尾：<br>
<code>In[10]:= Select[WordData["body", "PartTerms", "List"],<br>
 StringMatchQ[#, "*" ~~ "x"] &amp;]<br>
Out[10]= {"cervix", "thorax"}</code></p>
<p> <br>
另类字符串输出：<br>
<code>In[11]:=<br>
DictionaryLookup["m" ~~ "*" ~~ "x"][[3]] ~~<br>
 ToString[23*3 - 2] ~~ "原创"<br>
Out[11]= "matrix67原创"</code></p>
			 ]]></content>
<pubDate>2008-07-30T00:08:51+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/586</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Geek的悲哀 ]]></title>
<link>http://www.matrix67.com/blog/archives/596</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>感慨，解开一个女人的胸罩就有那么难么？<br>
来源：<a href="http://xkcd.com/457/">http://xkcd.com/457/</a></p>
			 ]]></content>
<pubDate>2008-08-02T17:49:55+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/596</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一个与矩形剖分有关的命题（四）：简便的数论证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/598</link>
<content><![CDATA[ 
		<blockquote><p>如果一个矩形可以分割为若干个小矩形，每个小矩形都有至少一边为整数长，则原矩形同样有至少一个长度为整数的边。换句话说，用至少有一边的长度是整数的小矩形拼成一个大矩形，大矩形也有至少一条整数长的边。</p></blockquote>
<p>    不假，利用数论知识我们真的可以证明这个和数论八杆子打不着的题目。证明的关键就在于，质数有无穷多个。给定一个满足要求的大矩形，如果你宣称它的每条边都不是整数，它们都至少多出了大小为ε的“零头”。那么，我就找出一个足够大的质数p，使得1/p &lt; ε，然后说明有一条边的长度除去整数部分后的“零头”不会超过1/p。这样的话，至少有一边恰好是整数长才行。
    仍然是把大矩形放在平面直角坐标系上，左下角对齐原点(0,0)。考虑所有形如(i/p, j/p)的点所形成的点阵（其中i, j均为整数）。我们需要把整个点阵平移到一个合适位置，使得点阵中没有点恰好落在小矩形的边界上。这总是可以办到的，例如我们算出每个小矩形的横边到点阵中离它最近的点的距离，取所有这些最近距离中最小的非0的值，然后竖直方向上移动一个比这还小的距离；另一个方向亦是如此。注意到每个小矩形内部所含的点数都是两个数的乘积，由于其中至少有一个数是p的倍数，因此每个小矩形内都有p的倍数个点。那么，整个大矩形所含的点的个数（即每个小矩形所含点数之和）也是p的倍数。大矩形内的所有点的个数也是两个数的乘积，然而p是质数，因此两个数中至少一个是p的倍数（数论的一个基本结论）。那么，对应的那条边就应该是整数长，并且最多有1/p的误差。

（三）（四）两种证明均来自<a href="http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/solutions/May1999.html">http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/solutions/May1999.html</a></p>
			 ]]></content>
<pubDate>2008-08-02T19:40:07+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/598</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 超强的储存方法：即使连续128个扇区全部损坏也能恢复原数据 ]]></title>
<link>http://www.matrix67.com/blog/archives/600</link>
<content><![CDATA[ 
		<p>    不知大家有过硬盘坏道没，反正有一次我是遇上了，珍贵的collection顷刻间化为乌有。信息时代，每个人都面临着一个新的问题：如何储存你的重要文件最为安全？大多数人会选择多弄它几个备份，虽然这种办法的效率和“性价比”都不高。有没有什么高效而又节省空间的办法来保证数据安全呢？最近，<a href="http://ttsiodras.googlepages.com/rsbep.html">ttsiod</a>写了一篇关于Linux小软件<a href="http://www.s.netic.de/gfiala/dvbackup.html">Rsbep</a>的文章，里面提到的算法可以保证大段数据丢失以后仍然能复原原来的数据。算法基于一种叫做<a href="http://en.wikipedia.org/wiki/Reed_Solomon">Reed-Solomon</a>的编码方式。</p>
<p>    Reed-Solomon编码的核心思想非常有趣：任意k个点都惟一地确定了一个最高次数为k-1次的多项式，如果我们把要传送的信息用一个多项式函数上的点来表示，那么我们可以用更多的点来描述这一信息，这样即使某些点的位置在传输过程中发生了错误，接收者也能根据其它的点来复原全部信息。考虑一个大小为n的有限域（由于一个字节有2^8=256种可能的值，n通常取256），其元素分别为x_0, x_1, x_2, …, x_n；而我们要传输的数据长度为k。首先我们把这k个字节的数据当作有限域的前k个非0元素所对应的函数值，确定出它们所对应的k-1次多项式函数f；然后计算出n-1个非0元素的函数值f(x_1), f(x_2), …, f(x_n)，作为最终的编码发送出去。注意我们的元素是一个有限域，因此多项式的值仍然在这个域里面（范围仍然是0到255）。在实际应用中，我们通常取k=223，这样的话223个字节的数据将加强为一段255字节长的数据，其中有32个字节是附加的信息。这种编码的纠错能力很强，即使有16个字节在传输中发生错误，我们也能通过剩余的信息复原出原始数据。</p>
<p><span id="more-600"></span><br>
    对于现今常用的数据储存方式，这样的算法仍然有它的局限性：数据丢失往往是一个扇区一个扇区地丢，而一个扇区就有512个字节，普通的存储方式将导致整段编码全部丢失。我们必需要避免把同一段自校对编码放在一个扇区里。rsbep强就强在：它把本该储存在同一个扇区的自校对编码分散存储到各个扇区去。得到整个数据编码后所需要的扇区数之后，我们重新排列整个编码中的所有字节，先顺序填满每个扇区的第一个字节，再依次填充每个扇区的第二个字节（就像栅栏密码一样）。如此一来，每一段（255字节长的）自校对编码都横贯255个扇区，倘若有一个扇区不能读了，那么我们丢失的就是512段编码各自在该扇区中的那一个字节。事实上，一个更强的储存方法是，在遍历扇区时也跳着进行存取，先填满第1, N+1, 2N+1, …个扇区，再填充第2, N+2, 2N+2, …个扇区。在ttsiod修改后的rsbep中，常数N=8，因此每第8个扇区中同一位置上的字节合在一起才组成一段编码。由于Reed-Solomon编码可以自我校对多达16个字节的错误，因此只有第i个、第i+8个、第i+8*2个、……、第i+8*16个扇区同时损坏才能造成真正的损失。这样的话，即使连续的128个扇区全部损坏，我们也能完整地恢复出原数据。</p>
			 ]]></content>
<pubDate>2008-08-06T02:37:56+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/600</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 不可能几何体与分形图形 ]]></title>
<link>http://www.matrix67.com/blog/archives/605</link>
<content><![CDATA[ 
		<p><a href="http://www.matrix67.com/blog/archives/243">Koch雪花</a>不可能图形版<br>
<img alt="image placeholder" >
<p> <br>
 <br>
<a href="http://www.matrix67.com/blog/archives/280">Sierpinski三角形</a>不可能图形版<br>
<img alt="image placeholder" >
<p><span id="more-605"></span><br>
 <br>
 <br>
<a href="http://www.matrix67.com/blog/archives/137">Cantor集？</a><br>
<img alt="image placeholder" >
<p> <br>
 <br>
<a href="http://en.wikipedia.org/wiki/Sierpi%C5%84ski_curve">Sierpinski曲线</a>不可能图形版<br>
<img alt="image placeholder" >
<p> <br>
 <br>
不可能几何体的嵌套<br>
<img alt="image placeholder" >
<p> <br>
 <br>
<a href="http://www.matrix67.com/blog/archives/249">Hilbert曲线</a>不可能图形版<br>
<img alt="image placeholder" >
<p> <br>
 <br>
接下来的两个比较强<br>
<img alt="image placeholder" >
<p><img alt="image placeholder" >
<p> <br>
 <br>
查看更多：<a href="http://www.cameronius.com/graphics/impossible-fractals-figures/">http://www.cameronius.com/graphics/impossible-fractals-figures/</a></p>
			 ]]></content>
<pubDate>2008-08-06T14:22:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/605</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一个不属于我的节日 ]]></title>
<link>http://www.matrix67.com/blog/archives/608</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2008-08-07T05:22:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/608</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ O3 ·7 ·5 ·5 ·4 ·7 ·6 ·6 ·7 ·? ]]></title>
<link>http://www.matrix67.com/blog/archives/610</link>
<content><![CDATA[ 
		<p>在<a href="http://www.ahapuzzles.com">ahapuzzles.com</a>逛了一天，看到了不少好玩的东西。<br>
Update: 刚收到<a href="mailto:Lloyd@ahapuzzles.com">Lloyd King</a>发来的邮件，我很高兴。所有这些谜题都是他创作的。他有一本书就叫做<a href="http://www.amazon.com/exec/obidos/tg/detail/-/1411613309/103-0334672-1461461">Amazing “Aha!” Puzzles</a>，里面全是让人拍案叫绝的谜题。</p>
<p><img alt="image placeholder" >
 <br>
<img alt="image placeholder" >
<p>问号处应该填哪一个图形？<br>
答案：<span style="color:#E5E5E5;">E。各方块的对角线组成了数字3、4、5、6、7的字样。</span></p>
<p> <br>
 <br>
 <br>
<img alt="image placeholder" >
<p>问号处应该填什么数字？<br>
答案：<span style="color:#E5E5E5;">5。圆圈和点表示太阳和9大行星，旁边的数字表示每颗星球的名字的字母个数。</span></p>
<p><span id="more-610"></span> <br>
 <br>
 <br>
<img alt="image placeholder" >
 <br>
<img alt="image placeholder" >
<p>问号处应该填哪一个图形？<br>
答案：<span style="color:#E5E5E5;">A。它们是字母A、B、C、D、E、F、G、H、I的侧视图。</span></p>
<p> <br>
 <br>
 <br>
<img alt="image placeholder" >
<p>问号处应该画一个什么图形？<br>
答案：<span style="color:#E5E5E5;">“&gt;”形。它们是扑克牌四种花色的图案的右半部分。</span></p>
<p> <br>
 <br>
 <br>
<img alt="image placeholder" >
<p>这是什么东西？<br>
答案：<span style="color:#E5E5E5;">麦田圈。把每个圆圈顺时针旋转90度，即可看到CROP CIRCLES的字样。</span></p>
<p> <br>
 <br>
 <br>
<img alt="image placeholder" >
<p>上面这幅图有一个明显的错误，你能找出来吗？<br>
答案：<span style="color:#E5E5E5;">“1”应该是“A”。这是方块A到方块5重叠起来的样子。</span></p>
<p> <br>
 <br>
 <br>
<img alt="image placeholder" >
<p>问号处应该画一个什么图形？<br>
答案：<span style="color:#E5E5E5;">问号处应填的图形是第四个图形竖直方向上的镜像。它们是罗马数字I、II、III、IV、V、VI加上下划线组成的。</span></p>
<p> <br>
 <br>
 <br>
<img alt="image placeholder" >
<p>问号处应该填写一个什么字母？<br>
答案：<span style="color:#E5E5E5;">L。把“K”看作“I”和“C”，即有单词ICONIC, PICNIC, VOICE和ICICLE。</span></p>
<p> <br>
 <br>
 <br>
<img alt="image placeholder" >
<p>哪一个图形是不完整的？添加一笔补完这幅图。<br>
答案：<span style="color:#E5E5E5;">第三个字母是不完整的。把“C”补成“O”，将图中的文字补为ABODE。</span></p>
<p> <br>
 <br>
 <br>
<img alt="image placeholder" >
<p>添加12根同样长的小木棒，把图中的数字补充完整。你所添加的小木棒不能挨在一起摆放（端点处相接也不行）。<br>
答案：<span style="color:#E5E5E5;">在四个空列中水平放置12根木棒，补成2、3、5、8四个数字。</span></p>
<p> <br>
 <br>
<strong>大家觉得哪个最好玩？</strong></p>
			 ]]></content>
<pubDate>2008-08-08T02:08:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/610</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 立体图与三维数据展示 ]]></title>
<link>http://www.matrix67.com/blog/archives/631</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p><code>img = ListPointPlot3D[<br>
  Table[Total[IntegerDigits[Binomial[i, j]]], {i, 0, 50}, {j, 0, 50}],<br>
   ViewVertical -&gt; {0, 0, 1}, ImageSize -&gt; 600];<br>
Export["F:\file.gif", {Show[img, ViewVector -&gt; {-32, -20, 60}],<br>
  Show[img, ViewVector -&gt; {-31, -21, 60}]}];</code></p>
<p><img alt="image placeholder" >
<p><img alt="image placeholder" >
<p>    类似地，我们还可以做出环视一周的gif动画来，虽然这样将很难观察出细节，但对总体的把握效果将更好。</p>
			 ]]></content>
<pubDate>2008-08-11T17:51:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/631</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：最小的可覆盖所有12种五联骨牌的图形 ]]></title>
<link>http://www.matrix67.com/blog/archives/638</link>
<content><![CDATA[ 
		<p>   <img alt="image placeholder" >
<p>    <a href="http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/challenges/July2008.html">IBM Ponder This</a>上个月的题目：一个多联骨牌(polyomino)是指平面上若干个正方形相接拼成的图形。经过旋转、镜像得到的图形仍然视为相同的多联骨牌。如上图所示，五联骨牌一共有12种。我们说一个多联骨牌A覆盖B，如果我们能在B上添加若干个新的方块得到A。回答下面两个问题：<br>
    1. 一个六联骨牌最多可以覆盖多少种不同的五联骨牌？<br>
    2. 给出一个最小的能够覆盖所有12种五联骨牌的图形。</p>
<p><span id="more-638"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
   <img alt="image placeholder" >
<p>    1. 覆盖5种是不可能的。证明很容易：六联骨牌只有有限个，挨个枚举就是了。为了减小枚举量，我们对这个问题稍作分析。换个角度考虑：把六联骨牌的其中一个方块去掉，是否能保证得到5种不同的连通图？如果这个六联骨牌没有“环”的话（即对应的图是一棵树），那么除了叶子节点以外其余点都是割点，去掉后无法形成连通图；但6个节点的最大度为4的无根树最多只能有4个叶子，不可能弄出5种连通图来。这意味着这个六联骨牌必须要有环。而使用不超过6个方块就能得到的环只能是2×2的方形了，因此这个六联骨牌必然有一个2×2的方形。下面我们从2×2的方形出发，添加两个新的方块上去。由对称性，第一个方块拼接在什么位置无所谓，反正都是“刀板五”的形状。现在我们只需要考虑第二个方块的9种可能的位置（事实上不同的只有8种）。割点最多一个的图形只有两种，但它们都是对称图形，将会出现很多重复的情况。于是，我们看到，覆盖5种不同的五联骨牌是不可能的。妈的累死了，谁有更简单的分析方法没？<br>
    下面给出两个可以覆盖4种五联骨牌的六联骨牌：</p>
<p><code>             #<br>
####       ###<br>
##         ##</code></p>
<p>    2. 8个方块显然是不够的。把长条形(1)和阶梯型(12)合在一起就已经需要至少8个方块了，而它们组成的形状显然无法覆盖十字架形(6)。下面给出两个九联骨牌的解：</p>
<p><code> ###       ###<br>
#####      #####<br>
 #           #</code></p>
			 ]]></content>
<pubDate>2008-08-12T10:28:42+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/638</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 艰苦奋斗，自力更生，和过去的自己团结起来！ ]]></title>
<link>http://www.matrix67.com/blog/archives/644</link>
<content><![CDATA[ 
		<p>    今年年初，一款叫做<a href="http://www.matrix67.com/blog/archives/408">Cursor*10</a>的Flash小游戏创造了游戏领域的一个新元素：时空变换。一时间，“时间类”游戏风靡一时，着实火了一把，这个Blog也曾经推荐了不少需要操纵时间的解谜游戏；但目前绝大多数同类游戏都只是Flash小游戏，我们期待着一个完整的、华丽的时间类游戏的出现。</p>
<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/iFrTjlkpdbM&amp;hl=en&amp;fs=1">
<param name="allowFullScreen" value="true">
<embed src="http://www.youtube.com/v/iFrTjlkpdbM&amp;hl=en&amp;fs=1" type="application/x-shockwave-flash" allowfullscreen="true" width="425" height="344"></embed></object></p>
<p>    <a href="http://braid-game.com/">Braid</a>是一个2D动作冒险游戏。所不同的是，你不但能操纵游戏人物的移动，还能操纵时间的流动。前几天这个游戏已经在Xbox Live Arcade发布，据说今年还将发行一个PC版。让我们拭目以待。</p>
<p>    Kloonigames的Blog又有<a href="http://www.kloonigames.com/blog/games/choke-on-my-groundhog-you-bastard-robots">新游戏</a>啦！Choke on my Groundhog, YOU BASTARD ROBOTS是一个很有创意的游戏。随着游戏难度的增加，到后面一个人通全关几乎是不可能的；每次死了后游戏时间将回到这一关刚开始，你可以和过去的自己并肩作战。试试看，通过一关需要多少个你。</p>
			 ]]></content>
<pubDate>2008-08-12T17:51:51+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/644</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ L: Change the WorLd中的数学题 ]]></title>
<link>http://www.matrix67.com/blog/archives/646</link>
<content><![CDATA[ 
		<p> <img alt="image placeholder" >
<p>    电影中涉及数学的地方很少有经得起仔细琢磨的。记得《考试一家亲》中那个小屁孩儿上去背圆周率没背几位就开始乱整了；要想骗骗观众，至少你得查一查前20位的精确值吧。这些细节很多电影都忽视掉了，就连电影<a href="http://www.imdb.com/title/tt0138704/">pi</a>开头的圆周率都是错的。<br>
    但在L: Change the WorLd里，几处涉及数学的地方都经得起推敲。估计大家应该还记得那个数字方阵式的密码吧？我们亲眼目睹到了这一密码的破译过程：写成一串，两位两位隔开，按字母表顺序转换为对应的字母，按题目（的另一种理解方式）去掉HOPE四个字母，最后得到WATARI（就是渡的名字）。</p>
<p>    另一处扯到数学的地方是那个答案为MK的几何题。这个题不是瞎编的，做出来的答案真的就和片中的一样，连最后那个小屁孩儿在黑板上画的辅助线都是正确的。</p>
<p><img alt="image placeholder" >
如果AB=26，BC=3，CA=25，请问AO:OC是多少？</p>
<p><span id="more-646"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p> <img alt="image placeholder" >
<p>    这题还蛮复杂的。把△BOC沿O点旋转到△AOE，显然有△BOC≌△AOE，即AO/AE=BO/BC；又△ABO和△ECO都是等腰三角形，且∠COE=∠BOA，因此有△ABO∽△ECO，即AB/BO=EC/CO。<br>
    整理一下我们得到的结果：<br>
  AO · BC = AE · BO ………… ①<br>
  AB · CO = BO · EC ………… ②</p>
<p>    ①②两式相加，有：<br>
  AO · BC + AB · CO = (AE+EC) · BO</p>
<p>    下面我们说明，A、E、C三点共线，即∠AEO+∠CEO=180°。由于∠AEO=∠BCO，∠CEO=∠ECO，因此我们只需说明∠ECO=∠BCX。再考虑到图中标明的垂直这一条件，我们只需要证明切线l平分∠BCA。可以证明，三圆两两相切，则切点处的三条切线交于一点（这里就不再证明了）。设这一点为D。注意到∠DAO=∠DBO=∠DCO=90°，于是A、B、C、D、O五点共圆，它们都在以DO为直径的圆上。另外，注意到大圆的两条切线DA=DB，长度相等的弦所对的圆周角相等，因此∠DCB=∠DCA，DC平分∠BCA，于是可知A、E、C三点共线。于是：</p>
<p>   AO · BC + AB · CO = 3 · AO + 26 · CO<br>
= (AE+EC) · BO = AC · BO = 25 · AO</p>
<p>    则22 · AO = 26 · CO，于是我们得到了答案AO:OC=13:11。<br>
    在字母表中，第13个字母是M，第11个字母是K，因此最后的“暗号”是“MK”。</p>
			 ]]></content>
<pubDate>2008-08-13T03:37:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/646</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 七点共圆：一个美妙的结论 ]]></title>
<link>http://www.matrix67.com/blog/archives/650</link>
<content><![CDATA[ 
		<p>  <img alt="image placeholder" >
<p>    线段AC上有一点B。以AB和BC为边，分别构造等边三角形XAB和YBC。证明，以下七个点共圆：点B，XC和YA的交点，以及线段AC、XC、YA、XB、YB的中点。</p>
<p><span id="more-650"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
  <img alt="image placeholder" >
<p>    如图，S为AB的中点，T为BC的中点。首先注意到，△ABY和△XBC全等(SAS)，也就是说△XBC是△ABY绕B点旋转60°得到的，因此AY和XC的夹角∠AMX=60°。注意到中位线LQ∥AX，中位线KQ∥CY，我们立即得到∠KQL也等于60°，于是K、L、M、Q四点共圆。<br>
    另外，中位线NL∥BC，中位线KP∥AB，因此线段NL、KP和AC全都平行。又中位线PT∥YC，YC∥XB，而XB与中位线LT平行，因此PT∥LT，即P、L、T三点共线。于是我们得知∠LPK=∠LTB=60°。类似地，∠NKP也等于60°，因此四边形KNLP是一个等腰梯形，这四个点共圆。而∠LPK也是弦KL所对的圆周角，因此这个圆和前面的那个圆是同一个圆，L、N、K、Q、P、M都在这个圆上。又∠NBP=60°=∠NKP，它们都是NP所对的圆周角，因此B也在这个圆上。</p>
<p>来源：<a href="http://www.cut-the-knot.org/Curriculum/Geometry/TwoEquilateralBumps.shtml">http://www.cut-the-knot.org/Curriculum/Geometry/TwoEquilateralBumps.shtml</a></p>
			 ]]></content>
<pubDate>2008-08-16T00:40:51+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/650</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Mathway：对付数学作业的新武器 ]]></title>
<link>http://www.matrix67.com/blog/archives/653</link>
<content><![CDATA[ 
		<p>    N多人抱怨说Mathematica没有解题步骤，做某些计算步骤繁琐的题目还得自己摆弄半天。嘿嘿，这下好了，现在我们又有了新的秘密武器。<a href="http://www.mathway.com/">Mathway</a>是一个在线的“Step-by-Step Math Problem Solver”。你可以输入各种类型的数学题目，它不但会给你解出来，还会替你打出详细的解题步骤，方便你腾到作业本上。这个系统仍然在不断完善中，前几天我测试时发现它连一个简单的不等式都解错了，今天发现这个bug已经补上了。<br>
    要是半年前有这个网站的话，我每个星期可以多抽出至少两个小时的时间来更新Blog。试着在Algebra里输入matrix[1,3,-2,5_3,5,6,7_2,4,3,8]，然后选Find Reduced Row Echelon Form，然后点Answer……爽死了！</p>
			 ]]></content>
<pubDate>2008-08-18T05:15:06+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/653</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 海盗分金问题的扩展：当N>200时 ]]></title>
<link>http://www.matrix67.com/blog/archives/655</link>
<content><![CDATA[ 
		<p>    才知道，海盗分金问题有一个非常有趣的扩展。5个海盗分100个金块不难，100个海盗分100个金块也不难，事实上200个海盗分100个金块也不成问题。有趣的事情发生在第201个海盗身上——为了保命，他连一块金子都不能拿。他不得不把所有100块金子都分给前面199个人中奇数编号的人，从而贿赂他们投他的票（因为在第200个海盗的最优方案中这些人什么都得不到）。加上自己的一票共101票，过半了。同样地，第202个海盗也必须把100块金子分给在第201个海盗的方案中什么也得不到的人，贿赂他们投自己一票。由于第201个海盗的方案中有101个海盗得不到任何东西，因此他的方案不再唯一。加上自己的票共101票，正好是202的一半，这样一来他也活下来了。当问题扩展到N=203时，情况有了戏剧性的变化——第203个海盗无论如何都会死！因为只有100块金子，根本不够他用来贿赂，他无论如何也只能得到101票（别忘了题目条件假设海盗在自身利益相同的情况下会选择杀更多的人）。牛B就牛B在第204个海盗，虽然他也只能贿赂到100票，但是他居然活下来了！你猜他怎么活的？哈哈哈~~~~因为第203个海盗无论如何都会投他一票，不投他的话等轮到自己时就完了。因此第204个海盗把100个金子分给在第202个海盗的方案中啥也得不到的人，加上203和自己的票共102票，这才活了下来。类似地，你会发现第205个海盗必死；第206个海盗虽然会得到205的支持，但是票数仍然不够；207想活的话需要104票，但他也只能搞到103票；208将得到205、206、207的支持，加上自己的一票和贿赂来的100票，正好活了。以后，第216, 232, 264, …, 200+2^n个海盗都将活下来，游戏将在他们这里结束。</p>
			 ]]></content>
<pubDate>2008-08-18T05:25:19+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/655</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一些新的视频处理技术 ]]></title>
<link>http://www.matrix67.com/blog/archives/661</link>
<content><![CDATA[ 
		<p>University of Washington的<a href="http://www.cs.washington.edu/homes/pro/">Pravin Bhat</a>上传了一些视频，介绍了一下他正在着手的一些project。下面是其中一个有趣的project：用照片来修正静物摄影的视频。</p>
<p><object width="506" height="337"><param name="allowfullscreen" value="true">
<param name="allowscriptaccess" value="always">
<param name="movie" value="http://www.vimeo.com/moogaloop.swf?clip_id=1513129&amp;server=www.vimeo.com&amp;show_title=1&amp;show_byline=1&amp;show_portrait=0&amp;color=&amp;fullscreen=1">
<embed src="http://www.vimeo.com/moogaloop.swf?clip_id=1513129&amp;server=www.vimeo.com&amp;show_title=1&amp;show_byline=1&amp;show_portrait=0&amp;color=&amp;fullscreen=1" type="application/x-shockwave-flash" allowfullscreen="true" allowscriptaccess="always" width="506" height="337"></embed></object></p>
<p>另外几个project的视频地址：<br>
<a href="http://www.vimeo.com/1513186">http://www.vimeo.com/1513186</a><br>
<a href="http://www.vimeo.com/1448831">http://www.vimeo.com/1448831</a><br>
<a href="http://www.vimeo.com/1447119">http://www.vimeo.com/1447119</a></p>
			 ]]></content>
<pubDate>2008-08-20T06:46:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/661</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 双向Josephus问题中的分形图形 ]]></title>
<link>http://www.matrix67.com/blog/archives/666</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p><span id="more-666"></span><br>
<code>joseprocess[m_, mm_] := Block[{t, p, q, u, v, w},<br>
   proc = {}; w = mm; t = Range[m]; p = t; q = t;<br>
   Do[p = RotateLeft[p, w];<br>
      u = First[p]; proc = Append[proc, u];<br>
      p = Rest[p]; q = Drop[q, Position[q, u][[1]]];<br>
      If[Length[p] == 1, Break[]];<br>
      q = RotateRight[q, w];<br>
      v = Last[q]; proc = Append[proc, v];<br>
      q = Drop[q, -1]; p = Drop[p, Position[p, v][[1]]];<br>
      If[Length[q] == 1, Break[]],<br>
    {n, 1, Ceiling[m/2]}];<br>
   proc];<br>
 <br>
ListPlot[Table[Complement[Range[n], joseprocess[n, 3]][[1]], {n, 2, 1000}]]</code></p>
<p>参考资料：<a href="http://demonstrations.wolfram.com/TheJosephusProblemInBothDirections/">http://demonstrations.wolfram.com/TheJosephusProblemInBothDirections/</a></p>
			 ]]></content>
<pubDate>2008-08-20T07:17:03+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/666</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：三角形中的六点共圆 ]]></title>
<link>http://www.matrix67.com/blog/archives/677</link>
<content><![CDATA[ 
		<p>    下面这个有趣的问题来自<a href="http://www.imo-2008.es/examenes/chs.pdf">IMO 2008</a>第一题，题目给出的结论非常美妙。<br>
 <img alt="image placeholder" >
    给定一个锐角三角形△ABC，垂心为H。Ma、Mb、Mc分别为三条边的中点。以Ma为圆心，过点H的圆与线段BC相交于点A1、A2；类似地，以Mb、Mc为圆心，过点H的圆与三角形交于B1、B2、C1、C2。求证，A1、A2、B1、B2、C1、C2六点共圆。</p>
<p><span id="more-677"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
   <img alt="image placeholder" >
    首先注意到，图中三角形的三条垂线正好穿过了圆和圆之间的公共弦。我们可以很轻易地证明这一点。只需注意到线段MaMb是三角形的中位线，它平行于AB，我们立即得到MaMb⊥HC；而过两圆交点并垂直于连心线的正好就是两圆的公共弦，因此圆Ma和圆Mb的公共弦在HC上。对于其余两对圆有同样的结论。由于C在圆Ma和圆Mb的公共弦的延长线上，因此C到两圆的切线一样长。假设这个长度为t。另外，把圆Ma和圆Mb的半径长分别记作Ra、Rb。观察两个蓝色的直角三角形，显然有(AC/2)^2 – (Rb)^2 = t^2 = (BC/2)^2 – (Ra)^2。<br>
    另一方面，如果题目中的六个点共圆，圆心一定在A1A2、B1B2、C1C2的中垂线的交点上（实际上也就是△ABC的外心）。假设这个点为O，它到Ma、Mb的距离分别为Sa、Sb。观察两个绿色的直角三角形，显然有(AC/2)^2 + (Sb)^2 = (OC)^2 = (BC/2)^2 + (Sa)^2。两式相减，有(Rb)^2 + (Sb)^2 = (Ra)^2 + (Sa)^2，应用到△OMaA1、△OMaA2、△OMbB1、△OMbB2四个直角三角形上，立即可以看到点O到A1、A2、B1、B2的距离相等，这四个点共圆。<br>
    同理，B1、B2、C1、C2也共圆，因此这六个点都在同一个圆上。</p>
<p>参考资料：<a href="http://www.cut-the-knot.org/Curriculum/Geometry/CirclesThroughOrthocenter.shtml">http://www.cut-the-knot.org/Curriculum/Geometry/CirclesThroughOrthocenter.shtml</a></p>
			 ]]></content>
<pubDate>2008-08-23T00:10:38+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/677</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：Prüfer编码与Cayley公式 ]]></title>
<link>http://www.matrix67.com/blog/archives/682</link>
<content><![CDATA[ 
		<p>  <img alt="image placeholder" >
    Cayley公式是说，一个完全图K_n有n^(n-2)棵生成树，换句话说n个节点的带标号的无根树有n^(n-2)个。今天我学到了Cayley公式的一个非常简单的证明，证明依赖于Prüfer编码，它是对带标号无根树的一种编码方式。<br>
    给定一棵带标号的无根树，找出编号最小的叶子节点，写下与它相邻的节点的编号，然后删掉这个叶子节点。反复执行这个操作直到只剩两个节点为止。由于节点数n&gt;2的树总存在叶子节点，因此一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。下面我们只需要说明，任何一个长为n-2、取值范围在1到n之间的数列都唯一地对应了一棵n个节点的无根树，这样我们的带标号无根树就和Prüfer编码之间形成一一对应的关系，Cayley公式便不证自明了。<br>
<span id="more-682"></span><br>
    注意到，如果一个节点A不是叶子节点，那么它至少有两条边；但在上述过程结束后，整个图只剩下一条边，因此节点A的至少一个相邻节点被去掉过，节点A的编号将会在这棵树对应的Prüfer编码中出现。反过来，在Prüfer编码中出现过的数字显然不可能是这棵树（初始时）的叶子。于是我们看到，没有在Prüfer编码中出现过的数字恰好就是这棵树（初始时）的叶子节点。找出没有出现过的数字中最小的那一个（比如④），它就是与Prüfer编码中第一个数所标识的节点（比如③）相邻的叶子。接下来，我们递归地考虑后面n-3位编码（别忘了编码总长是n-2）：找出除④以外不在后n-3位编码中的最小的数（左图的例子中是⑦），将它连接到整个编码的第2个数所对应的节点上（例子中还是③）。再接下来，找出除④和⑦以外后n-4位编码中最小的不被包含的数，做同样的处理……依次把③⑧②⑤⑥与编码中第3、4、5、6、7位所表示的节点相连。最后，我们还有①和⑨没处理过，直接把它们俩连接起来就行了。由于没处理过的节点数总比剩下的编码长度大2，因此我们总能找到一个最小的没在剩余编码中出现的数，算法总能进行下去。这样，任何一个Prüfer编码都唯一地对应了一棵无根树，有多少个n-2位的Prüfer编码就有多少个带标号的无根树。</p>
<p>    一个有趣的推广是，n个节点的度依次为D1, D2, …, Dn的无根树共有(n-2)! / [ (D1-1)!(D2-1)!..(Dn-1)! ]个，因为此时Prüfer编码中的数字i恰好出现Di-1次。</p>
			 ]]></content>
<pubDate>2008-08-23T03:21:51+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/682</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Al Zimmermann编程大赛已经开始 ]]></title>
<link>http://www.matrix67.com/blog/archives/687</link>
<content><![CDATA[ 
		<p>    来自<a href="http://www.mathpuzzle.com/">MathPuzzle</a>的消息：新一轮的<a href="http://www.recmath.org/contest/">Al Zimmermann编程大赛</a>开始了。这次比赛的<a href="http://www.recmath.org/contest/description.php">问题描述</a>如下：</p>
<blockquote><p>对于一个给定的n，找出n个正整数，使得通过它们之间的加减运算能够得到尽可能多的质数。</p></blockquote>
<p>    具体的说，对于一个指定的n，参数选手需要提交n个数A1, A2, …, An。这n个数将由公式ΣAi*Ci产生3^n个和（其中每个Ci可以取-1、0和1中的任一个），这3^n个和中（不同的）质数越多越好。例如，当n=4时，10, 29, 82, 106可以产生9个不同的质数：</p>
<blockquote><p>5 = 106 + 10 – 82 – 29<br>
19 = 29 – 10<br>
29 = 29<br>
43 = 82 – 29 – 10<br>
53 = 82 – 29<br>
67 = 106 – 29 – 10<br>
101 = 82 + 29 – 10<br>
149 = 106 + 82 – 29 -10<br>
227 = 106 + 82 + 29 + 10</p></blockquote>
<p>    参赛者需要完成n=3, 4, …, 14共12个问题，提交的每一组数的和不能超过2^32-1。比赛将在2008年11月10日结束，你可以在此之前提交任意多次。获胜者可以从下面两个网页中任选一个雕刻品作为奖品。说实话，奖品很诱人，我很想要。<br>
    <a href="http://www.bathsheba.com/sculpt/">http://www.bathsheba.com/sculpt/</a><br>
    <a href="http://www.bathsheba.com/math/">http://www.bathsheba.com/math/</a></p>
			 ]]></content>
<pubDate>2008-08-23T04:45:37+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/687</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 错觉动画：旋转的网格 ]]></title>
<link>http://www.matrix67.com/blog/archives/691</link>
<content><![CDATA[ 
		<p><a href="http://digg.com/odd_stuff/Trippy_Rotating_Grid_illusion">digg</a>上的网友发现了一个非常奇妙的视觉效果：一个匀速旋转的大网格会给人带来一种几个小网格各自在旋转的错觉。</p>
<p><img alt="image placeholder" >
<p><span id="more-691"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
如果旋转的速度更快，这种效果将更加明显（建议用Firefox看）：</p>
<p><img alt="image placeholder" >
<p>网友liquid<a href="http://www.matrix67.com/blog/archives/631#comment-110613">曾经告诉我们</a>：</p>
<blockquote><p>给一个简单的tip：点击右上的最小化或者恢复窗口/最大化按钮，摁住不要放，可以暂停gif图，帮助观察比较。</p></blockquote>
<p>用这种方法你可以清楚地看到，这个动画的每一帧都是一个完整的大网格。</p>
			 ]]></content>
<pubDate>2008-08-24T19:59:41+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/691</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Usain Bolt and the Curve Fitting Method ]]></title>
<link>http://www.matrix67.com/blog/archives/696</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
看来，已经有人提前做了一件我最近一直想要做的事情。<br>
最近的几个有点不正常的数据点估计把整条曲线拉低了不少。<br>
来源：<a href="http://blog.wired.com/wiredscience/2008/08/bolt-is-freaky.html">http://blog.wired.com/wiredscience/2008/08/bolt-is-freaky.html</a></p>
			 ]]></content>
<pubDate>2008-08-27T19:45:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/696</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：构造一个[0,1]到(0,1)的一一映射 ]]></title>
<link>http://www.matrix67.com/blog/archives/698</link>
<content><![CDATA[ 
		<p>    网友Gestorm在<a href="http://groups.google.com/group/pongba/browse_thread/thread/c4c10095393e464d">TopLanguage</a>里问到，如何构造一个[0,1]到(0,1)的一一映射。两个集合的势显然相等，它们之间一定有一个一一对应的函数。注意到(0,1)是[0,1]的子集，利用<a href="http://www.matrix67.com/blog/archives/536">Cantor-Bernstein-Schroeder定理</a>，只要我们能找到一个从[0,1]到(0,1)的单射函数，我们便找到了两个集合间的双射函数（因为上述定理的证明是构造性的）。这非常简单，例如f(x)表示x与0.5的平均数即可。考虑上述定理的Julius König证明，我们立即得到一个[0,1]到(0,1)的一一映射：f(0)=1/4, f(1/4)=3/8, f(3/8)=7/16, …，不断进行(x+1/2)/2的迭代；同样地，f(1)=3/4, f(3/4)=5/8, f(5/8)=9/16, …；对于其它所有未定义到的x，f(x)=x。这个函数显然是双射的。<br>
    仔细观察这个函数。当你领会到这个函数的真谛时，你突然恍然大悟：我可以用类似地办法弄出无穷多个[0,1]到(0,1)的一一映射。例如，最简单的便是f(0)=1/2, f(1)=1/3；然后f(1/2)=1/4, f(1/3)=1/5, f(1/4)=1/6, …, f(1/i)=1/(i+2)；对于其它未定义的x，f(x)=x。<br>
    查看TopLanguage的原帖可以看到一些类似的结果。</p>
			 ]]></content>
<pubDate>2008-08-27T23:15:51+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/698</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ “解答和题目一样长”：更多的一句话证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/701</link>
<content><![CDATA[ 
		<p>    网友hetong_007在<a href="http://blog.programet.cn/2008/08/blog-post_22.html">他的Blog</a>上分享了几个“一句话证明”：</p>
<p>    在一个圆周上有若干个实数，将它们染成或红或蓝，满足红数等于左右两个相邻数的和，蓝数等于左右两个相邻数的和再除以2。求证，红色数的总和为零。<br>
    <span style="color:#E5E5E5">我们用S红来表示所有红数的和，S蓝来表示所有蓝数的和，S表示所有数的和。于是不难得出S红+S蓝=S；S红+2S蓝=2S。</span></p>
<p>    定义f(x)满足：定义域及值域都是不为零的实数，且f(x)+f(y)=f(x·y·f(x+y))，求解f(x)。<br>
    <span style="color:#E5E5E5">可知，在条件下y·f(x+y)≠1，于是f(x+y)≠1/y；令z=x+y，则f(z)≠1/(z-x)；对于每一个固定的z，x可以取任意非0实数，而它们所产生的1/(z-x)都不等于f(z)，那么f(z)只能等于1/(z-0)。经验证，答案满足条件。</span></p>
<p>    在一个平面上对所有点任意红蓝染色，求证一定存在两个自同色的相似凸n边形，满足相似比为e^pi。自同色是指自己的顶点都是一种颜色，两个凸n边形不一定要互相同色。<br>
    <span style="color:#E5E5E5">在平面上做两个同心圆，且半径比为e^pi。在内圆上选2n-1个同色的点，分别与圆心连接，延长交于外圆。由鸽笼原理，外圆上的2n-1个点一定有n个点同色。</span></p>
<p>    网友B.Storm告诉我说，他正在写一个<a href="http://mathematica-nexus.blogspot.com/">Mathematica的进阶教程</a>。看这个趋势的话，这很可能会成为最强大的Mathematica中文教程了，希望能坚持写完。</p>
<p>    hetong_007发来邮件说，那位牛人在kloonigames把所有的原创游戏都<a href="http://www.kloonigames.com/blog/games">列了出来</a>。相当强大。</p>
			 ]]></content>
<pubDate>2008-08-28T16:28:54+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/701</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ iHologram：利用手机水平感应功能打造惊人3D效果 ]]></title>
<link>http://www.matrix67.com/blog/archives/706</link>
<content><![CDATA[ 
		<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/Tm2IhMdjXmQ&amp;hl=en&amp;fs=1">
<param name="allowFullScreen" value="true">
<embed src="http://www.youtube.com/v/Tm2IhMdjXmQ&amp;hl=en&amp;fs=1" type="application/x-shockwave-flash" allowfullscreen="true" width="425" height="344"></embed></object></p>
<p>手机的水平感应功能可以带给我们很多有趣的东西。这个叫做iHologram的iPhone程序可以利用水平感应显示出一种不可思议的3D效果。这个程序目前仍处于开发阶段。</p>
			 ]]></content>
<pubDate>2008-08-28T16:42:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/706</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一个与矩形剖分有关的命题（五）：数学归纳法 ]]></title>
<link>http://www.matrix67.com/blog/archives/718</link>
<content><![CDATA[ 
		<blockquote><p>如果一个矩形可以分割为若干个小矩形，每个小矩形都有至少一边为整数长，则原矩形同样有至少一个长度为整数的边。换句话说，用至少有一边的长度是整数的小矩形拼成一个大矩形，大矩形也有至少一条整数长的边。</p></blockquote>
<p><img alt="image placeholder" >
<p>    我们首先把每个小矩形都分割成单位长或单位宽的长条。这样的话，大矩形里就只有两种小矩形：宽为1的（图(2)中的蓝色矩形）和高为1的（图(2)中的红色矩形）。我们对蓝色矩形的个数施归纳。随便选择一个蓝色的矩形（例如图(2)中的阴影矩形）。增加它的高度，让它“穿过”它头顶上的红色矩形（把它正上方的红色矩形截成左右两段），直到这根竖条状矩形的顶端碰到了另一个蓝色矩形的底端。把那个矩形作为新的操作对象，继续增加其高度（并可能再次更换“当前矩形”），直到达到整个大矩形的上边界。我们用同样的方法让最初所选的阴影矩形向下“生长”到大矩形的下边界。注意到在此过程中，蓝色矩形始终保持着单位宽度，红色矩形始终保持着单位高度。整个过程结束后，红色矩形变多了，但蓝色矩形的个数不变。此时我们得到了一条上下贯穿整个大矩形的蓝色矩形链。把它们擦掉，将右半部分左移一个单位，重新拼成一个大矩形。新的大矩形高度不变，宽度减一（因此原来的整数边还是整数，非整数边仍然不是整数），并且最关键的是蓝色矩形的个数减少了。反复进行这样的操作，总有一个时候大矩形里只剩下红色的矩形（则原大矩形高度显然为整），或者某次操作后所有矩形都被去掉了（则原大矩形宽度为整）。<br>
    借用这种方法我们还可以得到一个有点搞笑的反证法。假设大矩形的横边竖边都不是整数。每一步操作后，这两个边仍然是非整数，这表明大矩形里不可能只剩一种颜色的小矩形，于是我们可以无限制地调用上面的操作。最后的结果是：我们得到了一个用整数长或整数宽的小矩形拼接而成的一个横边竖边都小于1的大矩形！这显然是荒谬的。</p>
<p>参考资料：<a href="http://www.cut-the-knot.org/Curriculum/Algebra/IntRectRobinson.shtml">http://www.cut-the-knot.org/Curriculum/Algebra/IntRectRobinson.shtml</a></p>
			 ]]></content>
<pubDate>2008-08-31T08:03:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/718</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 是否存在只在一点连续的函数？ ]]></title>
<link>http://www.matrix67.com/blog/archives/720</link>
<content><![CDATA[ 
		<p>    有人突然问到我，有不有可能构造一个函数，它只在一个点连续，其余地方处处不连续。函数构造是一个非常诱人的问题，我非常喜欢那些具有各种不可思议的性质的函数，那些令人吃惊的特性往往违背了大多数人的直觉和常识，这些都是茶余饭后闲谈的绝佳话题。前面提到的这个问题就是一个很有趣的问题。永远不要想当然地以为只在一点连续的函数不存在，各种怪相函数可谓无奇不有。仔细考虑了一下，我想这个函数应该和Dirichlet函数有点联系吧，毕竟很多与连续性相关的函数其原型都是Dirichlet函数，比如满足“无理点处处连续、有理点处处不连续”的爆米花函数就有Dirichlet函数的影子。然后我就突然想到，我彻底火星了，而且还是超级乌龙火星——这个玩意儿我自己还在Blog上写过，只是当时我并没注意到罢了。我曾经在描述<a href="http://www.matrix67.com/blog/archives/249">Hilbert曲线</a>时写到：</p>
<blockquote><p>    你知道吗，除了常函数之外还存在其它没有最小正周期的周期函数。考虑一个这样的函数：它的定义域为全体实数，当x为有理数时f(x)=1，当x为无理数时f(x)=0。显然，任何有理数都是这个函数的一个<del datetime="2008-09-03T13:34:09+00:00">最小正</del>周期，因为一个有理数加有理数还是有理数，而一个无理数加有理数仍然是无理数。因此，该函数的最小正周期可以任意小。如果非要画出它的图象，大致看上去就是两根直线。请问这个函数是连续函数吗？如果把这个函数改一下，当x为无理数时f(x)=0，当x为有理数时f(x)=x，那新的函数是连续函数吗？<br>
    …………<br>
    有了Cauchy定义，回过头来看前面的问题，我们可以推出：第一个函数在任何一点都不连续，因为当ε&lt; 1时，δ范围内总存在至少一个点跳出了ε的范围；第二个函数只在x=0处是连续的，因为此时不管ε是多少，只需要δ比ε小一点就可以满足ε-δ定义了。</p></blockquote>
<p>    类似地，我们可以扩展出只在两个点、只在三个点连续的函数。只需把有理点上的f(x)=x换成f(x)=(x-a)(x-b)(x-c)，我们便得到一个只在a, b, c三点连续的函数。</p>
			 ]]></content>
<pubDate>2008-09-02T05:24:37+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/720</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 牛！各种变态的数独谜题 ]]></title>
<link>http://www.matrix67.com/blog/archives/725</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
（目前已知的）所给条件最少的数独(17个已知条件) 这样的数独数量相当大<br>
…….1.4………2………..5.4.7..8…3….1.9….3..4..2…5.1……..8.6…<br>
（目前已知的）所给条件最少的仅有两个解的数独(16个已知条件) 目前只发现了这一个<br>
1…….5….3……2.4…………..34…7…..2.6..12….5….7…..3……1…<br>
（目前已知的）所给条件最少的左右轴对称的数独(19个已知条件)<br>
7…….2.6…..4….9.8….36…98…..1…..4…..3….8.6…..2…5..1…….7</p>
<p> <br>
<img alt="image placeholder" >
（目前已知的）所给条件最少的沿两条对角线都对称的数独(18个已知条件)<br>
….25……..73……..48……..597…….238……..95……..16……..83….<br>
（目前已知的）所给条件最少的完全对称数独(20个已知条件)<br>
..37.26……6….4…….17…….3.4…..1.1…….49…….7….2……68.32..<br>
（目前已知的）“零条件规则区域”个数最多的数独(9个，行列块各3个)<br>
14.93….93.1…………………..56……489…..27…………25..18…74..32</p>
<p><span id="more-725"></span><br>
 <br>
<img alt="image placeholder" >
（目前已知的）空白矩形区域最大的数独(6*5=30)<br>
..67.35……4….5…….29…….7.3…..4.8…….11…….4……….5926731.<br>
完全对称且对称数字互补（中心对称的数相加得10）的数独<br>
1…….2…389…….6…..87…61..3…..7..94…32…..4…….127…8…….9<br>
“我单身都这么久了上天啊就让我恋爱一次吧”数独<br>
.216.784.7…1…39…….23…….82…….7.9…..6…4…7…..2.1…….8….</p>
<p> <br>
<img alt="image placeholder" >
专杀暴力搜索程序的数独（前面的空白很长，解的字典序相当的大）<br>
…………..3.85..1.2…….5.7…..4…1…9…….5……73..2.1……..4…9<br>
一个有趣的数独（答案很好玩）<br>
3….5…4….6…5..1.7..66..2.8..7.1.3..2.8.2.4..3.9.3….4…4….5………..<br>
国外论坛上的“Human Cannot Solve”数独<br>
…7..8……4..3……9..16..5……1..3..4…5..1..75..2..6…3..8..9…7…..2</p>
<p> <br>
<img alt="image placeholder" >
几个非常非常非常非常非常难的数独（绝对不开玩笑）<br>
1…….2.9.4…5…6…7…5.9.3…….7…….85..4.7…..6…3…9.8…2…..1<br>
..1..4…….6.3.5…9…..8…..7.3…….285…7.6..3…8…6..92……4…1…<br>
…….39…..1..5..3.5.8….8.9…6.7…2…1..4…….9.8..5..2….6..4..7…..<br>
.2.4.37………32……..4.4.2…7.8…5………1…5…..9…3.9….7..1..86..</p>
<p>我亲自验证了，除了第二个以外，其余每一个数独都有唯一解。</p>
			 ]]></content>
<pubDate>2008-09-02T06:01:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/725</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 思考的乐趣：UyHiP趣题之用最少的块移动实现逆序操作 ]]></title>
<link>http://www.matrix67.com/blog/archives/730</link>
<content><![CDATA[ 
		<p>    <a href="http://www.brand.site.co.il/">Michael Brand</a>的<a href="http://www.brand.site.co.il/riddles/usingyourhead.html">Using your Head is Permitted</a>是我最喜欢的谜题挑战网站，很多题目相当精彩。我已经多次翻译了那上面的谜题（点击<a href="http://www.matrix67.com/blog/?s=brand.site">这里</a>看看）。不过，以往我都是静候月底释出答案，从来没有想过参与挑战。<a href="http://www.brand.site.co.il/riddles/200809q.html">这个月的题</a>相当诱人，只看题目描述的最后一句话我就知道这绝对是我喜欢的类型，于是我有了向本月题目发起挑战的冲动。印象中我真的是很久很久没有像这样疯狂地思考一个问题了。然后呢，我非常得意地告诉大家，哈哈~~~经过昨天一整夜的思考，我终于把它解决了！！于是赶忙写下我的解答过程，再三检查后发到了Michael Brand的邮箱。今天起床时收到了Michael Brand热情洋溢的回信，List of solvers也写上了我的名字，我很是兴奋。自我感觉这是一道非常好的题目，题目简洁有趣而有挑战性，解答本身并不难但也不太好想，很适合大家花一整天的时间仔细琢磨；因此这里也推荐给大家来挑战一下。解答不要发到下面的评论里，也不用发给我，直接发过去好了。期待过几天在List of solvers里看到大家的名字。</p>
<p>    在这里简单翻译一下题目。对数列的一次“块移动”是指把一段数取出来插入到数列中的另一个地方（说穿了就是一次选择剪切粘贴的操作）。例如，数列1,4,5,6,2,3,7可以通过一次块移动完成排序（把456挪到3后面）。那么，想要让一个1到n的逆序排列n, n-1, …, 3, 2, 1变为顺序排列，最少需要多少次块移动？给出你的算法，并证明这个移动数目不能再少了。</p>
<p style="color:red">Update: 为防止进一步讨论，我把评论禁了…</p>
			 ]]></content>
<pubDate>2008-09-03T02:12:35+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/730</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：奇怪的自然数集划分 ]]></title>
<link>http://www.matrix67.com/blog/archives/733</link>
<content><![CDATA[ 
		<p>    给定一个集合S和数n，从集合S中取出两个不同的数a,b满足a+b=n的总方案数叫做“集合S中关于n的互补数对个数”。是否有可能把全体非负整数划分为A、B两个集合，使得对于任意一个n，集合A和集合B中关于n的互补数对的个数都相同？</p>
<p> <br>
<span id="more-733"></span></p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    答案是肯定的。此处，神奇的二进制再次在看似与它毫不相干的地方显示出自己独特的力量。把所有数写成二进制，有偶数个数字“1”的数归入A集合，有奇数个数字“1”的归入B集合。为了证明A、B中关于n的互补数对个数相同，我们在这两组互补数对间建立一个一一对应的关系。假设A集合中有两个数a1,a2满足a1+a2=n，那么找出a1和a2的二进制表达中右起第一个数码不同的地方（由于a1≠a2，因此这一定能办到）。把两个数字各自在该位置上的数码对换一下，“0”变成“1”，“1”变成“0”。新的两个数就是b1和b2。显然，b1和b2都属于B集合，并且b1+b2=n。</p>
<p>    有趣的是，这种划分方法是唯一的（无妨设0∈A）。为了证明这一点，我们只需要施归纳于n：假设为了满足关于1,2,…,n-1的互补数对个数相同的条件，从0到n-1这n个数的位置是唯一确定的，现在考虑（为了满足关于n相等的条件）n应该放到哪边。假设在没有n的时候，两个集合关于n的互补数对分别有c(A)和c(B)个。把n放进集合B里之后c(A)和c(B)都不变，但把n放进集合A后c(A)会加一（因为0在A里）。因此，n最多属于其中一个集合，不可能出现两边都可以的情况。</p>
			 ]]></content>
<pubDate>2008-09-03T18:52:38+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/733</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 荒唐的一幕 ]]></title>
<link>http://www.matrix67.com/blog/archives/754</link>
<content><![CDATA[ 
		<p>    我没有接菜单。“六成熟的牛排加一份炸鳕鱼，谢谢”，我说。穿着艳丽的服务员MM拿着菜单微笑着退下。下午四点起床的好处在于，在任何一家餐厅就餐都不会有太多的人；不好的就是，没有人会陪你来吃。一个人在餐厅用餐看上去多少有些滑稽。<br>
    我把视线移到桌子对面的那个人。他手中翻开的《科幻世界》正好遮住了他的脸。从封面来看这应该是最近的一期，几个非常不起眼的五环标志和与背景几乎融为一色的中国字暗示着这期《科幻世界》的封面展示的是未来某次在中国举办的奥运会的盛况。我正想说“你也喜欢《科幻世界》么”时，他先发话了：“兄弟，你点的东西和我刚才点的完全一样。”他放下手中的杂志，我俩四目相对。我惊呆了。面前的这个人体型和我别无二致，穿着和我一样的衣服，留着完全相同的发型和胡子，脸上的斑点仿佛是用一个模子印出来的。如果不是他手中比我多拿了一本杂志，我可能会真的以为我面对的是一面镜子。<br>
    我静下心来，说道：“这让我想起了Kiefer Sutherland的新电影……”<br>
    话没说完，他接了一句“Mirrors吧，镜子里的人和镜子前的人动作不一样……”<br>
    他提到国外电影时也直接用英文名，这让我很是吃惊。我说：“但这部电影绝对比不上Kiefer Sutherland的另一经典之作。”<br>
    “你说Dark City吧，经典中的经典了。”他条件反射式地回答到。这绝对不是巧合！电影Dark City的知名度远远小于Kiefer Sutherland出演的火热美剧24。我本以为他会回答24的，但他给出的答案和我预想的完全一致。<br>
    他也开始试探性地发问：“你知道吗，最近Dark City出了一个特别的……”<br>
    我就知道他要说这个。我连忙抢过话头：“……10周年导演剪切版。哈哈，我还真想再看一次！”<br>
    “对啊，因为这个导演剪切版改了很多，网上有人甚至评论说‘就像变成了另一部电影’。”<br>
    “难道……”我长大了嘴，指着他惊奇地叫到，“难道你也经常去digg上看新闻？”<br>
    “呵呵，我还经常去found四个f呢！”<br>
    我笑了，“他妈的四个f，我他妈的还去八个i呢……”<br>
    “怎么你也……”他的声音明显地变了调。然后我们沉默了。网络中的语言在日常口语交际中的频频出现给这种沉默带来一些轻微的喜剧效果。</p>
<p><span id="more-754"></span><br>
    太可怕了。一个和我一模一样的人！连习惯和思维都完全一样！我虽然一天到晚都在想这个世界上的种种怪事，但从没想过自己能遇上啊！各种我以前熟知的阴谋论在我脑海中闪现，让我顿时慌了手脚。我抬起头来，正想发问，突然发现在同一时刻他也抬起头来看着我。我意识到或许他刚才也在思考相同的问题。他先一步发问：“你猜我圆周率能背到小数点后多少位？”<br>
    “25位。”我说。此时，问姓名和住址已经没什么必要了。这不是一个Geek的作风，事实上在这种情况下也几乎没有意义。我意识到，他略过学校姓名不谈，估计也是因为这样。我说：“你知不知道在我网站上唯一留过言的大学同学是谁？”<br>
    “古汉MM。梁静茹新专辑里的《我决定》是来自……”<br>
    “《生命中不可承受的轻》。是否存在一个在无理点处处连……”<br>
    “爆米花函数。”问题还没说完他就抢先喊出答案。他稍微停顿了一下，很可能是想找一个更偏的问题。他继续说：“n个数中有且仅有一个出现了奇数次，如何……”<br>
    “从头到尾异或一遍。”他提的问题也是我茶余饭后最喜欢和朋友聊起的问题。<br>
    “钝角三角形至少可以……”<br>
    “7个！哪国人养鱼？”<br>
    “德国人！环球飞行？<br>
    “3架！海盗？”<br>
    “98块！过桥？”<br>
    “17分钟！弓虽强？”<br>
    “不如石更硬！做爱做的事？”<br>
    “交配交的人！”<br>
    ……</p>
<p> <br>
    我们两人的对话几乎是一气呵成，没有任何停顿。末了，双方都喘了好长一口气。他说：“毫无疑问，我们是同一个人。”<br>
    我不得不确信他说的是对的：“我们拥有完全相同的外貌、经历、思维和……”我突然顿住了。没错！我们并没有验证我们具有相同的思维！我话题一转，提高一个调说：“我们刚才的一切仅仅说明我们有相同的记忆！哈哈哈……是不是政府里有人偷走了我的基因和记忆，然后造出来一个和我一模一样的人啊？”<br>
    “凭什么你不是那个复制品呢？”他说，“就像……”<br>
    “就像第六日一样！”我俩异口同声地说。我们都用的是“第六日”这个词。当电影名的翻译非常之准确时，我会用它的中文名。<br>
    这绝对不行。我一定要现场想出一道测试脑力的题目。复制品可以拥有我的记忆，但不可能拥有我的思维。我开始回忆在准备NOIp模拟赛时曾思考过的各种原创题目雏形，然后意识到我不该这样做。这个题目的任何一个部分都不能在我记忆中出现过，哪怕只是一个未完成的雏形。我开始观察周围的事物，希望有什么东西能启发我想到一个极具挑战性的智力题。<br>
    我说：“n个开关排成一排，你每次可以改变连续k个开关的状态。给你开关的初始状态，问k等于多少时把所有开关都关了需要的操作次数最少？”<br>
    他问：“要求多少的复杂度？”<br>
    “你他妈的想出一个多项式的就行，给你两分钟时间。”我颇有些得意地说。</p>
<p> <br>
    “时间到！”我坏坏地一笑，“不行了吧！”<br>
    “哼，一道题不能说明什么，要是我现场给你编一道题你也不一定会！”<br>
    “告诉你吧，在同一个位置操作两次显然是没用的……”<br>
    “嗯，对，然后呢？”<br>
    “然后？操作的顺序也无关紧要嘛！反正最后都是看每个开关被覆盖了多少次……”<br>
    “哦！哦！然后就枚举k，对每一种k从左到右扫一遍看是否可行？科学题目！太科学了！好题！好题！如果我再多想一下应该能想出来……”<br>
    “别找理由！你就是我的复制品！这个问题也是我临时想出来的，我一下就想到该怎么做了！”<br>
    “这绝对不是我的问题！”他对我苦笑一下，“今天我就像是喝醉了一样，完全不能进行正常的逻辑思维。平时我都不这样的……”<br>
    他陷入了沉思。我仔细观察着他的样子，心想我思考时的样子还真不咋样。又过了大概两分钟，他抬起头来看着我，问我：“一个单位立方体内是否能放置一个面积大于1的正方形？”<br>
    这下倒霉的是我了。对于这种问题，如果不需要严格证明的话，我只需在头脑中进行一次简单的空间想像即可得到精确的答案。但这一次，我似乎真的遇到瓶颈了，这种能力减弱了很多，就像……就像喝醉了酒一样。我似乎体会到了那些做不出多面体展开图判断题的人的苦衷。仔细整理一下这一切：为什么会存在两个连记忆都完全相同的人，但面对对方的提问时突然间都不能进行正常的思维了？这里面一定有一个合理的解释。</p>
<p> <br>
    然后，我做出了一个大胆的猜测。我抬头说：“兄弟，认真回答一个问题，这非常重要。看你背后那一桌的MM……”我指着他身后，“你觉得哪个最漂亮？”<br>
    他转过头去看了看，头也不回就说：“右边第二个。”<br>
    “怎么会呢？”我表示出坚决的反对，“你说的那个MM具有了所有丑MM的特征……左边第一个明显漂亮得多！”<br>
    “你真是瞎了眼，我选的那个MM那么像Stetson MM，怎么会不漂亮呢？”<br>
    我愣了一下。这下更加确定，我的猜想是正确的了。我稍作停顿后说：“兄弟，我们是一个人没错，但你发现了吗，你的逻辑思考能力下降了，我也几乎无法进行空间想像。另外，我的审美能力也明显出了问题……我们是……”<br>
    “同一个人的左右半脑！”我们再次异口同声地说。<br>
    “我们共享着实体的所有记忆，但却分成了两个可以独立思考的个体；其中一个使用右半脑的资源来思考，而我显然是使用左半脑的那一位。我们其实只存在于真实世界中的那个我们的头脑里！”<br>
    “这就是说……我们都在真实的我的……呃……梦境中？”<br>
    “嗯，很有可能，就像是……”<br>
    ——“House第二季的最后一集！”我们第三次不约而同地说出了同样的话。<br>
    “那么，现在的关键就是，我们需要想出一个在现实生活中不可能发生的事，唤醒我们的实体对吧？”我说。<br>
    “那就是你的事情咯！”他笑着对我说，“谁叫你当左半脑的？”</p>
<p> <br>
    思考啊！思考！在现实生活中，两个完全相同的人的出现会带来什么矛盾？上网登录北大的选课系统？我们用同一个帐号并不会立即带来什么矛盾；我们一起回去见老妈？万一我们有两个一模一样的家庭，有两个一模一样的老妈又咋办……我需要一个操作便捷、一针见血、立竿见影的方法……我突然灵光一闪，哈哈，想到了！<br>
    “喂，你该不会也有一个SmartMovie里有A片、Games文件夹里有百战天虫、把10086存到联系人里取个名字叫‘傻B移动’的N82吧！”我说。<br>
    我俩同时从裤子口袋里掏出手机，并排放在桌上。两部手机的外观和显示的内容完全一致，连屏幕右上角那个刺眼的亮点的位置都分毫不差。<br>
    他明白我的意思了。我俩哈哈大笑起来。<br>
    两个完全相同的人在一起显然是不可能的，因为……我们不可能有相同的手机号！</p>
<p> <br>
    服务员MM满脸堆笑地托着两个托盘走来，看见这一对点的东西完全一样的双胞胎很是惊奇。待她把我们的东西放好后，我给了她一张写有一个11位数的纸条。“麻烦您用您的手机打一下这个号码，谢谢！”我说。<br>
    服务员MM一脸狐疑地掏出自己的N78，纤细的手指在那臭名昭著的条状键盘上轻快地跳跃。我和他瞪大眼睛盯着两个并排放着的N82，期待着即将上演的荒唐的一幕。<br>
    突然，我猛地从床上坐起来。窗外的凉风吹起了桌上的几页草稿纸，整夜没关的显示器冲着我可爱地眨了眨眼睛。“哈哈哈哈哈……”我大笑起来。“最终我还是赢了！”我得意地自言自语道。</p>
			 ]]></content>
<pubDate>2008-09-04T09:04:08+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/754</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：循环赛中总存在一人“可传递一次”地打败了所有人 ]]></title>
<link>http://www.matrix67.com/blog/archives/746</link>
<content><![CDATA[ 
		<p>    n个人中每两个人之间都进行过一次比赛。假设比赛不可能出现平局。证明，一定能找出这样的一个人，对于其它任何一人p，他击败了p或者击败了某个打败了p的人。</p>
<p>    一句话证明：<span style="color:#E5E5E5;">赢的次数最多的那个人显然满足我们的条件。反证，假设被他打败的所有人的集合为P，万一有个人既没有输给他，也没有输给P里面的任何一人，那这个人至少赢了|P|+1次，成了获胜次数更多的人，矛盾。</span>我故意在这里多写一句话，目的是想说明前面的空白有多短。在Ctrl+A之前，不妨试试看自己能否想到如此简单的证明。</p>
<p>来源：<a href="http://www.cut-the-knot.org/arithmetic/combinatorics/RoundRobinTournament.shtml">http://www.cut-the-knot.org/arithmetic/combinatorics/RoundRobinTournament.shtml</a></p>
<p><span id="more-746"></span><br>
顺便说两件事情。<br>
网友yuye_abc建议我搞一个wap浏览插件。其实没有必要，大家直接去<a href="http://wap.feedsky.com/matrix67">wap.feedsky.com/matrix67</a>就可以了。<br>
<del datetime="2008-09-07T08:29:50+00:00">网友hetong_007留言说NOI专刊引用了我两篇文章？求详情。</del>依然欢迎大家在自己的文章里引用我Blog上的东西。</p>
			 ]]></content>
<pubDate>2008-09-07T03:29:19+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/746</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：2n+1个点中任n个都与同一点相连，则存在一个连接所有点的点 ]]></title>
<link>http://www.matrix67.com/blog/archives/751</link>
<content><![CDATA[ 
		<p>    有2n+1个人，他们的朋友关系满足这样一种奇特的性质：任选n个人，则在剩下的人中总能找到一个人，他和这n个人都是朋友。求证，存在这样一个人，他和所有人都是朋友。我们假设朋友关系是双向的，也就是说如果A是B的朋友，那么B一定是A的朋友。</p>
<p style="color:#E5E5E5">    这明显可以转化为一个图论问题。选出两个互为朋友的人。我们得到了一个大小为2的团（一个“团”就是一个所有结点两两相连的子图，或者干脆说是完全图形状的子图）。和另外n-2个人并在一起，则存在一个人和他们都是朋友（当然和那两个人也就是朋友了）。把这个人加进刚才那个团里，于是我们得到了一个大小为3的团。又随便取n-3个人和这3个并在一起，则有一个人和所有这些人都是朋友，于是我们继续扩展出一个大小为4的团。反复进行这个操作，直到我们得到一个大小为n+1的团，此时团的大小已经不能再继续扩展了。但是，一旦注意到此时不属于团的人只剩n个了时，我们发现问题已经解决了：在团里面存在一个人P，他和不属于这个团的那n个人都是朋友。而P本身在一个大小为n+1的团里面，他和团里的其余n个人都是朋友。因此，P和所有人都是朋友。</p>
<p>来源：<a href="http://www.cut-the-knot.org/arithmetic/combinatorics/Clique.shtml">http://www.cut-the-knot.org/arithmetic/combinatorics/Clique.shtml</a></p>
			 ]]></content>
<pubDate>2008-09-07T03:41:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/751</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 最酷的证明：Pick定理另类证法 ]]></title>
<link>http://www.matrix67.com/blog/archives/768</link>
<content><![CDATA[ 
		<p>    难以想像，一段小小的证明竟然能比一个瘦小的留着长头发穿黑色短袖T恤紧身牛仔裤边跳边弹吉他的MM还要酷。原来一直以为<a href="http://www.matrix67.com/blog/archives/33">这个证明</a>已经很酷了，现在显然我已经找到了一个更酷的证明。<br>
    Pick定理是说，假设平面上有一个顶点全在格点上的多边形P，那么其面积S(P)应该等于i+b/2-1，其中i为多边形内部所含的格点数，b是多边形边界上的格点数。绝大多数证明都是用割补的办法重新拼拆多边形。这里，我们来看一个另类的证明。<br>
    假设整个平面是一个无穷大的铁板；在0时间，每个格点上都有一个单位的热量。经过无穷长时间的传导后，最终这些热量将以单位密度均匀地分布在整个铁板上。下面我们试着求多边形P内的热量。考虑多边形的每一条线段e：它的两个端点均在格点上，因此线段e的中点是整个平面格点的对称中心，因而流经该线段的热量收支平衡（这半边进来了多少那半边就出去了多少），即出入该线段的热量总和实际为0。我们立即看到，P的热量其实完全来自于它自身内部的i个格点（的全部热量），以及边界上的b个格点（各自在某一角度范围内传出的热量）。边界上的b个点形成了一个内角和为(b-2)*180的b边形，从这b个点流入P的热量为(b-2)*180/360 = (b-2)/2 = b/2-1。<del datetime="2008-10-06T13:44:29+00:00">在</del>再加上i个内部格点，于是S(P)=i+b/2-1。</p>
<p>来源：<br>
<a href="http://zhuhcheng.spaces.live.com/blog/cns!DE38E96268C49F28!212.entry">http://zhuhcheng.spaces.live.com/blog/cns!DE38E96268C49F28!212.entry</a><br>
<a href="http://www.math.ethz.ch/~blatter/Pick.pdf">http://www.math.ethz.ch/~blatter/Pick.pdf</a></p>
			 ]]></content>
<pubDate>2008-09-08T13:33:08+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/768</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 数学思维游戏两则：Gabriel喇叭、世界末日论 ]]></title>
<link>http://www.matrix67.com/blog/archives/773</link>
<content><![CDATA[ 
		<p>    看到新词就上一下Wikipedia确实是一个好习惯。<a href="http://www.matrix67.com/blog/archives/768">前一篇日志</a>的那个pdf里作者提到了Gedankenexperiment(Thought experiment)，上<a href="http://en.wikipedia.org/wiki/Thought_experiment">Wikipedia</a>一查果然学到了牛B的新东西。好多物理定律其实完全是由思维实验推导出来的，难以置信仅仅是思考竟然就能得出物理世界遵从的各种法则。经典的物理思维实验有Newton大炮、Galileo斜塔实验、Schrödinger的猫猫、Maxwell的妖怪等等。还有，Turing机也是一个伟大的思维实验。</p>
<p>   <img alt="image placeholder" >
    数学上的不少悖论（特别是涉及到维度和无穷的悖论）都是相当有趣的思维实验。<a href="http://en.wikipedia.org/wiki/Gabriel%27s_Horn">Gabriel喇叭</a>是y=1/x在[1,+∞)上的图象沿x轴旋转一周所形成的旋转体。这个简单的三维图形有一个奇特的性质：它的表面积无穷大，却只有有限的体积。为了证实这一点，只需注意到：<br>
   <img alt="image placeholder" >
    Gabriel喇叭会导出一个非常诡异的悖论：如果你想用涂料把Gabriel喇叭的表面刷一遍，你需要无穷多的涂料；然而把涂料倒进Gabriel喇叭填满整个内部空间，所需要的涂料反而是有限的。<br>
    有网友一定会问，那有没有什么二维图形，面积有限大，周长却无限长呢？答案是肯定的，<a href="http://www.matrix67.com/blog/archives/243">Koch雪花</a>就是这样一个经典的例子。不过，通过分形构造出来的这类图形似乎并不存在涂料悖论，因为递归到一定深度时分形图形的尺度将小于表面涂料的厚度，因此表面大小不能永无止境地算下去，涂满表面所需的涂料不再是无穷多。当考虑到涂料厚度时，原先的悖论也可以解释清楚了：填充内部空间仅仅涂满了图形的内表面，一旦考虑到涂料的厚度，它和外表面的区别就出来了。</p>
<p><span id="more-773"></span><br>
    另一个有趣的思维实验与<a href="http://en.wikipedia.org/wiki/Doomsday_argument">世界末日论</a>相关：我们可以通过数学算法“求”出世界末日在哪一天！！下面我们将用简单的数学知识得出这一结论：人类文明已经发展到一半的概率达到95%。<br>
    假设整个人类文明史上一共诞生了N个人，而你是其中的第n个人。根据Copernican原理，假设把整个人类文明看作数轴上[0,1]的线段，则你在这条“时间线”上可能处在的位置概率均等地分布在区间(0,1]中。下面我们在(0,1)中取一个足够大的数，比如0.95。那么，你发现自己处在人类文明的(0.05,1]区间上的概率是95%，也即n/N &gt; 0.05。整理一下，我们得到N&lt;20n。如果我们取目前人类文明的总人数n=600亿，代入上式我们有N&lt;12000亿。我们得到这样的结论：有95%的可能性，整个人类文明共诞生了12000亿个人。假设世界人口稳定在100亿，人的平均寿命是80年，那么剩下的11400亿人将在9120年内走完自己的生命。换句话说，人类文明在9120年内灭亡有95%的可能性。这是一个惊人的数字啊！整个人类文明已经过了近万年，居然再过个这么多年就要结束了。
</p>
			 ]]></content>
<pubDate>2008-09-10T06:49:33+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/773</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Oh 一层一层 一层一层 一层一层 又一层层的Klein瓶 ]]></title>
<link>http://www.matrix67.com/blog/archives/785</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>查看更多：<a href="http://www.sciencemuseum.org.uk/images/I046/10314758.aspx">http://www.sciencemuseum.org.uk/images/I046/10314758.aspx</a></p>
			 ]]></content>
<pubDate>2008-09-11T12:34:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/785</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 八皇后加强版：每个皇后最多攻击一个其它的皇后 ]]></title>
<link>http://www.matrix67.com/blog/archives/789</link>
<content><![CDATA[ 
		<p>    想必搞OI/ACM的朋友都应该知道八皇后问题，这是学习编程的必修课程之一：在国际象棋棋盘上最多可以放置多少个互不攻击的皇后（皇后可以攻击它所在的行、列、对角线方向上的棋子）？显然，能够放置的皇后数不超过8个，因为国际象棋的棋盘一共就8行8列。事实上，放置8个互不攻击的皇后是有可能的，并且方法不止一种。<br>
    上个月的<a href="http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/Challenges/August2008.html">IBM Ponder This</a>考虑了一个八皇后问题的扩展：最多可以在国际象棋棋盘上放置多少个皇后，使得每一个皇后最多只能攻击到一个其它的皇后？</p>
<p><span id="more-789"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    首先我们证明，一个n行n列的棋盘上不能放置超过4n/3个皇后，使得每个皇后的攻击范围内最多只有一个其它的皇后。用X<sub>i</sub>表示有多少个行放置了i个皇后，用Y<sub>i</sub>来表示有多少个列放置了i个皇后。由于同一行（或者同一列）不能放置3个或3个以上的皇后，即一行（或一列）的皇后个数只能是0个、1个或者2个。于是有X<sub>0</sub>+X<sub>1</sub>+X<sub>2</sub>=n, Y<sub>0</sub>+Y<sub>1</sub>+Y<sub>2</sub>=n。因此，我们有X<sub>1</sub>+X<sub>2</sub>≤n, Y<sub>1</sub>+Y<sub>2</sub>≤n。同时，在X<sub>2</sub>个放了2个皇后的行中共有2*X<sub>2</sub>个皇后，其中的每一个皇后都已经攻击了同行的另一个皇后，因此至少有2*X<sub>2</sub>列里恰好有一个皇后，即2*X<sub>2</sub>≤Y<sub>1</sub>。类似地，2*Y<sub>2</sub>≤X<sub>1</sub>。令m为棋盘上的皇后总数，则m=X<sub>1</sub>+2*X<sub>2</sub>=Y<sub>1</sub>+2*Y<sub>2</sub>。<br>
    于是，我们有</p>
<p>  m = (X<sub>1</sub>+2X<sub>2</sub> + Y<sub>1</sub>+2Y<sub>2</sub>)/2<br>
     = (X<sub>1</sub>+4X<sub>2</sub>/3+2X<sub>2</sub>/3 + Y<sub>1</sub>+4Y<sub>2</sub>/3+2Y<sub>2</sub>/3)/2<br>
     ≤ (X<sub>1</sub>+4X<sub>2</sub>/3+Y<sub>1</sub>/3 + Y<sub>1</sub>+4Y<sub>2</sub>/3+X<sub>1</sub>/3)/2<br>
     = 2(X<sub>1</sub>+X<sub>2</sub> +Y<sub>1</sub>+Y<sub>2</sub>)/3 ≤ 4n/3</p>
<p>    当n=8时，上界m=10是可以达到的。</p>
<p><code>+---+---+---+---+---+---+---+---+<br>
| * |   |   |   |   |   |   |   |<br>
+---+---+---+---+---+---+---+---+<br>
|   |   |   |   | * | * |   |   |<br>
+---+---+---+---+---+---+---+---+<br>
|   | * |   |   |   |   |   |   |<br>
+---+---+---+---+---+---+---+---+<br>
|   | * |   |   |   |   |   |   |<br>
+---+---+---+---+---+---+---+---+<br>
|   |   |   |   |   |   | * |   |<br>
+---+---+---+---+---+---+---+---+<br>
|   |   |   |   |   |   | * |   |<br>
+---+---+---+---+---+---+---+---+<br>
|   |   | * | * |   |   |   |   |<br>
+---+---+---+---+---+---+---+---+<br>
| * |   |   |   |   |   |   |   |<br>
+---+---+---+---+---+---+---+---+</code></p>
			 ]]></content>
<pubDate>2008-09-13T15:19:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/789</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：一个数论定理的组合学证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/796</link>
<content><![CDATA[ 
		<p>    最近忙着迎新，很久没有更新了。见了很多可爱的MM，让人欲火焚身。管萌MM是我们这个专业08的新生，人气相当高。在这里祝她生日快乐。好了，最近的情况就聊到这儿。<br>
    Wilson定理指出，对于任一个质数p，都有(p-1)! ≡ -1 (mod p)，换句话说(p-1)! + 1能被p整除。为了证明这一点，让我们来考虑一个圆周上的p等分点。顺次连接这p个点我们可以得到一个正p边形，让它随便旋转多少个360/p度所得到的图形都和原来一样。类似地，跳跃着连接起第1, 3, 5…个点，或者两个两个地跳开来（连接1, 4, 7…个点），你可以得到一个星形的广义正p边形，它们同样满足类似的旋转对称性质。由于跳过k个点和跳过p-k-2个点是一回事，因此这种类型的多边形一共有(p-1)/2个。注意像这种“k个点k个点地跳着连接”的连接方式一定会遍历所有的点最后回到出发点：假如连接d个点后你就提前回到出发点了（而没有遍历完所有点），那一定还有若干组大小为d的点集没被连过，这样的话总点数就是d的倍数，与p是质数就矛盾了。<br>
    除了这种旋转对称的“广义正p边形”以外，其它的多边形随便旋转多少都不能和原来全等。假设有图形最少只需要旋转d个点的位置(d&gt;1)之后就与原图形重合，那么p一定是d的倍数，否则当到了k·d&lt;p&lt;(k+1)d时p-k·d就成了更小的与原图重合的旋转角度；然而p是d的倍数与p是质数矛盾。这告诉我们，非旋转对称的多边形总是p个p个的成组出现，因此它们的数目能被p整除。<br>
    另一方面，连接圆周上的各点所能形成的多边形总数为(p-1)!/2，这是因为规定了起始点后，多边形就由剩下的p-1个点的排列确定，但每个多边形都各算了两次（顺时针、逆时针遍历各一次）。而前面已经提到过，广义的正p边形有(p-1)/2个。这样的话，非旋转对称的多边形总数就等于</p>
<p>  (p-1)!/2 – (p-1)/2 = 1/2 [(p-1)! + 1 – p]</p>
<p>    这个数目能被p整除当且仅当(p-1)! + 1能被p整除。</p>
<p>    来源：<a href="http://www.cut-the-knot.org/blue/GeometricWilson.shtml">http://www.cut-the-knot.org/blue/GeometricWilson.shtml</a></p>
<p>    有趣的是，“p是质数”这一条件也是必要的。假设一个合数p也能整除(p-1)! + 1，这意味着它的某个大于1的因子d也能整除(p-1)! + 1；但同时d还能整除(p-1)!，这显然是不可能的。</p>
			 ]]></content>
<pubDate>2008-09-17T18:28:08+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/796</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：奇怪的有向图 任两点间两步之内可达的路径有且仅有一条 ]]></title>
<link>http://www.matrix67.com/blog/archives/801</link>
<content><![CDATA[ 
		<p>    有这么一个无自环的有向图，它的顶点数在30和40之间（包括30和40）。对于图里面的任意两个点A和B，要么存在一条有向边A-&gt;B，要么存在唯一的一个“中间点”C使得A可以通过A-&gt;C-&gt;B两步走到B。换句话说，对任意给定的A、B两点，从A到B的长度不超过2的路径有且仅有一条。注意，即使当A=B时，这个条件也是成立的。试问这个图有多少个顶点。</p>
<p> <br>
<span id="more-801"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    这道题有趣就有趣在，我们的突破口居然是考察A、B两点间长度为2或3的路径数。假设A有p个后继节点（即从A出发的边有p条），B有q个前驱节点（即有q条边指向B），那么从A到B的路径中长度为2或3的一共有多少条？你可能会说：当然有p条咯！因为A有p个后继节点，而每个后继节点两步之内走到B恰有一种方法。但为什么不说答案是q呢？有q个点可以直达B，而点A在两步之内到这q个点的路径都是唯一的，这就说明从A到B长为2或3的路径数目为q。这告诉我们，p和q是相等的，即A的出度和B的入度相等。再找一个点C，则我们立即可知C的出度也等于B的入度，于是A和C的出度相等。你会立刻发现：搞了半天，这个图的所有点的出度和所有点的入度全部相等。假设这个数字为k，即每个点的前驱和后继都有k个。从某个点A出发，走一步可以到达k个点，再走一步就可以到达k*k个点，这k+k*k个点恰好就是所有点的个数，既无重复也无遗漏。由于30 &lt;= k+k*k &lt;= 40，我们得到k=5，这个图的顶点数为30。
    且慢！我们还没说明满足条件的图真的存在呢！事实上，考虑这样30个点{V_ij|1&lt;=i&lt;=6, 1&lt;=j&lt;=6, i≠j}，从V_ij到V_kl有边当且仅当j=k。这个图显然满足我们的题目条件。

来源：<a href="http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/challenges/October1999.html">http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/challenges/October1999.html</a><br>
最近打算把IBM Ponder This的老题翻一下</p>
			 ]]></content>
<pubDate>2008-09-18T10:54:21+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/801</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Light-Bot：一个编程启蒙游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/810</link>
<content><![CDATA[ 
		<p><object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0" width="650" height="320" id="gamefile" align="middle"><param name="movie" value="http://armorgames.com/files/games/light-bot-2205.swf">
<param name="quality" value="high">
<embed src="http://armorgames.com/files/games/light-bot-2205.swf" quality="high" width="650" height="320" name="gamefile" align="middle" type="application/x-shockwave-flash" pluginspage="http://www.adobe.com/go/getflashplayer"></embed></object></p>
<p><a href="http://kristallklareblase.spaces.live.com">Stetson MM</a>给我推荐的一个Flash小游戏。挺适合给完全没有学过编程的人了解一下什么是“程序设计”。<br>
给个链接：<a href="http://armorgames.com/play/2205/light-bot">http://armorgames.com/play/2205/light-bot</a></p>
<p><span id="more-810"></span><br>
另外，Stetson MM还分享了一个巨猥琐的Flash动画：<a href="http://www.explosm.net/movies/124/">http://www.explosm.net/movies/124/</a></p>
			 ]]></content>
<pubDate>2008-09-23T11:36:11+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/810</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用位运算生成下一个含有k个1的二进制数 ]]></title>
<link>http://www.matrix67.com/blog/archives/813</link>
<content><![CDATA[ 
		<p>    在所有8-bit的整数中，含有k个数字“1”的二进制数一共有C(8,k)个。给出其中的一个二进制数，你如何利用位运算快速找到下一个恰有k个“1”的数？例如，如果给你二进制数01011100，那么下一个（含4个“1”的）数就是01100011。在继续阅读下去之前，建议你仔细思考一下。你或许会想看看我很早以前写的一篇<a href="http://www.matrix67.com/blog/archives/263">介绍位运算的文章</a>。这是一道很好的题目，很多位运算技巧在这里都有体现。</p>
<p>    在草稿纸上随便举几个例子，规律很容易看出来。由于“1”的个数是固定的，为了让这个二进制数更大，我们必须把第一个出现在“1”左边的“0”改成“1”；同时，为了让这个二进制数尽可能小，我们必须把它右边那些“1”重新排到最低位去。<br>
    更具体地说，下一个二进制数可以通过以下步骤得到：找到右起第一个单个的或连续的数字“1”，把它们全改成“0”，同时把它们左边的那个“0”改为“1”。此时，“1”的个数可能减少了，我们只需把还差的“1”摆在最右边就行了。举个例子，01011100的右起第一个“1”在第三位，把它和左边紧挨着的“1”一并变为“0”，并把再左边那个“0”变为“1”，于是我们得到01100000。我们还差两个“1”，把这两个“1”补在最低位得到01100011即可。现在我们的任务是，想出一个用位运算来实现这些步骤的办法。<br>
    我们已经熟知，用x &amp; -x可以提取最右边的那个“1”。当意识到可以利用加法来消除连续的“1”时，我们很快得到了第一步操作的位运算实现：把x &amp; -x加到x上，利用二进制加法的进位把“..01111..”变成“..10000..”。现在，我们需要计算出刚才的操作中一共“跳过”了多少个“1”，换句话说现在的x的右起第一个“1”和原来的x的右起第一个“1”差了多少位。关键就在这里！我们可以用除法来完成这一步，例如100000除以100就相当于把被除数右移2位，得到的结果即可以表示两个数中的“1”差了多少位。在最低位产生指定数量的“1”需要用到另一个技巧：减1操作可以把右边连续的“0”都变成“1”，即把…10000变成…01111。我们得到了该问题的第一个算法：</p>
<p><code>b = x &amp; -x;<br>
t = x + b;<br>
c = t &amp; -t;<br>
m = (c/b &gt;&gt; 1) - 1;<br>
r = t | m; //最终结果</code></p>
<p>    我们对上述算法做一个简单的说明：</p>
<p style="font-family:simsun">操作              | 样例     |  说明<br>
——————+———-+—————————-<br>
x                 | 01011100 |  原数<br>
b = x &amp; -x        | 00000100 |  提取x的右起第一个“1”<br>
t = x + b         | 01100000 |  把x的右起第一个位于某个“1”左边的“0”变成“1”，并把它右边的那些“1”都变为“0”<br>
c = t &amp; -t        | 00100000 |  提取t的右起第一个“1”<br>
c / b             | 00001000 |  右移c中的那个“1”，其结果中最低位连续的“0”的个数正好是c和b中的“1”相差的距离<br>
m = (c/b &gt;&gt; 1) – 1| 00000011 |  在最低位产生数字“1”，其个数比上述的“距离”少1<br>
r = t | m         | 01100011 |  最终结果</p>
<p>    除去赋值，我们一共用了9个运算符。有可能用更少的运算么？</p>
<p><span id="more-813"></span><br>
    回想x^(x-1)的作用：保留右起第一个“1”，同时把右起连续的“0”也都变为“1”；直观地说，“…10000”异或“…01111”得到“11111”。巧妙就巧妙在，我可以用c=t^(t-1)同时完成定位右起第一个“1”和产生足够多的数字“1”两个步骤。我们的新算法省下了一个运算，只需要8个运算符：</p>
<p><code>b = x &amp; -x;<br>
t = x + b;<br>
c = t ^ (t-1);<br>
m = (c &gt;&gt; 2) / b;<br>
r = t | m; //最终结果</code></p>
<p>    同样地，我们做一个简单的说明：</p>
<p style="font-family:simsun">操作              | 样例     |  说明<br>
——————+———-+—————————-<br>
x                 | 01011100 |  原数<br>
b = x &amp; -x        | 00000100 |  提取x的右起第一个“1”<br>
t = x + b         | 01100000 |  把x的右起第一个位于某个“1”左边的“0”变成“1”，并把它右边的那些“1”都变为“0”<br>
c = t ^ (t-1)     | 00111111 |  提取t的右起第一个“1”，同时把后面的“0”也全变为“1”<br>
m = (c &gt;&gt; 2) / b  | 00000011 |  把c右移两位，再右移b所表示的位数<br>
r = t | m         | 01100011 |  最终结果</p>
<p> <br>
    现在，我们只用了8个运算符便完成了最初提到的一系列操作。这个数目还能再少吗？其实，这里面还有一个非常隐蔽的可改进之处：计算c时我们根本不需要用t来异或t-1，直接异或x就行了，它所产生的“1”的个数显然足够多。这样，我们又可以节省一个运算符了：</p>
<p><code>b = x &amp; -x;<br>
t = x + b;<br>
c = t ^ x;<br>
m = (c &gt;&gt; 2) / b;<br>
r = t | m; //最终结果</code></p>
<p style="font-family:simsun">操作              | 样例     |  说明<br>
——————+———-+—————————-<br>
x                 | 01011100 |  原数<br>
b = x &amp; -x        | 00000100 |  提取x的右起第一个“1”<br>
t = x + b         | 01100000 |  把x的右起第一个位于某个“1”左边的“0”变成“1”，并把它右边的那些“1”都变为“0”<br>
c = t ^ x         | 00111100 |  提取t的右起第一个“1”，同时把后面足够多的“0”也全变为“1”<br>
m = (c &gt;&gt; 2) / b  | 00000011 |  把c右移两位，再右移b所表示的位数<br>
r = t | m         | 01100011 |  最终结果</p>
<p>    这次，我们只用了7个运算就实现了题目的要求。还能继续优化吗？欢迎大家继续讨论！<br>
    来源：<a href="http://realtimecollisiondetection.net/blog/?p=78">http://realtimecollisiondetection.net/blog/?p=78</a></p>
			 ]]></content>
<pubDate>2008-09-24T12:25:12+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/813</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：尽可能用奇数次猜测完成猜数游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/830</link>
<content><![CDATA[ 
		<p>    现在，我在心里想一个不超过n的正整数t。你的任务是尽可能用奇数次猜测猜中这个数（你知道n是多少）。每次猜测后，我都会告诉你你所做的猜测是大了还是小了。你不能猜测已经被排除了的数（来消耗猜测次数），你的每次猜测都必须符合我原来给出的回答。你觉得，你获胜（奇数次猜中）的几率有多大？</p>
<p> <br>
    动态规划的几个类似的经典模型启发了我们：设a[m]表示采取最优策略后在m个数里猜奇数次猜中的概率，b[m]表示如果题目要求我们猜偶数次，那最优策略下有m个数时获胜的概率是多少。考虑现在我有m个数可以猜，我想在奇数次内猜中。现在我猜的是数字i。狗屎运最好时，我一次猜中直接就赢了，它的概率是1/m；有(i-1)/m的情况下我会得到“大了”的提示，这样的话我需要用偶数次猜测去猜前面那i-1个数；剩余的那(m-i)/m的情况中，我需要用偶数次猜测去猜m-i个数。因此，a[m] = Max {1/m + (i-1)/m * b[i-1] + (m-i)/m * b[m-i], 1≤i≤m} 。类似地，我们也可以得出b[m]的递推公式：b[m] = Max {(i-1)/m * a[i-1] + (m-i)/m * a[m-i], 1≤i≤m} 。<br>
    学习使用Mathematica确实是一件好事，你可以用Mathematica非常方便地描述出我们上面的两个递推公式，不需要自己去写那些冗长的程序了。<br>
<code>a[m_] := Max[Table[1/m + (i-1)/m * b[i-1] + (m-i)/m * b[m-i], {i, m}]]; a[0] := 0;<br>
b[m_] := Max[Table[(i-1)/m * a[i-1] + (m-i)/m * a[m-i], {i, m}]]; b[0] := 0;</code></p>
<p><span id="more-830"></span><br>
    让我们看一看结果怎么样：<br>
In[3]:= Table[a[i], {i, 12}]<br>
Out[3]= {1, 1/2, 2/3, 3/4, 3/5, 2/3, 5/7, 5/8, 2/3, 7/10, 7/11, 2/3}</p>
<p>In[4]:= Table[b[i], {i, 12}]<br>
Out[4]= {0, 1/2, 2/3, 1/2, 3/5, 2/3, 4/7, 5/8, 2/3, 3/5, 7/11, 2/3}</p>
<p>    猛然一看似乎看不出规律，但稍微把数列重新整理一下，规律一下子就出来了：<br>
a[i] = {1, 1/2, 2/3, 3/4, 3/5, 4/6, 5/7, 5/8, 6/9, 7/10, 7/11, 8/12}<br>
b[i] = {0, 1/2, 2/3, 2/4, 3/5, 4/6, 4/7, 5/8, 6/9, 6/10, 7/11, 8/12}</p>
<p>    我们开始猜想，是不是a[m] = [(2m+1)/3] / m，b[m] = [2m/3] / m啊？ （我这里用[]表示取下整）<br>
    只需要注意到[x]+[y] ≤ [x+y]始终成立，简单的数学归纳法可以立即得出这一结论：</p>
<p>a[m] = 1/m + (i-1)/m * b[i-1] + (m-i)/m * b[m-i]<br>
    = 1/m + (i-1)/m * [2(i-1)/3]/(i-1) + (m-i)/m * [2(m-i)/3]/(m-i)<br>
    = 1/m + [2(i-1)/3]/m + [2(m-i)/3]/m<br>
    = (1 + [2(i-1)/3] + [2(m-i)/3]) / m<br>
    ≤ [(2m+1)/3] / m</p>
<p>b[m] = (i-1)/m * a[i-1] + (m-i)/m * a[m-i]<br>
    = (i-1)/m * [(2i-1)/3]/(i-1) + (m-i)/m * [(2m-2i+1)/3]/(m-i)<br>
    = [(2i-1)/3]/m + [(2m-2i+1)/3]/m<br>
    = ([(2i-1)/3] + [(2m-2i+1)/3]) / m<br>
    ≤ [2m/3] / m</p>
<p>    什么情况下[x]+[y] ≤ [x+y]能够取到等号呢？显然，如果x和y中有一个恰为整数时，等号一定成立。当i=1时，a[m]一式可以取到等号，因为此时2(i-1)/3是一个整数；同样地，i=2时b[m]一式也能取等号，因为此时(2i-1)/3为整数。i的取值告诉了我们游戏的最佳策略：按顺序依次猜1, 3, 4, 6, 7, 9, …。这样的话，只有对方想的数恰好是3的倍数时才会以偶数次猜测结束游戏：如果对方想的数除以3余1，我们将在第奇数次说到这个数；如果对方想的数除以3余2，我们将在第偶数次得到一个“猜大了”的提示，然后再猜一次得到答案。采取这种策略，获胜的概率显然是[(2m+1)/3]/m，也即大约为2/3。</p>
			 ]]></content>
<pubDate>2008-09-28T11:43:58+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/830</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 用计算机自动作曲？Wolfram的手机铃声生成算法 ]]></title>
<link>http://www.matrix67.com/blog/archives/835</link>
<content><![CDATA[ 
		<p>    随着计算机科学的发展，越来越多的人开始思考，人工智能到底能强到什么地步？是否会有一天，我们可以完全通过计算机算法生成一部想象力丰富、情节跌宕起伏的科幻小说？“写作机器”或许离我们还有些遥远，不过用计算机来自动作曲已经有了一些像模像样的算法了。网友digiter分享了一个非常有意思的站点<a href="http://tones.wolfram.com">WolframTones</a>，它是Wolfram的一个有趣的项目：用程序算法随机生成一段动听的音乐（用来当手机铃声）。随便点击一个Style，系统会自动生成一段音乐，而且每次生成的都不一样。程序的算法简单得简直让人不敢相信：随机生成一组初始编码（第一列），然后按照一些简单的“生命游戏低维版”式的规则不断迭代生成出余下列的编码，再将这些编码与各音高一一对应起来。难以置信的是，这样简单的算法居然能产生出如此和谐动听的旋律，科学与艺术奇迹般地结合在了一起。</p>
<p>  <img alt="image placeholder" >
			 ]]></content>
<pubDate>2008-09-28T12:30:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/835</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 寻求真心话大冒险之猜数游戏的最佳策略 ]]></title>
<link>http://www.matrix67.com/blog/archives/844</link>
<content><![CDATA[ 
		<p>    去年的高中同学会上，吃完饭后大家就坐成一圈开始玩猜数游戏了。主持人自己在手机上输入一个1到，比如说500，的数，然后大家轮流猜数，并由主持人告之是猜大了还是猜小了。猜中了的那个人接受惩罚，真心话，或者大冒险，然后成为新的主持人。例如，我们班班长想了个数230。然后某男猜200，班长说“200到500”，意思就是200小了，以后的人只能猜200到500之间的数；接下来某女说“300”，美女班长说“200到300”；然后另一个MM猜250，班长回答“200到250”；然后就轮到我猜了，我说“230吧”，班长一脸坏笑把手机拿出来给大家看，说“哈哈，你猜中啦”。然后呢，我就和某个MM做了一件特别牛B的事情，细节呢就不在这里说了。<br>
    当天同学会结束后我赶回学校机房继续讲课。我提出了这么一个问题：如果我不想猜中的话，怎么决策最好？如果我想猜中的话，又该猜什么呢？这个博弈过程复杂就复杂在，这是由多个人参与的游戏，目的不是尽早猜中或者最晚猜中，最佳决策很可能既不是猜正中间也不是猜最大或最小；游戏是一圈一圈地循环进行，策略要视总人数和数字范围而定，并且很可能每个人居心各不相同。</p>
<p><span id="more-844"></span><br>
    写完<a href="http://www.matrix67.com/blog/archives/830">前面那篇日志</a>，我突然意识到：由于我们只能猜某个范围内的数，而该范围总是会变得越来越小，因此这个问题的状态有一个非常自然的拓扑序。我们立即想到，这是一个典型的动态规划模型：设f[i, j_1, j_2, k_1, k_2]表示还剩下i个数要猜，如果当前这个人（比如张三）希望用最少j_1次最多j_2次猜测结束游戏，而事实上在他的最优策略下猜测次数落在k_1到k_2范围内的概率。由于大家是围成一圈依次猜数，因此对j_1, j_2, k_1, k_2可能需要引入关于总人数同余的概念。枚举决策l，可能性分三种：有1/i的可能性直接猜中，有(l-1)/i的可能性猜大了，还有(i-l)/i的可能性猜小了。对于后两种情况，状态转移到下一个人（比如李四）在剩下的数中作出符合他（李四）的利益的最佳选择后，张三所期望的事实将会发生的概率。得出最佳决策后，还可以根据已有结果算出在张三的这种策略下实际上各种结局发生的概率。状态的具体定义和转移方程随着具体情况的变化而变化。例如，所有人都足够聪明并且都不想猜中，或者某些人将会像傻子一样的随机猜，或者男女各坐一个半圆两边想互相陷害，或者n-1个人合伙想整剩下的那个人，或者你反倒想猜中这个数从而有充分的借口猥亵一个多年来一直让你欲火焚身的漂亮MM。<br>
    这个动态规划的思路是不是正确的？在每一种具体问题下可以怎样简化和优化？程序运行的结果怎样呢？这个问题还可以怎样扩展？欢迎大家在下面留言谈谈自己的看法。</p>
			 ]]></content>
<pubDate>2008-09-30T17:47:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/844</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Count Like a Mathematician ]]></title>
<link>http://www.matrix67.com/blog/archives/846</link>
<content><![CDATA[ 
		<p>  <img alt="image placeholder" >
<p>来源：<a href="http://brownsharpie.courtneygibbons.org/?p=752">http://brownsharpie.courtneygibbons.org/?p=752</a></p>
			 ]]></content>
<pubDate>2008-10-01T22:27:38+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/846</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Code Golf：比比谁写的代码最短 ]]></title>
<link>http://www.matrix67.com/blog/archives/848</link>
<content><![CDATA[ 
		<p>    在网上闲逛时发现了这么一个有趣的网站。<a href="http://codegolf.com/">Code Golf</a>是一个另类的编程挑战网站。这个网站定期发布一个编程题目，你所提交的代码越短越好（keystroke越少越好，就像Golf一样要求尽可能少的stroke）。目前网站支持Perl、PHP、Python和Ruby语言。</p>
			 ]]></content>
<pubDate>2008-10-02T01:33:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/848</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 为什么平分圆面积的所有曲线中以直径最短？ ]]></title>
<link>http://www.matrix67.com/blog/archives/853</link>
<content><![CDATA[ 
		<p>    很多时候，我们往往不知道如何证明一些最简单、最基本的命题，即使证明本身也并不复杂。上个星期我去《数学思维方法与创新》这门通选课时，丘维声教授就提到了这个问题；在随堂统计中，知道三角函数和角公式证明方法的人出乎意料的少，而事实上高中的数学教材上印有这个公式的完整证明。<br>
    试着证明这个定理：给定一个圆，则端点在圆周上的平分圆面积的曲线以圆的直径最短。</p>
<p><span id="more-853"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>   <img alt="image placeholder" >
<p> <br>
    证明：随意作一条平分圆面积的曲线（图中的红色曲线），它的两个端点分别为A、B。作出平行于AB的直径CD，作出过A点的直径AB’。注意到B和B’关于CD对称。红色曲线不可能全部在CD的一侧（否则它围住的面积小于一个半圆，无法平分圆面积），因此它与直径CD必然有交点。找出一个交点E，则曲线长度大于AE+EB，它等于AE+EB’，而AE+EB’的长度大于直径AB’。</p>
			 ]]></content>
<pubDate>2008-10-04T01:48:38+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/853</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用最少的块移动实现逆序操作 ]]></title>
<link>http://www.matrix67.com/blog/archives/858</link>
<content><![CDATA[ 
		<p>    <a href="http://www.matrix67.com/blog/archives/730">上次那篇日志</a>发布之后，据说大家解题的热情相当高。Michael Brand告诉我说，他收到了很多来自中国的邮件，他感到非常高兴。在揭晓谜底之前，还是让我们先回顾一下题目：</p>
<blockquote><p>    对数列的一次“块移动”是指把一段数取出来插入到数列中的另一个地方（说穿了就是一次选择剪切粘贴的操作）。例如，数列1,4,5,6,2,3,7可以通过一次块移动完成排序（把456挪到3后面）。那么，想要让一个1到n的逆序排列n, n-1, …, 3, 2, 1变为顺序排列，最少需要多少次块移动？给出你的算法，并证明这个移动数目不能再少了。</p></blockquote>
<p>    需要指出的是，答案并不是n-1那么简单。当n=5时，只需要三步就可以搞定了：</p>
<blockquote><p> 5  4 [3  2] 1<br>
 3  2  5 [4  1]<br>
[3  4] 1  2  5<br>
 1  2  3  4  5</p></blockquote>
<p><span id="more-858"></span></p>
<p>    事实上，给出1到n的逆序排列，最少需要Ceil[(n+1)/2]次块移动就可以完成排序（除了n=1或n=2，Ceil表示取上整）。当n为奇数时，一个满足要求的算法是：每一次把数字n后面那一段的正中间两个元素拿出来，插入到数字n前面那一段数的正中间。当数字n后面的数被移动完了后，把它前面n-1个数左右两半对换一下就行了。例如，当n=7时：</p>
<blockquote><p> 7  6  5 [4  3] 2  1<br>
 4  3  7  6 [5  2] 1<br>
 4  5  2  3  7 [6  1]<br>
[4  5  6] 1  2  3  7<br>
 1  2  3  4  5  6  7</p></blockquote>
<p>    算法的移动步数显然为(n+1)/2，其正确性可以用数学归纳法说明，这里不再详细叙述了。<br>
    当n为偶数时，只需要用n/2次操作把前面n-1个元素排好序，再花一次操作把末一个元素移动到最前面，加起来正好Ceil[(n+1)/2]次操作。下面我们证明，移动次数不可能比Ceil[(n+1)/2]更少。<br>
    对于数列中相邻的两个数，如果前面那个数比后面的大，我们就把它们俩称作一组“逆序相邻数”。初始时，数列中有n-1个这样的逆序相邻数，我们的目标就是通过块移动把这个数目减少到0。整个证明过程的关键就在于，一次块移动操作最多只能消除两个逆序相邻数。</p>
<p>原数列： **aA–Bb***CD****<br>
新数列： **ab***CA–BD****</p>
<p>    假如我们把块A–B插入到CD中间。注意到，相邻数发生变动的地方只有三处。要想同时消除三个逆序相邻数，只有一种可能：原数列中a&gt;A, B&gt;b, C&gt;D，同时新数列中的a&lt;b, C&lt;A, B&lt;D。这将导出一个很荒谬的结论：A &lt; a &lt; b &lt; B &lt; D &lt; C &lt; A。这告诉我们，一次块移动同时消除三个逆序相邻数是不可能的，它最多只能消除两个逆序相邻数。另外，容易看出，第一次移动只能消除一个逆序的相邻数，因为初始时原数列完全逆序，即有a &gt; A &gt; B &gt; b &gt; C &gt; D，在新数列中只有C&lt;A成立。对称地，最后一次移动也只可能消除一个逆序相邻数，因为新数列中a &lt; b &lt; C &lt; A &lt; B &lt; D，只有B&gt;b是成立的。<br>
    于是我们得知，k次块移动最多消除1+2*(k-2)+1个逆序相邻数。为了消除n-1个逆序相邻数，我们有1+2*(k-2)+1 &gt;= n-1，整理得k&gt;=(n+1)/2。</p>
<p> <br>
题目来源：<a href="http://www.brand.site.co.il/riddles/200809q.html">http://www.brand.site.co.il/riddles/200809q.html</a></p>
			 ]]></content>
<pubDate>2008-10-04T03:00:36+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/858</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Original Ideas ]]></title>
<link>http://www.matrix67.com/blog/archives/866</link>
<content><![CDATA[ 
		<p>    首先呢，小小的庆祝一下我的订阅数终于过千了。真可惜，昨天的订阅数1023，差一点就是1024了……<br>
    最近不知道为什么，思维特别活跃，脑子里经常蹦出一些牛B的想法。先声明，这篇文章为matrix67.com原创；谁要是用了里面的东西而没署名，或者拿去用作商业用途的话……Alan Shore的模样将会像幽灵一样缠绕着你，出现在你的每一个恶梦中。</p>
<p><strong>关于输入法：为什么能打出“推倒”却打不出“推不倒”？</strong></p>
<p>    为什么没有输入法可以依据语法规则生成更多词组？例如，我可以把“睡觉”、“理发”、“洗澡”、“打球”、“吃饭”一类词做一个标记，那么在里面插入“了”、“过”等词也可以直接视为一个词（这些词同样很常用）。这样的话，词库容量大大扩充了，但这种方法本身并不耗费太多的空间和时间。<br>
    或者有输入法已经开始这么做了？大家的输入法中，这些词语可以直接打出来么？</p>
<blockquote><p>睡觉 睡了觉 睡过觉 睡个觉 睡完觉 睡不成觉<br>
理发 理了发 理过发 理个发 理完发 理不成发<br>
洗澡 洗了澡 洗过澡 洗个澡 洗完澡 洗不成澡<br>
打球 打了球 打过球 打个球 打完球 打不成球<br>
吃饭 吃了饭 吃过饭 吃个饭 吃完饭 吃不成饭</p></blockquote>
<p>    事实上，这种结构能够派生出来的短语比你想像的更多，如“睡一睡觉”、“睡不睡觉”、“睡了一小时的觉”、“睡不完的觉”、“你睡你的觉去”、“觉也不睡”、“觉不好好睡”、”觉已经睡过了“等等；同时，这一类词的数量也相当多，漱口刷牙洗脸穿衣服穿鞋拿钥匙锁门开车上班写程序玩游戏下班回家做饭洗衣服上床做爱全是这一类词。因此词类标记的价值显得更大了。<br>
    又如，结果补语中间可以插入“不”、“得”变成可能补语。奇怪的是，为什么绝大多数输入法里都有“推倒”这个词，却没有“推不倒”这个词？这明明是在词库里做几个标记就能办到的事情。</p>
<blockquote><p>推倒 推得倒 推不倒<br>
吃完 吃得完 吃不完<br>
学会 学得会 学不会<br>
长高 长得高 长不高<br>
飞起来 飞得起来 飞不起来<br>
走进去 走得进去 走不进去</p></blockquote>
<p><span id="more-866"></span><br>
<strong>5×5图灵测试</strong></p>
<p>    组织这么一个有趣的图灵测试。每一组测试需要在两个从没见过面的人之间进行。A在一个5×5的矩阵中进行黑白涂色，即创作一个25像素的黑白图画作为输入数据；然后B和另外四个计算机给出另一个5×5的01矩阵作为回应。A从中选出最有可能是B作出的回应。A、B两人的任务就是，在不经过任何交流的情况下，能够找到一种确认对方是人的方法。<br>
    例如，A输入下面这个<br>
<code>#.###<br>
#...#<br>
#.###<br>
#.#..<br>
#.###</code></p>
<p>    并从5个回复中选出了这一个：<br>
<code>.###.<br>
...#.<br>
.###.<br>
...#.<br>
.###.</code></p>
<p>    因为他相信，B准确地看出了A的输入其实是“1”、“2”两个数字，并绘出“3”作为回应。当然，A的选择不一定是正确的。有可能那个B是一个笨蛋，它没看懂A给它发的是什么；同时，某个超强的AI程序里或许已经预先考虑到了数字和字母的各种可能的形状。<br>
    做一个名为5x5turingtest.com的web 2.0网站可能会非常有趣。每个人都可以参与测试（在线配对），同时每个人也都可以提交自己的AI。网站将定期评选出最强的AI（混过测试的几率最大的AI）。</p>
<p> <br>
<strong>01交流</strong></p>
<blockquote><p>    尽管如此，大众还是不屈不挠地将这场战争——或者说游戏——继续下去，他们挑选健康词汇列表中的合法字眼来表达不合法的意思：两个连续的“稳定”意思就是“反对”，“稳定”加“繁荣昌盛”则暗示“屏蔽”。美国政府不得不对这一动向保持着警惕，并日复一日地将更多的词汇从健康词汇列表里删掉，禁止大众使用。<br>
    当然，这场战争会持续下去的。只要世界上还存在着两个不同的字或者词组，那么就可以继续自由交流。</p></blockquote>
<p>    事实上真是如此么？人们真的可以用二进制进行交流吗？不同的文化之间是否能建立一种可用于沟通的二进制语言？与上面所说的图灵测试一样，我们可以做一个长期的、大规模的试验，也可以借助互联网来进行广泛的在线测试。</p>
<p> <br>
<strong>绝对匿名的统计</strong></p>
<p>    做一个投票统计页面，请来访者在符合条件的选项前打勾。该网站保证绝对的匿名。提交后显示每一个选项有百分之几的人选。选项涉及到的都是极度隐私的但并不罕见，甚至有时候备受社会关注的事情：例如“我是同性恋/双性恋”、“我偷过东西”、“我杀过人”、“我每天至少手淫一次”、“我背叛过我的男友/女友”、“我有异装癖”、“我被强奸过”等等。这个网站的价值在于：给人们一次倾诉自己心里积压已久的秘密的机会，同时从统计结果中看到自己并不孤独，从而消除一些罪恶、恐惧和不安的感觉。<br>
    如果你觉得“绝对匿名”不可能保证的话……不妨用<a href="http://www.matrix67.com/blog/archives/572">这种方法</a>。</p>
<p> <br>
<strong>小说：《递归》</strong></p>
<p>    我想写这么一篇小说，小说的名字叫做《递归》。小说的主人公是一个很现代的电影导演，小说将讲述他的一些划时代的创作将给社会带来怎样的影响。小说的主人公准备制作一部有史以来最庞大的、引入角色最多的电影。这是一部关于生活的电影，电影以一个网络游戏设计人的视角来展现生活的各个方面。片中所提到的游戏是一个有如Second Life一样的大型网络游戏，游戏开发者在游戏开发和现实世界中存在一个有趣的互动：他将在游戏设计过程中体会到人生的复杂性，同时他也会把自己在生活中的体会写进游戏里。他有一个朋友是一位出色的漫画家，他在这位漫画家那里学到了不少东西，于是决定把漫画家这一人物编写到游戏中去。在虚拟世界中，没有什么事情是做不到的。游戏中的漫画家是整个游戏的一大亮点，因为这位漫画家将做出一件在现实生活中难以想象的事情：他将画一张巨幅的漫画，这幅漫画的纸张有好几千米长，从左到右画出来的就是一个人一生的故事。这幅漫画已经完成了大约1/5。在刚刚画完的那格图画中，一个人正孤独地坐在寝室的一角，面前是一个黑不溜秋的IBM R51e，手指在键盘上快速地敲打着一篇名为《递归》的小说的简要提纲。</p>
<p>    （事实上，我觉得上述这段文字本身已经是这个故事最好的表现手法了）</p>
<p> <br>
<strong>加入身份验证的微型Blog</strong></p>
<p>    Blog用户可以设置若干个用于身份验证的问题，并准备好相应的答案。每一位来访者每一次进入该页面时都需要回答一道随机抽取出来的问题，答案正确才能进入此微型Blog。有些网友应该知道，我自己曾经在网站首页上做过类似的事情。</p>
<p> <br>
<strong>KTV：为什么没有Shuffle功能？</strong></p>
<p>    经常会出现一个人点了6首歌，然后换另一个人去点它个4首，第三个人又在后面接着点5首歌。此时，队列里的歌就变成了AAAAAABBBBCCCCC，这显然不科学。为什么没有一个按键可以把队列里的歌随机打乱顺序呢？这样就避免了老是一个人唱的情况。</p>
<p> <br>
<strong>公钥加密术</strong></p>
<p>    有没有什么加密算法，即使你知道怎么加密也不知道如何解密？众所周知，RSA算法就是这样一种可以公开加密钥匙，人人都能进行加密操作，但只有持有解密钥匙的人才能算出明文的一种加密算法，其原理就是：将两个大质数乘起来很容易，但反过来分解质因数却没有什么简便快速的算法。其它那些比较困难的问题能否运用到公钥加密术呢？比如，是否有什么公钥加密术利用了同构图构造容易判断难的性质，或者Hamilton图生成容易判断难等等。</p>
			 ]]></content>
<pubDate>2008-10-06T11:40:27+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/866</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 随机洗牌：哪一种算法是正确的？ ]]></title>
<link>http://www.matrix67.com/blog/archives/879</link>
<content><![CDATA[ 
		<p>    记得当年搞NOIp时，我犯过一个相当严重的错误：错误地把Floyd算法的i, j, k三层循环的位置顺序搞颠倒了。直到准备省选时我才突然意识到，Floyd算法应该最先枚举用于松驰操作的那个“中间变量”k，表示只经过从1到k的顶点的最短路；而我却一直习惯性地以为i, j, k应该顺次枚举。令人惊讶的是，这个错误跟了我那么久我居然从来都没有注意到过。后来，我发现有我这种经历的人不止一个。惯性思维很可能会让你接受一些明显错误的算法，并且让你用得坦坦荡荡，一辈子也发觉不了。<br>
    假使你需要把一个数组随机打乱顺序进行重排。你需要保证重排后的结果是概率均等、完全随机的。下面两种算法哪一种是正确的？其中，random(a,b)函数用于返回一个从a到b（包括a和b）的随机整数。</p>
<p>1. for i:=1 to n do swap(a[i], a[random(1,n)]);<br>
2. for i:=1 to n do swap(a[i], a[random(i,n)]);</p>
<p><span id="more-879"></span><br>
    如果不仔细思考的话，绝大多数人会认为第一个算法才是真正随机的，因为它的操作“更对称”，保证了概率均等。但静下心来仔细思考，你会发现第二种算法才是真正满足随机性的。为了证明这一点，只需要注意到算法的本质是“随机确定a[1]的值，然后递归地对后n-1位进行操作”，用数学归纳法即可轻易说明算法的正确性。而事实上，这段程序一共将会产生n*(n-1)*(n-2)*…*1种等可能的情况，它们正好与1至n的n!种排列一一对应。<br>
     有人会问，那第一种算法为什么就错了呢？看它的样子多么对称美观啊……且慢，我还没说第一种算法是错的哦！虽然第一种算法将产生比第二种算法更多的可能性，会导致一些重复的数列，但完全有可能每种数列重复了相同的次数，概率仍然是均等的。事实上，更有可能发生的是，这两种算法都是正确的，不过相比之下呢第一种算法显得更加对称美观一些。为此，我们需要说明，第一种算法产生的所有情况均等地分成了n!个等价的结果。显然，这个算法将会产生n^n种情况，而我们的排列一共有n!个，因此n^n必须能够被n!整除才行（否则就不能均等地分布了）。但是，n!里含有所有不超过n的质数，而n^n里却只有n的那几个质因子。这表明要想n^n能被n!整除，n的质因子中必须含有所有不超过n的质数。这个结论看上去相当荒唐，反例遍地都是，并且直觉上告诉我们对于所有大于2的n这都是不成立的。为了证明这一点，只需要注意到2是质数，并且根据Bertrand-Chebyshev定理，在n/2和n之间一定还有一个质数。这两个质数的乘积已经大于n了。搞了半天，第一种看似对称而美观的算法居然是错的！</p>
<p>参考资料：<a href="http://adrianquark.blogspot.com/2008/09/how-to-shuffle-array-correctly.html">http://adrianquark.blogspot.com/2008/09/how-to-shuffle-array-correctly.html</a></p>
			 ]]></content>
<pubDate>2008-10-07T23:17:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/879</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：环面上的七色定理 ]]></title>
<link>http://www.matrix67.com/blog/archives/890</link>
<content><![CDATA[ 
		<p>    有时候，一个看似更加复杂的问题反而有一个更简单的解答。<br>
    四色问题是说，对一个平面地图进行染色，要想用不同的颜色来区别相邻的区域，最少需要多少种颜色。在很长一段时间里，人们猜想，只要四种颜色就足够了；但这个“四色猜想”却怎么也证不出来。直到上世纪70年代，“四色猜想”才在计算机的帮助下获得证明。在《从一到无穷大》一书中，作者提到了这样一个有趣的事实：平面上的四色问题一直是一个相当复杂的难题，然而有意思的是，在环面上的染色问题却只需要短短十几行文字就能得出一个完美的结论。下面我们来说明，给一个游泳圈上任意划分出来的区域进行染色，为了使相邻区域不同色，只需要7种颜色就够了。<br>
    为了证明这一点，我们只需要说明，在一个环面图中总能找到一块区域，它的邻域不超过6块。如果真是这样的话，余下的部分用数学归纳法就直接证到了：对于一个有n个区域的图，我们找出它的一个邻域数量不超过6的区域，然后把这块区域缩小为一个点，使整个图的区域个数减少到n-1。按照我们的数学归纳，这个有n-1个区域的图是可以7染色的；并且显然地，把第n个区域添加回去后所产生的图仍然可以7染色，因为我的邻域不超过6个，我总能找一个和这些邻域都不一样的颜色。<br>
    现在的问题就是，为什么总存在邻域数量不超过6的区域呢？注意到在环面上，有V+F-E=0，其中V表示顶点数，F表示区域数，E表示边的总条数。注意到每个顶点都发射出了至少三条边，即所有顶点引出的边数至少为3V；但每条边都被重复计算了一次（因为一条边有两个端点），因此3V/2≤E，即3V≤2E。代入V+F-E=0，得到E≤3F。假设每个区域都有7个或7个以上的邻域，那么它们将产生至少7F条边；但每条边都被重复计算了一次（因为每条边都为两块区域共享），因此7F/2≤E，即7F≤2E。于是，2E≥7F&gt;6F≥2E，矛盾。</p>
<p><span id="more-890"></span><br>
    事实上，7种颜色是必需的。构造一个至少需要7种颜色才能染色的环面是一件非常有趣的事情。其实，只要你想到了下面这一点，构造这样的环面是非常容易的：把游泳圈剪断并拉成一根空心的管子，再从中间破开来摊成一个长方形，所谓的“环面”实际上就是一个特殊的矩形平面区域——它的上下和左右是“通的”。下面这个图是从Wikipedia上找来的，它告诉了你如何制作一个7块区域两两相邻的环面。</p>
<p>   <img alt="image placeholder" >
			 ]]></content>
<pubDate>2008-10-10T03:31:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/890</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 停机问题、Chaitin常数与万能证明方法 ]]></title>
<link>http://www.matrix67.com/blog/archives/901</link>
<content><![CDATA[ 
		<p>    高中一次英语课上，英语老师问我们，如果你有机会乘坐时光机回到过去，你想利用这次机会来干啥。“人上一百，形形色色”这句老话得到了完美的验证。什么“回去看看四大美女”呀、“看看金字塔是怎么建造的”呀、“回到三年前的那个风雨交加的夜晚握住她的手深情地告诉她其实我不想让你离开我你知道你走了之后我有多么痛苦吗”之类的东西，各种稀奇古怪的想法都被我们说了个遍。我还记得当时我说的啥——一个无比实用的雕虫小技。我说，我就想回到一个星期前，然后去买彩票。发明一个新东西并不是关键，关键是你怎么去使用它。<br>
    最奇怪的幻想总是来自于最奇怪的需求。大家有过这种经历吗？看到自己写的程序运行了半天都还没有任何结果，于是开始纠结，到底是再等一会儿呢还是强行终止了检查一下看程序写错没；犹豫了半天决定杀掉进程后，检查了半天又发现程序没有写错。于是开始怨念，早知道程序没有死循环的话刚才就多等一会儿了。此时，你会突然开始幻想，有没有什么编译器能够事先告诉你你的程序是否会无限运行下去？虽然编程判断一段代码是否会无限执行下去很可能会相当的困难，但我们仍然不排除会有某个天才程序员想出了一个比三角恋爱更加复杂的算法，花它五年的功夫为他心爱的编译器写出了这样一个强大的插件。为什么不可能呢？这个东西看上去似乎比时光旅行机更现实一些。或许我们会在某个科幻电影中看到，一个程序员在黑黢黢的屏幕上输入了几个数，敲了一下回车，然后屏幕上立即用高亮加粗字体显示“警告：该输入数据会导致程序无限运行下去，确定执行？(Y/N)”。如果有一天，这一切真的成为了现实，那么你能利用这个玩意儿来做些什么实用的、有价值的事情？如果我说你能靠这玩意儿发大财你相信么？</p>
<p><span id="more-901"></span><br>
    永远不要说什么“看看当年我NOIp第二题的第四个数据是不是真的因为死循环了才超时的”之类的东西。如果是我的话，我一定会用点别人想不到的雕虫小技干出一番惊天动地的大事。我上来就先写一个Goldbach猜想的验证程序。我写一个程序从小到大枚举所有的偶数，看是不是有两个质数加起来等于它：如果找到了，继续枚举下一个偶数；否则输出这个反例并结束程序。然后我编译它。这个编译器不是可以判断我这程序能否终止么？如果编译器说我这个程序会无限执行下去的话……我不就相当于把Goldbach猜想证到了吗？或者，编译器说程序最终会终止，那Goldbach猜想不就直接被推翻了吗？反正，那个证Goldbach猜想的奖金肯定是我的了。拿下Goldbach猜想的奖金后，我接着写程序看是不是真的有无穷多个孪生素数，顺便利用前面那几个程序把Mersenne素数是否无穷多的问题也给解决了。写个证明Riemann假设的程序似乎有点麻烦，但是写一个验证Collatz猜想（3x+1问题）的程序只是一两分钟的事情。永远不要怕没有事情做，大不了把Hilbert的23个问题或者什么千禧年七大数学难题之类的全部翻出来，或者直接去Wikipedia的<a href="http://en.wikipedia.org/wiki/Unsolved_problems_in_mathematics">Unsolved Problems in Mathematics</a>词条，看看哪些命题是离散的，写几个程序就可以把它们统统解决了……</p>
<p>    还是从幻想中清醒过来吧，能判断一个程序能否无限运行下去的程序是否真的存在我们还不知道呢。不过仔细回想一下上面的讨论，你会意识到这种程序的存在该是多么的不可思议啊。即使这样的程序真的存在，实现它的难度也绝对不亚于解决上述的任何一个数学猜想，不然的话大家都转而向这个神奇的“万能证明方法”进攻了。<br>
    而事实上，科学家们已经从理论上证明了，这种程序是永远不可能实现出来的。这就是著名的停机问题(The Halting Problem)，它是一个不可解问题。停机问题不可解的证明并不复杂，并且非常有趣。你可以在<a href="http://www.matrix67.com/blog/archives/55">这里</a>看到整个证明过程。我们刚才那些美好的梦想被这一个简短的证明摔成了碎片。</p>
<p>    永远不要小瞧人类的想象力。对“万能证明方法”的进攻并没有就此结束。虽然判断一段代码运行后是否会终止的程序是不存在的，但这个“万能证明法”的思路是非常值得借鉴的。下面，我来提出一个绝对存在的东西，它同样可以用于我们的“程序证明”。它就是指定的编程语言中任意一段代码运行后最终会停止下来的概率。假如说这种编程语言有p种字符（包括代码结束的符号共p+1种），长度为n的代码中有T(n)个不会无限运行下去，那么我们定义这个概率就是Σ(n=1..∞) T(n)/(p+1)^n。考虑两种极端的情况：如果所有代码都永不终止，则这个概率值为0；如果所有代码运行后最终都能停下来（包括语法错误根本不能编译的情况），则概率为Σ(n=1..∞) p^(n-1)/(p+1)^n，其中p^(n-1)表示除去那个结束符号后所有可能的n-1位代码。利用等比数列求和公式容易得出这个值等于1。当然，在实际情况下，这个概率值是一个介于0和1之间的确定的数。<br>
    有了这个概率之后，我们就无敌了！！我们故技重施，写一个Goldbach猜想验证程序。假如这个程序的长度为L。注意到Σ(n=k+1..∞) p^(n-1)/(p+1)^n=(p/(p+1))^k，当k足够大时必然有某个时刻(p/(p+1))^k比1/(p+1)^L小。我们再用一个程序来生成所有可能的长度不超过k的代码（这让我想起了《诗云》中的“啊啊啊啊啊，啊啊啊啊啊”）。然后，壮观的一幕发生了：我们同时运行所有这Σ(n=1..k) p^(n-1)个程序！这里面，有些程序根本就不能跑（编译都通不过），有些程序运行后闪一下就退出来了，有些程序可能得等个好几天才能退出；当然也有将要无限运行下去的程序。不过可以肯定的是，受到上面那个概率值的限制，最终停止下来的程序是有一个上限的。随着越来越多的程序停止下来，总有某个时刻会达到这样一种状态：终止的程序所占的比例与我们那个概率值的误差不到1/(p+1)^L（因为我们没有考虑的那些代码即使全部都会终止也只占(p/(p+1))^k的分量，而k值的选择保证了这个分量不足1/(p+1)^L），此时只要再有一个长度不超过L的程序终止，实际比例（将增加至少1/(p+1)^L）就超过那个概率了。这时，我们就可以肯定，到时候还没有停止的程序必然将无限运行下去。如果届时我们的Goldbach猜想还没找出反例，这就意味着这个程序永远找不出反例了，Goldbach猜想也就得到了证实。显然，这种算法并不要求我们所提到的概率值要达到无限精确，我们只需要概率公式的前k项的和就足够了。<br>
    或许，这个工程确实有点庞大，需要耗费大量的时间和金钱。不过，为了证明那么多悬而未解的数学之谜，投入再多的时间和资金也值得啊！我们还可以采取SETI@home的办法，邀请全球的计算机一起来参与计算啊！那么，为什么我们不这样做呢？真实的情况到底如何呢？<br>
    这或许会有些不合常理：我们上面提到的那个概率值是一个“不可计算数字”(uncomputable number)。它是一个可以严格定义出来，并且也确实存在的数，但我们永远无法计算出它的值（即不存在某种算法能够给出小数点后任意多位的数字）。这个概率是有一个名字的，它叫做Chaitin常数，它是以数学家和计算机科学家Gregory Chaitin的名字命名的。我们可以证明出，Chaitin常数确实是不可计算的。不妨反过来想，假如我们有一个算法能够给出小数点后任意多位的值，那么我们就能用上面那种“等足够多的程序终止”的方法判断出一个代码长为n的程序是否会无限运行下去，这相当于我们有了一个解决停机问题的算法；但我们前面已经证明了，停机问题是不可解的，因此我们可以肯定地说，想要算出Chaitin常数一定是办不到的。</p>
			 ]]></content>
<pubDate>2008-10-12T01:45:19+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/901</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：如何用集合来定义有序对 ]]></title>
<link>http://www.matrix67.com/blog/archives/910</link>
<content><![CDATA[ 
		<p>    上周六的离散数学课上，我学到了一个比较有趣的东西：有序对的定义。在引入有序对之前，所有的东西都是以集合为基础的；因此当我们讨论到有序对的概念时，我们只能用集合的语言去描述它。如何用集合来叙述有序对&lt;a,b&gt;，使得&lt;a,b&gt;=&lt;c,d&gt;当且仅当a=c且b=d呢？集合本身的无序性给我们带来了相当大的困难。比如，大多数人可能会想到&lt;a,b&gt;:={a,{b}}。可惜这种定义方法是错误的。考虑集合{ {1}, {2} }，则它既可以是&lt;{1},2&gt;，又可以表示&lt;{2},1&gt;。那么定义&lt;a,b&gt;:={a,{b,Ø}}呢？这样也不行，道理是一样的，{{1,Ø}, {2,Ø}}既可能是&lt;{1,Ø},2&gt;，又可能是&lt;{2,Ø},1&gt;。那么，到底应该怎样定义有序对呢？如何定义最简单呢？</p>
<p><span id="more-910"></span></p>
<p>    几经尝试后我们发现，我们得用处于同一“层”的、元素个数不对称的集合来区别有序对中的两个元素。1914年，Norbert Wiener给出了有序对的第一个集合定义：&lt;a,b&gt; := { {{a},Ø}, {{b}} }，这从根本上区别出了a和b的顺序。目前最常用的定义是由Kuratowski给出的：&lt;a,b&gt;:={{a},{a,b}}。下面我们来证明一下，这种定义满足我们的要求：&lt;a,b&gt;=&lt;c,d&gt;当且仅当a=c且b=d。当a=c且b=d时，由条件和定义有{{a},{a,b}}={{c},{c,d}}，于是充分性显然成立。下面我们只需要说明必要性：若&lt;a,b&gt;=&lt;c,d&gt;，则一定能推出a=c以及b=d。<br>
    由我们的定义，&lt;a,b&gt;=&lt;c,d&gt;可以写作{{a},{a,b}}={{c},{c,d}}，则∩{{a},{a,b}}=∩{{c},{c,d}}，即{a}={c}。我们立即得到，a和c是相等的。于是，我们有&lt;a,b&gt;=&lt;a,d&gt;，即{{a},{a,b}}={{a},{a,d}}。两边同时取并集，有∪{{a},{a,b}}=∪{{a},{a,d}}，整理出来就是{a,b}={a,d}。好了，现在如果a≠b，注意到b是属于{a,d}的，那么只可能是b=d；如果a=b呢，那么{a,b}={a,d}={a}，则a、b、c、d都相等，结论依然成立。</p>
<p>    大家自然会想到，上述结论能否扩展到多元的有序组呢？换句话说，我们能不能照葫芦画瓢，定义&lt;a,b,c&gt;:={{a},{a,b},{a,b,c}}呢？出人意料的是，这种定义是错误的，这将导致&lt;x,x,y&gt;=&lt;x,y,y&gt;之类的荒谬的结论。那么我们又该如何定义三元有序组呢？其实很简单，定义&lt;a,b,c&gt;:=&lt;a,&lt;b,c&gt;&gt;就是了。本文主要参考了Wikipedia上的<a href="http://en.wikipedia.org/wiki/Ordered_pair">相关词条</a>，也参考了<a href="http://www.charlesgao.com/?p=109">Charlesgao</a>上的一些内容。</p>
<p>    最近看到的另一些有趣的东西都来自于各位网友。网友multiple1902发布了一个原创的<a href="http://www.multiple1902.cn/blog/article.asp?id=13">数学公式定理速查表</a>，比起<a href="http://www.matrix67.com/blog/archives/281">这个</a>来要精简实用一些，更适合高中使用。<br>
    好友leimiaos分享了一道（可能比较火星的）C语言趣题：不用比较符（&gt;, int max(int x,int y)<br>
{<br>
    int number[2]={x,y};<br>
    unsigned __int64 z=(__int64)x-y;<br>
    return number[z&gt;&gt;63];<br>
} </p>
<p>    很高兴又认识了一个搞ACM/ICPC的<a href="http://hi.baidu.com/5l2_">MM</a>。在这里向她打个招呼。</p>
			 ]]></content>
<pubDate>2008-10-16T00:09:06+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/910</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Typography Art: Mathematical Induction ]]></title>
<link>http://www.matrix67.com/blog/archives/920</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>挖到一张好图，做成海报贴在墙上会很酷。<br>
来源：<a href="http://fiveless.deviantart.com/art/mathematical-induction-56305755">http://fiveless.deviantart.com/art/mathematical-induction-56305755</a><br>
我很喜欢Typography Art。最喜欢<a href="http://www.youtube.com/watch?v=uuiKJ0rRTAo">这个</a>。</p>
			 ]]></content>
<pubDate>2008-10-16T23:33:35+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/920</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣闻：世界上最大的数是多少？ ]]></title>
<link>http://www.matrix67.com/blog/archives/925</link>
<content><![CDATA[ 
		<p>    你能想到的最大的数是多少？我电脑里A片的字节数？人体的细胞个数？整个地球的质量？宇宙间所有原子的个数？当然，在数学研究中，数学家们很可能会创造出一些比这些数都大的数。<br>
    1938年，数学家Edward Kasner的外甥发明了一个表示10^100的单词googol，这个数已经超过了宇宙中所有原子的个数。Pólya曾经猜想，小于等于n的正整数中，质因子个数为奇数的数不少于质因子个数为偶的数；1958年数学家C. B. Haselgrove首先给出了一个长达361位的反例。上个月，人们找到了一个新的Mersenne素数2^43112609-1，它一共有12978189位。1955年，数学家Stanley Skewes证明在不超过10^(10^(10^963))的范围内存在x满足π(x) &gt; li(x)，其中π(x)表示不超过x的素数有多少个，而li(x)则是dt/ln(t)从0到x的定积分。</p>
<p><span id="more-925"></span><br>
    根据一项吉尼斯世界纪录，目前人类所创造的具有实际意义的最大的数是Graham数。<br>
    考虑这样一个问题：给定一个n维超立方体，连接这2^n个顶点所产生的所有点对，得到一个顶点数为2^n的完全图。对所有边进行红蓝二染色。是否可能找到某个n，使得在任意染色方案中总存在一个完全子图K_4，它的所有边都是一种颜色，并且四个顶点共面？我们通常把满足要求的最小的n记为N*。1971年，Graham和Rothschild证明了满足要求的n是存在的，并且给出N*的一个上界：N*&lt;=g(64)，其中g(1)=3↑↑↑↑3，并且g(n)=3↑↑...↑3（共g(n-1)个“↑”）。“↑”是Knuth发明的一种数学符号，简单地说，它的定义如下：

    <img alt="image placeholder" >
<p>    注意并列的“↑”要从右至左计算。因此，m↑n就表示m^n，而m↑↑3则表示m↑m↑m，即m^(m^m)。<br>
    通常把这个g(64)叫做Graham数。Graham数有多大呢？这恐怕只能靠诸位想象了。上面这句话没有任何修辞手法，因为我们真的无法用任何现有的语言直观地说明这个数的大小。即使说它有多少位，或者它的位数有多少位，或者我们需要在前面那句话里嵌套进多少个“的位数”（相当于用n^n^n^…^n的形式来表示），也不能言出这个数的大小。</p>
			 ]]></content>
<pubDate>2008-10-17T18:05:36+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/925</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 统计数据、相关性与因果关系 ]]></title>
<link>http://www.matrix67.com/blog/archives/930</link>
<content><![CDATA[ 
		<p>    在去年10月份的数学文化节期间，我去听了好几次讲座，其中<a href="http://www.matrix67.com/blog/archives/336">有一些讲的相当精彩</a>。时间过得好快，转眼间又是一年了，如果不是Wind牛发短信问我去不去听讲座，我估计今年数学文化节过了都还想不起这档子事。于是和Wind牛跑去二教309，听了一场叫做《从数据中挖掘因果关系》的讲座。这个题目是很有趣的：数据本身并不说谎，难就难在我们如何从中挖掘出正确的信息。当我们讨论数据时，我们讲的最多的是数据的相关性，而我们希望得到的则是事件之间的因果联系；但事实往往是复杂的，统计数据有相关性并不意味着两个事件具有因果联系，而具有因果联系的两件事从统计数据上看有时也并不相关。<br>
    对于前者，最简单的例子就是公鸡打鸣与太阳升起：公鸡打鸣与太阳升起总是同时发生，但这并不表示把全世界所有的公鸡都杀光了后太阳就升不起来了。统计发现，手指头越黄的人，得肺癌的比例越大。但事实上，手指的颜色和得肺癌的几率之间显然没有直接的因果联系。那么为什么统计数据会显示出相关性呢？这是因为手指黄和肺癌都是由吸烟造成的，由此造成了这两者之间产生了虚假的相关性。我们还可以质疑：根据同样的道理，我们又如何能从统计数据中得出吸烟会致癌的结论呢？要想知道吸烟与癌症之间究竟是否有因果联系的话，方法很简单：找一群人随机分成两组，规定一组抽烟一组不抽烟，过它十几年再把这一拨人找回来，数一数看是不是抽烟的那一组人患肺癌的更多一些。这个实验方法本身是无可挑剔的，但它太不道德了，因此我们只能考虑用自然观察法：选择一些本来都不吸烟的健康人进行跟踪观察，然后呢，过段时间这一拨人里总会出现一些失意了堕落了犯上烟瘾的人，于是随着时间的流逝这帮人自然而然地分成了可供统计观察的两组人。注意，这里“是否吸烟”这一变量并不是随机化得来的，它并没有经过人为的干预，而是自然区分出来的。这是一个致命的缺陷！统计结果表明，犯上烟瘾的那些人得肺癌的几率远远高于其他人。这真的能够说明吸烟致癌吗？仔细想想你会发现这当然不能！原因恰似黄手指与肺癌一例：完全有可能是某个第三方变量同时对“爱吸烟”和“患肺癌”产生影响。1957年，Fisher提出了两个备选理论：癌症引起吸烟（烟瘾是癌症早期的一个症状），或者存在某种基因能够同时引起癌症和烟瘾。<br>
    有虚假的相关性数据，就有虚假的独立性数据。“健康工人效应”是一个特别有意思的理论。调查发现，在铀矿工作的工人居然与其它人的寿命一样长（有时甚至更长）。这表明在铀矿工作对身体无害么？当然不是！其实，是因为去铀矿工作的工人都是经过精心挑选的身强体壮的人，他们的寿命本来就该长一些，正是因为去了铀矿工作才把他们的寿命拉低到了平均水平。这一有趣的细节导致了数据的伪独立性。类似地，有数据表明打太极拳的人和不打太极拳的人平均寿命相同。事实上呢，太极拳确实可以强身健体、延长寿命，但打太极拳的人往往是体弱多病的人，这一事实也给统计数据带来了虚假的独立性。</p>
<p><span id="more-930"></span><br>
    现实中的统计数据往往会表现出一些更加诡异复杂的反常现象。Simpson悖论是统计学中最有名的悖论：各个局部表现都很好，合起来一看反而更差。统计学在药物实验中的应用相当广泛，每次推出一种新药，我们都需要非常谨慎地进行临床测试。但有时候，药物实验的结果会让人匪夷所思。假设现在我们有一种可以代替安慰剂的新药。统计数据表明，这种新药的效果并不比安慰剂好：</p>
<p><code>         有效   无效   总人数<br>
新药      80    120     200<br>
安慰剂   100    100     200</code></p>
<p>    简单算算就能看出，新药只对40%的人有效，而安慰剂则对50%的人有效。新药按理说应该更好啊，那问题出在哪里呢？是否是因为这种新药对某一类人有副作用？于是研究人员把性别因素考虑进来，将男女分开来统计：</p>
<p><code>       男性有效  男性无效  女性有效  女性无效<br>
新药      35        15        45       105<br>
安慰剂    90        60        10        40</code></p>
<p>    大家不妨实际计算一下：对于男性来说，新药对高达70%的人都有效，而安慰剂则只对60%的人有效；对于女性来说，新药对30%的人都有效，而安慰剂则只对20%的人有效。滑稽的一幕出现了：我们惊奇地发现，新药对男性更加有效，对女性也更加有效，但对整个人类则无效！</p>
<p>    这种怪异的事屡见不鲜。前几个月一个高中的师弟给我发短信，给了我两个大学的名字，问该填报哪个好。鉴于我目前的悲惨境遇，我非常认真地帮他查了一下两所大学的男女比例，并且很细致地将表格精确到了各个院系。然后呢，怪事出现了：A学校的每个院系的女生比例都比B学校的同院系要高，但合起来一看就比B学校的低。当然，进错了大学找不到MM是小事，大不了像我一样20岁了连初吻都还没有，拿出去丢丢人让别人笑话笑话就完事了；但医药研究需要的是极其精细的统计实验，稍微出点差错的话害死的可就不是一两个人了。上面的例子再次告诉我们，统计实验的“随机干预”有多么重要。从上面的数据里我们直接看到，这个实验的操作本身就有问题：新药几乎全是女的在用，男的则大都在用安慰剂。被试者的分组根本没有实现完全的随机化，这才导致了如此混乱的统计结果；不难设想，如果每种药物的使用者都是男女各占一半，上述的悖论也就不会产生了。当然，研究人员也不都是傻子，这么重大的失误一般还是不会发生的。问题很可能出在一些没人注意到的小细节上。比如说，实验的时候用粉色的瓶子装新药，用蓝色的瓶子装安慰剂，然后让被试人从中随机选一个来用。结果呢，MM喜欢粉色，选的都是新药；男的呢则大多选择了蓝瓶子，用的都是安慰剂。最后，新药和安慰剂都发完了，因此直到结果出来之前没有人会注意到这个微小的性别差异所带来的统计失误。<br>
    当然，上面这个药物实验的例子并不是真实的，一看就知道那个数据是凑出来方便大家计算的。不过，永远不要以为这种戏剧性的事件不会发生。一本叫做《致命的药物》的书详细披露了20世纪美国的一次重大药害事件，其原因可以归结到药物实验上去。药物实验的时间是有限的，如果用死亡率作为唯一标准的话，估计每个药物实验都得观察个十几二十年才行。为此，科学家们想到了利用各种“中间变量”来替代死亡率这一指标。</p>
<p>    统计数据表明，抑制心律失常能够减少死亡率，而当时的药物实验明确表明该药物能有效地抑制心律失常。这些药物得到了FDA批准并成功上市，当时每年有20多万人服用这些药品，超过5万人因为服用这种药物而死亡。这个药物实验中蕴含的逻辑推理看似无懈可击，到底什么地方出错了呢？人们推测很可能是某个第三方变量的问题。我们不妨称这种情况为“中间变量悖论”。</p>
<p><code>               抑制心律失常           死亡率<br>
              对照组  实验组     未抑制    抑制<br>
无缺陷(70%)    0.02    0.99       0.02     0.01<br>
有缺陷(30%)    0.98    0.79       1.00     0.02<br>
---------------------------------------------------<br>
期望值         0.38    0.93       0.314    0.013</code></p>
<p>    让我们假设存在一个第三方因素，例如基因问题。我们不妨暂时管它叫做“先天缺陷”。从上表中我们可以看到，实验组（使用新药的人）中有93%的人成功抑制了心律失常，远远高于什么都不做的人(38%)；同时，心律失常确实会导致31.4%的人心脏骤停而死，但抑制心律失常则把这个比率下降到1.3%。这似乎确实可以说明，新药能够有效降低死亡率。但引入第三方因素后，情况有了很大的改变。有先天缺陷的人，心律往往很正常，恐怖的是一旦无法抑制心律失常则必死无疑。真正要命的就是，这种药物会使那些有先天缺陷的人心律变得更差。在没有缺陷的那70%的人当中，用药后有99%的人能抑制心律失常，而这里面只有1%的人会死；同时，另外1%的人则无法抑制，其中又有2%的人会死亡；有先天缺陷的那30%的人就惨了，用药后抑制住心律失常的人反而下降到79%，其中有2%的人会死，而对于另外21%的人则必死无疑。计算表明，使用药物后死亡的人数竟然三倍于不使用药物时的情况！</p>
<blockquote><p>   (0.7*0.99*0.01 + 0.7*0.01*0.02 + 0.3*0.79*0.02 + 0.3*0.21*1.00)<br>
/ (0.7*0.02*0.01 + 0.7*0.98*0.02 + 0.3*0.98*0.02 + 0.3*0.02*1.00)<br>
≈ 2.91</p></blockquote>
<p>    可以看到，从数据中挖掘因果关系并不是那么简单的事。如何确定影响目标的事件，如何从数据中获取相关关系，怎样用最少的实验次数（控制最少的变量）为因果关系定向，这都是建立一个因果网络所需要考虑的因素。因果网络是一个很复杂的学问，前天的讲座里还提到了很多确定因果网络的算法，在这里我就不再多说了。</p>
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2008-10-19T01:22:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/930</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：只用赋值、自增和循环操作实现减法运算 ]]></title>
<link>http://www.matrix67.com/blog/archives/944</link>
<content><![CDATA[ 
		<p>  网友Mingliang Zhu在<a href="http://groups.google.com/group/pongba/browse_thread/thread/a5abc11899e04006">TopLanguage</a>上发起提问。</p>
<p>  设想这样一个计算机系统，它只支持以下几个操作：<br>
    1. 定义变量、给变量赋值；<br>
    2. 变量自身加一；<br>
    3. 令一段语句循环执行指定的次数。<br>
  这个系统只处理且只能处理0和正整数。系统不存在“溢出”的问题。<br>
  注意这个系统没有比较运算，事实上它甚至不存在Boolean值和判断语句。<br>
  循环语句也不是FOR i=a TO b DO的形式，只能是LOOP n的形式。</p>
<p>  在这个系统上实现加法很容易，让a自增b次即可。现在的问题是，你能在这个系统上实现减法吗？</p>
<p><span id="more-944"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
  问题的关键在于如何实现自减一操作。<br>
  本来让-1自增n次即可实现n的自减的，但系统偏偏又不支持负数。<br>
  网友Dingding给出了一个答案：</p>
<p><code>tmp = 0<br>
result = 0<br>
loop(n) {<br>
   result = tmp<br>
   tmp++<br>
}</code></p>
<p>  这段代码执行后，result的值将变为n-1。注意到这段代码在自增时是如何巧妙地延迟了一步的。<br>
  现在，我们相当于有了自减一的函数dec。实现a-b只需要令a自减b次即可：</p>
<p><code>result = a<br>
loop(b) {<br>
   dec(result)<br>
}</code></p>
			 ]]></content>
<pubDate>2008-10-22T00:36:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/944</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用最少的“并行交换”完成排序 ]]></title>
<link>http://www.matrix67.com/blog/archives/954</link>
<content><![CDATA[ 
		<p>    今天是10月25日。祝<a href="http://blog.sina.com.cn/yanyang1025">古汉MM</a>生日快乐。<br>
    曾经有一段时间这个Blog的访问量和订阅量剧增，后来才知道因为这个Blog上的<a href="http://www.matrix67.com/blog/archives/858">一道牛B题目</a>被出成<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3705">POJ的月赛题</a>了。那道题目真的很好玩，题目和解答都很简单有趣。其实我挺喜欢这种“给出一个算法并证明该算法最优”类型的数学题目。这里再和大家分享一个类似的比较老的题目，有兴趣的话不妨先想想再看答案。<br>
    一次“交换”操作是指将数列中的两个数位置对换。我们假设，互不相交的若干个交换操作可以一次同时进行；换句话说，如果k个交换中任两个都不会对同一个数进行操作，那么这k个操作可以并行完成。例如，在数列</p>
<p>  10, 6, 8, 5, 2, 3, 1, 4, 7, 9</p>
<p>    中，我们可以同时交换第4个数和第6个数，第8个数和第9个数，以及第3个数和第7个数。经过这一次“并行交换”后，数列变为：</p>
<p>  10, 6, 1, 3, 2, 5, 8, 7, 4, 9</p>
<p>    任意给定一个长度为n的全排列，请问对该序列进行排序最坏情况下需要多少次并行交换？给出一种具体的算法，说明这个次数足够了；并且给出一种最坏情况，证明这个次数是必需的。</p>
<p><span id="more-954"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    这种“并行交换”是如此的强大，以致于我们要问自己的第一个问题是，是否有可能对所有数列都只需要一次并行交换就够了。不难发现，除了n=1和n=2之外，对于其它的n，我们总能找到一个数列，它至少需要两次并行交换才能完成排序。考虑到一次并行交换只能变动偶数个数的位置，因此我们只需要弄出一个有奇数个数不在正确位置上的排列就可以了。对于n≥3的情况，这总是可以办到的，例如数列2, 3, 1, 4, 5, 6, 7, …, n（仅让最前面的1、2、3三个数位置顺次挪一位）就可以了。这样的话，我们要不然就无法处理完所有要移动的数，要不然就会动到已经在目标位置上的数，总之一次交换是怎么也不能满足要求。<br>
    令人吃惊的是，不管n有多大，不管数列有多乱，最多只需要2次并行交换就可以排好序了。为了证明这一点，我们首先看一种特殊情况：对于“顺次挪动一位”，即“2占了1该在的位置，3又占了2应该在的位置，……，n占了n-1的位置，最后1又占了n本该在的位置”的情况，如何用两次并行交换调整顺序。回想一下线性时间常数附加空间的数组循环移动的算法，我们立即得到了我们需要的算法：由于循环移动一位相当于两次逆序操作，而一次逆序操作可以由前后对称位置上的n/2组交换完成，因此我们只需要两次并行交换即可。具体地说，对于下面这个数列</p>
<p>  2, 3, 4, …, n-1, n, 1</p>
<p>    首先将整个序列进行逆序，即2和1交换，3和n交换，4和n-1交换，……，于是得到：</p>
<p>  1, n, n-1, …, 4, 3, 2</p>
<p>    接下来，将得到的序列的后面n-1位再逆序一次，即n和2交换，n-1和3交换，……，于是数列就变成了</p>
<p>  1, 2, 3, 4, …, n-1, n</p>
<p>    这样，我们就可以只用两次并行交换完成“循环移动一位”型的数列了。<br>
    到这里，我们离最终的答案已经很近很近了。最关键的一点是，这个“循环移动一位”可以是广义的。换句话说，只要是“数字1应该到现在4的位置上去，而4又该移到7的位置上去，7则本该在现在2的位置上，而2又该替代现在的1”一类的“圈”，我们都可以用上面的方法在两步以内还原为应有的顺序。一旦想到了任何一个排列总能分解成若干个互不相交的循环时，我们的问题也就立即解决了。<br>
    举个例子，我们对原题中的例子</p>
<p>  10, 6, 8, 5, 2, 3, 1, 4, 7, 9</p>
<p>    进行排序。这个数列包含了两个循环：10 -&gt; 9 -&gt; 7 -&gt; 1 -&gt; 10，以及6 -&gt; 3 -&gt; 8 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 6。也就是说，我们要把[10,9,7,1]四个数依次变成[1,10,9,7]，同时把[6,3,8,4,5,2]变成[2,6,3,8,4,5]。在第一步，我们把第一个循环中的(10,1)和(9,7)进行交换以实现逆序，同时并行地在另一个不相交的循环中进行同样的操作，将(6,2)、(3,5)和(8,4)进行交换；第二步，我们把每个循环中的后面一段进行逆序，即交换第一个循环中的(10,7)，同时交换第二个循环中的(6,5)和(3,4)。</p>
<p>10, 6, 8, 5, 2, 3, 1, 4, 7, 9  http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/challenges/April1999.html</p>
			 ]]></content>
<pubDate>2008-10-25T22:25:01+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/954</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 《从一到无穷大》选谈：思维的尺度 ]]></title>
<link>http://www.matrix67.com/blog/archives/959</link>
<content><![CDATA[ 
		<p>    这个月月初就开始看《从一到无穷大》，花了接近两个星期才看完。这确实是一本让人放不下手的好书。考虑到我的阅读速度，一个多星期一本书已经近乎神速了。在这本书里我经常会看到一些有趣的数学知识，前段时间我还写过书里提到的一个<a href="http://www.matrix67.com/blog/archives/890">有趣的东西</a>——环面上的染色问题反而比平面上的“四色问题”更加简单。这种例子并不罕见，很多时候一些扩展版的问题反而比原问题更加简单。在第八章，我看到了另一个好玩的东西：随机游走(random walk)问题。<br>
    随机游走问题是说，假如你每次随机选择一个方向迈出一个单位的长度，那么n次行动之后你离原点平均有多远（即离原点距离的期望值）。有趣的是，这个问题的二维情况反而比一维情况更加简单，关键就是一维情况下的绝对值符号无法打开来。先拿一维情况来说，多数人第一反应肯定是，平均距离应该是0，因为向左走和向右走的几率是一样的。确实，原点两边的情况是对称的，最终<strong>坐标</strong>的平均值应该是0才对；但我们这里考虑的是<strong>距离</strong>，它需要加上一个绝对值的符号，期望显然是一个比0大的数。如果我们做p次实验，那么我们要求的平均距离D就应该是</p>
<p>  <img alt="image placeholder" >
<p>    其中d的值随机取1或者-1。这里的绝对值符号是一个打不破的坚冰，它让处于不同绝对值符号内的d值无法互相抵消。但是，当同样的问题扩展到二维时，情况有了很大的改变。我们把每一步的路径投射到X轴和Y轴上，利用勾股定理我们可以求出离原点的距离的平方R^2的值：</p>
<p>  <img alt="image placeholder" >
<p>    一旦把平方展开后，有趣的事情出现了：这些X值和Y值都是有正有负均匀分布的，因此当实验次数p充分大时，除了那几个平方项以外，其它的都抵消了。最后呢，式子就变成了</p>
<p>  <img alt="image placeholder" >
<p>    于是呢，就有平均距离R=sqrt(n) （准确的说是均方根距离）。我们得出，在二维平面内随机选择方向走一个单位的长度，则n步之后离出发点的平均距离为根号n。这是一个很美妙的结论。</p>
<p><span id="more-959"></span><br>
    有些时候，数学世界和物理世界会奇迹般地结合起来，碰撞出绚丽的火花。这个Blog之前就曾经写过一系列<a href="http://www.matrix67.com/blog/?s=%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98">用物理方法解决数学问题</a>的例子。在这里，这一个简单的随机游走定律同样对应了一个极其普遍的物理现象：Brown运动。你会发现，不管是水中墨滴扩散，两种液体的混合，还是热导体中的传热，都遵循一个简单的定律：扩散的距离与时间的平方根成正比。事实上，这本书花了相当大的篇幅来讲解这几种物理现象及其扩散速度定律的意义。<br>
    “从一到无穷大”这个名字会让人误以为这本书是一本数学书。其实，这本书里面的数学知识只占了很小的一部分。这是一本贯穿各大科学领域的科普读物，书里面从数字讲到空间和维度，引出Einstein的时空观念，试图揭示宇宙的时空本质；进而乘坐“下降的阶梯”进入微观世界，从化学一直谈到生物；最后我们将再次迈入宇宙空间，进入神秘莫测的宇宙学。<br>
    作为一个（形式上的）文科生，我很高兴能够以这种方式学习到理科的各种基础知识，而不是被应试教育强迫地灌进各种做题所需的知识和技巧；后者必然会减少很多乐趣。</p>
<p>    大概有三四年没有接触物理了吧，但对物理的钟爱一直未减。我经常说起一句很经典的话，这非常确切地表达出我对数理化孰轻孰重等问题的看法：Chemistry is physics without thought. Mathematics is physics without purpose. 不知道为什么，我就是非常讨厌化学，或许这种厌恶是来自于化学本身的一些非逻辑性。即使看完了《从一到无穷大》，我仍然觉得，除了元素周期以外，其它的很多东西都是不成逻辑体系的牵强附会。或许这是一种偏见，或许这只是我认识不够深，总之我因为化学成绩太差，高一下学期被迫选择了文科。但我一直舍不得物理学，开始文科学习的头半年仍然被惯性驱动着，读完了物理的高中教材。物理和数学都有其独特的魅力：数学美在其精巧的证明，物理则美在巧妙的实验设计。第一个想出用水银代替普通液体测量大气压强的人真的是天才，用镜片的细小扭动把万有引力放大到肉眼可见的尺度似乎是人类在向大自然高呼自己并不渺小。物理实验最震撼的就是，凭借一些并不复杂但却异常巧妙的装置，我们可以观测出比自己大很多很多的尺度下的物理现象。</p>
<p>    说起大尺度，估计没什么比得过光速了。最初试图测量光速的做法是可笑的：Galileo和它的助手站在郊外旷野，彼此相距好几英里远，然后Galileo打开遮光板并开始计时，助手在远处看到光线后立即打开他那边的遮光板，最后Galileo看到对方过来的光线并停止计时。当然，现在我们知道，光的速度太快了，一秒钟足以绕地球七圈半，而在这个时间里他助手的手脚甚至还反应不过来。说来有趣，Galileo用实验的方法得知了他的实验是没有意义的：当他和他助手之间的距离扩大一倍后，测出来的时间还是一样的，并未随距离的扩大而翻倍。于是Galileo意识到：光的速度值是可怕的，这种传统的方法根本测量不出来，所得到的时间间隔仅仅是“反应迟误”。<br>
    法国物理学家Fizeau真是一个天才！他用一个小小的仪器精确地得到了光的速度。把两个同样规格的齿轮安装在同一根转轴的两侧，并让这两个齿轮正好齿和齿缝错开来相对。在转轴的其中一头放置一个光源，则（转轴静止时）从转轴的另一头向光源看过去，两个齿轮重叠的方式正好挡住了对面全部的光线。然后我们开始转动转轴，转轴带动两个齿轮以相同的速度转动。当转速到达一定值时，我们会观察到一个神奇的现象：两个齿轮的齿缝似乎对在了一起，那一端的光线直接从齿缝间穿过来了。这是因为光线在两个齿轮间传播的过程中，齿轮正好转过了半个齿，于是当光线到达第二个齿轮时原本齿的位置就变成了齿缝，光线就这样通过了两个本来错位相对的齿轮。如果此时再以双倍的速度转动转轴，则齿与齿之间的缝隙就又不见了，因为光线传播的时间里齿轮正好转过整整的一个齿。根据转速和齿轮的规格，我们就可以计算出光速的值。为了让实验更加精确，我们可以在光线传播的途中多加一些镜子来延长光路。</p>
<p>    人类所面临的第一个超越自己尺度的物体或许就是我们脚下的大地。有时候我们会觉得奇怪：古人是怎么发现地球是圆的呢？事实上，要发觉这一点并不困难，自然界中有相当多的征兆预示着“地面是弯曲的”这一事实。例如，一艘船消失在地平线时，总是船身已经看不见了，但桅杆还露在水面上。地球是一个球体，这意味着我们脚下的大地是有限的。那么，这个世界到底有多大呢？想要测量出地球的大小似乎是不可能的，因为我们本来就生活在地球上，人类似乎面临着一个“抓着头发把自己提起来”的难题。公元前3世纪，Eratosthenes想出了一个绝妙的办法：当阳光垂直射入A城的竖井时，在800公里外的B城测得日光与地面有7度的夹角。我们立即可知，地球圆周的1/50长大概是800公里，那么整个圆周长度就是40000公里左右了。<br>
    测量地球的大小还不算牛B，人类所干的牛B事儿多了去了。比如，我们是怎么知道月球距离我们有多远的？尽管我们仍然面临着更加严重的“只缘身在此山中”难题，但科学家们还是把它解决了。为了说明这个问题，不妨让我们看一个同样是远距离地测量处于自身之外的物理量，但更具有启发性的问题：“目测”是如何工作的？这让我们想起一个很有趣的小游戏：睁一只眼闭一只眼穿针相当困难，但两只眼睛一起用的话线一下子就穿进去了。只用一只眼睛看东西会失去立体感。我穿针相当的笨，曾经一度以为那是我手脚不灵活，但后来我开始设想是不是由于我眼睛分辨不出深度的问题。我很可能从来没感受过真正的“立体感”，因为我的左眼有严重的散光和弱视，因此我看东西几乎可以说是只用到了右眼。说了半天，为什么两只眼睛看东西就能分辨远近呢？这是因为，由于角度的原因，两只眼睛看到的画面并不是完全相同。不断换用左右眼来看东西，你会发现，距离你近的东西会在远景上产生一定的位移。这就是所谓的“视差”，我们的大脑能够根据两眼所获得的视差来判断距离。同样的方法仍然可以适用于在地球上观察月球，只是为了产生更大的“视差”，我们的两只“眼睛”应该相离足够远才行。天文学家们从地球的两端同时对着月球拍照，算出视差为1°24’5”，从而得知地球和月球之间的距离为地球直径的30.14倍，即384403公里。<br>
    当然，存在一些更远的星星，即使地球两端这么远的距离仍然不能造成足以观测到的视差。这下怎么办呢？德国天文学家Bessel突发奇想，企图利用地球在公转轨道上的不同位置所造成的视差来测量距离！<del datetime="2008-10-28T07:21:37+00:00">1938</del> 1838年，他开始对相隔半年的星空进行比较，发现一颗天鹅座的恒星在星空背景中有了些许的位移。然而，再过半年重新进行观测时，这颗恒星又回到了一年前的位置，这说明了半年前的位移确实是由视差造成的，而不是星星本身的移动。根据这个视差，Bessel计算出这颗恒星在103 000 000 000 000公里之外，比太阳还远690 000倍！人类似乎一下子变得异常的高大，人类文明的双手伸向了太阳系外的星球，而Bessel就是拿着尺子跨出太阳系进入星际空间的第一人！<br>
    大家当然会问，那更远的星星呢？事实上，尽管视差法已经不再凑效了，但我们也有别的测量方法。甚至包括银河系的样子、银河系的旋转、地球的年龄、宇宙的年龄这样一些天文尺度下的物理现象和物理量，我们也能从一些细小的线索中逐步推测出来。以前一直在想，人们是怎么知道地球的公转和自转，又是如何知道地球的年龄和形成过程的；从这本书中我找到了答案，并且由衷地感叹人类思维的无穷力量！在宇宙的大尺度下，人类或许很渺小，但思维绝对不受任何尺度的限制！从一走到无穷大的，不仅是指几千年来的数学史，更是整个人类文明的思想和智慧。</p>
<p> <br>
    最后呢，和大家分享书上的一段有趣的文字。</p>
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2008-10-28T04:21:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/959</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 号外：物理构建类解谜游戏World of Goo下载 ]]></title>
<link>http://www.matrix67.com/blog/archives/973</link>
<content><![CDATA[ 
		<p>有朋友告诉我说，上次推荐的游戏<a href="http://www.matrix67.com/blog/archives/430">World of Goo</a>这个月13号已经发行了。大家快去<a href="http://www.mininova.org/tor/1909754">下载</a>吧。</p>
<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/-A_JfkzPwww&amp;hl=zh_CN&amp;fs=1">
<param name="allowFullScreen" value="true">
<embed src="http://www.youtube.com/v/-A_JfkzPwww&amp;hl=zh_CN&amp;fs=1" type="application/x-shockwave-flash" allowfullscreen="true" width="425" height="344"></embed></object></p>
			 ]]></content>
<pubDate>2008-10-29T17:55:09+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/973</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 构造函数使得任意小的区间所对应的值域都是整个实数域 ]]></title>
<link>http://www.matrix67.com/blog/archives/978</link>
<content><![CDATA[ 
		<p>    首先呢，让我们来一个牛B函数大回顾。这下我不知道要赚多少的PV。你能否构造一个函数f(x)，使得：</p>
<p>  <a href="http://www.matrix67.com/blog/archives/137">它是一个阶梯状的连续函数？</a><br>
  <a href="http://www.matrix67.com/blog/archives/720">它是除常函数之外的没有最小正周期的周期函数？</a><br>
  <a href="http://www.matrix67.com/blog/archives/720">该函数只在一点连续？</a><br>
  <a href="http://www.matrix67.com/blog/archives/698">该函数在[0,1]和(0,1)之间形成一一对应？</a><br>
  <a href="http://www.matrix67.com/blog/archives/330">该函数某一点导数为正，但该点邻域不构成单增区间？</a><br>
  <a href="http://www.matrix67.com/blog/archives/448">平面上任意小的圆内均包含函数上的点？</a></p>
<p>    另外还有一些可能是众所周知（所以没在Blog里写过）的函数，比如<a href="http://en.wikipedia.org/wiki/Weierstrass_function">处处连续但处处不可导的函数</a>、<a href="http://en.wikipedia.org/wiki/Popcorn_function">在有理点处处不连续在无理点处处连续的函数</a>等等。<br>
    好了，现在呢，又一个牛B东西出现了。你能不能想出这样一个函数f，它的定义域和值域都是R，并且对于任意小的区间l=(u,v)，这个函数都能把(u,v)满射到整个R上。换句话说，是否存在这样的函数f(x)，对于任意一个实数t以及任意一个区间(u,v)，总存在一个x满足u&lt;x&lt;v且f(x)=t。</p>
<p><span id="more-978"></span></p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
     首先，注意到函数h(x)=tan( pi*(x-1/2) )将(0,1)上的数与全体实数一一对应，因此，我们只需要找出一个g(x)，它能把任意小的区间满射到(0,1)区间上，然后在它上面复合一个h(x)就得到我们题目所求的函数了。<br>
    我们的g(x)可以这样定义：首先，把x写成三进制数。如果x的三进制表达里没有数字2或者有无穷多个数字2，那么g(x)=0。否则，x的三进制中含有有限多个数字2。找到最末的一个数字2，把它及其前面的部分都去掉，这样剩下的就只有0和1了。在这个01串前面加上一个小数点，把它当作一个二进制小数转换回去，作为g(x)的函数值。这样的话，g(x)就是一个值域为[0,1)的函数，并且在任意小的区间内，我们总能找到一个点，它所对的函数值就是你想要的那个值：只需要取一个该区间内的精度足够高（小数点位数足够多）的三进制有限小数，在后面加一个数字2，再后面的01串就可以想要啥就要啥了。<br>
    注意到g(x)把任意小的区间都映射到[0,1)上，而前面提到的h(x)则在(0,1)和R之间建立了一一对应的关系。于是，定义f(x)为，当g(x)=0时f(x)=0，否则f(x)=h( g(x) )。这就是满足题意的函数f。</p>
<p>题目来源：<a href="http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/Challenges/October2001.html">http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/Challenges/October2001.html</a></p>
			 ]]></content>
<pubDate>2008-10-30T23:16:47+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/978</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ World of Goo与Sierpinski三角形 ]]></title>
<link>http://www.matrix67.com/blog/archives/989</link>
<content><![CDATA[ 
		<p>    打完了World of Goo，确实是一个难得一见的好游戏。自从打完Portal后，很久没玩到这么好的游戏了。遗憾的是呢，和Portal一样，这个游戏的关卡并不难，游戏时间也太短了一些。一款好的游戏会设置一些在游戏通关后仍然具有可玩性和挑战性的环节，比如这个游戏中你的终极目标就是反复挑战关卡收集尽可能多的球球，在Tower of Goo里面建造尽可能高的塔。如何用尽可能少的球球来建造一个尽可能高的、稳定的塔呢？受到经典分形图形<a href="http://www.matrix67.com/blog/archives/280">Sierpinski三角形</a>的启发，我打算建这么一个塔（下图为草图），这个样子看上去蛮稳定的（大家认为呢？），并且节省了不少材料。由于球球是可以重新安放的，因此我可以在搭建好三角形后从中间挖出不要的球球来，这给我建造Sierpinski三角形提供了可能性。不过，目前这个工程只做到了2阶，因为我还差球球。大家还想到了什么其它的结构？欢迎在下面和大家分享。</p>
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2008-11-02T21:26:23+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/989</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ UyHiP趣题：(√2 +√3)^1948小数点后第48位是多少？ ]]></title>
<link>http://www.matrix67.com/blog/archives/996</link>
<content><![CDATA[ 
		<p>    作为一个<a href="http://www.brand.site.co.il/riddles/">UyHiP</a>的忠实粉丝，我决定把<a href="http://www.brand.site.co.il/riddles/200810q.html">上个月的题目</a>和解答翻译过来，即使<a href="http://www.matrix67.com/blog/archives/396">类似的把戏</a>我们之前已经见到过了。<br>
    题目就一句话：根号2和根号3的和的1948次方的小数点后第48位是多少？如果你立即就想到了正确算法的话，我敢保证在别人还没打开Mathematica的时候你就已经得到答案了。</p>
<p style="color:#E5E5E5">    这道题背后隐藏的把戏就是，(√2 +√3)^1948 + (√2 -√3)^1948永远是一个整数，因为展开之后偶数次幂本来就是整数，而奇数次幂的项恰好又正负互相抵消了。注意到√3 -√2只比0.3多一点，因此(√2 -√3)^1948是一个很小很小的数，粗略估算一下的话它小数点后面紧跟着好几百个“0”；而前面说了(√2 +√3)^1948和(√2 -√3)^1948加起来是个整数，那么前者的小数点后必然有相当长的一段数字9。保守估计的话，不但(√2 +√3)^1948小数点后的第48位是“9”，就是480位也是“9”。事实上，这个数的小数点后面900多位都是“9”。</p>
			 ]]></content>
<pubDate>2008-11-03T21:55:16+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/996</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：完全图K_n最少可以拆成多少个完全二分图？ ]]></title>
<link>http://www.matrix67.com/blog/archives/998</link>
<content><![CDATA[ 
		<p>   <img alt="image placeholder" >
<p>    一个完全图K_n是指一个有n个顶点的图，其中每两个点之间都有一条边相连。一个完全二分图是指这样一种图，图中的顶点分为两个点集L和R，L里的每个顶点都和R里的所有点相连。上图显示了一种把K_5划分为四个完全二分图的方法（分别用红蓝绿灰四种颜色来表示这四个子图）。你觉得，最少可以把完全图K_n划分成多少个完全二分图？给出一种划分方案，并证明这个数目已经不能再少了。</p>
<p><span id="more-998"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    和你想象的一样，这个答案就是n-1。一个完全图K_n永远不可能被拆分为n-2个或更少的完全二分图。拆成n-1个是很好办的：从K_n中随便取出一个点作为L集，其余n-1个点作为R集，把这n-1条边从图中取出来形成一个完全二分图，然后继续递归地处理K_(n-1)；当规模降到K_2时，我们已经得到了n-2个二分图，并且图中就只剩下一条边了，合起来正好是n-1个完全二分图。现在的关键是，如何证明n-1个已经是最少的了？<br>
    这个证明牛B就牛B在，它根本就不是用组合数学的方法证明的。它居然是用线性代数来证明的！这可以说是我见过的最诡异的证明了。假设我们把K_n划分为了m个完全二分图，第i个二分图的左右两个点集分别记作L_i和R_i。给图中的每个顶点设置一个变量，第i个顶点上的数就记作x_i。于是呢，有</p>
<p><img alt="image placeholder" >
<p>    现在，让我们假设m&lt;n-1。考虑下面这个线性方程组：</p>
<p><img alt="image placeholder" >
<p>    这个线性方程组的式子个数比未知量少，因此它一定有一组非零解c_1, c_2, …, c_n。既然每个L_i里面的变量和都为0了，根据前面的那个恒等式，我们得知</p>
<p><img alt="image placeholder" >
<p>    考虑所有c_i的和的平方，展开后有</p>
<p><img alt="image placeholder" >
<p>    但是，一方面，由线性方程组的第一个方程知c_i的总和为0，其平方当然也等于0；另一方面，c_i是非零解，它的平方和是大于0的。矛盾产生。</p>
<p>    题目来源：Proofs from THE BOOK, Chapter 9</p>
			 ]]></content>
<pubDate>2008-11-06T23:57:55+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/998</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：不用数学归纳法直接推导平面图的Euler公式 ]]></title>
<link>http://www.matrix67.com/blog/archives/1006</link>
<content><![CDATA[ 
		<p>    把《三体II黑暗森林》看完后，又把上学期已经放下的Proofs from THE BOOK拿出来翻了几页。当结束了数论部分进入几何学时，一些离散性的东西让整本书陡然科学了起来。前面那篇日志里的牛B证明就是我从这本书的第9章中看到的，运用线性代数的基本定理我们居然可以证明一个无从下手的图论问题！今天我又看到牛B证明了：平面图Euler公式V+F=E+2的非数学归纳法证明。以前我见到过各种Euler公式的证明，证明方法千奇百怪，其中不乏很多独具匠心的精巧证明，但它们本质上都是运用数学归纳法不断拆边重组减低规模，将复杂的平面图一点一点变得简单。在Proofs from THE BOOK的第11章，我见到了一个用半页纸写下的巧妙证明，证明方法简单、美观而有趣，读后让人会心一笑。</p>
<p>  <img alt="image placeholder" >
    在介绍这个证明之前，让我们先来回顾一下什么是Euler公式。Euler公式是说，在一个由若干顶点和它们之间的一些不相交的边所组成的图中，等式V+F=E+2总成立，其中V表示顶点个数，E表示总的边数，F表示这个图分割出来的区域个数（包括一个“外部区域”，例如一个圆把平面分割为两个区域）。如图1，这个图共有6个顶点、10条边和6个区域，可以看到6+6=10+2是成立的。为了证明这个结论，考虑这个图的任意一个生成树（图1中加粗了的边）。再考虑这个图的“对偶图”：新图的每个顶点代表原图的一个区域，原图的两个区域相邻则在新图上的两个对应顶点之间连一条边（图2中的虚线部分）。接下来，我们找出原图中那些不属于生成树的边界线，把它们在新图中所对应的边加粗（图2中的加粗虚线）。容易看出，加粗的虚线是连通的，因为原图的粗线条是一棵生成树，它没有隔离出任何一块区域；同时呢，加粗虚线是没有环的，否则它将把某个原图的顶点包起来，从而原图中的加粗线条就不可能是生成树了。只需要注意到一棵树的顶点数等于边数加一，我们的结论就直接出来了：原图的顶点数就是Euler公式中的V，它等于原图生成树的边数加一；新图的顶点数就是Euler公式中的F，它等于新生成树的边数加一；而两棵生成树的边数总和正好就是原图中的E。于是呢，我们就得到了V+F=E+2。</p>
			 ]]></content>
<pubDate>2008-11-08T18:11:26+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1006</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 漫话二分（上） ]]></title>
<link>http://www.matrix67.com/blog/archives/1013</link>
<content><![CDATA[ 
		<p>    二分思想真的是无所不在，即使在中文系的专业课中我们也能见到这个词。在语言学概论中我们提到，一个音位可以由一组区别特征确定下来，这些区别特征总是以只具有“是/否”、“有/无”等两种对立属性的“二元偶分组”形式存在，因为这样可以最方便最快捷地确定出一个元素。这有点像猜数字一样，我想一个数字后让你来猜，我告诉你你的猜测是大了还是小了。只是在这里，回馈的信息不再是大小，而是“辅音/元音”、“口音/鼻音”、“浊音/清音”、“送气/不送气”等形式逐层细分。这让人联想到5张卡片猜年龄的老把戏，一系列火星的称球问题，基于比较的排序算法的复杂度下界，或者经典的<a href="http://y.20q.net/">20q在线游戏</a>。<br>
    一个有趣的事实是，相当多的人都错误地理解了“二分”这个词，但他们在生活中却拥有很强的二分意识。我们语言学概论的老师（这里就不说是谁了）在讲解二分时举了一个甚为荒谬的例子：如果你要在房间里找一根针，那么你可以把房间划分为两半，如果这一半找不到的话说明针一定在房间另一半，此时再把那一半分成两部分，不断分分分分分最后总能找到针的位置。这是这位老师无数荒唐的例子中的冰山一角，因为这个“二分”与搜索别无二致。这个“二分”的判断环节并不是即刻返回的，而且最关键的是它并不具有规模减半的功能，或者说一旦返回“真”后我们并不会再接着二分下去。如果让我来举例子的话，同样是拿找东西打比方，<a href="http://www.matrix67.com/blog/archives/415">在合唱队中找出跑调了的人</a>是一个绝佳的例子，因为在合唱中我们能轻易分辨出一个不和谐的声音（虽然无法准确判断这个声音是从哪儿传来的），不断叫当前的人的其中一半来合唱便可渐渐判断出那个人的位置。但讽刺的是，这老师在举这个错误例子的同时，竟然在不自觉地用二分法来调整课件的字号。他发现这一页ppt的字号太小了，我们可能看不清，于是希望让字号尽可能的大但又不致于大到显示不下。他开始尝试40号，发现字已经超出屏幕了；然后把字体改成20号，又觉得还能再大一些；进而又改到28号（工具栏上的字号调整以4为步长），最后确定到了24号字。</p>
<p>    如果真的叫一个课讲的好的老师来说二分，课程可以变得相当有意思。每次回我们高中时我都讲了很多次课，我最喜欢聊到的话题之一就是二分。从猜数游戏引入二分查询有序队列中的指定元素，然后提出一些标准的有序队列二分搜索的实际应用，比如解方程x^x=100一类的问题。紧接着提出二分的各种有趣的变形，例如如何在有序整数序列中查询A_i=i的元素。提出这些问题的目的就在于告诉大家，二分的思想不仅仅是用在猜数游戏一类的情况下。二分判断并不只限于“比目标值大/比目标值小”，只要能判断出目标值在哪边都行，例如在这里，A_i&lt;i表明目标元素一定还在右边，A_i&gt;i则表明目标元素在左边。</p>
<p><code> i  =    1   2   3   4   5   6   7   8   9   10<br>
A_i = -100 -20  -3   0   2   6  13  14  27  298</code></p>
<p><span id="more-1013"></span><br>
    另一个经典的变形则是分段有序队列中的二分查询。假如有这么一个数列，它可以分为前后两个部分，两段各是一个递增数列，并且后一段的最大值比前一段的最小值还要小。比如说，数列12, 15, 19, 3, 6, 7, 9, 10就是这样一个数列。这相当于是一个有序数列循环移动之后的结果。如何在这个数列中查询指定的元素呢？事实上，这种“有序序列”虽然经过了变形，但丝毫不影响二分法的应用，因为我们依旧能判断出目标值在当前值的哪一边（这是很显然的，我不多解释了），这就已经足够了。<br>
    不结合实际应用的话，这些似乎没有实用价值的理论会变得乏味。其实，只要仔细思考，生活中对应的现象总是有的。我的秘方就是，想不出例子就想MM，爱情的复杂性保证其蕴含了各种千奇百怪的数学模型。一想到爱情，分段有序队列就能用上了。不妨为恋爱前后的“愉悦程度”建一个简单的模型：在恋爱之前，你会为找不到MM而越来越难过；一旦开始热恋愉悦值瞬间达到极大；之后热情会慢慢减小，但愉悦值始终比恋爱前要大。好啦，如果你想出一道题的话，问题背景已经是现成的了，不妨再定义一个符合这个模型的且不能直接解出来的分段函数，编几句形如“科学家发现恋爱前的愉悦值以a减某某某的速度递减，恋爱后则变为曲线a加某某某”的话，然后就来看看有多少人还能想到二分法吧。一般说来，好的题目背景起到了一个很强的干扰作用：题目背景越顺理成章，问题描述越是简单，看清问题背后隐藏的算法障碍就越大。另外，如果你给的函数巧妙到还需要大家先证明它的单调及有界，那这题目就真的绝了。</p>
<p>    要比谁的题目更绝，那绝对比不过USACO。USACO月赛中的二分题是真牛B了。我对二分的热情是相当的高。为高一高二的几个人备战省选时，我出了好几套模拟题，前面四套题每套都有一道来自USACO月赛的二分题。这个二分题是越来越诡异，以至于大家越来越难看出这套题里面哪道要用二分了。<br>
    第一套题里的二分题是一个简单题：把一个长为N的数列划分为M段，要求每段数之和的最大值最小。例如，把100 400 300 100 500 101 400分割成5块，则100 400 | 300 100 | 500 | 101 | 400是最优方案之一，最大值500已经不能再小了，这个题一看就知道是二分后贪心判断，“最大值最小”之类的关键词几乎成了二分题的信号灯。像什么最小权值最大的完全匹配、瓶颈生成树问题（求最大边最小的生成树：二分后判断连通）、寻找权值波动最小的路径（找一条从A到B的路径使得所经过的边的最大权值和最小权值相差最小：枚举下界二分上界判断连通，滑动窗口更好），都是二分的经典问题。<br>
    第二套题中的二分也是“最大值最小”类的问题，只是要更复杂一些：在带权无向图中，选择一些边使得A、B两点连通，要求费用最小。费用是这样算的：先从图中选出K条边（K值是给定的），免费；然后从图中选择其它你需要的边，费用为这些边的最大权值。这个题里，选边过程的先后顺序有一个很强的误导作用。事实上，正确的算法应该是先二分这个最大权值，再来判断把K条免费边的机会用上能不能把A、B连通，换句话说就是要想把A、B连通还差的边数超没超过K。当时做这个题时，不少人二分法是想到了，但却怎么也想不到该如何计算最少还需要多少条边才能连通A、B两点。其实方法很简单，把不超过当前二分出来的那个“最大权值”的所有边权值设为0，其它边的权值设为1，然后找一下最短路就可以了。<br>
    第三次的二分题就不容易看出来了。给定一个有向图，每条边都有两种权值，时间和愉悦值。叫你寻找一条回路（不经过重复的边），使得愉悦值之和与时间总和之比最大。能想到这个题目是二分的话，那就真的很厉害了。二分最优比率C，然后给每条边设置一个新的权值，它等于C倍的时间减去愉悦值，再来判断是否有负权回路。这是怎么来的呢？不妨这样来看：对于任意一条回路，所求比率等于(Σ愉悦值)/(Σ时间)。如果二分出来的最优比率C偏小了，那说明满足(Σ愉悦值)/(Σ时间)&gt;C的回路多得是，移动一下便有C*(Σ时间)-(Σ愉悦值)&lt;0，即在新的权值设定下存在负权回路。如果没有负权回路的话，说明所有回路的比率都比C小，这就说明我们的C取大了。同样的思路也可以用来解决最优比率生成树问题。

    第四次的二分题可就是真的牛B大发了。假设有一个长度为N的数组A_i，里面的每个数都不一样。但是呢，你不知道数组里的数是多少。给出若干个形如“从A_i到A_j中的最小值是x”的命题，问你第一个和前面有矛盾的命题在哪里。例如，给你四个命题：A_1到A_10的最小值是7，A_5到A_19的最小值是8，A_3到A_12的最小值是5，A_11到A_15的最小值是4。第三句话显然是错的，否则前两个区间中至少有一个的最小值也达到了5。
    这个题难就难在，我们需要挖掘出“矛盾”的本质。究竟每一条命题给我们带来了什么信息呢？假设我告诉你，A_1到A_10的最小值是7，你仍旧不能推断出任何一个数，但有两点是肯定的：第一，这10个数里有一个数字7；第二，这里面的每个数都不能小于7。假设我们再给出一个A_5到A_19的最小值是8呢？此时，我们得知A_5到A_19里面有一个8，并且A_5到A_19的所有数都不小于8。注意！此时从A_5到A_10这一段中的数字下界升级了！由此得到启发，这些条件给出的信息说穿了就是每个位置可能出现的数的下界，它就是覆盖它的那些区间中的最大值。我们可以把区间端点排序，从左到右扫描一遍，用堆不断更新当前的最大值。在确定完每个位置可能的最小数后，我们开始寻找一个满足这些条件的解。由于数组中没有相同的数，因此对于所有回答“最小值为x”的区间，x必需出现在它们的交集中。如果这个交集为空，或者交集里面所有的位置（因下界过大）都不能取这个数，那么我们就可以肯定地说这一组条件是有矛盾的。如果我们顺利地给每个区间都安排好最小值所在位置，这立即说明了该组条件没有矛盾，因为我把其它那些没确定下来的位置取到无穷大，满足全部条件的数组就构造出来了。于是，我们有了一个O(nlogn)判断一组命题是否有矛盾的算法。
    这个题有趣就有趣在，上述算法虽然高效，但却只能判断命题组是否矛盾，不能检测矛盾首次出现的位置；而在线判断命题是否矛盾（一个命题一个命题地往里面加）反而要慢些。于是呢，二分答案就派上用场了：二分前面的无冲突命题的最大长度，然后用上面的O(nlogn)算法来判断看是不是有矛盾。

    然而，上面这些二分题都还太“正统”了一些。拼完了NOI之后，我便在网上自由潇洒地学习各种自己感兴趣的算法，看到了不少真正另类而绝妙的二分……
</p>
			 ]]></content>
<pubDate>2008-11-13T22:34:37+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1013</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Steffen可活动多面体 ]]></title>
<link>http://www.matrix67.com/blog/archives/1029</link>
<content><![CDATA[ 
		<p>    大家都知道，三角形具有稳定性。如果你把三根木条钉成一个三角形，则这几根木条是不能活动的。这是因为，根据三角形的SSS全等判定法则，两个三角形的三边长对应相等，则这两个三角形一定全等。但四边形就不是了，用四根一样长的木条钉成一个正方形，握着相对的两个角往两边一拉，正方形就变成菱形了。不知道大家想过没有，类比到三维空间中，多面体的稳定性又是怎样的呢？<br>
    Cauchy定理指出，如果两个凸多面体对应的面全等，那么这两个多面体全等。这告诉我们，任何一个凸多面体一定都是不可活动的。在Cauchy定理中，“凸多面体”这一条件是必需的。如果允许凹的多面体存在，对应面相等但整个多面体不全等的形状可以很轻易地构造出来。例如，想象立方体的某个面中心有一个小金字塔，这个金字塔既可以是向外凸的（就像表面上的一根刺），也可以是向内凹的（表面上的一个坑）；这是两个截然不同的多面体，但它们的对应面都是相等的。不过，这与我们的稳定性并没有关系，因为它并不是做连续的变形，而是直接一下就“跳”过来了。<br>
    很长一段时间，人们曾经猜想，不存在可以做出连续变形且保持所有面不变的“可活动多面体”(Flexible Polyhedron)。1978年，Connelly找到了第一个反例。他给出了一个由18个面组成的可活动多面体。</p>
<p><span id="more-1029"></span><br>
   <img alt="image placeholder" >
    Proofs from THE BOOK的第12章给出了Cauchy定理的一个非常精巧的证明，并在这一章末尾给出了一个更加简单的可活动多面体（上图），它是由Klaus Steffen构造出来的，只含有14个面和9个顶点，现在已经证明是“最简单”的可活动多面体。如果你按图中所标注的比例裁剪一张展开图，拼接成一个多面体的话，你可以捏着它的一条棱拽来拽去的玩。</p>
<p> <br>
  <img alt="image placeholder" >
<p>    你猜怎么着？我还就真做了一个！我把<a href="http://www.matrix67.com/data/steffen.pdf">这个pdf文件</a>打印在了一张稍微硬一点的纸上，然后按图示粘贴成了一个可活动的多面体。标了黑线的地方应该往外折，蓝线则应该往内折。做好后捏在手里玩了一下，嘿，还真他妈的可以动！</p>
<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/OH2kg8zjcqk&amp;hl=en&amp;fs=1">
<param name="allowFullScreen" value="true">
<param name="allowscriptaccess" value="always">
<embed src="http://www.youtube.com/v/OH2kg8zjcqk&amp;hl=en&amp;fs=1" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="425" height="344"></embed></object></p>
			 ]]></content>
<pubDate>2008-11-17T00:40:16+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1029</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 无限长的金属杆：理想模型带来的悖论 ]]></title>
<link>http://www.matrix67.com/blog/archives/1035</link>
<content><![CDATA[ 
		<p>    有些时候，数学模型和物理世界相结合可能会得出一些不可思议的悖论，<a href="http://www.matrix67.com/blog/archives/773">Gabriel喇叭</a>就是最经典的例子。这里，让我们来看另一个有趣的例子。</p>
<p>  <img alt="image placeholder" >
    假设有一个无穷大的桌面，上面垂直地树立着一根有限长的金属杆。在这根金属杆的顶端用铰链连接一根无穷长的金属杆。这根无穷长的金属杆可以绕着活动关节处上下转动。让无穷长的金属杆随重力自由活动。注意到夹角α绝对不可能小于90度，因为我们的金属杆和桌面都是理想刚体，它们不能相交、穿透。这样的话，α只可能是90度。于是，荒唐的一幕发生了：这根无穷长的金属杆平行地悬在桌面上空，但却只有端点处这一个支撑点。</p>
<p>来源：<a href="http://www.cut-the-knot.org/WhatIs/Infinity/InfiniteRod.shtml">http://www.cut-the-knot.org/WhatIs/Infinity/InfiniteRod.shtml</a></p>
			 ]]></content>
<pubDate>2008-11-19T00:44:47+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1035</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 假如宇宙是有界的…… ]]></title>
<link>http://www.matrix67.com/blog/archives/1037</link>
<content><![CDATA[ 
		<p>  <img alt="image placeholder" >
<p>    看完Proofs from THE BOOK的几何部分，我决定把书又放一放，开始阅读Infinity and the Mind。我承认我不该在当代文学史课上读这本书——读到第15页时，我看到了一段非常有趣的文字，竟然在课堂上放声大笑出来。不知道大家之前是否见过这个“思维实验”，我好像是第一次见到，它真的好搞笑。<br>
    历史上，不同的人对宇宙空间有着不同的见解。古罗马哲学家Lucretius认为，宇宙是无限的。让我们来看一看他的经典论证。假设宇宙是有限的。我们往宇宙的边界投掷一根标枪。则我们将看到以下两种情况之一：这根标枪穿过边界飞向远方，这说明宇宙并无边界，它是无限的；或者这根标枪一头装上宇宙边界停了下来，这说明边界外“有东西”挡住了标枪，同样说明宇宙是无界的。</p>
<p>Update: 其实我想说的是，笑点不是古人的论证与现代科学的差距，而是论证自身用到的二难性所带来的滑稽效果与逻辑推理出奇宏大的力量；正如证明上帝不是万能的（上帝能否创造一块连自己也举不起来的石头），或者大球小球落下去的速度一样快之类的思维实验，它们总是让人会心一笑。</p>
			 ]]></content>
<pubDate>2008-11-20T00:02:29+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1037</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 讲个故事：Saw V中的死亡谜题 ]]></title>
<link>http://www.matrix67.com/blog/archives/1053</link>
<content><![CDATA[ 
		<p>    严重剧透警告！！这篇日志涉及到Saw V的一个非常非常科学的twist，打算看Saw V但是还没看的同志们别进来！！<br>
    严重剧透警告！！这篇日志涉及到Saw V的一个非常非常科学的twist，打算看Saw V但是还没看的同志们别进来！！<br>
    严重剧透警告！！这篇日志涉及到Saw V的一个非常非常科学的twist，打算看Saw V但是还没看的同志们别进来！！</p>
<p><span id="more-1053"></span></p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    Ashley、Charles、Brit、Mallick和Luba醒来，发现自己身处Jigsaw精心安排的“生存竞争游戏”中。每个人颈子上都套了一个带锁的项圈，颈部正后方各有一个金属刀片。每个人的正前方五六步远的地方都有一个玻璃箱，箱子里有打开自己项圈的钥匙。五个项圈后面的金属链是互相连着的，每一次只允许其中一人向前走。游戏时间很短，时间不允许每个人都能拿到钥匙打开项圈。时间一到，五个项圈后面的链锁同时拉紧，没有取下项圈的人将被拽到刀片上。Mallick最先打破沉默冲了出去，触发了一分钟计时。最后，除了Ashley之外，其余人都顺利拿到钥匙。Ashley整个身体向后飞去，颈子卡在刀片上，脑袋像足球一样滚了下来。与此同时，通往第二个房间的门开了。剩下的人向第二个房间走去。Brit（一个乖MM）多了一个心眼，她把这一关的五把钥匙拾起，担心以后会用到。<br>
    关上房间入口的门后，计时器开始计时，第二个房间将很快爆炸。房间的四壁各有一个狭小的避难室。四个幸存者必需打破天花板上吊着的几十个玻璃瓶，找到三把钥匙。这意味着，其中有一个人将得不到钥匙，无法进入庇护室。最后，四个人中最有性格的光头男Charles没得到钥匙，被炸得满地是肠子。<br>
    三人进入第三个房间。关上入口的门后，又一个计数器开始计时，这个房间很快也会爆炸。他们看到房间正中有一个浴缸，里面有半缸子的水。房间里有五条电缆，它们都必须和浴缸里的水连通才能打开房间的出口。但五根电缆都太短，根本无法伸进浴缸。这意味着，必须要有一个人躺在浴缸中当作导体。Brit冷静地杀死Luba，和Mallick一起把尸体扔进浴缸，然后把四根电缆夹在她的四肢上，再用力挥动一根带金属钩的电缆，插进Luba的后脑勺。出口的门开了。Brit和Mallick进入第四个房间，关上大门，不久后第三个房间爆炸了。<br>
    最后一个房间同样会在15分钟后爆炸。Brit和Mallick看到五个透明的箱子，它们并排放置在一个半人高的桌子上。每个箱子正中都有一个高速旋转的电锯。每个电锯下方都有一个用于收集液体的烧杯。每个箱子的正前方都开了一个圆形的洞，刚好够一只胳膊伸进去。只有每个烧杯都充满液体后，出口的门才能被打开。<br>
    Mallick发现出口的门上有钥匙孔，于是提示Brit试试第一关的那些钥匙。不出所料，这些钥匙都打不开门。但同时Brit发现了一件奇怪的事情：五把钥匙竟然一模一样。她说到，为什么刚才是五根电缆，为什么这里有五个箱子？一瞬间她恍然大悟：这根本就不是一场关于弱肉强食、生存竞争的游戏。这是一场关于团队合作的游戏。在第一关中，只需要一个人拿到钥匙后直接传给其他人即可，因为大家的钥匙都是一样的。第二关中，一个避难室显然可以同时容纳两人，游戏规则让大家先入为主地认为一个避难室只能进去一人。第三关中，五个人可以共同充当导体，每人仅需承担五分之一的电压，这是不致命的。而在这里，如果每个人只献出一杯子血，逃出去了之后照样可以活蹦乱跳。<br>
    谜题解开后，Brit和Mallick决定两人各分担一半的血量。最后，Brit来到倒在地上的Mallick身边说，我们成功了。Mallick举起已被锯成树枝的小臂，神志不清地在地上扭动。最漂亮的Brit活着出来了。我心里很高兴。</p>
<p> <br>
 <br>
    昨天Saw V的TC版出了。作为一个忠实的Saw迷，我毫不犹豫地下载了下来，并且立即决定把它看了。最后的那个teamwork twist确实出人意料而在情理之中，是Saw系列里的又一个设计精妙的谜题——一组关于定势思维的死亡谜题。<br>
    但美中不足的是，头两个场景的设置似乎有些失败：第二关中“可容纳多人”这一点太明显了，让人有些不可接受；第一关里似乎也没有足够的机会或提示让人观察到钥匙的异样（虽然最后以钥匙的异样为线索猛然解开整个谜题是一段相当巧妙的情节）。为什么不在第一个录像带里面加上一句“There is only *one* key to this game”之类的话？<br>
    第三关是整套trap里面最科学的，中间差的那段距离正好就是一个人的体长，让人产生“只能一个人上”的定势思维；而“分担电压”这一点确实很不好想。第四个也很牛B，不过要是把设备改为一个正好能容纳一个人的身体的大型粉碎机（或者说把一个人扔进全是电锯的坑里），产生的定势思维将更强。至于前面两个呢，不妨大家自己来创造。你会发现你那可怕的想象力能想出多么恐怖恶心的东西。其实，一个人必死但五个人分担则没事，并且场景设置让人产生定势思维的trap还有很多很多。昨天晚上上床睡觉时我就想了一个：一人大的浓硫酸水池，要求液体必须溢出来。扔一个人进去必死，但事实上五个人把各自的胳膊放进去就足够了。</p>
<p>    浓硫酸在Saw III里已经玩过了？换成液态铝吧……</p>
			 ]]></content>
<pubDate>2008-11-21T18:03:50+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1053</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 睡觉也不歇息…… ]]></title>
<link>http://www.matrix67.com/blog/archives/1066</link>
<content><![CDATA[ 
		<p>   <img alt="image placeholder" >
<p>  来源：<a href="http://brownsharpie.courtneygibbons.org/?p=808">http://brownsharpie.courtneygibbons.org/?p=808</a></p>
			 ]]></content>
<pubDate>2008-11-22T01:05:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1066</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 漫话二分（下） ]]></title>
<link>http://www.matrix67.com/blog/archives/1057</link>
<content><![CDATA[ 
		<p>    很多问题并不完全符合二分的模型。最常见的一个情况估计应该是无穷长的有序队列中的二分查找问题。例如，前文所提到的求解x^x=a实际上就是这样的问题，这里x的取值范围可以是大于0的所有实数。当然，这里的x明显有一个上界，比如x明显要比a小。但是，如果有什么二分问题，它没有一个明确的上界呢？比如，我们再玩一次猜数游戏，我想一个数，然后告诉你你的猜测是大了还是小了。不同的是，我不告诉你这个数是在什么范围内选的，我想的数可以是任意一个正整数。那你该怎么办呢？最初的想法当然是，不断往大的猜，直到某个时候它超过了目标值为止；然后以它为上界，剩下的就可以看作有限多了。关键是，我们以什么样的跨度来枚举这个上界？首先必须肯定的是，这个上界枚举序列必须是发散的，否则会有数我们一辈子也猜不到；同时，线性增长的策略也是很傻的：跨度太小了你可能得到猴年才能找出上界，跨度太大了的话一来就确定了上界，但待考虑的队列也可能远远超过所需。一个比较灵活的想法是：按照1, 2, 4, 8, 16, …, 2^n的序列来猜测上界。这是一种“相对大小”的思想：既然连前面N个数都小了，我们也就不在乎那么一两个了，不妨直接再跳过N个数直接考察2N。这样的话，整个猜测过程仍然保持log(n)的复杂度，整个算法也更加美观一些。</p>
<p>    假如你有一台时光机，可以让你到任意远的未来去，你打算怎么来使用它？或许你会说，先去100年后看看，生活一年之后再去200年后体验体验，然后再去300年后生活一年，再去400年后生活一年……其实，这种线性的时光旅行并不科学。当你已经跨越了数千年以后，相比之下100年的跨度已经不算遥远了，1000年后与1100年后的差异远远没有今天和100年以后的变化那样令人震撼。我说我和<a href="http://kristallklareblase.spaces.live.com/">Stetson MM</a>的思维如出一辙，那不是说着好玩的。一次MSN聊天时我们讨论到这个话题，两人同时想到了这样的时间旅行方式：先直接跳到1年后生活，再到2年后生活一段时间，再到4年后，再到8年后……用这种方式来体验未来，即使我在每一个时间点停留一年，我也能保证见到从我余生的感情生活到人类文明的各种不可思议的形态，甚至到文明的轮回与宇宙的毁灭等各种尺度下的牛B事。我的确能够看到充分远的未来，了解到足够宏大的文明史和宇宙史：假设我还能活80年，那么我可以看到2^80=1208925819614629174706176年内的种种，这么多年里估计就是宇宙热寂也该结束了。<br>
    折纸后的高度、在棋盘里放米、Hanoi塔与世界末日……无数火星的例子告诉我们，倍增的力量是异常强大的。如果你不信的话，下次来北京时请我喝酒，不妨这样来试试：先我喝一杯，你喝一口；然后我喝一杯，你喝两口；然后我喝一杯，你喝四口……看咱俩谁坚持的久。</p>
<p><span id="more-1057"></span><br>
    倍增法有许多出乎意料的神奇应用。有兴趣的读者不妨去看一看<a href="http://en.wikipedia.org/wiki/Chan%27s_algorithm">Chan凸包算法</a>，这是我所见过的倍增法最诡异的应用。</p>
<p>    另一个不符合二分模型的相关问题是：如何寻找凸函数上的极大点？生活中的很多东西都是这样，大了也不好，小了也不好，不多不少的时候最好。我最喜欢举的例子是，粉笔短了不好写且用得快，粉笔长了又容易断；为了贯彻拿MM打比方的精神，这里可以再举一些例子来说明这一情况的普遍性：陪MM出去玩的次数多了很快会腻，陪MM次数少了又会疏远；把握火候贯彻“半糖主义”方针是非常重要的。事实上，从硬盘缓存的大小到初期农民的个数，从每学期的学分到论文的长度，生活中几乎所有东西都是这样，就连饭量和睡眠时间也是。这些例子说穿了就是一个单峰函数，我们需要用尽可能少的试验次数快速找到极大点。永远不要以为决策者们面对的都是高中数学考卷上的“每涨10块钱就会少100个消费者”一类的屁话，这些屁话都是用来编二次函数题目的。现实生活中企业做决策时，样点实验、不断取舍、逐步逼近最优点仍然是最实在最有效的手段。考虑到我们今天的话题，我们首先要做的是，想一个可以让规模层层递减的方法。这个办法貌似不错：从函数中选择两个点x、y（无妨假设x&lt;y），如果f(x)&lt;f(y)，那么去掉所有比x还小的部分；反之若f(x)&gt;f(y)，那么y点的右边都可以抛弃掉。不管这两个点是在极大点的同侧还是异侧，抛弃较小值那一侧都是正确的。另外，如果不巧f(x)=f(y)，这说明极大值一定在它们之间，去掉哪一边都是可以的。</p>
<p>   <img alt="image placeholder" >
<p>    问题的关键就是，每一次我们的x和y取在哪里最合适？或许有人会说，既然有两个点，那就对称地取在三等分处吧。这样的话，每次问题的规模都降低到原来的2/3。当然，更好的办法是把两个点都取到中点附近，相互之间的距离充分小；这虽然不那么美观，但每次的规模都将变为原先的1/2+ε，效率上说显然更好一些。最聪明的做法是，把x和y两点取在一对既不远也不近的合适位置上，使得其中一个点（比如y）被去掉后，x点所在的位置正好可以作为下一个测试点（于是每一轮新的实验就只需要取一个点了）。这种“循环利用”旧测试点的做法将更加节省资源。为了保证这一过程可以永远进行下去，我们希望让x在y点去掉后的那一段上的位置与y点原先在整段上所处的位置比例相同，用算式写出来就是y/L=x/y，即(L-x)/L = x/(L-x)，解出来x=(1±√5)L/2。神奇！黄金分割竟然出现在了这样一个意想不到的场合中！这就是所谓的“优选法”：不断在两个黄金分割点处进行测试，抛弃较次的测试点；由于黄金分割点的性质，另一个点仍然处于余下部分的黄金比例处，因此只需再对该小段的另一黄金分割点进行测试即可继续如此递归地操作下去。</p>
<p> <br>
 <br>
    二分的应用范围还很广。这里我们再举四个简单的例子，它们是二分法的各种极其特殊的用法。首先，我们来看看交互式问答题中的一个奇妙的二分。黑箱子中有一个竞赛图（任两点之间都有一条单向边）。询问两个顶点，返回它们之间的边的方向。请用尽量少的询问次数找出一条经过全部n个顶点的路径。</p>
<p>   <img alt="image placeholder" >
<p>    竞赛图有一个神奇的性质：经过所有顶点的路是一定存在的。换句话说，如果n个人之间两两进行比赛，假设比赛没有平局；那么我们一定能够给这n个人排出一个顺序，使得第一个人打败了第二个人，第二个人打败了第三个人，一直到倒数第二个人打败了最末一个人。这个证明是构造性的。从任意一条边出发，我们可以不断扩展出越来越长的链。假设现在我们已经有了一个长度为k的链，它们的节点分别是P_0, P_1, …, P_k。现在我们想把节点P_t加进来，使得这条链的长度达到k+1。注意到，如果有边P_t → P_0或者P_k → P_t，那就直接完事儿了。否则的话，我们必须要找出链中的一个P_i，使得P_i → P_t并且P_t → P_(i+1)，然后将P_t插到P_i和P_(i+1)中间。这样的P_i是一定存在的，因为此时P_0到P_t的边是正向的，但到了P_k时从链到P_t的边却变成逆向的了，这说明中间至少有从正向边变成逆向边这一步。换句话说，给你一个长度为k的01串，首位为0，末尾为1，那中间至少出现了一次子串“01”。<br>
    按照这种方法做，最坏情况下我们需要询问O(n^2)条边。这相当于把整个图都给你了。有更好的办法吗？有！我们可以用二分法寻找P_i，从而只需要O(nlogn)次询问即可得到答案。具体地说，每次需要寻找那个P_i时，我们二分P_i的位置：如果有P_i→P_t，则P_t一定能插入到P_i后面的部分；反之如果P_t→P_i，则需要寻找的目标节点一定在它前面。用01串来解释似乎更清楚一些：由于每个首位为0末位为1的子串都包含至少一个“01”，于是我们看中间那一位数。如果它是“0”，即可抛弃前面那一段；如果它是“1”，则后面那一段就可以不管它了。</p>
<p> <br>
    接下来，让我们看一看二分法在两个有序数组中的应用。在多个有序数组中查找指定的数不好玩，真正好玩的是在多个有序数组中查找指定序数的数。给你两个有序数组，如何快速找出第k小的数？合并两个有序数组将导致线性的复杂度，这里还有更好的算法吗？不啰嗦了，我直接给出答案：分别取两个数组正中间的那个数a和b，不妨设a≥b。两个数组被划分为四段，分别记作A1、A2、B1和B2。如果A1的长度与B1的长度加起来还没有k大，那所求数绝对不可能在B1里面（任选B1中的一个数，比它小的只有A1和B1各自的一部分数，数目远不到k）；反之如果len(A1)+len(B1)≥k，那么所求元素必然不在A2中（因为A1和B1里的所有数都比A2里的数小，而它们就已经有k个了）。对于两种情况，我们都可以将某个数组的长度减半，从而得到log级别的算法。</p>
<p><code>1 2 3 6 7 8 14 *16* 18 19 20 23 27 28 33<br>
||  a  ||<br>
 <br>
4 5 9 10 11 *12* 14 17 22 24 29<br>
||  b ||</code></p>
<p> <br>
    在竞赛题目中，大家见过最多的当属二分加贪心检测了。当然，偶尔也会遇到二分加最短路、二分加匹配、二分加网络流、二分加动态规划之类的题目。但是，大家有想过二分加二分的题目吗？前不久，我就见过这么一道“两次二分”的题目：给你n个数，这n个数两两的差值将产生n(n-1)/2个数。试求这n(n-1)/2个数的中位数。算法：二分答案加二分检测。先二分这个中位数，然后数一数比该数小的有多少，比该数大的又有多少，以确定这个“中位数”是取大了还是取小了。为了判断有多少个数比选定的中位数小，我们需要再一次使用二分：对于每一个固定的数A_i，二分A_j的位置，看A_i-A_j比中位数大还是小（j=1..i-1，假设数列已经有序）。假设n个数中的最大值为q，则算法的复杂度为O(n*log(n)*log(q))。</p>
<p>    有时候，二分的作用甚至根本就不是为了减小时间复杂度。某天在<a href="http://zhiqiang.org/blog/posts/introduction-communication-complexity.html">阅微堂</a>看到一个非常有趣的题目。假设有两台计算机，每台计算机上都存了一个长度为n的字符串。两台计算机之间的数据传输是非常昂贵的。因此，我们希望用最少的数据传输量来确定，哪台计算机上存储的字符串的字典序更大。<br>
    答案：一个基于概率的二分算法。两台机器各自算出前半段字符串的md5值，然后机器A把它的md5值传过来和机器B比。把比较结果传回去。若两个md5值不等，表明第一个不同之处一定在这里面发生，此时即可抛弃后面一半；若两个md5值相等则说明不同的地方一定在后面，前面这一半即可舍去。（补充一句，这里的“一定”并不是真的一定，md5判重是有概率因素的。）</p>
<p>    二分这个话题太有趣了，好玩的东西说也说不完。欢迎大家在下面留言，分享你所见过的最有趣、最奇妙、最不可思议的二分。</p>
			 ]]></content>
<pubDate>2008-11-22T18:05:50+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1057</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 八卦的学问：实现所有人消息共享最少需要多少通电话？ ]]></title>
<link>http://www.matrix67.com/blog/archives/1078</link>
<content><![CDATA[ 
		<p>    最近看到了一个有趣的问题Gossip Problem。假如我们班有n个MM，每一个MM都有一个独家八卦消息。两个MM可以通过电话联系，一通电话将使得双方都获知到对方目前已知的全部消息。要想所有n个MM都知道所有n条八卦消息，最少需要多少通电话？<br>
    一个最简单的办法就是从n个人中选一个消息汇总人，所有n-1个人都打电话给她，她再打电话给所有人。这样总共需要2n-2通电话。其实，汇总阶段的最后一通电话和发布阶段的第一通电话可以合并为一通电话，这样的话该方案实际上只需要2n-3通电话。打电话的次数还能更少吗？给出一个最优解，并证明这个数目已经不能再少了。</p>
<p> <br>
    显然，n=2时只需要一通电话，n=3时必须要3通电话。当n=4时，可以让AB互相通话，CD互相通话，此时每个人都知道了（包括自己的）两条消息；然后A和C通话，B和D通话，从而使得每个人都获知另外两条自己还不知道的消息。显然，对于4个人的情况，4通电话已经是最少的了。<br>
    对于n&gt;4的情况，有一种算法可以保证在2n-4通电话内解决问题。首先，选出4个人作为消息汇总人。其余每个人都选择一个汇总人并与之通话；然后4个汇总人再用4通电话互相更新一下消息（用刚才n=4的办法）；最后4个汇总人把电话再打回去，实现所有消息全部共享。下面我们证明，2n-4已经是最少的了。证明方法很多，也都很复杂。最常见的证明由Brenda Baker和Robert Shostak在1972年给出。</p>
<p><span id="more-1078"></span><br>
    证明的关键在于这个引例：如果我们可以在2n-5次电话以内达到要求，则整个过程中绝对不会有人在电话中听到对方八卦自己的消息。我们将用反证法来证明这一点。首先找出最小的n使得n个人可以在2n-5次通话中传遍消息。如果某个人G听到了自己的消息，表明整个过程中存在这么一条通话线路：(G – G<sub>1</sub>)(G<sub>1</sub> – G<sub>2</sub>)…(G<sub>r</sub> – G)。现在，我们把G这个人去掉，再重新安排一些通话线路，使得剩下的n-1个人同样能在2(n-1)-5次通话后传遍信息，从而与n的最小性矛盾。直接忽略上述“通话环”中的(G – G<sub>1</sub>)和(G<sub>r</sub> – G)两条边。对于其他某个人P和G之间的通话(P-G)，找出(P-G)通电后最先出现的“通话环”中的其中一链（比如(G<sub>i</sub> – G<sub>i+1</sub>)）。在新方案中，让P把电话打给G<sub>i</sub>。这样，原方案中任何一条由P<sub>1</sub>带给G再带给P<sub>2</sub>的消息，都由对应的G<sub>i</sub>、G<sub>j</sub>以及他们之间的链条来完成，即(P<sub>1</sub> – G<sub>i</sub>)(G<sub>i</sub> – G<sub>i+1</sub>) … (G<sub>j</sub> – P<sub>2</sub>)。新方案与原方案一样满足要求，且通话次数减少了两次，同样小于等于2n-5。</p>
<p>    每个人都不会听到自己的消息，这可以推出一个很有趣的东西：记一通电话的双方为A和B，则要么A和B都还没打完，要么这通电话对双方来说都是最后一通。原因很简单，假如这通电话是A的最后一电，这表明A和B都知道了所有的消息，但B还要给别人打电话，别人就会听到自己的消息。类似地，一通电话的双方要么都是第一次打，要么都不是第一次打：假如A的第一通电话是跟B打的，但B之前已经和C通过话了，那A的消息将永远与C的消息一起传递，因此最终C听到A的消息时也会听到她自己的。<br>
    于是，对于所有电话次数不超过2n-5的情况，n只能是偶数。并且情况只可能是这样：先两两配对拨打n/2通“处女电”，然后中间打很多“中介电话”，最后再两个两个地打n/2个“最后一电”。由于所有的“处女电”和“最后一电”加起来恰好有n通，那么“中介电话”最多只能有n-5通。又由于连通所有n个点至少要n-1条边，可知这些“中介电话”构成了至少5个连通分量。对于任何一个人来说，在任何“最后一电”拨打之前，她的消息最多只能够在其中两个连通分量内传递（她所在的连通分量和她“处女电”的对象所在的连通分量）；类似地，所有“处女电”都打完了后，每个人都只能收到两个连通分量内的消息（她自己的和“最后一电”的对象的）。对于一个特定的人G来说，除去她自己、“处女电”的对象和“最后一电”的对象所在的连通分量，至少还有两个连通分量，里面的所有“中介电话”对她没有任何意义：这些“中介电话”既不会把她的消息传出去，也不会把别人的消息带给她。设与G不相干的电话通数为c(G)。<br>
    反过来，又有多少通电话与G有关呢？让我们继续把目光停留到G身上。要想把她的消息传给所有人，至少需要n-1通电话；要想让所有消息都传到她那里，同样也得要n-1通电话。某些电话可以同时起到这两种作用，但有一个前提条件：这些电话必需是她亲自打的。否则，她自己的消息将“捆绑”进那些将会传给她的消息里，从而与引理矛盾。假设她自己打了v(G)通电话，那么总共有2n-2-v(G)通电话负责传出她的消息并把别人的消息传给她。由2n-5 ≥ 2n-2-v(G)+c(G)可知v(G) ≥ 3+c(G) ≥ 3。既然每个人都打了至少3次电话，这表明每个人都打过“中介电话”，直接推出每个连通分量都有至少一条边。前面说了，c(G)包含了至少两个连通分量中的所有边，因此c(G)≥2。因此，v(G)≥5。每个人都打了至少5次电话？这当然是不可能的，这将导致总的电话数目比2n还大了。</p>
			 ]]></content>
<pubDate>2008-11-26T01:03:29+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1078</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用正则表达式判断一个二进制数是否能被3整除 ]]></title>
<link>http://www.matrix67.com/blog/archives/1089</link>
<content><![CDATA[ 
		<p>    我们之前已经见过了<a href="http://www.matrix67.com/blog/archives/475">正则表达式的一些很特殊的用法</a>。这里我们再来看一个：用正则表达式判断数的整除性。例如，下面这个表达式可以匹配01串S当且仅当S是一个可以被3整除的二进制数。</p>
<p><code>^1((10*1)|(01*0))*10*$</code></p>
<p>    如果你不信的话，不妨把下面这段代码粘贴进浏览器的地址栏，然后回车运行一下：</p>
<p><code>javascript:alert(/^1((10*1)|(01*0))*10*$/.test("1000000100"))</code></p>
<p>    被test的是516的二进制表达。516可以被3整除，因此程序返回true。你可以自己把1000000100换成其它的二进制数试试。<br>
    但是呢，从这个正则表达式里我们竟看不出任何端倪。奇怪了，为什么这个正则表达式可以用于判断整除性？能被3整除的二进制数究竟有何规律？</p>
<p><span id="more-1089"></span></p>
<p> <br>
 <br>
    其实，能被3整除的二进制数并没有什么明显的规律。这个正则表达式的求法可以说是相当暴力的。这一切的谜底很简单——判断一个数的整除性能轻易地用有限状态自动机实现，而有限状态自动机又可以翻译成正则表达式。</p>
<p>  <img alt="image placeholder" >
<p>    注意到，一个二进制数后面加一个“0”相当于该数乘以2，一个二进制数后面加一个“1”相当于该数乘2加1。设定三个状态，分别叫做0、1和2，它们表示当前的数除以3所得的余数。如果对于某个i和j，有i*2≡j (mod 3)，就加一条路径i→j，路径上标一个字符“0”；如果i*2+1≡j (mod 3)，则在路径i→j上标记“1”。状态0既是我们的初始状态，也是我们的最终状态。我们的自动机就做好了。现在，假如二进制数10010走进来了。从状态0出发，机器首先读到一个“1”，于是当前位置挪到状态1，表明目前该数模3余1；然后，系统读了一个“0”，我们紧跟着走到状态2，表明二进制数“10”被3除余2；下一步，我们回到状态1，表明“100”除以3余1；再往后，我们得知“1001”能被3整除。最后呢，我们读到一个0，“1001”的两倍当然还是能被3整除，我们依旧停留在原位。我们得到结论：二进制数10010能被3整除。<br>
    有限状态自动机是可以转化为正则表达式的。上面的这个自动机转化起来非常容易。我们可以先试着用自然语言叙述一下。首先，每个二进制数第一位必然为“1”。到达状态1后，我们可以随意地、任意多次地在状态1周围绕圈圈，最终回到状态1。临近末尾，我们再读到一个“1”返回状态0，这之后随便读多少个“0”都可以了。现在问题分解为：我们又如何用正则表达式表述“从状态1出发随意地走最终回到状态1”呢？在本例中，这是很好描述的：它可以是字符串“1000..001”和“0111..110”的任意组合。把这些东西用正则表达式写出来，就是我们刚才那个神秘的式子：1((10*1)|(01*0))*10* 。<br>
    从原理上说，我们可以这种方法求出任意进制下用于任意数的整除性判断的正则表达式。只不过，它们所对应的自动机都更加复杂，从而得出一长串令人眼花缭乱的表达式。本文开头我把1((10*1)|(01*0))*10*的来源作为一个有趣的问题提出来，因为这个式子恰好不长，让人很难想到这背后藏有一个普适的暴力算法。</p>
<p>强大的“反引用”：<a href="http://www.sxnsx.com/niubility-regular-and-divisibility-deciding/">http://www.sxnsx.com/niubility-regular-and-divisibility-deciding/</a></p>
			 ]]></content>
<pubDate>2008-12-01T06:27:28+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1089</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 征税到底亏了谁？简单数学背后的经济学原理 ]]></title>
<link>http://www.matrix67.com/blog/archives/1094</link>
<content><![CDATA[ 
		<p>    某日，在<a href="http://zhiqiang.org/blog/posts/test-on-probability.html">阅微堂</a>看到一句非常深刻的话：“所有大学生都应该学的两门课程，一是经济学，二是概率论；这两门课分别代表着一种生活中的思维方式。”每一个学过经济学和概率论的人都明白，这句话概括得太贴切了。这两门课程其实都是一种关于生活的学问，它们都是用简单的理性思维和数学方法解释各种奇怪的现象，对未来的事件进行预测。<br>
    可惜我对经济学了解不多。在经济学方面，唯一看过的书是一个MM给我推荐的《牛奶可乐经济学》。这本书里用一些理性思维揭示了生活中一些反常现象的根本原因。看完后我只是会心一笑，但还未对经济学产生极大的兴趣；毕竟这本书更注重于生活现象的理性思考，科学程度上远没有达到经济学本来所具有的水平。<br>
    后来呢，身边的人都开始学习经济双学位。每次好友上完课后都会兴冲冲地跑过来，在纸上画着各种图形，给我演示各种牛B的经济学原理。可惜他讲得太快，我没怎么听明白。今天没事翻了一下他们那本经济学原理的教材（曼昆写的那本），顿时后悔没去选经双了。同许多国外教材一样，这本书深入浅出，读起来饶有兴趣，完全可以当作科普读物甚至小说来看。经济学真的是一门有趣的学问，你可以看到经济学家们如何利用简单的数学知识推导出一些不可思议的结论。在这里我写一些简单的例子，希望能够让大家喜欢上这门学科。</p>
<p><span id="more-1094"></span><br>
 <br>
  <img alt="image placeholder" >
<p>    我们还是从需求量与供给量开始说起。按照以往的传统我会用MM或者A片来举例子，但这里我害怕由于MM市场或者A片市场的特殊性，某些结论并不适用，不妨还是用曼昆书上的例子——冰淇淋——好了。与众多其它市场一样，冰淇淋市场的需求曲线与供给曲线是正好相反的。和所有消费者一样，我可能每两个月才去一次哈根达斯，但我可以天天都吃可爱多。当冰淇淋的价格增加时，越来越多的消费者觉得吃冰淇淋的享受不值这么多钱，从而退出了消费市场，于是市场的总需求量越来越低。反之，冰淇淋的价格越低，能够提供冰淇淋的生产商也越少，因为越来越多的卖者认为他们没有赚头，从而退出市场竞争。两条曲线有一个交点，这个交点叫做市场均衡。对应的价格叫做市场均衡价格，对应的数量则叫均衡数量。在均衡价格下，买者的需求与卖者的供给数量正好相当，市场上的每个人都得到了满足。若市场价不等于均衡价格时，供给数量和需求数量将不再平衡；供不应求将导致价格上涨，供大于求则价格下跌，最终还是会自发地调整到均衡价。<br>
    现在呢，有趣的事情发生了。假设有一个地方具有相当浓厚的冰淇淋文化，该地政府打算举办一个年度冰淇淋节。为了筹到这项活动的经费，政府决定：卖方每卖出一个冰淇淋，政府就向卖者征收0.5美元的税收。于是，各大冰淇淋制造商上街游行，宣称这个税收应该由买者支付。而消费者协会则声援政府，坚持认为这部分税收应该由冰淇淋生产商支付。两大游说集团吵成一团。为此，我们不妨仔细研究一下，如果这部分税收由消费者来承担的话，会发生什么奇特的事情。</p>
<p> <br>
  <img alt="image placeholder" >
<p>    假设政府向消费者征税。消费者自然会决定自己亏大了：每买一个冰淇淋还要多付0.5美元。由于消费者并不关心市场价格，只关心自己的实际支出；因此，如果原本我能接受两块钱的冰淇淋，现在我只愿意接受一块五的了，因为我还得额外支付0.5的税。换句话说，需求曲线向下移动了0.5个单位。新的需求曲线与供给产生了新的交点，市场的均衡数量变少了，市场均衡价也降低了。假如说，没有税收时市场均衡价为3.0美元，现在的市场均衡价为2.8美元。但消费者要交0.5美元的税，因此消费者支付的实际价格是3.3美元。我们可以看到，政府若向消费者征税，则卖方损失了0.2美元的收益，买方则多付出了0.3美元。这0.5美元的税收实际上是由双方共同承担的。究竟哪一边分担得多些，这由两条线的斜率决定。上个世纪美国曾经大规模地向消费者征税奢侈品消费税。因为政府觉得，买奢侈品的都是富人，因此对奢侈品征收消费税其实是非常巧妙地变相向富人多征一些税。殊不知，奢侈品不是生活必需品，只要价格抬高一点，便有大量的消费者退出市场，反正有的是地方花钱，买点房子啊出去旅游啊实在得多。反过来，奢侈品的供给曲线则非常的陡，即使价格变化很大，产量变化仍然不大，毕竟生产制造奢侈品需要用到很多时间、人力和设施，这些既定因素使得生产商无法快速应对市场需求变化。可见，需求曲线比供给曲线要“平”得多。结果呢，明明是向买方征税，税收反而几乎都由生产者承担；而这些生产者并不是富人，奢侈品税收的重担落在了中产阶级身上。政府的决策适得其反。</p>
<p> <br>
 <br>
  <img alt="image placeholder" >
<p>    别着急，冰淇淋的故事还没讲完呢。我们再来看看，如果果真向生产商征税，结果又如何呢？显然，生产者必然会觉得自己亏了，原本可以卖两块钱，现在卖了后只能得一块五了。因此，要想弥补这0.5美元的损失，卖方只接受比原来高0.5美元的市场价格。其结果是，供给曲线上升了0.5个单位，从而使得市场均衡价从3.0美元增加到了3.3美元。但这3.3美元并不全部归卖方，卖方要交给政府0.5美元的税，因此事实上卖方只能得到2.8美元。结果呢，向生产者征税的效果与向消费者征税的效果完全一样。搞了半天，最开始两边在那里拼了命地争论，结果完全没有必要——不管向谁征税，结果都是一样的。</p>
<p>    目前为止我们看到的都非常和谐：政府要办活动，于是决定征税；不管向哪边征税，费用都是由双方共同分担；这相当于双方共同出钱办了一个活动。但事实上真的如此吗？我们来看一看，在征税之后，买卖双方各自的收益如何。在这里，我们要先看看，双方在交易中都获得了什么。<br>
    只有当你认为，这个商品对你的价值（你的心理价位）不小于它的实际价格时，你才会购买这个商品。此时，你觉得你获益了，因为你以较低的价钱获得了更高的实际价值。但是呢，同样一个东西对于不同人来说，心理价位是不相等的。于是，市场价格每下降一点，原本就愿意交易的人今后将获益更多；同时会出现新的一批人，他们愿意以该价格再买一个冰淇淋；这部分新加入市场的交易数量用需求曲线来衡量。当市场规模足够大时，需求曲线上的每个位置都有大批的消费者，所有消费者的总收益就是需求曲线之下均衡价格之上的那块三角形面积。类似地，卖方的目的就是以高于成本的价格卖出商品，供给曲线之上市场价之下的那部分面积就是卖方获得的利益。</p>
<p> <br>
  <img alt="image placeholder" >
<p>    如果政府征税，那么市场的均衡数量将减小，于是买方将支付更多，同时卖方将获得更少。在税收以前，A、B、C的面积是买方的总获利，卖方获利大小则为D、E、F的面积和；但一旦征税，全体消费者的获利之和只有面积A，卖方的总利润则为面积F。B、D的面积（税额×均衡数量）则归政府所得。但是，有一部分消费者（面积C）和一些生产者（面积E）的收益却凭空消失了。他们既没增加政府的税收收入，也没为自己赢得利益，而是直接退出了市场。看来，政府为筹办冰淇淋节而征税也并不是什么和谐的决策。<br>
    政府征税必然使得市场的总收益减小。这就叫税收所带来的无谓损失。</p>
			 ]]></content>
<pubDate>2008-12-02T11:48:59+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1094</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 最牛的图纸：Escher网格 ]]></title>
<link>http://www.matrix67.com/blog/archives/1103</link>
<content><![CDATA[ 
		<p> <img alt="image placeholder" >
<p>    Escher在创作上面这幅画时曾经做了一张草图。受此启发，Steve Witham绘制了下面这张图纸。在这样的图纸上作图要有多牛B就有多牛B。假如以左下角的那个小圆点为(0,0)，曲线y=1走着走着就变成y=1/4了，而x=1则慢慢变为了x=4。</p>
<p><span id="more-1103"></span><br>
<img alt="image placeholder" >
<p>图纸源文件：<a href="http://www.tiac.net/~sw/2005/05/escher_grid_2/escher_grid.ps">http://www.tiac.net/~sw/2005/05/escher_grid_2/escher_grid.ps</a><br>
来源：<a href="http://www.tiac.net/~sw/2005/05/escher_grid_2/index.html">http://www.tiac.net/~sw/2005/05/escher_grid_2/index.html</a></p>
			 ]]></content>
<pubDate>2008-12-05T02:04:15+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/1103</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
</channel>
</rss>
