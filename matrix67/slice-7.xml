<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Matrix67: The Aha Moments</title>
<description></description>
<link>http://www.matrix67.com/blog</link>
<pubDate>2021-11-20T14:45:25+08:00</pubDate>
<!-- other elements omitted from this example -->
<item>
<title><![CDATA[ UyHiP趣题：拉灯游戏总有解吗？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4263</link>
<content><![CDATA[ 
		<p>    某公司有 n 间办公室。每间办公室都有一盏灯，拉动它的开关即可改变电灯的状态。某些办公室之间存在“业务相关”的关系（这是一个对称的关系）。一个办公室可以和 0 到任意多个办公室相关。愚人节那天，有人在大家上班之前偷偷对办公室的电灯开关做了手脚：拉动任何一个办公室的电灯开关，都会同时改变该办公室以及所有相关办公室的电灯状态。初始时，所有灯都是关着的。证明：等到大家来上班后，总能用有限次的开关，最终把所有办公室的灯都打开。</p>
<p><span id="more-4263"></span></p>
<p> </p>
<p>    证明：对 n 施归纳。只有一间办公室时，结论显然成立。下面假设我们已经有办法让任意 n-1 个办公室的灯全部打开。如果把其中某 n-1 个办公室的灯全打开后，发现剩下的那个办公室的灯正好也亮了，问题就解决了。否则，我们就相当于有办法同时改变任意 n-1 个办公室的电灯状态（并且不对剩下的那个办公室造成影响）。</p>
<p>    考虑这样的操作：先改变除了办公室 A 以外的所有办公室的电灯状态，再改变除办公室 B 以外的所有办公室的电灯状态。这样下来的结果就是，只有办公室 A 、 B 的电灯状态真的被改变了，其它办公室的电灯状态又都变了回去。也就是说，我们可以同时改变任意两个办公室的电灯状态了（并且不影响其它办公室）。</p>
<p>    如果 n 是偶数，两个两个地把它们的灯打开，问题直接就解决了。麻烦的就是，如果 n 是奇数的话，该怎么办呢？要是有一个办公室正好有偶数个相关的办公室就好了，这样的话就可以先拉下它的开关，剩下灯没亮的办公室正好偶数个，问题也就解决了。下面我们就证明，如果 n 是奇数，那么一定存在一个办公室，它正好有偶数个相关办公室。</p>
<p>    注意到，把所有办公室的相关办公室数加起来，结果一定是一个偶数（因为每个相关关系都被算了两次）。但是，我们一共有奇数个办公室，如果它们各自的相关办公室数目都是奇数，加起来也还是个奇数。因此，至少有一间办公室，它有偶数个相关办公室。这就完成了整个证明过程的最后一环。</p>
<p>问题来源：<a href="http://www.brand.site.co.il/riddles/201103q.html">http://www.brand.site.co.il/riddles/201103q.html</a></p>
			 ]]></content>
<pubDate>2011-04-02T19:31:29+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4263</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ UyHiP趣题：如果每个人都随大流，结果会怎样？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4270</link>
<content><![CDATA[ 
		<p>    一个公司里有 n 个员工，其中某些员工之间有“好友”的关系（这是一个对称的关系）。每天早晨来到公司，员工们都会从茶和咖啡中选择一样作为早饮。此时，每个员工都会观察自己的朋友们都在喝啥：如果超过一半的人都在喝茶，第二天他自己也会跟着喝茶；如果超过一半的人都在喝咖啡，第二天他自己就会跟着喝咖啡；如果喝茶喝咖啡的人数各占一半（仅当他有偶数个朋友时才会发生这种情况），则第二天他的决策不变，继续喝自己今天喝的东西。<br>
    由于 n 个员工一共只能产生 2<sup>n</sup> 种不同的早饮组合，因此总有一天大家喝的东西会和过去的某一天一模一样，从而产生循环。证明：循环的长度不超过 2 。</p>
<p><span id="more-4270"></span><br>
    我们用一个图论模型来描述这个问题，每个员工都用图里的一个顶点来表示。所不同的是，尽管这是一个无向图（朋友关系是对称的），但在下面的证明中我们仍然使用了有向图的模型。对于两个互为好友的顶点 x 和 y，我们同时添加从 x 到 y 的有向边，以及从 y 到 x 的有向边。<br>
    对于每一个有奇数个好友的员工，他的决策都很简单：昨天大多数好友都喝的啥，今天他就喝啥。但是对于有偶数个好友的员工，决策就没有那么容易描述了。妙就妙在这里：我们给所有有偶数个好友的员工添加一个从自己出发指向自己的自环，让他的出度入度也都是奇数。这样一来，当喝两种饮料的好友各占一半时，他自己的决策会打破平局；而当喝两种饮料的好友数量不同（至少相差 2）时，算上自己喝的也不会改变结果。因此，对于有偶数个好友的员工，决策变得和其他员工也一样了：他所指向的顶点昨天喝什么的更多，他今天就喝什么，不必担心有平局现象发生。</p>
<p>    如果员工 x 和员工 y 是好朋友，并且第 i 天 x 喝的饮料与第 i + 1 天 y 喝的饮料相同，我们就说第 i 天员工 x 影响了员工 y。注意，那些有自环的人要把自己看作自己的朋友，因此自己影响自己也是要算的。那么在第 i 天，图里一共有多少条“影响边”呢？如果 x 的好友中，第 i+1 天里有 t<sub>i+1</sub> 个人喝茶，有 c<sub>i+1</sub> 个人喝咖啡（记住， t<sub>i+1</sub> 一定不等于 c<sub>i+1</sub> ），那么从 x 出发的影响边数量就是 t<sub>i+1</sub> 或者 c<sub>i+1</sub> （取决于第 i 天 x 喝的什么）。遍历所有的 x 求出总和，就是图里总的影响边数量。</p>
<p>    在第 i+1 天，图里有多少条影响边呢？我们现在换一个方法，从“被影响”的角度来计算影响边的数量。对于 x 来说，指向他的影响边数目显然是 t<sub>i+1</sub> 和 c<sub>i+1</sub> 的较大值，因为按照规则，他在第 i+2 天喝的饮料应该与第 i+1 天多数人喝的一样。遍历所有的 x 求出总和，就是图里总的影响边数量。注意，影响边的数量不可能变少了，因为刚才我们累加的是 t<sub>i+1</sub> 和 c<sub>i+1</sub> 之一，但这次我们累加的是 t<sub>i+1</sub> 和 c<sub>i+1</sub> 的较大值。</p>
<p>    但是图里的影响边数量不可能一直在严格增加，因为它不可能超过图里的总边数。因此，总会有一天，图里的影响边总数和前一天相等。而考虑前面的证明过程，这就意味着，对于每个员工 x 来说，昨天从他出发的影响边数量和今天指向他的影响边数量取的是 t<sub>i+1</sub> 和 c<sub>i+1</sub> 中的同一个数，即昨天他影响的那些人，也就是今天影响了他的人。换句话说，昨天他喝的东西，和明天他要喝的东西一样。因此，循环长度不超过 2。</p>
<p>题目来源：<a href="http://www.brand.site.co.il/riddles/201102q.html">http://www.brand.site.co.il/riddles/201102q.html</a></p>
			 ]]></content>
<pubDate>2011-04-04T23:24:29+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4270</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Arrow不可能性定理：独裁是唯一完美的选举制度 ]]></title>
<link>http://www.matrix67.com/blog/archives/4279</link>
<content><![CDATA[ 
		<p>    由于某些原因，最近在整理以前的日志。偶然翻到<a href="http://www.matrix67.com/blog/archives/3537">这篇日志</a>时，顺便在 Wikipedia 复习了一下 Arrow 不可能性定理的证明，惊奇地发现这个定理的证明过程非常困难但又非常初等，是一个门槛很低、老少咸宜的思维游戏。虽然不少人都翻译过 Wikipedia 上的这段证明，但我也想自己写一个自己的理解，一来做个笔记，二来也锻炼一下自己的表达能力。</p>
<p>    Arrow 不可能性定理是一个与选举制度有关的定理。选举制度，说穿了就是把所有选民的意见综合成一个全体意见的算法。选民的意见，无非是候选对象在心目中谁优谁劣，完整地反应在选票上，就是候选对象们从优到劣的一个顺序；形式最完整的全体意见，也就是候选对象的这么一个排列。因此，我们可以把整个选举制度想像成一个函数，输入 n 个排列（相当于 n 张选票），将会输出一个排列（相当于选举结果）。对输入数据的任何一处小改变，都有可能导致输出结果随之变化。作为一个合理的选举制度，它必须满足一些起码的要求。我们提出两个最基本的选举制度要求：</p>
<p>      1. 如果每张选票都认为 X 比 Y 好，那么投票结果中 X 的排名也必须比 Y 更靠前；<br>
      2. 如果每张选票中 X 、 Y 的相对排名都不改变，那么投票结果中 X 和 Y 谁先谁后也不能变。</p>
<p>    我们将证明，同时满足上述两个条件的选举制度只有一种，就是选举结果唯一地由其中某个选民的选票决定。也就是说，独裁是唯一一种完美的选举制度。为了简便起见，让我们假设候选人只有 A 、 B 、 C 三个人。你会发现，下面的证明过程很容易扩展到多个人的情况。</p>
<p><span id="more-4279"></span><br>
    假设每张选票都把 B 放在最后一名。也就是说，每张选票都认为， A 比 B 好， C 也比 B 好。根据条件 1 ，最终投票结果中也应该满足， A 和 C 都排在 B 前面。也就是说，投票结果里 B 也是最后一名。现在，让我们按照一定的顺序依次把每张选票里的 B 从最后一名挪到第一名的位置上去，同时不断关注在改票过程中选举结果的变化。当所有的票都改完了后，根据同样的道理，投票结果中 B 自然就排到了第一名。因此，在改票的过程中，一定存在这么一个人，改完他的选票后，投票结果中 B 的名次靠前了（从最后一名升了上来）。我们把这张选票叫做“枢纽选票”。</p>
<p>    接下来的证明分成四个大步骤。我们第一步要证明的就是，在改票过程中，改完这张枢纽选票，投票结果中 B 的名次将会直接从最后一名一下子升到第一名。反证，假如此时 B 没有跑到投票结果的第一名去，那么投票结果要么是 A 、 B 、 C ，要么是 C 、 B 、 A 。不妨假设是 A 、 B 、 C 吧。现在，把每张选票中 C 的名次都改到 A 前面（ C 本来就在 A 前面的那些选票就不用改了）。按照条件 1 ，最后的结果里 C 也应该跑到 A 的前面去。但同时，由于此时每张选票都把 B 列于第一名或者最后一名，调整 A 和 C 的顺序不可能影响到 B 、 A 之间的相对顺序，以及 B 、 C 之间的相对顺序，因此由条件 2 ，结果里 B 、 A 的相对排名和 B 、 C 的相对排名是不能变的。这就矛盾了：我们绝不可能在不改变 B 、 A 的相对位置以及 B 、 C 的相对位置的情况下，把投票结果 A 、 B 、 C 里 A 和 C 的位置互换。因此，把那张枢纽选票中的 B 提到第一名，一定让投票结果中的 B 也直接跑到了第一名去。</p>
<p> <br>
    注意，枢纽选票的产生是有前提的：它要从某个满足“每张选票里 B 都排最后”的情形开始，再按照一定的顺序把选票里的 B 都改成第一名，在此过程中才能产生对应的枢纽选票。如果具体的初始情形不一样，枢纽选票还一样吗？答案是肯定的。在第二步，我们要证明的就是，只要满足每张选票都把 B 放在最后一名（不管选票的具体内容是什么），并且按照同样的顺序进行改票，枢纽选票总会是同一张。</p>
<p>    这个原因很简单，关键就在于，我们总是把每张选票里的 B 从最后一名提到第一名。即使换一个不一样的初始情形，在改票过程的每一个时刻，每张选票里 B 和 A 、 B 和 C 之间的相对排名也都和原来一样，因而投票结果中 B 和 A 、 B 和 C 之间的相对排名也和原来一样。因此，投票结果里 B 的位置仍然会在同一个时候发生变化，枢纽选票还是同一张。</p>
<p> <br>
    在第三步里，我们要证明的是，这张枢纽选票有一个非常牛的性质：在<strong>任何情形</strong>下，它都能独裁 A 、 C 之间的相对排名。也就是说，这张枢纽选票认为 A 比 C 好，投票结果里 A 就一定比 C 好；反过来，它说 C 比 A 好，投票结果里 C 就比 A 好；并且此性质不依赖于任何前提条件，即使 B 不在各选票中的特殊位置，结论同样也成立。现在，我们就考虑<strong>任意一组</strong>选票，无妨假设其中枢纽选票里 A 比 C 靠前，我们将证明投票结果中 A 也是排在 C 前面的。证明的思路是，对各选票进行一系列不涉及 A 、 C 间相对排名的修改，从而看出投票结果里 A 在 C 前面。我们先把所有选票中的 B 都排到最后一位去，注意，这一步不会改变投票结果中 A 、 C 的先后顺序，但却让前面的结论得以适用。然后，我们把枢纽选票之前的所有票里 B 的位置都挪到最前面，由前面的结论，结果中的 B 仍然处于最后一位（因而 A 位于 B 前面）。接下来，我们把枢纽选票（它应该是 A 、 C 、 B 的顺序）改成 A 、 B 、 C ，由于这张票中 A 、 B 的相对位置没变，因此结果中 A 、 B 的相对位置也没变， A 仍然在 B 前面。接下来，我们把枢纽选票改成 B 、 A 、 C ，由前面的结论，此时结果里的 B 跑到了最前面（因而排到了 C 前面），但把枢纽选票从 A 、 B 、 C 改成 B 、 A 、 C 时并没有改变 B 和 C 的相对位置，因此刚才的投票结果中 B 也应该在 C 的前面。也就是说，枢纽选票是 A 、 B 、 C 时，投票结果里 A 在 B 前， B 在 C 前，也就是说 A 排在 C 前面。但上述所有修改都不会改变任何一张选票里 A 、 C 的相对排名，因此投票结果中 A 其实自始至终都在 C 前面。这就证明了，投票结果里 A 、 C 的相对排名完全取决于这张枢纽选票，不管其它选票是什么样的。</p>
<p> <br>
    最后一步证明就是，这张选票不但独裁了 A 、 C 的相对排名，它直接独裁了所有人的排名。原因很简单：按照之前的推理，还会有一张独裁 A 、 B 相对排名的选票，另外还有一张独裁 B 、 C 相对排名的选票；但一山不容二虎，这三个独裁者只能是同一个人，否则一个人说左一个人说右，就会立即产生矛盾。具体地说，首先，这三个独裁者肯定不可能是三个不同的人，否则 A 、 B 的独裁者说 A 比 B 好， B 、 C 的独裁者说 B 比 C 好， A 、 C 的独裁者说 C 比 A 好，投票结果就得同时满足 A 在 B 前、 B 在 C 前、 C 在 A 前，这是不可能的。这三个独裁者也不可能是两个人。比方说其中一人同时独裁了 A 、 B 和 A 、 C ，另一人则只独裁 B 、 C ，那么如果前者说 B 在 A 前面， A 在 C 前面，后者又说 C 在 B 前面，同样不会有兼顾两者的投票结果。因此，独裁者只能有一个，它就是填写枢纽选票的那个人。</p>
<p>    至此，我们就证明了，满足那两个基本条件的选举制度只有一种——独裁制度。</p>
<p> <br>
    上述结论有另外一种等价的表述方法：同时满足全体一致性、无关候选人独立性（就是那两个基本条件）以及非独裁性这三个条件的选举制度理论上是不存在的。这就是美国经济学家 Kenneth Arrow 提出的 Arrow 不可能性定理：不存在完美的选举制度。</p>
			 ]]></content>
<pubDate>2011-04-10T19:46:03+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4279</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 随记：我们需要怎样的数学教育？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4294</link>
<content><![CDATA[ 
		<p>    注：这篇文章里有很多个人观点，带有极强的主观色彩。其中一些思想不见得是正确的，有一些话也是我没有资格说的。我只是想和大家分享一下自己的一些想法。大家记得保留自己的见解。也请大家转载时保留这段话。</p>
<p>    我不是一个数学家。我甚至连数学专业的人都不是。我是一个纯粹打酱油的数学爱好者，只是比一般的爱好者更加执着，更加疯狂罢了。初中、高中一路保送，大学不在数学专业，这让我可以不以考试为目的地学习自己感兴趣的数学知识，让我对数学有如此浓厚的兴趣。从 05 年建立这个 Blog 以来，每看到一个惊人的结论或者美妙的证明，我再忙都会花时间把它记录下来，生怕自己忘掉。不过，我深知，这些令人拍案叫绝的雕虫小技其实根本谈不上数学之美，数学真正博大精深的思想我恐怕还不曾有半点体会。</p>
<p>    我多次跟人说起，我的人生理想就是，希望有一天能学完数学中的各个分支，然后站在一个至高点，俯瞰整个数学领域，真正体会到数学之美。但是，想要实现这一点是很困难的。最大的困难就是缺少一个学习数学的途径。看课本？这就是我今天想说的——课本极其不靠谱。</p>
<p><span id="more-4294"></span><br>
 <br>
 <br>
    这个我深有体会。最近两年，我一直在做初中数学培训，有了一些自己的看法。数学教育大致分成三个阶段，看山是山看水是水，看山不是山看水不是水，看山是山看水是水。</p>
<p>    最早数学教育就是，教你几个定理，告诉你它们是怎么证的，再让你证明一些新的定理。</p>
<p>    后来的要求就变了：光学数学不够，还要用数学。数学教育已经上升了一个层次：大家要把数学用到生活中去，解释生活中的现象。一时间，课本也好，中考题也好，全是与生活实际紧密联系的数学应用题，仿佛放眼望去身边真的处处都是数学一样。商场卖货，书店卖书，农民耕地，工人铺砖，再一次涌现在了课本、教辅书和考试题里。其实，数学可以解释生活，只是我们并不会这样去做。生活的变量太多，再强大的数学模型也不可能考虑到一切。对于平常人来说，真正能用到数学的地方，也就只有算算帐了。</p>
<p>    总有一天，数学教育会拔高到第三层：返朴归真，数学真正牛 B 的还是它本身。你会发现，那些伟大的数学思想，那些全新的数学理论，最初研究的动机并不是要急于解释我们身边的某某诡异现象，而是它本身的美妙。线性代数的出现，很大程度上要归功于神奇的 <a href="http://www.matrix67.com/blog/archives/3803">Cramer 悖论</a>；群论的诞生，也是 Galois 研究多项式的解的结构时的产物；Euler 创立图论，源于那个没有任何实用价值的 Königsberg 蛋疼问题；非欧几何的出现，则完全是由于这个问题本身的魅力。微积分呢？它确实有非常广泛的实用价值，物理学的各种定义都依赖于微积分；但很可惜，它不是一种具有颠覆性的数学思想。</p>
<p>    初一课本讲负数时，反复说负数的实际意义，比如海拔、得分、温度、收支等等，把负数变成一种真实的存在。其实，这不是人们使用负数的主要动机。负数的价值在于，它可以把减去一个数变成加上一个负数，很多加加减减复杂到甚至需要分类讨论的东西都能够用一个式子统一在一起了。比如说小学的盈亏问题：如果每人分 3 个苹果还多 8 个，如果每人分 5 个苹果则还多 2 个，问有多少人多少苹果？解法是，两种分法多出来的苹果相差 6 个，这是每个人多分了两个苹果引起的，因此一共 3 个人，从而可以算出有 17 个苹果。但是，如果把问题改成“每人分 3 个就多 8 个，每人分 5 个就<strong>少</strong> 2 个”该怎么办？上面的公式就变了，8 不能减 2，要加 2 。因此，小学讲盈亏问题会分“盈亏”、“盈盈”、“亏亏”三种情况讨论。其实，如果把“少 2 个”理解成“多 -2 个”，问题是一模一样的，之前的公式同样适用。负数这一新思想立即把三种情况统一在了一起，它们的本质变得一模一样了。</p>
<p>    这是我给初一学生讲负数时必讲的例子。这才是负数的意义。这才是课本里应该反复举例强调的。</p>
<p>    某次看到论坛里有人问，群论有什么意思啊？某人回复，群论很有意思啊，只是课本把它写得没意思了，比方说，讲群论怎么能不讲魔方呢？我不赞同这个回复。数学吸引人的地方，不在于它在生活中的应用，而在于它本身的美。为什么不讲 Lagrange 定理？为什么不讲 Sylow 定理？对于我来说，最能吸引我学习一个数学课题的，莫过于一系列非平凡的结论以及它的精彩证明了。</p>
<p>    科幻小说《伤心者》的末尾列举了很多长期以来未得到实际应用的数学理论，不过却没有说到一个更为极端的例子。数学中的皇冠——数论——2000 年来一直没有任何实际应用，是最纯粹的数学。直到计算机，尤其是现代密码学的出现，才让数论第一次走出数学，走进了人们的生活中。是什么在支持数论的研究呢？只能是数学本身了。</p>
<p>    在我给初中孩子出几何题时，我都尝试着给出一般性的问题，求证三角形中两边的平均长度大于第三边上的中线长，求证三角形三条高的倒数和等于内切圆半径的倒数，等等。即使是纯代数问题和解析几何问题，我也总能编出题目描述简单并且极具挑战性的问题。两数的和与积相等共有多少个整数解？把直线 y=x 沿 y=2x 翻折后得到的直线方程是什么？在感受结论之美的同时，他们也会因自己独立解决了一个真正的数学问题而激动。</p>
<p> <br>
 <br>
 <br>
    然而，这还不算教育的主要问题。某次与一个数学专业的同学聊到 Riemann 假设时，对方说她从没听说过 Riemann 假设。我大吃一惊，数学专业的人怎么可能不知道 Riemann 假设呢？随即明白，这也是拜数学教育所赐。翻开数学课本，总是成套的理论体系，先定义再证明，说得头头是道。可是，这些东西都是怎么来的呢？在得出这些东西的过程中，数学家们走了哪些弯路呢？课本上只字不提。课本里从来都只讲什么是对的，却从来不讲什么是错的。数学考试只会让你证明一个结论，从不会让你推翻一个结论。</p>
<p>    2010 年江苏高考数学题因为“太难”备受争议。其中最后一道大题如下：已知 △ABC 的三边长都是有理数，(1) 求证 cos(A) 是有理数； (2) 求证对任意正整数 n ， cos(nA) 是有理数。其实这道题是一个非常漂亮的好题，描述简单，问题普遍，结论有趣，证明巧妙，中考题就该这么出。不过我觉得，如果再补上这么一个小问，这道题就真的完美了：证明或推翻， sin(A) 一定是有理数。当然，问题本身并不难，等边三角形就是一个最简单的反例。关键在于，推翻一个结论，寻找一个反例，也是数学研究的一个基本能力，而这是中学数学教育中很少重视的。</p>
<p>    于是，在教初中数学时，我布置的每道作业题都无一例外地以“证明或推翻”打头。偶尔，有些题目真的是需要学生们去推翻它。比方说，证明或推翻，周长和面积都相等的两个三角形全等。不同的人找到的反例不一样，有的简单有的复杂，有的深刻有的盲目。再用一整节课的时间逐一讲解并点评大家构造的反例，给孩子们带来的收获远比直接讲题要大得多。</p>
<p> <br>
 <br>
 <br>
    但是，我还没有讲到数学教育中最主要的问题。前段时间去图灵的作译者交流会，期间和刘江老师简单地聊了几句。刘江老师提到一个网站叫做 <a href="http://betterexplained.com/">Better Explained</a> 。他说，其实大家没能理解数学之妙，是因为教的时候没教好，数学本来可以讲得更直观，更通俗的。</p>
<p>    我非常同意刘江老师的说法。举个例子吧。如果有学生问，质数是什么？老师会说，质数就是除了 1 和自身以外，没有其它约数的数。不对，这不是学生想要的答案。学生真正想知道的是，质数<strong>究竟是什么</strong>？其实，质数就是不可再分的数，是组成一切自然数的基本元素。 12 是由两个 2 和一个 3 组成的，正如 H<sub>2</sub>O 是由两个 H 原子和一个 O 原子组成的一样。只是和化学世界不同，算术世界的元素有无穷多个。算术世界内的一切对象、定理和方法，都是由这些基本元素组成的，这才是质数为什么那么重要的原因。</p>
<p>    高中学复数时，相信很多人会纳闷儿：虚数是什么？为什么要承认虚数？虚数怎么就表示旋转了？其实，人们建立复数理论，并不是因为人们有时需要处理根号里是负数的情况，而是因为下面这个不可抗拒的理由：如果承认虚数，那么 n 次多项式就会有恰好 n 个根，数系一下子就如同水晶球一般的完美了。但复数并不能形象地反映在数轴上，这不仅是因为实数在数轴上已经完备了，还有另外一个原因：没有什么几何操作连做两次就能实现取相反数。比如，“乘以 3”就代表数轴上的点离原点的距离扩大到原来的三倍，“3 的平方”，也就是“乘以 3 再乘以 3”，就是把上述操作连做两次，即扩大到 9 倍。同样地，“乘以 -1”表示把点翻折到数轴另一侧，“-1 的平方”就会把这个点又翻回来。但是，怎么在数轴上表示“乘以 i ”的操作？换句话说，什么操作连做两次能够把 1 变成 -1 ？一个颇具革命性的创意答案便是，把这个点绕着原点旋转 90 度。转 90 度转两次，自然就跑到数轴的另一侧了。没错，这就把数轴扩展到了整个平面，正好解决了复数没地方表示的问题。于是，复数的乘法可以解释为缩放加旋转，复数本身自然也就有了 z = r (cosθ + sinθi) 的表示方式。顺着这个道理推下去，一切都顺理成章了。复数不但有了几何解释，有时还能更便捷地处理几何问题。</p>
<p>    一直对线性代数很感兴趣，于是大学选了线性代数这门课，结果收获几乎为零。原因很简单，本来期待着来一次大彻大悟，结果学了一个学期，我还是不知道矩阵究竟是什么，矩阵乘法为什么要这么定义，矩阵可逆又怎么了，行列式究竟表示什么。</p>
<p>    直到今天看到<a href="http://mathoverflow.net/questions/7584/what-are-the-most-misleading-alternate-definitions-in-taught-mathematics">这个网页</a>，才看见有人一语道破线性代数的真谛（这也是我终于决定写成此文的直接原因）。我终于找到了我那一个学期企图寻找的东西。就好像把 x 变成 2 x 一样，我们经常需要把 (x, y) 变成 (2 x + y, x – 3 y) 之类的东西，这就叫做线性变换。于是才想到定义矩阵乘法，用于表示一切线性变换。几何上看，把平面上的每个点 (x, y) 都变到  (2 x + y, x – 3 y) 的位置上去，效果就相当于对这个平面进行了一个“线性的拉扯”。</p>
<p>      <img alt="image placeholder" >
<p>    矩阵的乘法，其实就是多个线性变换叠加的效果，它显然满足结合律，但不满足交换律。主对角线全是 1 的矩阵所对应的线性变换其实就是不变的意思，因此它叫做单位矩阵。矩阵 A 乘以矩阵 B 得单位矩阵，就是做完线性变换 A 后再做一次线性变换 B 就又变回去了的意思，难怪我们说矩阵 B 是矩阵 A 的逆矩阵。课本上对行列式的定义千奇百怪，又是什么递归，又是什么逆序对，还编写口诀帮助大家记忆。其实，行列式的真正定义就一句话：每个单位正方形在线性变换之后的面积。因此，单位矩阵的行列式当然就为 1，某行全为 0 的行列式显然为 0 （因为某一维度会被无视掉，线性变换会把整个平面压扁）， |A·B| 显然等于 |A|·|B| 。行列式为 0 ，对应的矩阵当然不可逆，因为这样的线性变换已经把平面压成一条线了，什么都不能把它变回去了。当然，更高阶的矩阵就对应了更高维的空间。一瞬间，所有东西都解释清楚了。</p>
<p>    难以置信的是，如此令人兴奋的东西，我们所用的课本上竟然一点都没有说到！那些开篇就讲行列式定义的课本，为什么不先把线性变换下的面积当作行列式的定义，再推导出行列式的计算方法，再来补充说明“其实从逻辑上说，我们应该先用这个计算公式来定义行列式，然后才说行列式可以用来表示面积”？为了严密性而牺牲了可读性，太不值得了。写到这里，我真想立即拾起线性代数课本，用全新的眼光重看所有的定义和定理，然后重新写一份真正的线性代数教材来。</p>
<p>    高数课本同样荒唐。主流的高数课本都是先讲导数，再讲不定积分，再讲定积分，完全把顺序弄颠倒了。好多人学完微积分，虽然已经用得得心应手，但仍然没懂这是怎么回事。究其原因，还是数学教学的问题。</p>
<p>    我理想中的微积分课本则应该是先讲定积分，再讲导数，再讲不定积分。先讲定积分，不过千万不能用现在的定积分符号，避免学生误认为定积分是由不定积分发展而来的。讲自古就有的积分思想，讲分割求和取极限的方法，自创一套定积分的符号。然后另起炉灶，开始讲微分，讲无穷小，讲变化量。最后才讲到，随着 x 一点一点的增加，曲线下方面积的变化量就是那一条条竖线的高度——不就是这个曲线本身的函数值吗？因此，反过来，为了求出一个函数对应的曲线下方的面积，只需要找到一个新函数，使得它的微分正好就是原来那个函数。啪，微积分诞生了。</p>
<p>    光讲形式化的推导沒有用。这才是真正把微积分讲懂的方式。严格定义和严格证明应该放到直观理解之后。只可惜，我还没看到哪本课本是这样写的。</p>
<p> <br>
 <br>
 <br>
    说了这么多，其实总结起来只有一句话：我们学习数学的过程，应该和人类认识数学的过程一样。我们应该按照数学发展历史的顺序学习数学。我们应该从古人计数开始学起，学到算术和几何，学到坐标系和微积分，了解每个数学分支创立的动机，以及这个分支曲折的发展历程。我们应该体会数学发展的每个瓶颈，体会每个全新理论的伟大之处，体会每一次数学危机让数学家们手忙脚乱的感觉，体会先有直观思维再给出形式化描述的艰难。</p>
<p>    可惜，我没有找到任何用这种方式学习数学的途径。</p>
<p>    不过也好。既然没有捷径，那就让我自己把那堆形式化的定义和证明通看一遍，然后自己去体会其中的道理吧。这样看来，我们的教育也没错：先用考试逼着大家把该学的东西都学了，尽管自己也不知道自己学的是啥；等将来的某一天达到一定高度时，回头看看过去学的东西，突然恍然大悟，明白了当初学的究竟是什么。这无疑是一件更有乐趣的事情。我希望有一天能像今天这样，能悟出高等代数究竟在讲什么，能悟出范畴论到底有什么用，能悟出 Riemann 假设为何如此牛 B，能悟出 Hilbert 空间是什么东西，然后把它们都写下来。</p>
<p>    这恐怕得花我大半辈子的时间吧。</p>
			 ]]></content>
<pubDate>2011-04-14T13:47:46+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4294</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 视频：How Round is Your Circle 各种神奇的几何构造 ]]></title>
<link>http://www.matrix67.com/blog/archives/4300</link>
<content><![CDATA[ 
		<p><embed src="http://www.tudou.com/v/Detx4Pf5koc/&amp;rpid=46416124/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="600" height="380"></embed></p>
<p>这是今天在 <a href="http://mathpuzzle.com">MathPuzzle</a> 上看到的视频。视频里演示了<a href="http://www.matrix67.com/blog/archives/2628">单平衡多面体</a>、<a href="http://www.matrix67.com/blog/archives/3427">Peaucellier 连杆</a>等非常帅气的几何图形和机械系统的实物版。这些几何构造各显神通，来头都不小，都是非常不错的数学话题。</p>
<p>大家看完这个视频后的感觉估计会跟我一样：为什么没有 <a href="http://www.matrix67.com/blog/archives/381">Gömböc</a> 呢？</p>
			 ]]></content>
<pubDate>2011-04-22T12:02:01+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4300</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：八等分一张圆饼最少需要多少刀？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4306</link>
<content><![CDATA[ 
		<p>一个有趣的智力题：将一张摊好的软面饼分成八等份，最少需要几刀？你可以任意折叠这张面饼。</p>
<p><img alt="image placeholder" >
<p><span id="more-4306"></span></p>
<p> <br>
 <br>
 <br>
 <br>
 </p>
<p>答案：一刀。如图。你想到了吗？</p>
<p><img alt="image placeholder" >
<p>来源：<a href="http://mindyourdecisions.com/blog/2011/04/07/the-worlds-best-tortilla-puzzle/">Mind Your Decisions</a></p>
			 ]]></content>
<pubDate>2011-04-25T14:46:06+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4306</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 蛋疼研究之单词等式 ]]></title>
<link>http://www.matrix67.com/blog/archives/4313</link>
<content><![CDATA[ 
		<p>    先给大家看两个“单词等式”：</p>
<p><code>ACT + DEAL = DONE<br>
COIN + TRY = DIAL</code></p>
<p>    除了意义上说得通以外，从另外一个角度来看，这两个等式也是成立的。大家能猜到是什么吗？</p>
<p><span id="more-4313"></span><br>
 <br>
    答案是：这两个等式真的就是成立的——如果把单词看作 36 进制数的话。把 ACT 转换成 10 进制就是 13421 ，把 DEAL 转换成 10 进制就是 625053 ，而 DONE 的 10 进制正好就是 638474 。类似地， COIN 加 TRY 也真的等于 DIAL ，对应的 10 进制算式为 591647 + 38590 = 630237 。</p>
<p>    其实，蛋疼的数学家们已经干过类似的事情了。数学家们对质数的热爱如此疯狂，以至于他们甚至搞出了一份质数单词表。最近我偶然看到 N 年前自己的一篇<a href="http://www.matrix67.com/blog/archives/135">罗列质数单词的日志</a>，立即想到了这个更蛋疼的主意——单词等式。于是写程序小小地搜索了一下，很快便出现了上面两个式子。</p>
<p>    我把 ACT + DEAL = DONE 加上引号拿到 Google 里去搜，没有结果。哈哈，似乎我是第一个蛋疼到想要研究这种 36 进制单词等式的人。于是我用 Mathematica 写了一个程序，在所有字母个数为 3 到 5 的常用单词中寻找等式：</p>
<p><code>minWordNetID[word_] := <br>
  If[Head[WordData[word, "WordNetID"]] === WordData, [Infinity], <br>
   Min[FromDigits[#, 10] &amp; /@ <br>
     WordData[word, "WordNetID"][[All, 2]]]];<br>
v = DictionaryLookup[RegularExpression["[a-z]{3,5}"]];<br>
v = Select[v, minWordNetID[#]  0 &amp;];<br>
TableForm[result]</code></p>
<p>    人工筛选有意义的等式并不是一件容易的事。我找到了下面三个很漂亮的单词等式：</p>
<p><code>MAP + LOOP = MAZE<br>
DYE + BLADE = BLOBS<br>
MAN + ROAR = SALE</code></p>
<p>    另外还有一些不那么好的单词等式，我也写出来吧：</p>
<p><code>BUG + BUG = NOW<br>
SHOWN + BLUR = STARE<br>
ACT + HEAR = HONK</code></p>
<p>    我也尝试过搜索字母更多的单词等式，以及包含乘法的单词等式，但结果数量极少，很难出现意义正好也相符的式子。我有没有错过什么更为绝妙的单词等式呢？欢迎蛋疼的网友们也来找一找。</p>
			 ]]></content>
<pubDate>2011-04-27T11:39:27+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4313</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：不动点与线性代数 ]]></title>
<link>http://www.matrix67.com/blog/archives/4318</link>
<content><![CDATA[ 
		<p>    假设 X 、 Y 是两个有限集合，f:X→Y 和 g:Y→X 是两个函数。求证：复合函数 g∘f 和 f∘g 拥有相同数量的不动点（也就是说 g(f(x)) = x 和 f(g(y)) = y 的解的个数相同）。</p>
<p>    下面先提供一个“正常”的解法。观察函数 g∘f 的不动点，可以看出它有以下两个性质：首先，如果某个 x 是 g∘f 的不动点，即 x = g(f(x)) ，那么 f(x) = f(g(f(x)))，这就说明 f(x) 是 f∘g 的一个不动点；另外，如果 x<sub>1</sub> 和 x<sub>2</sub> 是 X 中两个不同的不动点，则函数 f 不可能把它们映射到 Y 中的同一个元素，否则 g 没办法把它分别还原成 x<sub>1</sub> 和 x<sub>2</sub> 。结合上面两点可以看出， f∘g 中的不动点至少和 g∘f 的一样多。</p>
<p>    同理，考察 f∘g 的不动点，可知 g∘f 的不动点至少和 f∘g 的一样多。这就说明了 g∘f 和 f∘g 拥有相同数量的不动点。</p>
<p><span id="more-4318"></span><br>
    今天在 <a href="http://www.reddit.com/r/math/comments/h13mw/cool_simple_proofs_which_use_linear_algebra/">reddit</a> 上学到了一招：利用线性代数的一些已知结论，我们可以得到一个更帅的证明方法。把集合 X 和 Y 的元素个数分别记作 |X| 和 |Y| ，再把函数 f 和 g 分别表示成 |X| × |Y| 的 01 矩阵 A 和 |Y| × |X| 的 01 矩阵 B 。我们可以用矩阵的乘积来表示复合函数， AB 和 BA 这两个矩阵就分别表示复合函数 g∘f 和 f∘g 。而 g∘f 和 f∘g 的不动点个数，也就是对应矩阵的迹。由于 tr(AB) = tr(BA) ，因此 g∘f 和 f∘g 拥有相同数量的不动点。</p>
<p>    如果你喜欢这样的证明，千万不要错过另外两个线性代数出奇制胜的例子：<a href="http://www.matrix67.com/blog/archives/1900">选取最多的子集使得任两子集恰有一个公共元素，</a>以及<a href="http://www.matrix67.com/blog/archives/998">完全图 K<sub>n</sub> 最少可以拆成多少个完全二分图</a>。</p>
			 ]]></content>
<pubDate>2011-05-02T23:27:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4318</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Kolakoski序列：我们知道的还是太少 ]]></title>
<link>http://www.matrix67.com/blog/archives/4324</link>
<content><![CDATA[ 
		<p>    上帝创造了整数，其余的则是我们人类的事了。正因为如此，质数、完全数、Fibonacci 数之类的数列才会让数学家们如痴如醉，因为它们的存在是如此自然，没有任何人造的因素。事实上，数学家们对这些数的认识也越来越丰富，挖掘出了这些数列中越来越深刻的性质。</p>
<p>    不过，人类确实太渺小了。还有好多构造异常简单的“纯天然数列”，我们了解得实在太少。Kolakoski 数列就是最好的例子之一。</p>
<p>    Kolakoski 数列仅由 1 和 2 构成，其中头 100 个数是</p>
<blockquote><p>1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1,<br>
2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1,<br>
1, 2, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 2, 1, 1, 2,<br>
1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 2,<br>
2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, …</p></blockquote>
<p><span id="more-4324"></span><br>
    如果我们把连续的相同数看作一组的话，整个数列的定义就只有两句话： a(1) = 1 ， a(n) 表示第 n 组数的长度。例如，a(6) = 2，就表明第 6 组数（从第 8 个数算起）的长度就是 2。注意，有了这几个条件，整个序列就已经唯一地确定了！a(1) = 1 就表明第一组数只有一个数，因此下一个数必须要换成 2 ，因此 a(2) = 2 ；而 a(2) = 2 又说明这个 2 必须要连着出现两个，因此 a(3) = 2；而 a(3) = 2 就表明数列接下来要有两个 1 ，等等。也就是说，生成这个数列的“参数”就是这个数列本身。更酷的说法则是，这个数列是分形的：如果把每一组数用它的长度来替换，就会得到这个数列本身。另外一个可能有些出人意料的事实是：Kolakoski 数列在 OEIS 中的序号非常靠前—— <a href="http://oeis.org/A000002">A000002</a>。</p>
<p>    关于 Kolakoski 数列，我们知道些什么？很少。我们知道，这个数列可以用递归式 a(a(1) + a(2) + … + a(k)) = (3 + (-1)<sup>k</sup>)/2 来表达。我们目前已经知道，去掉数列最前面的 1，剩下的部分可以从 22 开始，由替换规则 22→2211，21→221，12→211，11→21 迭代产生。</p>
<p>    Kolakoski 数列的第 n 项有非递归的公式吗？目前我们还不知道。已经出现过的数字串今后都还会再次出现吗？目前我们也不知道。还有，我们有理由猜想，数列中 1 和 2 的个数各占一半。下图显示的就是数列前 n 项中数字 1 所占的比例，可见我们的猜想很可能是对的。</p>
<p>    <img alt="image placeholder" >
<p>    不过，目前还没有人能够证明这一点。而最近的一些研究则表明，数字 1 的比例很可能不是 1/2 。当然，还有第三种可能——这个极限可能根本不存在。这无疑又是一个<a href="http://www.matrix67.com/blog/archives/4035">最折磨人的数学未解之谜</a>。</p>
			 ]]></content>
<pubDate>2011-05-04T10:36:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4324</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 幸福结局问题，以及一个幸福的结局 ]]></title>
<link>http://www.matrix67.com/blog/archives/4331</link>
<content><![CDATA[ 
		<p>    今天是我第一次听说这个故事。</p>
<p>    1933 年，匈牙利数学家 George Szekeres 还只有 22 岁。那时，他常常和朋友们在匈牙利的首都布达佩斯讨论数学。这群人里面还有同样生于匈牙利的数学怪才——Paul Erdős 大神。不过当时，Erdős 只有 20 岁。</p>
<p>    在一次数学聚会上，一位叫做 Esther Klein 的美女同学提出了这么一个结论：在平面上随便画五个点（其中任意三点不共线），那么一定有四个点，它们构成一个凸四边形。Szekeres 和 Erdős 等人想了好一会儿，没想到该怎么证明。于是，美女同学得意地宣布了她的证明：这五个点的凸包（覆盖整个点集的最小凸多边形）只可能是五边形、四边形和三角形。前两种情况都已经不用再讨论了，而对于第三种情况，把三角形内的两个点连成一条直线，则三角形的三个顶点中一定有两个顶点在这条直线的同一侧，这四个点便构成了一个凸四边形。</p>
<p>    <img alt="image placeholder" >
<p><span id="more-4331"></span><br>
    众人大呼精彩。之后，Erdős 和 Szekeres 仍然对这个问题念念不忘，于是尝试对其进行推广。最终，他们于 1935 年发表论文，成功地证明了一个更强的结论：对于任意一个正整数 n ≥ 3，总存在一个正整数 m，使得只要平面上的点有 m 个（并且任意三点不共线），那么一定能从中找到一个凸 n 边形。 Erdős 把这个问题命名为了“幸福结局问题”（Happy Ending problem），因为这个问题让 George Szekeres 和美女同学 Esther Klein 走到了一起，两人在 1936 年结了婚。</p>
<p>    对于一个给定的 n ，不妨把最少需要的点数记作 f(n)。求出 f(n) 的准确值是一个不小的挑战。由于平面上任意不共线三点都能确定一个三角形，因此 f(3) = 3 。Esther Klein 的结论则可以简单地表示为 f(4) = 5 。<br>
    当 n = 5 时，八个点是不够的。下图就是八个不含凸五边形的点。</p>
<p>    <img alt="image placeholder" >
<p>    利用一些稍显复杂的方法可以证明，任意九个点都包含一个凸五边形，因此 f(5) 等于 9 。</p>
<p>    2006 年，利用计算机的帮助，人们终于证明了 f(6) = 17 。对于更大的 n ， f(n) 的值分别是多少？ f(n) 有没有一个准确的表达式呢？这是数学中悬而未解的难题之一。</p>
<p>    不管怎样，最后的结局真的很幸福。结婚后的近 70 年里，他们先后到过上海和阿德莱德，最终在悉尼定居，期间从未分开过。 2005 年 8 月 28 日， George 和 Esther 相继离开人世，相差不到一个小时。</p>
			 ]]></content>
<pubDate>2011-05-04T23:01:49+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4331</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 数学之美：垂心的各种优雅的性质 ]]></title>
<link>http://www.matrix67.com/blog/archives/4340</link>
<content><![CDATA[ 
		<p>    下面这些文字来源于我在初三数学竞赛课的一份讲义。这节课的主题本是四点共圆，但由此引出了三角形中很多漂亮的性质，让人深感数学之美。在此整理出来，献给所有还在中学读书的读者，以及早已远离中学数学的 80 后。不管大家是否喜爱数学，想必都会被这些奇妙的结论所震撼。</p>
<p>    <img alt="image placeholder" >
<p>    三角形的奇迹首先表现在各个“心”上：三角形内部的每一组有几何意义的线条都交于一点。三条角平分线交于一点，这个点就叫做三角形的“内心”，它是三角形内切圆的圆心；三边的中垂线交于一点，这个点就叫做三角形的“外心”，它是三角形外接圆的圆心；三角形的三条中线也交于一点，这个点叫做三角形的“重心”，因为它真的就是这个三角形的重心。用力学方法可以很快推导出，它位于各中线的三等分点处。这些心将会在本文后面某个出人意料的地方再次出现。</p>
<p>    三角形的三条高也不例外——它们也交于一点，这个点就叫做三角形的垂心。</p>
<p>    垂心看上去很不起眼，但深入研究后即会冒出很多奇妙的结论。由于两个斜边重合的直角三角形将会产生出共圆的四点，因此画出三角形的三条高后，会出现大量四点共圆的情况，由此将挖掘出一连串漂亮的结论。让我们先来看一个简单而直接的结论：</p>
<p><span id="more-4340"></span></p>
<blockquote><p>定理：若 D 、 E 、 F 分别是 △ABC 三边的高的垂足，则 ∠1 = ∠2 。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：由于 ∠AFC = ∠ADC = 90°，因此 A 、 C 、 D 、 F 四点共圆，因此 ∠1 = 180° – ∠CDF = ∠A 。同理，由 A 、 B 、 D 、 E 四点共圆可知 ∠2 = ∠A 。因此 ∠1 = ∠2 。</p></blockquote>
<p> <br>
    如果把三边垂足构成的三角形称作“垂足三角形”的话，我们就有了下面这个听上去很帅的推论：</p>
<blockquote><p>推论：三角形的垂心是其垂足三角形的内心。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：因为 AD 垂直于 BC，而刚才又证明了 ∠1 = ∠2，因此 ∠3 = ∠4 ，即 HD 平分 ∠EDF 。类似地， HE 、 HF 都是 △DEF 的内角平分线，因此 H 是 △DEF 的内心。</p></blockquote>
<p> <br>
    另一个有趣的推论如下：</p>
<blockquote><p>推论：将 △ABC 沿 AC 翻折到 △AB’C ，假设 EF 翻折到了 EF’ ，则 EF’ 和 DE 共线。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：这可以直接由上图中的 ∠1 = ∠2 推出。</p></blockquote>
<p> <br>
    1775 年，Fagnano 曾经提出了下面这个问题：在给定的锐角三角形 ABC 中，什么样的内接三角形具有最短的周长。这个问题就被称作“Fagnano 问题”。 Fagnano 自己给出了答案：周长最短的内接三角形就是垂足三角形。下面我们就来证明这个结论。</p>
<blockquote><p>定理：在 △ABC 的所有内接三角形中，垂足三角形 △DEF 拥有最短的周长。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：像上图那样，把三角形翻折五次，得到折线段 DEF<sub>1</sub>D<sub>2</sub>E<sub>2</sub>F<sub>3</sub>D<sub>4</sub> 。这条折线段的总长度等于内接三角形 DEF 周长的两倍。注意到，由前面提到的垂足三角形的性质可知，这条折线段正好组成了一条直线段。另外，注意到如此翻折之后， BC 和 B<sub>2</sub>C<sub>2</sub> 是平行且相等的，而且 D 和 D<sub>4</sub> 位于两线段上相同的位置，因此从 D 到 D<sub>4</sub> 的折线段总长以直线段 DD<sub>4</sub> 最短。这就说明了，垂足三角形 △DEF 拥有最短的周长。</p></blockquote>
<p> <br>
    不过，这还不够震撼，垂心还有不少的本事。四点共圆还会给我们带来其它的等角。</p>
<blockquote><p>定理：若 D 、 E 、 F 分别是 △ABC 三边的高的垂足，则 ∠1 = ∠2 。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：由于 ∠BFH = ∠BDH = 90°，因此 B 、 F 、 H 、 D 四点共圆，因此 ∠1 = 180° – ∠FHD = ∠2 。</p></blockquote>
<p> <br>
    这将给我们带来了下面这个非常漂亮的推论。</p>
<blockquote><p>推论：把 △ABC 的垂心 H 沿 BC 边翻折到 H’ ，则 H’ 在 △ABC 的外接圆上。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：由于 H 和 H’ 沿 BC 轴对称，因此 ∠H’ = ∠1 。而前面已经证明过了， ∠1 = ∠2 。因此， ∠H’ = ∠2 。而 ∠H’ 和 ∠2 都是 AC 所对的角，它们相等就意味着 A 、 C 、 H’ 、 B 是四点共圆的。</p></blockquote>
<p> <br>
    换一种描述方法，这个结论还可以便得更酷：</p>
<blockquote><p>推论：把 △ABC 的垂心 H 沿三边分别翻折到 H<sub>1</sub> 、 H<sub>2</sub> 、 H<sub>3</sub> ，则 A 、 B 、 C 、 H<sub>1</sub> 、 H<sub>2</sub> 、 H<sub>3</sub> 六点共圆。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：这可以直接由前面的结论得到。</p></blockquote>
<p> <br>
    另一个更加对称美观的结论如下：</p>
<blockquote><p>推论：若 D 、 E 、 F 分别是 △ABC 三边的高的垂足， H 是垂心，则 AH·DH = BH·EH = CH·FH 。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：做出 △ABC 的外接圆，然后延长 HD 、 HE 、 HF ，它们与外接圆的交点分别记作 H<sub>1</sub> 、 H<sub>2</sub> 、 H<sub>3</sub> 。前面的结论告诉我们， HH<sub>1</sub> = 2HD ， HH<sub>2</sub> = 2HE ， HH<sub>3</sub> = 2HF。而相交弦定理（或者圆幂定理，可以用相似迅速得证）告诉我们， AH·HH<sub>1</sub> = BH·HH<sub>2</sub> = CH·HH<sub>3</sub> 。各等量同时除以 2 ，就有 AH·DH = BH·EH = CH·FH 。</p></blockquote>
<p> <br>
    让我们再来看一个与外接圆有关的定理。</p>
<blockquote><p>定理：若 D 、 E 、 F 分别是 △ABC 三边的高的垂足， H 是垂心。过 C 作 BC 的垂线，与 △ABC 的外接圆交于点 G 。则 CG = AH 。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：我们将证明四边形 AHCG 的两组对边分别平行，从而说明它是一个平行四边形。注意到 CG 和 AD 都垂直于 BC ，因此 CG 和 AD 是平行的。由于 ∠BCG 是直角，这说明 BG 是圆的直径，也就说明 ∠BAG 也是直角，即 GA 垂直于 AB 。而 CF 也垂直于 AB ，所以 AG 与 CF 平行。因而四边形 AHCG 是平行四边形， CG = AH 。</p></blockquote>
<p> <br>
    它也能带来一个更帅的推论：</p>
<blockquote><p>推论：若 H 是 △ABC 的垂心，O 是 △ABC 的外心，则 O 到 BC 的垂线段 OM 与 AH 平行，并且是 AH 长度的一半。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：前面我们证明了，上图中的 CG 与 AH 平行且相等。注意到 BG 是外接圆的直径， BG 的中点就是圆心，也就是 △ABC 的外心 O 。垂线段 OM 是 △BCG 的中位线，它平行且等于 CG 的一半，从而也就平行且等于 AH 的一半。</p></blockquote>
<p> <br>
    好了，下面大家将会看到的就是初等几何的瑰宝：</p>
<blockquote><p>推论：三角形的垂心、重心和外心共线，且重心在垂心和外心连线的三等分点处。<br>
 <br>
<img alt="image placeholder" >
 <br>
证明：把 AM 和 HO 的交点记作 X 。刚才我们已经证明了， AH 与 OM 平行，且长度之比为 2:1 。因此， △AHX 和 △MOX 相似，相似比为 2:1 。由此可知， HX:XO = 2:1 ，即 X 在线段 HO 的三等分点处。另外， AX:XM = 2:1 ，也就是说 X 在三角形中线 AM 的 2:1 处。这说明， X 正是三角形的重心！</p></blockquote>
<p> <br>
    任意给定一个三角形，它的垂心、重心和外心三点共线，且重心将垂心和外心的连线分成 1:2 两段。这个美妙的结论是大数学家 Euler 在 1765 年时发现的，它是众多“Euler 定理”的其中之一。</p>
<p>    说到 Euler 定理，九点圆是不能不提的；不过由于篇幅有限，也就到这儿为止了。垂心的性质还有很多，很难在一篇文章里把它们讲完。而且，这还仅仅是与垂心相关的定理，三角形中的心还有很多很多。1994 年，美国数学教授 Clark Kimberling 开始收集历史上被数学家们研究过的三角形的心，并建立了“三角形中心百科全书”的网站。这个网站记录了几乎所有目前已知的三角形的心。在这部百科全书里，每个三角形的心都有一个编号，编号为 n 的心就用符号 X(n) 来表示，其中 X(1) 到 X(8) 分别为内心、重心、外心、垂心、九点圆圆心、类似重心、 Gergonne 点和 Nagel 点。不但每个心都有自己独特的几何性质，各个心之间还有大量共线、共圆的关系。</p>
<p>    这个网站的地址是 <a href="http://faculty.evansville.edu/ck6/encyclopedia/ETC.html">http://faculty.evansville.edu/ck6/encyclopedia/ETC.html</a> 。目前，整个网站已经收集了 3000 多个三角形的心，且这个数目还在不断增加。</p>
			 ]]></content>
<pubDate>2011-05-11T09:53:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4340</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 等待的时间比你想象的更久 ]]></title>
<link>http://www.matrix67.com/blog/archives/4349</link>
<content><![CDATA[ 
		<p>    最近忙于写学年论文，一直没时间更新 Blog 。不过，我却并没有停止在网上闲逛的习惯。这几天会慢慢把最近看到的有意思的东西写下来。今天学到的一个比较有趣的东西就是：平均等待时间往往大于平均间隔时间的一半。</p>
<p>    比方说，有这么一趟公交车，平均每 10 分钟发一班车，但具体的发车时间是很不固定的。如果你在某个时刻来到车站，等到下一班车平均要花多久呢？很多人或许都觉得，平均等待时间应该是 5 分钟，毕竟平均间隔时间是 10 分钟嘛。然而事实上，平均等待时间是大于 5 分钟的。这是因为，10 分钟的发车间隔只是一个平均值，实际间隔有时是几分钟，有时是十几分钟。如果你出现在车站的时刻，正好位于几分钟的间隔中，你的平均等待时间显然就会小于 5 分钟；但如果你出现在车站的时刻，正好位于较长的间隔中，那么你的平均等待时间就会大于 5 分钟。关键就在这里：你出现在车站的时刻，更有可能落在了较长的发车间隔中。因而，平均等待时间会偏向于大于 5 分钟的情况。</p>
<p>    那么，如果公交车发车的时间足够随机，概率均等地分布在时间轴上（假设平均间隔仍是 10 分钟），那么当你来到车站时，平均需要多久才能等到公交车呢？答案或许很出人意料——平均等待时间就是 10 分钟。下面我们就来证明这一点。</p>
<p><span id="more-4349"></span><br>
      <img alt="image placeholder" >
<p>    首先注意到，如果发车间隔依次为 X<sub>1</sub>, X<sub>2</sub>, …, X<sub>n</sub> ，出现在车站的时刻不同，等候时间也会不同，其函数图象大致是锯齿形的。而平均等待时间，就是这个函数图象的平均高度，或者说所有阴影部分的面积和（也就是 X<sub>1</sub>, X<sub>2</sub>, …, X<sub>n</sub> 的平方和的一半）除以这段时间总长（也就是 X<sub>1</sub>, X<sub>2</sub>, …, X<sub>n</sub> 的和）。如果用 <span style="text-decoration:overline">W</span> 来表示平均等待时间的话，则</p>
<p>      <img alt="image placeholder" >
<p>    另外，由于公交车的发车时间是完全随机的，因而发车间隔长度服从指数分布  λe<sup>-λx</sup> ，它的平均值 μ = 1/λ ，方差 σ<sup>2</sup> = 1/λ<sup>2</sup> ，后者正好是前者的平方。如果把上述所有 X 的方差记作 Var(X)，那么</p>
<p>      <img alt="image placeholder" >
<p>    但是</p>
<p>      <img alt="image placeholder" >
<p>    因此</p>
<p>      <img alt="image placeholder" >
<p>    也就是</p>
<p>      <img alt="image placeholder" >
<p>    所以说</p>
<p>      <img alt="image placeholder" >
<p>    这就表明，平均等待时间就是平均间隔时间！</p>
<p>    当然，转念一想，你会发现这其实并不难理解。由于发车时间是完全随机的，过去的都已经过去了，并不会对未来造成影响。也就是说，当你开始等车时，知道前面那趟车已经走了很久了，并不意味着下一班车就会更快到来。不管你出现在时间轴的什么位置，等到下一班车的期望时间都是一样的——平均的间隔时间。</p>
<p> <br>
参考资料：<br>
<a href="http://mahalanobis.twoday.net/stories/3486587/">http://mahalanobis.twoday.net/stories/3486587/</a><br>
<a href="http://en.wikipedia.org/wiki/Exponential_distribution">http://en.wikipedia.org/wiki/Exponential_distribution</a></p>
			 ]]></content>
<pubDate>2011-05-23T20:27:03+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4349</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：老鼠与毒药问题的推广 ]]></title>
<link>http://www.matrix67.com/blog/archives/4361</link>
<content><![CDATA[ 
		<p>    今天的趣题来源于 <a href="http://domino.research.ibm.com/comm/wwwr_ponder.nsf/challenges/March2011.html">IBM Ponder This 三月份的谜题</a>。</p>
<p>    大家应该都听说过这个老题目：有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 10 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？</p>
<p>    这个问题的答案也堪称经典：把瓶子从 0 到 999 依次编号，然后全部转换为 10 位二进制数。让第一只老鼠喝掉所有二进制数右起第一位是 1 的瓶子，让第二只老鼠喝掉所有二进制数右起第二位是 1 的瓶子，等等。一星期后，如果第一只老鼠死了，就知道毒药瓶子的二进制编号中，右起第一位是 1 ；如果第二只老鼠没死，就知道毒药瓶子的二进制编号中，右起第二位是 0 ⋯⋯每只老鼠的死活都能确定出 10 位二进制数的其中一位，由此便可知道毒药瓶子的编号了。</p>
<p>    现在，有意思的问题来了：如果你有两个星期的时间（换句话说你可以做两轮实验），为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？注意，在第一轮实验中死掉的老鼠，就无法继续参与第二次实验了。</p>
<p><span id="more-4361"></span></p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    答案：7 只老鼠就足够了。事实上，7 只老鼠足以从 3<sup>7</sup> = 2187 个瓶子中找出毒药来。首先，把所有瓶子从 0 到 2186 编号，然后全部转换为 7 位三进制数。现在，让第一只老鼠喝掉所有三进制数右起第一位是 2 的瓶子，让第二只老鼠喝掉所有三进制数右起第二位是 2 的瓶子，等等。一星期之后，如果第一只老鼠死了，就知道毒药瓶子的三进制编号中，右起第一位是 2 ；如果第二只老鼠没死，就知道毒药瓶子的三进制编号中，右起第二位不是 2，只可能是 0 或者 1 ⋯⋯也就是说，每只死掉的老鼠都用自己的生命确定出了，三进制编号中自己负责的那一位是 2 ；但每只活着的老鼠都只能确定，它所负责的那一位不是 2 。于是，问题就归约到了只剩一个星期时的情况。在第二轮实验里，让每只活着的老鼠继续自己未完成的任务，喝掉它负责的那一位是 1 的所有瓶子。再过一星期，毒药瓶子的三进制编号便能全部揭晓了。</p>
<p>    类似地，我们可以证明， n 只小白鼠 t 周的时间可以从 (t+1)<sup>n</sup> 个瓶子中检验出毒药来。</p>
			 ]]></content>
<pubDate>2011-05-27T12:27:57+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4361</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 或许你从小就一直在思考的两个算术问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/4365</link>
<content><![CDATA[ 
		<p>你是否很小就注意到了下面这两个有趣的算术现象？这两个简单的算术谜题是否一直都困扰着你？今天，大家终于有机会解开谜团了。</p>
<p><strong>问题一： 2 加 2 等于 4 ， 2 乘 2 也等于 4 。还有其他的整数对，它们的和与积也相等吗？</strong></p>
<p>我们要求的就是 m + n = mn 的整数解。方程可以变为 mn – m – n + 1 = 1 ，也就是 (m – 1)(n – 1) = 1 。由于 m 、 n 都是整数，因此 m – 1 和 n – 1 也都是整数。两个整数之积为 1 ，只有两种情况——这两个数都是 1，或者这两个数都是 -1 。前者对应了 m = 2, n = 2 ，后者解出来则是 m = 0, n = 0 。如果把 (0, 0) 看作平凡解（或者如果我们把问题限制在正整数范围）的话，非平凡解就只有 (2, 2)，没有其他的了。</p>
<p><span id="more-4365"></span></p>
<p>2015 年 5 月 19 日更新：我又学到了三种新的证明方法。这里，我们统一把问题限制在正整数范围内。</p>
<ol>
<li>不妨假设 m ≤ n 。如果 m ≥ 3 的话，那么 mn ≥ 3n &gt; 2n = n + n ≥ m + n = mn ，矛盾。因此， m 只能是 1 或者 2 。但是，如果 m = 1 的话， m + n = mn 就变成了 1 + n = n ，这显然无解。所以， m 只能等于 2 。原方程变为 2 + n = 2n ，解得 n = 2 。</li>
<li>不妨假设 m ≤ n 。由于 m + n = mn ，因而 m = mn / n = (m + n) / n = m / n + 1 。但是，当 m &lt; n 时， m / n + 1 根本不是整数。所以 m = n 。因此， m + n = mn 就变成了 2m = m<sup>2</sup> ，显然 m 只能等于 2 。因此， n 也只能等于 2 。</li>
<li>首先注意到， m · (n – 1) 一定是 m 的倍数。但是， m · (n – 1) = m · n – m = m + n – m = n 。这说明， n 一定是 m 的倍数。根据同样的道理， m 也一定是 n 的倍数。所以， m 和 n 一定是两个相等的数。因此， m + n = mn 就变成了 2m = m<sup>2</sup> ，显然 m 只能等于 2 。因此， n 也只能等于 2 。</li>
</ol>
<p>以上是 2015 年 5 月 19 日更新的内容。</p>
<p>有趣的是，如果三个正整数之和恰好等于它们的乘积，解也只有一个：(1, 2, 3) 。更有趣的是，如果四个正整数之和恰好等于它们的乘积，解仍然是唯一的：(1, 1, 2, 4) 。如果五个数呢？这一回，解就不止一个了，(1, 1, 2, 2, 2) 、 (1, 1, 1, 3, 3) 、 (1, 1, 1, 2, 5) 都是满足要求的解。</p>
<p>我们自然想问，对于哪些 n，“n 个正整数的和恰好等于它们的积”有唯一解。让人意想不到的是，这竟然是一个数学未解之谜。目前已经知道，在 n &lt; 13 587 782 064 的范围内，只有 n = 2, 3, 4, 6, 24, 114, 174, 444 时有唯一解。是否有其他满足要求的 n ，这个问题至今仍未解决。</p>
<p> </p>
<p><strong>问题二： 2 的 4 次方等于 16 ， 4 的 2 次方也等于 16 。还有其他的正整数 m 和 n ，使得 m 的 n 次方和 n 的 m 次方也相等吗？</strong></p>
<p>当然，我们忽略所有 m = n 的平凡解。另外，当 m = 1 时，有 1<sup>n</sup> = n<sup>1</sup> ，于是 m = n = 1 。因此，下面我们都假设 2 ≤ m &lt; n 。</p>
<p>等式两边同时除以 m<sup>m</sup>，有</p>
<blockquote><p>m<sup>n</sup>/m<sup>m</sup> = n<sup>m</sup>/m<sup>m</sup></p></blockquote>
<p>即</p>
<blockquote><p>m<sup>n – m</sup> = (n/m)<sup>m</sup></p></blockquote>
<p>由于等式左边是一个整数，因此等式右边也一定是一个整数，可见 n 一定是 m 的整数倍。不妨令 n = k·m ，其中 k 是一个大于等于 2 的整数。于是上式继续变为：</p>
<blockquote><p>m<sup>km – m</sup> = k<sup>m</sup></p></blockquote>
<p>即</p>
<blockquote><p>m<sup>m(k – 1)</sup> = k<sup>m</sup></p></blockquote>
<p>两边同时开 m 次方，有</p>
<blockquote><p>m<sup>k – 1</sup> = k</p></blockquote>
<p>当 k = 2 时，上式化为 m<sup>1</sup> = 2，于是我们找到一组非平凡解 m = 2, n = 4 。</p>
<p>如果 k = 3 呢？上式将变为 m<sup>2</sup> = 3。注意到我们的 m 至少等于 2 ，因此 m<sup>2</sup> 至少也是 4 ，是不可能等于 3 的。</p>
<p>如果 k 更大呢？m<sup>k – 1</sup> 肯定会更大，更不可能等于 k 了。我们用数学归纳法证明这一点。</p>
<p>假设 m<sup>k – 2</sup> &gt; k – 1，那么m<sup>k – 1</sup> = m · m<sup>k – 2</sup> &gt; m(k – 1) ；但 m 是大于等于 2 的，因而 m(k – 1) ≥ 2(k – 1) ；但 k 是大于等于 3 的，因此 2(k – 1) = 2k – 2 &gt; k。</p>
<p>因此， (2, 4) 是这个算术问题的唯一一组非平凡解。</p>
			 ]]></content>
<pubDate>2011-05-30T23:13:38+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4365</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 44个精彩的物理趣题 ]]></title>
<link>http://www.matrix67.com/blog/archives/4372</link>
<content><![CDATA[ 
		<p>    这个 Blog 几乎一直在讲数学趣题，却很少提到物理趣题。其实，我个人觉得，物理也是相当好玩的（我是化学不好才选的文科）。隐约记得初中搞物理竞赛时，曾见过大量让人大呼过瘾的好题。前几天看到了<a href="http://star.tau.ac.il/QUIZ/">一个绝好的网站</a>，里面有相当多的物理题目，让我激动了好一阵子。我搜集整理了里面的一些好题，加上了我自己的一些补充，在这里和大家分享。不过，由于我的物理实在不怎么样，如果出现什么错误，请大家及时纠正。</p>
<p>    那个网站上的“官方解答”并不见得靠谱，也不知是因为我没有悟到，还是因为它真的不靠谱。不管怎样，我给出的基本上还是它的官方答案。其实，阅读过程中你会发现，答案是次要的，真正有趣的其实是问题本身。</p>
<p>    几乎从没写过物理题目的 Blog ，想要用一篇文章总结物理趣题，因此毫无疑问——这是一篇非常，非常，非常长的文章。建议大家用自己喜欢的方式做个书签，一天看一点。如果觉得还不过瘾，推荐订阅物理大牛 <a href="http://www.eaglefantasy.com/">EagleFantasy 的 Blog</a>。</p>
<p>    另外，此日志一出，想必又会收到无数邮件，询问我作图用的什么工具的。在此就先回答了——请见 <a href="http://www.matrix67.com/blog/faq">FAQ</a> 。</p>
<p>    开始吧。</p>
<p><span id="more-4372"></span></p>
<p> <br>
    <strong>有一块 V 字形木板，两侧与地面的夹角都是 θ 。一根密度均匀的绳子放在木板上，绳子与木板之间的摩擦系数为 1 。整个系统左右对称。没挨着木板的那段绳子所占的比例最大是多少？此时 θ 是多少度？</strong></p>
<p>    <img alt="image placeholder" >
<p>    用一些非常初等的方法可以得到，答案是 (√<span style="text-decoration:overline">2</span> – 1)<sup>2</sup> ≈ 0.172 ，此时 θ = 22.5° 。具体解答可以见 <a href="http://star.tau.ac.il/QUIZ/05/sol_rope.pdf">http://star.tau.ac.il/QUIZ/05/sol_rope.pdf</a> 。</p>
<p> <br>
 <br>
    <strong>一个长、宽、高分别为 a 、 b 、 c 的长方体物块，斜靠在一个墙角。由于墙壁和地面都是完全光滑的，因此物块将会开始下滑。什么时候，物块会脱离墙壁？</strong></p>
<p>    <img alt="image placeholder" >
<p>    为了解决这个问题，首先需要把物块和地面的夹角记作 θ ，物块下滑过程中的各种物理量都可以用 θ 来表示。然后，解决这个问题的关键就在于，当物块脱离墙壁时，物块向右的加速度就消失了，这个临界点就由等量关系 dv<sub>x</sub> / dθ = 0 给出。不过，由此产生的方程非常复杂，我们只能用数值的方式去解它。</p>
<p> <br>
 <br>
    <strong>有一个半圆柱体横放在水平桌面上，截面的半径为 R 。我们在半圆柱体上放一块木板，试图让它在半圆上保持平衡。假如这块木板非常薄，那么这块木板很容易放稳，即使有些小动静，木板也会自动恢复平衡。但考虑另外一个极端，假如这是一块非常厚非常厚的木板（甚至是大楼一般的形状），它显然不能稳放在这个半圆上。那么，这中间一定会有一个临界点。这个临界点在哪里？换句话说，这个半圆上最多能放稳一块多厚的木板？</strong></p>
<p>    <img alt="image placeholder" >
<p>    把半圆的半径记作 R ，把木板的厚度记作 t 。如果把木板平放在半圆上，其重心的高度就是 R + t/2 。假如这块木板倾斜了一个微小的角度 θ ，那么图中 M’T 的长度等于弧 MT 的长度，即 2πR·(θ/2π) = R·θ 。此时，木板的重心 G’ 的高度变为了 (t/2)cosθ + (R·θ)sinθ + R·cosθ。为了让木板保持平衡，不会自动往下滑，我们需要让新的重心高度大于原来的重心高度，即 (t/2)cosθ + (R·θ)sinθ + R·cosθ &gt; R + t/2。解出不等式，再令 θ→0 ，即可得到 t &lt; 2R。也就是说，一旦木板的厚度超过半圆的直径，木板就无法放稳了。</p>
<p> <br>
 <br>
    <strong>假如你面向东边，站在冰面上，鞋底与冰面完全没有摩擦。你能否做出一系列动作，使得自己最后能面向西边站立？</strong></p>
<p>    <img alt="image placeholder" >
<p>    可以。只需要重复“伸臂－挥臂－屈臂”的动作，你的身体便会向反方向转动一点。期待实验党。</p>
<p> <br>
 <br>
    <strong>用过多年的插座（尤其是插过大功率电器的插座），右边的孔（火线）往往会有过热的迹象。如果是劣质插座，加上经常插拔插头的话，右边的孔甚至会有烧黑了的痕迹。明明是通过相同大小的电流，为什么右边的孔会被烧得更厉害呢？</strong></p>
<p>    目前，这个问题没有一个所谓的标准答案。当然，这个现象本身是否存在也是存疑的。大家不妨来说说自己家里插座的情况。</p>
<p> <br>
 <br>
    <strong>呼拉圈是怎么转起来的？人应该做一个什么样的运动？呼拉圈的转动频率是由什么决定的？和人的体形、运动速度、运动方式有关系吗？是否存在一个最优的频率？⋯⋯</strong></p>
<p>    我有几件事情死活搞不明白，吹泡泡是怎么吹出来的，小舌颤音是怎么发出来的，骑车不动把手是怎么实现拐弯的⋯⋯当然，还有呼拉圈是怎么转起来的。和呼拉圈有关的问题似乎永远也列举不完。如果你真的把它当成一回事仔细分析，你会发现这不是一般的困难。<br>
    2004 年， Biological Cybernetics 上发表了一篇长达 15 页的论文，论文题目是 Coordination Modes in the Multi-Segmental Dynamics of Hula-Hooping 。这篇论文终于不负众望，成功地摘得了诺贝尔奖——当然，是搞笑版的。</p>
<p> <br>
 <br>
    <strong>投一枚硬币，如果是正面，我就去打球，如果是反面，我就去打游戏，如果立起来，我就去学习。不知道大家第一次看到这个笑话时，有没有想过，如果一枚硬币真的有 1/3 的概率正面朝上，有 1/3 的概率反面朝上，有 1/3 的概率立起来，那么这个硬币的半径与厚度满足什么样的关系？</strong></p>
<p>    <img alt="image placeholder" >
<p>    这枚硬币必须满足，把它立起来后，即使倾斜 30 度仍然不倒。这样，硬币直立的“势力范围”才会达到 120 度。因此，硬币的直径应该是厚度的 √<span style="text-decoration:overline">3</span> 倍。</p>
<p> <br>
 <br>
    <strong>考虑某颗星球，它由某种密度均匀的物质组成，其质量为 M ，体积为 V 。如果这颗星球是一个球体，那么它的半径 R = ((3V) / (4π))<sup>1/3</sup>，星球表面上的重力加速度则为 g = GM / R<sup>2</sup> = GM((4π) / (3V))<sup>2/3</sup>，其中 G 是万有引力常数。</strong><br>
    <strong>考虑这颗星球所有可能的形状，怎样的形状才会让星球表面的某一点重力加速度达到最大？最大值是多少？</strong></p>
<p>    下图就是让表面某处的重力加速度达到最大的星球形状。这个图形是一个稍微有些变形的球体，整个图形是一个以 z 方向为轴的旋转体，顶端的 m 点即是重力加速度最大的点，它的重力加速度为 g = (4/5)(15/4)<sup>1/3</sup>π<sup>2/3</sup>M / V<sup>2/3</sup>，只比球形星体的重力加速度大 2.6% 。这是又一个经典的例子——圆形似乎并不是那么完美。</p>
<p>    <img alt="image placeholder" >
<p>    这个问题的解法非常漂亮。首先，假设我们想要让星体表面上的某个点 m 的重力加速度最大，并且所受重力方向在 z 轴上，那么这个星体必然是沿 z 轴方向对称的。否则，取出不对称的一层，把多的部分填进少的部分让它变成一个完全对称的圆盘，这将会让 m 点在竖直方向上的受力变大。不断这样做直到这个图形沿 z 轴完全对称，显然就得到了一个更优的形状。<br>
    接下来的步骤就真的神了。现在，在星体上取一个非常细的圆环，假设它的质量是 dM 。那么，这个圆环所贡献的重力加速度大小就是 G·dM·cosθ /r<sup>2</sup> 。如果把这个圆环从星体中挖掉，放到其它的位置上，那么新的圆环将会有新的 r 值和 θ 值。当整个形状达到最优时，这个形状将位于“极值点”的位置，也就是说它的“微分”为 0 ，任何微小的变动都不会改变 m 的加速度。这就意味着， cosθ / r<sup>2</sup> 是一个常数。这个条件就确定出整个星体的形状。</p>
<p> <br>
 <br>
    <strong>Fermat 光程最短原理指出，光从 A 点到 B 点，总是沿着最快的路径传播。这一神奇的定律一下子就把直线传播定律、反射定律、折射定律统一在了一起。不过，后来我们知道了，更一般的描述应该是，光总是沿着光程处于驻点的路径传播。为什么会加上这一条？有没有光程极大的例子呢？</strong></p>
<p>    <img alt="image placeholder" >
<p>    这里有一个例子。考虑椭圆内的两个焦点 A 、 B ，和椭圆上的一点 M 。显然，不管 M 取在哪儿， AM + BM 都是相同的。现在，在椭圆内部画一条曲线，这条曲线与椭圆相切于 M 点。然后，擦掉原来的椭圆，把这条曲线视作镜面。显然， AMB 仍然是一条反射光线，但从其它地方反射，光程都会小于 AMB 。 AMB 是一个光程极大的路径。</p>
<p> <br>
 <br>
    <strong>物理量的单位总是由基本单位（质量、长度、时间等）的幂相乘得来的。比如，能量的单位就是 1J = kg·m<sup>2</sup>·s<sup>-2</sup> 。为什么没有什么物理量，它是由基本单位通过更复杂的形式导出的？比如说，为何没有什么物理量，它的单位是 sin(kg)·log(m) ？</strong></p>
<p>    这是一个非常有趣，无疑也是非常深刻的问题。它让我们开始认真思考一个看上去很不像问题的问题：什么是物理量？什么是物理单位？我们需要去挖掘物理量和物理单位的最基本、最本质的性质。<br>
    网站上的标准答案是，只有这种形式的导出单位才能保证，在不同的单位制下，得到的导出单位是等价的。<br>
    具体地说，物理单位的作用就是用来描述，当各个基本单位的尺度变化以后，这个物理量会发生怎样的变化。比如说，密度单位是质量除以长度的三次方，就表明如果质量扩大到原来的 2 倍（或者说单位量变成了原来的 1/2 ），长度扩大到原来的 4 倍（或者说单位量变成了原来的 1/4 ），那么这个物理量将会变成原来的 2/4<sup>3</sup> = 1/32 。<br>
    现在，假设某个物理量的单位是质量的正弦乘以长度的对数。按照国际标准单位制，这个单位是 sin(kg)·log(m) 。假如单位换成了 sin(g)·log(cm) ，那么这个物理量将会变成原来的 sin(1000)·log(100) ≈ 3.80792 。再继续换算成 sin(mg)·log(mm) ，物理量应该继续变成原来的 sin(1000)·log(10) ≈ 1.90396 。但是，如果从 sin(kg)·log(m) 直接变到 sin(mg)·log(mm) ，物理量应该变成原来的 sin(1 000 000)·log(1000) ≈ -2.41767 ，这就和前面的结果矛盾了。利用一些微积分知识可以证明，如果一个合成物理单位不会出现这样的问题，它必然是基本单位的幂的乘积的形式。<br>
    不过，这个解释并不能让我十分满意。大家怎么看呢？</p>
<p> <br>
 <br>
    <strong>有一个无穷大的正方形网格，每条小线段都是 1Ω 的电阻丝。求相邻两点间的等效电阻阻值。</strong></p>
<p>    <img alt="image placeholder" >
<p>    这个问题有一个很妙的解法。假设一个大小为 1A 的电流从红点处流入，从各个无穷远处流出。由对称性，有 (1/4)A 的电流将会流过红蓝两点之间的线段。现在，再假设一个大小为 1A 的电流从各个无穷远处流入，从蓝色点流出。由对称性，红蓝两点之间的线段仍然有 (1/4)A 的电流。现在，把两种情况叠加在一起看，大小为 1A 的电流从红点进去从蓝点出来，那么，红蓝两点间的线段就有 (1/2)A 的电流。因而，两点间的电压就是 (1/2)A·1Ω = (1/2)V 。因而两点间的等效电阻就是 (1/2)V / 1A = (1/2)Ω。</p>
<p>    说到无穷网格电阻的问题，我们有说不完的话题。这个问题本身的扩展非常之多。例如，我们可以把问题扩展到 N 维的情形：N 维无限电阻网格中，相邻两点的等效电阻是多少？利用同样的方法可以得出，答案就是 1/N。</p>
<p>    回到二维情形，如果我们换一个扩展方向，改问对角两点间的电阻，上述分析方法就不行了。而这个加强版问题的答案也更加玄妙：两点间的阻值为 (2/π)Ω 。大家可以在网上很多地方查到这个加强版问题的解法。</p>
<p>    <img alt="image placeholder" >
<p>    <a href="http://xkcd.com/356/">xkcd</a> 有一个经典漫画，形象地描绘出 nerd 们被数理趣题折磨的感受。当然，这幅画本身也折磨了不少人，网上涌现出大量对这个问题的讨论。</p>
<p>    <img alt="image placeholder" >
<p>    还有一种经典的无穷电阻问题：一个向右无穷延伸的梯子形网格，每条线段都是 1Ω 的电阻，求两点间的等效电阻。</p>
<p>    <img alt="image placeholder" >
<p>    问题的解法非常漂亮。假设我们要求的答案是 R，则 R 可以看作是三个 1Ω 的电阻串联，然后把一个阻值为 R 的电阻（也就是它本身）与中间那个  1Ω 电阻并联所得。于是得到等量关系 R = 1 + 1/(1+1/R) + 1，解得 R = 1 + √<span style="text-decoration:overline">3</span>。</p>
<p>    <img alt="image placeholder" >
<p>    还有一些经典的求电阻问题。其中一个问题是，一个正方体的 12 条棱上各有一个 1Ω 的电阻，求距离最远的两个顶点之间的等效电阻。 2007 年 10 月份 <a href="http://domino.research.ibm.com/comm/wwwr_ponder.nsf/challenges/October2007.html">IBM Ponder This</a> 的题目则是，分别考虑五种正多面体，如果每条棱上各有一个 1Ω 的电阻，则相邻两顶点的等效电阻是多少？巧妙地利用对称性，这几个问题都可以迅速被秒杀。</p>
<p> <br>
 <br>
    <strong>假设有一个圆锥形的冰山，冰山表面绝对光滑。你打算把一个绳圈套在山尖上，然后沿着绳索爬上去。考虑两个极端情况：如果冰山特别尖，顶角特别小，这个计划自然不成问题；但若冰山特别“肥”，顶角特别大，向下拉绳子后，绳圈将会滑出山尖。这中间一定有一个临界点，也就是绳圈掉不出来的最大顶角。这个顶角是多大？</strong></p>
<p>    <img alt="image placeholder" >
<p>    这是一个非常有趣的问题。问题的本质就是，绳圈在怎样的圆锥面上才存在“被拉紧”的稳定状态。容易想到，绳子被拉紧，意味着绳圈从 A 点出发，将沿最短路径绕过山尖一周，再回到 A 点。如果把圆锥的侧面展开成扇形，绳圈其实就像下面这样（图中的 A 点和 A’ 点在圆锥上是同一个点）。</p>
<p>    <img alt="image placeholder" >
<p>    显然，当这个扇形的顶角小于 180 度时，这样的绳圈才可能存在；而当这个扇形的顶角大于 180 度时，拉紧的绳圈就会滑到山尖外面去。据此不难推出，所求的临界情况就是，圆锥的高与母线的夹角为 30 度。</p>
<p> <br>
 <br>
    <strong>n 块相同的木板重叠，最多能够伸出桌面多远？</strong></p>
<p>    <img alt="image placeholder" >
<p>    这是一个非常经典的问题。传统的答案是，把第一块木板的重心放在第二块木板的右边缘，把这两块木板的重心放在第三块木板的右边缘，把这三块木板的重心放在第四块木板的右边缘⋯⋯利用杠杆原理可以推出，如果每块木板都是单位长，那么 n 块木板可以伸出桌面 (1 + 1/2 + 1/3 + … + 1/n) / 2 个单位的长度。由调和级数的性质，我们立即可以得知，只要木板数量足够多，木块伸出桌面的长度是没有上界的，想伸出去多长就能伸出去多长。但同时，这个增长速度也非常缓慢⋯⋯ 20 块木板只能伸出大约 1.79887 个单位的长度， 1000 块木板也只能伸出大约 4.8938 个单位的长度。</p>
<p>    <img alt="image placeholder" >
<p>    不过，采用一些其它的方案（比如拿几块木板在后方作为“配重”），我们可以让木板伸出的长度更远。下面是一篇非常经典的论文，总结了目前对这个问题的研究结果： <a href="http://arxiv.org/abs/0707.0093">http://arxiv.org/abs/0707.0093</a> 。</p>
<p> <br>
 <br>
    <strong>上楼时，人克服重力做功，需要耗费很多能量。但是，在平地上行走时，人并没有做功。那么，为什么我们走路时还要耗费能量呢？</strong></p>
<p>    1999 年 3 月的 Scientific American 上说到，其实在步行时，我们也是要克服重力做功的。这是因为，在步行的过程中，人的重心会一上一下地摆动。当两腿一前一后着地时，人的重心偏低；而单腿着地迈步时，人的重心会升高大约 3cm 。我们走路的能量主要就消耗在了这里。<br>
    当然，事实上，即使人不走路，光是原地站着，也是要耗费能量的（大约为 80W ）。假设人的步行速度是 v ，那么步行所用的能量可以用公式 P = 80W + K·v 大致算出，其中 K·v 就是步行过程中耗费的能量，系数 K 大约为 160N 。<br>
    教中学物理最怕聪明孩子，一些古怪的问题常常会让老师也支支吾吾答不上来。初中物理中，有几个最不好给学生解释的事情。走路不做功，为什么还要耗费能量？电流从电厂来又回到电厂去，为什么我们还要支付电费？把装满水的水杯不盖纸片直接倒过来，为什么大气压没有把水支撑起来？拳头打在墙上后将会受到墙给拳头的反作用力，但若拳头挥空了，这个力的反作用力是什么？<br>
    你都打算怎么解释？</p>
<p> <br>
 <br>
    <strong>橄榄油的沸点是 300℃ ，锡的熔点是 231.9℃ 。为什么我们能在锡锅里炸东西？</strong></p>
<p>    答案：橄榄油并没有沸腾，沸腾的其实是食物里的水。而且，正是食物里的水才让橄榄油和锡锅都保持在 100℃ 。如果食物里的水被烧干了，食物就会被烧焦，锡锅当然也会被烧毁。</p>
<p> <br>
 <br>
    <strong>在晃动的火车车厢上，把一瓶水放在小桌子上。如果想让这瓶水放得更稳，有一个极其简单的方法。这个方法是什么？</strong></p>
<p>    答案：喝掉一部分水，让整瓶水的重心下降。<br>
    注意，这里又有一个有趣的极值问题。如果瓶子里装满水，整个系统的重心显然要比只装有一部分水时更高；但若把水全部喝掉，只剩一个空瓶子，整个系统的重心仍然会比有一部分水时高。建立模型，求出使得整个系统重心最低的水位高度，是一个绝佳的物理课题。<br>
    有一个蛮有意思的结论：当整个系统的重心达到最低时，水位一定和此时整个系统的重心高度相同。其实这个很好理解：当水位没有达到整个系统的重心高度时，每加一点水，都相当于在重心下方填充质量，让重心下降；但水位高度超过了整个系统的重心，则每加一点水，都相当于在重心上方新添质量，重心便会开始上升了。</p>
<p> <br>
 <br>
    <strong>12 节 1V 的电池首尾相接，然后将一块电压表如图连接。电压表的示数是多少？</strong></p>
<p>    <img alt="image placeholder" >
<p>    有时候，方言的力量真是强大。看到这个题目后，我脑子里闪过的第一个形容词就是重庆话“想得出来”，但始终没找到合适的普通话替代词。总之，这题可以说是非常具有想象力了。<br>
    答案是 0V 。假设每个电池的内电阻是 R ，这个回路的电流就等于 12V 除以 12R ，即 (1V)/R 。于是，每个电池的内电压就是 R·(1V)/R = 1V ，而这恰好是这个电池的电动势。因此，每个电池的外电压都为 0 。对于一组连续的电池来说，这个推理同样成立。</p>
<p> <br>
 <br>
    <strong>为什么跳蚤、蚱蜢、人和狮子，尺寸差异那么大，但能跳起的最高高度都是 1 米左右（最多相差一个不超过 2 的系数）？</strong></p>
<p>    看到这个问题之后，我在 Google 里搜了一下，竟然真是这样。猫猫狗狗老鼠老虎，可以跳起的高度都在 1 米这个尺度左右——猫猫和狗狗都能跳 1 米左右，老鼠能跳 40 厘米，老虎能跳 2 米。你以为袋鼠牛 B 吗？其实袋鼠也只能跳 2 到 3 米高。注意，这里的跳起高度并不是指“手能摸到的高度”，而是生物让自己重心升高的高度。<br>
    有人可能想到了原因。一个动物身体小，力量也小，但正因为它身体小，跳起 1 米也不需要太大的力。反之，大型动物力量倒是大，不过要跳起来确实也需要很大的力。这就让动物们能够跳起的高度变得平衡。<br>
    不过，为什么这两个因素能够平衡，而不是一个压过另一个呢？假设生物的形体和密度都相近，我们就可以漂亮地证明这一点：把一次跳跃中足部可以提供的能量记作 E ，生物自身的重量则记作 W ，那么生物跳起的高度应该正比于 E/W 。如果再把生物的尺寸（一维上的长度，比如身长）记作 L ，那么 W 是与 L<sup>3</sup> 成正比的。而 E 则等于肌肉提供的力乘以这个力能够牵引的肢体运动距离，其中前者与肌肉的横截面积成正比，也就与 L<sup>2</sup> 成正比，后者和足部长度成正比，也就是和 L 成正比。因此， E 和 L<sup>3</sup> 成正比。于是， E/W 与 L 无关！<br>
    小时候大家应该都听说过，跳蚤巨牛无比，能跳起 1 米多高，是自身高度的 100 多倍。原来，不管什么都能跳起 1 米多高，这个倍数关系这么惊人，只是因为跳蚤自己太矮罢了。</p>
<p> <br>
 <br>
    <strong>一个空心正方体的内部有六面墙。能否让一个小球在每一面墙上都各反弹一次，最后又回到出发点（假设没有重力）？</strong></p>
<p>    <img alt="image placeholder" >
<p>    可以。这是由 Hugo Steinhaus 首先发现的。注意，每反弹一次，只会让速度中的其中一个分量变为相反数，因此六次反弹后，速度向量会和出发时相同。为了让六次反弹后还能回到出发点，我们只需要再让各段路程的长度都相同就行了。上图中的方案里，每段路程都是一个小立方体的对角线，因而最后就正好能回到原点。</p>
<p> <br>
 <br>
    <strong>一个物块从高度为 h 的光滑斜面顶端开始下滑，下滑到底端后沿光滑水平面以速度 v 匀速直线运动下去。初始时，物块的重力势能为 mgh ；到了斜面底部后，重力势能为0，完全转化为了动能 (1/2)mv<sup>2</sup>。由此我们可以解出， v = √<span style="text-decoration:overline">2gh</span> 。</strong><br>
    <strong>现在，假设你坐在一个以 v 的速度向右做匀速直线运动的车里。如果以你为参照物，你将会看到，斜面顶端的物块初始时机械能为 mgh + (1/2)mv<sup>2</sup>，而到了斜面底端后，机械能突然变成 0 了！这该怎么解释呢？</strong></p>
<p>    <img alt="image placeholder" >
<p>    这是一个非常漂亮的问题，大家不妨多想一想。简单地说，就是在新的参照系下，物体并不是沿着直线下滑，斜面也对物体做功了。不过，这只能解释一部分“消失”的机械能。具体答案在 <a href="http://star.tau.ac.il/QUIZ/99/A07.99.html">http://star.tau.ac.il/QUIZ/99/A07.99.html</a>。<br>
    有网友来信说，从根本原因上看，只要把斜面本身也算进系统里，考察斜面的能量，就不会产生不守恒的问题了。</p>
<p> <br>
 <br>
    <strong>有一段横截面是等边三角形的木头，密度为 0.5g/cm<sup>3</sup> 。它在水中漂浮时，哪头会朝上？</strong></p>
<p>    <img alt="image placeholder" >
<p>    答案：如图所示，漂浮时，它的其中一条中线一定和水面重合。这是因为，通过计算可知，此时整个物体的重心 G<sub>1</sub> 和浸入水中的部分的重心 G<sub>2</sub> （也就是浮力的作用点）正好在同一竖直线上，并且高度差达到最小值。</p>
<p> <br>
 <br>
    <strong>20 世纪初，一本名为 Power 的杂志上曾经登载了这样一个永动机模型。如图，把光滑绳圈套在滑轮上，绳圈右侧浸在水中。于是，绳圈右侧将持续受到一个竖直向上的浮力，绳子便逆时针转动了起来。</strong><br>
    <strong>这个永动机模型可行吗？如果不可行，问题出在哪儿？</strong></p>
<p>    <img alt="image placeholder" >
<p>    答案：废话，当然不可行。可是，这个模型错在哪儿呢？注意，浮力其实是物体上下表面的液体压强差产生的。因此，浮力只会出现在完全浸入液体，或者漂浮在液体表面的物体上。在这个例子中，绳子并不会受到浮力。如果你把绳子想像成是一片片圆盘拼成的，每个圆盘都只受到侧面来的液体压强，在绳子的方向上是不可能有力产生的。<br>
    围观更多的永动机，请移步 <a href="http://en.wikipedia.org/wiki/History_of_perpetual_motion_machines">http://en.wikipedia.org/wiki/History_of_perpetual_motion_machines</a> 。</p>
<p> <br>
 <br>
    <strong>秤上放着一个玻璃瓶子，瓶盖是密封的。一只苍蝇飞在瓶子中，没有挨着瓶子。秤的示数等于瓶子的重量，还是大于瓶子的重量？如果苍蝇靠栓在身上的一个小氢气球浮在瓶子中呢？</strong></p>
<p>    这是一个经典问题了。对于前一个问题，秤的示数应该大于瓶子的重量，多的这点重量正好就是苍蝇自身的重量。这是因为，苍蝇要想飞起来，必须要给空气一个等于自身重量的向下的力（从而获得一个等于自身重量的向上的力）。空气将会把这个力传到瓶底，也就是对瓶底施加一个相同的力。<br>
    对于第二个问题，答案是，秤的示数就等于瓶子的重量。如果苍蝇受空气浮力悬浮在空中，我们就可以把苍蝇连同气球所占据的位置等价地用空气来替换，毕竟瓶子里悬浮着一只气球苍蝇和悬浮着一坨空气没什么两样嘛。这样看来，秤的示数就是瓶子的重量了。<br>
    这个问题扯开来，也有一大堆可以说的。初中物理有一道经典题目：把一杯水放在秤上，然后手指伸进水里（手指未碰到杯底，水未溢出），问秤的示数怎么变。答案是，变大了。因为水位升高，对杯底的水压增大了，从而杯底受到的压力也就增大了。当然，按照之前的思路，我们还有一个更好的解释。你的手指受到了一个竖直向上的浮力，水自然也就受到了一个竖直向下的反作用力，这个力的大小就等于手指排开水的重量。因此，你可以把手占据的位置替换成一堆水。可见，杯子里的水量相当于是凭空增加了，秤的示数自然也就增加了。<br>
    大家估计听过一个脑筋急转弯，说一个独木桥载重 80 公斤，为什么一个重 70 公斤的人可以拿着两个各重 10 公斤的球过桥？答案是，这个人像杂技演员一样，轮流把球扔到空中，保证手里只有一个球。不过大家仔细想想便会发现，这个题明显有 bug 。你需要给球一个大于 10 公斤的力，才能让球加速上升；此时，球会给你一个大于 10 公斤的反作用力，这样就超过独木桥的载重了。</p>
<p> <br>
 <br>
    <strong>云是由小水滴组成的。水的密度是空气密度的 800 多倍。为什么云不会掉下来？</strong></p>
<p>    我操，这个问题太有型了！我在反省自己，为什么小时候听说“云是由小水滴组成的”的时候，没有提出过这个问题呢？<br>
    这个问题的答案是，云就是会往下掉的，只不过下落的速度非常慢⋯⋯<br>
    云中的小水滴颗粒极小，因而小水滴受到的空气阻力，其数量级和自身重力相当。计算可知， 1 微米的水滴下落速度约为 0.13 毫米每秒，也就是一天下降 11 米。即使是 10 微米的水滴，下落速度也很慢，大约每天 1.1 千米。如果不精确测量的话，我们是没办法观察到的。详细计算过程可以见这里： <a href="http://star.tau.ac.il/QUIZ/98/A10.98.html">http://star.tau.ac.il/QUIZ/98/A10.98.html</a> 。<br>
    这让我想起一个冷知识：蚂蚁是摔不死的，因为空气阻力和自身重力相当。这又让我想起一个冷笑话：蚂蚁从摩天大楼摔下去，是怎么死的？答案是——饿死的。</p>
<p> <br>
 <br>
    <strong>利用蹦床一次，你可以跳到多高？</strong></p>
<p>    答案：两倍原地起跳的高度。蹦床自己既不会消耗能量，也不会提供能量，因而你跳到蹦床上以后，蹦床储存的弹性势能只能把你弹回到一次起跳的高度。你在蹦床上再跳一次，便能跳到两倍高。</p>
<p> <br>
 <br>
    <strong>大家在电影的各种爆炸场面里都会看见这样一个情景：一个正在倒下的烟囱，在倒下的过程中，会自己断成两截。断裂处将出现在烟囱的什么位置？</strong><br>
    <strong>这是 MIT 的一道入学考试题。</strong></p>
<p>    <img alt="image placeholder" >
<p>    这个问题很漂亮。在断裂之前，整个烟囱显然以一个相同的角速度在下落。考虑烟囱的顶部，由于自身重力的影响，它本来应该下落得更快，但却被强行地“扳”回到一个和烟囱下部相同的角速度。这使得烟囱最终发生断裂。计算可知，断裂将发生在烟囱的 2/3 处。更技术的分析请看 <a href="http://star.tau.ac.il/QUIZ/96/A07.96.html">http://star.tau.ac.il/QUIZ/96/A07.96.html</a> 。</p>
<p> <br>
 <br>
    <strong>为什么床单、被罩、桌布上的污渍都是这种形状？</strong></p>
<p>    <img alt="image placeholder" >
<p>    相信大家都曾经遇上过这样的现象吧。这个问题要解释起来，还真不容易——网上提出此问题后，无一人答对。很多人都说，液体中含有什么什么，布料里含有什么什么等等。其实，这种现象是很普遍的，它与布料、溶剂、溶质都没关系。这种现象真正的原因，是和液体蒸发的模式有关的。如果液体表层蒸发了，液体会向外展开，填充刚刚流失的部分。其结果就是，液体会不断地向边缘涌去，造成了边缘痕迹堆积。</p>
<p>    <img alt="image placeholder" >
<p>    对几种不同的蒸发模式进行模拟，可以看到不同的污渍形状，进而很好地说明了上述推测的正确性。</p>
<p>    <img alt="image placeholder" >
<p> <br>
 <br>
    <strong>为什么水渍是深色的？</strong></p>
<p>    这是个好问题呀！我们每天都会遇上这样的事情，已经习以为常，却从来没有想过为什么。真要问个为什么，嘿，还真不好回答。<br>
    在网站上，这个问题同样无人答对。根据布料的不同，官方给出了两种解释，大家可以去看看： <a href="http://star.tau.ac.il/QUIZ/96/A11.96.html">http://star.tau.ac.il/QUIZ/96/A11.96.html</a> 。</p>
<p> <br>
 <br>
    最后，附上一些我以前收集的一些漂亮的物理谜题。</p>
<p> <br>
 <br>
 <br>
    <strong>你现在正位于赤道，此时太阳刚刚升起。你要用一把激光炮轰炸太阳中心。你应该瞄准什么地方？</strong></p>
<p>    你应该瞄准太阳的中心。有人会说，不对呀，阳光不是会被大气层折射吗？但是，你射出的激光也会被折射，由于光路是可逆的，因而你就该瞄准你看到的太阳。有人会说，还是不对呀，太阳光射到地球需要 8 分钟，你看到的太阳是 8 分钟前的太阳，现在太阳已经不在原来的位置了呀？你又被坑了——太阳是不动的，动的其实是地球。</p>
<p> <br>
 <br>
    <strong>用天平测量物体的重量（准确地说，是质量）时，如果砝码有磨损，那么测量结果会偏大还是偏小？仔细想想吧，这题很容易答错。</strong></p>
<p>    这是初中物理最阴险的陷阱题目之一。绝大多数人会认为，既然砝码被磨损了，没有它标识的那么重了，那么测量结果一定是偏小了。答案恰恰相反，如果砝码有磨损，测量结果应该偏大了。 正因为砝码没有它标识的那么重，所以我们才需要在天平上添加更多的砝码让它保持平衡。因此，测量出来的结果会更大一些。</p>
<p> <br>
 <br>
    <strong>用一盆水，一张纸，一台电子秤，如何测量一个给定排球击打在地上对地的作用力有多大？</strong></p>
<p>    首先把纸张铺在地上，在排球上蘸水，然后对着地上的纸击打。这样一来，纸上便留下了一个圆形的水印。然后，把印有水的纸铺在电子秤上，把排球放在纸上，一点一点向下挤压排球，直到排球的下底面与水印重合。此时，电子秤上的示数也就是排球击打在地上时的作用力了。<br>
    这是间接测量实验设计问题中让人拍案叫绝的一道好题。</p>
<p> <br>
 <br>
    <strong>一个人站在湖里的一艘船上，把一颗石子扔进湖里。湖水的水位将会发生怎样的变化？</strong></p>
<p>    答案：湖面将会变低。这是一个非常经典的初中物理问题。由浮力公式，物体所受的浮力等于它排开水的重力。初始时，船、人、石子都在水面上静止，它们的总浮力（也就是总的排开水重量）等于总重力；但石子投入水中后将会沉底，它所受到的浮力小于它的重力，因此船、人、石子的总浮力（同样即为排开水的总重）小于它们总重力。也就是说，排开水的总量减少了，因而水位将会下降。<br>
    这是最标准的解法。每次讲到这个问题时，我都喜欢讲讲另外一种直观的理解方法。不妨把这个将会被投掷出去的石子悬挂在船的底部。由于漂浮在水面上的船、人和石子的总重力不变，因此总的排开水重量也不变，这样的假设不会改变水位高度。现在，把悬挂石子的绳子剪断，于是石子下沉，船会上浮一些，致使水位下降。</p>
<p> <br>
 <br>
    <strong>两根一模一样的金属棒，一根是磁铁，一根是普通的金属棒。没有其他工具，怎样把它们区别开来？</strong></p>
<p>    把它们摆成一个 T 字形。如果相吸，竖着的就是磁铁；如果没有相吸，横着的就是磁铁。<br>
    磁铁中部几乎没有磁性。</p>
<p> <br>
 <br>
    <strong>为什么镜子里的东西是左右颠倒的，不是上下颠倒的？</strong></p>
<p>    这是一道经典智力题了，镜子问题、羊与车问题和 0.9999… = 1 的问题可谓是引发口水战的三大法宝。哪个论坛想要增加人气的话，把这三个问题挨着发一遍就行了。问题的答案是，镜子里的东西既不是左右颠倒，也不是上下颠倒，而是前后颠倒的。不过，人们似乎并不喜欢接受“镜像”的概念，总爱拿镜子里的东西跟实际的东西来比。但是，两个镜像的东西怎么转都不能完全重合，于是纠结的事情就发生了。如果你想象镜子里的东西水平转 180 度转回去，这并不能和实际物体重合，每个东西都左右颠倒了。如果你想象镜子里的东西竖直方向转 180 度，这样也不能和镜子前的物体重合——左右倒是没问题，但上下就颠倒了。不过，人们生活在一个水平面上，人本身的对称轴正好又是竖直方向上，因此人总是习惯性地采用了前一种思维。<br>
    为了摆脱传统思维的束缚，不妨假设镜子前的物体是一个三角形什么的，想象起来就会方便多了。<br>
    Geek 小美女 <a href="http://localhost-8080.com/2011/03/why-counterclockwise-open/">localhost_8080</a> 曾对左手右手左手系右手系左右颠倒左右镜像纠结过很久，她曾在 Twitter 上提过一个非常有趣的问题：某地外生命在飞船中，你只能用无线电与它交流，如何通过口头描述指导它在一双手套中分辨出右边的那一只？<br>
    你打算怎么办？</p>
			 ]]></content>
<pubDate>2011-06-02T23:18:07+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4372</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 史上最Geek的桌游：ERGO ]]></title>
<link>http://www.matrix67.com/blog/archives/4400</link>
<content><![CDATA[ 
		<p>    我先认错，这实在有些标题党了；不过看完游戏规则介绍，我的第一感受确实是这样——这无疑是最适合数学 Geek 的卡牌游戏。在游戏中，玩家们需要轮流出牌，在置牌区中构造出有利于自己的逻辑表达式，证明自己的存在。哈哈，听上去很有意思吧！让我先来详细说说游戏规则。</p>
<p>    ERGO 是 2009 年 Catalyst Game Labs 出品的一款桌游。游戏共有 55 张牌，包括：</p>
<p>      变量牌 16 张，其中 A 、 B 、 C 、 D 各 4 张<br>
      符号牌 20 张，其中 AND 、 OR 、 THEN 各 4 张， NOT 牌 8 张<br>
      括号牌 6 张，其中左右括号各 3 张<br>
      白板牌 1 张<br>
      回转牌 1 张<br>
      谬误牌 3 张<br>
      辩解牌 3 张<br>
      万能牌 2 张，其中变量万能牌和符号万能牌各 1 张<br>
      ERGO 牌 3 张</p>
<p><span id="more-4400"></span><br>
    <img alt="image placeholder" >
<p>    这个游戏需要 2 到 4 个人来玩。游戏开始前，给每个人各分配 A 、 B 、 C 、 D 中的一个字母。然后洗牌，每人摸起五张牌作为手牌，游戏便正式开始。<br>
    玩家按顺时针方向轮流行动。轮到某个玩家行动时，该玩家需要摸起两张牌，然后打出两张牌。如果没有可以打的牌，或者不想出牌的话，要弃掉相应数量的牌，总之要保证最后手牌还是五张。</p>
<p>    <img alt="image placeholder" >
<p>    只有变量牌、符号牌和括号牌才能放进置牌区，这些牌一个挨着一个摆放，构成若干行合法的逻辑表达式。在任意时刻，桌面上最多有四行逻辑表达式（也就是四个前提）。玩家的目的就是尽可能让桌面上的这些前提能够证明自己为真，其他人为假。最常规的出牌方式，就是给桌面上的逻辑表达式添砖加瓦。你可以插入一张符号牌和一张变量牌，或者插入一个 NOT ，或者插入一对括号，等等。总之，当你出完牌后，置牌区中的逻辑表达式必须仍然合法，不能出现变量牌相邻、符号牌相邻、括号不匹配之类的情形。如果桌面上的逻辑表达式不到四行，你可以另起一行。<br>
    有几点需要注意。一个是优先级的问题：在 ERGO 中， NOT 的优先级最高，其次是 THEN ，再次是 OR ，最后是 AND 。另外， NOT 不能连用。 ~ ~ A 只能写成 ~ ( ~ A ) 。</p>
<p>    玩家可以打出白板牌（Tabula Rasa，中译作“白板”，哲学名词，表示人的个体生来没有内在的或者与生俱来的心智），然后从任意一个逻辑表达式中删掉一张牌。通常删掉一张牌后，逻辑表达式都不再合法了，因此通常你还得再出一张牌补上。白板牌只能用一次，用完即弃。<br>
    玩家还可以打出回转牌（Revolution），然后从置牌区中任意选择两张同种类型的牌（变量牌或者符号牌，可以来自不同的表达式），交换它们的位置。回转牌只能用一次，用完即弃。<br>
    这两种牌的威力特别大，很可能给整个局势带来 360 度大转变。不过，好在这两种牌各只有 1 张。</p>
<p>    还有两种比较特殊的牌，谬误牌（Fallacy）和辩解牌（Justification）。对某个玩家使用谬误牌后，目标玩家在接下来的三回合内禁止在置牌区内放牌（但仍然可以摸牌弃牌、对其他人用谬误牌等等）。实际游戏过程中，玩家可以每次把自己面前的谬误牌旋转 90 度，表示已经被禁一轮；谬误牌转了一周后，玩家就恢复了全部的行动能力。玩家可以对自己用一张辩解牌，提前解掉谬误牌。这里还有一个小规定：不能对已经出过辩解牌的玩家再次使用谬误牌。</p>
<p>    卡牌中还有两张万能牌，一张牌的四个角上分别写有 A 、 B 、 C 、 D ，一张牌的四个角则分别是 AND 、 OR 、 THEN 和 NOT。出牌时，把牌旋转到对应的位置，插入到逻辑表达式中，代替对应的变量牌或者符号牌。万能牌也可以用作辩解牌和马上将说到的 ERGO 牌。</p>
<p>    最后就是 ERGO 牌了。ergo 是拉丁语 therefore 的意思，相当于证明里面的“所以说”。出示 ERGO 牌就表明“证毕”，然后开始统计得分。对于每一个被证明为真的变量，置牌区有多少张牌，就奖励对应玩家多少分。如果逻辑表达式中出现矛盾，则谁也不得分。<br>
    有两点需要注意。首先，只有置牌区中每种字母都出现了时，才能出示 ERGO 牌。另外，如果牌已经摸完了，即使没有人出 ERGO 牌，游戏也自动进入“证毕统分”的阶段。</p>
<p>    游戏结束后洗牌重玩。第一个得到 50 分的人获胜。</p>
<p>    下面是一个游戏实例。 A 、 B 、 C 三位玩家游戏，初始时每人五张手牌。 A 摸起两张手牌，打出一张 A ，弃掉一张：</p>
<p><code>A</code></p>
<p>    B 摸起两张牌，打出 OR 和 B ：</p>
<p><code>A ∨ B</code></p>
<p>    C 摸起两张牌，打出 NOT 和 B：</p>
<p><code>A ∨ B<br>
~ B</code></p>
<p>    A 摸起两张牌，打出 NOT 和 C：</p>
<p><code>A ∨ B<br>
~ B<br>
~ C</code></p>
<p>    B 摸起两张牌，打出 THEN 和 C ：</p>
<p><code>A ∨ B<br>
~ B → C<br>
~ C</code></p>
<p>    C 摸起两张牌，打出一对括号牌：</p>
<p><code>A ∨ B<br>
~ B → C<br>
( ~ C )</code></p>
<p>    A 摸起两张牌，给 B 一张谬误牌，然后弃掉一张。 B 摸起两张牌，因为无法出牌，弃掉两张。 C 摸起两张牌，出了一张 NOT 和一张 D：</p>
<p><code>A ∨ B<br>
~ B → C<br>
~ ( ~ C )<br>
D</code></p>
<p>    注意，此时已经有四行表达式，不能再另起一行了，只能往已有表达式里添加元素。并且，所有字母都已经打出，游戏随时可以结束。<br>
    接下来又轮到 A 了。 A 摸起两张牌，使用一张白板删掉了第二行中的 THEN ，然后放了一张 AND ：</p>
<p><code>A ∨ B<br>
~ B ∧ C<br>
~ ( ~ C )<br>
D</code></p>
<p>    B 继续摸牌弃牌；C 觉得这个结局能够接受，便打出了 ERGO 牌。此时，只有 A 、 C 、 D 被证明了，因而 A 和 C 各得 12 分。</p>
<p>    这个游戏算是相当有创意了。不过，真要玩起来会是什么样子呢？我在网上大致看了看，反馈情况并不好。除了游戏本身的平衡性有待加强以外，官方的规则说明本身竟也含混不清漏洞百出。看来，生产商似乎并没有想要认真发展这个如此具有潜力的游戏。期待各路桌游高人能够沿着这个思路继续想下去，设计一款真正又强大又好玩的数理逻辑桌游吧。</p>
<p> <br>
  购买、评价、讨论等信息： <a href="http://boardgamegeek.com/boardgame/55279/ergo">BoardGameGeek</a><br>
  漏洞百出的官方游戏说明： <a href="http://catalystgamelabs.com/pdfs/Ergo_Rules_LO.pdf">http://catalystgamelabs.com/pdfs/Ergo_Rules_LO.pdf</a><br>
  如果你喜欢这个，不妨看看 <a href="http://www.matrix67.com/blog/archives/344">Eleusis Express：非常有创意的多人纸牌游戏</a></p>
			 ]]></content>
<pubDate>2011-06-06T09:50:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4400</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：和为90度的一组锐角，正弦值之和一定大于1 ]]></title>
<link>http://www.matrix67.com/blog/archives/4413</link>
<content><![CDATA[ 
		<p>    偶然瞥见一道很妙的题目：已知三个锐角 α 、 β 、 γ 的和为 90°，求证：sinα + sinβ + sinγ &gt; 1</p>
<p>    这个问题的证明方法有很多，不过大家一定会喜欢下面这个证明：</p>
<p>      <img alt="image placeholder" >
<p>    作一个半径为 1 的 90° 扇形，于是图中 α + β + γ = 90° 。注意到 △ABM 的面积可以写成 (1/2) · AB · AM · sinα = sinα / 2，类似地 △AMN 、 △ANC 的面积分别为 sinβ / 2 和 sinγ / 2 ，但他们的面积之和显然大于 △ABC。于是，sinα / 2 + sinβ / 2 + sinγ / 2 &gt; 1/2，即 sinα + sinβ + sinγ &gt; 1 。</p>
<p>    这个问题来源于张景中的《数学家的眼光》。</p>
			 ]]></content>
<pubDate>2011-06-10T02:42:51+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4413</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 视频：Steiner问题的肥皂膜解法 ]]></title>
<link>http://www.matrix67.com/blog/archives/4418</link>
<content><![CDATA[ 
		<p>    给定 n 个村庄的位置，要想把他们全部连通，最少需要修建多长的公路？这个问题被称为 Steiner 问题，是由数学家 Jakob Steiner 提出来的。注意，和最小生成树不同的是，公路是可以在中间汇合、分岔的。目前已经知道，Steiner 问题是 NP-hard 的，在规模很大的情况下，不能有效地得出最优解来。</p>
<p>     <img alt="image placeholder" >
<p>    然而，大自然却是无敌的，它可以迅速秒杀这样的难题。由于肥皂膜总会试图让自己的表面积最小，利用肥皂膜实验，我们可以轻易获得 Steiner 问题的解。我在很多书上都看到过肥皂膜实验的方法，不过却从没见过真正的实验视频。今天我终于看到了<a href="http://www.youtube.com/watch?v=dAyDi1aa40E">这样的视频</a>，把它搬进墙来，和大家分享。这个视频也很好地解释了一个普遍存在的误区：说肥皂膜实验一举解决了 NP 问题是不恰当的，因为这个实验只能找到极小值，并不能找到最小值，运气不好的话，实验结果会是失败的。</p>
<p><span id="more-4418"></span><br>
 <br>
     <embed src="http://www.tudou.com/v/d7MahcVW4n8/&amp;rpid=46416124/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="580" height="400"></embed></p>
<p> <br>
 <br>
    用物理方法解决数学问题，还有一个经典的例子：<a href="http://www.matrix67.com/blog/archives/422">广义 Fermat 点问题</a>。虽然实验的视觉感官可能没有那么振奋人心，不过还是召唤一下实验党吧。</p>
			 ]]></content>
<pubDate>2011-06-10T13:33:44+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4418</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 巧解定积分：用定积分来求解定积分 ]]></title>
<link>http://www.matrix67.com/blog/archives/4424</link>
<content><![CDATA[ 
		<p>    今天在<a href="http://1over137.wordpress.com/2011/06/04/integration-by-integration-under-the-integral-sign/">这里</a>学到一种很诡异的定积分方法。看看下面这个定积分，你打算怎么求解？</p>
<p>      <img alt="image placeholder" >
<p>    当然，我们假设 a 、 b 满足这个定积分的值确实存在。</p>
<p><span id="more-4424"></span><br>
    下面是一个很妙的做法：</p>
<p>      <img alt="image placeholder" >
<p>    正所谓“用定积分来求解定积分”，实在让人眼前一亮。这告诉我们，“化简”并不一定要化“简”，把问题还原为更复杂的形式，反而会有出其不意的效果。</p>
			 ]]></content>
<pubDate>2011-06-11T14:10:56+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4424</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：公司应该雇用多少员工？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4429</link>
<content><![CDATA[ 
		<p>    某大公司有这么一个规定：只要有一个员工过生日，当天所有员工全部放假一天。但在其余时候，所有员工都没有假期，必须正常上班。这个公司需要雇用多少员工，才能让公司一年内所有员工的总工作时间期望值最大？<br>
    假设一年有 365 天，每个员工的生日都概率均等地分布在这 365 天里。</p>
<p><span id="more-4429"></span><br>
    你的第一感觉或许是，公司应该雇用 100 多人，或者 200 多人吧。答案或许会让你大吃一惊：公司应该雇用 365 个人。注意，雇用 365 个人并不意味着全体员工全年的总工作时间为 0 ，因为 365 个人的生日都是随机的，恰好每天都有一个人过生日的概率极小极小。下面我们就来证明，这个问题的最优解就是 365 人。</p>
<p>    由于期望值满足线性关系（即对于随机变量 X 和 Y 有 E(X) + E(Y) = E(X+Y) ），因此我们只需要让每一天员工总工作时间的期望值最大就可以了。假设公司里有 n 个人，那么在特定的一天里，没有人过生日的概率是 (364/365)<sup>n</sup> 。因此，这一天的期望总工作时间就是 n · (364/365)<sup>n</sup> 个工作日。为了考察函数 n · (364/365)<sup>n</sup> 的增减性，我们来看一下 ((n+1) · (364/365)<sup>n+1</sup>) / (n · (364/365)<sup>n</sup>)  的值，它等于 (364 · (n+1)) / (365 · n) 。如果分子比分母小，解得 n &gt; 364 。可见，要到 n = 365 以后，函数才是递减的。</p>
<p>    这个问题的答案非常出人意料，反直觉性恐怕不亚于经典的生日悖论。它应该可以看作是生日悖论番外篇了吧。对于这个答案，还有什么更直观，更有启发性的解释吗？大家一起来想想吧。</p>
<p>    问题来源：<a href="http://mindyourdecisions.com/blog/2011/06/07/birthday-laws-probability-puzzle/">http://mindyourdecisions.com/blog/2011/06/07/birthday-laws-probability-puzzle/</a></p>
			 ]]></content>
<pubDate>2011-06-13T22:16:12+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4429</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 锈规作图续篇：单用一个只能画单位圆的圆规如何作线段中点 ]]></title>
<link>http://www.matrix67.com/blog/archives/4439</link>
<content><![CDATA[ 
		<p>    在这个 Blog 的一篇<a href="http://www.matrix67.com/blog/archives/497">很老很老的文章</a>里，我曾经讲过一个非常有趣的几何作图问题，这个问题最早是由 D. Pedoe 教授在 1983 年提出的：给定 A 、 B 两点，只用一个生锈的圆规（没有直尺），如何找出一个点 C ，使得 A 、 B 、 C 恰好构成一个等边三角形？所谓“生锈的圆规”，也就是一个被卡住的圆规，它的两脚张角不能改变。我们不妨假设，它只能画出单位大小的圆。1987 年，我国的侯晓荣等人成功地解决了这个问题，并借助复平面理论得到了很多一般的结果，其研究成果《锈规作图论》发表在了《中国科学技术大学学报》上。</p>
<p>    锈规作出等边三角形的方法非常漂亮：利用锈规作图，我们能构造出两点之间由单位长线段构成的折线段，进而实现平行四边形的构造（已知其中三个点，能够只用锈规找出第四个点），进而完成等边三角形的构造。刚才提到的那篇“很老很老的文章”里有详细的描述，继续阅读之前，强烈建议先看一看。</p>
<p>    事实上，D. Pedoe 教授还提过另外一个问题：给定 A 、 B 两点，只用锈规能否作出 A 、 B 连线的中点？注意，由于没有直尺，线段 AB 实际上是画不出的。要想“隔空”找出线段的中点，显然并不容易。</p>
<p>    前几天翻起张景中的《数学家的眼光》，就是为了查阅这个问题的解决方法。《数学家的眼光》一书中详细描述了锈规作图找中点的方法，在这里和大家分享。</p>
<p><span id="more-4439"></span><br>
      <img alt="image placeholder" >
<p>    有了作等边三角形的方法后，有一件很爽的事情，就是我们可以任意地倍长线段了。如图，给定 A 、 B 两点后，连续作三次等边三角形，我们便能得到 E 点，使得 A 、 B 、 E 在一条直线上，并且 AB = BE 。</p>
<p>    接下来的证明过程分成三步。首先我们将说明，如果线段 AB 的长度正好等于 1/√<span style="text-decoration:overline">19</span> ，如何仅用锈规找出线段 AB 的中点。然后我们将进一步推出，只要线段 AB 的长度小于 2/√<span style="text-decoration:overline">19</span> ，我们都能找出 AB 的中点。最后，我们将得到一种找出任意长线段的中点的办法。大家或许会说，在作图之前，我怎么知道 AB 有多长呢？读完全部证明后你就会发现，这其实无关紧要，我们不用知道 AB 的长度，最后得出的方法适用于任何长度的线段。</p>
<p>      <img alt="image placeholder" >
<p>    首先假设 AB = 1/√<span style="text-decoration:overline">19</span> 。用刚才的倍长法，作出同一直线上的 B’ 、 C 、 C’ 三个点，使得 C’B’ = B’A = AB = BC。分别以 C 、 C’ 为圆心，以单位长为半径作圆，两圆相交于点 D 。因此， △DCC’ 就是一个腰长为 1 ，底边长为 4/√<span style="text-decoration:overline">19</span> 的等腰三角形。用勾股定理可以算出， DA （也就是等腰三角形的高）的长度为 √<span style="text-decoration:overline">15</span> / √<span style="text-decoration:overline">19</span>， DB 的长度则为 4/√<span style="text-decoration:overline">19</span> 。接下来，倍长 BD 到 B”，分别以 B 和 B” 为圆心作单位圆，两圆交于 E 、 E’ 两点。显然， BB” 和 EE’ 互相垂直平分，用勾股定理可以求出，DE = DE’ = √<span style="text-decoration:overline">3</span> / √<span style="text-decoration:overline">19</span> 。最后，作出等边三角形 EE’G ，容易看出 G 恰好落在 BD 上，并且用勾股定理可以算出 DG = 3/√<span style="text-decoration:overline">19</span> 。也就是说， G 点正好是 BD 的四等分点！</p>
<p>      <img alt="image placeholder" >
<p>    用同样的方法，我们可以找出线段 AB 下方的另一个 G 点，不妨把它叫做 G’ 。作出以 G 、 B 、 G’ 为顶点的平行四边形 GBG’M ，由相似关系可以得出， M 点就是 BB’ 的四等分点，也就是 AB 的中点了。</p>
<p> </p>
<p>      <img alt="image placeholder" >
<p>    接下来，我们将推出，只要 AB 的长度小于 2/√<span style="text-decoration:overline">19</span> ，我们都能找出 AB 的中点来。像图中那样，以 AB 为底，连续作等边三角形，构成一个“五层宝塔”，最顶端的点记作点 K 。显然，三角形 ABK 是一个等腰三角形。用勾股定理不难算出， AK = BK = √<span style="text-decoration:overline">19</span> · AB ，也就是说这个三角形的腰长是底边的 √<span style="text-decoration:overline">19</span> 倍。接下来，以 K 为圆心作单位圆，再分别以 A 、 B 为圆心画弧，与圆 K 分别交于 P 、 Q 两点。分别以 P 、 Q 为圆心作单位圆，把两圆的另一个交点记作点 C 。注意到， △BCQ 是一个腰长为 1 的等腰三角形。另外，在圆 Q 中，圆心角 ∠BQC 等于两倍的圆周角 ∠BKC ，而 ∠BKC 又是 ∠BKA 的一半，因此 ∠BQC = ∠BKA 。于是， △BCQ 和 △ABK 是顶角相等的两个等腰三角形，它们是相似的。因而， △BCQ 的腰与底之比也是 √<span style="text-decoration:overline">19</span> : 1 ，因此 BC 的长度是 1/√<span style="text-decoration:overline">19</span> 。由对称性， AC 也等于 1/√<span style="text-decoration:overline">19</span> 。也就是说，我们做出了长度为 1/√<span style="text-decoration:overline">19</span> 的线段！接下来，找出 AC 的中点 D ，以及 BC 的中点 E ，作出平行四边形 CDME ， M 就是 AB 的中点了。</p>
<p>      <img alt="image placeholder" >
<p>    当然，这需要 AB 的长度小于 2/√<span style="text-decoration:overline">19</span> ，否则满足 AC = BC = 1/√<span style="text-decoration:overline">19</span> 的点 C 是不存在的。</p>
<p> </p>
<p>      <img alt="image placeholder" >
<p>    如果 AB 再长一些，怎么办呢？接下来的构造就真的具有冲击力了。当 AB 很长时，在 A 点附近取一个充分近的点 A<sub>1</sub> （具体地说， AA<sub>1</sub> &lt; 1/√<span style="text-decoration:overline">19</span> ）。然后，从 A 和 A<sub>1</sub> 出发，不断作等边三角形，形成一个等边三角形点阵。然后从 A 点出发，在这个点阵中行走，每次都朝着某个方向连续走两个线段长。这样两步两步地走，最终总能找到一个离 B 足够近的点 C ，使得 BC &lt; 2/√<span style="text-decoration:overline">19</span> 。 AC 的中点 D 已经在点阵上了，而 BC 的中点 E 也能作出。作出平行四边形 CDME ， M 点就是 AB 的中点了。</p>
			 ]]></content>
<pubDate>2011-06-16T22:12:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4439</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 几个令人惊叹的函数图像 ]]></title>
<link>http://www.matrix67.com/blog/archives/4447</link>
<content><![CDATA[ 
		<p>    国外<a href="http://www.xamuel.com/graphs-of-implicit-equations/%20">有人</a>发现一个鲜为人知的古董级函数作图软件—— <a href="http://www.peda.com/grafeq/">GrafEq</a> 。这个软件只有 2M 大小，它的功能就只有一个：作出形如 x<sup>2</sup> + y<sup>2</sup> = 1 的二元等式或者不等式的图像。令人惊叹的是，这个软件的图像绘制能力异常强大， Mathematica 等大型专业数学软件完全不是它的对手。<br>
    这个软件早就没再更新了。它的“最新版本”是 2.12 ，只支持 Windows 95 到 Windows XP 的系统，或者 PowerPC 7.12 到 MacOS 9.2 的系统，可见其年代久远。神奇的是，这个软件的官方网站依然健在，而且软件竟然也都能下载。如果你有幸还能装上这款软件，你将有机会重温一次 Windows 95 时代的软件安装画面。</p>
<p><span id="more-4447"></span><br>
    一些带有三角函数的方程，某些地方的图像变化非常剧烈，连 Mathematica 也无法准确地描绘出来：</p>
<p>      <img alt="image placeholder" >
<p>    然而， GrafEq 却能很好地描绘出来：</p>
<p>      <img alt="image placeholder" >
<p>    注意，方程的图像显然无法形成实心的方块，这只是因为图像太密集罢了。</p>
<p>    既然有机会见到各种方程图像的真容，我们当然要多尝试一些更复杂的方程。下面是另外几个例子：</p>
<p>      <img alt="image placeholder" >
<p> <br>
      <img alt="image placeholder" >
<p> <br>
      <img alt="image placeholder" >
<p> <br>
      <img alt="image placeholder" >
<p> <br>
    要比哪个图像最帅，还是要数 GrafEq 官方网站上提供的<a href="http://www.peda.com/grafeq/gallery/frontispiece.html">一个示例</a>：</p>
<p>      <img alt="image placeholder" >
<p> <br>
    2011-10-07 Update: 今天，我碰巧看到了这个软件的来头（事实上，本页 29 楼的网友 zhangyoufu 也提到了）。这个软件的算法是 Jeff Tupper 在 2001 年的一篇论文中提出的，感兴趣的读者可以在这里看到： <a href="http://www.dgp.toronto.edu/people/mooncake/papers/SIGGRAPH2001_Tupper.pdf">http://www.dgp.toronto.edu/people/mooncake/papers/SIGGRAPH2001_Tupper.pdf</a></p>
<p>    在这篇论文中， Jeff Tupper 创作了很多漂亮的函数图像，其中一个就是著名的 <a href="http://www.matrix67.com/blog/archives/301">Tupper 自我指涉公式</a> 。论文中还有几个精彩的图像，我也重新绘制了一遍，贴出来和大家一同分享。</p>
<p> <br>
      <img alt="image placeholder" >
<p> <br>
      <img alt="image placeholder" >
<p> <br>
      <img alt="image placeholder" >
			 ]]></content>
<pubDate>2011-06-21T23:52:21+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4447</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：Cantor集中的元素两两相加可以遍历[0,2] ]]></title>
<link>http://www.matrix67.com/blog/archives/4453</link>
<content><![CDATA[ 
		<p>    今天看到一个有趣的证明，来源在<a href="http://www.cut-the-knot.org/do_you_know/cantor5.shtml">这里</a>。</p>
<p>      <img alt="image placeholder" >
<p>    Cantor 集是一个简单而又神奇的分形图形。把 [0, 1] 三等分，挖去中间那一段（即挖去 (1/3, 2/3) ），然后把剩下两段也都分别进行三等分，并挖去各自中间的一段。这样无限地进行下去，最后得到的极限点集就是 Cantor 集了（上面那张图不是分割线，是 Cantor 集的一个示意图）。我们通常把 Cantor 集记作 C 。Cantor 集具有很多神奇的性质：它的 Lebesgue 测度为 0，但它却包含有不可数个点；它里面的每个点都不是孤点，但它却又是无处稠密的。你可以在<a href="http://www.matrix67.com/blog/archives/137">这里</a>看到一些具体的分析。</p>
<p>    Cantor 集还有很多其他的性质。若 A 、 B 是两个集合，定义 A + B = {a + b | a ∈ A 并且 b ∈ B} ，也就是 A 中的某个元素与 B 中的某个元素相加可能得到的所有结果。下面我们将证明，C + C = [0, 2]。</p>
<p><span id="more-4453"></span><br>
    下面是一个直观而又漂亮的证明。我们在平面直角坐标系上构造出点集 C × C，原问题就可以等价于，对于任意一个实数 a ∈ [0, 2] ，直线 x + y = a 都将经过这个平面点集中的至少一个点。</p>
<p>      <img alt="image placeholder" >
<p>    注意到， C × C 也可以用下面的这个方法来构造。先把 [0, 1] × [0, 1] 分成九个小正方形，挖去中间的五个小正方形，剩下四个小正方形。注意到直线 x + y = a 是一条 45 度倾斜的直线，它不管摆在哪儿都会穿过至少一个角上的小正方形。我们继续对每个剩下的小正方形做“分割 – 擦除”操作，让每个小正方形也只剩下四个角。刚才那条直线也就会穿过它所经过的那个小正方形的其中一个角。如此进行下去，我们将会得到单位正方形的其中一角的其中一角的其中一角的其中一角⋯⋯最后就会收敛到一个点。这个点显然既属于直线 x + y = a ，又属于平面点集 C × C 。因此，只要 0 ≤ a ≤ 2，在 C 中总有两个数，他们的和恰好是 a。</p>
			 ]]></content>
<pubDate>2011-06-24T12:13:34+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4453</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：连接多个数字串时怎样避免歧义？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4459</link>
<content><![CDATA[ 
		<p>    今天碰上一个非常有意思的问题。有一条通信线路，每次可以发送一个由数字 0 到 9 组成的任意长的数字串。怎样巧妙地利用这条通信线路，构造一种一次能够发送两个数字串的协议？注意到，直接将两个数字串相连是不行的，因为这将会产生歧义。如果对方收到的数字串是 1234 ，他没法知道你发送的是数字串 12 和 34 ，还是数字串 123 和 4 ，抑或是 1 和 234。</p>
<p>    能否把第一个串的位数编码进去，比如把 12 和 34 编码成 21234 ，这样不就知道第一个数字串到哪儿截止了吗？不行，因为你不知道这个位数信息本身到哪儿截止，假如编码结果是 123456789012345 ，你就不知道第一个数字串是 1 位还是 12 位了。换一个思路，能否用几个非常特殊的数字当作分隔符呢？也不行，因为你要发送的数字串里有可能偏偏也包含了这几位数。怎么办呢？</p>
<p><span id="more-4459"></span><br>
    一种非常容易想到的方法是，把两个数字串都转换为九进制，这样便把数字 9 腾了出来，它就能用作分隔符了。例如，要想发送数字串 12 和 34，只需要把 12 和 34 分别转成九进制，再在他们之间添加一个数字 9，得到数字串 13937，然后发送出去就可以了。即使要发送的数字串中有前导 0 ，问题也不大，我们可以在九进制数前面也加上相同数量的前导 0 。例如，把 012 和 0034 连在一起，也就成了 01390037 ，原始信息中的前导 0 也就很容易识别出来了。</p>
<p>    注意到，把一个十进制数转化成九进制数，数字位数是要增加的。一个值得考虑的问题是，为了实现数字串的连接，采用上述方法需要多花费多少位数字？一个 n 位数的九进制表达，其位数大致可以记作 log(9, 10<sup>n</sup>) ，也就是 log(9, 10) · n ，大约等于 1.048 n 。因此，把一个 n 位数变成九进制，将会增加 0.048n 位数，似乎是相当节省了。不过，从计算机算法的角度来看，系数再小，它也是 O(n) 的；当数据规模非常大的时候，这个算法的效率并不让人满意。上述算法还有优化的余地吗？</p>
<p>    一个优化方案是，既然首次出现的 9 一定是分隔符，后一个数字串就不必转成九进制了， 12 和 34 只需要编码成 13934 就行了。但是，渐近意义上看，所得数字串的附加长度仍然是 O(n) 。不过，如果和之前“写明第一个串的位数”的思路结合一下，我们就有了一个渐近意义上更优的方案：把第一个串的位数转化为九进制，再添加数字 9 标识出它的右边界即可。如果想要发送数字串 123456789012345 和 12345 ，就可以先数出前一个数有 15 位，再把位数本身转换成九进制 16 ，原始信息便可编码为 16912345678901234512345 。这样一来，附加长度就比原来小得多了，它只有第一个数的位数的 0.048 倍，也就是 0.048 log(n) 了。</p>
<p>    同样是 log(n) 级别的附加长度，我们还有一种更加简单巧妙的方案。将第一个串的位数用“口吃”的方式表达出来，每个数字都重复说一遍，然后加上一对不相同的数字（比如“01”）作为结束标记。例如， 123456789012345 和 12345 就将被编码为 11550112345678901234512345 ，表示第一个数字有 15 位。这样一来，附加的长度就是 2 log(n) + 2 ，同样也是 log(n) 的级别，不过方法简便多了。而且更棒的是，这种方法能够直接扩展到一个更加一般更加困难——两个 01 串的连接！</p>
<p>    大家还能想到什么其他有趣的方案？</p>
<p> <br>
    Update: 在写上面的文字时，我显然还想得不够多，现在看来让人很不满意。看了大家的回复，我深受启发，决定继续往下说一说。上述方法说穿了就是，用 11 来表示 1 ，用 22 来表示 2 ，一直到用 99 来表示 9 ，然后用 01 来表示分隔。这背后的核心思想其实就是：用两位数字来表示一位数字，从而扩展字符集。因此，我们还可以构造出很多类似的方案来。比方说，用 01 表示 1 ，用 02 表示 2，等等，一直到用 09 表示 9 ，最后用 10 表示分隔符。因此， 123456789012345 和 12345 就可以编码为 01051012345678901234512345 。读取编码后的数字串时，如果读到的是 0?0?0?… 的模式，那么我们都是在读取第一个数字串的位数；什么时候模式被打破了，出现了一个 10 ，第一个数字串的位数也就读完了。</p>
<p>    注意到，扩展字符集的根本动机，就是我们希望能够在字符集中新增加一个分隔符。不过，上面的方案把字符集扩展得太大了，绝大多数新字符其实都没用，实在有些浪费。有办法能够对 {0, 1, 2, …, 9, 分隔符} 这 11 个字符重新编码，使得编码效率又高，连接起来又不会产生歧义吗？不少网友提到了 Huffman 编码，就是专门解决这个问题的。网友 hhb 提到，扩展字符集还有一个更简单的方法：直接把分隔符用 A 来表示，然后把带有分隔符的数字串看作 11 进制数，再转成 10 进制数即可（有前导 0 的话要做保留）。</p>
<p>    转义符的功能不也是这样吗？由于字符串无法表示出换行的概念，于是用 n 表示换行；为了不造成歧义，又规定 \ 表示真正的  。受转义符的启发，我们就有了更好的方案，比方说用 01 表示分隔符，用 00 表示真正的 0 。解码时，每读到一个 0 ，都看看它后面跟的是什么，如果还是一个 0，表明这是一个真正的 0 ；如果是 1 ，则表示分隔符。</p>
<p>    如果看到了新的想法，我再接着补充。</p>
			 ]]></content>
<pubDate>2011-06-27T02:02:42+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4459</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 今天才知道，空壳星球的内部是没有重力的 ]]></title>
<link>http://www.matrix67.com/blog/archives/4470</link>
<content><![CDATA[ 
		<p>    曾经想过要写一篇科幻小说，讲一种生活在空壳星球内表面的文明，如何发现自己的星球是圆的，如何成功地环游世界一周，又如何发现自己其实是在星球的内表面。今天我长出了一口气，幸好当初没写这样的文章，不然就闹笑话了。今天我才知道，空壳星球内部的人是不能居住在星球的内表面的，因为空壳星球内的任意一点都没有重力。</p>
<p>    这其实并不难理解。虽然脚下的土地离你更近，产生的重力作用更显著，但可惜这部分土地并不多。星球的更多部分将会位于你的头上，但可惜它们又离你太远了，影响也不会太大。近的部分太小，大的部分又太远，这两者很可能是一种平衡的状态。</p>
<p><span id="more-4470"></span><br>
      <img alt="image placeholder" >
<p>    而事实上也正是如此。不妨让我们先来考虑当星球壳充分薄的情况。考虑星球内部的一点 M ，以及这个星球上充分小的一块皮 A 。不妨假设这块皮到 M 点的距离为 d<sub>1</sub> 。现在，将 A 上的每个点都与 M 相连并延长出去，由此确定出对面的一块内表皮 B 。假设它到 M 点的距离为 d<sub>2</sub> 。注意到，一块表皮对 M 的引力，与表皮的面积成正比，与距离的平方成反比；而 A 、 B 的面积之比正好是 d<sub>1</sub> 和 d<sub>2</sub> 的平方比，因此 A 、 B 对 M 的作用力就正好抵消了。同理，这个薄壳星球的任意位置对 M 的作用力都恰好被对面的相应部分抵消，因此 M 点没有重力。而一个有一定厚度的空壳星球可以看作是由无穷个充分薄的空壳叠加而来，因而它内部也是没有重力的。</p>
<p>    其实，刘慈欣在科幻小说中早就注意到这一点了（我现在才意识到）。在科幻小说《山》中，刘慈欣真的构想了一种生存在星球内部的外星文明，从外星人的角度来看，他们的世界“就是这固体宇宙中的一个空泡”，于是这个外星文明就把它称为“泡世界”。小说中写到：“我们那时不知道万有引力这回事，泡世界中没有重力，我们生活在失重状态中。真正意识到引力的存在是几万年以后的事了。”</p>
<p> <br>
    逻辑推导是一回事，事实上又是怎样呢？有趣的是，这个结论可以用实验来进行验证。我们虽然无法制造一个空壳星球，但我们另有妙招。两个带电粒子的引力公式 F = K · q<sub>1 · </sub>q<sub>2</sub> / r<sup>2</sup>，其形式与万有引力惊人地一致。让一个铜球壳带上一定量的电荷，电荷将会均匀分布于外层。此时，你会发现铜球内没有电场，这样便验证了上面的结论。</p>
<p> <br>
    这个结论有一个非常有趣的应用，它可以帮助我们计算地下的重力。比方说，假设你在地下 1 千米的某个地方，那么我们就把整个地球分成两部分，一个 1 千米厚的外壳，和它内部的实心球。刚才的结论告诉我们，前一部分对你没有作用力，因此你所受的重力全部来源于剩下的那部分实心球。如果地球的半径是 R 千米，那么地下 1 千米处的重力就相当于是一个半径为 R – 1 千米的地球表面上的重力。</p>
<p>    注意到，如果地球半径减小到了原来的 1/n，那么质心到表面的距离也就减小到了原来的 1/n，同时星球质量也将会减小到原来的 (1/n)<sup>3</sup>。由此可知，物体所受的重力就变成了原来的 (1/n)<sup>3</sup> / (1/n)<sup>2</sup> = 1/n 。也就是说，如果你朝着地心挖过去，你所受到的重力是线性地变化的。在地球表面，重力加速度还是 9.8 m/s<sup>2</sup> ，挖到一半的地方时就只剩 4.9 m/s<sup>2</sup> 了，到地心就没有了重力加速度。当然，如果穿过地心继续往对面挖，重力就开始往反方向线性增加了。</p>
<p>    有趣的事情发生了：如果修建一个贯穿地心的隧道，从中国一直延伸到阿根廷，由于重力大小与物体位置始终是一个线性关系，那么在这个隧道中所做的“自由落体运动”，实际上将会是一个简谐振动！取地球半径 R = 6 371 000 米，那么简谐振动的一个周期就是 2π · √<span style="text-decoration:overline">6 371 000 / 9.8</span> ≈ 5066 秒，因而半个周期（也就是从中国单程前往阿根廷的时间）就大约为 2533 秒，也就是 42.2 分钟。</p>
<p>    写到这里，似乎突然想到了什么，于是立即去翻刘慈欣的《地球大炮》，果然看到这么一段：“计算结果很快出来了，以地球理想的平均密度，从中国跳进地球隧道，穿过直径一万两千多公里的地球，坠落到阿根廷，需四十二分钟十二秒。”这个数据竟然不是随便编的。</p>
<p>    大刘太牛 B 了。</p>
<p> <br>
    扩展阅读： <a href="http://en.wikipedia.org/wiki/Gravity_train">http://en.wikipedia.org/wiki/Gravity_train</a><br>
    大家可以看到， gravity train 的想法最早可以追溯到 17 世纪，并且更有意思的是，它还可以扩展到地球表面任意两点的直线旅行。如果这个隧道不是穿过地心的，而是一条“弦”的话，虽然速度更慢，但同时隧道本身也更短。一个有趣的推论是：在地球表面任意两点的直线隧道上自由运动，周期是一个定值——单程旅行总是 42.2 分钟。</p>
			 ]]></content>
<pubDate>2011-07-02T02:14:59+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4470</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 盯着结论看，直到它变得显然成立为止 ]]></title>
<link>http://www.matrix67.com/blog/archives/4480</link>
<content><![CDATA[ 
		<p>    很多看上去很显然的结论，其实是需要严格证明的，并且有时候证明相当困难。比方说算术基本定理，每一个数分解质因数的方法都是唯一的。这看上去几乎是显然的，但证明过程需要很多深刻的数论知识。更极端的例子则是 Jordan 曲线定理，即平面上每一条不与自身相交的封闭曲线都把平面分成了里外两部分。这几乎就是一句废话，但要想严格证明起来相当不容易， Camille Jordan 本人的证明最后发现竟然也是错误的。<br>
    最近 <a href="http://mathoverflow.net/questions/28788/nontrivial-theorems-with-trivial-proofs">MathOverflow</a> 上有人提了一个非常有趣的问题：有那么多结论很显然但证明很困难的定理，那有没有什么结论很不可思议但证明过程却不言而喻的定理呢？</p>
<p>    在众人的回答中，呼声最高的就是 Desargues 定理：若三角形 ABC 和 A’B’C’ 中， AA’ 、 BB’ 、 CC’ 所在直线交于一点，则两个三角形中每一组对应边的交点（即 BC 和 B’C’ 的交点 D 、 AC 和 A’C’ 的交点 E 、 AB 和 A’B’ 的交点 F ）是共线的。</p>
<p>      <img alt="image placeholder" >
<p>    这个定理看上去太神奇了，大家一定会以为证明很难吧。但事实上，这个定理根本不需要证明，它显然是成立的。现在，把 P-ABC 看成一个三棱锥，而 A’B’C’ 则是一个不平行于底面的截面。由于 AB 、 A’B’ 在同一平面内，因此这两条线会相交；这个交点既在平面 ABC 上，也在平面 A’B’C’ 上，因而也就在两平面的交线上。同理，另外两个交点也都在平面 ABC 和 A’B’C’ 的交线上，因此三个交点共线。当然，画在纸上的也好，照相机照出来的也好，人眼看到的也好，其实都是一个二维图形罢了。因此，命题在平面上也是成立的（这背后的逻辑是，在立体图形的平面投影中，直线仍然是直的，共线的仍然共线，共点的仍然共点；借助射影几何的思想，我们能给出一个更严格的证明）。</p>
<p>    这个证明神就神在，当你悟到之后，整个证明过程不但不需要一个字，而且连图形说明都可以不用，只需要盯着原图看，结论自己就跳出来了。看来，我们又多了一种证明问题的思路：盯着问题看，直到它突然一下变得显然成立了为止。</p>
<p><span id="more-4480"></span><br>
    这让我立即想到之前讲过的不少把平面几何的辅助线作到空间去的趣题，我至少回想起了四篇日志（<a href="http://www.matrix67.com/blog/archives/58">58</a>，<a href="http://www.matrix67.com/blog/archives/1947">1947</a>，<a href="http://www.matrix67.com/blog/archives/3918">3918</a>，<a href="http://www.matrix67.com/blog/archives/3965">3965</a>）。其中好几个问题也有类似的精神，尤其是第一篇日志里讲到的第一个问题。</p>
<p>      <img alt="image placeholder" >
<p>    问题很帅：平面上三个圆两两相交。试证明三条公共弦共点。</p>
<p>      <img alt="image placeholder" >
<p>    利用根轴的相关性质，我们有一个非常漂亮的证明。不过，要想看出定理的正确性，远不用那么复杂。用一种新的方式解读原图后，定理几乎是显然成立的。想象以这三个圆为“赤道面”的三个球体。我们把这三个球的球心（也就是原问题中的三个圆心）所确定的平面（也就是原问题的图形所在的平面）记作 α 。注意到，每两个球面将会相交于一个圆圈，他们在 α 上的投影就是那三条公共弦。而三个球面将会交于两个点（这两个点一上一下，关于 α 对称），并且这两个点都同时属于空间中的三个圆圈。从投影的角度来看，这就是说，在平面 α 上存在一个点，它同时属于那三条公共弦。</p>
<p> <br>
      <img alt="image placeholder" >
<p>    说到直观的证明，不得不提到下面这个经典例子。 1989 年的 American Mathematical Monthly 上有一个貌似非常困难的数学问题：考虑由一个个小三角形组成的正六边形棋盘，现在请你用右边的三种（仅朝向不同的）菱形把整个棋盘全部摆满（图中只摆了其中一部分），证明当你摆满整个棋盘后，你所使用的每种菱形数量一定相同。</p>
<p>      <img alt="image placeholder" >
<p>    文章末尾提供了一个非常帅的“证明”。把每种菱形涂上一种颜色，整个图形瞬间有了立体感，看上去就成了一个个立方体在墙角堆叠起来的样子。三种菱形分别是从左侧、右侧、上方观察整个立体图形能够看到的面，它们的数目显然应该相等。这个证明虽然并不严格，但却深受数学家喜爱，甚至还收录进了《Proofs Without Words》一书中。</p>
<p> <br>
    《Proofs Without Words》一书的第 109 页则给出了另外一个例子：六边形数 h<sub>n</sub> 可以写成 n<sup>3</sup> – (n – 1)<sup>3</sup> 。其实这也是显然的，结论根本不用证明。你只需要盯着排列成六边形的圆点阵，不断看不断看，一直看一直看，直到看出它显然就是 n<sup>3</sup> – (n – 1)<sup>3</sup> ，结论就证到了。</p>
<p>      <img alt="image placeholder" >
<p>    由此还能立刻可知， h<sub>1</sub> + h<sub>2</sub> + … + h<sub>n</sub> = n<sup>3</sup> ，从图形的角度看上去，这也是显然的。</p>
<p>    大家还有什么好的例子吗？</p>
			 ]]></content>
<pubDate>2011-07-04T13:03:31+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4480</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：不用相似怎么办？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4485</link>
<content><![CDATA[ 
		<p>    我老早就写过一个<a href="http://www.matrix67.com/blog/archives/2434">经典的小学几何题</a>。如果你还没看过这个问题，你一定要去看看。一个小学奥数老师曾经告诉我，当年带领学生参加这次竞赛时，领队老师们都没有想到这个问题的“小学生解法”，以至于开始质疑这道题是否超纲了。看到答案后，老师们大为折服——这个问题确实有一个无需任何几何知识的妙解。</p>
<p>      <img alt="image placeholder" >
<p>    今天，同样的事情发生了。今天临时去代一节小学奥数课，见到这么一道题： ABCD 是一个正方形，边长为 4 ， DEFG 是一个矩形，其中 DG = 5 ，求 DE 的长度。还是那段话：题目本身并不难，大家一看就知道答案；问题的关键在于，这个问题是一道小学竞赛题，这意味着这个题目一定有一个异常巧妙的傻瓜解。这个解法不用相似形，不用列方程，事实上几乎什么都不用，只需要用到最基本最显然的正方形长方形的性质。你能想到这个解法吗？</p>
<p><span id="more-4485"></span></p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
      <img alt="image placeholder" >
<p>    我叫了几个初中数学老师来，一起围着它研究了半天，结果想破脑袋也还是满脑子的相似，于是只好求助小学组的老师，果然取得真经，赞不绝口，大呼妙哉。连接 AG ，注意到三角形 ADG 的面积既是正方形 ABCD 面积的一半，又是矩形 DEFG 面积的一半，可见正方形和矩形的面积是相等的。既然正方形的面积是 16，矩形的一边长是 5，另一边就是 3.2 了。<br>
    你想到了吗？</p>
			 ]]></content>
<pubDate>2011-07-09T13:42:00+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4485</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 千万不要迷信规律：大反例合集 ]]></title>
<link>http://www.matrix67.com/blog/archives/4491</link>
<content><![CDATA[ 
		<p>    数学猜想并不总是对的，错误的数学猜想不占少数。关键在于，有时反例太大，找出反例实在是太困难了。这篇日志收集了很多“大反例”的例子，里面提到的规律看上去非常诱人，要试到相当大的数时才会出现第一个反例。</p>
<p><strong>千万不要迷信规律</strong></p>
<p>    圆上有 n 个点，两两之间连线后，最多可以把整个圆分成多少块？</p>
<p>      <img alt="image placeholder" >
<p>    上图显示的就是 n 分别为 2 、 3 、 4 的情况。可以看到，圆分别被划分成了 2 块、 4 块、 8 块。规律似乎非常明显：圆周上每多一个点，划分出来的区域数就会翻一倍。</p>
<p><span id="more-4491"></span><br>
    事实上真的是这样吗？让我们看看当 n = 5 时的情况：</p>
<p>      <img alt="image placeholder" >
<p>    果然不出所料，整个圆被分成了 16 块，区域数依旧满足 2<sup>n-1</sup> 的规律。此时，大家都会觉得证据已经充分，不必继续往下验证了吧。偏偏就在 n = 6 时，意外出现了：</p>
<p>      <img alt="image placeholder" >
<p>    此时区域数只有 31 个。</p>
<p> <br>
 <br>
<strong>最有名的素数生成公式</strong></p>
<p>    1772 年，Euler 曾经发现，当 n 是正整数时， n<sup>2</sup> + n + 41 似乎总是素数。事实上，n 从 1 一直取到 39，算出来的结果分别是：</p>
<blockquote><p>43, 47, 53, 61, 71, 83, 97, 113, 131, 151, 173, 197, 223, 251, 281,<br>
313, 347, 383, 421, 461, 503, 547, 593, 641, 691, 743, 797, 853,<br>
911, 971, 1033, 1097, 1163, 1231, 1301, 1373, 1447, 1523, 1601</p></blockquote>
<p>    这些数全都是素数。第一次例外发生在 n = 40 的时候，此时 40<sup>2</sup> + 40 + 41 = 40<sup>2</sup> + 40 + 40 + 1 = (40 + 1)(40 + 1) = 41 × 41。</p>
<p> <br>
 <br>
<strong>x<sup>n</sup> – 1 的因式分解</strong></p>
<p>    x<sup>2</sup> – 1 分解因式后等于 (x + 1)(x – 1) 。 x<sup>20</sup> – 1 分解因式后等于</p>
<blockquote><p>(x – 1) (x + 1) (x<sup>2</sup> + 1) (x<sup>4</sup> – x<sup>3</sup> + x<sup>2</sup> – x + 1) (x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x + 1) (x<sup>8</sup> – x<sup>6</sup> + x<sup>4</sup> – x<sup>2</sup> + 1)</p></blockquote>
<p>    对于所有的正整数 n ， x<sup>n</sup> – 1 因式分解后各项系数都只有可能是 1 或者 -1 吗？据说有人曾经算到了 x<sup>100</sup> – 1 ，均没有发现反例，终于放心大胆地做出了这个猜想。悲剧的是，这个猜想是错误的，第一个反例出现在 n = 105 的情况， x<sup>105</sup> – 1 分解出来等于</p>
<blockquote><p>(x – 1) (x<sup>2</sup> + x + 1) (x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x + 1) (x<sup>6</sup> + x<sup>5</sup> + x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x + 1)<br>
(x<sup>8</sup> – x<sup>7</sup> + x<sup>5</sup> – x<sup>4</sup> + x<sup>3</sup> – x + 1) (x<sup>12</sup> – x<sup>11</sup> + x<sup>9</sup> – x<sup>8</sup> + x<sup>6</sup> – x<sup>4</sup> + x<sup>3</sup> – x + 1)<br>
(x<sup>24</sup> – x<sup>23</sup> + x<sup>19</sup> – x<sup>18</sup> + x<sup>17</sup> – x<sup>16</sup> + x<sup>14</sup> – x<sup>13</sup> + x<sup>12</sup> – x<sup>11</sup> + x<sup>10</sup> – x<sup>8</sup> + x<sup>7</sup> – x<sup>6</sup> + x<sup>5</sup> – x + 1)<br>
(x<sup>48</sup> + x<sup>47</sup> + x<sup>46</sup> – x<sup>43</sup> – x<sup>42</sup> – <span style="color:red">2</span> x<sup>41</sup> – x<sup>40</sup> – x<sup>39</sup> + x<sup>36</sup> + x<sup>35</sup> + x<sup>34</sup> + x<sup>33</sup> + x<sup>32</sup> + x<sup>31</sup> – x<sup>28</sup><br>
 – x<sup>26</sup> – x<sup>24</sup> – x<sup>22</sup> – x<sup>20</sup> + x<sup>17</sup> + x<sup>16</sup> + x<sup>15</sup> + x<sup>14</sup> + x<sup>13</sup> + x<sup>12</sup> – x<sup>9</sup> – x<sup>8</sup> – <span style="color:red">2</span> x<sup>7</sup> – x<sup>6</sup> – x<sup>5</sup> + x<sup>2</sup> + x + 1)</p></blockquote>
<p> <br>
 <br>
<strong>以 2 为底的伪素数</strong></p>
<p>    下面是当 n 较小的时候， n 与 2<sup>n</sup> – 2 的值。</p>
<p>      <img alt="image placeholder" >
<p>    似乎有这样的规律： n 能整除 2<sup>n</sup> – 2 ，当且仅当 n 是一个素数。如果真是这样的话，我们无疑有了一种超级高效的素数判定算法（ 2<sup>n</sup> 可以用二分法速算，期间可以不断模 n ）。国外数学界一直传有“中国人 2000 多年前就发现了这一规律”的说法，后来发现其实是对《九章算术》一书的错误翻译造成的。再后来人们发现，这个规律竟然是错误的。第一个反例是 n = 341，此时 341 能够整除 2<sup>341</sup> – 2 ，但 341 = 11 × 31 。</p>
<p>    事实上，根据 Fermat 小定理，如果 p 是素数，那么 p 一定能整除 2<sup>n</sup> – 2。不过，它的逆定理却是不成立的，上面提到的 341 便是一例。我们把这种数叫做以 2 为底的伪素数。由于这种素数判定法的反例出人意料的少，我们完全可以用它来做一个概率型的素数判定算法。事实上，著名的 <a href="http://www.matrix67.com/blog/archives/234">Miller-Rabin 素性测试算法</a>就是用的这个原理。</p>
<p> <br>
 <br>
<strong>Perrin 伪素数</strong></p>
<p>    定义 f(n) = f(n – 2) + f(n – 3) ，其中 f(1) = 0 ， f(2) = 2 ， f(3) = 3 。这个数列叫做 Perrin 数列。</p>
<p>      <img alt="image placeholder" >
<p>    似乎有这么一个规律： n 能整除 Perrin 数列的第 n 项 f(n) ，当且仅当 n 是一个素数。如果这个规律成立的话，我们也将获得一个效率非常高的素数检验方法。根据 <a href="http://mathworld.wolfram.com/PerrinPseudoprime.html">MathWorld</a> 的描述，1899 年 Perrin 本人曾经做过试验，随后 Malo 在 1900 年， Escot 在 1901 年，以及 Jarden 在 1966 年都做过搜索，均未发现任何反例。直到 1982 年， Adams 和 Shanks 才发现第一个反例 n = 271 441 ，它等于 521 × 521 ，却也能整除 f(271 441) 。下一个反例则发生在 n = 904 631 的时候，再下一个反例则是 n = 16 532 714 。这种反例被称为 Perrin 伪素数。</p>
<p> <br>
 <br>
<strong>最经典的大反例</strong></p>
<p>    说到大反例，这是我最喜欢举的例子。下面是大于 1 的正整数分解质因数后的结果：</p>
<blockquote><p>2 = 2<br>
3 = 3<br>
4 = 2 × 2<br>
5 = 5<br>
6 = 2 × 3<br>
7 = 7<br>
8 = 2 × 2 × 2<br>
9 = 3 × 3<br>
10 = 2 × 5<br>
…</p></blockquote>
<p>    其中，4、6、9、10 包含偶数个质因子，其余的数都包含奇数个质因子。你会发现，在上面的列表中一行一行地看下来，不管看到什么位置，包含奇数个质因子的数都要多一些。1919 年，George Pólya 猜想，质因子个数为奇数的情况不会少于 50% 。也就是说，对于任意一个大于 1 的自然数 n ，从 2 到 n 的数中有奇数个质因子的数不少于有偶数个质因子的数。这便是著名的 Pólya 猜想。</p>
<p>    Pólya 猜想看上去非常合理——每个有偶数个质因子的数，必然都已经提前经历过了“有奇数个质因子”这一步。不过，这个猜想却一直未能得到一个严格的数学证明。到了 1958 年，英国数学家 C. B. Haselgrove 发现， Pólya 猜想竟然是错误的。他证明了 Pólya 猜想存在反例，从而推翻了这个猜想。不过，Haselgrove 仅仅是证明了反例的存在性，并没有算出这个反例的具体值。Haselgrove 估计，这个反例至少也是一个 361 位数。</p>
<p>    1960 年，R. Sherman Lehman 给出了一个确凿的反例：n = 906 180 359。而 Pólya 猜想的最小反例则是到了 1980 年才发现的：n = 906 150 257。</p>
<p> <br>
 <br>
<strong>Fermat 大定理还能推广吗？</strong></p>
<p>    Fermat 大定理说，当 n &gt; 2 时，方程 x<sup>n</sup> + y<sup>n</sup> = z<sup>n</sup> 没有正整数解。 Euler 曾经猜想，当 n &gt; k 时，方程 x<sub>1</sub><sup>n</sup> + x<sub>2</sub><sup>n</sup> + … + x<sub>k</sub><sup>n</sup> = y<sup>n</sup> 都没有正整数解。 1986 年，Noam Elkies 给出了方程 x<sup>4</sup> + y<sup>4</sup> + z<sup>4</sup> = w<sup>4</sup> 的一个正整数解，从而推翻了这个猜想。这个反例是：2 682 440<sup>4</sup> + 15 365 639<sup>4</sup> + 18 796 760<sup>4</sup> = 20 615 673<sup>4</sup> 。</p>
<p> <br>
 <br>
<strong>XX 型平方数</strong></p>
<p>    11, 22, 33, 44, 55, 66, 77, 88, 99, 1010, 1111, 1212, … 都不是完全平方数。有没有什么数，把它连写两次后，正好是一个完全平方数呢？有。第一个这样的数是 13 223 140 496 ，把它连写两次将得到 1 322 314 049 613 223 140 496 ，是 36 363 636 364 的平方。第二个这样的数则是 20 661 157 025 ，它对应了 45 454 545 455 的平方。更多信息可见 <a href="http://oeis.org/A102567">http://oeis.org/A102567</a> 。</p>
<p> <br>
 <br>
<strong>总是相等吗？</strong></p>
<p>    下面是 n 为正整数时， 2 / (2<sup>1/n</sup> – 1) 取上整的结果与 2n / ln(2) 取下整的结果：</p>
<p>      <img alt="image placeholder" >
<p>    这两者的结果总是相等吗？不是的。第一个反例是 n = 777 451 915 729 368，前者算出来的结果是 2 243 252 046 704 767 ，但后者是 2 243 252 046 704 766 。下一个反例则出现在 n = 140 894 092 055 857 794 的时候。更多信息可见 <a href="http://oeis.org/A129935">http://oeis.org/A129935</a> 。</p>
<p> <br>
 <br>
<strong>至今仍未找到的反例</strong></p>
<p>    有没有什么猜想，明明已经被推翻了，所有人都知道存在反例，但因为反例实在是太大了，直到现在仍然没有找到呢？有。下面这张表展示了 n 取不同值时 pi(n) 和 li(n) 的值，其中 pi(n) 表示不超过 n 的素数的个数，li(n) 则是对数积分 ∫<sub>0</sub><sup>n</sup> dx/ln(x) 。</p>
<p>      <img alt="image placeholder" >
<p>    pi(n) 是否永远小于 li(n) 呢？1914 年，Littlewood 证明了存在一个大数 n 使得 pi(n) ≥ li(n) ，不过却并没有给出一个具体的 n 值来。1955 年，Skewes 给出了这样的 n 值的一个上界：在 10^(10^(10^963)) 以内，必有一个满足 pi(n) ≥ li(n) 的 n 。</p>
<p>    虽然数学家们正在不断地改进上界（目前的上界大约是 e<sup>727.9513</sup> ），但仍然无法找出一个具体的 n 来。原因很简单——这个反例实在是太大了。</p>
<p> <br>
 <br>
几个主要来源：<br>
<a href="http://redd.it/iikk4">http://redd.it/iikk4</a><br>
<a href="http://www.guokr.com/article/9688/">http://www.guokr.com/article/9688/</a><br>
<a href="http://mathoverflow.net/questions/15444">http://mathoverflow.net/questions/15444</a></p>
<p>如果你对此感兴趣，不要错过数学史上的一篇经典论文：<a href="http://www.math.sjsu.edu/~hsu/courses/126/Law-of-Small-Numbers.pdf">The Strong Law of Small Numbers</a></p>
<p>这篇日志今后将不断更新</p>
<p> <br>
 <br>
2011-10-13 Update:<br>
<strong>Borwein 积分</strong></p>
<p>    2001 年， David Borwein 和 Jonathan M. Borwein 在一篇论文中指出：</p>
<p>      <img alt="image placeholder" >
<p>    事实上，这个规律一直到</p>
<p>      <img alt="image placeholder" >
<p>    都是成立的。但</p>
<p>      <img alt="image placeholder" >
<p>    却打破了规律。其原因是， 1/3 + 1/5 + … + 1/15 超过了 1 。</p>
			 ]]></content>
<pubDate>2011-07-13T13:39:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4491</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ IMO2011趣题：总存在一条将会遍历所有点的直线 ]]></title>
<link>http://www.matrix67.com/blog/archives/4511</link>
<content><![CDATA[ 
		<p>    下面这个精彩的问题来自于刚刚结束的 <a href="http://www.imo-official.org/problems.aspx">IMO 2011</a> 中的第 2 题：</p>
<blockquote><p>    设 S 是平面上包含至少两个点的一个有限点集，其中没有三点在同一条直线上。所谓一个“风车”是指这样一个过程：从经过 S 中单独一点 P 的一条直线 l 开始，以 P 为旋转中心顺时针旋转，直至首次遇到 S 中的另一点，记为点 Q 。接着这条直线以 Q 为新的旋转中心顺时针旋转，直到再次遇到 S 中的某一点，这样的过程无限持续下去。<br>
    证明：可以适当选取 S 中的一点 P ，以及过 P 的一条直线 l ，使得由此产生的“风车”将 S 中的每一点都无限多次用作旋转中心。</p></blockquote>
<p><span id="more-4511"></span><br>
    注意，由于两点确定的直线只有有限多条，因此直线无限旋转下去，必然会出现和以前某个时刻相同的状态，于是产生循环。另外，由于直线旋转的过程是可逆的，我们不必担心最终产生的是一个 ρ 字形的循环。因此，我们实际上只需要证明，存在这样一条初始直线，它可以碰到所有的点。</p>
<p>      <img alt="image placeholder" >
<p>    我用 Mathematica 写了一个程序，做了一些直观的动画。如图所示的由 6 个点构成的点集，适当地选择初始直线就能遍历所有的点，但错误的选择将会导致有一些点永远也碰不到。</p>
<p>    IMO 2011 赛后统计资料显示，这道漂亮的问题竟然是六道题中第二难的题（第一难的题是最后一道）。 <a href="http://polymathprojects.org/">polymath blog</a> 组织了 <a href="http://michaelnielsen.org/polymath1/index.php?title=Imo_2011">mini-polymath3</a> 活动，邀请众人一同讨论这道题的解法。活动一开始，便引来各路数学高人献计献策，提出了很多有趣的思路和猜想；第 74 分钟，终于有人给出了正确的解法。果然不出所料，神题就该有神解，这道题有一个异常简单巧妙的证明方法。</p>
<p>      <img alt="image placeholder" >
<p>    找一条直线，这条直线两侧的点数一样多（最多相差一个）。下面我们证明，这条直线就满足要求。容易看出，在直线的旋转过程中，直线两侧的点数之差始终不变。因此，这条直线转了 180 度后，直线一定回到了初始的位置（或者它旁边一个点的位置）。但此时，原来在直线左侧的点现在全部跑到了直线右侧，原来在直线右侧的点现在全部跑到了直线左侧。这些点当然是不能瞬移到直线另一侧的，要想跑到直线的另一侧，必须要先穿过直线才行。由此可见，所有点都被直线碰到过了。</p>
			 ]]></content>
<pubDate>2011-07-29T09:07:58+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4511</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 数学冷知识：不断取英文表达的字符数，最后总会得到数字4 ]]></title>
<link>http://www.matrix67.com/blog/archives/4520</link>
<content><![CDATA[ 
		<p>    这道题的答案有几个字母？答案：four。</p>
<p>    有趣的是，这是唯一的答案。如果令函数 f(n) 表示非负整数 n 的英文表达中有多少个字母（不算空格和短横线）， n=4 是该函数的唯一不动点。</p>
<p>       n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, …<br>
      f(n)  4, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, …</p>
<p>    事实上， <a href="http://twitter.com/#!/IanMathmogician">@IanMathmogician</a> 发现了一个更有趣的“数学冷知识”：任取一个 0 到 100 之间的整数 n ，算出这个数的英文表达中的字符个数，再算出所得结果的英文表达的字符数，并这样一直迭代下去，最后总会得到数字 4 。我用 Mathematica 做了一张图片，可以让大家直观地看到，这真的可以说是条条大路通向数字 4 啊。</p>
<p><span id="more-4520"></span><br>
      <img alt="image placeholder" >
<p>    那么，对于更大的数，如此迭代下去也都会变成 4 吗？恐怕没有人会置疑这一点吧。事实上，由于数字的英文描述所需字符数是对数级别增长的，因此从理论上说，对于更大的数，英文表达所用的字符数都应该比这个数字本身更小。于是，反复取字符数，所得结果必会越来越小；到了充分小的时候，就会按照上图的指示掉进数字黑洞 4 里。</p>
<p>    我另外画了一张从 0 到 1000 的所有数的转移示意图，非常壮观，贴在下面供大家观赏。</p>
<p>      <img alt="image placeholder" >
<p>查看更多：<a href="http://www.reddit.com/r/math/comments/jarub/interesting_mathematical_curiosity/">http://www.reddit.com/r/math/comments/jarub/interesting_mathematical_curiosity/</a></p>
			 ]]></content>
<pubDate>2011-08-08T21:50:06+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4520</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：能否在等边三角形点阵中画一个正方形？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4525</link>
<content><![CDATA[ 
		<p>    这是一个非常有趣的问题：能否在一个无限大的等边三角形点阵中选取四个点，使得这四个点恰好构成一个正方形？这个问题有一个非常简单巧妙的解法，你能想到吗？</p>
<p>      <img alt="image placeholder" >
<p><span id="more-4525"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
      <img alt="image placeholder" >
<p>    答案：不可能。为了证明这一点，首先注意到，如果选定三角形点阵中任意两个不同的点，则以这两个点为顶点作等边三角形，所得的第三个顶点也一定在点阵中。这是因为，以任意一点为中心，将整个平面旋转 60 度，新的点阵与原来的点阵仍然是重合的。等边三角形的第三个顶点，其实可以看作是已知两点中的其中一点绕另一点旋转 60 度所得的，自然也就还在点阵中了。</p>
<p> <br>
      <img alt="image placeholder" >
<p>    下面，假设点阵中存在正方形，则我们一定能找到一个最小的正方形。以正方形的每条边为边，向内作等边三角形，所得的第三个顶点也仍然在点阵上。然而，这四个新的顶点将会构成一个更小的正方形，于是产生矛盾。所以，我们永远无法在等边三角形点阵中作出一个正方形来。</p>
<p> <br>
题目来源：<a href="http://www.cut-the-knot.org/Curriculum/Geometry/DavidRadcliffe.shtml">http://www.cut-the-knot.org/Curriculum/Geometry/DavidRadcliffe.shtml</a><br>
大家有什么其他的证明方法吗？</p>
			 ]]></content>
<pubDate>2011-08-08T21:58:58+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4525</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 生成函数的妙用：平均抛掷多少次硬币才会出现连续两个正面？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4534</link>
<content><![CDATA[ 
		<p>    在<a href="http://www.matrix67.com/blog/archives/3638">一篇老日志</a>中，我提到了一个经典的概率问题：平均需要抛掷多少次硬币，才会首次出现连续两个正面？它的答案是 6 次。它的计算方法大致如下。</p>
<p>    首先，让我们来考虑这样一个问题： k 枚硬币摆成一排，其中每一枚硬币都可正可反；如果里面没有相邻的正面，则一共有多少种可能的情况？这可以用递推的思想来解决。不妨用 f(k) 来表示摆放 k 枚硬币的方案数。我们可以把这些方案分成两类：最后一枚硬币是反面，或者最后一枚硬币是正面。如果是前一种情形，则我们只需要看前 k – 1 枚硬币有多少摆法就可以了；如果是后一种情形，那么倒数第二枚硬币必须是反面，因而这种情形下的方案数就取决于前 k – 2 枚硬币的摆放方案数。因此我们得到， f(k) = f(k – 1) + f(k – 2) 。由于摆放一枚硬币有两种方案，摆放两枚硬币有三种方案，因而事实上 f(k) 就等于 F<sub>k+2</sub> ，其中 F<sub>i</sub> 表示 Fibonacci 数列 1, 1, 2, 3, 5, 8, …的第 i 项。</p>
<p>    而“抛掷第 k 次才出现连续两个正面”的意思就是，最后三枚硬币是反、正、正，并且前面 k – 3 枚硬币中正面都不相邻。因此，在所有 2<sup>k</sup> 种可能的硬币正反序列中，只有 F<sub>k-1</sub> 个是满足要求的。也就是说，我们有 F<sub>1</sub> / 4 的概率在第二次抛币就得到了连续两个正面，有 F<sub>2</sub> / 8 的概率在第三次得到连续两个正面，有 F<sub>3</sub> / 16 的概率在第四次得到连续两个正面⋯⋯因此，我们要求的期望值就等于：</p>
<p>     <img alt="image placeholder" >
<p><span id="more-4534"></span><br>
    这个无穷级数就等于 6：</p>
<p>      <img alt="image placeholder" >
<p>    不过，最后这一步来得也太假了，因为我们借助了强大的 Mathematica 。今天重新翻到这篇旧日志时，我就在想，究竟怎样求出这个无穷级数呢？这个数列的某些特征让我联想到了生成函数这一数学工具，用生成函数处理这样的数列非常合适。我在很早很早以前就写过<a href="http://www.matrix67.com/blog/archives/120">介绍生成函数的文章</a>，但遗憾的是，我对生成函数运用的了解，仅仅局限于教材和网络上给出的各种经典例子，从没有亲自用到过生成函数。今天算是我第一次真正使用生成函数，深感生成函数之妙。如果你是第一次看到生成函数的应用，想必你会大吃一惊，这种诡异的方法竟然能把答案搞出来！整个过程用到了很多生成函数的经典处理手段，这让它足以打败教材上的各种经典例子，成为了我最爱的生成函数应用例题之一。</p>
<p> <br>
 <br>
    让我们先来说说什么是生成函数吧。生成函数就是对数列进行编码的一种方式。我们可以用一个含有无限多项的多项式（注：这个说法是不准确的，有无限多项的不能叫多项式） a<sub>1</sub> · x<sup>1</sup> + a<sub>2</sub> · x<sup>2</sup> + a<sub>3</sub> · x<sup>3</sup> + … 把整个数列的全部信息装进去，其中第 i 次项系数就表示数列的第 i 项。因此，Fibonacci 数列的生成函数就可以写成：</p>
<p>     <img alt="image placeholder" >
<p>    厉害就厉害在，我们可以把生成函数表示成一个更简单的形式。先来看看 g(x)·x 的结果：</p>
<p>     <img alt="image placeholder" >
<p>    再看看 g(x) + g(x)·x 的结果：</p>
<p>     <img alt="image placeholder" >
<p>    你会发现， Fibonacci 数列的递推性质，使得上面这行式子与 g(x) 本身非常相像。事实上，如果把 g(x) 的每一项都除以 x ，再减去最前面多出来的 1 ，就能得到上面的这行式子了。因此，我们有：</p>
<p>     <img alt="image placeholder" >
<p>    我们甚至可以就此解出 g(x) 来：</p>
<p>     <img alt="image placeholder" >
<p>    于是，整个无穷级数 g(x) 被我们化简为了一个关于 x 的代数式！注意，虽然这个等式只在 x 充分小（小到级数 g(x) 收敛）的时候才有意义，不过这并不妨碍我们用这个代数式来代表 Fibonacci 数列的生成函数。我们可以把 Fibonacci 数列看作是生成函数的一个“展开”：</p>
<p>     <img alt="image placeholder" >
<p>    也就是说，这么一个小小的代数式就容纳了 Fibonacci 数列的全部信息！</p>
<p> <br>
 <br>
    生成函数是如此地具有代表性，以至于在研究数列时，我们常常会给出它的生成函数。在数列百科全书 <a href="http://oeis.org/">OEIS</a> 中，生成函数几乎是必不可少的一项。例如，在 <a href="http://oeis.org/A000045">Fibonacci 数列</a> 的描述中，FORMULA 一栏的第一行就是 G.f.: x/(1-x-x^2) ，说的就是 Fibonacci 数列的生成函数（generating function）。</p>
<p>    更绝的是，我们还可以直接对数列的生成函数进行变换，从而得到新的数列。比方说，在生成函数上再乘以一个 x ，我们就会让每一项的 x 的指数加 1 ，从而让整个数列右移一位，得到了一个新的数列 F<sub>i-1</sub>，即 0, 1, 1, 2, 3, 5, …</p>
<p>     <img alt="image placeholder" >
<p>    现在，我们需要用各种代数运算手段，对等式左边的生成函数进行变换，让等式右边的展开式变成本文开头的那个数列。什么操作能够同时让数列第 1 项除以 2 ，第 2 项除以 4 ，第 3 项除以 8 ，以此类推，让所有的第 i 项都除以 2<sup>i</sup> 呢？我们可以把所有的 x 都用 x / 2 来替代：</p>
<p>     <img alt="image placeholder" >
<p>    化简一下：</p>
<p>     <img alt="image placeholder" >
<p>    这就是数列 F<sub>i-1</sub> / 2<sup>i</sup> 的生成函数了。接下来，我们想要让第 i 项系数乘以一个 i ，也就是想要让每一项的系数都乘以该项的次数，这该怎么办呢？最神奇的地方出现了——我们对生成函数进行求导：</p>
<p>     <img alt="image placeholder" >
<p>    也就是：</p>
<p>     <img alt="image placeholder" >
<p>    不过，求导的同时，x 的次数也移动了一位。我们在生成函数上再乘以 x ，把 x 的次数纠正回来：</p>
<p>     <img alt="image placeholder" >
<p>    这就是本文最初的那个数列的生成函数了。令 x = 1 ，便有：</p>
<p>     <img alt="image placeholder" >
<p>    Tada！</p>
			 ]]></content>
<pubDate>2011-08-11T18:25:07+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4534</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：等边三角形内一点到各顶点的距离长可构成一个三角形 ]]></title>
<link>http://www.matrix67.com/blog/archives/4545</link>
<content><![CDATA[ 
		<p>    这是初中平面几何的一个经典问题：等边三角形 ABC 内有任意一点 P，求证 PA 、 PB 、 PC 的长度一定能构成一个三角形。</p>
<p>      <img alt="image placeholder" >
<p><span id="more-4545"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
      <img alt="image placeholder" >
<p>    这里给出两种证明方法。传统的证明方法是，把 △CPA 绕着点 C 逆时针旋转 60 度，从而旋转后的 CA 将会和 CB 重合，同时 P 点落在了 P’ 的位置。由于 △CP’B 是由 △CPA 旋转过去得到的，因此 P’B = PA 。另外，线段 CP’ 是 CP 绕着点 C 旋转 60 度得到的，说明 CP 和 CP’ 长度相等且夹角为 60 度，即 △CPP’ 是等边三角形，于是 PP’ = CP 。那么， △BPP’ 的三边长事实上分别等于 PA 、 PB 、 PC ，命题得证。</p>
<p> <br>
 <br>
      <img alt="image placeholder" >
<p>    今天我学到了另外一种证明方法，看上去更简洁巧妙一些。过点 P 分别作三边的平行线，将整个三角形划分为三个蓝色四边形。那么，图中的三个蓝色四边形都有一组对边平行，因而它们都是梯形；事实上，容易看出，这些梯形的两个底角都是 60 度，因而它们都是等腰梯形。只需注意到，等腰梯形的两条对角线长度是相等的，因此红色三角形 A’B’C’ 的三边长度事实上就分别等于 PA 、 PB 、 PC ，命题得证。</p>
<p>来源：<a href="http://www.cut-the-knot.org/Curriculum/Geometry/Pompeiu2.shtml">http://www.cut-the-knot.org/Curriculum/Geometry/Pompeiu2.shtml</a></p>
			 ]]></content>
<pubDate>2011-08-12T17:49:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4545</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 又一种证明素数无穷多的方法 ]]></title>
<link>http://www.matrix67.com/blog/archives/4548</link>
<content><![CDATA[ 
		<p>    今天又学到一种证明素数无穷多的方法。它是由 Filip Saidak 发现的，论文曾发表在 2006 年的 The American Mathematical Monthly 上。</p>
<p>    首先注意到，两个相邻自然数一定是互质的（否则，假设它们有大于 1 的公因数 k ，则它们的差也能被 k 整除，这显然是不可能的）。现在，取一个自然数 n &gt; 1 。由于 n 和 n + 1 是相邻自然数，因此 n 和 n + 1 是互质的。也就是说，n 的质因数和 n + 1 的质因数完全没有重合，因而 n(n + 1) 至少有两个不同的质因数。类似地，由于 n(n + 1) 和 n(n + 1) +1 是相邻自然数，因此它们是互质的，这说明 n(n + 1) 和 n(n + 1) +1 没有相同的质因数，也就是说 (n(n + 1))(n(n + 1) +1) 至少有三个不同的质因数。我们可以无限地这样推下去，从而得出，素数必然是无穷多的。</p>
<p><span id="more-4548"></span><br>
来源：<a href="http://primes.utm.edu/notes/proofs/infinite/Saidak.html">http://primes.utm.edu/notes/proofs/infinite/Saidak.html</a></p>
<p>素数无穷多的证明方法：<br>
<a href="http://www.matrix67.com/blog/archives/282">用 Fermat 数和 * – 集合证明素数无穷多</a><br>
<a href="http://www.matrix67.com/blog/archives/1678">素数无穷多的拓扑学证明</a><br>
<a href="http://www.matrix67.com/blog/archives/2700">用信息熵证明素数无穷多</a><br>
<a href="http://www.matrix67.com/blog/archives/2753">利用阶乘因子数公式证明素数无穷多</a><br>
<a href="http://www.matrix67.com/blog/archives/539">素数无穷多与两个更强的命题</a></p>
			 ]]></content>
<pubDate>2011-08-15T13:05:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4548</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 八皇后问题算什么，来看看无穷皇后问题吧 ]]></title>
<link>http://www.matrix67.com/blog/archives/4556</link>
<content><![CDATA[ 
		<p>    当 1848 年国际象棋玩家 Max Bezzel 提出八皇后问题（eight queens puzzle）时，他恐怕怎么也想不到，100 多年以后，这个问题竟然成为了编程学习中最重要的必修课之一。八皇后问题听上去非常简单：把八个皇后放在国际象棋棋盘上，使得这八个皇后互相之间不攻击（国际象棋棋盘是一个 8×8 的方阵，皇后则可以朝横竖斜八个方向中的任意一个方向走任意多步）。虽然这个问题一共有 92 个解，但要想徒手找出一个解来也并不容易。下图就是其中一个解：</p>
<p>     <img alt="image placeholder" >
<p>    八皇后问题有很多变种，不过再怎么也不会比下面这个变种版本更帅：请你设计一种方案，在一个无穷大的棋盘的每一行每一列里都放置一个皇后，使得所有皇后互相之间都不攻击。具体地说，假设这个棋盘的左下角在原点处，从下到上有无穷多行，从左到右有无穷多列，你需要找出一个全体正整数的排列方式 a1, a2, a3, … ，使得当你把第一个皇后放在第一行的第 a1 列，把第二个皇后放在第二行的第 a2 列，等等，那么任意两个皇后之间都不会互相攻击。</p>
<p>     <img alt="image placeholder" >
<p><span id="more-4556"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    下面给出一个非常简单巧妙的构造。首先，我们给出五皇后问题的一个解。并且非常重要的是，其中一个皇后占据了最左下角的那个格子。</p>
<p>     <img alt="image placeholder" >
<p>    接下来，我们把五皇后的解扩展到 25 皇后，而依据则是五皇后本身的布局：</p>
<p>     <img alt="image placeholder" >
<p>    这样一来，同一组里的五个皇后显然不会互相攻击，不同组的皇后之间显然也不会互相攻击，这便是一个满足要求的 25 皇后解了。注意到，在扩展之后，之前已经填好的部分并未改变。</p>
<p>    再接下来怎么办呢？没错，我们又把 25 皇后的解复制成五份，再次按照五皇后的布局来排列，从而扩展到 125 皇后！</p>
<p>     <img alt="image placeholder" >
<p>    像这样不断地根据已填的部分，成倍地向外扩展，便能生成一个无穷皇后问题的解。</p>
<p>    这个解法收录在了 Proofs without Words 一书中。</p>
			 ]]></content>
<pubDate>2011-08-24T03:49:02+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4556</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 最难的组合游戏：To Knot or Not to Knot ]]></title>
<link>http://www.matrix67.com/blog/archives/4560</link>
<content><![CDATA[ 
		<p>    <a href="http://arxiv.org/abs/1003.4494">A Midsummer Knot’s Dream</a> 简直可以说是去年学术界的一篇奇文，大家点进去看看就知道了。论文里讲了一个基于纽结理论的双人对弈游戏，名字也非常有艺术感： To Knot or Not to Knot 。这个游戏可能是最难的组合游戏了，它的数学性极强，思考难度非常大，甚至比 <a href="http://www.matrix67.com/blog/archives/4400">ERGO</a> 更不容易上手。一场游戏下来，究竟谁赢谁输可能都不好判断。</p>
<p>    To Knot or Not to Knot 的游戏规则非常简单。用铅笔在纸上画一个封闭的、可以自相交的回路，然后 A 、 B 两人轮流在图形中选取一个尚未被处理过的交叉点，并用橡皮擦对图形进行“细化”，明确两根线条的位置关系（可以抛掷硬币决定谁先行动）。A 的目的是要让最终的图形变成一个结，而 B 的目的则是避免图形打结。下面是其中一种可能的游戏过程，双方约定 B 先走。两人轮流对交叉点进行细化，七步之后，整个图形并未打结（你能看出来吗）， B 获得胜利。</p>
<p>      <img alt="image placeholder" >
<p>    注意，这是一个决策透明、信息公开的游戏，并且游戏不可能有平局产生。因此，即使双方都使出最佳策略，也必然有一个人会赢有一个人会输。也就是说，任意给定一个初始状态，总有一方有必胜的策略。不过，难就难在，究竟谁有必胜策略，必胜策略是什么，这并不容易判断。让我们来做一个练习题吧：下面的图形中，如果 A 先走，B 后走，谁有必胜策略？如果 B 先走，A 后走呢？记住，A 的任务是要让最终的图形打成结，而 B 的任务则是避免图形打结。</p>
<p>      <img alt="image placeholder" >
<p><span id="more-4560"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
      <img alt="image placeholder" >
<p>    答案是，两种情况下，后走的人都是必胜的。为了便于叙述，我们用 a 、 b 、 c 、 d 、 e 、 f 来标记图中的六个交叉点。对于两根线条连续两次相交的地方，最终只可能是右图所示的 I 、 II 、 III 、 IV 四种情形之一。我们把前两种情形叫做“假交叉”，把后两种情形叫做“真交叉”。</p>
<p>    注意到，如果 B 能把 (e, f) 变成假交叉，那么不管下面四个交叉点是什么样，整个图形必然不打结。因此，如果 B 是后走的，那么 B 一定可以获胜：一旦 A 动了 e 、 f 中的一个交叉点，那么 B 立即细化另一个交叉点，让它成为假交叉；否则， B 就陪着 A 在下面四个交叉点中玩。但是，下面只有四个交叉点，是一个偶数，因而最终 A 将被迫对 e 或者 f 进行细化，从而宣告 B 的胜利。</p>
<p> <br>
      <img alt="image placeholder" >
<p>    如果 A 是后走的人呢？ A 也将必胜。 A 可以把六个交叉点分成 (a, b) 、 (c, d) 、 (e, f) 三组，然后 B 细化了哪一个交叉点， A 也就跟着修改同组的另一个交叉点，从而决定每组交叉点的交叉类型。 A 可以把 (e, f) 变成真交叉，把 (a, b) 和 (c, d) 当中的一个也变成真交叉，另一个变成假交叉，这便能保证让整个图形打结（如图 1）。需要注意的是，把下面两组交叉变成一真一假，这是必需的。如果下面两组都是假交叉，得到的图形仍然没有打结（如图 2）；而如果下面两组都是真交叉的话，最终的图形也不见得就一定是一个结（如图 3）。</p>
<p> <br>
    有没有什么图形能够让先走者必胜，不管先走者是谁呢？当然有。我们只需要把刚才的图形中任意一处线条扭一下，得到的新图形就满足要求了。先走的人就先把这里进行细化，整个图形就退化成了原来的图，先走的人此时也就成为了后行者，便能套用刚才的必胜策略了。</p>
<p>      <img alt="image placeholder" >
<p>    当然，也存在这样的初始局面，使得必胜者并不是由先行后行直接决定的，还要具体看先行者是谁后行者是谁。这里就不再举例了。有没有什么更有意思的初始局面？判断必胜方有什么简便方法吗？能否迅速找出必胜策略呢？似乎目前都还没有什么漂亮的答案。</p>
			 ]]></content>
<pubDate>2011-08-25T02:55:04+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4560</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 再谈Julia集与Mandelbrot集 ]]></title>
<link>http://www.matrix67.com/blog/archives/4570</link>
<content><![CDATA[ 
		<p>    很早以前，我简单介绍过 Julia 集和 Mandelbrot 集，<a href="http://www.matrix67.com/blog/archives/292">文章在此</a>。这可以说是数学中最神秘、最令人敬畏的研究对象之一。不过，那时我对这个话题了解还不太深。今天见到<a href="https://christopherolah.wordpress.com/2011/08/08/the-real-3d-mandelbrot-set/">这个网页</a>，让我对 Julia 集和 Mandelbrot 集有了更深的了解。我查阅了一些其他的资料，然后写下这篇长文，与大家一同分享。继续阅读以前，建议先看看我原来那篇文章（很短），那里面有很多漂亮的 Julia 集和 Mandelbrot 集的图片，这篇文章就不再展示了。</p>
<p> <br>
    还是让我们先来简单复习一下复数吧。由于承认“负数也能开平方”将会带来很多幽雅和便利的结论，因此我们发明了虚数，用 i 来表示 -1 的平方根（即虚数单位），并把实数扩展为复数（即一切形如 a + b i 的数）。正如实数可以用数轴上的点来表示一样，复数可以用平面直角坐标系上的点来表示。令 x 轴表示复数的实数部分，令 y 轴表示复数的虚数部分，则 a + b i 就对应了平面上的点 (a, b) 。我们把这个平面直角坐标系叫做“复平面”。</p>
<p><span id="more-4570"></span><br>
    复数与复数之间不但可以相加相减，还可以相乘相除。(a + b i) + (c + d i) 就等于 (a + c) + (b + d) i ，而 (a + b i) (c + d i) 则等于 (ac – bd) + (bc + ad) i 。需要注意的是，我们不能讨论一个复数乘以另一个复数后是变大了还是变小了，因为复数根本没有大小之分。如果真的要比较它们的大小，我们可以比较它们的模。复数 a + b i 的模就是 a<sup>2</sup> + b<sup>2</sup> 的平方根，也就是它到复平面原点的距离。如果我们用不同的颜色来表示不同大小的模，那么整个复平面大致就是这样：</p>
<p>      <img alt="image placeholder" >
<p>    如果我们用 |z| 来表示复数 z 的模，那么上面这个图也就是函数 f(z) = |z| 的“等高线地图”。复数的模有一个重要的性质，大家可以自行验证：乘积的模等于模的乘积，即 |a·b| = |a|·|b| 。现在，我们对复平面上的所有点都进行平方，画出 f(z) = |z<sup>2</sup>| 的等高线地图：</p>
<p>      <img alt="image placeholder" >
<p>    可以看到，这一操作让模的变化更剧烈了，等高线变得更加密集了。外面浩瀚的蓝色空间，就对应着那些模已经相当大了的复数。</p>
<p>    有趣的事情开始了。如果对上图中的每个点再加上某个数，比如 0.3 ，那么整个图会怎样变化呢？容易想到，对于模相同的复数来说，给实数部分加上 0.3 ，这对实数部分本来就较大的数影响会更大一些。因此，上图将会变得更扁，整个图形会在水平方向上压缩。这也就是 f(z) = |z<sup>2</sup> + 0.3| 的等高线地形图：</p>
<p>      <img alt="image placeholder" >
<p>    接下来，我们再对所得的图形进行平方，继续加剧模的变化：</p>
<p>      <img alt="image placeholder" >
<p>    然后，再给每个点的实数部分加上 0.3 ，于是得到 f(z) = |(z<sup>2</sup> + 0.3)<sup>2</sup> + 0.3| 的图像：</p>
<p>      <img alt="image placeholder" >
<p>    再平方：</p>
<p>      <img alt="image placeholder" >
<p>    再加上 0.3 ，此时图形已经开始变得有意思起来了：</p>
<p>      <img alt="image placeholder" >
<p>    再平方一次：</p>
<p>      <img alt="image placeholder" >
<p>    再加上 0.3 ：</p>
<p>      <img alt="image placeholder" >
<p>    这也就是函数 f(z) = |(((z<sup>2</sup> + 0.3)<sup>2</sup> + 0.3)<sup>2</sup> + 0.3)<sup>2</sup> + 0.3| 的图像，它反映了对复平面上的各个复数“平方再加 0.3 ”迭代 4 次后模的大小情况。随着迭代次数的增加，整个图形将会变得越来越复杂。下图显示的就是迭代 12 次后的结果，可以看见整个图形已经具有了分形图形的复杂程度（图形的“黑边”其实是密集的等高线）：</p>
<p>      <img alt="image placeholder" >
<p>    上图中，大部分区域内的数都变得越来越大，直达无穷。而原点附近这个四叶草形区域内的数，至少目前还不算太大。这给出了上图的另外一种解读方法：随着迭代次数的增加，复平面上各个点的模的发散速度。有没有什么复数，随着迭代次数的增加，最终并不会趋于无穷呢？当然有。比如方程 z<sup>2</sup> + 0.3 = z 的两个复数解，它是这个迭代下的不动点，每次迭代后都维持原来的值，自然不会趋于无穷。我们把所有这种迭代后不会趋于无穷的点所组成的集合就叫做 Julia 集，它是以法国数学家 Gaston Julia 命名的。只可惜， z → z<sup>2</sup> + 0.3 的 Julia 集是由一些孤点组成的，我们无法把它画出来。上图中的四叶草形区域也只是那些发散比较慢的点，但再多迭代几次，最终也会趋于无穷。</p>
<p> <br>
 <br>
    是否存在适当的常数 c ，使得迭代 z → z<sup>2</sup> + c 的 Julia 集能够形成一块连通的区域呢？答案是肯定的。下图是对复平面上的点执行 12 次 z → z<sup>2</sup> – 1 迭代后的结果，中间这些紫色和黄色的点已经稳定下来，不会发散了，它们构成了一块连通的 Julia 集：</p>
<p>      <img alt="image placeholder" >
<p>    常数 c 还可以是复数。下图则是迭代过程 z → z<sup>2</sup> + (0.2 + 0.5 i) 迭代 12 次的结果，其中也有一些模非常小的点，它们不会发散，构成了连通的 Julia 集：</p>
<p>      <img alt="image placeholder" >
<p>    难以置信的是，每取一个不同的 c ，我们都能得到一个不同的 Julia 集，这些 Julia 集大小不同，形状各异，可谓是百花齐放，各有各的美丽。在我的那篇旧文章里，可以找到更多的 Julia 集图片。</p>
<p> <br>
 <br>
    在 Julia 集相关领域中，有一个非常漂亮而且非常重要的定理叫做 fundamental dichotomy theorem ，它告诉我们，一个 Julia 集要么是完全连通的，任意两点间都有一条通路；要么是完全不连通的，整个图形全是一个个孤立的点。</p>
<p>    随着常数 c 的变化，对应的 Julia 集也会连续地发生变化。我们比较关心的一个问题就是，哪些 c 值会让对应的 Julia 集形成一个连通的区域？为了回答这个问题，让我们来看看 Julia 集的另外一种计算方法。</p>
<p>    在研究 Julia 集时，我们通常假设 c 的模总是小于 2 的。注意到，对任意一个满足 |z| &gt; 2 的复数 z ，都有 |z<sup>2</sup>| = |z|<sup>2</sup>  &gt; 2·|z| ，也就是说，对这样的 z 进行平方后，它的模至少都会变成原来的两倍。即使常数 c 的方向和 z<sup>2</sup> 的方向完全相反，也不足以把 z<sup>2</sup> 的模抵消到原来的水平。因此，在迭代运算过程中，一旦某一步结果的模大于 2 了，可以断定它必将发散到无穷。</p>
<p>    因此，我们有了 Julia 集合的另一个定义。 z → z<sup>2</sup> + c 对应的 Julia 集，就是无限迭代下去后模仍然不超过 2 的点。于是，我们立即有了 Julia 集的另一种生成方法。我们可以从复平面上模不超过 2 的所有点，也就是以原点为中心半径为 2 的圆盘出发，看看哪些点的平方加 c 后会落在这个圆盘内，进而考察哪些点平方加 c 再平方加 c 后将会落在这个圆盘内，如此反向迭代，不断找出原象，反推出符合要求的点集。我们先用 c = -1 来试验一下。</p>
<p>    这就是复平面上模小于 2 的所有复数所组成的点集，即一个半径为 2 的圆盘：</p>
<p>      <img alt="image placeholder" >
<p>    我们把上图右移一个单位，得到所有加上 -1 后模小于 2 的点：</p>
<p>      <img alt="image placeholder" >
<p>    我们再找出上图区域中的每个点的平方根（别忘了，每个数都有两个平方根，因此每个点都有两个原象），于是得到所有平方再加 -1 后模仍然小于 2 的点。由于开平方是一个连续函数，而每个点都有一正一负两个平方根，因此整个图像本该变为两个关于原点对称的连通区域。不过，这两个连通区域有所重合，它们将会并在一起成为一整块连通区域。为了看出这一点，只需要注意到，0 是一个非常特殊的数，它的原象只有一个，就是它本身。由于上图中的区域内包含零点，因此它的两组原象也都包含原点，这就表明两个区域是有重合的，结果就像下图这样：</p>
<p>      <img alt="image placeholder" >
<p>    再将上图右移一个单位：</p>
<p>      <img alt="image placeholder" >
<p>    再作出平方根：</p>
<p>      <img alt="image placeholder" >
<p>    再次右移：</p>
<p>      <img alt="image placeholder" >
<p>    再次找平方根，由于零点始终没有跑出去，因此图像始终是一整块连通区域：</p>
<p>      <img alt="image placeholder" >
<p>    再次右移：</p>
<p>      <img alt="image placeholder" >
<p>    再次找平方根，图像仍然连通：</p>
<p>      <img alt="image placeholder" >
<p>    可以看到，此时得到的点集已经非常接近之前给出的 z → z<sup>2</sup> – 1 的 Julia 集了。下图则是反推 12 次后的结果，它基本上可以看作是 z → z<sup>2</sup> – 1 的 Julia 集了：</p>
<p>      <img alt="image placeholder" >
<p>    让我们再来看一个无法构成连通区域的 Julia 集的例子。取 c = – 1 – 0.9 i ，让我们来看看逆推的过程。还是先画出半径为 2 的圆盘：</p>
<p>      <img alt="image placeholder" >
<p>    现在，找出所有加上 – 1 – 0.9 i 后会落进该圆盘的点，实际上相当于把圆盘右移 1 个单位，再上移 0.9 个单位：</p>
<p>      <img alt="image placeholder" >
<p>    寻找上图中的点的平方根：</p>
<p>      <img alt="image placeholder" >
<p>    再平移：</p>
<p>      <img alt="image placeholder" >
<p>    再找平方根：</p>
<p>      <img alt="image placeholder" >
<p>    再次平移：</p>
<p>      <img alt="image placeholder" >
<p>    这里发生了一个非常值得注意的现象：原点现在跑到了灰色区域的外边。也就是说，这个点在若干次迭代之后不能落入那个半径为 2 的圆盘里，表明这个点的模最终将会发散。换句话说， 0 不属于 c = – 1 – 0.9 i 时的 Julia 集。</p>
<p>    由于 0 的原象还是 0 ，因此当我们考察哪些点的平方会落入上图中的区域时，0 继续排除在外。此时注意，灰色区域内不包含原点，说明这个图形不见得仍然连通了。事实上，我们可以证明，一个不包含原点的区域，开平方后必然会得到两块不连通的区域。为了证明这一点，我们在上图中画一条过原点的回路，把整个图形围起来。对这个回路上的所有点开平方后，将会得到一个过原点的、关于原点对称的封闭曲线。容易想到，这条闭曲线一定是一个 8 字形。而上图灰色区域的两个原象，则只能分居在 8 字形的两个圆圈中：</p>
<p>      <img alt="image placeholder" >
<p>    我们把上图再次平移：</p>
<p>      <img alt="image placeholder" >
<p>    再取平方根。注意到，上图中的两块区域都不含零点，因此由前面的结论，每个区域都将会再分成两个更小的连通区域，从而使得整个图中出现四个连通块：</p>
<p>      <img alt="image placeholder" >
<p>    如此逆推下去，连通块的数量将会越来越多，它们的总面积则会越来越小，最后就只剩下一些孤立的点了，就如同我们最早所说的 z → z<sup>2</sup> + 0.3 的 Julia 集一样。只不过，要想看出 z → z<sup>2</sup> + 0.3 所对应的 Julia 集并不连通，我们需要的逆推次数更多一些。下图中可以看到，直到第 12 次逆推，零点仍然还在候选区域中；到了第 13 次逆推，才把零点排除在 Julia 集之外。此后，图形很快便收缩为了一堆离散的点。</p>
<p>      <img alt="image placeholder" >
<p> <br>
 <br>
    也就是说，为了判断 z → z<sup>2</sup> + c 的 Julia 集是否连通，我们只需要测试一下，看对初始值 0 迭代无穷多次，所得的模是否会趋于无穷大。我们自然希望知道，能够使 Julia 集连通的常数值 c 在复平面上组成了一个什么样的图形。为此，我们只需要固定初始值为 0 ，把复平面上不同的点当作 c ，画出迭代过程中模的发散速度（和最开始制作 Julia 集一样，我们用不同的颜色来表示不同的发散速度）：</p>
<p>      <img alt="image placeholder" >
<p>    神奇的是，这本身竟然又是一个漂亮的分形图形！数学家 Benoît B. Mandelbrot 是最早对其进行系统研究的人之一，因此我们就把所有不会让零点发散的复数 c 组成的集合叫做 Mandelbrot 集。更多 Mandelbrot 集细节的惊人图片，也可以参见那篇老文章。整个 Mandelbrot 集可以包含于一个以原点为圆心，半径为 2 的圆里。这也就是我们在考虑 Julia 集时往往假设常数 c 的模小于 2 的原因。</p>
<p>    生成 Mandelbrot 集的算法和生成 Julia 集的算法完全一样，只是这一次我们固定的是初始值，而把 c 当作了变量。Mandelbrot 集内的每一个点就对应了一个连通的 Julia 集，Mandelbrot 集合外的点则对应了不连通的 Julia 集，并且很容易想到，越靠近 Mandelbrot 集的边界，对应的 Julia 集形状就越诡异。因此， Mandelbrot 集还有另外一种解读方法：它就是 Julia 集的缩略图！完全没有比喻的意思，它真的就是 Julia 集的缩略图：</p>
<p>      <img alt="image placeholder" >
<p>    因此， Mandelbrot 集可以说是所有无穷多个 Julia 集的一个高度总结。究其原因，还是因为 Julia 集的零点太重要了。Julia 集的零点的迭代结果，很大程度上决定了 Julia 集的形状，就好像这个零点“知道” Julia 集是什么样子似的。而 Mandelbrot 集则把所有的零点信息都汇聚在了一起，自然高度归纳出了所有的 Julia 集。</p>
<p> <br>
 <br>
    让我们总结一下 Julia 集和 Mandelbrot 集的关系。在迭代过程 z → z<sup>2</sup> + c 中，我们有四个参数： z 的初始值的实部、虚部，以及 c 的实部、虚部。 Julia 集就是给定 c 的实部、虚部后所得的结果，而 Mandelbrot 集则是限定 z 的实部和虚部均为 0 后的结果。大家可能想到，任意限定其中两个参数，把另外两个参数当作变量，我们还能得到很多不同的图形。事实上，如果把所有不同的 Julia 集重合起来，我们将会得到一个四维图形，它的其中两个维度是不同的初始值 z 构成的复平面，另外两个维度则是不同的常数 c 构成的复平面。这个四维空间就包含了所有不同的初始值在所有不同的常数 c 之下迭代的发散情况。而 Mandelbrot 集，则是这个四维图形在 c = 0 处的一个切片，并且是最具有概括力的一个切片。</p>
<p>    因此，我们相当于有了 Mandelbrot 集的一个四维扩展，从这个四维图形中，我们可以切出很多二维的或者三维的切片，得到更多惊人而漂亮的图形。Mandelbrot 集还有另外一种高维扩展，即用四元数 a + b i + c j + d k 来代替复数，从而得到另一种四维 Mandelbrot 集。可惜，这些扩展都是四维的，我们只能从它们的切片中获取三维图形。要想欣赏真正的三维版 Mandelbrot 集，我们还得想想别的方法。数学家们创造了很多漂亮的三维版 Mandelbrot 集，不过它们的定义有些生硬，并不自然。另外还有一个叫做 Multibrot 集的东西，它就是把 Mandelbrot 集产生规则中的 z<sup>2</sup> 一般化，用 z<sup>n</sup> 代替。随着 n 的连续变化， Multibrot 集也会连续地变化。如果把不同 n 所对应的 Multibrot 集重叠在一起，我们就会得到一个三维图形（如下图， n 从 1 取到 5 ）。这也勉强算得上是 Mandelbrot 的三维扩展吧。</p>
<p>      <img alt="image placeholder" >
<p>    Gaston Julia 和 Benoît B. Mandelbrot 两人的研究并未就此结束，这一系列研究直接导致了复动力学（complex dynamics）这一新学科的诞生。如果大家对这个感兴趣的话，不妨从 Wikipedia <a href="http://en.wikipedia.org/wiki/Complex_dynamics">相关页面</a>的 references 出发，深入阅读下去。</p>
			 ]]></content>
<pubDate>2011-08-31T12:48:57+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4570</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 无聊小制作：电影的颜色 ]]></title>
<link>http://www.matrix67.com/blog/archives/4581</link>
<content><![CDATA[ 
		<p>    昨天无聊时用 MPlayer 和 Mathematica 做了一张图。大致过程是，用 MPlayer 从各个电影中提取出间隔大致均等的 600 帧图像，导入到 Mathematica 中，再取各帧图像的颜色平均值，用一根根宽度为 1 像素的竖条来表示。得到的结果就是下面这个样子。你能在看到答案之前先猜出电影名字吗？你能识别出每一段颜色都对应着什么情节吗？</p>
<p> <br>
<img alt="image placeholder" >
 </p>
<p>Update: 看了大家的回复，我才悲催地发现，这件事情早有人做过了，而且做得比我更好。大家感兴趣的话可以前往： <a href="http://moviebarcode.tumblr.com/">http://moviebarcode.tumblr.com/</a></p>
			 ]]></content>
<pubDate>2011-09-01T12:02:37+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4581</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：2n位平衡01串平均有多少个平衡前缀？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4592</link>
<content><![CDATA[ 
		<p>    这次的趣题来源于 UyHiP <a href="http://www.brand.site.co.il/riddles/201108q.html">今年八月份的谜题</a>：概率均等地随机选取一个恰好含有 n 个 0 和 n 个 1 的 2n 位 01 串，这个 01 串平均会有多少个 0 和 1 个数相等的前缀（包括空串和整个串本身）？</p>
<p>    为了叙述简便起见，下面我们把所含 0 和 1 个数恰好相等的 01 串叫做平衡的 01 串。例如， 010010110011 就是一个平衡 01 串，它有四个平衡前缀，空串、 01 、01001011 以及整个 01 串本身。我们需要求出的就是，任取一个长为 2n 的平衡 01 串，平衡前缀的个数的期望值是多少。</p>
<p><span id="more-4592"></span><br>
    注意到，在所有长为 2n 的 01 串中，平衡 01 串一共有 C(2n, n) 个。下面我们证明，所有这些串的所有平衡前缀一共有 4<sup>n</sup> 个，从而得出问题的答案，即 4<sup>n</sup> / C(2n, n) 。</p>
<p>    不妨把所有 2n 位平衡 01 串的所有平衡前缀的总数记作 F(n) ，容易得出：</p>
<p>      <img alt="image placeholder" >
<p>    利用<a href="http://www.matrix67.com/blog/archives/4534">生成函数</a>，我们可以瞬间证明，这个和等于 4<sup>n</sup> 。由 Taylor 展开可知， 数列 C(2n, n) 所对应的生成函数为：</p>
<p>      <img alt="image placeholder" >
<p>    对上式平方，有：</p>
<p>      <img alt="image placeholder" >
<p>    但</p>
<p>      <img alt="image placeholder" >
<p>    因此 F(n) = 4<sup>n</sup> 。</p>
<p> <br>
 <br>
    Joseph DeVincentis 和 Daniel Bitin 给出了一个初等的证明。令 S 为某个平衡 01 串，令 k 为 S 的某个平衡前缀的长度（ k 有可能取 0 或者 2n ）。我们下面建立一个从所有可能的 (S, k) 到所有长为 2n 的 01 串的一一对应的关系，从而说明所有平衡前缀一共有 4<sup>n</sup> 个。</p>
<p>    我们先给出把 (S, k) 变换为一个普通 01 串的方法。首先，取 S’ = S 。接下来，找出 S’ 中比 k 更长的平衡前缀中最短的那一个，把它的长度记作 l 。然后，对 S’ 中从第 k + 2 位到第 l 位的数字全部取反。继续寻找新的 l 并执行相应的取反操作，直到 S’ 中不再有比 k 更长的平衡前缀。</p>
<p>    下面我们来说明，这个过程不会无限继续下去，总会有终止的时候。不妨假设 S 的第 k + 1 位是一个 0 。由于取反操作不影响前面 k + 1 位数字，因此 S’ 的前 k 位始终平衡，第 k + 1 位也始终是 0 。容易看出，每次取反前，第 k + 2 位到第 l 位中 1 的个数比 0 的个数多一个，因此对这一段数字取反将会让整个串少一个 1 多一个 0，从而让整个串的后半部分越来越不平衡。因此，总有一个时候，第 k 位以后将会不再有别的平衡点产生。如果 S 的第 k + 1 位是 1 ，类似的推理同样成立。</p>
<p>    然后，我们需要说明，这个对应关系确实是一一对应的。为此，我们需要给出把 S’ 变回 (S, k) 的方法。首先，我们可以很快还原出 k 的值来：找出 S’ 中最长的平衡前缀，它的长度就是 k 。注意， k 一定是偶数，并且有可能是 0 或者 2n 。如果 k 是 2n ，即 S’ 本身就是一个平衡串，那么我们可以直接还原出 S = S’ 。下面只考虑 k &lt; 2n 的情况。

    不妨假设 S' 的第 k + 1 位是 0 ，由于在此之后 S' 没有其他平衡点了，因此从第 k + 2 位开始数下去， 0 的个数必须始终大于等于 1 的个数。由于从第 k + 2 位一直数到最后一位一共有奇数个数字，因此其中 0 的总个数也就一定严格大于 1 的总个数。找出从第 k + 2 位起， 0 的个数首次超过 1 的个数的地方，比如说第 l 位。对第 k + 2 位到第 l 位的数取反（此时 S' 的前 l 位将变成一个平衡前缀）。这样一来，整个串的后面部分将会少一个 0 多一个 1 ，但 0 的个数有可能仍然比 1 多。继续找出从第 k + 2 位起首次 0 的个数刚好比 1 多一个的地方，像刚才那样继续取反，让 0 越来越少， 1 越来越多，直到整个串变为平衡串为止。整个过程显然是从 (S, k) 变换到 S' 的逆操作，因而最后得到的串正是 S 。当然，如果 S' 的第 k + 1 位是 1 ，上面的推理同样成立。至此，我们便完成了全部证明。
</p>
			 ]]></content>
<pubDate>2011-09-05T17:24:59+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4592</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：Conway的士兵 ]]></title>
<link>http://www.matrix67.com/blog/archives/4595</link>
<content><![CDATA[ 
		<p>    今天听说了 Conway’s Soldiers ，这是 Conway 大牛在 1961 年提出的一个数学谜题（似乎 <a href="http://www.matrix67.com/blog/?s=Conway">Conway</a> 的出镜率也太高了），我觉得非常有意思，在这里跟大家介绍一下。内容基本上来自于 Wikipedia 的<a href="http://en.wikipedia.org/wiki/Conway's_Soldiers">相关页面</a>。</p>
<p>    假设有一个无限大的棋盘。棋盘上可以放置一些象征着士兵的棋子。一个棋子可以跳过并吃掉和它相邻的一枚棋子（就像孔明棋一样）。这是棋子的唯一一种移动方式。现在，在某个位置画一条无限长的水平线，你需要在水平线下面放置足够多的棋子，使得它们前仆后继地往水平线上方跳，最终能够跳到水平线以上 n 个单位的位置。</p>
<p>      <img alt="image placeholder" >
<p>    如图所示，当 n = 1 时，两个棋子就够了。当 n = 2 时，我们需要 4 个棋子。当 n = 3 时，最少需要 8 个棋子。</p>
<p><span id="more-4595"></span><br>
    我们还能让士兵们冲到更远吗？可以的。下图显示的就是 n = 4 的最少棋子摆布方案，它一共要用 20 枚棋子（看看你能不能看出具体的移动步骤）。有趣的是， Conway 证明了下面这个或许有些不可思议的事实：当 n = 5 时，这个问题就不再有解了。换句话说，无论用多少个初始棋子，我们都不可能冲到 5 个单位远的位置去。这个证明过程非常神奇，它竟然和黄金分割莫名其妙地扯上了关系。</p>
<p>      <img alt="image placeholder" >
<p>    我们给每个格子标一个关于 x 的单项式。把目标格子标记为 x<sup>0</sup> ，也就是 1 ；一个格子离目标格子有多少步（相当于 manhattan 距离），就给这个格子标上 x 的多少次方。于是，整个棋盘就变成了下面这样。棋盘上的若干棋子形成的布局，也就对应了一个关于 x 的多项式。例如，下图中的 6 枚棋子就对应了多项式  x<sup>4</sup> +  3 · x<sup>5</sup> +  2 · x<sup>6</sup> 。</p>
<p>      <img alt="image placeholder" >
<p>    每次移动棋子，我们都会改变一个棋子的位置，同时从棋盘中拿掉另一个棋子，从而让整个多项式发生变化。我们把棋子的移动分成三类：正向移动、中性移动、背向移动（分别如上图中左、中、右三个棋子跳跃的例子）。所谓正向移动，也就是朝着目标点的方向跳跃，棋子落点处的指数比出发点的指数更小。假如棋子的出发点所在位置是 x<sup>n</sup>，那么这次跳跃给整个多项式带来的变化就是减去了一个 x<sup>n</sup> ，加上了一个 x<sup>n-2</sup> ，并且还减去了一个 x<sup>n-1</sup> 。我们可以记作 x<sup>n-2</sup> (1 – x – x<sup>2</sup>) 。中性移动就是指一个棋子从标有 x<sup>n</sup> 的格子跳到了另一个标有 x<sup>n</sup> 的格子，和目标点的距离并未变化，仅仅会让棋盘上少一个棋子  x<sup>n-1</sup> 。因此，这种移动给整个多项式带来的变化就是  – x<sup>n-1</sup> 。背向移动则是往远离目标点的方向跳跃，它给多项式带来的变化则是 – x<sup>n</sup> + x<sup>n+2</sup> – x<sup>n+1</sup> ，即 x<sup>n</sup> (x<sup>2</sup> – x – 1) 。</p>
<p>    现在，我们需要选取一个适当的底数 x ，使得正向移动给多项式带来的变化为 0 。为此，我们需要让 x 满足 1 – x – x<sup>2</sup> = 0 ，解得 x = (±√<span style="text-decoration:overline">5</span> – 1) / 2 。我们选取其中的正数解  (√<span style="text-decoration:overline">5</span> – 1) / 2 。出人意料的是，它正是神奇的黄金分割数 φ ≈ 0.618 。</p>
<p>    这样，棋盘的每个格子都对应了一个形如 φ<sup>n</sup> 的正实数，其中目标点是 φ<sup>0 </sup> ，也就是 1 。定义一个棋局的价值为各个棋子位置上所对应的正实数之和。任何正向移动都不会改变布局的价值，其它形式的移动都会让价值变小。我们的目标就是把整个阵型的价值变成 1 （或者更大，如果最后还有残余棋子的话）。</p>
<p>    注意 φ 的一些有趣的性质。由于 φ<sup>2</sup> = 1 – φ ，不断在等式两边乘以 φ ，我们还可以得到 φ<sup>3</sup> = φ – φ<sup>2</sup> ，φ<sup>4</sup> = φ<sup>2</sup> – φ<sup>3</sup> ， φ<sup>5</sup> = φ<sup>3</sup> – φ<sup>4</sup> 等等。把等式左边全部加起来，也就得到 φ<sup>2</sup> + φ<sup>3</sup> + φ<sup>4</sup> + … = 1 了。</p>
<p>      <img alt="image placeholder" >
<p>    当 n 等于 1 时，水平线以下第一行的格子的价值总和是 φ + 2 · φ<sup>2</sup> + 2 · φ<sup>3</sup> + 2 · φ<sup>4</sup> + … ，第二行每个格子的价值分别是第一行对应格子的 φ 倍，第三行格子的价值则再乘以 φ ，以此类推。因此，水平线以下的所有格子的总价值为：</p>
<p>        (φ + 2 · φ<sup>2</sup> + 2 · φ<sup>3</sup> + 2 · φ<sup>4</sup> + …) (1 + φ + φ<sup>2</sup> + φ<sup>3</sup> + …)<br>
     = (φ + 2)(1 + φ + 1)<br>
     = (φ + 2)<sup>2</sup><br>
     = φ<sup>2</sup> + 4 φ + 4<br>
     = 5 + 3 φ ，</p>
<p>    其中，最后一步再次用到了 φ<sup>2</sup> = 1 – φ 。</p>
<p>    当 n = 2 时，水平线离目标点的距离增加一个单位，从而导致每个格子的价值都乘以了一个 φ ，于是水平线下的所有格子的价值总和就是 (5 + 3 φ) φ = 5 φ + 3 φ<sup>2</sup> = 3 + 2 φ 。类似的， n = 3 时水平线下方的格子总价值为 (3 + 2 φ) φ = 3 φ + 2 φ<sup>2</sup> = 2 + φ ， n = 4 时这个值变为了 (2 + φ) φ = 2 φ + φ<sup>2</sup> = 1 + φ ， n = 5 时这个值变为了 (1+ φ) φ = φ + φ<sup>2</sup> = 1 。这表明，当 n 等于 5 时，如果在水平线以下的所有格子里都放上棋子，总价值正好为 1 。当然，棋子的数量不可能是无限的，因而初始布局的价值是严格小于 1 的，我们不可能把它变为一个价值大于等于 1 的棋局。这就说明， n = 5 时问题是没有解的。</p>
			 ]]></content>
<pubDate>2011-09-11T22:53:48+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4595</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 千万别学数学：最折磨人的数学未解之谜（二） ]]></title>
<link>http://www.matrix67.com/blog/archives/4603</link>
<content><![CDATA[ 
		<p>    数学之美不但体现在漂亮的结论和精妙的证明上，那些尚未解决的数学问题也有让人神魂颠倒的魅力。和 Goldbach 猜想、 Riemann 假设不同，有些悬而未解的问题趣味性很强，“数学性”非常弱，乍看上去并没有触及深刻的数学理论，似乎是一道可以被瞬间秒杀的数学趣题，让数学爱好者们“不找到一个巧解就不爽”；但令人称奇的是，它们的困难程度却不亚于那些著名的数学猜想，这或许比各个领域中艰深的数学难题更折磨人吧。</p>
<p>    今年年初时，我曾经写过一篇名为 <a href="http://www.matrix67.com/blog/archives/4035">千万别学数学：最折磨人的数学未解之谜</a> 的文章，选取并翻译了 Mathematical Puzzles 一书中提到的未解数学谜题。不过，毕竟 Mathematical Puzzles 一书容量有限，没法把所有折磨人的数学猜想都收录进来。后来，我慢慢收集了更多漂亮的数学猜想，今天又见到 MathOverflow 的<a href="http://mathoverflow.net/questions/75698/examples-of-seemingly-elementary-problems-that-are-hard-to-solve">这个问题</a>，足以凑成一篇新的文章了。于是写下来，和大家一同分享。</p>
<p><span id="more-4603"></span><br>
<strong>196 问题</strong></p>
<p>    一个数正读反读都一样，我们就把它叫做“回文数”。随便选一个数，不断加上把它反过来写之后得到的数，直到得出一个回文数为止。例如，所选的数是 67，两步就可以得到一个回文数 484：</p>
<blockquote><p>67 + 76 = 143<br>
143 + 341 = 484</p></blockquote>
<p>    把 69 变成一个回文数则需要四步：</p>
<blockquote><p>69 + 96 = 165<br>
165 + 561 = 726<br>
726 + 627 = 1353<br>
1353 + 3531 = 4884</p></blockquote>
<p>    89 的“回文数之路”则特别长，要到第 24 步才会得到第一个回文数，8813200023188。<br>
    大家或许会想，不断地“一正一反相加”，最后总能得到一个回文数，这当然不足为奇了。事实情况也确实是这样——对于几乎所有的数，按照规则不断加下去，迟早会出现回文数。不过，196 却是一个相当引人注目的例外。数学家们已经用计算机算到了 3 亿多位数，都没有产生过一次回文数。从 196 出发，究竟能否加出回文数来？196 究竟特殊在哪儿？这至今仍是个谜。</p>
<p><strong>Gilbreath 猜想</strong></p>
<p>    从小到大依次列出所有的质数：</p>
<blockquote><p>2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, …</p></blockquote>
<p>    求出相邻两项之差：</p>
<blockquote><p>1, 2, 2, 4, 2, 4, 2, 4, 6, 2, …</p></blockquote>
<p>    现在，再次求出所得序列中相邻两项之差，又会得到一个新的序列：</p>
<blockquote><p>1, 0, 2, 2, 2, 2, 2, 2, 4, …</p></blockquote>
<p>    重复对所得序列进行这样的操作，我们还可以依次得到</p>
<blockquote><p>1, 2, 0, 0, 0, 0, 0, 2, …<br>
1, 2, 0, 0, 0, 0, 2, …<br>
1, 2, 0, 0, 0, 2, …<br>
1, 2, 0, 0, 2, …</p></blockquote>
<p>    大家会发现一个有趣的规律：每行序列的第一个数都是 1。<br>
    某日，数学家 Norman L. Gilbreath 闲得无聊，在餐巾上不断对质数序列求差，于是发现了上面这个规律。Gilbreath 的两个学生对前 64 419 行序列进行了检验，发现这个规律始终成立。1958 年，Gilbreath 在一个数学交流会上提出了他的发现，Gilbreath 猜想由此诞生。<br>
    这个规律如此之强，很少有人认为猜想不成立。1993 年，Andrew Odlyzko对 10 000 000 000 000 以内的质数（也就是 346 065 536 839 行）进行了检验，也没有发现反例。<br>
    不过，这一看似简单的问题，几十年来硬是没人解决。</p>
<p><strong>Ramsey 问题</strong></p>
<p>    有这么一个定理：六个人参加一场会议，其中某些人之间握过手，那么一定存在三个人互相之间都握过手，或者三个人互相之间都没握过手。我们可以借助鸽笼原理很快证明这个结论。选出其中一个人 A ，然后把剩下的五个人分成两组，和 A 握过手的，以及没和 A 握过手的。显然，其中一组至少有三个人。不妨假设和 A 握过手的那一组至少有三个人吧。把这一组里的三个人分别记作 B 、 C 、 D（如果这一组的人数大于 3 ，任意选三个人就行了）。如果 B 、 C 、 D 三个人之间有两个人握过手，那么这两个人和 A 就成了互相之间握过手的三人组；如果 B 、 C 、 D 三个人之间都没握过手，那么他们本身就成了互相之间都没握手的三人组。如果至少有三个人的是没和 A 握手的那一组，根据类似的推理也能得出，总能找到互相之间都握过手或者都没握过手的三个人。<br>
    1930 年，英国数学家 Frank Ramsey 证明了一个更强的结论：给定两个正整数 r 和 s ，总能找到一个 n ，使得一场 n 人会议中，或者存在 r 个人互相之间都握过手，或者存在 s 个人互相之间都没握过手。用图论的语言来叙述，就是对于任意给定的 r 和 s ，总存在一个 n ，使得在完全图 K<sub>n</sub> 的任意一种红蓝二染色方案中，要么存在一个大小为 r 的红色完全子图，要么存在一个大小为 s 的蓝色完全子图。我们把满足条件的最小的 n 记作 R(r, s) 。<br>
    前面我们已经证明了，六个人足以产生互相都握过手的三个人或者互相都没握手的三个人，也就是说 R(3, 3) ≤ 6 。但五个人是不够的，比方说如果只有 A 和 B 、 B 和 C 、 C 和 D 、 D 和 E 、 E 和 A 之间握手，容易看出不管选哪三个人，握过手的和没握过手的总是并存。因此， R(3, 3) 精确地等于 6 。<br>
    求出 R(r, s) 的精确值出人意料地难。目前已经知道 R(4, 4) = 18 ，但对于 R(5, 5) ，我们只知道它介于 43 到 49 之间，具体的值至今仍未求出来。如果要用计算机硬求 R(5, 5) ，则计算机需要考虑的情况数大约在 10<sup>300</sup> 这个数量级，这是一个不可能完成的任务。而 R(6, 6) 就更大了，目前已知它在 102 到 165 的范围内。它的准确值是多少，恐怕我们永远都不可能知道了。<br>
    Erdős 神牛曾经说过，假如有一支异常强大的外星人军队来到地球，要求人类给出 R(5, 5) 的准确值，否则就会摧毁地球。Erdős 建议，此时我们应该集结全世界所有数学家的智慧和全世界所有计算机的力量，试着求出 R(5, 5) 来。但是，假如外星人要求人类给出 R(6, 6) 的准确值，那么 Erdős 建议，我们应该试着摧毁外星人军队。</p>
<p><strong>Singmaster 猜想</strong></p>
<p>    在杨辉三角中，数字 1 出现了无穷多次。除了数字 1 以外，哪个数字出现的次数最多呢？ 6 出现了 3 次，不过不算多。 10 出现了 4 次，不过也不算多。 120 出现了 6 次，算多了吧？还不算多。目前已知的出现次数最多的数是 3003 ，它同时等于 C(3003, 1) 、 C(78, 2) 、 C(15, 5) 、 C(14, 6) ，在杨辉三角中出现了 8 次。有没有出现次数更多的数，目前仍然是一个未解之谜。<br>
    真正精彩的来了。如果把正整数 a 在杨辉三角中出现的次数记作 N(a) ，那么函数 N(a) 是什么级别上涨的呢？ 1971 年，David Singmaster 证明了 N(a) = O(log a) ，即 N(a) 最多是对数级别上涨的。他同时猜想  N(a) = O(1) ，即 N(a) 有一个上限。这也就是 Singmaster 猜想。由于我们一直没能找到出现次数超过 8 次的数，因而这个上界很可能就是 8 。不过， Singmaster 猜测这个上界更可能是 10 或者 12 。<br>
    Erdős 认为，Singmaster 的猜想很可能是正确的，但证明起来会非常困难。目前最好的结果是，N(a) = O((log a · log log log a) / (log log a)<sup>3</sup>) 。</p>
<p><strong>有理距离</strong></p>
<p>    在平面上是否存在一个点，它到单位正方形的四个顶点的距离都是有理数？<br>
    第一次知道这个问题竟然没被解决时，我很是吃惊——我原本还以为这个问题会有一些很平凡的解呢。然而，仔细想想也不奇怪，这和很多其他的数学难题一样，本质上都是 Diophantus 方程，其解的存在性都是很难判断的。只不过，某些问题的叙述方式会给人带来一种格外基本、格外初等的感觉。<br>
    与这个问题类似的是 Euler 完美长方体问题：是否存在一个长方体，它的长、宽、高、所有面对角线以及体对角线的长度都是有理数？<br>
    事实上，还有很多“构造点集让距离满足一定关系”形式的数学问题，它们都是长期以来悬而未解的难题。</p>
<p>    另外几个与点集内的距离有关的未解之谜，我也一并写在这里。其中一个问题是 Ulam 在 1945 年提出的：是否存在一个平面上的稠密点集，使得每两个点之间的距离都是有理数？另一个有趣的问题则是，注意到 n 个点两两之间能确定 C(n, 2) 条线段，而这个数目<a href="http://www.matrix67.com/blog/archives/2904">正好等于</a> 1 + 2 + … + (n – 1) 。于是我们想问，是否对于任意一个正整数 n ，我们总能找出平面上任意三点不共线、任意四点不共圆的 n 个点，使得其中有一种长度的线段恰好出现了一次，有一种长度的线段恰好出现了两次，等等，一直到有一种长度的线段恰好出现了 n – 1 次？目前，人们已经构造出了 n ≤ 8 时的解，其中一部分构造可以见<a href="http://www.matrix67.com/blog/archives/3113">这里</a>（问题 12 ）。对于 n &gt; 8 的情况究竟是否有解，目前尚无定论。</p>
<p><strong>重构猜想</strong></p>
<p>    这可以说是图论中最重要的猜想之一，然而我却是最近才听说。这个猜想叫做“重构猜想”（reconstruction conjecture），最早是由 Kelly 和 Ulam 提出的。它的叙述非常简单：对于某个顶点数为 n 的图（n ≥ 3），如果已知它的每一个顶点为 n – 1 的子图，是否足以将原图重构出来？<br>
    让我们把这个问题变得形式化一些。假设 A 是一个至少有三个顶点的图（顶点无标号），把它的顶点数记作 n 。我们把去掉其中一个顶点后可能得到的所有 n 个子图所组成的多重集（允许重复元素的集合）叫做图 A 的 n – 1 子图集。重构猜想就是问，如果 A 、 B 两个图拥有完全相同的 n – 1 子图集，那么这两个图是否也一定同构？<br>
    目前已经发现，有很多类型的图都是可以重构的，比如完全图（显然）、不连通图、树等等。所有图都是可重构的吗？这是图论中最大的谜题之一。<br>
    和其他的数学猜想不一样，如果要用计算机来检验这个猜想，其计算量相当惊人。目前，计算机仅仅验证了 n ≤ 11 的情况。</p>
<p><strong>(3/2)<sup>n</sup> 的小数部分</strong></p>
<p>    假如 n 是正整数， (3/2)<sup>n</sup> 的小数部分在 [0, 1] 区间内稠密吗？<br>
    目前，我们已经知道，对于任意无理数 a ， n · a 的小数部分一定在 [0, 1] 区间内稠密。我们也已经知道，对于几乎所有的 t ，t · (3/2)<sup>n</sup> 的小数部分在 [0, 1] 区间内稠密。我们还知道，对于几乎所有的实数 b &gt; 1 ， b<sup>n</sup> 的小数部分在 [0, 1] 区间内稠密。不过，这都还不足以解决我们刚刚提到的问题。</p>
<p><strong>Kusner 猜想</strong></p>
<p>    定义 n 维空间中 P(p<sub>1</sub>, p<sub>2</sub>, …, p<sub>n</sub>) 和 Q(q<sub>1</sub>, q<sub>2</sub>, …, q<sub>n</sub>) 两点之间的 Manhattan 距离为 |p<sub>1</sub> – q<sub>1</sub>| + |p<sub>2</sub> – q<sub>2</sub>| + … + |p<sub>n</sub> – q<sub>n</sub>| ，直观地说就是在 n 维网格中从 P 到 Q 的最短路径长度。某日，<a href="http://imaginary.farmostwood.net/517.html">木遥</a>告诉了我一个与此相关的数学未解之谜：在 n 维空间中，最多可以有多少个 Manhattan 距离两两相等的点？<br>
    容易看出，这样的点至少可以有 2n 个，例如三维空间中 (1, 0, 0) 、 (-1, 0, 0) 、 (0, 1, 0) 、 (0, -1, 0) 、 (0, 0, 1) 、 (0, 0, -1) 就是满足要求的 6 个点。大家肯定会想，这应该就是点数最少的方案了吧？不过，真要证明起来可没那么容易。1983 年，Robert Kusner  猜想， n 维空间中 Manhattan 距离两两相等的点最多也只能有 2n 个，这也就是现在所说的 Kusner 猜想。目前人们已经证明，当 n ≤ 4 时， Kusner 猜想是正确的。当 n &gt; 4 时呢？虽然大家相信这个猜想也应该是正确的，但还没有人能够证明。<br>
    有趣的是，在很多其他的度量空间下，同类型的问题却并没有这么棘手。如果把距离定义为标准的 Euclidean 距离，那么 n 维空间中显然最多有 n + 1 个等距点；如果把距离定义为 Chebyshev 距离（即所有 |p<sub>i</sub> – q<sub>i</sub>| 中的最大值），问题的解则是 2<sup>n</sup> ，即 n 维坐标系中单位立方体的 2<sup>n</sup> 个顶点。一旦换作 Manhattan 距离，问题就迟迟不能解决，这还真有些出人意料。</p>
<p> <br>
    好了，这次我们就先说到这里。和往常一样，希望能看到大家留言或者来信分享更多精彩的例子。<br>
    如果文章中有错误或者时效性问题，也请速告知。</p>
			 ]]></content>
<pubDate>2011-09-24T14:02:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4603</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 无聊小研究：各种文体中出现频率最高的四字词 ]]></title>
<link>http://www.matrix67.com/blog/archives/4619</link>
<content><![CDATA[ 
		<p>今天，我拿到了梦寐以求的大规模中文语料库，总大小超过 1 G ，覆盖了各个时代各种文体的中文资料。有了这个语料库后，我便能完成很多早就想做的事情，比方说，统计各种文体中出现频率最高的四字词。给定一段文本后，基本的统计过程如下：</p>
<p>  1. 统计所有连续四字的出现频数；<br>
  2. 按频数对所有四字组合从高到低排序；<br>
  3. 删掉所有包含非汉字字符（比如数字、标点）的四字组合；<br>
  4. 删掉明显不成词或者不成词组的四字组合（这一步有人为因素，因此下面的数据并不是 100% 客观的）；<br>
  5. 列出频数最高的 10 个四字词。</p>
<p>所选用的统计对象基本上都是数十万字的篇幅，所有步骤都是用 Mathematica 实现的。下面是结果：<br>
<span id="more-4619"></span></p>
<p> <br>
<strong>《物种起源》</strong></p>
<p>自然选择、生活条件、一个物种、博物学者、这种情形、我们可以、如果我们、发生变异、这个问题、同一物种</p>
<p> <br>
<strong>《梦的解析》</strong></p>
<p>我们可以、歇斯底里、梦的内容、可以看出、精神分析、梦的形成、梦的解析、俄狄浦斯、愿望达成、典型的梦</p>
<p> <br>
<strong>《自私的基因》</strong></p>
<p>雄性个体、雌性个体、生存机器、利他行为、自然选择、这种情况、亲缘关系、我们可以、复制基因、一个个体</p>
<p> <br>
<strong>《时间简史》</strong></p>
<p>爱因斯坦、量子力学、统一理论、事件视界、人们可以、不确定性、弗利德曼、早期宇宙、科学定律、时间箭头</p>
<p> <br>
<strong>《资本论》</strong></p>
<p>剩余价值、资本主义、生产资料、使用价值、劳动时间、劳动过程、另一方面、生活资料、生产过程、剩余劳动</p>
<p> <br>
<strong>《全球通史》</strong></p>
<p>欧亚大陆、伊斯兰教、世界大战、民族主义、印第安人、土耳其人、葡萄牙人、阿拉伯人、澳大利亚、罗马帝国</p>
<p> <br>
<strong>《邓小平文选（一）》</strong></p>
<p>这个问题、社会主义、资产阶级、统一战线、代表大会、共产党员、少数民族、党的领导、群众运动、人民群众</p>
<p> <br>
<strong>《谁动了我的奶酪》</strong></p>
<p>这个故事、新的奶酪、在迷宫中、觉得自己、没有奶酪、我的奶酪、害怕改变、在墙上写、我们公司、找到奶酪</p>
<p> <br>
<strong>《西游记（上）》</strong></p>
<p>行者笑道、齐天大圣、有诗为证、毕竟不知、摇身一变、行者闻言、观音菩萨、按落云头、三藏闻言、厉声高叫</p>
<p> <br>
<strong>《1984》</strong></p>
<p>从来没有、什么东西、没有什么、思想警察、什么地方、双重思想、他们两人、杜松子酒、泰晤士报、没有办法</p>
<p> <br>
<strong>《股市宝典》</strong></p>
<p>证券分析、日成交量、证券市场、技术分析、十日成交、五日成交、股票市场、上市公司、趋近交叉、波浪理论</p>
<p> <br>
<strong>《实用软件工程》</strong></p>
<p>软件开发、软件工程、数据流图、测试用例、程序设计、维护工作、需求分析、程序结构、开发工作、规格说明</p>
<p> <br>
<strong>《李敖有话说》</strong></p>
<p>言论自由、看到没有、为什么呢、告诉大家、什么原因、给大家看、换句话说、为什么不、可以看到、我们可以</p>
<p> <br>
<strong>《易中天品三国》</strong></p>
<p>这个时候、三国演义、这样一个、是什么呢、这个事情、我们知道、这个地方、投降曹操、为什么要、三顾茅庐</p>
<p> <br>
<strong>《故事会》2005年</strong></p>
<p>怎么回事、就在这时、不好意思、哈哈大笑、中年男子、什么时候、不一会儿、这天晚上、莫名其妙、大吃一惊</p>
<p> <br>
<strong>1982年北京话口语调查记录</strong></p>
<p>那时候儿、这个这个、那个那个、解放以后、没有什么、就是那个、儿媳妇儿、也不知道、就是这个、我那会儿</p>
<p> <br>
<strong>《人民日报》2000年4月份新闻版</strong></p>
<p>社会主义、领导干部、思想政治、一个中国、巴勒斯坦、中国政府、中国人民、改革开放、全国人大、两国人民</p>
			 ]]></content>
<pubDate>2011-09-29T22:06:49+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4619</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：旋转桌子避免灯泡全亮 ]]></title>
<link>http://www.matrix67.com/blog/archives/4631</link>
<content><![CDATA[ 
		<p>    网友 <a href="http://twitter.com/#!/ipondering/status/118675034968571905">@ipondering</a> 分享了一个非常精彩的<a href="http://www.cs.cmu.edu/puzzle/index.html">数学趣题集</a>，里面有很多我之前从没见过的趣题，其中有些问题的题目和解答都相当漂亮。近段时间里，我打算从中选一些最精彩的题目来讲讲。今天的题目是该趣题集中的第二题，原题背景涉及到 King Arthur 和 Merlin 的故事，我就舍去简化了。</p>
<p>    某个国王手下有 n 个大臣。国王定期主持国家会议，届时 n 个大臣将会间隔均匀地坐在圆桌上。每个座位前都有一盏照明灯，只有所有的灯都亮了，会议才能开始进行。如果有些灯没亮，国王会下达指令，让指定位置上的大臣按下座位前的灯的开关，把没亮的灯都打开。例如，当 n = 100 时，圆桌上会坐着 100 个大臣。不妨将座位从 1 到 n 顺序编号，假设其中编号为 3 、 28 、 97 的座位前没有亮灯。于是，国王下令这三个位置上的大臣按下各自面前的开关，把这三盏灯打开，这样才能开始会议议程。</p>
<p>    在这 n 个大臣中，有一个奸臣。这次会议的议题恰好就是商讨对这个奸臣的惩治办法。奸臣知道自己难逃一劫，但他希望能够无限制地拖延会议。他可以在所有大臣就座前精心设置各个照明灯的初始状态，并在国王每次下达指令之后（但在大臣执行命令之前）把圆桌旋转到一个合适的位置，让大臣们按下错误的开关。</p>
<p>    对于哪些 n ，奸臣可以始终保证灯不会全亮，从而无限制地拖延会议？对于哪些 n ，国王可以根据局势巧妙地构造指令，使得有限轮指令之后所有灯必然全亮？</p>
<p>    在会议结束前，奸臣仍然是 n 个大臣中的一员。国王每次只能下达形如“座位编号为 a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, … 的大臣改变各自面前的灯的状态”的指令。奸臣可以任意旋转圆桌，改变灯与大臣的对应关系。当然，他也可以选择不旋转圆桌。即使桌子被旋转过，所有大臣也必须严格遵守国王的指令。</p>
<p><span id="more-4631"></span><br>
 <br>
    我们来看两个例子吧。首先，当 n = 1 时，国王显然是必胜的。当 n = 2 时，国王也是必胜的。注意到，如果两灯状态相同，国王便立即获胜了。如果初始时两灯状态不同，国王可以随便叫某个人按下开关。不管奸臣是否旋转圆桌，两灯状态都会变得相同，国王便可在第二轮获胜。</p>
<p>    下面我们用数学归纳法来说明，当 n = 2<sup>k</sup> 时，国王都有必胜策略。为此，我们只需要说明，如果对于某个 n ，国王有必胜策略，那么对于 2n 的情况，国王也有必胜策略。首先，把每两个关于圆桌中心对称的灯视为一组，这样就把 2n 个灯分成了 n 组。把这 n 组灯看作是 n 个“超级灯”。如果一组灯里的两个灯泡状态相同，我们就认为这个超级灯发亮；如果这组灯里的两个灯泡状态不同，就认为这个超级灯不亮。接下来，国王只对编号为 1, 2, 3, …, n 范围内的座位下达命令，那么不管奸臣怎么旋转圆桌，他都最多只能改变每组灯里的其中一个灯泡。事实上，我们完全可以把现在的情形等价地想像成这样：圆桌旁有 2n 个座位， n 个大臣坐满圆桌的其中半边；桌上则有 n 个超级灯，旋转圆桌半周正好让这 n 个超级灯重新回到初始位置。由归纳假设，对于 n 个灯泡的情形国王可以必胜，因此现在，国王可以套用这个算法，让每一个超级灯都发亮。换句话说，国王能够让位于对称位置上的每一组灯都处于相同的状态。</p>
<p>    接下来，国王把每两个处于对称位置的座位也编为一组，换句话说就是把 2n 个座位分成了 (1, n+1), (2, n+2), …, (n – 1, 2n – 1), (n, 2n) 共 n 组。此后，国王总是成组地下达指令，叫某个人按下开关，必须要叫和他同组的另一个人也按下开关。这下，不管奸臣怎么旋转圆桌，每组灯里的灯泡状态要么同时改变，要么都不变，于是每组灯里两个灯泡的状态都继续保持相同。重新解释超级灯的状态：如果这组灯的两个灯泡都亮，就认为这个超级灯是亮的；如果这组灯的两个灯泡都不亮，则认为这个超级灯不亮。容易看出，这下又成了这样的情况： n 组人操作 n 个超级灯，桌子每转半周就会回到原来的位置。因此，国王再次套用 n 个灯时的算法，便能让所有超级灯都发亮。这样，所有 2n 个灯泡也都亮了。</p>
<p> <br>
    下面我们说明，当 n 不是 2 的幂时，奸臣可以无限拖延会议。让我们先来看一个简单的情况。当 n 是奇数时，只要初始时灯泡不全亮也不全灭，奸臣都能必胜。注意到，如果灯泡既没全亮又没全灭，那么我们一定能找到相邻的两盏灯，它们是一亮一灭的。奸臣可以保证今后这两盏灯始终一亮一灭。如果国王对所有人都下指令，奸臣大可不必担心，这两盏灯显然仍然一亮一灭。如果国王只对一部分人下指令，那么由于 n 是奇数，因而即使国王故意间隔着选人，也将不可避免地出现两个相邻的人，他们都被叫到了或者都没被叫到。此时，奸臣旋转桌子，让那两盏灯对齐这两个人，从而保持这两盏灯仍然一亮一灭。</p>
<p>    事实上，只要 n 不是 2 的幂，我们都有类似的方法。把 n 写成 2<sup>k</sup> · m ，其中 m 是一个奇数。现在，我们从某盏灯出发，选出每第 2<sup>k</sup> 盏灯，从而选出间隔均等的 m 盏灯。国王下达指令后，我们也只关心这 m 盏灯所对应的人是否被叫到，并限定圆桌只能旋转 2<sup>k</sup> 的倍数格。这样，我们便可以完全把其他灯都无视掉，对这 m 盏灯套用灯数为奇数时的做法，从而让这 m 盏灯始终不能全亮。这就足以让会议无限延期了。</p>
<p> <br>
题目来源：<a href="http://www.cs.cmu.edu/puzzle/puzzle2.html">http://www.cs.cmu.edu/puzzle/puzzle2.html</a></p>
			 ]]></content>
<pubDate>2011-10-03T14:14:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4631</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：从1到4000中各位数字之和能被4整除的有多少个？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4644</link>
<content><![CDATA[ 
		<p>    一个小学奥数老师给我讲了一道小学奥数题，这是他在上课时遇到的：从 1 到 4000 中，各位数字之和能被 4 整除的有多少个？</p>
<p>    注意，问题可能没有你想的那么简单，满足要求的数分布得并没有那么规则。 1 、 2 、 3 、 4 里有一个满足要求的数， 5 、 6 、 7 、 8 里也有一个满足要求的数，但是 9 、 10 、 11 、 12 里就没有了。</p>
<p>    尽管如此，这个问题仍然有一个秒杀解。你能多快想到？</p>
<p><span id="more-4644"></span><br>
 <br>
    答案就是 1000 。首先， 0 和 4000 都是满足要求的数，因而我们不去看 1 到 4000 中有多少个满足要求的数，转而去看 0 到 3999 中有多少个满足要求的数，这对答案不会有影响。注意到，如果固定了末三位，比如说 618 ，那么在 0618 、 1618 、 2618 、 3618 这四个数中，有且仅有一个数满足，其各位数字之和能被 4 整除。考虑从 000 到 999 这 1000 个可能的末三位组合，每一个组合都唯一地对应了一个满足要求的四位数，因此问题的答案就是 1000 。</p>
<p>    真正有趣的事情在后面呢。一个小朋友举手说：“老师，我明白了，按照这个道理，从 1 到 3000 里各位数字之和能被 3 整除的数也是 1000 个。”另一个小朋友说：“废话，各位数字之和能被 3 整除就表明整个数能被 3 整除，在 1 到 3000 里这样的数当然有 1000 个嘛！”全班哄堂大笑。</p>
			 ]]></content>
<pubDate>2011-10-05T10:14:11+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4644</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 难倒犹太人的11个数学问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/4649</link>
<content><![CDATA[ 
		<p>    这个并不是标题党。很多年以前，要想进入莫斯科国立大学的数学系，你必须通过四项入学考试；头两个都是数学考试，一个笔试，一个面试。在面试中，学生和考官都是一对一的，考官可以自由向学生提出任何他喜欢的问题。考官们都准备了很多“棺材问题”，这些问题的答案非常简单，但由于思路太巧妙了，以至于学生很难想到。考官便可以以“你连这个都没想到”为理由，光明正大地拒绝学校不想要的人（主要是犹太人）。这个 Blog 之前就曾经<a href="http://www.matrix67.com/blog/archives/507">介绍过这样的问题</a>。</p>
<p>    最近<a href="http://arxiv.org/pdf/1110.1556v1">网上的一篇文章</a>介绍了 21 个这样的“棺材问题”，其中有些这个 Blog 以前讲过的经典问题，但也有不少我第一次见到的好题。我选取了 11 个比较有意思的问题，在这里和大家分享。</p>
<p><span id="more-4649"></span></p>
<blockquote><p>1. 找出所有的函数 F(x): R→R ，使得对于任意两个实数 x<sub>1</sub> 、 x<sub>2</sub> 都满足 F(x<sub>1</sub>) – F(x<sub>2</sub>) ≤ (x<sub>1</sub> – x<sub>2</sub>)<sup>2</sup> 。</p></blockquote>
<p> </p>
<blockquote><p>答案：不等式可以变为 (F(x<sub>1</sub>) – F(x<sub>2</sub>)) / |x<sub>1</sub> – x<sub>2</sub>| ≤ |x<sub>1</sub> – x<sub>2</sub>| ，于是我们立即可知，对于任意实数 x<sub>2</sub> ，函数在 x<sub>2</sub> 处的导数都为 0 。因此， F(x) 是常函数。</p></blockquote>
<p> <br>
 </p>
<blockquote><p>2. 给定三角形 ABC ，用尺规作图找出 AB 上的一点 K 以及 BC 上的一点 M ，使得 AK = KM = MC 。<br>
  <img alt="image placeholder" >
<p> </p>
<blockquote><p>答案：先在 BC 上任取一个点 M’ ，然后用圆规截取 AD = CM’ 。过 D 作 AC 的平行线，以 M’ 为圆心 M’C 为半径作圆，与这条平行线交于点 K’ 。过 K’ 作 AB 的平行线。容易看出，此时 A’K’ = K’M’ = M’C ，并且三角形 A’B’C 与整个大三角形 ABC 是相似的。如果以 C 为中心将 A’B’C 放大到 ABC ，就可以得到满足要求的 K 点和 M 点了。因此，我们延长 CK’ ，并把它与 AB 的交点记为点 K ，这个点 K 就是要求的点。既然 AK 的长度知道了， M 点的位置也就确定了。<br>
  <img alt="image placeholder" >
<p> <br>
 </p>
<blockquote><p>3. 解方程 2 · <sup>3</sup>√<span style="text-decoration:overline">2y – 1</span> = y<sup>3</sup> + 1 。</p></blockquote>
<p> </p>
<blockquote><p>答案：令 x = (y<sup>3</sup> + 1) / 2 ，原式就变成了 y = (x<sup>3</sup> + 1) / 2 。如果令函数 f(t) = (t<sup>3</sup> + 1) / 2，你会发现 x 和 y 同时满足 f(x) = y 和 f(y) = x 。然而函数 f(t) 是严格单调递增的，因此 x 一定等于 y 。<br>
于是，方程就变成了 y<sup>3</sup> – 2y + 1 = 0 。等式左边可以变为 (y<sup>3</sup> – y<sup>2</sup>) + (y<sup>2</sup> – y) – (y – 1) ，进而分解为 (y – 1)(y<sup>2</sup> + y – 1) 。于是得到方程的三个解： y = 1 和 y = (- 1 ± √<span style="text-decoration:overline">5</span>) / 2 。</p></blockquote>
<p> <br>
 </p>
<blockquote><p>4. 给定平面上的一个点 M 以及一个角 XOY 。用尺规作图确定出一条过 M 的直线，使得它与这个角的两边围成的三角形周长为一个给定值 p 。<br>
  <img alt="image placeholder" >
<p> </p>
<blockquote><p>答案：在角的两边上分别作出 A 、 B 两点，使得 AO = BO = p / 2 。过 A 、 B 两点分别作所在直线的垂线，两垂线交于点 C 。不难看出， AC 和 BC 的长度相等。事实上，如果以 C 为圆心作一个经过 A 、 B 的圆，这个圆将正好和角 XOY 的两边切于 A 、 B 两点。现在，过 M 作这个圆的切线，将切点记为 T 。只需要注意到 PT = PA ，并且 QT = QB ，因此三角形 OPQ 的周长就等于 AO + BO ，也就是 p 。<br>
  <img alt="image placeholder" >
补充一下切线的作法：以 MC 为直径作圆，与圆 C 交于点 T 。于是 ∠CTM 是一个直角，因而 MT 就是切线。</p></blockquote>
<p> <br>
 </p>
<blockquote><p>5. 给定一个等边三角形 ABC ，以及三角形内的一个点 O ，满足 ∠AOC = x ， ∠BOC = y 。如果用线段 AO 、 BO 、 CO 组成一个三角形，它的各个内角是多少（用 x 和 y 来表示）？<br>
  <img alt="image placeholder" >
<p> </p>
<blockquote><p>答案：将整个三角形绕着点 A 顺时针旋转 60 度，把 B 和 O 的落点分别记作 B’ 和 O’ 。这样的话， ∠AO’B 和 ∠BO’B’ 的角度也是 x 和 y ，并且 CO = BO’ 。另外，由于 AO 与 AO’ 长度相等且夹角为 60 度，因此三角形 AOO’ 是等边三角形， AO = OO’ 。因此，三角形 BOO’ 的三边长度实际上就分别等于 AO 、 BO 、 CO 。根据已知条件很容易算出它的三个内角度数，它们分别是 x – 60° 、 y – 60° 和 300° – x – y 。<br>
  <img alt="image placeholder" >
<a href="http://www.matrix67.com/blog/archives/4545">这里</a>有一个相关的问题。</p></blockquote>
<p> <br>
 </p>
<blockquote><p>6. 给定平面上的两条相交直线。到这两条直线的距离和等于某个给定值 p 的所有点将组成一个什么样的图形？</p></blockquote>
<p> </p>
<blockquote><p>答案：一个矩形。假设有一个等腰三角形 ABC ，底边 BC 上有一个动点 P 。把三角形腰长记为 l ，把 P 到两腰的距离分别记作 PM 和 PN 。线段 AP 将三角形 ABC 分成了左右两个小三角形，它们的面积和 (l · PM) / 2 + (l · PN) / 2 = l · (PM + PN) / 2 是一个定值（即整个三角形的面积），因此 PM + PN 也是一个定值。这个定值就是等腰三角形腰上的高。<br>
  <img alt="image placeholder" >
两条相交直线将产生四个角，每个角里都有这么一个“底边”。这四条“底边”组成了一个矩形。<br>
  <img alt="image placeholder" >
<p> <br>
 </p>
<blockquote><p>7. 能否在平面上放置六个点，使得任意两点之间的距离都是整数，并且任意三点不共线？</p></blockquote>
<p> </p>
<blockquote><p>答案：可以。我们先专心构造出任意两点之间的距离都是有理数的点集，再把所有点的坐标都扩大一个相同的倍数即可。把三边长分别为 3 、 4 、 5 的经典直角三角形放在平面直角坐标系上，斜边放在 x 轴上，斜边的中点和原点重合。那么，斜边上的高 CH 一定是有理数，因为由面积法可知它等于 AC · BC / AB 。另外，由于 △AHC 、 △BHC 、 △ABC 都是相似的，它们都是 3 : 4 : 5 的三角形，可知 AH 、 BH 也都是有理数。另外， C 到原点 O 的距离也是有理数，因为它是直角三角形斜边上的中线，它等于斜边长度的一半。<br>
  <img alt="image placeholder" >
现在，把 C 沿着 x 轴翻折到 C’ ，再把 C 和 C’ 分别沿 y 轴翻折到 D 和 D’ 。于是 A 、 B 、 C 、 C’ 、 D 、 D’ 就是满足要求的六个点。为了去掉分母，我们需要把它们的坐标都扩大到原来的 10 倍，于是得到一个答案：(±25, 0) 以及 (±7, ±24) 。<br>
事实上，我们<a href="http://www.matrix67.com/blog/archives/4018">有办法</a>构造出平面上任意多个点，使得它们两两之间距离都为整数，同时任意三点都不共线。</p></blockquote>
<p> <br>
 </p>
<blockquote><p>8. 给出 AB 、 BC 、 CD 、 DA 四条边的长度，以及 AB 和 CD 两边中点的连线长度，用尺规作图还原出四边形 ABCD 来。</p></blockquote>
<p> </p>
<blockquote><p>答案：让我们先来看一个简单的问题：已知三角形其中两边的长以及第三边上的中线，如何用尺规作图还原出这个三角形来？我们可以先倍长中线 AD 到 E ，容易看出 BE 和 AC 平行且相等。我们已经知道 AB 、 BE 和 AE 的长度（ AE 的长度就是两倍的 AD ），便能确定出三角形 ABE 来。然后，截取 AE 的一半 AD ，再把 BE 平移到 AC ，就得到要求的三角形 ABC 了。<br>
  <img alt="image placeholder" >
回到原问题。将 AB 的中点记为 E 。把 AD 和 BC 分别平移到 ED’ 和 EC’ 。于是， CC’ 和 DD’ 是平行且相等的（它们都平行且等于 AB 的一半），如果把 C’D’ 和 CD 的交点记作 F ，那么 △CC’F 和 △DD’F 是全等的， F 既是 CD 的中点，又是 C’D’ 的中点。由于我们知道 EC’ 、 EF 、 ED’ 的长度，用刚才的方法我们就能画出三角形 EC’D’ 了。<br>
  <img alt="image placeholder" >
现在，把 BC 平移到 AC” ，容易看出 △EC’D’ 和 △AC”D 是全等的，而 CC” 和 CD 的长度是已知的。这样一来，问题就解决了。把刚才画的三角形当作 △AC”D ，再以 C” 和 D 为圆心分别作圆，找出 C 点的位置。最后把 AC” 平移到 BC ，我们就作出了四边形 ABCD 的全部四个顶点。</p></blockquote>
<p> <br>
 </p>
<blockquote><p>9. 给定线段 AB ，再预先给定一条与 AB 平行的直线。只用直尺作图，将线段 AB 六等分。<br>
  <img alt="image placeholder" >
<p> </p>
<blockquote><p>答案：在平行线上任取 C 、 D 两点。我们可以用如下方法找出 CD 的中点：先在平面上取一个点 E ，然后依次作出 F 、 G 、 H 、 I 各点，那么 I 就是 CD 的中点。具体的证明可以参见<a href="http://www.matrix67.com/blog/archives/3513">这里</a>。<br>
  <img alt="image placeholder" >
现在，对 CD 上的每一个小线段继续平分下去，直到把 CD 分为八等分。用下图的方法把 AB 分为六等分。<br>
  <img alt="image placeholder" >
<p> <br>
 </p>
<blockquote><p>10. 给定正方形各边上的一个点。用尺规作图恢复出这个正方形来。</p></blockquote>
<p> </p>
<blockquote><p>答案：假设 A 、 B 、 C 、 D 依次是正方形四条边上的点。过 B 作 AC 的垂线，截取 BD’ = AC 。那么， D’ 也在正方形上， D 和 D’ 的连线就是正方形的其中一条边。剩下的事情就简单了。<br>
  <img alt="image placeholder" >
<p> <br>
 </p>
<blockquote><p>11. 两条水平线之间有一段严格单调递增的函数。函数上有一个动点 P 。过 P 点作一条竖直线，它与其他已有线条围成了两块阴影面积。当 P 运动到什么位置时，阴影面积之和最小？<br>
  <img alt="image placeholder" >
<p> </p>
<blockquote><p>答案：当 P 运动到两条水平线正中间（到两条水平线距离相等）时，阴影面积之和最小。此时，如果 P 往右移动，将导致下边面积增加的速度超过上边面积减少的速度；如果 P 往左移动，将导致上边面积增加的速度超过下边面积减少的速度。因此，这个 P 点就是答案。<br>
  <img alt="image placeholder" >
<p> </p>
			 ]]></content>
<pubDate>2011-10-12T16:30:49+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4649</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 无聊小制作：“数词+非数词+数词+非数词”的出现频数 ]]></title>
<link>http://www.matrix67.com/blog/archives/4675</link>
<content><![CDATA[ 
		<p>    昨天和同事聊到，汉语还真是奇怪，有“四分五裂”，有“五颜六色”，也有“七上八下”，但好像从没听说过六什么七什么的。于是想到，在汉语中，“数词 + 非数词 + 数词 + 非数词”的短语是怎样分布的呢？回到家后立即用 Mathematica 做了一个柱状图，绘出了九九八十一种数词短语模式在大规模真实语料中的出现频数。注意，这里统计的是总的出现频数，重复出现也会计算在内。另外，这是一个简单而机械的统计过程，因而 “三人一组”、“七天七夜”之类的非成语也被算了进来。</p>
<p>      <img alt="image placeholder" >
<p>    嗯，对，没有任何意义，纯属无聊之作。</p>
			 ]]></content>
<pubDate>2011-10-17T13:41:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4675</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：只允许加倍操作的水桶倒水问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/4690</link>
<content><![CDATA[ 
		<p>    今天的题目来自<a href="http://www.cs.cmu.edu/puzzle/puzzle5.html">这里</a>。有三个水桶，它们里面分别装了 a 升的水、 b 升的水和 c 升的水（其中 a 、 b 、 c 都是正整数，桶本身没有容量限制）。你可以把水从一个桶倒进另一个桶，但必须保证让后者的水量刚好变成原来的两倍。证明，不管 a 、 b 、 c 是多少，你总能让其中某一个水桶变空。</p>
<p>    例如，假设初始时 (a, b, c) = (3, 2, 1) ，那么你可以先把 (3, 2, 1) 变成 (1, 4, 1) ，再把它变成 (2, 4, 0) ，从而把第三个水桶变空。</p>
<p><span id="more-4690"></span><br>
    让我们先来看一个特殊的情形。假如只有两个水桶，并且其中一个水桶的水量为奇数，另一个水桶的水量为偶数。由于我们只有两个水桶，并且它们的水量也不相等，因此我们只有唯一一种可行的操作：拿起水多的桶，把水倒进水少的桶。注意，每次操作之后，两个桶里的水量仍然是一奇一偶，因此我们还能继续操作下去，永远不会“走死”。</p>
<p>    但是，两个桶里的水量只有有限种组合，因而如果我们一直这么走下去，最终必然会和原来的某个状态重合，从而产生循环。事实上，第一个重复的状态一定就是初始时的状态，而不会是半路中的某个状态；换句话说这个循环一定是一个完整的圈，而不是一个 ρ 字形的循环。这是因为，每一个状态都只能由唯一的“前继状态”变过来，即水量为偶数的那个桶其中一半的水在另一个桶中。</p>
<p>    这意味着，如果循环的长度是 n ，那么经过 n – 1 步移动之后，我们就能到达初始状态的前继。换句话说，假如 a 是一个偶数， b 是一个奇数，那么我们就有了一种把 (a, b) 变成 (a/2, b + a/2) 的方法。</p>
<p> <br>
    让我们来看看一些更复杂的情况。假如初始时三个桶的水量分别是奇、偶、偶，下面我们给出一种方法，它能增加“奇数桶”里的水量，同时保持另外两个桶里的水量仍是偶数。把三个桶里的水量分别记作 (a, b, c) ，其中 a 是奇数， b 和 c 都是偶数。如果 b 和 c 都不能被 4 整除的话，可以在它们俩之间倒一次水，让其中一个桶里的水量变成 4 的倍数（同时另一桶水的水量仍是偶数）。现在，无妨假设 b 的水量是 4 的倍数。我们把 (a, b) 变成它的前继，从而让三个桶里的水量分别变成 (a + b/2, b/2, c) 。这样一来，三个桶里的水量仍是奇、偶、偶，但“奇数桶”里的水量变多了。</p>
<p>    不断重复上述操作，让“奇数桶”里的水越来越多，同时保持另外两个桶的水量始终是偶数。最终，总有一个“偶数桶”会变空。因此，我们就解决了三个桶分别为奇、偶、偶的情况。</p>
<p> <br>
    其他情况呢？随便走一步，奇、奇、奇的情况立马就变成了奇、偶、偶，因此奇、奇、奇的情况也就解决了。现在，我们只剩下奇、奇、偶和偶、偶、偶的情况。在两个“奇数桶”之间倒水，可以把奇、奇、偶变成偶、偶、偶。而初始情况为偶、偶、偶，这意味着以后三个桶里的水量也永远都是偶数，因此我们可以把所有桶里的水量都除以 2 ，从而化为规模更小的情况。我们可以用这种方法不断减小问题的规模，直到把问题化为我们已解决的状态为止。至此，这个问题便彻底解决了。</p>
<p> <br>
    这是一个非常经典的题目了，它也出现在了趣题王 Peter Winkler 的 Mathematical Puzzles 一书中。在书里， Peter Winkler 指出，这道题出自第五届全苏数学奥林匹克竞赛中，随后又出现在了 1993 年的 Putnam 竞赛中。 Peter Winkler 还在书里提到了另一个答案，这是由 Svante Janson 首先给出的。</p>
<p> <br>
    为了解释清楚，还是让我用一个例子来说明吧。不妨假设这三个桶里的水量分别为 67 升、 10000 升和 12345 升。把三个桶按照水量从少到多排列，依次编号为 A 、 B 、 C 。下面我们给出一个过程，它能把 B 里的水变得比 A 更少。先计算 10000 除以 67 ，结果等于 149 余 17 。把 149 转换为二进制 10010101 。现在，从这个二进制数的最低位开始，从右往左依次查看各个数字：每读到一个 1 ，就把 B 倒进 A ；每读到一个 0 ，就把 C 倒进 A 。容易看出，最后 A 中的水量变成了原来的 2<sup>8</sup> = 256 倍，其中 B 贡献了 149 倍。因此， B 总共倒出了 149 × 67 升的水，因而 B 里面将会只剩下 17 升的水。由于 17 这个数字是 10000 除以 67 的余数，因此它是一个比 67 小的数。这意味着，我们有了一种刷新水量最小值的方法。不断执行这个过程，最终总能把其中一个桶里的水量变为 0 。</p>
<p>    且慢，我们还需要证明，为了完成上述过程， C 里面储备有足够多的水。这很容易看出来，因为在最坏情况下，二进制数恰好为 1000..00 ，但即使是这样， C 需要贡献的水量也不会比 B 更多。然而， C 本来拥有的水量是三个桶里最多的，因此我们永远不用担心 C 里的水不够。</p>
			 ]]></content>
<pubDate>2011-10-20T17:23:09+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4690</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ UyHiP趣题：按照盒子的三边长之和来计费有没有漏洞？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4698</link>
<content><![CDATA[ 
		<p>    今天的趣题来自 <a href="http://www.brand.site.co.il/riddles/201110q.html">UyHiP 今年十月的趣题</a>。</p>
<p>    许多快递公司都依据物件的长、宽、高三边之和来收费，一些航空公司也要求托运行李的三边长相加不能超过某个限制。那么是否有人想过，有没有可能把一个三边之和较大的盒子装进一个三边之和较小的盒子里，从而骗取更低的费用呢？有人会说，恐怕不行吧，长宽高之和更大的盒子体积不也应该更大一些吗？不见得。比方说，盒子 A 的长宽高分别是 10 、 10 、 10 ，盒子 B 的长宽高分别是 9 、 9 、 12.1 。盒子 B 的三边长之和显然比盒子 A 要大，但体积只有 980.1 ，比前者要小近 20 个单位。那么，为什么就不能把盒子 B 沿斜线方向塞进盒子 A 呢？有人会敏锐地发现，在上面的例子中，盒子 A 的体对角线长为 17.3205 ，但盒子B的对角线长度达到 17.5616 ，显然无法完全放进盒子 A 里。不过且慢，我也能举出这样的例子，三边和更大的盒子其体积和对角线都比小的盒子的要小。盒子 A 的长宽高分别为 10 、 10 、 20 ，盒子 B 的长宽高分别为 7.1 、 16.5 、 16.5 。盒子 B 的长宽高之和比盒子 A 大，体积为 1932.98 ，对角线长度比前者小大约 0.1 。看来，为了解决这个问题，我们还需要从一些更巧妙的方面入手。</p>
<p><span id="more-4698"></span><br>
    其实我偷了一个懒。这个 Blog 之前就<a href="http://www.matrix67.com/blog/archives/2374">曾经介绍过</a>这个有趣的数学问题，上面的文字直接取自那篇文章。不过，当时我们给出的解法来自 Peter Winkler ，是一个虽然巧妙但却并不那么美观的方法。 UyHiP 给出了一个基于线性代数的解答。这个解答不但更加漂亮，而且直接适用于任意维度的情况。下面我们来证明，在任意维度中，我们都无法把 n 边长之和更大的盒子放进 n 边长之和更小的盒子。</p>
<p>    令 d 是一个 n 维向量，向量中的 n 个正实数依次表示小盒子 n 个维度上的长度。假设我们现在要把它以一个很诡异的角度放进大盒子里。让我们用一个 n × n 的矩阵 A 来表示小盒子的放置角度，矩阵的每一行都是一个单位向量，依次表示小盒子各个维度上的边在大盒子中的方向。</p>
<p>    n 维盒子共有 2<sup>n</sup> 个顶点，每个顶点都有一个与之完全相对的顶点，因而整个小盒子中一共有 2<sup>n</sup> 条体对角线向量。这些体对角线向量是很容易求出来的，它们就是小盒子各个维度上的边的向量和，也就是 ± d<sub>1</sub>A<sub>1</sub> ± d<sub>2</sub>A<sub>2</sub> … ± d<sub>n</sub>A<sub>n</sub> 。如果考虑所有 2<sup>n</sup> 条体对角线向量，我们也就会取遍上式中所有可能的 2<sup>n</sup> 种正负号组合。大盒子第 i 个维度上的长度，必须大于等于所有可能的体对角线在第 i 个维度上的分量的最大值，也就是 d<sub>1</sub> · |A<sub>1i</sub>| + d<sub>2</sub> · |A<sub>2i</sub>| … + d<sub>n</sub> · |A<sub>ni</sub>| 。因此，大盒子所有维度上的长度之和，至少也就有</p>
<p>        d<sub>1</sub> · |A<sub>11</sub>| + d<sub>2</sub> · |A<sub>21</sub>| … + d<sub>n</sub> · |A<sub>n1</sub>|<br>
      + d<sub>1</sub> · |A<sub>12</sub>| + d<sub>2</sub> · |A<sub>22</sub>| … + d<sub>n</sub> · |A<sub>n2</sub>|<br>
      + d<sub>1</sub> · |A<sub>13</sub>| + d<sub>2</sub> · |A<sub>23</sub>| … + d<sub>n</sub> · |A<sub>n3</sub>|<br>
      + … …<br>
      + d<sub>1</sub> · |A<sub>1n</sub>| + d<sub>2</sub> · |A<sub>2n</sub>| … + d<sub>n</sub> · |A<sub>nn</sub>|</p>
<p>    换一种方式累加起来，也就是 d<sub>1</sub> · ∑<sub>i</sub> |A<sub>1i</sub>| + d<sub>2</sub> · ∑<sub>i</sub> |A<sub>2i</sub>| … + d<sub>n</sub> · ∑<sub>i</sub> |A<sub>ni</sub>| 。下面我们将证明，对于任意 r 都有 ∑<sub>i</sub> |A<sub>ri</sub>| ≥ 1 ，从而完成全部证明。</p>
<p>    注意到矩阵 A 是一个正交矩阵，它的每一行数的平方和都等于 1 。由于正交矩阵的转置仍然是正交矩阵，因此矩阵 A 的每一列数的平方和也都等于 1 。也就是说， ∑<sub>i</sub> A<sub>ri</sub><sup>2</sup> = 1 。然而 ( ∑<sub>i</sub> |A<sub>ri</sub>| )<sup>2</sup> = ∑<sub>i</sub> A<sub>ri</sub><sup>2</sup> + ∑<sub>i≠j</sub> ( |A<sub>ri</sub>| · |A<sub>rj</sub>| ) ≥ ∑<sub>i</sub> A<sub>ri</sub><sup>2</sup> = 1 ，也就说明 ∑<sub>i</sub> |A<sub>ri</sub>| 是大于等于 1 的。</p>
			 ]]></content>
<pubDate>2011-11-03T22:13:32+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4698</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 用抛物线筛选质数 ]]></title>
<link>http://www.matrix67.com/blog/archives/4713</link>
<content><![CDATA[ 
		<p>    今天见到一种看上去很帅的质数筛选法。在平面直角坐标系上画出抛物线 y = x<sup>2</sup> 的图像，然后标出抛物线上的所有格点（两坐标均为整数的点）。其中，只有点 (0, 0) 正好在 y 轴上，其余的点要么在 y 轴左侧，要么在 y 轴右侧。把 y 轴左侧除了 (-1, 1) 以外的所有格点与 y 轴右侧除了 (1, 1) 以外的所有格点相连，这些连线将自动避开 y 轴上纵坐标为质数的点。连接足够多的线条之后，质数就逐渐露了出来。</p>
<p>      <img alt="image placeholder" >
<p>    这是因为， (-a, a<sup>2</sup>) 和 (b, b<sup>2</sup>) 的连线将经过 (0, a · b) ，这可以通过计算斜率的方法得到验证。这个颇具创意的质数筛选法叫做 visual sieve ，它是由 Yuri Matiyasevich 和 Boris Stechkin 提出的。</p>
<p>查看更多：<br>
<a href="http://plus.maths.org/content/catching-primes">http://plus.maths.org/content/catching-primes</a><br>
<a href="http://www.mathteacherctk.com/blog/2011/10/the-parabolic-sieve-of-prime-numbers/">http://www.mathteacherctk.com/blog/2011/10/the-parabolic-sieve-of-prime-numbers/</a></p>
			 ]]></content>
<pubDate>2011-11-05T22:49:15+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4713</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：只用一把带有两条平行边的直尺作图 ]]></title>
<link>http://www.matrix67.com/blog/archives/4717</link>
<content><![CDATA[ 
		<p>    在下面的问题中，你不能使用圆规，只能使用直尺作图。不过，你的直尺拥有两条平行边，你可以在作图时同时使用它们。你需要充分利用直尺的这个特点，完成下面几个作图任务。</p>
<p>      1. 作出已知角的角平分线；<br>
      2. 作出已知线段的中点；<br>
      3. 作出已知圆的圆心；<br>
      4. 过已知点作已知直线的平行线。</p>
<p>    假设你的直尺是无限长的。直尺的宽度是固定不变的。直尺不能用来度量长度。</p>
<p><span id="more-4717"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    其实，满足要求的作图方案是很多的，下面只给出一种比较官方的解答。</p>
<p>    1. 作出 ∠ABC 的角平分线。</p>
<p>      <img alt="image placeholder" >
<p>    如图，我们利用尺子的宽度，把角的两边各自都向内平移一个相同的距离，交点 P 与顶点 B 的连线就是角平分线。</p>
<p> </p>
<p>    2. 找出已知线段 AB 的中点。</p>
<p>      <img alt="image placeholder" >
<p>    如果 AB 的距离大于尺子宽度的话，很好办，我们把尺子卡在两点之间，用两种不同的方法作出过这两点的平行线。两组平行线交于 C 、 D 两点。容易看出，四边形 ADBC 是一个菱形，那么 CD 和 AB 的交点 M 就是 AB 的中点。事实上，我们不但作出了 AB 的中点，还顺带作出了 AB 的垂直平分线（一会儿会用到）。</p>
<p>    但是，如果 AB 的距离小于尺子的宽度呢？</p>
<p>      <img alt="image placeholder" >
<p>    如图，借助尺子的宽，作出 AB 的一条平行线 l 。然后，找出距离 AB 足够近的一点 C ，使得 CA 与 l 的交点 A’ 以及 CB 与 l 的交点 B’ 这两个交点之间的距离超过尺子的宽度。然后，用刚才的方法找出 A’B’ 的中点 M’ ，连接 CM’ 与 AB 交于点 M ，M 就是 AB 的中点了。</p>
<p> </p>
<p>    3. 找出已知圆的中心。我们只需要随便选取两条弦，作出它们各自的垂直平分线，两条垂直平分线的交点就是圆的中心。关键在于，怎样做线段的垂直平分线呢？下面我们就来讨论作出已知线段 AB 的垂直平分线的方法。</p>
<p>      <img alt="image placeholder" >
<p>    当线段 AB 的长度大于尺子的宽度时，我们已经有办法作出它的垂直平分线了。如果线段 AB 的长度小于尺子的宽度，那么我们先作出 AB 的中点 M ，然后过 M 任意作一条直线。接着，借助尺子的宽度，把这条直线向左和向右平移相同的距离，与 AB 所在直线交于 A’ 和 B’ 。那么，A’B’ 的距离就超过了尺子的宽度。作出 A’B’ 的垂直平分线，它也就是 AB 的垂直平分线了。</p>
<p> </p>
<p>    4. 已知直线 l 和直线外一点 P ，过点 P 作出 l 的平行线。</p>
<p>      <img alt="image placeholder" >
<p>    我们先在直线 l 上任取一点 Q ，连接 PQ ，并找出 PQ 的中点 M 。然后，借助尺子的宽度，把 PQ 向左和向右平移相同的距离。假设 PQ 左边的平行线与 l 交于点 A ，连接并延长 AM ，与 PQ 右边的平行线交于点 N 。那么 PN 就是 l 的一条平行线。</p>
<p> <br>
    这个有趣的问题来自 1967 年 IMO 候选题。</p>
			 ]]></content>
<pubDate>2011-11-06T09:08:06+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4717</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 如果对Heron公式求导的话 ]]></title>
<link>http://www.matrix67.com/blog/archives/4722</link>
<content><![CDATA[ 
		<p>    Heron 公式是一个已知三角形三边长便能直接求出其面积的经典公式。把三角形的三边长分别记作 a 、 b 、 c ，令三角形的半周长 p = (a + b + c) / 2 ，则三角形的面积可以用 Heron 公式 S = √<span style="text-decoration:overline">p(p – a)(p – b)(p – c)</span> 求出。如果把 p = (a + b + c) / 2 代入式子，得到的公式其实也挺对称的： S = √<span style="text-decoration:overline">(a + b + c)(a + b – c)(a – b + c)(- a + b + c)</span> / 4 。</p>
<p>    现在，我们把这个公式看作是一个关于 c 的函数： f(c) = √<span style="text-decoration:overline">(a + b + c)(a + b – c)(a – b + c)(- a + b + c)</span> / 4 。它的导数是多少？</p>
<p>    注意到，利用平方差公式，根号内的式子可以进一步整理为 ((a + b)<sup>2</sup> – c<sup>2</sup>)(c<sup>2</sup> – (a – b)<sup>2</sup>) ，它的导数是 – 2c(c<sup>2</sup> – (a – b)<sup>2</sup>) + 2c((a + b)<sup>2</sup> – c<sup>2</sup>) = 4c(a<sup>2</sup> + b<sup>2</sup> – c<sup>2</sup>) 。因而，整个原函数的导数就是 c(a<sup>2</sup> + b<sup>2</sup> – c<sup>2</sup>) / (2 · √<span style="text-decoration:overline">(a + b + c)(a + b – c)(a – b + c)(- a + b + c)</span> ) 。</p>
<p>      <img alt="image placeholder" >
<p>    有趣的是，当 a 、 b 、 c 满足勾股定理的关系 a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup> 时，导数值正好为 0 。这是为什么？ Heron 公式的导数的零点和勾股定理有什么联系呢？</p>
<p><span id="more-4722"></span><br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>      <img alt="image placeholder" >
<p>    假设一个三角形其中两边的长度已经固定，分别为 a 和 b 。但是，这个三角形的第三条边 c 是不确定的，因此整个三角形是活动的，三角形的面积也就成了一个关于 c 的函数 f(c) 。其中， c 的取值范围是从 |a – b| 到 a + b ，同时函数值从 0 开始逐渐增大，最后又变回 0 。而 f'(c) = 0 则给出了三角形面积达到极大时的情形。什么时候三角形的面积达到极大呢？</p>
<p>      <img alt="image placeholder" >
<p>    如图，我们把 b 水平放置，并考虑 a 绕着它们的公共端点转动。显然，当 a 、 b 成直角时，三角形的高 h 最大，因而整个面积达到极大，此时 a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup> ，这正是 f'(c) = 0 的一个解。</p>
<p>    真正神奇的是，我们完全有可能用这种方法，反过来去证明勾股定理！与此有关的详细讨论，可以参见 <a href="http://www.cut-the-knot.org/pythagoras/HeronsDerivative.shtml">http://www.cut-the-knot.org/pythagoras/HeronsDerivative.shtml</a></p>
			 ]]></content>
<pubDate>2011-11-08T22:43:29+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4722</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：能否在平面上写下不可数个不相交的Y？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4731</link>
<content><![CDATA[ 
		<p>    <a href="http://www.matrix67.com/blog/archives/3243">这篇文章</a>收录了 Which Way Did the Bicycle Go 趣题集中一个非常有趣的问题：是否有可能在平面上画不可数个不相交的 8 ？答案是否定的。证明方法非常简单。对于任意一个 8 字形，在两个洞里各取一个有理点 P 、 Q （由于平面上的有理点是稠密的，这是总能办到的），则称这个 8 字形圈住了有理点对 (P, Q) 。注意到由于 8 字形不能相交，因此两个 8 字形不可能圈住同一对有理点。由于平面上的有理点对是可数的，因此 8 字形的数量也是可数的。</p>
<p>      <img alt="image placeholder" >
<p>    注意到，平面上显然能够容下不可数个不相交的直线段，也显然能够容下不可数个不相交的圆（比方说一系列同心圆）。在 Mathematical Puzzles 一书里， Peter Winkler 提出了这样一个问题：我们能在平面上写下不可数个不相交的字母 Y 吗？</p>
<p>      <img alt="image placeholder" >
<p><span id="more-4731"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    答案是否定的。下面有一个漂亮的证明，这是由 Randy Dougherty 给出的。让我们先来看一个经典结论：假设平面上有三个红点和三个蓝点，那么我们绝不可能用线条把每一个红点和每一个蓝点都连起来，并且保证这 9 根线条互不相交（即使线条可以弯曲也不行，不信的话你可以试一试）。从图论的角度来说，就是完全二分图 K<sub>3,3</sub> 不是一个平面图。利用 Euler 公式我们可以很快证明这一点：把一个平面图的顶点数、边数和区域数（包括最外面那个无限大的区域）分别记为 V 、 E 、 F ，则 Euler 公式告诉我们 F = E – V + 2 。由于每条边都同属于两个区域，因而所有区域的平均边数为 2E / F 。在完全二分图 K<sub>3,3</sub> 中有 6 个顶点和 9 条边，若它是一个平面图，则它应该有 9 – 6 + 2 = 5 个区域，于是每个区域平均拥有 18/5 条边。这说明该图中至少存在一个边数小于 4 的区域，但对于一个二分图来说这是不可能的。</p>
<p>    我们把一个 Y 看作是由一个中心点、三个手臂和三个端点构成的。现在，对于平面上的每一个 Y ，我们都给它画出三个有理圆（圆心的两坐标和半径的长度都是有理数），让每个圆都圈住 Y 的其中一个端点，并且不包含 Y 的另外两臂。注意到，平面上的有理点是稠密的，半径的长度也可以任意小，因此这总是能办到的。不过，这些有理圆完全有可能和别的 Y 相交，也有可能和别的有理圆相交。我们甚至不能排除这样的情况：其中一个 Y 的某个有理圆和另一个 Y 的某个有理圆是同一个有理圆！不过，下面我们会给大家证明，三个不相交的 Y 绝不可能拥有同一组有理圆。</p>
<p>      <img alt="image placeholder" >
<p>    如图，假设三个 Y 对应了同一组圆。我们修改每一个 Y 的每一条臂，让它在碰到有理圆后直接连接到这个圆的圆心。现在，把三个圆心染成红色，把三个 Y 的中心点染成蓝色，则这 9 条（修改后的）手臂就连接了所有可能的红蓝点对。然而，前面我们已经说过， K<sub>3,3</sub> 不可能是一个平面图。因此，这三个 Y 必然会相交。</p>
<p>    由于平面上的有理圆是可数的，因而平面上不相交的 Y 也必然是可数的。</p>
<p> <br>
    值得一提的是，我们这里证明的是一个相当强的结论：对于所有含有交叉点或者分岔点的图形，它在平面上都只能画出可数个（如果不允许相交的话）。这不但可以直接推出平面上不相交的 8 字形是可数的，事实上不相交的 4 或者 6 或者 9 也都只能是可数的。</p>
			 ]]></content>
<pubDate>2011-11-09T13:26:21+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4731</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 用生命游戏来模拟生命游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/4742</link>
<content><![CDATA[ 
		<p>    这是我前几天看到的一个视频。毫无疑问，它是我所见过的各种<a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">生命游戏</a>构造中最神奇的一个：</p>
<p>      <embed src="http://www.tudou.com/v/ntkMWuBZKO0/&amp;rpid=46416124/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="600" height="400"></embed></p>
<p>    在 LifeWiki 中有一个<a href="http://www.conwaylife.com/wiki/OTCA_metapixel">词条</a>详细介绍了这个构造：它叫做 OTCA metapixel ，是由 Brice Due 在 2005 至 2006 年间构造的。其中，每一个 metapixel 的大小为 2048 × 2048 ，周期为 35328 。</p>
<p> <br>
视频出处：<a href="http://www.youtube.com/watch?v=QtJ77qsLrpw">http://www.youtube.com/watch?v=QtJ77qsLrpw</a><br>
查看更多：<a href="http://www.reddit.com/r/math/comments/lutec/l_i_f_e_c_e_p_t_i_o_n_or_how_to_simulate_the/">http://www.reddit.com/r/math/comments/lutec/l_i_f_e_c_e_p_t_i_o_n_or_how_to_simulate_the/</a><br>
如果你喜欢生命游戏，不要错过之前我们介绍过的史上最大的生命游戏构造—— <a href="http://www.matrix67.com/blog/archives/1270">Caterpillar 飞船</a></p>
			 ]]></content>
<pubDate>2011-11-14T18:12:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4742</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：所有人手上的糖数最终会变得一样多 ]]></title>
<link>http://www.matrix67.com/blog/archives/4746</link>
<content><![CDATA[ 
		<p>    n 个小朋友在圆桌上坐成一圈。初始时，每个小朋友都拥有一定数量的糖。接下来，反复进行下面两个操作：</p>
<p>      1. 如果有人手里的糖数是奇数，就向老师再要一颗糖，把手里的糖数补成偶数；<br>
      2. 每个人都把自己手中一半的糖传给他右边的人（同时接到从左边传过来的糖）。</p>
<p>    证明：总有一个时刻，所有小朋友手中都会拥有相同数量的糖。<br>
    附加题：这是一个非常经典的问题。猜猜看我最早在什么地方看到的这个问题？</p>
<p><span id="more-4746"></span><br>
 <br>
 <br>
 <br>
 </p>
<p>    我很小很小的时候，就在《十万个为什么》的数学分册 1 上读到了这个问题。在我看过的所有书里，这本书恐怕是历史最悠久，被我翻得最烂，对我意义最大的书了。我甚至还记得书里那篇文章的标题——《怎样调整，使大家的糖一样多》。不过，让人哭笑不得的是，文章中用大量篇幅演示了结论的意思，最终却并没有给出一个证明。于是，究竟该怎样证明这个结论，便成了一桩“悬案”。今天在<a href="http://www.cs.cmu.edu/puzzle/puzzle6.html">这里</a>看到这个问题的证明时，实在是有些激动，毫不犹豫地把它记了下来。</p>
<p>    在第一次传糖之前，每个人手里的糖数都会被补成偶数。因此，我们可以直接假设初始时所有人手里的糖数都是偶数。把所有人手中的糖数的最大值记作 M 。下面，让我们考虑任意一个小朋友，假设他手中的糖数为 a ，他左边的人手中的糖数为 a’ 。第一次传糖之后，这个人手里的糖数就变成了 (a + a’) / 2 。由于 a 和 a’ 都不超过 M ，因而要么 (a + a’) / 2 正好等于 M （但由于 M 是偶数，因此他不能再向老师要糖了），要么 (a + a’) / 2 将会严格小于 M （即使之后再向老师要一颗糖，最多也只能刚好达到 M ）。因此，在第二次传糖之前，每个人手中的糖数仍然都不超过 M 。由此可见，不断继续下去，今后任何人在任何时刻手中的糖数都不会超过 M 。</p>
<p>    这表明，所有人的糖数之和有一个上限。因此，小朋友们手中的总糖数不会无限制地增加，总有一个时候，所有人都不再得到新的糖了，整个过程只剩下 n 个数值间简单的迭代。接下来，神奇的一步出现了。让我们考虑在此之后，每一次传糖将导致所有人的糖数的平方和会如何变化：</p>
<p>      <img alt="image placeholder" >
<p>    这说明，如果小朋友们手上的糖数不全相等的话，糖数的平方和将会严格地减少。但是，这个平方和显然不会无限地减少，总会有一个时候，平方和不再变化。此时，小朋友们手上的糖数就都相等了。</p>
			 ]]></content>
<pubDate>2011-11-15T23:26:50+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4746</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：选出最多的大小为奇数的子集，使得两两的交集大小都是偶数 ]]></title>
<link>http://www.matrix67.com/blog/archives/4750</link>
<content><![CDATA[ 
		<p>    在集合 {1, 2, …, n} 中选出尽可能多的子集，使得每个子集所含的元素个数都是奇数，但是任意两个子集的交集都含有偶数个元素。那么，我们最多能够选出多少个这样的子集来？</p>
<p>    容易看出，我们至少可以选出 n 个子集。例如，当 n = 4 时， {1} 、 {2} 、 {3} 、 {4} 就满足要求。我们还能选出更多的子集来吗？简单地尝试后，你会觉得似乎不行。不过，这却并不是显然的，因为存在一些不那么平凡的方案，也能让子集的数量达到 n ，例如 {1, 2, 3} 、 {1, 2, 4} 、 {1, 3, 4} 、 {2, 3, 4} 这 4 个子集也是满足要求的。看来，证明最多只能选出 n 个子集，好像并不那么容易。</p>
<p><span id="more-4750"></span><br>
    不过，借助线性代数，我们有一个几乎是秒杀的证明方法。假如说我们可以从集合 {1, 2, …, n} 中选出 m 个满足要求的子集，并且用 m 个 n 维 01 向量 v<sub>1</sub>, v<sub>2</sub>, …, v<sub>m</sub> 分别表示这 m 个子集。例如，当 n = 4 时，子集 {1, 2, 4} 就表示成向量 (1, 1, 0, 1) 。我们用 v<sup>T</sup> 来表示矩阵的转置。注意到， v<sub>i</sub><sup>T</sup> · v<sub>j</sub> 正好等于这两个向量所对应的子集的交集的元素个数。根据要求，这些向量必须满足，对于任意一个 i ，v<sub>i</sub><sup>T</sup> · v<sub>i</sub> 都是奇数，而对于任意两个不同的 i 和 j ， v<sub>i</sub><sup>T</sup> · v<sub>j</sub> 都是偶数。下面，我们证明这 m 个向量在模 2 的有限域 F<sub>2</sub> 上是线性无关的，从而说明 m 一定小于等于 n 。</p>
<p>    只需要注意到，如果存在一组数 a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub> 使得</p>
<p>      a<sub>1</sub> v<sub>1</sub> + a<sub>2</sub> v<sub>2</sub> + … + a<sub>n</sub> v<sub>n</sub> = 0</p>
<p>    那么对于任意一个 i ，都有</p>
<p>      0 = (a<sub>1</sub> v<sub>1</sub> + a<sub>2</sub> v<sub>2</sub> + … + a<sub>i</sub> v<sub>i</sub> + … + a<sub>n</sub> v<sub>n</sub>)<sup>T</sup> v<sub>i</sub><br>
        = a<sub>1</sub> v<sub>1</sub><sup>T</sup> v<sub>i</sub> + a<sub>2</sub> v<sub>2</sub><sup>T</sup> v<sub>i</sub> + … + a<sub>i</sub> v<sub>i</sub><sup>T</sup> v<sub>i</sub> + … + a<sub>n</sub> v<sub>n</sub><sup>T</sup> v<sub>i</sub><br>
        = a<sub>i</sub></p>
<p>    因此，这 m 个向量是线性无关的。</p>
<p> <br>
题目来源：<a href="http://mathoverflow.net/questions/33911/why-linear-algebra-is-funor">http://mathoverflow.net/questions/33911/why-linear-algebra-is-funor</a><br>
一个非常类似的问题：<a href="http://www.matrix67.com/blog/archives/1900">选取最多的子集使得任两子集恰有一个公共元素</a><br>
更多线性代数的妙用：<a href="http://www.matrix67.com/blog/archives/998">一个图论问题</a>、<a href="http://www.matrix67.com/blog/archives/4318">一个不动点数量问题</a>、<a href="http://www.matrix67.com/blog/archives/4698">盒子的三边和问题</a></p>
			 ]]></content>
<pubDate>2011-11-16T13:11:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4750</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 如此保证选举公正性能成吗？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4756</link>
<content><![CDATA[ 
		<p>    一个小镇上即将进行大选，候选人有 m ≥ 3 个，选民一共有 n 人。选举时，每个选民在选票上写下一个候选人的名字，然后由计算机根据某种选举机制算出大选的获胜者来。如果把 n 个选民的选票依次记为 x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub> 的话，那么选举机制的算法其实就是一个映射到 {1, 2, …, m} 的函数 f(x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>) 。</p>
<p>    为了保证选举程序的公平性，让每个人手中的选票都能发挥作用，政府提出了“差异性原则”：如果每个人的选票都变了，那么竞选的获胜者也应当改变。也就是说，如果对于所有的 i 都有 x<sub>i</sub> ≠ y<sub>i</sub> ，那么必有 f(x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>) ≠ f(y<sub>1</sub>, y<sub>2</sub>, …, y<sub>n</sub>) 。选票系统的算法虽然不是透明的，但政府保证，这个算法满足差异性原则。</p>
<p>    差异性原则真的能够保证，每个选民的选票都有足够的权力吗？不是。差异性原则看似很强，但实际情况则是，它不但不能保证每张选票都能影响选举结果，甚至还无法避免有选民独裁选举结果的现象发生。更不可思议的是，事实上独裁现象是必然会发生的——独裁是差异性原则的必然推论！下面我们将证明，对于任意一种满足差异性原则的选票算法，我们都能找到这样一个选民，他的选票独裁了选举结果，获胜者是谁完全由他的选票决定，与其他人的选票无关。</p>
<p><span id="more-4756"></span><br>
    为了便于叙述，我们假设有 6 个选民，有 4 个候选人。因此，选票算法相当于是一个把所有仅由数字 1 到 4 组成的全部 4<sup>6</sup> 个 6 位数映射到 {1, 2, 3, 4} 的一个函数。我们不妨把这些 6 位数看作是由所有可能的前 5 位数加上最后一位数得来的。</p>
<p>    让我们先来考虑这样一种情形：在所有可能的前 5 位数中，存在一个 5 位数，它后面加上 1 、 2 、 3 、 4 后所对应的获胜者各不相同。不妨假设这个前 5 位数是 14232 吧。也就是说，当 i 取 1 到 4 时， 14232i 正好对应了所有可能的获胜者。下面，我们任意选取另外一个 5 位数组合 x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub> ， 使得它的每一位数字正好都和 14232 上对应位置的数字不同。考虑 x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub>1 所对应的获胜者，它必然和 142321 、 142322 、 142323 、 142324 之一相同；但根据差异性原则，它和 142322 、 142323 、 142324 都不同，因而只可能是和 142321 相同。同理， x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub>2 所对应的获胜者也就和 142322 相同，事实上对于每个 i ， x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub>i 所对应的获胜者与 14232i 都完全一致。</p>
<p>    我们还可以继续推出，事实上，对于任意的前 5 位数组合 y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub> 都有，对于每个 i ， y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub>i 所对应的获胜者都与 14232i 完全一致。为了看出这一点，我们只需要精心选取一个适当的前 5 位数 x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub> ，使得它和 14232 、 y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub> 对应位置上的数字都不相同。由前面的推理， x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub>i 所对应的获胜者已经与 14232i 一致了，根据同样的道理，y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub>i 所对应的获胜者又依次与 x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub>i 相同，如此一“传递”便证明了任意 5 位数 y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub> 都与 14232 拥有完全相同的效力。</p>
<p>    也就是说，选举结果与前 5 个人的选票无关，完全被最后一个人的选票独裁了。</p>
<p> <br>
    接下来，我们来考虑另一种情形：对于所有可能的前 5 位数 x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub> ，当 i 从 1 取到 4 时，在 x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub>i 当中都至少有两个相同的获胜者。下面，我们任选一个前 5 位数组合，比方说 12314 吧，然后给前 5 个人定义 4 个新的选票算法 g<sub>k</sub> （这里 k 可以取 1 、 2 、 3 、 4 中的任意一个）：当 y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub> ≠ 12314 时， g<sub>k</sub>(y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub>) 就等于  y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub>i 当中重复出现的那个获胜者；当 y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub> = 12314 时，就让 g<sub>k</sub>(y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub>) 等于 y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>y<sub>4</sub>y<sub>5</sub>k 所对应的获胜者。注意到，每一个选票算法 g<sub>k</sub> 同样满足差异性原则。这是因为，任取每位数字都不相同的两组选票 a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>a<sub>4</sub>a<sub>5</sub> 和 b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub> ，我们可以假设 a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>a<sub>4</sub>a<sub>5</sub> 在 g<sub>k</sub> 中所对应的获胜者也就是原来的选票算法中 a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>a<sub>4</sub>a<sub>5</sub>m 所对应的获胜者（即使 a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>a<sub>4</sub>a<sub>5</sub> 恰好等于 12314 ），其中 m 是某个 1 到 4 之间的数。那么， b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub> 就不可能再等于 12314 了，因而，一定存在某个 p 和 q ，使得 b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub> 在 g<sub>k</sub> 中对应的获胜者和原选票算法中的 b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub>p 、 b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub>q 都相等。其中， p 和 q 必有一个与 m 不同，比如说 p 吧。那么在原选票算法中，由差异性原则， b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub>p 和 a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>a<sub>4</sub>a<sub>5</sub>m 对应了不同的获胜者。因而在 g<sub>k</sub> 中， b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub> 和 a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>a<sub>4</sub>a<sub>5</sub> 也对应了不同的获胜者。</p>
<p>    但是 g<sub>1</sub> 、 g<sub>2</sub> 、 g<sub>3</sub> 、 g<sub>4</sub> 这四个选票算法其实只有一个差别： 12314 所对应的获胜者不同。两个满足差异性原则的选票算法怎么可能只在一处有不同呢？ 12314 和 23421 、 34132 、 41243 两两之间都构成了完全差异的情况，根据差异性原则，它们正好对应了 4 个不同的获胜者；如果后面三种情况对应的获胜者都不变， 12314 所对应的获胜者自然也没有别的选择。因此，两个选票算法绝不可能只在一处有区别。这说明，事实上 g<sub>1</sub> 、 g<sub>2</sub> 、 g<sub>3</sub> 、 g<sub>4</sub> 这四个选票算法是完全相同的，它们其实都把 12314 映射到了相同的获胜者身上。回顾 g<sub>k</sub> 的定义，我们立即发现，当 i 从 1 取到 4 时， 12314i 所对应的获胜者是相同的。</p>
<p>    根据同样的道理，把 12314 换作任意一个 5 位数组合 z<sub>1</sub>z<sub>2</sub>z<sub>3</sub>z<sub>4</sub>z<sub>5</sub> ， 那么 z<sub>1</sub>z<sub>2</sub>z<sub>3</sub>z<sub>4</sub>z<sub>5</sub>i 都对应着相同的获胜者。这说明，事实上最后一张选票没有任何权力，获胜者完全由前 5 张选票决定，不随最后一张选票的改变而改变。于是，我们可以无视最后一张选票，递归地对前 5 张选票继续分析，直到发现独裁者为止。至此，我们便完成了整个证明。</p>
<p> <br>
    不过话说回来，文章开头提到的“差异性原则”，其实是明显不合理的——谁说每个人的选票都变了，结果就一定要变的？这个条件太不自然，当然会造成一些诡异的结果。相比之下， <a href="http://www.matrix67.com/blog/archives/4279">Arrow 不可能性定理</a>则更加令人震撼，在“全体一致性”和“无关候选人独立性”这两个看上去更加自然的条件下，独裁仍然是一个必然推论。因此，最后还是那句颇有些耸人听闻的话：独裁是唯一完美的选举制度。</p>
<p> <br>
题目来源：<a href="http://www.cs.cmu.edu/puzzle/puzzle13.html">http://www.cs.cmu.edu/puzzle/puzzle13.html</a><br>
原题答案的叙述方式很怪异，我看了很久才看明白。<br>
复述时做了大量改动，若有疏忽请大家及时指正。</p>
			 ]]></content>
<pubDate>2011-11-23T17:16:11+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4756</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 汉字地图第二版 ]]></title>
<link>http://www.matrix67.com/blog/archives/4769</link>
<content><![CDATA[ 
		<p>    去年年初的时候，我曾经发布过某专业课期末作业研究过程中带来的一个有趣的副产品：<a href="http://www.matrix67.com/blog/archives/2728">汉字的字义网络图</a>。不过，当时我是直接调用的 Mathematica 的相关函数，函数几乎不能调整参数，并且也无法处理边上权重不同的情况。最近在研究<a href="http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing)">引力斥力绘图算法</a>，突然想到把当时的数据重新画一张图。于是就有了汉字地图第二版（点击小图看大图）：</p>
<p>   <a href="http://www.matrix67.com/blogimage_2011/201111262.png"><img alt="image placeholder" >
<p><span id="more-4769"></span><br>
    还是简述一下整个图的制作方法吧。我们的基本依据就是，在全唐诗中，经常对偶的字往往都有非常密切的关系。于是，我们首先找出全唐诗中的对偶字：</p>
<p>      1. 从全唐诗中提取所有处于对偶位置的字对（不管这些字对实际上是否是对偶的）；<br>
      2. 利用 <a href="http://www.matrix67.com/blog/archives/439">Bayesian 评分系统</a> 给字对的对偶程度评分；<br>
      3. 选出对偶评分最高的 8000 个字对；<br>
      4. 随机指定所有涉及到的字在图中的初始位置。</p>
<p>    现在，假设每两个字之间都有斥力，这些斥力大小都符合 Coulomb 定律，即斥力大小与距离的平方成反比。另外，再假设那 8000 个字对之间都有一根橡皮筋，它所带来的引力大小符合 Hooke 定律，其中字对的对偶评分越高，橡皮筋的倔强系数越大（或者说橡皮筋越强劲）。现在，假设把整个系统往桌面上一放，这些字就会在引力斥力的作用下弹过去弹过来，静止时应该就有很好的聚类效果了。不过这里有一个问题——谁说这个系统最终一定会静止下来？考虑两个点和一根橡皮筋的情况，它们最终会吸引、排斥、吸引、排斥，做出重复性的周期运动，毕竟机械能守恒嘛。那为什么在实际情况下，这个系统会静止下来呢？原因很简单，因为在实际情况下，系统会有能量损耗（比如摩擦力）。因此，我们必须假设系统每时每刻都有一定比例的能量损耗，具体落实下来，便是给每个字的实际运动速度强制性地打折扣。这样，这些字的位置最终才能收敛起来。下面，我们需要模拟这个物理过程。</p>
<p>      5. 按照 0.01 个单位时间的间隔迭代 1000 次，不断更新每个字的受力、速度和位置；<br>
      6. 按照计算出来的结果绘图，并在 8000 个字对之间连线，连线颜色越深表示对偶评分越高。</p>
<p>    其中，前面 3 步是用 Mathematica 实现的，与物理模拟有关的步骤是用 Python 实现的（ Mathematica 太慢了），最后的绘图工作又重新交给了 Mathematica 。这个绘图算法的缺点就是运行效率太低，即使使用 Python ，迭代 1000 次也需要用大概一整夜的时间。我试了一些不同的参数（每跑一次都需要一整夜的时间），在第三次得到了比较令人满意的结果。其实和当初直接用 Mathematica 生成的结果相比，也好不到哪里去，不过我还是挺高兴的。首先，图上用不同的颜色表现出了不同权重的边，看起来更好看了。另外，整个过程更加透明，我也更加心安一些。当然，值得改进的地方还挺多的，不知道各位朋友有什么好的想法没。</p>
<p>    哦，对了，赶在 11 月 26 日结束之前赶快发布。今天是 <a href="http://localhost-8080.com/2011/11/page-25/">localhost_8080</a> 的生日，在这里祝她生日快乐。</p>
			 ]]></content>
<pubDate>2011-11-26T21:13:15+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4769</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：不断把凹的部分翻出来，总能把凹多边形变凸吗？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4780</link>
<content><![CDATA[ 
		<p>      <img alt="image placeholder" >
<p>    左图是一个凹多边形，而且凹得相当厉害。作为一个完美主义者，我很难容忍这么一个图形，总想着要把凹进去的部分翻出来，把它还原为一个凸多边形。不幸的是，翻折之后的结果仍然不是凸多边形，图中又产生了新的凹陷。于是，我们想继续把凹进去的部分往外翻，直到整个图形变成凸多边形为止。问题是，这个过程有完吗？换句话说，我们一定能通过有限多步翻折，把凹多边形变成凸的吗？</p>
<p>    这个问题有着非常纠结复杂的历史。这个问题最早可能是由数学家 Paul Erdős 正式提出的。 1935 年，他在 American Mathematical Monthly 上猜想，经过有限步翻折之后，凹多边形一定能变凸。 1939 年， Béla Szőkefalvi-Nagy 给出了一个证明。因此，这个结论又叫做 Erdős-Nagy 定理。有趣的是，这个问题是如此的自然，以至于在此之后，又有一大堆人重新提出并研究了这个问题，而且他们明显并不知道相互之间的已有研究。这事儿给我们带来的好处就是，我们有了 Erdős-Nagy 定理的好几种截然不同的证明方法。不过，这些证明或者太长，或者太高深，或者又有些漏洞。 1999 年， Godfried Toussaint 从这些证明中取长补短，给出了一个比较初等的证明。</p>
<p><span id="more-4780"></span><br>
      <img alt="image placeholder" >
<p>    在下面的讨论中，我们可能会遇到上图所示的情况：某次翻折之后，三个相邻顶点正好共线，构成了一整条长边。那么，今后中间的那个点将永远位于这条边上，因此我们可以放心地把它从顶点集里去掉。于是，我们可以默认，下面讨论的所有多边形，边上都不会有“废”的顶点。</p>
<p>    让我们先来看一个引理：任意给定一个凸多边形后，我们总能找到一个 ε ，使得只要该凸多边形的每一个顶点都移动了不超过 ε 的距离，得到的新多边形仍然是凸的。</p>
<p>      <img alt="image placeholder" >
<p>    让我们考虑凸多边形上的某个顶点 V<sub>i</sub> ，以及它的两个相邻顶点 V<sub>i-1</sub> 和 V<sub>i+1</sub> 。把 V<sub>i-1</sub>V<sub>i</sub> 的中点和 V<sub>i</sub>V<sub>i+1</sub> 的中点的连线记为 l 。于是， V<sub>i</sub> 、 V<sub>i-1</sub> 、 V<sub>i+1</sub> 这三个顶点到 l 的距离都是相等的。让我们把这个距离值为 r 。现在，以 r 为半径，分别以这三个顶点为圆心作圆，那么，只要每个顶点都在各自的圆内移动，这些顶点与直线 l 的相对位置都保持不变， V<sub>i-1</sub> 和 V<sub>i+1</sub> 仍然在 l 的同侧， V<sub>i</sub> 仍然在 l 的另一侧。也就是说，整个多边形在 V<sub>i</sub> 这个点仍然是凸的。注意到，对于每个不同的顶点 V<sub>i</sub> ，我们都能找到这么一个合适的 r 。取所有这些 r 当中的最小值，它就是一个满足要求的 ε 。</p>
<p>    下面我们开始证明，对于任意的一个凹多边形，经过有限次的翻折后，最后总能变成一个凸多边形。</p>
<p>      <img alt="image placeholder" >
<p>    首先，让我们考虑初始时多边形内的任意一点 X ，以及多边形上的任意一个顶点 Y 。今后，这个 Y 点的位置将不时发生变化。我们把第 i 次翻折之后 Y 点的位置记作 Y<sup>(i)</sup> 。注意到，由于每次翻折之后，新的凸多边形都完全覆盖了原来的凸多边形，因此 X 将永远留在凸多边形的内部。现在我们来考虑每一次翻折对 X 和 Y 之间的距离将带来怎样的影响，在第 i 次翻折之前， X 和 Y<sup>(i-1)</sup> 都在翻折的折痕同侧，在第 i 次翻折之后， Y 点要么根本没动，要么被对称地翻折到了折痕的另一侧。在前一种情况下， X 到 Y 的距离并没有变；在后一种情况下，假设 X 和 Y<sup>(i)</sup> 的连线与折痕交于点 K ，则 XY<sup>(i)</sup> = XK + KY<sup>(i)</sup> = XK + KY<sup>(i-1)</sup> &gt; XY<sup>(i-1)</sup> ，可见 X 到 Y 的距离严格地增加了。</p>
<p>      <img alt="image placeholder" >
<p>    但是，多边形的翻折操作不会改变整个多边形的周长，因此 X 到 Y 的距离有一个上限：它最多等于整个多边形周长的一半（类似于上图的极端情况）。这表明， XY<sup>(1)</sup>, XY<sup>(2)</sup>, XY<sup>(3)</sup> … 的长度构成了一个有上界的不下降序列，因而这个序列有一个极限。也就是说，最终 Y 点到 X 点的距离会慢慢固定下来。注意到，由于 X 的任意性，因而我们实际上说明了，随着翻折次数的增加， Y 点到初始多边形内的任意一点的距离都会固定下来，因此事实上， Y 点存在一个极限位置。根据同样的道理，多边形的所有顶点都将慢慢趋近于它们各自的极限位置，因此整个多边形也就存在一个极限。显然，这个极限多边形一定是凸的，否则它还能再翻折，与它是一个极限相矛盾。</p>
<p>    别忘了我们之前的引理：我们总能够找到一个 ε ，使得极限多边形的每个顶点都移动不超过 ε 的距离之后仍然能保持凸性。现在，在极限多边形的每个顶点周围都画上一个半径为 ε 的圆盘。对于初始多边形的每一个顶点，它最终都会收敛到它的极限位置，因而在有限步翻折之后，它必然会踏入它所对应的圆盘。因此，我们只需要等待有限步翻折，所有的点都会踏入各自的圆盘。此时，我们便得到了一个凸多边形。</p>
<p>    这个证明很有意思：结论本身是离散的，证明却用到了连续和极限的思想。由此带来的结果是，我们虽然证明了凹多边形能在有限步之内变凸，但却完全无法给出所需步骤数的一个上限，哪怕是一个很松很粗略的上限！</p>
			 ]]></content>
<pubDate>2011-11-29T07:14:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4780</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 2011年度最变态的迷宫难题 ]]></title>
<link>http://www.matrix67.com/blog/archives/4790</link>
<content><![CDATA[ 
		<p>    下面大家将会看到的是一个极其简单而又极其复杂的“迷宫”，这无疑是我在本年度见到的最变态的谜题：从左边入口处的 2011 进去，在迷宫里转悠，最后变成 2012 从右边出来。你可以在迷宫里转圈，可以重复之前走过的路，但不能往回退着走。</p>
<p>      <img alt="image placeholder" >
<p>    你能成功走出来吗？</p>
<p><span id="more-4790"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    放弃吧，答案是</p>
<blockquote><p>2011 +7 ÷2 +7 ÷2 +7 -5 ×3 ÷2 +7 ÷2 +7 ×3 -5 ÷2 +7 ÷2 +7 -5 ×3 -5 ×3 ÷2 +7 -5 ×3 ÷2 +7 -5 = 2012</p></blockquote>
<p>    这个变态的谜题来自 <a href="http://www2.stetson.edu/~efriedma/holiday/2011/index.html">Holiday Puzzles 2011</a> ，作者是 <a href="http://www2.stetson.edu/~efriedma/">Erich Friedman</a> 。<br>
    提前祝大家新年快乐。</p>
			 ]]></content>
<pubDate>2011-11-30T14:22:34+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4790</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：舞台里的狮子 ]]></title>
<link>http://www.matrix67.com/blog/archives/4793</link>
<content><![CDATA[ 
		<p>    有一个半径为 10 米的圆形舞台，初始时舞台上的某个地方有一头狮子。这头狮子在舞台上以折线段的方式跑了 30 千米。求证：在整个过程中，这头狮子至少转了 2998 个弧度。</p>
<p>    有时候，换一个角度思考，问题就会迎刃而解。</p>
<p><span id="more-4793"></span></p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    现在，让我们站在狮子的角度，用狮子的眼光来看周围的世界。这样的话，狮子本身就是静止不动的，运动的其实是整个舞台；再假设狮子的头也是始终朝北的，狮子原地旋转实际上就是整个舞台绕着它做圆周运动。这样一来，舞台中心的运动就只有两种形式：竖直向下的直线运动，以及以狮子为中心的圆弧运动。如下图，左图就是在我们看来，狮子的移动轨迹，其中圆心代表舞台中心；右图就是在狮子的眼中，舞台中心的移动轨迹，其中圆心代表狮子。注意到，由于舞台始终包含了狮子，因此舞台中心绝不可能跑出狮子周围 10 米的范围。因此，每段直线运动都不能持续太久。我们需要不断靠圆弧运动上调舞台中心的位置，让它有继续竖直向下移动的空间。</p>
<p>      <img alt="image placeholder" >
<p>    由于舞台中心一共下降了 30000 米，但舞台中心的初始位置最多只能比终点位置高出 20 米，因而在整个过程中，舞台中心的高度至少还要靠圆弧运动上调 29980 米。因此，圆弧运动的总路程也就至少有 29980 米（事实上，由于两点之间直线段最短，走弧线绕了弯路，因此实际路程比 29980 米大得多）。如果每段圆弧的半径都是 10 米，那么所有圆弧的度数之和就应该有至少 2998 弧度；何况绝大多数圆弧的半径都小于 10 米，因此圆弧的总度数就更大了。这就说明了，在整个过程中，狮子至少转了 2998 个弧度。</p>
<p>题目来源：<a href="http://www.cs.cmu.edu/puzzle/puzzle16.html">http://www.cs.cmu.edu/puzzle/puzzle16.html</a></p>
			 ]]></content>
<pubDate>2011-12-02T10:15:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4793</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 对角线方法之后的故事 ]]></title>
<link>http://www.matrix67.com/blog/archives/4812</link>
<content><![CDATA[ 
		<p>    同样是无穷集合，如果集合里的元素能够与全体正整数构成一一对应的关系，我们就说它是可数的，否则就说它是不可数的。 1874 年， Cantor 发表了一篇重要的论文，论文中证明了全体有理数甚至是全体代数数都是可数的，但全体实数却是不可数的。换句话说，同样是无穷多，实数的数量比有理数、代数数的数量都高出了一个级别。不过，当时 Cantor 证明实数集不可数的方法并不容易理解。 1891 年， Cantor 发表了另一篇论文，给出了实数集不可数的另一种证明方法。此后，这个简单到不可思议的证明不断地震撼着每一个初学集合论的人：</p>
<p>    事实上，实数区间 (0, 1) 就已经是一个不可数的集合了。换句话说，你绝不可能用“第一个数是某某某，第二个数是某某某”的方式把 0 到 1 之间的所有实数一个不漏地列举出来。我们大致的证明思路是，假设你把实数区间 (0, 1) 里的所有数按照某种顺序排列起来，那么我总能找到至少一个 0 到 1 之间的实数，它不在你的列表里，从而说明你的列表并不全。把你的列表上的数全写成 0 到 1 之间的无限小数（如果是有限小数，可以在其后面添加数字 0 ，把它变成无限小数）：</p>
<blockquote><p>a<sub>1</sub> = 0.0147574628…<br>
a<sub>2</sub> = 0.3721111111…<br>
a<sub>3</sub> = 0.2323232323…<br>
a<sub>4</sub> = 0.0004838211…<br>
a<sub>5</sub> = 0.0516000000…<br>
………</p></blockquote>
<p>    那么我就构造这么一个小数，小数点后第一位不等于 a<sub>1</sub> 的第一位，小数点后第二位不等于 a<sub>2</sub> 的第二位，总之小数点后第 i 位不等于 a<sub>i</sub> 的第 i 位。这个数属于实数区间 (0, 1) ，但它显然不在你的列表里，因为它和你列表里的每一个数都有至少一位是不同的。这样，我们就证明了实数区间是不可数的。</p>
<p><span id="more-4812"></span><br>
    这就是传说中的“对角线方法”。第一次看到这个对角线方法的证明之后，想必所有人都会拍案叫绝，大呼巧妙。但是，冷静下来思考一下，你会发现对角线方法里面还有不少值得注意的问题。一个经典的问题就是，上述证明究竟在什么地方用到了“实数区间”这个条件？为什么同样的方法不能用来证明 0 到 1 之间的有理数是不可数的呢？我当然可以把 0 到 1 之间的全体有理数都写成无限小数，也可以假设它们已经排列成了 a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …</p>
<blockquote><p>a<sub>1</sub> = 0.1111111111…<br>
a<sub>2</sub> = 0.3267676767…<br>
a<sub>3</sub> = 0.5302000000…<br>
a<sub>4</sub> = 0.0439439439…<br>
a<sub>5</sub> = 0.1126000000…<br>
………</p></blockquote>
<p>    我当然也可以像刚才那样，用对角线方法取出一个不在列表里的数，从而说明有理数是不可数的。这个“证明”错在哪儿呢？它错在，最后用对角线方法取得的数不保证是一个有理数，因此如果它不在上述列表中，并不会对“有理数是可数的”这一结论造成威胁。下面，我会给出一个更隐蔽的误用对角线方法的例子，你还能看出问题出在哪里吗？</p>
<p>    对于某个实数，如果存在一个算法，它能给出该实数小数点后任意多位的数字，我们就把这个实数叫做“可计算数”。说得更简单一些，可计算数就是那些能够编写程序打印出来的数。因此，不但所有整数、有理数都是可计算数，所有代数数也都是可计算数，事实上很多超越数（比如 π 和 e ）也都是可计算数。但是注意到，所有可能的程序代码的数量是可数的，因为我们能够按照代码长度从小到大把它们一一列举出来（代码长度相等时可以按字典序排序）。因而，所有的可计算数也是可数的，它只占全体实数中很小很小的一部分。</p>
<p>    不过，利用对角线方法，我们能够“证明”一个完全相反的结论：可计算数是不可数的。</p>
<p>    同样地，我们只考虑 (0, 1) 区间内的可计算数。我们首先把所有的可计算数列成一张表，然后利用对角线方法，找出一个与列表中任意一个数都不相等的数。问题的关键就是，这个数本身是可计算数吗？仔细一想，还真是！由于每一个 a<sub>i</sub> 本身都是可计算的，因此我们可以在有限的时间里得到它的第 i 位数。我们再把“不同于第 i 位数字”的含义规定死，严格按照 0→1, 1→2, …, 8→9, 9→0 的规则选取相异的数字。 现在，让 i 从 1 开始递增，我们便能依次找出 a<sub>1</sub> 的第一位， a<sub>2</sub> 的第二位， a<sub>3</sub> 的第三位等等，每找到一个新的数字，便按照规则输出一个不同的数字。因而，这个数显然是可计算的。但是，这个可计算数却不在列表里，说明你的列表并不全。 Tada ，可计算数是不可数的。</p>
<p> <br>
    这个证明错在哪里呢？这个证明错在，我们一开始就凭空假设了一个可计算数列表，这个列表的生成规则是不透明的。这本来没啥（事实上我们在证明实数不可数时也是这么做的），但关键是，如果这个列表本身并不是通过某种方式计算出来的，最后用对角线法得到的数也就不是可计算的。那么，如果我们修改一下证明，事先给定一种生成可计算数列表的方案呢？麻烦就麻烦在这里：可计算数确实是可数的，确实能够一个一个地列举出来，但我们不见得能找出一个具体的列举算法。大家或许会奇怪，我们先依次列举出所有可能的程序代码，然后划掉那些不合法的代码，不就列出了所有的可计算数吗？问题就出在，我们不能有效地判断哪些代码是不合法的。这里“不合法的代码”含义很多，它有可能是根本无法正确编译的代码，也有可能是将会输出非数字字符的代码，还有可能是在某一步之后陷入死循环永远输不出下一个数字的程序代码。后面两个问题显然很难办，因为你不知道程序运行后将在什么地方开始就不合法了，也无法知道程序迟迟没能输出下一位数是因为真的遇到死循环了还是只需要再等一等。因此，仅用模拟运行的方法，我们无法在有限的时间里判断代码的合法性。有没有可能不模拟运行代码，依靠某种方法提前“预知”一段代码是否是合法的呢？在 1936 年的一篇著名论文中， Turing 证明了，这在理论上就是不可行的，再牛的算法，再牛的程序员也不能做到。这个结论可以重新叙述为，不存在这样的一个算法，它能判断一段代码运行之后究竟是会无限地运行下去，还是最终会在某一时刻停止下来。后来，人们就把它叫做“停机问题”。</p>
<p>    了解停机问题的朋友可能会惊呼，这简直是引入停机问题的一个绝佳切入口啊！事实上， Turing 在那篇著名的论文中，就是这样引入停机问题的。注意，如果“预知代码运行结果”的算法真的存在，我们就会得出“可计算数是不可数的”这么一个荒谬的结论，这已经证明了这种算法是不存在的。不过，为了让证明更具说服力， Turing 还给出了一些更具体的分析（警告：下文非常绕人，小心走火入魔）。</p>
<p>    如果我们真的发明了这样一种判断代码合法性的算法，那么我们就能编写出一个这样的程序，它将自动枚举所有可能的并且合法的代码，同时模拟运行这些代码（这是可以实现的，事实上 Turing 在论文中已经给出了在一个程序内部模拟另一个程序的方法，用现在的话说就相当于是用 C 语言写了一个 C 语言解释器），找出第 i 个代码将会输出的第 i 个数字，然后自己输出一个和它不同的数字。可见，这个程序本身是合法的，因为它模拟运行的都是合法的代码，不会被卡死，同时它也只会输出数字，不会输出别的东西。因此，这个程序代码本身也在合法代码的列表里。不妨假设它是第 n 个合法的代码吧。现在，运行这个程序，这个程序便会开始枚举所有合法的代码。总有一个时候，这个程序将会枚举到第 n 个代码，也就是这个程序本身的代码。这个程序将会模拟运行这个程序本身，试图找出它将输出的第 n 位数字是什么，然后输出一个与之不同的数。你会发现，此时矛盾已经出现了：它怎么能在第 n 位输出一个不同于它在第 n 位应该输出的数呢？</p>
<p>    而实际情况则更有意思：这个程序永远卡在这里了。当这个程序遇到第 n 个代码（也就是它本身）时，这个程序将会模拟它本身的运行。这个程序将会模拟它本身模拟前 n – 1 个程序的代码，找出它本身在前 n – 1 位输出了什么。然后这个程序将会模拟它本身模拟第 n 个代码。于是，这个程序将会模拟它本身模拟它本身又一次模拟之前的代码，并再次遇到自己的代码⋯⋯你会发现，这个程序将会陷入一个死循环，这与它本身是合法程序相矛盾。 Turing 用这种方法证明了，预知代码的行为是永远不可能实现的。</p>
<p> <br>
    集合论、可数集、不可数集、可计算数、不可计算数、对角线方法、Turing 机、停机问题、 Chaitin 常数、 Kolmogorov 复杂度、数理逻辑、 Gödel 不完备定理⋯⋯这是一个异常庞大的话题，它们之间彼此联系，形成一张巨大的网。似乎目前还没有一条漂亮的线索能够将这张网一次性地呈现出来，我们一次只能看到这张网的其中一角。这篇文章是我在读《The Annotated Turing》时看到的和想到的一些东西，如果你对这个话题感兴趣，我的 Blog 里还有一些类似的文章：</p>
<p>      可数集与不可数集的介绍：<a href="http://www.matrix67.com/blog/archives/416">http://www.matrix67.com/blog/archives/416</a><br>
      以及一些扩展：<a href="http://www.matrix67.com/blog/archives/2172">http://www.matrix67.com/blog/archives/2172</a><br>
      停机问题的介绍：<a href="http://www.matrix67.com/blog/archives/55">http://www.matrix67.com/blog/archives/55</a><br>
      Chaitin 常数：<a href="http://www.matrix67.com/blog/archives/901">http://www.matrix67.com/blog/archives/901</a><br>
      Chaitin 定理：<a href="http://www.matrix67.com/blog/archives/1392">http://www.matrix67.com/blog/archives/1392</a></p>
<p>    <a href="http://mindhacks.cn/">刘未鹏</a>大牛的两篇文章明显比我写得更好（标题也比我写的都帅多了）：</p>
<p>      图灵机杂思 <a href="http://blog.csdn.net/pongba/article/details/621723">http://blog.csdn.net/pongba/article/details/621723</a><br>
      康托尔、哥德尔、图灵——永恒的金色对角线 <a href="http://mindhacks.cn/?p=13">http://mindhacks.cn/?p=13</a></p>
<p>    当然，《GEB》和《皇帝的新脑》也是两本不得不看的奇书。</p>
			 ]]></content>
<pubDate>2011-12-07T16:35:56+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4812</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用最少的点挡住所有可能的反射路径 ]]></title>
<link>http://www.matrix67.com/blog/archives/4831</link>
<content><![CDATA[ 
		<p>    有一个正方形的房间，房间的四壁都是镜子。房间里有一个天使和一个恶魔。假设房间是一个单位正方形 [0, 1] × [0, 1] ，那么天使和恶魔便是这个正方形内的两个点 (a, b) 和 (c, d) 。恶魔想要在原地发射致命激光杀死天使（激光可以无限地在镜子间反射）。天使可以根据恶魔的位置，预先在房间里放置一些守卫为自己挡住激光（守卫实际上也是一个个点）。当然，天使可以在自己周围密密麻麻地放一圈守卫，围成一个封闭的圆形，从而让恶魔不管朝什么方向发射激光，最终都无法击中天使。我们的问题是，能把守卫的数量减少到可数个点吗？能把守卫的数量减少到有限个点吗？</p>
<p>    这是一个非常经典的问题，我已经见过不止一次了。它可以重新叙述为很多更有趣的实际问题。去年的这个时候，网友 Spark 发来邮件，分享了他在看台球比赛时想到的一个问题：最少需要摆放多少个球，才能挡住白球到目标球的所有可能的路线，迫使对手犯规？如果我们把台球也抽象成一个一个的点，问题就和前面提到的情况一样了。</p>
<p>    今天，我终于看到了这个问题的答案，颇为激动，在此和大家分享。</p>
<p><span id="more-4831"></span><br>
      <img alt="image placeholder" >
<p>    解决这类问题的一个常用技巧便是利用多次翻折把反射路线变为直线。现在，把这个房间不断地翻折，让它平铺整个平面；各种复杂的反射路径，就变成了一条一条的直线段。这样，我们便可认为恶魔的激光并不是在反射，而是径直穿过镜面射入房间的“虚像”。恶魔的目标，便是直接对准某个天使的虚像射击。由于天使的虚像只有可数个，因此天使可以在恶魔周围摆放可数个守卫，一一挡住射向每一个天使虚像的激光（有觉得下图中的网格线弯曲得异常严重吗？那是你的错觉）。</p>
<p>      <img alt="image placeholder" >
<p>    守卫的数量还能进一步减少到有限个点吗？注意到，即使只有有限的守卫，经过翻折之后也将会产生无穷多个守卫的虚像，每一个虚像都可以帮忙挡住激光。因此，只使用有限的守卫是完全有可能的。事实上，不管天使的位置 (a, b) 和恶魔的位置 (c, d) 在哪儿，摆放 16 个守卫总是足够的。下面我们给出一个具体的方案。</p>
<p>    容易看出，所有天使虚像的坐标都形如 (2m ± a, 2n ± b) ，其中 m 和 n 都是整数（可以为负）。我们先来考察其中一类虚像，即所有形如 (2m – a, 2n + b) 的点。对于任意确定的 m 和 n ，恶魔 (c, d) 和天使虚像 (2m – a, 2n + b) 的连线都会经过 (m – a/2 + c/2, n + b/2 + d/2) 这个点，因为这个点其实是前两个点的连线的中点。也就是说，在每个格子里的 (- a/2 + c/2, b/2 + d/2) 处都放一个点，就能够挡住所有射向这类虚像的激光了（注意，当 a &gt; c 时，横坐标是负的，因而这些点实际上将位于各个房间的 (1 – a/2 + c/2, b/2 + d/2) 处）：</p>
<p>      <img alt="image placeholder" >
<p>    等等，等等，这些黑点都是从哪儿来的？别忘了，我们只能通过翻折建立虚像，不能通过平移建立虚像。因此，事实上，我们需要在初始的房间里对称地放置四个守卫，才能让所有“虚房间”的 (- a/2 + c/2, b/2 + d/2) 处都有一个点：</p>
<p>      <img alt="image placeholder" >
<p>    类似地，天使的虚像坐标还有 (2m + a, 2n + b) 、 (2m + a, 2n – b) 、 (2m – a, 2n – b) 三类，它们又需要另外四组守卫。因此，总共 16 个守卫便能挡住所有可能的激光。</p>
<p> <br>
问题来源： <a href="http://www.cs.cmu.edu/puzzle/puzzle23.html">http://www.cs.cmu.edu/puzzle/puzzle23.html</a></p>
			 ]]></content>
<pubDate>2011-12-14T00:20:46+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4831</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：这些词有什么共同点？ ]]></title>
<link>http://www.matrix67.com/blog/archives/4858</link>
<content><![CDATA[ 
		<p>     据说，爱出题也是 Geek 的一种特征。这几天在做语言工程课的期末大作业时，再一次见识了汉语里各种诡异的语法规则，然后突然想到了这样一种好玩的题型，于是竟然暂时放下手中的作业，花时间编了几个这样的题目来（感谢 Geek 小美女 <a href="http://localhost-8080.com/">localhost_8080</a> 的帮助）。<br>
    下面的每一组词中，前五个词都具有某种共同的性质，这种性质是后面五个词都不具有的。你能猜出每组词所对应的那个性质吗？</p>
<p>      (1) 反复、高兴、磨蹭、说笑、许多 | 地震、动静、金黄、巨大、雕刻<br>
      (2) 鱼、路、船、裙子、短信 | 山、剑、伞、文章、水母<br>
      (3) 锁、画、挂钩、标志、爱好 | 钟、鞋、密码、学问、照片<br>
      (4) 腿、门、气味、鱼刺、笔记本 | 手、电、建筑、铅笔、地球仪<br>
      (5) 车、地、桌子、屁股、筷子 | 水、胃、位置、大陆、晚餐</p>
<p><span id="more-4858"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    答案：(1) 可以 AABB 式重叠 (2) 量词是“条” (3) 可兼类作动词 (4) 可以儿化 (5) 可以在前面加“一”作临时量词<br>
    如果你喜欢这几个小问题，你或许会喜欢<a href="http://www.matrix67.com/blog/archives/3677">这里</a>的第一题。<br>
 </p>
			 ]]></content>
<pubDate>2011-12-29T20:07:40+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4858</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 漫话中文自动分词和语义识别（下）：句法结构和语义结构 ]]></title>
<link>http://www.matrix67.com/blog/archives/4870</link>
<content><![CDATA[ 
		<p>    这篇文章是<a href="http://www.matrix67.com/blog/archives/4212">漫话中文分词算法</a>的续篇。在这里，我们将紧接着上一篇文章的内容继续探讨下去：如果计算机可以对一句话进行自动分词，它还能进一步整理句子的结构，甚至理解句子的意思吗？这两篇文章的关系十分紧密，因此，我把前一篇文章改名为了《漫话中文自动分词和语义识别（上）》，这篇文章自然就是它的下篇。我已经在很多不同的地方做过与这个话题有关的演讲了，在这里我想把它们写下来，和更多的人一同分享。</p>
<p>    什么叫做句法结构呢？让我们来看一些例子。“白天鹅在水中游”，这句话是有歧义的，它可能指的是“白天有一只鹅在水中游”，也可能指的是“有一只白天鹅在水中游”。不同的分词方案，产生了不同的意义。有没有什么句子，它的分词方案是唯一的，但也会产生不同的意思呢？有。比如“门没有锁”，它可能是指的“门没有被锁上”，也有可能是指的“门上根本就没有挂锁”。这个句子虽然只能切分成“门／没有／锁”，但由于“锁”这个词既有可能是动词，也有可能是名词，因而让整句话产生了不同的意思。有没有什么句子，它的分词方案是唯一的，并且每个词的词义也都不再变化，但整个句子仍然有歧义呢？有可能。看看这句话：“咬死了猎人的狗”。这句话有可能指的是“把猎人的狗咬死了”，也有可能指的是“一只咬死了猎人的狗”。这个歧义是怎么产生的呢？仔细体会两种不同的意思后，你会发现，句子中最底层的成分可以以不同的顺序组合起来，歧义由此产生。</p>
<p><span id="more-4870"></span><br>
    在前一篇文章中，我们看到了，利用概率转移的方法，我们可以有效地给一句话分词。事实上，利用相同的模型，我们也能给每一个词标注词性。更好的做法则是，我们直接把同一个词不同词性的用法当作是不同的词，从而把分词和词性标注的工作统一起来。但是，所有这样的工作都是对句子进行从左至右线性的分析，而句子结构实际上比这要复杂多了，它是这些词有顺序有层次地组合在一起的。计算机要想正确地解析一个句子，在分词和标注词性后，接下来该做的就是分析句法结构的层次。</p>
<p>    在计算机中，怎样描述一个句子的句法结构呢？ 1957 年， Noam Chomsky 出版了《句法结构》一书，把这种语言的层次化结构用形式化的方式清晰地描述了出来，这也就是所谓的“生成语法”模型。这本书是 20 世纪为数不多的几本真正的著作之一，文字非常简练，思路非常明晰，震撼了包括语言学、计算机理论在内的多个领域。记得 Quora 上曾经有人问 <a href="http://www.quora.com/Best-Of/Who-are-the-best-minds-of-the-world-today-and-why">Who are the best minds of the world today</a> ，投出来的答案就是 Noam Chomsky 。</p>
<p>    随便取一句很长很复杂的话，比如“汽车被开车的师傅修好了”，我们总能自顶向下地一层层分析出它的结构。这个句子最顶层的结构就是“汽车修好了”。汽车怎么修好了呢？汽车被师傅修好了。汽车被什么样的师傅修好了呢？哦，汽车被开车的师傅修好了。当然，我们还可以无限地扩展下去，继续把句子中的每一个最底层的成分替换成更详细更复杂的描述，就好像小学语文中的扩句练习那样。这就是生成语法的核心思想。</p>
<p>    熟悉编译原理的朋友们可能知道“上下文无关文法”。其实，上面提到的扩展规则本质上就是一种上下文无关文法。例如，一个句子可以是“什么怎么样”的形式，我们就把这条规则记作</p>
<p>      句子 → 名词性短语＋动词性短语</p>
<p>    其中，“名词性短语”指的是一个具有名词功能的成分，它有可能就是一个名词，也有可能还有它自己的内部结构。例如，它有可能是一个形容词性短语加上“的”再加上另一个名词性短语构成的，比如“便宜的汽车”；它还有可能是由“动词性短语＋的＋名词性短语”构成的，比如“抛锚了的汽车”；它甚至可能是由“名词性短语＋的＋名词性短语”构成的，比如“老师的汽车”。我们把名词性短语的生成规则也都记下来：</p>
<p>      名词性短语 → 名词<br>
      名词性短语 → 形容词性短语＋的＋名词性短语<br>
      名词性短语 → 动词性短语＋的＋名词性短语<br>
      名词性短语 → 名词性短语＋的＋名词性短语<br>
      ⋯⋯</p>
<p>    类似地，动词性短语也有诸多具体的形式：</p>
<p>      动词性短语 → 动词<br>
      动词性短语 → 动词性短语＋了<br>
      动词性短语 → 介词短语＋动词性短语<br>
      ⋯⋯</p>
<p>    上面我们涉及到了介词短语，它也有自己的生成规则：</p>
<p>      介词短语 → 介词＋名词性短语<br>
      ⋯⋯</p>
<p>    我们构造句子的任务，也就是从“句子”这个初始结点出发，不断调用规则，产生越来越复杂的句型框架，然后从词库中选择相应词性的单词，填进这个框架里：</p>
<p>      <img alt="image placeholder" >
<p>    而分析句法结构的任务，则是已知一个句子从左到右各词的词性，要反过来求出一棵满足要求的“句法结构树”。这可以用 <a href="http://en.wikipedia.org/wiki/Earley_parser">Earley parser</a> 来实现。</p>
<p>    这样看来，句法结构的问题似乎就已经完美的解决了。其实，我们还差得很远。生成语法有两个大问题。首先，句法结构正确的句子不见得都是好句子。 Chomsky 本人给出了一个经典的例子： Colorless green ideas sleep furiously 。形容词加形容词加名词加动词加副词，这是一个完全符合句法要求的序列，但随便拼凑会闹出很多笑话——什么叫做“无色的绿色的想法在狂暴地睡觉”？顺便插播个广告，如果你还挺喜欢这句话的意境的，欢迎去我以前做的 <a href="http://www.matrix67.com/ideagen/">IdeaGenerator</a> 玩玩。不过，如果我们不涉及句子的生成，只关心句子的结构分析，这个缺陷对我们来说影响似乎并不大。生成语法的第二个问题就比较麻烦了：从同一个词性序列出发，可能会构建出不同的句法结构树。比较下面两个例子：</p>
<p>      老师 被 迟到 的 学生 逗乐 了<br>
      电话 被 窃听 的 房间 找到 了</p>
<p>    它们都是“名词＋介词＋动词＋的＋名词＋动词＋了”，但它们的结构并不一样，前者是老师被逗乐了，“迟到”是修饰“学生”的，后者是房间找到了，“电话被窃听”是一起来修饰房间的。但是，纯粹运用前面的模型，我们无法区分出哪句话应该是哪个句法结构树。如何强化句法分析的模型和算法，让计算机构建出一棵正确的句法树，这成了一个大问题。</p>
<p>    让我们来看一个更简单的例子吧。同样是“动词＋形容词＋名词”，我们有两种构建句法结构树的方案：</p>
<p>      <img alt="image placeholder" >
<p>    未经过汉语语法训练的朋友可能会问，“点亮蜡烛”和“踢新皮球”的句法结构真的不同吗？我们能证明，这里面真的存在不同。我们造一个句子“踢破皮球”，你会发现对于这个句子来说，两种句法结构都是成立的，于是出现了歧义：把皮球踢破了（结构和“点亮蜡烛”一致），或者是，踢一个破的皮球（结构和“踢新皮球”一致）。</p>
<p>    但为什么“点亮蜡烛”只有一种理解方式呢？这是因为我们通常不会把“亮”字直接放在名词前做定语，我们一般不说“一根亮蜡烛”、“一颗亮星星”等等。为什么“踢新皮球”也只有一种理解方式呢？这是因为我们通常不会把“新”直接放在动词后面作补语，不会说“皮球踢新了”、“衣服洗新了”等等。但是“破”既能作定语又能作补语，于是“踢破皮球”就产生了两种不同的意思。如果我们把每个形容词能否作定语，能否作补语都记下来，然后在生成规则中添加限制条件，不就能完美解决这个问题了吗？</p>
<p>    基于规则的句法分析器就是这么做的。汉语语言学家们已经列出了所有词的各种特征：</p>
<p>      亮：词性 = 形容词，能作补语 = True ，能作定语 = False ⋯⋯<br>
      新：词性 = 形容词，能作补语 = False ，能作定语 = True ⋯⋯<br>
      ⋯⋯</p>
<p>    当然，每个动词也有一大堆属性：</p>
<p>      点：词性 = 动词，能带宾语 = True ，能带补语 = True ⋯⋯<br>
      踢：词性 = 动词，能带宾语 = True ，能带补语 = True ⋯⋯<br>
      污染：词性 = 动词，能带宾语 = True ，能带补语 = False ⋯⋯<br>
      排队：词性 = 动词，能带宾语 = False ，能带补语 = False ⋯⋯<br>
      ⋯⋯</p>
<p>    名词也不例外：</p>
<p>      蜡烛：词性 = 名词，能作主语 = True ，能作宾语 = True ，能受数量词修饰 = True ⋯⋯<br>
      皮球：词性 = 名词，能作主语 = True ，能作宾语 = True ，能受数量词修饰 = True ⋯⋯<br>
      ⋯⋯</p>
<p>    有人估计会觉得奇怪了：“能作主语”也是一个属性，莫非有些名词不能做主语？哈哈，这样的名词不但有，而且还真不少：剧毒、看头、地步、正轨、存亡⋯⋯这些词都不放在动词前面。难道有些名词不能做宾语吗？这样的词也有不少：享年、芳龄、心术、浑身、家丑⋯⋯这些词都不放在动词后面。这样说来，存在不受数量词修饰的词也就不奇怪了，事实上上面这些怪异的名词前面基本上都不能加数量词。</p>
<p>    另外一个至关重要的就是，这些性质可以“向上传递”。比方说，我们规定，套用规则</p>
<p>      名词性短语 → 形容词性短语＋名词性短语</p>
<p>    后，整个名词性短语能否作主语、能否作宾语、能否受数量词修饰，这将取决于它的第二个构成成分。通俗地讲就是，如果“皮球”能够作主语，那么“新皮球”也能够作主语。有了“词语知识库”，又确保了这些知识能够在更高层次得到保留，我们就能给语法生成规则添加限制条件了。例如，我们可以规定，套用规则</p>
<p>      动词性短语 → 动词性短语＋名词性短语</p>
<p>    的前提条件就是，那个动词性短语的“能带宾语”属性为 True ，并且那个名词性短语“能作宾语”的属性为 True 。另外，我们规定</p>
<p>      动词性短语 → 动词性短语＋形容词性短语</p>
<p>    必须满足动词性短语的“能带补语”属性为 True ，并且形容词性短语“能作补语”属性为 True 。这样便阻止了“踢新皮球”中的“踢”和“新”先结合起来，因为“新”不能作补语。</p>
<p>    最后我们规定，套用规则</p>
<p>      名词性短语 → 形容词性短语＋名词性短语</p>
<p>    时，形容词性短语必须要能作定语。这就避免了“点亮蜡烛”中的“亮”和“蜡烛”先组合起来，因为“亮”通常不作定语。这样，我们便解决了“动词＋形容词＋名词”的结构分析问题。</p>
<p>    当然，这只是一个很简单的例子。在<a href="http://www.matrix67.com/blog/archives/508">这里</a>的问题 6 、 7 、 8 中你可以看到，一条语法生成规则往往有很多限制条件，这些限制条件不光是简单的“功能相符”和“前后一致”，有些复杂的限制条件甚至需要用 IF … THEN … 的方式来描述。你可以在<a href="http://www.matrix67.com/blog/archives/4858">这里</a>看到，汉语中词与词之间还有各种怪异的区别特征，并且哪个词拥有哪些性质纯粹是知识库的问题，完全没有规律可循。一个实用的句法结构分析系统，往往拥有上百种属性标签。北京大学计算语言所编写了《现代汉语语法信息词典》，它里面包含了 579 种属性。我们的理想目标就是，找到汉语中每一种可能会影响句法结构的因素，并据此为词库里的每一个词打上标签；再列出汉语语法中的每一条生成规则，找到每一条生成规则的应用条件，以及应用这条规则之后，整个成分将会以怎样的方式继承哪些子成分的哪些属性，又会在什么样的情况下产生哪些新的属性。按照生成语言学的观点，计算机就应该能正确解析所有的汉语句子了。</p>
<p> <br>
 <br>
    那么，这样一来，计算机是否就已经能从句子中获取到理解语义需要的所有信息了呢？答案是否定的。还有这么一些句子，它从分词到词义到结构都没有两可的情况，但整个句子仍然有歧义。考虑这句话“鸡不吃了”，它有两种意思：鸡不吃东西了，或者我们不吃鸡了。但是，这种歧义并不是由分词或者词义或者结构导致的，两种意思所对应的语法结构完全相同，都是“鸡”加上“不吃了”。但为什么歧义仍然产生了呢？这是因为，在句法结构内部，还有更深层次的语义结构，两者并不相同。</p>
<p>    汉语就是这么奇怪，位于主语位置上的事物既有可能是动作的发出者，也有可能是动作的承受者。“我吃完了”可以说，“苹果吃完了”也能讲。然而，“鸡”这个东西既能吃，也能被吃，歧义由此产生。</p>
<p>    位于宾语位置上的事物也不一定就是动作的承受者，“来客人了”、“住了一个人”都是属于宾语反而是动作发出者的情况。记得某次数理逻辑课上老师感叹，汉语的谓词非常不规范，明明是太阳在晒我，为什么要说成是“我晒太阳”呢？事实上，汉语的动宾搭配范围极其广泛，还有很多更怪异的例子：“写字”是我们真正在写的东西，“写书”是写的结果，“写毛笔”是写的工具，“写楷体”是写的方式，“写地上”是写的场所，“写一只狗”，等等，什么叫做“写一只狗”啊？我们能说“写一只狗”吗？当然可以，这是写的内容嘛，“同学们这周作文写什么啊”，“我写一只狗”。大家可以想像，学中文的老外看了这个会是什么表情。虽然通过句法分析，我们能够判断出句子中的每样东西都和哪个动词相关联，但从语义层面上看这个关联是什么，我们还需要新的模型。</p>
<p>    汉语语言学家把事物与动词的语义关系分为了 17 种，叫做 17 种“语义角色”，它们是施事、感事、当事、动力、受事、结果、系事、工具、材料、方式、内容、与事、对象、场所、目标、起点、时间。你可以看到，语义角色的划分非常详细。同样是动作的发出者，施事指的是真正意义上的发出动作，比如“他吃饭”中的“他”；感事则是指某种感知活动的经验者，比如“他知道这件事了”中的“他”；当事则是指性质状态的主体，比如“他病了”中的“他”；动力则是自然力量的发出者，比如“洪水淹没了村庄”中的“洪水”。语义角色的具体划分以及 17 这个数目是有争议的，不过不管怎样，这个模型本身能够非常贴切地回答“什么是语义”这个问题。</p>
<p>    汉语有一种“投射理论”，即一个句子的结构是由这个句子中的谓语投射出来的。给定一个动词后，这个动词能够带多少个语义角色，这几个语义角色都是什么，基本上都已经确定了。因而，完整的句子所应有的结构实际上也就已经确定了。比如，说到“休息”这个动词，你就会觉得它缺少一个施事，而且也不缺别的了。我们只会说“老王休息”，不会说“老王休息手”或者“老王休息沙发”。因而我们认为，“休息”只有一个“论元”。它的“论元结构”是：</p>
<p>      休息 </p>
<p>    因此，一旦在句子中看到“休息”这个词，我们就需要在句内或者句外寻找“休息”所需要的施事。这个过程有一个很帅的名字，叫做“配价”。“休息”就是一个典型的“一价动词”。我们平时接触的比较多的则是二价动词。不过，它们具体的论元有可能不一样：</p>
<p>      吃 <br>
      去 <br>
      淹没 </p>
<p>    三价动词也是有的，例如</p>
<p>      送 </p>
<p>    甚至还有零价动词，例如</p>
<p>      下雨 </p>
<p>    下面我们要教计算机做的，就是怎样给动词配价。之前，我们已经给出了解析句法结构的方法，这样计算机便能判断出每个动词究竟在和哪些词发生关系。语义分析的实质，就是确定出它们具体是什么关系。因此，语义识别的问题，也就转化为了“语义角色标注”的问题。然而，语义角色出现的位置并不固定，施事也能出现在动词后面，受事也能出现在动词前面，怎样让计算机识别语义角色呢？在回答这个问题之前，我们不妨问问自己：我们是怎么知道，“我吃完了”中的“我”是“吃”的施事，“苹果吃完了”中的“苹果”是“吃”的受事的呢？大家肯定会说，废话，“我”当然只能是“吃”的施事，因为我显然不会“被吃”；“苹果”当然只能是“吃”的受事，因为苹果显然不能发出“吃”动作。也就是说，“吃”的两个论元都有语义类的要求。我们把“吃”的论元结构写得更详细一些：</p>
<p>      吃 </p>
<p>而“淹没”一词的论元结构则可以补充为：</p>
<p>      淹没 </p>
<p>    所以，为了完成计算机自动标注语义角色的任务，我们需要人肉建立两个庞大的数据库：语义类词典和论元结构词典。这样的人肉工程早就已经做过了。北京语言大学 1990 年 5 月启动的“九〇￼五语义工程”就是人工构建的一棵规模相当大的语义树。它把词语分成了事物、运动、时空、属性四大类，其中事物类分为事类和物类，物类又分为具体物和抽象物，具体物则再分为生物和非生物，生物之下则分了人类、动物、植物、微生物、生物构件五类，非生物之下则分了天然物、人工物、遗弃物、几何图形和非生物构件五类，其中人工物之下又包括设施物、运载物、器具物、原材料、耗散物、信息物、钱财七类。整棵语义树有 414 个结点，其中叶子结点 309 个，深度最大的地方达到了 9 层。论元结构方面则有清华大学和人民大学共同完成的《现代汉语述语动词机器词典》，词典中包括了各种动词的拼音、释义、分类、论元数、论元的语义角色、论元的语义限制等语法和语义信息。</p>
<p>    说到语义工程，不得不提到董振东先生的<a href="http://www.keenage.com/html/c_index.html">知网</a>。这是一个综合了语义分类和语义关系的知识库，不但通过语义树反映了词与词的共性，还通过语义关系反映了每个词的个性。它不但能告诉你“医生”和“病人”都是人，还告诉了你“医生”可以对“病人”发出一个“医治”的动作。知网的理念和 WordNet 工程很相似，后者是 Princeton 在 1985 年就已经开始构建的英文单词语义关系词典，背后也是一个语义关系网的概念，词与词的关系涉及同义词、反义词、上下位词、整体与部分、子集与超集、材料与成品等等。如果你装了 Mathematica，你可以通过 WordData 函数获取到 WordNet 的数据。至于前面说的那几个中文知识库嘛，别问我，我也不知道上哪儿取去。</p>
<p> <br>
    看到这里，想必大家会欢呼，啊，这下子，在中文信息处理领域，从语法到语义都已经漂亮的解决了吧。其实并没有。上面的论元语义角色的模型有很多问题。其中一个很容易想到的就是隐喻的问题，比如“信息淹没了我”、“悲伤淹没了我”。一旦出现动词的新用法，我们只能更新论元结构：</p>
<p>      淹没 </p>
<p>    但更麻烦的则是下面这些违背语义规则的情况。一个是否定句，比如“张三不可能吃思想”。一个是疑问句，比如“张三怎么可能吃思想”。更麻烦的就是超常现象。随便在新闻网站上一搜，你就会发现各种不符合语义规则的情形。我搜了一个“吃金属”，立即看到某新闻标题《法国一位老人以吃金属为生》。要想解决这些问题，需要给配价模型打上不少补丁。</p>
<p> <br>
    然而，配价模型也仅仅解决了动词的语义问题。其他词呢？好在，我们也可以为名词发展一套类似的配价理论。我们通常认为“教师”是一个零价名词，而“老师”则是一个一价名词，因为说到“老师”时，我们通常会说“谁的老师”。“态度”则是一个二价的名词，因为我们通常要说“谁对谁的态度”才算完整。事实上，形容词也有配价，“优秀”就是一个一价形容词，“友好”则是一个二价形容词，原因也是类似的。配价理论还有很多更复杂的内容，这里我们就不再详说了。</p>
<p>    但还有很多配价理论完全无法解决的问题。比如，语义有指向的问题。“砍光了”、“砍累了”、“砍钝了”、“砍快了”，都是动词后面跟形容词作补语，但实际意义各不相同。“砍光了”指的是“树砍光了”，“砍累了”指的是“人砍累了”，“砍钝了”指的是“斧子砍钝了”，“砍快了”指的是“砍砍快了”。看来，一个动词的每个论元不但有语义类的限制，还有“评价方式”的限制。</p>
<p>    两个动词连用，也有语义关系的问题。“抓住不放”中，“抓住”和“不放”这两个动作构成一种反复的关系，抓住就等于不放。“说起来气人”中，“说起来”和“气人”这两个动作构成了一种条件关系，即每次发生了“说起来”这个事件后，都会产生“气人”这个结果。大家或许又会说，这两种情况真的有区别吗？是的，而且我能证明这一点。让我们造一个句子“留着没用”，你会发现它出现了歧义：既可以像“抓住不放”一样理解为反复关系，一直把它留着一直没有使用；又可以像“说起来气人”一样理解为条件关系，留着的话是不会有用的。因此，动词与动词连用确实会产生不同的语义关系，这需要另一套模型来处理。</p>
<p>    虚词的语义更麻烦。别以为“了”就是表示完成，“这本书看了三天”表示这本书看完了，“这本书看了三天了”反而表示这本书没看完。“了”到底有多少个义项，现在也没有一个定论。副词也算虚词，副词的语义同样捉摸不定。比较“张三和李四结婚了”与“张三和李四都结婚了”，你会发现描述“都”字的语义没那么简单。</p>
<p> <br>
    不过，在实际的产品应用中，前面所说的这些问题都不大。这篇文章中讲到的基本上都是基于规则的语言学处理方法。目前更实用的，则是对大规模真实语料的概率统计分析与机器学习算法，这条路子可以无视很多具体的语言学问题，并且效果也相当理想。最大熵模型和条件随机场都是目前非常常用的自然语言处理手段，感兴趣的朋友可以深入研究一下。但是，这些方法也有它们自己的缺点，就是它们的不可预测性。不管哪条路，似乎都离目标还有很远的一段距离。期待在未来的某一日，自然语言处理领域会迎来一套全新的语言模型，一举解决前面提到的所有难题。</p>
			 ]]></content>
<pubDate>2012-01-05T16:25:55+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4870</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 12个经典的行程问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/4881</link>
<content><![CDATA[ 
		<p>    无论是小学奥数，还是公务员考试，还是公司的笔试面试题，似乎都少不了行程问题——题目门槛低，人人都能看懂；但思路奇巧，的确会难住不少人。平时看书上网与人聊天和最近与小学奥数打交道的过程中，我收集到很多简单有趣而又颇具启发性的行程问题，在这里整理成一篇文章，和大家一同分享。这些题目都已经非常经典了，绝大多数可能大家都见过；希望这里能有至少一个你没见过的题目，也欢迎大家来信提供更多类似的问题。</p>
<p>    让我们先从一些最经典最经典的问题说起吧。选中空白部分显示答案。</p>
<p>    甲、乙两人分别从相距 100 米的 A 、B 两地出发，相向而行，其中甲的速度是 2 米每秒，乙的速度是 3 米每秒。一只狗从 A 地出发，先以 6 米每秒的速度奔向乙，碰到乙后再掉头冲向甲，碰到甲之后再跑向乙，如此反复，直到甲、乙两人相遇。问在此过程中狗一共跑了多少米？</p>
<p><span id="more-4881"></span></p>
<p style="color:#e5e5e5">    这可以说是最经典的行程问题了。不用分析小狗具体跑过哪些路程，只需要注意到甲、乙两人从出发到相遇需要 20 秒，在这 20 秒的时间里小狗一直在跑，因此它跑过的路程就是 120 米。<br>
    说到这个经典问题，故事可就多了。下面引用某个经典的数学家八卦帖子： John von Neumann 曾被问起一个中国小学生都很熟的问题：两个人相向而行，中间一只狗跑来跑去，问两个人相遇后狗走了多少路。诀窍无非是先求出相遇的时间再乘以狗的速度。 Neumann 当然瞬间给出了答案。提问的人失望地说你以前一定听说过这个诀窍吧。 Neumann 惊讶道：“什么诀窍？我就是把狗每次跑的都算出来，然后计算无穷级数⋯⋯”</p>
<p>    某人上午八点从山脚出发，沿山路步行上山，晚上八点到达山顶。不过，他并不是匀速前进的，有时慢，有时快，有时甚至会停下来。第二天，他早晨八点从山顶出发，沿着原路下山，途中也是有时快有时慢，最终在晚上八点到达山脚。试着说明：此人一定在这两天的某个相同的时刻经过了山路上的同一个点。</p>
<p style="color:#e5e5e5">    这个题目也是经典中的经典了。把这个人两天的行程重叠到一天去，换句话说想像有一个人从山脚走到了山顶，同一天还有另一个人从山顶走到了山脚。这两个人一定会在途中的某个地点相遇。这就说明了，这个人在两天的同一时刻都经过了这里。</p>
<p>      <img alt="image placeholder" >
<p>    甲从 A 地前往 B 地，乙从 B 地前往 A 地，两人同时出发，各自匀速地前进，每个人到达目的地后都立即以原速度返回。两人首次在距离 A 地 700 米处相遇，后来又在距离 B 地 400 米处相遇。求 A 、 B 两地间的距离。</p>
<p style="color:#e5e5e5">    答案： 1700 米。第一次相遇时，甲、乙共同走完一个 AB 的距离；第二次相遇时，甲、乙共同走完三个 AB 的距离。可见，从第一次相遇到第二次相遇的过程花了两个从出发到第一次相遇这么多的时间。既然第一次相遇时甲走了 700 米，说明后来甲又走了 1400 米，因此甲一共走了 2100 米。从中减去 400 米，正好就是 A 、 B 之间的距离了。</p>
<p>    甲、乙、丙三人百米赛跑，每次都是甲胜乙 10 米，乙胜丙 10 米。则甲胜丙多少米？</p>
<p style="color:#e5e5e5">    答案是 19 米。“乙胜丙 10 米”的意思就是，等乙到了终点处时，丙只到了 90 米处。“甲胜乙 10 米”的意思就是，甲到了终点处时，乙只到了 90 米处，而此时丙应该还在 81 米处。所以甲胜了丙 19 米。</p>
<p>    哥哥弟弟百米赛跑，哥哥赢了弟弟 1 米。第二次，哥哥在起跑线处退后 1 米与弟弟比赛，那么谁会获胜？</p>
<p style="color:#e5e5e5">    答案是，哥哥还是获胜了。哥哥跑 100 米需要的时间等于弟弟跑 99 米需要的时间。第二次，哥哥在 -1 米处起跑，弟弟在 0 米处起跑，两人将在第 99 米处追平。在剩下的 1 米里，哥哥超过了弟弟并获得胜利。</p>
<p>    如果你上山的速度是 2 米每秒，下山的速度是 6 米每秒（假设上山和下山走的是同一条山路）。那么，你全程的平均速度是多少？</p>
<p style="color:#e5e5e5">    这是小学行程问题中最容易错的题之一，是小孩子们死活也搞不明白的问题。答案不是 4 米每秒，而是 3 米每秒。不妨假设全程是 S 米，那么上山的时间就是 S/2 ，下山的时间就是 S/6 ，往返的总路程为 2S ，往返的总时间为 S/2 + S/6 ，因而全程的平均速度为 2S / (S/2 + S/6) = 3 。<br>
    其实，我们很容易看出，如果前一半路程的速度为 a ，后一半路程的速度为 b ，那么总的平均速度应该小于 (a + b) / 2 。这是因为，你会把更多的时间花在速度慢的那一半路程上，从而把平均速度拖慢了。事实上，总的平均速度应该是 a 和 b 的调和平均数，即 2 / (1/a + 1/b) ，很容易证明调和平均数总是小于等于算术平均数的。</p>
<p>    接下来的两个问题与流水行船有关。假设顺水时实际船速等于静水中的船速加上水流速度，逆水时实际船速等于静水中的船速减去水流速度。</p>
<p>    船在静水中往返 A 、 B 两地和在流水中往返 A 、 B 两地相比，哪种情况下更快？</p>
<p style="color:#e5e5e5">    这是一个经典问题了。答案是，船在静水中更快一些。注意船在顺水中的实际速度与在逆水中的实际速度的平均值就是它的静水速度，但由前一个问题的结论，实际的总平均速度会小于这个平均值。因此，船在流水中往返需要的总时间更久。<br>
    考虑一种极端情况可以让问题的答案变得异常显然，颇有一种荒谬的喜剧效果。假设船刚开始在上游。如果水速等于船速的话，它将以原速度的两倍飞速到达折返点。但它永远也回不来了⋯⋯</p>
<p>    船在流水中逆水前进，途中一个救生圈不小心掉入水中，一小时后船员才发现并调头追赶。则追上救生圈所需的时间会大于一个小时，还是小于一个小时，还是等于一个小时？</p>
<p style="color:#e5e5e5">    这也是一个经典问题了。中学物理竞赛中曾出现过此题，《编程之美》上也有一个完全相同的问题。答案是等于一个小时。原因很简单：反正船和救生圈都被加上了一个水流的速度，我们就可以直接抛开流水的影响不看了。换句话说，我们若以流水为参照系，一切就都如同没有流水了。我们直接可以想像船在静水当中丢掉了一个救生圈并继续前行一个小时，回去捡救生圈当然也还需要一个小时。<br>
    每当有人还是没想通时，我很愿意举这么一个例子。假如有一列匀速疾驰的火车，你在火车车厢里，从车头往车尾方向步行。途中你掉了一个钱包，但继续往前走了一分钟后才发现。显然，你回去捡钱包需要的时间也是一分钟。但是，钱包不是正被火车载着自动地往远方走吗？其实，既然你们都在火车上，自然就可以无视火车的速度了。前面的救生圈问题也是一样的道理。</p>
<p>    下面这个问题也很类似：假设人在传送带上的实际行走速度等于人在平地上的行走速度加上一个传送带的速度。</p>
<p>    你需要从机场的一号航站楼走到二号航站楼。路途分为两段，一段是平地，一段是自动传送带。假设你的步行速度是一定的，因而在传送带上步行的实际速度就是你在平地上的速度加上传送带的速度。如果在整个过程中，你必须花两秒钟的时间停下来做一件事情（比如蹲下来系鞋带），那么为了更快到达目的地，你应该把这两秒钟的时间花在哪里更好？</p>
<p style="color:#e5e5e5">    这个漂亮的问题出自 Terence Tao 的 Blog （http://terrytao.wordpress.com/2008/12/09/an-airport-inspired-puzzle）。很多人可能会认为，两种方案是一样的吧？然而，真正的答案却是，把这两秒花在传送带上会更快一些。这是因为，传送带能给你提供一些额外的速度，因而你会希望在传送带上停留更久的时间，更充分地利用传送带的好处。因此，如果你必须停下来一会儿的话，你应该在传送带上多停一会儿。</p>
<p>    假设你站在甲、乙两地之间的某个位置，想乘坐出租车到乙地去。你看见一辆空车远远地从甲地驶来，而此时整条路上并没有别人与你争抢空车。我们假定车的行驶速度和人的步行速度都是固定不变的，并且车速大于人速。为了更快地到达目的地，你应该迎着车走过去，还是顺着车的方向往前走一点？</p>
<p style="color:#e5e5e5">    这是我在打车时想到的一个问题。我喜欢在各种人多的场合下提出这个问题，此时大家的观点往往会立即分为鲜明的两派，并且各有各的道理。有人说，由于车速大于人速，我应该尽可能早地上车，充分利用汽车的速度优势，因此应该迎着空车走上去，提前与车相遇嘛。另一派人则说，为了尽早到达目的地，我应该充分利用时间，马不停蹄地赶往目的地。因此，我应该自己先朝目的地走一段路，再让出租车载我走完剩下的路程。<br>
    其实答案出人意料的简单，两种方案花费的时间显然是一样的。只要站在出租车的角度上想一想，问题就变得很显然了：不管人在哪儿上车，出租车反正都要驶完甲地到乙地的全部路程，因此你到达乙地的时间总等于出租车驶完全程的时间，加上途中接人上车可能耽误的时间。从省事儿的角度来讲，站在原地不动是最好的方案！<br>
    我曾经把这个有趣的问题搬上了《新知客》杂志 2010 年第 9 期的趣题专栏（http://www.matrix67.com/blog/archives/3677）。不少人都找到了这个题的一个 bug ：在某些极端情况下，顺着车的方向往前走可能会更好一些，因为你或许会直接走到终点，而此时出租车根本还没追上你！</p>
<p>    某工厂每天早晨都派小车按时接总工程师上班。有一天，总工程师为了早些到工厂，比平日提前一小时出发步行去工厂。走了一段时间后，遇到来接他的小车才上车继续前进。进入工厂大门后，他发现只比平时早到 10 分钟。总工程师在路上步行了多长时间才遇到来接他的汽车？设人和汽车都做匀速直线运动。</p>
<p style="color:#e5e5e5">    据说，这是一道初中物理竞赛题（初中物理有“运动”一章）。答案是 55 分钟。首先，让我们站在车的角度去想（正如前一题那样）。车从工厂出发，到半途中就遇上了总工程师并掉头往回走，结果只比原来早到 10 分钟。这说明，它比原来少走了 10 分钟的车程，这也就是从相遇点到总工程师家再到相遇点的路程。这就说明，从相遇点到总工程师家需要 5 分钟车程。<br>
    现在，让我们把视角重新放回总工程师那里。让我们假设总工程师遇上了来接他的车并坐上去之后，并没有下令汽车立即掉头，而是让车像平日那样继续开到他家再返回工厂，那么他到工厂的时间应该和原来一样。这说明，他提前出发的那一个小时完全浪费了。这一个小时浪费在哪儿了呢？浪费在了他步行到相遇点的过程，以及乘车又回到家的过程。既然乘车又回到家需要 5 分钟，因此步行的时间就是 55 分钟了。</p>
<p>    有一位隐居在深山老林的哲学家。一天，他忘记给家里唯一的时钟上发条了。由于他家里没有电话、电视、网络、收音机等任何能获知时间的设备，因此他彻底不知道现在的时间是多少了。于是，他徒步来到了他朋友家里坐了一会儿，然后又徒步回到自己家中。此时，他便知道了应该怎样重新设定自己的时钟。他是怎么做的？<br>
    很多人的第一想法或许是观察日出日落。在此，我们也假设通过太阳位置判断时间是不可靠的。 Update: 不少网友找到了此题的一个 bug 。在此我们假设，时钟是固定在墙上的，或者由于太重，无法直接带走。</p>
<p style="color:#e5e5e5">    传统意义上说，这个问题不算行程问题。不过，在写这篇文章时，这个问题立即跳入我的脑海，我也就把它放进来了。<br>
    答案：别忘了，他家里的时钟并不是不走了，只是不准了而已。因此，他可以借助自己家里的时钟，判断他此次出行一共花了多久。假设往返所花时间一样，再结合在朋友那儿看到的正确时间，他便能算出应该怎样调整自己的时钟了。</p>
<p> <br>
还有几个不太相关的经典问题这里没有提到，不过你或许会感兴趣：<br>
汽车穿越沙漠问题：<a href="http://en.wikipedia.org/wiki/Jeep_problem">http://en.wikipedia.org/wiki/Jeep_problem</a><br>
木杆上的蚂蚁：<a href="http://www.matrix67.com/blog/archives/3791">http://www.matrix67.com/blog/archives/3791</a> 计算题1</p>
			 ]]></content>
<pubDate>2012-01-21T23:54:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4881</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Fibonacci数列性质的组合证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/4891</link>
<content><![CDATA[ 
		<p>    数列 1, 1, 2, 3, 5, 8, 13, 21, 34, … 叫做 Fibonacci 数列。这个数列有很多神奇的性质，其中一个性质是，每一个 Fibonacci 数的平方与它前后两个 Fibonacci 数的乘积一定正好相差 1 。具体地说，如果把第 n 个 Fibonacci 数记做 F<sub>n</sub> ，那么有：</p>
<p>      F<sub>n+1</sub> · F<sub>n+1</sub> – F<sub>n</sub> · F<sub>n+2</sub> = (-1)<sup>n</sup></p>
<p>    今天看到了<a href="http://www.cut-the-knot.org/arithmetic/combinatorics/FibonacciTilings.shtml">这个定理的一个组合数学证明</a>，觉得非常有意思，在这里和大家分享。</p>
<p><span id="more-4891"></span><br>
    Fibonacci 数有很多组合数学上的意义。比如说，用 1 × 1 和 1 × 2 的积木覆盖一个 1 × n 的棋盘，总的方案数恰好是 F<sub>n+1</sub> 。下图显示的就是 n 较小时的一些实例：</p>
<p>      <img alt="image placeholder" >
<p>    这个规律背后的原因其实很简单：给出一个长度为 n 的棋盘后，它的覆盖方案可以分成两类，最后边放的是一个 1 × 1 的积木，或者最后边放的是一个 1 × 2 的积木。前一类情况下的方案数也就完全取决于前 n – 1 个格子的覆盖方案数，后一类情况下的方案数则等于前 n – 2 个格子的覆盖方案数。因此，如果用 f(n) 来表示 1 × n 棋盘的覆盖方案数，那么正好就有 f(n) = f(n – 1) + f(n – 2) 。另外，由于 f(1) = 1 ， f(2) = 2 ，因而接下来的数 f(3), f(4), f(5), … 也就恰好构成了 Fibonacci 数列。</p>
<p>      <img alt="image placeholder" >
<p>    既然这样，那么用积木覆盖两个独立的 1 × n 棋盘，总方案数就是 F<sub>n+1</sub> · F<sub>n+1</sub> 。我们有意把这两个独立的棋盘像左图那样摆放。类似地，用积木覆盖一个 1 × (n+1) 棋盘加上另一个 1 × (n-1) 棋盘的总方案数则为 F<sub>n</sub> · F<sub>n+2</sub> ，我们把这两个棋盘放成右图所示的样子。左图的覆盖方案和右图的覆盖方案之间有一种非常巧妙的一一对应关系。</p>
<p>      <img alt="image placeholder" >
<p>    对于左图中的任意一种覆盖方案，我们找出上下两块棋盘中所有位置重合的“公共分割线”，选出最右边的那条公共分割线，然后交换此分割线右侧的部分。这样，左图棋盘的每个覆盖方案就能变成右图棋盘的一个覆盖方案。根据同样的方法，右图棋盘的每个覆盖方案也能变回左图棋盘的覆盖方案，这就说明了 F<sub>n+1</sub> · F<sub>n+1</sub> 和 F<sub>n</sub> · F<sub>n+2</sub> 是相当的。</p>
<p>    等等，那为什么当 n 为偶数时， F<sub>n+1</sub> · F<sub>n+1</sub> 比 F<sub>n</sub> · F<sub>n+2</sub> 要大 1 ，而 n 为奇数时， F<sub>n+1</sub> · F<sub>n+1</sub> 会比 F<sub>n</sub> · F<sub>n+2</sub> 小 1 呢？神就神在这里。这是因为，刚才所说的一一对应关系并不是真的完全一一对应的。当 n 为偶数时，左图棋盘有一例极其特殊的覆盖方案无法对应到右图的棋盘——因为这种方案中根本没有公共分割线。当 n 为奇数时，左图的棋盘就不再有如此特殊的覆盖方案了，但右图棋盘中却又多出了一例没有公共分割线的情况。这就证明了 F<sub>n+1</sub> · F<sub>n+1</sub> – F<sub>n</sub> · F<sub>n+2</sub> = (-1)<sup>n</sup> 。</p>
<p>      <img alt="image placeholder" >
			 ]]></content>
<pubDate>2012-01-27T20:44:04+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4891</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：星际争霸是NP-hard的 ]]></title>
<link>http://www.matrix67.com/blog/archives/4897</link>
<content><![CDATA[ 
		<p>    今天看到<a href="http://arxiv.org/pdf/1201.4995v1.pdf">这里</a>给出了一个“星际争霸是 NP-hard 问题”的一个证明。具体地说，给定一个初始布局（包括地图、双方已有资源、双方已有建筑、双方已有兵力），判断其中一方是否能获胜，这个问题是 NP-hard 的。当然，考虑到即时战略游戏的复杂性，这个结论并不出人意料；真正有趣的，则是如何巧妙地利用游戏中的元素，构造出极其精巧的初始局面，从而转化成某个已知的 NP-complete 问题。下面是原文中给出的证明。这个证明有没有什么漏洞？你还能想到哪些别的证明方法？欢迎在下面留言一同分享。</p>
<p><span id="more-4897"></span><br>
    假设初始时有 A 、 B 两位玩家，他们分别位于两个孤岛上。玩家 B 有非常多的地面兵力，但没有空中单位，并且已有资源为 0 ，而且还没有任何经济来源。他只能坐等玩家 A 来攻打他。玩家 A 一开始则完全没有兵力，但他有不少可以生产作战单位的建筑，也有一定的经济来源，理论上有获胜的希望。地图上还有第三个孤岛，孤岛周边放满 B 的对空防御，玩家 A 即使派遣空中部队也无法进入该孤岛。</p>
<p>    初始时，玩家 A 的资源刚好够造一个农民，玩家 A 还需要收集额外的 x 个单位的资源才足以消灭玩家 B 。但是，玩家 A 的所有可采集资源都在第三个孤岛上。这个孤岛上有 n 个采矿点，每个采矿点都配备有一个基地，以及 x/n 个单位的矿石资源。每个采矿点也都还预先配备了一个农民，只不过这个农民被矿石围在里面出不来了。采矿点与采矿点之间靠一些小路连接，每条路上都有玩家 B 的防御塔，保证一个农民走过去必死无疑，但是两个农民走过去恰好能活一个。</p>
<p>    游戏开始后，玩家 A 唯一获胜的途径便是，在某个采矿点建造一个农民，采完这个采矿点的矿，把被困的农民救出来，然后选择某条小路走到下一个采矿点（途中死掉一个农民），继续采矿并解救农民，以此类推，直到走遍每一个采矿点，采完所有的矿。很容易看到，玩家 A 相当于要解决一个 Hamilton 路的问题（注意，即使平面图的 Hamilton 路问题也是 NP-complete 的）。因此，星际争霸是 NP-hard 的。</p>
			 ]]></content>
<pubDate>2012-01-28T03:07:21+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4897</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 2月14日：送给你的礼物 ]]></title>
<link>http://www.matrix67.com/blog/archives/4911</link>
<content><![CDATA[ 
		<div style="margin:10px" id="love">
<table id="board" style="border-collapse:collapse; width: 276px;"></table>
<p id="iloveyou" style="width:250px; text-align:center"> </p>
<p><script type="text/javascript" src="http://www.matrix67.com/data/scripts/valentine.js"></script></p>
</div>
<p><!-- 没错，小懒猪，这是专门为你写的节日礼物 --></p>
			 ]]></content>
<pubDate>2012-02-14T00:01:16+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4911</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：填写两个声母互相颠倒的词 ]]></title>
<link>http://www.matrix67.com/blog/archives/4922</link>
<content><![CDATA[ 
		<p>    英语当中有一种笑话类型。第一次看到的是：</p>
<blockquote><p> – What’s the difference between a girl in church and a girl in the bathtub?<br>
 – One has hope in her soul, one has soap in her hole.</p></blockquote>
<p>    把我给笑坏了。在说这种笑话的时候，只说一半的效果往往更好。又比如：</p>
<blockquote><p> – What’s the difference between a midget magician and a female jogger?<br>
 – One is a cunning runt…</p></blockquote>
<p>    我想，汉语当中应该也有不少这样的词语对吧。于是，我找来了一份汉语常用词拼音的数据，从中搜索出了一大堆声母颠倒的词语对。喜欢给别人出谜题的我自然没有放过这一机会。请你在下面每句话的两个空格中分别填入两个声母颠倒的双字词，使得整个句子通顺完整。每个小题都有至少一个由常用词构成的解。比如，第一小题的答案就是“宝地”和“倒闭”。</p>
<p>      1. 虽然公司位于一块 _____ ，但最后还是 _____ 了。<br>
      2. 魔术师熟练地从 _____ 里变出了一只 _____ 。<br>
      3. 他知道好几种 _____ 翻新机的 _____ 方法。<br>
      4. 为了磨炼意志，他常常赤身睡在 _____ 铁钉的 _____ 上。<br>
      5. 这种机械化的 _____ 严重 _____ 了学生的创造思维。<br>
      6. 《阿凡达》电影票一票难求，排队买票的 _____ _____ 超过了春运。<br>
      7. 使用过期的 _____ 会 _____ 检测结果有误差。<br>
      8. 前线发来 _____ 称他们已经发现了敌方 _____ 部队。<br>
      9. _____ 的领导者不应该与员工之间有任何 _____ 。<br>
      10. 各个主要 _____ 都有专职护林防火人员 _____ 。<br>
      11. _____ 功能衰退不影响学生正常 _____ 。<br>
      12. 目前，各地塑料 _____ 市场现状一片 _____ 。<br>
      13. 服用戒烟 _____ 药物最好听从医师的 _____ 。<br>
      14. 人体内脏 _____ 业正在美国悄悄 _____ 。<br>
      15. 与 _____ 关系不融洽终会让你逐渐 _____ 对工作的热情。<br>
      16. “民工潮” _____ 的人口 _____ 将不断推进户籍制度的改革。<br>
      17. 表盘上的 6 点钟位置附有非常 ______ 的 _____ 显示。<br>
      18. 她那半月形的银质发箍卡在金色的头发上，远远看去就像是 _____ 时期的 _____ 。<br>
      19. _____ 设计的一个重要应用就是 _____ 设计。<br>
      20. 人们在工地里挖出了那次 _____ 中留下来的一颗 _____ 。</p>
<p><span id="more-4922"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
<!--more--><br>
    答案：<br>
      1. 虽然公司位于一块 _____ ，但最后还是 _____ 了。（宝地，倒闭）<br>
      2. 魔术师熟练地从 _____ 里变出了一只 _____ 。（台布，白兔）<br>
      3. 他知道好几种 _____ 翻新机的 _____ 方法。（鉴别，便捷）<br>
      4. 为了磨炼意志，他常常赤身睡在 _____ 铁钉的 _____ 上。（布满，木板）<br>
      5. 这种机械化的 _____ 严重 _____ 了学生的创造思维。（复述，束缚）<br>
      6. 《阿凡达》电影票一票难求，排队买票的 _____ _____ 超过了春运。（阵势，甚至）<br>
      7. 使用过期的 _____ 会 _____ 检测结果有误差。（试纸，致使）<br>
      8. 前线发来 _____ 称他们已经发现了敌方 _____ 部队。（密电，地面）<br>
      9. _____ 的领导者不应该与员工之间有任何 _____ 。（合格，隔阂）<br>
      10. 各个主要 _____ 都有专职护林防火人员 _____ 。 （山口，看守）<br>
      11. _____ 功能衰退不影响学生正常 _____ 。（嗅觉，就学）<br>
      12. 目前，各地塑料 _____ 市场现状一片 _____ 。（板材，惨白）<br>
      13. 服用戒烟 _____ 药物最好听从医师的 _____ 。（辅助，嘱咐）<br>
      14. 人体内脏 _____ 业正在美国悄悄 _____ 。（清洗，兴起）<br>
      15. 与 _____ 关系不融洽终会让你逐渐 _____ 对工作的热情。（上司，丧失）<br>
      16. “民工潮” _____ 的人口 _____ 将不断推进户籍制度的改革。（掀起，迁徙）<br>
      17. 表盘上的 6 点钟位置附有非常 ______ 的 _____ 显示。（清晰，星期）<br>
      18. 她那半月形的银质发箍卡在金色的头发上，远远看去就像是 _____ 时期的 _____ 。（中古，公主）<br>
      19. _____ 设计的一个重要应用就是 _____ 设计。（平面，名片）<br>
      20. 人们在工地里挖出了那次 _____ 中留下来的一颗 _____ 。（大战，炸弹）</p>
			 ]]></content>
<pubDate>2012-03-01T10:26:26+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4922</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Turing机、人工智能以及我们的世界 ]]></title>
<link>http://www.matrix67.com/blog/archives/4930</link>
<content><![CDATA[ 
		<p>    昨天终于读完了《The Annotated Turing》一书，第一次完整地阅读了 Turing 最经典的那篇论文，理解了 Turing 机提出的动机和由此带来的一系列结论。不过，这本书的最大价值，则是让我开始重新认识和思考这个世界。在这里，我想把我以前积累的哲学观点和最近一些新的思考记下来，与大家一同分享。《The Annotated Turing》一书中的一些学术内容，留待以后几篇日志与大家分享。今年是 Alan Turing 诞辰 100 周年，图灵公司将推出这本书的中译本<a href="http://www.ituring.com.cn/book/801">《图灵的秘密》</a>，现在正在紧张的编辑排版中，不久之后就能和大家见面。</p>
<p>    1928 年， David Hilbert 提出了一个著名的问题：是否存在一系列有限的步骤，它能判定任意一个给定的数学命题的真假？这个问题就叫做 Entscheidungsproblem ，德语“判定性问题”的意思。大家普遍认为，这样的一套步骤是不存在的，也就是说我们没有一种判断一个数学命题是否为真的通用方法。为了证明这一点，真正的难题是将问题形式化：什么叫做“一系列有限的步骤”？当然，现在大家知道，这里所说的“有限的步骤”指的就是由条件语句、循环语句等元素搭建而成的一个机械过程，也就是我们常说的“算法”。不过，在没有计算机的时代，人们只能模模糊糊地体会“一个机械过程”的意思。 1936 年，Alan Turing 在著名的论文《On computable numbers, with an application to the Entscheidungsproblem》中提出了一种假想的机器，第一次给了“机械过程”一个确凿的含义。</p>
<p><span id="more-4930"></span><br>
    Turing 提出的机器非常简单。假设有一张无穷向右延伸的纸条，从左至右分成一个一个的小格子。每一个小格子里都可以填写一个字符（通常是单个数字或者字母）。纸条下方有一个用来标识“当前格子”的箭头，在机器运行过程中，箭头的位置会不断移动，颜色也会不断变化。不妨假设初始时所有格子都是空白，箭头的颜色是红色，并且指向左起第一个格子。为了让机器实现不同的功能，我们需要给它制定一大堆指令。每条指令都是由五个参数构成，格式非常单一，只能形如“如果当前箭头是红色，箭头所在格子写的是字符 A ，则把这个格子里的字符改为 B ，箭头变为绿色并且向右移动一格”，其中最后箭头的移动只能是“左移一格”、“右移一格”、“不动”中的一个。<br>
    精心设计不同的指令集合，我们就能得到功能不同的 Turing 机。你可以设计一个生成自然数序列的 Turing 机，或者是计算根号 2 的 Turing 机，甚至是打印圆周率的 Turing 机。 Turing 本人甚至在论文中实现了这么一种特殊的 Turing 机叫做通用 Turing 机，它可以模拟别的 Turing 机的运行。具体地说，如果把任意一个 Turing 机的指令集用 Turing 自己提出的一种规范方式编码并预存在纸条上，那么通用 Turing 机就能够根据纸条上已有的信息，在纸条的空白处模拟那台 Turing 机的运作，输出那台 Turing 机应该输出的东西。<br>
    但是， Turing 机并不是无所不能的。 Turing 证明了一个看似有些惊人的事实：不存在这样的一个 Turing 机，它能读取任意一个 Turing 机的指令集，并判断该 Turing 机是否将会在纸条上打印出至少一个 0 。注意，简单地用通用 Turing 机做模拟并不是一个可行的方案，因为模拟到现在还没有打出 0 ，不意味着今后也就永远不会打出 0 。这个定理有一个更深刻的含义，即没有一种通用的方法可以预测一台 Turing 机无穷远后的将来（后人把这个结论简化为了著名的<a href="http://www.matrix67.com/blog/archives/55">停机问题</a>）。正如《The Annotated Turing》封底上的一段文字所说：在没有计算机的时代， Turing 不但探索了计算机能做的事，还指出了计算机永远不能做到的事。<br>
    在论文的最后一章， Turing 给出了一种 Turing 机指令集和一阶逻辑表达式的转换规则，使得这个 Turing 机将会打出 0 来，当且仅当对应的一阶逻辑表达式为真。然而，我们没有一种判断 Turing 机是否会输出 0 的算法，因此我们也就没有一种判断数学命题是否为真的通用办法。于是， Entscheidungsproblem 有了一个完美的解答。</p>
<p>    有趣的是，Turing 机本身的提出比 Entscheidungsproblem 的解决意义更大。计算机诞生以后，出现了五花八门的高级编程语言，一个比一个帅气，但它们的表达能力实际上都没有超过 Turing 机。事实上，再庞大的流程图，再复杂的数学关系，再怪异的语法规则，最终都可以用 Turing 机来描述。 Turing 机似乎是一个终极工具，它似乎能够表达一切形式的计算方法，可以描述一切事物背后的规律。在同一时代，美国数学家 Alonzo Church 创立了 λ 算子（λ-calculus），用数学的方法去阐释“机械过程”的含义。后来人们发现， Turing 机和 λ 算子是等价的，它们具有相同的表达能力，是描述“可计算性”的两种不同的模型。 Turing 机和 λ 算子真的能够描述所有直观意义上的“可计算数”、“可计算数列”、“可计算函数”吗？有没有什么东西超出了它们的表达能力？这个深刻的哲学问题就叫做 Church–Turing thesis 。当然，我们没法用形式化的方法对其进行论证，不过大家普遍认为， Turing 机和 λ 算子确实已经具有描述世间一切复杂关系的能力了。人们曾经提出过一些 hypercomputer ，即超出 Turing 机范围的假想机器，比如能在有限时间里运行无穷多步的机器，能真正处理实数的机器，等等。不过这在理论上都是不可能实现的。</p>
<p>    事实上， Turing 在他的论文中就已经指出，人的思维也没有跳出 Turing 机的范围。对此， Turing 有一段非常漂亮的论证：人在思考过程中，总能在任意时刻停下来，把当前进度记录在一张纸上，然后彻底走开并把它完全抛之脑后，过一会儿再回来，并完全凭借纸上的内容拾起记忆，读取进度，继续演算。也就是说，人的每一帧思维，都可以完全由上一帧思维推过来，不依赖于历史的思维过程。而 Turing 机所做的，也就是把人的思维步骤拆分到最细罢了。</p>
<p>    没错，这意味着，或许一个人的语言、计算甚至学习能力，完全等价于一个 Turing 机，只不过这个 Turing 机的指令集可能异常庞大。1950 年， Turing 的另一篇经典论文《Computing Machinery and Intelligence》中正式把人和机器放到了相同的高度：让一个真人 C 先后与一台计算机 A 和另一个真人 B 进行聊天，但事先不告诉他 A 和 B 哪个是机器哪个是人；如果 C 无法通过聊天内容分辨出谁是机器谁是人，我们就认为计算机 A 具有了所谓的人工智能。这就是 Turing 测试。</p>
<p>    计算机拥有智能？这岂不意味着计算机也能学习，也能思考，也拥有喜怒哀乐？人类似乎瞬间失去了不少优越感，于是不少科学家都旗帜鲜明地提出了反对意见。其中最为经典的恐怕要数美国哲学家 John Searle 在 1980 年提出的“中文屋子”思想实验了。把一个不懂汉语的老外关在一个屋子里，屋子里放有足够多的草稿纸和铅笔，以及一本汉语机器聊天程序的源代码。屋子外面则坐着一个地地道道的中国人。屋里屋外只能通过纸条传递信息。老外可以用人工模拟程序运行的方式，与屋外的人进行文字聊天，但这能说明老外就懂中文了吗？显然不能。每次讲到中文屋子时，我往往会换一种更具戏剧效果的说法。一群微软研究员在小屋子里研究代码研究了半天，最后某人指着草稿纸一角的某个数字一拍大腿说，哦，原来屋外的人传进来的是一段笑话！于是，研究员们派一个代表到屋子外面捧腹大笑——但是，显然这个研究员是在装笑，他完全不懂笑点在哪儿。这个例子非常有力地说明了，机器虽然能通过 Turing 测试，但它并不具有真正的智能。</p>
<p>    当然，有反方必有正方。另一派观点则认为，计算机拥有智能是一件理所当然的事。这涉及到一个更为根本的问题：究竟什么是智能？<br>
    记得我曾经看过一本科幻小说，书名不记得了，情节内容也完全不记得了，只记得当我看完小说第一页时的那种震撼。在小说的开头，作者发问，什么是自我意识？作者继续写到，草履虫、蚯蚓之类的小动物，通常是谈不上自我意识的。猫猫狗狗之类的动物，或许会有一些自我意识吧。至于人呢，其实我只敢保证我自己有自我意识，其他人有没有自我意识我就不知道了。看到这里我被吓得毛骨悚然：完全有可能整个世界就只有我一个人有自我意识，其他所有人都是装出一副有意识的样子的无生命物！<br>
    有一次做汉语语义识别的演讲时，讲到利用语义角色模型结合内置的知识库，计算机就能区别出“我吃完了”和“苹果吃完了”的不同，可以推出“孩子吃完了”多半指的是什么。一位听众举手说，难道计算机真的“理解”句子的意思了？我的回答是，没有冒犯的意思，你认为你能理解一个汉语句子的意思对吧，那你怎样证明这一点呢？听众朋友立即明白了。你怎样证明，你真的懂了某一句话？你或许会说，我能对其进行扩句缩句啊，我能换一种句型表达同样的意思啊，我能顺着这句话讲下去，讲出与这句话有关的故事、笑话或者典故，我甚至还能在纸上画出句子里的场景来呢！那好，现在某台电脑也能做到这样的事情了，怎么办？<br>
    这就是所谓的“功能主义”：只要它的输入输出表现得和人一样，不管它是什么，不管它是怎么工作的，哪怕它只是一块石头，我们也认为它是有智能的。永远不要觉得规则化、机械化的东西就没有智能。你觉得你能一拍脑袋想一个随机数，并且嘲笑计算机永远无法生成真正的随机数。但是，你凭什么认为你想的数真的就是随机的呢？事实上，你想的数究竟是什么，这也是由你的大脑机器一步一步产生的。你的大脑逃不出 Turing 机。</p>
<p>    事实上，整个世界也逃不出 Turing 机的范围。 Newton 系统地总结了物体运动规律后，人类豁然开朗，原来世界万事万物都是由“力”来支配的，扔出一个东西后，这个东西将以怎样的路线做怎样的运动，会撞击到哪些其他的物体，它们分别又会受到怎样的影响，这都是可以算出来的。这便是所谓的机械唯物主义：我们的世界是一个简单的、确定的、线性的、无生的世界。 1814 年，法国数学家 Laplace 给出一个更加漂亮的诠释：如果有一个妖精，它知道宇宙某个时刻所有基本粒子的位置和动量，那么它就能够根据物理规律，计算出今后每一时刻整个宇宙的状态，从而预测未来。刘慈欣在科幻小说《镜子》中更加极端地把初始状态取到宇宙大爆炸的时刻，因为宇宙诞生之初的状态极其简单，调整到正确的参数就可以生成我们所处的这个宇宙。这就是所谓的决定论。<br>
    我特别相信这些说法。我的拖延症有一个非常怪异的缘由，那就是我会告诉自己，截止的那一天总会到来的，这堆破事儿总会被我做完的。遇上纠结的问题，我不会做过多的思考，而会让一切顺其自然。其实，结果已经是确定的了，我真正需要做的不过是亲自把这个过程经历一遍。就仿佛我没有自由意志了一样。</p>
<p>    不过，现代物理学的观念，尤其是量子理论的诞生，开始质疑上帝究竟会不会掷骰子了。然而，上帝会不会掷骰子，对于我们来说其实并不重要。 Turing 的结论告诉我们，即使未来是注定的，我们也没有一种算法去预测它，除非模拟它运行一遍。但是，要想模拟这个宇宙的运行，需要的计算量必然超出了这个宇宙自身的所有资源。运行这个宇宙的唯一方式，就是运行这个宇宙本身。 Seth Lloyd 在《Programming the Universe》里说到，“我们体会到的自由意志很像 Turing 的停机问题：一旦把某个想法付诸实践，我们完全不知道它会通向一个怎样的结局，除非我们亲身经历这一切，目睹结局的到来。”</p>
<p>    未来很可能是既定的，但是谁也不知道未来究竟是什么样。每个人的将来依旧充满了未知数，依旧充满了不确定性。所以，努力吧，未来仍然是属于你的。</p>
			 ]]></content>
<pubDate>2012-03-06T12:33:11+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4930</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 正多边形的滚动与旋轮线下方的面积 ]]></title>
<link>http://www.matrix67.com/blog/archives/4955</link>
<content><![CDATA[ 
		<p>    想像一个圆盘在地面上滚动一周，那么圆周上一点所形成的轨迹就叫做旋轮线（或者摆线）。旋轮线下方的面积是多少，这是一个非常有趣的问题。据说， Galileo 曾经用一种非常流氓的方法，推测出了旋轮线下方的面积。他在金属板上切出一块圆片，再在金属板边缘剪下这个圆形所对应的旋轮线，把它们拿到秤上一称，发现后者的重量正好是前者的三倍。于是，他推测，半径为 r 的滚轮所产生的旋轮线，其下方的面积就是 3πr<sup>2</sup> 。</p>
<p>    <img alt="image placeholder" >
<p>    不过，今天我第一次知道，这个结论对于正多边形是同样成立的。</p>
<p><span id="more-4955"></span><br>
    考虑一个正三角形在平地上滚动一周，则原来的顶点 A<sub>1</sub> 将会先后转到 A<sub>2</sub> 和 A<sub>3</sub> 的位置。容易看出， A<sub>1</sub> 、 A<sub>2</sub> 、 A<sub>3</sub> 的连线与地面构成的面积正好是正三角形的三倍。</p>
<p>      <img alt="image placeholder" >
<p>    类似地，让正方形在平地上滚动一周，则原来的顶点 A<sub>1</sub> 将会先后转到 A<sub>2</sub> 、 A<sub>3</sub> 和 A<sub>4</sub> ，这四个点的连线下方的面积也正好是这个正方形的三倍。</p>
<p>      <img alt="image placeholder" >
<p>    另外两个比较简单的情形则是正六边形和正八边形，大家也可以自行验证一下。看来，这里面一定有一个深刻的原因，能够解释为何结论对于任意正 n 边形都成立。</p>
<p>      <img alt="image placeholder" >
<p>      <img alt="image placeholder" >
<p>    让我们先来看另一个看似无关，但仍然非常神奇的结论：假设正多边形的外接圆半径为 r ，从外接圆上任意一点出发，依次与该多边形的 n 个顶点相连，则这 n  条连线的长度的平方和等于 2n · r<sup>2</sup> 。我们来证明这个结论。</p>
<p>    把正多边形的中心放在平面直角坐标系的原点处，把外接圆上的那个点记作 (u, v) ，再假设多边形 n 个顶点的位置分别是 (a<sub>1</sub>, b<sub>1</sub>), (a<sub>2</sub>, b<sub>2</sub>), …, (a<sub>n</sub>, b<sub>n</sub>) ，则这 n 条连线的平方和为</p>
<p>         Σ((u – a<sub>i</sub>)<sup>2</sup> + (v – b<sub>i</sub>)<sup>2</sup>)<br>
      = Σ(u – a<sub>i</sub>)<sup>2</sup> + Σ(v – b<sub>i</sub>)<sup>2</sup><br>
      = n · u<sup>2</sup> – 2u · Σa<sub>i</sub> + Σa<sub>i</sub><sup>2</sup> + n · v<sup>2</sup> – 2v · Σb<sub>i</sub> + Σb<sub>i</sub><sup>2</sup><br>
      = n · (u<sup>2</sup> + v<sup>2</sup>) – 2u · Σa<sub>i</sub> – 2v · Σb<sub>i</sub> + Σ(a<sub>i</sub><sup>2</sup> + b<sub>i</sub><sup>2</sup>)</p>
<p>    显然， u<sup>2</sup> + v<sup>2</sup> 以及所有的 a<sub>i</sub><sup>2</sup> + b<sub>i</sub><sup>2</sup> 都等于 r<sup>2</sup> ，因此上面的式子也就等于了 2n · r<sup>2</sup> – 2u · Σa<sub>i</sub> – 2v · Σb<sub>i</sub> 。接下来，我们只需要说明 Σa<sub>i</sub> 和 Σb<sub>i</sub> 都为 0 即可。其实这是显然的：因为正多边形 n 个顶点的重心在中心 (0, 0) 处，说明这 n 个顶点的所有横坐标之和就是 0 ，所有纵坐标之和也为 0 。</p>
<p>    特别地，把外接圆上的那个点取成正多边形的顶点，于是我们得到，从正 n 边形的某个顶点出发，连接其他 n – 1 个顶点，如果把这 n – 1 条连线分别记作 d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n-1</sub> ，则有：</p>
<p>       d<sub>1</sub><sup>2</sup> + d<sub>2</sub><sup>2</sup> + … + d<sub>n-1</sub><sup>2</sup> = 2n · r<sup>2</sup></p>
<p>    我们利用这个结论来说明，连接正多边形滚动一周后某个顶点依次所达的位置，所得折线段下方的面积恰为该正多边形的三倍。</p>
<p>      <img alt="image placeholder" >
<p>    现在，假设正多边形的外接圆半径为 r ，把这个正多边形的面积记作 A 。如图，折线段下方的面积可以被分成 n – 2 个蓝色三角形和 n – 1 个红色三角形（图中所示的是 n = 9 的情况）。这 n – 2 个蓝色三角形恰好能拼成一个原多边形，它们的面积和为 A 。下面，我们来看一下剩下的 n – 1 个红色三角形都是怎么形成的。正多边形一共转动了 n – 1 次，每一次都是绕着一个新的顶点在转动，这 n – 1 个红色三角形就是在这 n – 1 次转动中产生的。容易看出，每个红色三角形都是等腰三角形，它们的腰长分别为 d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n-1</sub>。同时，由于 n 次转动后正多边形将回到原来的方向，因此每一次正多边形都转过了 (360/n)° 。因此，每个红色等腰三角形的顶角也都是  (360/n)° 。于是你会发现，第 i 个红色三角形的形状与正多边形的其中 1/n 块完全一样，只不过有一个 d<sub>i</sub> : r 的相似比！注意到面积比是相似比的平方，于是所有红色三角形的面积之和为：</p>
<p>         (A/n) · d<sub>1</sub><sup>2</sup> / r<sup>2</sup> + (A/n) · d<sub>2</sub><sup>2</sup> / r<sup>2</sup> + … + (A/n) · d<sub>n-1</sub><sup>2</sup> / r<sup>2</sup><br>
      = (A/n) · (d<sub>1</sub><sup>2</sup> + d<sub>2</sub><sup>2</sup> + … + d<sub>n-1</sub><sup>2</sup>) / r<sup>2</sup><br>
      = (A/n) · 2n · r<sup>2</sup> / r<sup>2</sup><br>
      = 2A</p>
<p>    因此，折线下方的面积是 3A ，即原正多边形面积的三倍。当 n 趋于无穷的时候，我们便又回到了 Galileo 所发现的那个结论。</p>
			 ]]></content>
<pubDate>2012-04-06T19:44:08+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4955</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：八根并排放置的水管 ]]></title>
<link>http://www.matrix67.com/blog/archives/4966</link>
<content><![CDATA[ 
		<p>    下面这个有趣的问题来自于 2012 年 4 月的 <a href="http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/Challenges/April2012.html">IBM Ponder This 谜题</a>。</p>
<p>    有 8 根很长的并且颜色不同的水管并排放在一起， A 、 B 两人分别位于这些水管的两端。两个人手中各有若干根很短的橡皮管，他们可以用这些橡皮管任意连接自己这一侧的水管口。 A 的旁边还有一个水龙头， A 可以用橡皮管把水龙头与自己这一侧的其中一个水管口相连。</p>
<p>    A 、 B 两人各将获得一个五位 01 串，然后两人可以根据自己手中的 01 串来连接水管口。当 A 打开水龙头后，容易看出，水必然会从其中一侧流出。两人需要保证，如果两人手中的 01 串相等，则水从 A 的一侧流出，否则水从 B 的一侧流出。他们事先可以商量一个策略，但游戏一旦开始，两人一旦拿到各自的 01 串之后，就不允许再交流了（因此两人都不知道对方手中的 01 串是什么）。请你想出一个能保证两人获胜的策略。</p>
<p><span id="more-4966"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    让我们先来看另一个问题。假如 A 、 B 之间有 4 根水管，他们各自将获得一个 0 到 5 之间的整数，如何才能让水从 A 侧流出，当且仅当两人手里的整数相等？注意到，从 4 根水管中选出 2 根共有 6 种方案，两人可以事先约定好，每个整数分别代表连接哪两根水管。游戏开始后， B 把他手中的整数所对应的“水管对”连接起来， A 也找出自己手中的整数所对应的两根水管，并把其中一个记为“入口”，把另一个记为“出口”，然后把另外的两根水管连接上。 A 把水龙头接到“入口”，如果 A 、 B 两人的数相等，水将会从“出口”流出。</p>
<p>    好了。实际上， A 、 B 之间将会有 8 根水管，每 4 根水管能处理 6 个数的情况， 8 根水管不就能处理 36 个数的情况了吗？ A 、 B 两人可以把 0 到 35 的整数想成是一个两位的六进制数，并约定好哪 4 根水管代表低位，哪 4 根水管代表高位。这样，两人不就能判断出低位和高位是否分别相等了吗？</p>
<p>    但是这里有一个问题： A 那里只有一个水龙头，而上述方案需要给高位和低位各一个水龙头。我们需要想个办法把“低位出水”和“高位出水”做一个逻辑与的运算。接下来的一步就牛了： A 可以把水龙头接到低位的“入口”，再把低位的“出口”接到高位的“入口”。如果 A 、 B 手中的数完全相等，水最终会从高位的“出口”流出。</p>
<p>    五位 01 串共有 32 种可能，因而原问题自然也就解决了。</p>
			 ]]></content>
<pubDate>2012-05-25T10:31:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4966</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：把矩形分割为面积相同但形状各不相同的小矩形 ]]></title>
<link>http://www.matrix67.com/blog/archives/4971</link>
<content><![CDATA[ 
		<p>    Using your Head is Permitted 数学谜题站的主持人 Michael Brand 某日收到了来自 R. Nandakumar 的一个谜题：是否有可能把一个矩形剖分成若干个小矩形，使得每个小矩形的形状互不相同，但它们的面积都一样？没有想到，从这个问题出发，加上一些非常机智巧妙的分析与构造，我们能得到越来越多有意思的东西。于是，它就变成了 Using your Head is Permitted <a href="http://www.brand.site.co.il/riddles/201203q.html">今年 3 月的谜题</a>。看了谜题的答案后，我也被彻底折服，决定把这一系列的思考重述在此，和大家一同分享。为了简便起见，下面的“矩形剖分方案”一律指的是把一个大矩形分割成若干个小矩形的方案。</p>
<p><span id="more-4971"></span><br>
    让我们先来看一个无关的问题。如果一个矩形剖分方案中不含“子矩形”，我们就说这是一个基本的矩形剖分方案。一个基本的矩形剖分中可能含有多少个小矩形？最平凡的当然是含有 2 个小矩形的基本矩形剖分，最典型的则是含有 5 个小矩形的基本矩形剖分。</p>
<p>      <img alt="image placeholder" >
<p>    对后者继续扩展，我们还能得到含有 7 个小矩形、 8 个小矩形的基本矩形剖分。事实上，对于所有 n = 2 、 n = 5 和 n ≥ 7 的情况，恰好含有 n 个小矩形的基本矩形剖分都是存在的，它们都可以看作是把小矩形螺旋状一圈一圈向外摆放得到的结果。我们下面证明，含有其他数量的小矩形不可能成为基本的矩形剖分方案。这个结论可以用繁冗的分类讨论甚至是计算机程序枚举来完成。我们尽可能用简单巧妙的方法，让证明变得更加可读一些。不感兴趣的读者可以跳过。</p>
<p>    考虑某个矩形剖分方案中所有的水平线段。我们把整个大矩形最下面和最上面的两条边叫做边界线段，把其余的水平线段叫做内部线段，并计算这些内部线段一共有多少个不同的纵坐标，把不同纵坐标的个数记作 m 。注意到，如果小矩形的个数 n &gt; 2 ，那么一条边界线段绝不可能被某个小矩形完全霸占（否则会产生子矩形）。每条边界线段一定都被分给了至少两个小矩形。另外，每条内部线段一定都共享给了三个小矩形。如果某条内部线段只被一上一下两个小矩形所用，这两个小矩形就已经构成了子矩形。</p>
<p>    于是我们得到，所有小矩形累计有至少 4 + 3m 条水平边。由于每个小矩形有两条水平边，因此小矩形的个数应该满足 n ≥ (4 + 3 m) / 2 。</p>
<p>    如果 m ≥ 3 ，则 n ≥ 7 ；如果 m = 2 ，则 n ≥ 5 。另外， m 是不可能等于 1 的，如果矩形剖分里所有的内部线段都在同一个水平位置，那么或者这是一整条从左至右拦腰截断大矩形的线段，从而导致子矩形的出现；或者是一条没能连通左右边界，在中间断开过的线段，这意味着存在一个从上到下贯通整个大矩形的小矩形，同样会导致子矩形的出现。</p>
<p>    为了完成我们的证明，我们只剩下 m = 2 并且 n = 6 的情况有待讨论。对竖直边应用相同的推理，可知在此情况下，竖直边也只能有两种不同的横坐标。换句话说，整个矩形剖分只分三层，只有三列，以下面这个 3 × 3 正方形为“模子”。</p>
<p>      <img alt="image placeholder" >
<p>    我们需要把这 9 个格子划作 6 个小矩形，因而至少 3 个小矩形只占一个格子。不妨把这种只占一个格子的小矩形叫做孤立矩形吧。首先，各边中间的格子（即 B 、 D 、 F 、 H）都不能成为孤立矩形。比如，如果 B 是孤立矩形的话，那么 A 、 D 不得不合成一个小矩形， C 、 F 也不得不合成一个小矩形，于是 B 和 E 或者 E 所在的小矩形就构成了子矩形。其次，同侧两个角上的格子也不能同时成为孤立矩形。如果 A 和 C 是孤立的，那么 B 必须和 E 组合起来，从而 A 和包含了 D 的小矩形将构成子矩形。最后，孤立矩形也不能是 A 、 E 、 I 或者 C 、 E 、 G ，否则剩下的形状至少也要被划成 4 个小矩形，总的小矩形个数会超过 6 个。这下，我们便排除了所有的情况。</p>
<p>    因此，当且仅当 n = 2, 5, 7, 8, 9, … 时，才存在包含 n 个小矩形的基本矩形剖分。</p>
<p> </p>
<p>    我们准备好回答本文开头提出的问题了：是否有可能把一个矩形剖分成若干个小矩形，使得每个小矩形的形状互不相同，但它们的面积都一样？自然地，我们更希望找到最简单的、所含小矩形最少的剖分。首先注意到，如果满足条件的矩形剖分包含有子矩形，则这个子矩形同样满足条件。因此，小矩形个数最少的剖分方案必须得是基本的。因此， n 为 3 、 4 、 6 的情况都不用再考虑了。显然，把一个矩形分成面积相等的两个小矩形，它们必然全等，因此 n =2 也就不用考虑了。我们下面要考虑的是 n = 5 的情况。</p>
<p>    注意到 n = 5 的基本剖分只能发生在 m = 2 的情况下，因而它仍然是以上图中的九宫格为模子的。据此容易验证，如果把镜像也考虑进来的话，本质不同的剖分就只有一种，就是本文最开头给出的那个图（这里就不再证明了）。为了找出一个所有小矩形面积都相等的剖分，我们假设中间那个小矩形的高为 1 ，宽为 x ，从而小矩形的面积也都得是 x 了。再假设紧邻其右的小矩形宽为 y ，于是所有小矩形的宽和高都能顺次表示出来了：</p>
<p>    <img alt="image placeholder" >
<p>    可惜的是，求解 x 和 y 的关系，却发现这个方程没有正数解：</p>
<p>    <img alt="image placeholder" >
<p>    对 n = 7 的情况可以做出类似的分析：</p>
<p>    <img alt="image placeholder" >
<p>    不过这一次，方程有解了：</p>
<p>    <img alt="image placeholder" >
<p>    Using your Head is Permitted 给出的解答精心选择了 1 、 x 和 y 的值，使得整个大矩形恰好是一个单位正方形，并且此时所有小矩形正好都互不全等，如下图所示：</p>
<p>    <img alt="image placeholder" >
<p>    其实这个图历史上已经有人研究过了。它叫做 Blanche’s Dissection ，可以参见<a href="http://mathworld.wolfram.com/BlanchesDissection.html">这里</a>。</p>
<p>    我们最后的问题就是，对于哪些其他的 n ，小矩形面积都相同但形状互不相同的剖分仍然存在呢？答案是，对于其他所有大于 7 的 n ，满足要求的剖分都是存在的。当 n = 8 时，只需要在上图的最顶部摞一个占满整个宽度并且面积相同的小矩形。当 n = 9 时，则在 n = 8 的构造解的左边加一个占满整个高度并且面积相同的小矩形，以此类推。每一个新加上去的小矩形，其宽度（或者高度）都超过了之前的所有小矩形，因此不会直接与之前的小矩形全等。但是，万一这个新小矩形的宽度恰好等于之前某个小矩形的高度呢？由于所有小矩形的面积都相等，这就意味着前者的高度也将正好等于后者的宽度，这也会导致两个小矩形全等。会不会出现这样的情况还真不敢肯定，不过即使出现了这样的情况，我们也有一个非常巧妙的方法来挽救局面。我们可以对整个矩形进行任意的拉伸（甚至改变原来的长宽比），所有小矩形的面积仍然是相同的。保持整个矩形的高度不变，调整整个矩形的宽度，使得每个小矩形的宽度都不等于任意一个小矩形的高度（比如说，直接把矩形拉到足够宽，使得最小的宽都比整个大矩形的高度更长）。这样一来，所有大于等于 7 的 n 都有了构造解。</p>
<p>    不过，问题并没有就此结束。还有哪些本质不同的构造解？是否存在一个有理的解？这都是非常有趣的话题。</p>
			 ]]></content>
<pubDate>2012-05-27T13:12:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4971</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：几乎所有有理数都是无理数的无理数次方 ]]></title>
<link>http://www.matrix67.com/blog/archives/4984</link>
<content><![CDATA[ 
		<p>    一个无理数的无理数次方是否有可能是一个有理数？这是一个非常经典的老问题了。答案是肯定的，证明方法非常巧妙：考虑根号 2 的根号 2 次方。如果这个数是有理数，问题就已经解决了。如果这个数是无理数，那么就有：</p>
<p>      <img alt="image placeholder" >
<p>    我们同样会得到一个无理数的无理数次方是有理数的例子。</p>
<p>    这是一个典型的非构造性证明的例子：我们证明了无理数的无理数次方有可能等于有理数，但却并没有给出一个确凿的例子。毕竟我们也不知道，真实情况究竟是上述推理中的哪一种。那么，真实情况<strong>究竟</strong>是上述推理中的哪一种呢？ Gelfond-Schneider 定理告诉我们，假设 α 和 β 都是代数数，如果 α 不等于 0 和 1 ，并且 β 不是有理数，那么 α 的 β 次方一定是超越数。根据这一定理我们可以立即看出，根号 2 的根号 2 次方真的是一个无理数，实际情况应该是上述推理中的后者。</p>
<p>    那么，是否存在一个无理数 a ，使得 a 的 a 次方是有理数呢？最近， Stan Dolan 证明了这样一个结论：事实上，几乎所有 (1, ∞) 里的有理数都是某个无理数 a 的 a 次方。</p>
<p><span id="more-4984"></span><br>
    注意到当 x 大于 1 时，函数 f(x) = x<sup>x</sup> 是连续单调递增的，因而对于所有 (1, ∞) 里的有理数 r ，一定存在唯一的 a ，使得 a<sup>a</sup> = r 。不妨假设 a 是一个有理数，它的最简分数形式是 n / m 。如果 m = 1 ，那么我们会有平凡解 n<sup>n</sup> = r 。下面我们证明， m 是不可能大于 1 的，否则会产生矛盾。</p>
<p>    假设有理数 r 的最简分数形式是 c / b ，于是我们有：</p>
<p>      (n / m)<sup>n / m</sup> = c / b</p>
<p>    或者说：</p>
<p>      n<sup>n</sup> · b<sup>m</sup> = m<sup>n</sup> · c<sup>m</sup></p>
<p>    注意到， m<sup>n</sup> 是 n<sup>n</sup> · b<sup>m</sup> 的约数。然而， m 和 n 是互质的， m<sup>n</sup> 与 n<sup>n</sup> 没有公共因子，因而 m<sup>n</sup> 一定是 b<sup>m</sup> 的约数。同理， b<sup>m</sup> 是 m<sup>n</sup> · c<sup>m</sup> 的约数，但由于 b 和 c 是互质的，因此 b<sup>m</sup> 一定是 m<sup>n</sup> 的约数。 m<sup>n</sup> 和 b<sup>m</sup> 怎么可能互为对方的约数呢？只有一种可能，就是 m<sup>n</sup> 等于 b<sup>m</sup> 。</p>
<p>    既然 m<sup>n</sup> = b<sup>m</sup> ，说明 m 和 b 肯定有大于 1 的公因数。假设 p 是 m 和 b 的某个公共质因数。我们把 m 和 b 中的所有质因数 p 都提出来，将它们写成 m = p<sup>i</sup> · k 和 b = p<sup>j</sup> · l ，其中 k 和 l 都不再含有质因数 p 。于是， m<sup>n</sup> = b<sup>m</sup> 就可以重新写为：</p>
<p>      p<sup>i·n</sup>  · k<sup>n</sup> = p<sup>j·m</sup> · l<sup>m</sup></p>
<p>    既然 m<sup>n</sup> 是等于 b<sup>m</sup> 的，它们一定含有相同数量的质因数 p ，因而 i·n = j·m ，可知 m 是 i·n 的约数。但是 m 和 n 是互质的，因此 m 一定是 i 的约数。最后，注意到 p<sup>i</sup> 是 m 的约数，从而也就是 i 的约数。于是矛盾产生了：由于 p ≥ 2 ，因此 p<sup>i</sup> 一定严格地大于 i ，不可能是它的约数。</p>
<p>    因此，对于所有大于 1 的有理数，除非它恰好等于某个整数 n 的 n 次方，否则它都将是某个无理数 a 的 a 次方。</p>
<p> <br>
来源：<a href="http://www.mathteacherctk.com/blog/2012/04/a-representation-of-rational-numbers/">http://www.mathteacherctk.com/blog/2012/04/a-representation-of-rational-numbers/</a></p>
			 ]]></content>
<pubDate>2012-05-31T23:25:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/4984</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：构造多边形使得过边界上某一点的任意直线均能等分面积 ]]></title>
<link>http://www.matrix67.com/blog/archives/5004</link>
<content><![CDATA[ 
		<p>    这是 2008 年莫斯科数学竞赛中的一个问题。构造一个多边形，使得这个多边形的边界上存在这样的一个点 O ：经过点 O 的任意直线均会把该多边形分成面积相等的两部分。这看起来不大可能对吧？但其实构造却并不困难。你能想出来吗？</p>
<p><span id="more-5004"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    <img alt="image placeholder" >
<p>    首先，在平面直角坐标系的第一象限内，沿着坐标轴放置一个等腰直角三角形。在第二象限内，拼接一个面积相等的等腰梯形。在第三象限和第四象限内，继续摆放面积相等的等腰梯形，并且让它们离原点越来越远，以保证最终所得的图形确实是一个多边形（而不是一块环形区域）。现在，把平面直角坐标系的原点记作点 O ，则过点 O 的任意一条直线都将把整个多边形分成面积相等的两份。</p>
<p> <br>
    <img alt="image placeholder" >
<p>    为了验证这一点，我们举一个例子。如上图，过点 O 作一条过一三象限的直线。容易看出，三角形 OAB 的面积占了三角形 OPB 面积的几分之几，三角形 OCD 的面积就占了三角形 OQD 面积的几分之几，同样地三角形 OEF 的面积就占了三角形 ORF 面积的几分之几，从而梯形 CDFE 的面积就是梯形 QDFR 的几分之几。由于三角形 OPB 的面积等于梯形 QDFR 的面积，因此三角形 OAB 的面积也就总是等于梯形 CDFE 的面积。自然，三角形 OAP 的面积也等于梯形 QCER 的面积了。而第二象限和第四象限的图形面积也是相等的，因此这条直线两侧的面积总和相等。类似的，过点 O 作其他方向上的直线，直线两侧的面积也相等，道理是一样的。</p>
<p> <br>
来源：<a href="http://www.mathteacherctk.com/blog/2012/05/a-crooked-polygon/">http://www.mathteacherctk.com/blog/2012/05/a-crooked-polygon/</a></p>
			 ]]></content>
<pubDate>2012-06-03T22:06:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5004</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 几个精彩的数论问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/5013</link>
<content><![CDATA[ 
		<p>从同事那里借来了一本单墫教授￼主编的《初等数论》奥数书，看到很多精彩的问题，在这里做个笔记，与大家一同分享。不少问题和答案都有过重新叙述，个别问题有所改动。</p>
<p> <br>
问题：找出所有使得 2<sup>n</sup> – 1 能被 7 整除的正整数 n 。</p>
<p>答案：由于 2<sup>n</sup> 的二进制表达为 1000…00 （n 个 0），因此 2<sup>n</sup> – 1 的二进制表达为 111…11 （n 个 1）。而 7 的二进制表达是 111 ，要想让它整除 n 个 1 ，显然 n 必须是也只能是 3 的倍数。</p>
<p><span id="more-5013"></span><br>
问题：是否存在 100 个数，使得它们的和等于它们的最小公倍数？</p>
<p>答案：是的。考虑 3, 2 × 3, 2 × 3<sup>2</sup> , 2 × 3<sup>3</sup>, …, 2 × 3<sup>98</sup>, 3<sup>99</sup> ，它们的和为：</p>
<p>     3 + 2 × 3 + 2 × 3<sup>2</sup> + 2 × 3<sup>3</sup> + … + 2 × 3<sup>98</sup> + 3<sup>99</sup><br>
  = 3 × (1 + 2) + 2 × 3<sup>2</sup> + 2 × 3<sup>3</sup> + … + 2 × 3<sup>98</sup> + 3<sup>99</sup><br>
  = 3<sup>2</sup> + 2 × 3<sup>2</sup> + 2 × 3<sup>3</sup> + … + 2 × 3<sup>98</sup> + 3<sup>99</sup><br>
  = 3<sup>2</sup> × (1 + 2) + 2 × 3<sup>3</sup> + … + 2 × 3<sup>98</sup> + 3<sup>99</sup><br>
  = 3<sup>3</sup> + 2 × 3<sup>3</sup> + … + 2 × 3<sup>98</sup> + 3<sup>99</sup><br>
  = … …<br>
  = 3<sup>99</sup> + 3<sup>99</sup><br>
  = 2 × 3<sup>99</sup></p>
<p>而这 100 个数的最小公倍数正是 2 × 3<sup>99</sup> 。</p>
<p> <br>
问题：能否找出 100 个不同的正整数，使得其中任意 2 ≤ k ≤ 100 个数的算术平均数都恰为整数。</p>
<p>答案：能。这个问题非常唬人，它的答案异常简单： 1 · 100!, 2 · 100!, 3 · 100!, …, 100 · 100! 显然满足要求。</p>
<p> <br>
问题：求证，存在任意长的连续正整数，使得其中任何一个数都不是质数的幂（当然更不能是质数）。</p>
<p>答案。有一个经典的问题是，求证存在任意长的连续正整数，它里面不包含任何质数。换句话说，相邻质数的间隔可以达到任意大。构造的方法堪称经典。显然 n! + 2 是 2 的倍数（因为我们可以提出一个 2 来）， n! + 3 是 3 的倍数，等等。因此， n! + 2, n! + 3, n! + 4, …, n! + n 就是 n – 1 个连续的正整数，其中任意一个数都不是质数。由于 n 可以任意大，因此这个数列可以任意长。</p>
<p>现在，我们要证明的是一个更强的结论。我们可以把刚才的构造方案简单地修改一下。只需要考虑 (n!)<sup>2</sup> + 2, (n!)<sup>2</sup> + 3, (n!)<sup>2</sup> + 4, …, (n!)<sup>2</sup> + n ，则其中每一个数都不是质数的幂。比如说 (n!)<sup>2</sup> + 5 ，显然它是 5 的倍数，因为我们可以提出一个 5 来；然而提出一个 5 之后将会得到 5 · (1<sup>2</sup> · 2<sup>2</sup> · 3<sup>2</sup> · 4<sup>2</sup> · 5 · 6<sup>2</sup> · … · n<sup>2</sup> + 1) ，括号里的数显然不再是 5 的倍数，它除以 5 余 1 。</p>
<p>利用中国剩余定理，我们还能给出另一种非常巧妙的构造方案，它能找出 n 个不含质数幂的连续正整数数列，其中 n 可以任意大。我们只需要保证，每个数都含有至少两个不同的质因数即可。取 2n 个不同的质数 p<sub>1</sub>, p<sub>2</sub>, …, p<sub>n</sub>, q<sub>1</sub>, q<sub>2</sub>, …, q<sub>n</sub> ，显然 p<sub>1</sub> · q<sub>1</sub>, p<sub>2</sub> ·  q<sub>2</sub>, …, p<sub>n</sub> · q<sub>n</sub> 是两两互质的 n 个数。由中国剩余定理，我们能找到一个正整数 M ，使得 M 除以 p<sub>1</sub> · q<sub>1</sub> 余 1 ，并且 M 除以 p<sub>2</sub> · q<sub>2</sub> 余 2 ，并且 M 除以 p<sub>3</sub> · q<sub>3</sub> 余 3 ，一直到 M 除以 p<sub>n</sub> · q<sub>n</sub> 余 n 。于是， M – 1, M – 2, M – 3, …, M – n 就是 n 个连续的正整数，其中每一个都含有两个不同的质因数。</p>
<p> <br>
问题：求证，对于任意大的 n ，我们都能够找出 n 个两两互质的数，使得任意 2 ≤ k ≤ n 个数之和都不是质数</p>
<p>答案：如果只要求任意多个数之和都不是质数，这很好办：让所有数都是某个数的倍数即可。但是，如果这些数必须两两互质，同样的要求还能办到吗？可以的。考虑 n! + 1, 2 · (n!) + 1, 3 · (n!) + 1, …, n · (n!) + 1 这 n 个数，显然任意 k 个数之和都是 k 的倍数，因而不是质数。下面说明这 n 个数两两互质。假设 i · (n!) + 1 和 j · (n!) + 1 有公共的质因数 p ，其中 1 ≤ i &lt; j ≤ n ，那么它们的差 (j - i) ·  (n!) 也能被 p 整除，说明 p 只能是不超过 n 的质数。这与 p 能整除 i · (n!) + 1 矛盾。

 
问题：证明，对于任意正整数 n ，方程 x<sup>2</sup> + y<sup>2</sup> = z<sup>n</sup> 都有无穷多组正整数解。</p>
<p>答案：考虑 x + yi = (a + bi)<sup>n</sup> ，其中 i 为虚数单位。对于每一个固定的 n ，只要 a 和 b 都是整数，那么展开后得到的 x 和 y 也都一定是整数。我们选取充分大的 a ，让 a + bi 的辐角非常小非常小（小于 π/2 的 n 分之一），从而让 (a + bi)<sup>n</sup> 不会与坐标轴重合，因而保证 x 和 y 都是非零整数。等式两边同时取模，便有 x<sup>2</sup> + y<sup>2</sup> = (a<sup>2</sup> + b<sup>2</sup>)<sup>n</sup></p>
<p> <br>
问题：我们把平面直角坐标系上所有横纵坐标互质的整格点（也就是和原点的连线不经过其他点的整格点）叫做“既约格点”。证明，对于任意大的正整数 n ，总存在一个整格点，它到任意既约格点的距离都大于 n （换句话说，既约格点集的“空洞”可以达到任意大）。</p>
<p>答案：列一张 (2n + 1) × (2n + 1) 的表，每个格子里面填写一个不同的质数（由于质数无穷多，这是总可以办到的）。现在，找出这样的一个 a ，它除以第 i 行的质数总是余 i （其中 – n ≤ i ≤ n ）。找出这样的一个 b ，它除以第 j 列的质数总是余 j （其中 -n ≤ j ≤ n）。中国剩余定理保证了这样的 a 和 b 是存在的。下面说明，点 (a, b) 满足要求。</p>
<p>  <img alt="image placeholder" >
<p>假如 (a, b) 到 (x, y) 的距离不超过 n ，则 (a – x)<sup>2</sup> + (b – y)<sup>2</sup> ≤ n<sup>2</sup> 。因而， a – x 和 b – y 都必须在 – n 到 n 的范围内。把 a – x 的值记作 i ，把 b – y 的值记作 j ，那么 x 就等于 a – i ， y 就等于 b – j ，由 a 、 b 的构造可知， x 和 y 都是表格中第 i 行第 j 列的那个质数的倍数，故 (x, y) 不是既约格点。</p>
<p> <br>
问题：找出所有这样的正整数序列 (a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub>) ，它们的和为 2n ，但我们无法把它们分成和相等的两组。</p>
<p>答案：考虑 a<sub>1</sub>, a<sub>2</sub>, a<sub>1</sub> + a<sub>2</sub>, a<sub>1</sub> + a<sub>2</sub> + a<sub>3</sub>, …, a<sub>1</sub> + a<sub>2</sub> + a<sub>3</sub> + … + a<sub>n</sub> ，除了 a<sub>1</sub> 和 a<sub>2</sub> 以外，这些数除以 n 的余数不允许相等，否则它们的差就是 n 的倍数，我们就找到了和为 n 的子集。然而，上面一共有 n + 1 个数，它们除以 n 的余数必然有相等的，因而一定是 a<sub>1</sub> 和 a<sub>2</sub> 除以 n 的余数相等。类似地， a<sub>2</sub> 和 a<sub>3</sub> 除以 n 的余数也相等， a<sub>3</sub> 和 a<sub>4</sub> 除以 n 的余数也相等，因而事实上从 a<sub>1</sub> 到 a<sub>n</sub> 所有的数除以 n 的余数都是相等的。</p>
<p>但是这 n 个数加起来只有 2n ，可见所有的数除以 n 的余数只可能都是 1 或者都是 2 。于是我们得到了所有满足要求的数列： (1, 1, 1, …, 1, n + 1) ，以及 (2, 2, 2, …, 2) 。其中后者要求 n 为奇数。</p>
<p> <br>
问题：证明，存在无穷多个正整数三元组 (a, b, c) ，使得 a<sup>2</sup> + b<sup>2</sup> 、 b<sup>2</sup> + c<sup>2</sup> 、 a<sup>2</sup> + c<sup>2</sup> 都是完全平方数。</p>
<p>答案：任取一组勾股数 (x, y, z) ，令 a = x|4y<sup>2</sup> – z<sup>2</sup>| ， b = y|4x<sup>2</sup> – z<sup>2</sup>|， c = 4xyz 。于是，</p>
<p>  a<sup>2</sup> + b<sup>2</sup> = x<sup>2</sup>(3y<sup>2</sup> – x<sup>2</sup>)<sup>2</sup> + y<sup>2</sup>(3x<sup>2</sup> – y<sup>2</sup>)<sup>2</sup><br>
             = x<sup>6</sup> + 3x<sup>2</sup>y<sup>4</sup> + 3x<sup>4</sup>y<sup>2</sup> + y<sup>6</sup><br>
             =(x<sup>2</sup> + y<sup>2</sup>)<sup>3</sup> = (z<sup>3</sup>)<sup>2</sup><br>
  a<sup>2</sup> + c<sup>2</sup> = x<sup>2</sup>(4y<sup>2</sup> + z<sup>2</sup>)<sup>2</sup><br>
  b<sup>2</sup> + c<sup>2</sup> = y<sup>2</sup>(4x<sup>2</sup> + z<sup>2</sup>)<sup>2</sup></p>
<p>从而 a 、 b 、 c 满足要求。由于勾股数有无穷多组，因此满足要求的 (a, b, c) 也有无穷多组。</p>
<p>这相当于给出了 Euler 砖块（所有棱长和所有面对角线都是整数的长方体）的一种构造解。当 (x, y, z) = (3, 4, 5) 时，我们将得到棱长分别为 117 、 44 、 240 的 Euler 砖块，这就是最小的 Euler 砖块，它是由 Paul Halcke 在 1719 年发现的。</p>
<p>大家或许会想，有没有什么长方体，不但所有棱长和所有面对角线都是整数，连体对角线也是整数呢？这样的长方体就叫做完美长方体。有趣的是，虽然 Euler 砖块有无穷多种，但是人们目前还没有找到哪怕一个完美长方体。完美长方体究竟是否存在，目前仍然是一个未解之谜。</p>
<p> <br>
问题：证明，若正整数 a 和 b 互质，则 [b / a] + [2b / a] + [3b / a] + … + [(a – 1) b / a] = (a – 1)(b – 1) / 2 。其中， [n] 是 n 的整数部分，即对 n 取下整。</p>
<p>答案：我们先举一个例子来说明这个问题的复杂性。数列 [b / a], [2b / a], [3b / a], …, [(a – 1) b / a] 的规律并不一定非常明确。例如，当 a = 17 且 b = 12 时， [12 / 17], [2 · 12 / 17], [3 · 12 / 17], … [16 · 12 / 17] 分别为 0, 1, 2, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 9, 10, 11 ，但这 16 个数之和为 88 ，正好是 16 和 11 乘积的一半。</p>
<p>  <img alt="image placeholder" >
<p>结论的证明很有意思。在平面直角坐标系的第一象限摆放一个宽为 a ，高为 b 的矩形。则 [k · b / a] 就是图中第 k 条红色竖直线上的整格点数目，所有 [k · b / a] 之和也就是阴影三角形内的整格点总数。然而由于 a 和 b 互质，矩形的对角线不会经过矩形内部的任何格点，因此阴影三角形内的整格点数就应该是矩形内的整格点数的一半，即 (a – 1)(b – 1) / 2。</p>
<p> <br>
问题：若正无理数 α 和 β 满足 1 / α + 1 / β = 1 ，求证数列 [1 · α], [2 · α], [3 · α], … 和 [1 · β], [2 · β], [3 · β], … 既无重复又无遗漏地包含了所有的正整数。这里 [ ] 同样是取下整的意思。</p>
<p>答案：让我们先来看一个例子吧。考虑黄金比例 φ = (√<span style="text-decoration:overline">5</span> + 1) / 2 ≈ 1.618 ，我们有 1 / φ + 1 / (φ + 1) = 1 。数列 [1 · φ], [2 · φ], [3 · φ], … 为 1, 3, 4, 6, 8, 9, 11, 12, 14, 16, 17, … ，而数列 [1 · (φ + 1)], [2 · (φ + 1)], [3 · (φ + 1)], … 则为 2, 5, 7, 10, 13, 15, 18, 20, 23, 26, … 。你会发现，前一个数列里没有的数，正好都在后一个数列里，而后一个数列里没有的数，前一个数列里正好都有。两个数列合在一起，就是整个正整数序列。</p>
<p>这个定理叫做 Beatty-Rayleigh 定理，它有很多种证明，其中两种证明参见 <a href="http://en.wikipedia.org/wiki/Beatty_sequence">Wikipedia</a> 。这里给出一种我非常喜欢的证明，它出自 <a href="http://www.brand.site.co.il/riddles/201204a.html">Using your Head is Permitted</a> 。</p>
<p>首先注意到，如果 x 和 y 都不是整数，那么 [x] 严格地小于 x ，[y] 严格地小于 y ，从而 [x] + [y] &lt; x + y 。另外，[x] 一定严格地大于 x – 1 ， [y] 一定严格地大于 y – 1 ，从而 [x] + [y] 一定严格地大于 x + y – 2。这说明，当 x 和 y 都不是整数时， [x] + [y] 将介于 x + y – 2 和 x + y 之间。</p>
<p>回到原问题。显然，在第一个数列中，小于 n 的正整数有 [n / α] 个。显然，在第二个数列中，小于 n 的正整数有 [n / β] 个。因此，在这两个数列中，小于 n 的正整数共有 [n / α] + [n / β] 个。由于 α 和 β 都是无理数，因此 n / α 和 n / β 不可能为整数，由刚才的结论， [n / α] + [n / β] 一定介于 n / α + n / β – 2 和 n / α + n / β 之间，即 n – 2 和 n 之间。但是， [n / α] + [n / β] 是个整数，因而它精确地等于 n – 1 。</p>
<p>这说明，前 n – 1 个正整数在两个数列中一共出现了 n – 1 次，这对于所有 n 都成立。于是，正整数 1 必须且只能出现在其中一个数列中，正整数 2 必须且只能出现在其中一个数列中，以此类推，每一个新的正整数都必须且只能出现在其中一个数列中。</p>
<p>这种取整函数的处理技巧也可以用到上一个问题里：对上一个问题里的数头尾配对，你会发现每一对数之和都是 b – 1 。</p>
<p> <br>
问题：把 10, 100, 1000, 10000, … 分别写成二进制数和五进制数：</p>
<p>  原数列：10, 100, 1000, 10000, 10000, …<br>
  二进制：1010, 1100100, 1111101000, 10011100010000, …<br>
  五进制：20, 400, 13000, 310000, 11200000, …</p>
<p>你会发现，对于任意正整数 n &gt; 1 ，后两个数列里恰好有一个数是 n 位数。这是为什么？</p>
<p>答案：这是 Beatty-Rayleigh 定理的一个非常漂亮的直接推论。 10<sup>k</sup> 的二进制表达恰好有 [log<sub>2</sub>10<sup>k</sup>] + 1 位，即 [k · log<sub>2</sub>10] + 1 位。10<sup>k</sup> 的五进制表达恰好有 [log<sub>5</sub>10<sup>k</sup>] + 1 位，即 [k · log<sub>5</sub>10] + 1 位。我们只需要证明，数列 [1 · log<sub>2</sub>10], [2 · log<sub>2</sub>10], [3 · log<sub>2</sub>10], … 和 [1 · log<sub>5</sub>10], [2 · log<sub>5</sub>10], [3 · log<sub>5</sub>10], … 既无重复又无遗漏地包含了所有正整数。注意到 log<sub>2</sub>10 和 log<sub>5</sub>10 是两个倒数和为 1 的无理数，用一下 Beatty-Rayleigh 定理就出来了。</p>
<p> <br>
如果你喜欢这些问题，这里还有另一个类似的小合集：<a href="http://www.matrix67.com/blog/archives/3172">http://www.matrix67.com/blog/archives/3172</a></p>
			 ]]></content>
<pubDate>2012-06-13T21:30:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5013</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ IMO2012趣题：带有说谎的猜数游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/5036</link>
<content><![CDATA[ 
		<p>    考虑一个传统的猜数游戏。 A 、 B 两名玩家事先约定一个正整数 N ，然后 A 在心里想一个不超过 N 的正整数 x ， B 则需要通过向 A 提问来猜出 A 心里想的数。 B 的问题只有唯一的格式：先列出一些数，然后问 A “x 是否在这些数里”， A 则需要如实回答“是”或者“否”。显然， B 是保证能猜到 x 的，只需要依次询问“x 是否等于 1 ”，“x 是否等于 2 ”即可。由于 B 可以精心选出满足某种特征的所有数，询问 x 是否在这些数里，因而 B 还可以做得更好。例如当 N ＝ 16 时， B 第一次可以问“x 是否小于等于 8 ”，或者等价地，“x 是否属于 {1, 2, 3, 4, 5, 6, 7, 8} ”；接下来，根据 A 的回复继续细问“x 是否小于等于 4 ”或者“x 是否小于等于 12 ”，以此类推。另一种方法则是询问“x 的二进制表达的第一位是否是 1”，“x 的二进制表达的第二位是否是 1”，以此类推，从而获得 x 的二进制表达的所有数位，便能推出 x 来。</p>
<p>    现在，有意思的问题来了。假设 A 可以偶尔说谎（但保证不会连续说谎两次），那么 B 还能通过询问猜出 A 所想的数吗？如果愿意的话， B 可以询问任意多次。</p>
<p><span id="more-5036"></span><br>
    看上去 B 的机会似乎不小。考虑到任意两个连续问题中，至少有一个回答是真的，因而不断重复提问似乎是一个不错的策略。不过细想一下你会发现不行，因为 A 可以交替回答“是”、“否”、“是”、“否”，让 B 完全辨不出真假。事实上，即使 N = 2 ， B 也无法保证猜出 A 心里想的数。不管 B 怎样问问题， A 总能巧妙地给出回答，保证自己既不会连续两次撒谎，又不会让 B 猜到正确答案。方法如下。每当被问到“x 是否属于 {1, 2}”时，永远答“是”。每当被问到“x 是否等于 1”时，根据前一个问题来回答：如果前一个问题也是“x 是否等于 1”，则给出和前一次相反的答案，前一次说“是”这次就说“否”，前一次说“否”这次就说“是”；如果前一个问题是“x 是否等于 2”，则给出和前一次相同的回答，前一次说“是”这次还说“是”，前一次说“否”这次还说“否”；如果前一个问题是“x 是否属于 {1, 2}”，则这次就随便回答。当被问到“x 是否等于 2”时，用类似的处理方法。这样一来，不管 x 实际上是 1 还是 2 ，任意两次回答中都会有至少一个是正确的， B 将得不到任何信息。 A 的策略可以进一步归纳为：这次装作 x = 1 来回答，下次装作 x = 2 来回答，如此反复。由于 x 要么等于 1 要么等于 2 ，因此 A 的连续两次回答中必有一真。这样一来， B 显然会被 A 搞晕，因为 x = 1 和 x = 2 两种情况处于完全对称的地位。</p>
<p>    不过，如果我们允许 B 最后可以猜两个答案（只要其中一个是 x 就算 B 获胜）的话，可以证明 B 是必胜的，不管 N 有多大。当 N ≤ 2 时， B 显然必胜。当 N = 3 时， B 可以首先不断询问“x 是否等于 3”。如果 A 连续两次答“否”，这一定是实话，这样便能排除了 x = 3 的可能性，直接猜 x 等于 1 或者 2 即可。如果 A 答了一个“是”，那么紧接着问“x 是否等于 2”：如果 A 还答“是”，那么这两个问题的答案必有一真， x = 1 就被排除了；如果 A 答“否”，那么 x = 2 就被排除了，否则 A 就连续两次说谎了。不管怎样，我们最终都能排除掉一种情况，猜测剩下的两个数即可。</p>
<p>    当 N &gt; 3 时呢？我们可以把所有可能的数分成三组，分别标号为第 1 组、第 2 组和第 3 组。别忘了，我们可以给出一个任意大的集合，问“x 是否属于这个集合”，因而我们能套用刚才的方法，把“x 是否等于 3”改成“x 是否属于第 3 组数”，把“x 是否等于 2”改成“x 是否属于第 2 组数”，于是便能排除掉一组数了。不断把剩下的数分成三组，不断套用该方法，直到最后剩下的数不足三个为止。这样， B 便能保证自己的最终猜测是正确的了。</p>
<p><!--more--><br>
    上述讨论来自于刚刚结束的 2012 年 IMO 第三题。原题的结论更加一般：如果 A 最多能够连续撒谎 k 次（任意 k + 1 次回答中都有至少一次说真话），那么不管 N 有多大， B 最终总能给出一个大小不超过 2<sup>k</sup> 的数集，保证 A 心里想的 x 在这个数集里。这里， B 的问题仍然只能是刚才的那种格式，并且 B 仍然可以任意多次地询问。</p>
<p>    为了解决这个问题，我们着重考虑 N = 2<sup>k</sup> + 1 的情况，给出一种通过一系列询问排除其中一个数的方案。当 N &gt; 2<sup>k</sup> + 1 时，对数进行分组并在集合层面套用这种方法，直到最后所剩的数小于 2<sup>k</sup> + 1 个为止。</p>
<p>    我们把 x – 1 的二进制表达叫做 x 的“二进制编号”。注意到 x 可以取 1 到 2<sup>k</sup> + 1 之间的所有正整数，这些数的二进制编号最多 k + 1 位，其中唯一一个恰好拥有 k + 1 位二进制编号的数就是最后的那个数，2<sup>k</sup> + 1，其二进制编号为 100…000 ，1 后面 k 个 0 。我们假设其他所有数的二进制编号也都恰好是 k + 1 位，不足的话在前面用 0 补足。因此，所有数的二进制编号分别是 000…000 到 100…000 ，每个编号都是 k + 1 位。</p>
<p>    现在，不断问 A “x 的二进制编号的第一位是否是 1”，或者等价地，“x 是否等于 2<sup>k</sup> + 1”。如果连续 k + 1 次都得到“否”，则直接排除掉 x = 2<sup>k</sup> + 1 的情况。否则，我们一定得到了一个“是”的回复。紧接着抛出 k 个不同的问题，分别是“x 的二进制编号的第二位是否是 1 ”，“x 的二进制编号的第三位是否是 1 ”，一直到“x 的二进制编号的第 k + 1 位是否是 1 ”。当然，我们需要把这些问题翻译成规定的格式。由于 A 不能连续 k + 1 次撒谎，因此 A 不可能谎报了 x 的二进制编号里的所有数位。所以，我们可以排除掉二进制编号的每一位与 A 宣称的都不相符的那个数。这个数的二进制编号将会以 0 打头（因为 A 说了 x 的二进制编号的第一位是 1 ），因而它确实在 1 到 N 的范围里。</p>
<p>    当 N ≤ 2<sup>k</sup> 时，直接猜即可；当 N &gt; 2<sup>k</sup> + 1 时，我们可以用分组排除的方法。因而，对于任意大小的 N ， B 都能保证获胜，结论也就证到了。</p>
<p>    上述解法来自于 <a href="http://michaelnielsen.org/polymath1/index.php?title=Imo_2012">polymath</a> ，该题还有第二个问，目前似乎仍然没有解答。 polymath 去年也组织了 IMO 试题的讨论，那道题真是神题，见<a href="http://www.matrix67.com/blog/archives/4511">这里</a>。</p>
			 ]]></content>
<pubDate>2012-07-22T15:20:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5036</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 贴着另一枚硬币旋转一周则自身转了两周：不同的解释方法 ]]></title>
<link>http://www.matrix67.com/blog/archives/5040</link>
<content><![CDATA[ 
		<p>    有一道非常经典的智力问题：假设有两个一模一样的硬币 A 和硬币 B ，如果让硬币 B 不动，让硬币 A 贴着硬币 B 旋转一周，那么硬币 A 自身旋转了多少周？一个常见的错误答案是“显然也是一周啊”，而实际上正确的答案是两周，如下图所示。我们有很多方法来解释这种现象，其中最传统的说法便是“公转了一周，自转了一周”。硬币 A 的运动是由两部分合成的，公转一周（想像一个人绕着地球走了一圈），以及自转一周（想像一个轮子在地面上滚动了一周）。想像你是站在硬币 B 中心处的一个小人儿，看着硬币 A 贴着你脚下的硬币转动一圈。如果在此过程中，你始终面向硬币 A ，那么在你看来，硬币 A 似乎就是在长为 2πr 的平地上滚了一圈。而实际上，在观察硬币 A 的过程中，你自己也原地转了 360 度，因此从外面的人看来，硬币实际上转了两周。</p>
<p>      <img alt="image placeholder" >
<p>    写了<a href="http://www.matrix67.com/blog/archives/4955">这篇文章</a>后，我习惯性地开始用正多边形逼近的思路去分析一些与圆有关的一般性结论。在准备一份初中几何问题的材料时，我突然想到了上述问题的一个简单而漂亮的解释方法。</p>
<p><span id="more-5040"></span><br>
      <img alt="image placeholder" >
<p>    考虑一个正方形贴着另一个正方形旋转一周，你会发现，前者自身也旋转了两周。容易验证，对于正三角形和正六边形，情况也都是如此。这一定不是巧合，或许对于所有的正 n 边形，结论都同样成立。仔细一想，你发现这很容易理解：对于正 n 边形来说，每转过一个顶点，转过的角度都相当于正 n 边形两个外角的大小。转过 n 个顶点回到出发位置后，正 n 边形显然转过了两倍的外角和，也就是 720 度。因而，正 n 边形自身旋转了两周。当正多边形的边数趋于无穷多时可知，一枚硬币贴着另一枚硬币旋转一周，则这枚硬币自身也一定正好旋转了两周。</p>
			 ]]></content>
<pubDate>2012-08-10T17:06:31+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5040</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 互联网时代的社会语言学：基于SNS的文本数据挖掘 ]]></title>
<link>http://www.matrix67.com/blog/archives/5044</link>
<content><![CDATA[ 
		<p>    今年上半年，我在人人网实习了一段时间，期间得到了很多宝贵的数据，并做了一些还算有意义的事情，在这里和大家一块儿分享。感谢人人网提供的数据与工作环境，感谢赵继承博士、詹卫东老师的支持和建议。在这项工作中，我得到了很多与众人交流的机会，特别感谢 OpenParty 、 TEDxBeijing 提供的平台。本文已发表在了《程序员》杂志，分上下两部分刊于 2012 年 7 月刊和 8 月刊，在此感谢卢鸫翔编辑的辛勤工作。由于众所周知的原因，《程序员》刊出的文章被和谐过（看到后面大家就自动地知道被和谐的内容是什么了），因而我决定把完整版发在 Blog 上，同时与更多的人一同分享。对此感兴趣的朋友可以给我发邮件继续交流。好了，开始说正文吧。</p>
<p>    作为中文系应用语言学专业的学生以及一名数学 Geek ，我非常热衷于用计算的方法去分析汉语资料。汉语是一种独特而神奇的语言。对汉语资料进行自然语言处理时，我们会遇到很多其他语言不会有的困难，比如分词——汉语的词与词之间没有空格，那计算机怎么才知道，“已结婚的和尚未结婚的青年都要实行计划生育”究竟说的是“已／结婚／的／和／尚未／结婚／的／青年”，还是“已／结婚／的／和尚／未／结婚／的／青年”呢？这就是所谓的分词歧义难题。不过，现在很多语言模型已经能比较漂亮地解决这一问题了。但在中文分词领域里，还有一个比分词歧义更令人头疼的东西——未登录词。中文没有首字母大写，专名号也被取消了，这叫计算机如何辨认人名地名之类的东西？更惨的则是机构名、品牌名、专业名词、缩略语、网络新词等等，它们的产生机制似乎完全无规律可寻。最近十年来，中文分词领域都在集中攻克这一难关。自动发现新词成为了关键的环节。</p>
<p>    挖掘新词的传统方法是，先对文本进行分词，然后猜测未能成功匹配的剩余片段就是新词。这似乎陷入了一个怪圈：分词的准确性本身就依赖于词库的完整性，如果词库中根本没有新词，我们又怎么能信任分词结果呢？此时，一种大胆的想法是，首先不依赖于任何已有的词库，仅仅根据词的共同特征，将一段大规模语料中可能成词的文本片段全部提取出来，不管它是新词还是旧词。然后，再把所有抽出来的词和已有词库进行比较，不就能找出新词了吗？有了抽词算法后，我们还能以词为单位做更多有趣的数据挖掘工作。这里，我所选用的语料是人人网 2011 年 12 月前半个月部分用户的状态。非常感谢人人网提供这份极具价值的网络语料。</p>
<p><span id="more-5044"></span><br>
 <br>
 <br>
    要想从一段文本中抽出词来，我们的第一个问题就是，怎样的文本片段才算一个词？大家想到的第一个标准或许是，看这个文本片段出现的次数是否足够多。我们可以把所有出现频数超过某个阈值的片段提取出来，作为该语料中的词汇输出。不过，光是出现频数高还不够，一个经常出现的文本片段有可能不是一个词，而是多个词构成的词组。在人人网用户状态中，“的电影”出现了 389 次，“电影院”只出现了 175 次，然而我们却更倾向于把“电影院”当作一个词，因为直觉上看，“电影”和“院”凝固得更紧一些。</p>
<p>    为了证明“电影院”一词的内部凝固程度确实很高，我们可以计算一下，如果“电影”和“院”真的是各自独立地在文本中随机出现，它俩正好拼到一起的概率会有多小。在整个 2400 万字的数据中，“电影”一共出现了 2774 次，出现的概率约为 0.000113 。“院”字则出现了 4797 次，出现的概率约为 0.0001969 。如果两者之间真的毫无关系，它们恰好拼在了一起的概率就应该是 0.000113 × 0.0001969 ，约为 2.223 × 10<sup>-8</sup> 次方。但事实上，“电影院”在语料中一共出现了 175 次，出现概率约为 7.183 × 10<sup>-6</sup> 次方，是预测值的 300 多倍。类似地，统计可得“的”字的出现概率约为 0.0166 ，因而“的”和“电影”随机组合到了一起的理论概率值为 0.0166 × 0.000113 ，约为 1.875 × 10<sup>-6</sup> ，这与“的电影”出现的真实概率很接近——真实概率约为 1.6 × 10<sup>-5</sup> 次方，是预测值的 8.5 倍。计算结果表明，“电影院”更可能是一个有意义的搭配，而“的电影”则更像是“的”和“电影”这两个成分偶然拼到一起的。</p>
<p>    当然，作为一个无知识库的抽词程序，我们并不知道“电影院”是“电影”加“院”得来的，也并不知道“的电影”是“的”加上“电影”得来的。错误的切分方法会过高地估计该片段的凝合程度。如果我们把“电影院”看作是“电”加“影院”所得，由此得到的凝合程度会更高一些。因此，为了算出一个文本片段的凝合程度，我们需要枚举它的凝合方式——这个文本片段是由哪两部分组合而来的。令 p(x) 为文本片段 x 在整个语料中出现的概率，那么我们定义“电影院”的凝合程度就是 p(电影院) 与 p(电) · p(影院) 比值和 p(电影院) 与 p(电影) · p(院) 的比值中的较小值，“的电影”的凝合程度则是 p(的电影) 分别除以 p(的) · p(电影) 和 p(的电) · p(影) 所得的商的较小值。</p>
<p>    可以想到，凝合程度最高的文本片段就是诸如“蝙蝠”、“蜘蛛”、“彷徨”、“忐忑”、“玫瑰”之类的词了，这些词里的每一个字几乎总是会和另一个字同时出现，从不在其他场合中使用。</p>
<p> <br>
    光看文本片段内部的凝合程度还不够，我们还需要从整体来看它在外部的表现。考虑“被子”和“辈子”这两个片段。我们可以说“买被子”、“盖被子”、“进被子”、“好被子”、“这被子”等等，在“被子”前面加各种字；但“辈子”的用法却非常固定，除了“一辈子”、“这辈子”、“上辈子”、“下辈子”，基本上“辈子”前面不能加别的字了。“辈子”这个文本片段左边可以出现的字太有限，以至于直觉上我们可能会认为，“辈子”并不单独成词，真正成词的其实是“一辈子”、“这辈子”之类的整体。可见，文本片段的自由运用程度也是判断它是否成词的重要标准。如果一个文本片段能够算作一个词的话，它应该能够灵活地出现在各种不同的环境中，具有非常丰富的左邻字集合和右邻字集合。</p>
<p>    “信息熵”是一个非常神奇的概念，它能够反映知道一个事件的结果后平均会给你带来多大的信息量。如果某个结果的发生概率为 p ，当你知道它确实发生了，你得到的信息量就被定义为 – log(p) 。 p 越小，你得到的信息量就越大。如果一颗骰子的六个面分别是 1 、 1 、 1 、 2 、 2 、 3 ，那么你知道了投掷的结果是 1 时可能并不会那么吃惊，它给你带来的信息量是 – log(1/2) ，约为 0.693 。知道投掷结果是 2 ，给你带来的信息量则是 – log(1/3) ≈ 1.0986 。知道投掷结果是 3 ，给你带来的信息量则有 – log(1/6) ≈ 1.79 。但是，你只有 1/2 的机会得到 0.693 的信息量，只有 1/3 的机会得到 1.0986 的信息量，只有 1/6 的机会得到 1.79 的信息量，因而平均情况下你会得到 0.693/2 + 1.0986/3 + 1.79/6 ≈ 1.0114 的信息量。这个 1.0114 就是那颗骰子的信息熵。现在，假如某颗骰子有 100 个面，其中 99 个面都是 1 ，只有一个面上写的 2 。知道骰子的抛掷结果是 2 会给你带来一个巨大无比的信息量，它等于 – log(1/100) ，约为 4.605 ；但你只有百分之一的概率获取到这么大的信息量，其他情况下你只能得到 – log(99/100) ≈ 0.01005 的信息量。平均情况下，你只能获得 0.056 的信息量，这就是这颗骰子的信息熵。再考虑一个最极端的情况：如果一颗骰子的六个面都是 1 ，投掷它不会给你带来任何信息，它的信息熵为 – log(1) = 0 。什么时候信息熵会更大呢？换句话说，发生了怎样的事件之后，你最想问一下它的结果如何？直觉上看，当然就是那些结果最不确定的事件。没错，信息熵直观地反映了一个事件的结果有多么的随机。</p>
<p>    我们用信息熵来衡量一个文本片段的左邻字集合和右邻字集合有多随机。考虑这么一句话“吃葡萄不吐葡萄皮不吃葡萄倒吐葡萄皮”，“葡萄”一词出现了四次，其中左邻字分别为 {吃, 吐, 吃, 吐} ，右邻字分别为 {不, 皮, 倒, 皮} 。根据公式，“葡萄”一词的左邻字的信息熵为 – (1/2) · log(1/2) – (1/2) · log(1/2) ≈ 0.693 ，它的右邻字的信息熵则为 – (1/2) · log(1/2) – (1/4) · log(1/4) – (1/4) · log(1/4) ≈ 1.04 。可见，在这个句子中，“葡萄”一词的右邻字更加丰富一些。</p>
<p>    在人人网用户状态中，“被子”一词一共出现了 956 次，“辈子”一词一共出现了 2330 次，两者的右邻字集合的信息熵分别为 3.87404 和 4.11644 ，数值上非常接近。但“被子”的左邻字用例非常丰富：用得最多的是“晒被子”，它一共出现了 162 次；其次是“的被子”，出现了 85 次；接下来分别是“条被子”、“在被子”、“床被子”，分别出现了 69 次、 64 次和 52 次；当然，还有“叠被子”、“盖被子”、“加被子”、“新被子”、“掀被子”、“收被子”、“薄被子”、“踢被子”、“抢被子”等 100 多种不同的用法构成的长尾⋯⋯所有左邻字的信息熵为 3.67453 。但“辈子”的左邻字就很可怜了， 2330 个“辈子”中有 1276 个是“一辈子”，有 596 个“这辈子”，有 235 个“下辈子”，有 149 个“上辈子”，有 32 个“半辈子”，有 10 个“八辈子”，有 7 个“几辈子”，有 6 个“哪辈子”，以及“n 辈子”、“两辈子”等 13 种更罕见的用法。所有左邻字的信息熵仅为 1.25963 。因而，“辈子”能否成词，明显就有争议了。“下子”则是更典型的例子， 310 个“下子”的用例中有 294 个出自“一下子”， 5 个出自“两下子”， 5 个出自“这下子”，其余的都是只出现过一次的罕见用法。事实上，“下子”的左邻字信息熵仅为 0.294421 ，我们不应该把它看作一个能灵活运用的词。当然，一些文本片段的左邻字没啥问题，右邻字用例却非常贫乏，例如“交响”、“后遗”、“鹅卵”等，把它们看作单独的词似乎也不太合适。我们不妨就把一个文本片段的自由运用程度定义为它的左邻字信息熵和右邻字信息熵中的较小值。</p>
<p> <br>
    在实际运用中你会发现，文本片段的凝固程度和自由程度，两种判断标准缺一不可。只看凝固程度的话，程序会找出“巧克”、“俄罗”、“颜六色”、“柴可夫”等实际上是“半个词”的片段；只看自由程度的话，程序则会把“吃了一顿”、“看了一遍”、“睡了一晚”、“去了一趟”中的“了一”提取出来，因为它的左右邻字都太丰富了。</p>
<p> <br>
 <br>
    我们把文本中出现过的所有长度不超过 d 的子串都当作潜在的词（即候选词，其中 d 为自己设定的候选词长度上限，我设定的值为 5 ），再为出现频数、凝固程度和自由程度各设定一个阈值，然后只需要提取出所有满足阈值要求的候选词即可。为了提高效率，我们可以把语料全文视作一整个字符串，并对该字符串的所有后缀按字典序排序。下表就是对“四是四十是十十四是十四四十是四十”的所有后缀进行排序后的结果。实际上我们只需要在内存中存储这些后缀的前 d + 1 个字，或者更好地，只储存它们在语料中的起始位置。</p>
<blockquote><p>十<br>
十十四是十四四十是四十<br>
十是十十四是十四四十是四十<br>
十是四十<br>
十四是十四四十是四十<br>
十四四十是四十<br>
是十十四是十四四十是四十<br>
是十四四十是四十<br>
是四十<br>
是四十是十十四是十四四十是四十<br>
四十<br>
四十是十十四是十四四十是四十<br>
四十是四十<br>
四是十四四十是四十<br>
四是四十是十十四是十四四十是四十<br>
四四十是四十</p></blockquote>
<p>    这样的话，相同的候选词便都集中在了一起，从头到尾扫描一遍便能算出各个候选词的频数和右邻字信息熵。将整个语料逆序后重新排列所有的后缀，再扫描一遍后便能统计出每个候选词的左邻字信息熵。另外，有了频数信息后，凝固程度也都很好计算了。这样，我们便得到了一个无需任何知识库的抽词算法，输入一段充分长的文本，这个算法能以大致 O(n · logn) 的效率提取出可能的词来。</p>
<p> <br>
    对不同的语料进行抽词，并且按这些词的频数从高到低排序。你会发现，不同文本的用词特征是非常明显的。下面是对《西游记》上册的抽词结果：</p>
<blockquote><p>行者、师父、三藏、八戒、大圣、菩萨、悟空、怎么、和尚、唐僧、老孙、溃骸、什么、沙僧、太宗、徒弟、袈裟、妖精、玉帝、今日、兄弟、公主、玄奘、陛下、宝贝、性命、晓得、门外、妖魔、光蕊、观音、花果山、土地、木叉、东土、变化、变做、伯钦、判官、多少、真君、齐天大圣、蟠桃、丞相、魏征、扯住、溃骸澳、抬头、揭谛、言语、猪八戒、兵器、吩咐、安排、叩头、清风、哪吒、左右、美猴王、钉钯、孩儿、女婿、金箍棒、二郎、东西、许多、奈何、人参果、收拾、近前、太保、明月、南海、水帘洞、门首、弼马温、李天王⋯⋯</p></blockquote>
<p>    《资本论》全文：</p>
<blockquote><p> 商品、形式、货币、我们、过程、自己、机器、社会、部分、表现、没有、流通、需要、增加、已经、交换、关系、先令、积累、必须、英国、条件、发展、麻布、儿童、进行、提高、消费、减少、任何、手段、职能、土地、特殊、实际、完全、平均、直接、随着、简单、规律、市场、增长、上衣、决定、什么、制度、最后、支付、许多、虽然、棉纱、形态、棉花、法律、绝对、提供、扩大、独立、世纪、性质、假定、每天、包含、物质、家庭、规模、考察、剥削、经济学、甚至、延长、财富、纺纱、购买、开始、代替、便士、怎样、降低、能够、原料、等价物⋯⋯</p></blockquote>
<p>    《圣经》全文：</p>
<blockquote><p> 以色列、没有、自己、一切、面前、大卫、知道、什么、犹大、祭司、摩西、看见、百姓、吩咐、埃及、听见、弟兄、告诉、基督、已经、先知、扫罗、父亲、雅各、永远、攻击、智慧、荣耀、临到、洁净、离开、怎样、平安、律法、支派、许多、门徒、打发、好像、仇敌、原文作、名叫、巴比伦、今日、首领、旷野、所罗门、约瑟、两个、燔祭、法老、衣服、脱离、二十、公义、审判、十二、亚伯拉罕、石头、聚集、按着、祷告、罪孽、约书亚、事奉、指着、城邑、进入、彼此、建造、保罗、应当、摩押、圣灵、惧怕、应许、如今、帮助、牲畜⋯⋯</p></blockquote>
<p>    《时间简史》全文：</p>
<blockquote><p>黑洞、必须、非常、任何、膨胀、科学、预言、太阳、观察、定律、运动、事件、奇点、坍缩、问题、模型、方向、区域、知道、开始、辐射、部分、牛顿、产生、夸克、无限、轨道、解释、边界、甚至、自己、类似、描述、最终、旋转、爱因斯坦、绕着、什么、效应、表明、温度、研究、收缩、吸引、按照、完全、增加、开端、基本、计算、结构、上帝、进行、已经、发展、几乎、仍然、足够、影响、初始、科学家、事件视界、第二、改变、历史、世界、包含、准确、证明、导致、需要、应该、至少、刚好、提供、通过、似乎、继续、实验、复杂、伽利略⋯⋯</p></blockquote>
<p>    哦，对了，还有我最喜欢的，《人民日报》 2000 年 4 月新闻版的抽词结果：</p>
<blockquote><p>发展、我们、经济、主席、江泽民、领导、建设、关系、教育、干部、企业、问题、主义、政治、群众、改革、政府、思想、加强、台湾、地区、北京、总统、世界、记者、代表、民族、组织、历史、访问、原则、努力、管理、今天、技术、市场、世纪、坚持、社会主义、财政、江泽民主席、增长、积极、精神、同志、双方、自己、友好、领导干部、进一步、基础、提高、必须、不断、制度、政策、解决、取得、表示、活动、支持、通过、研究、没有、学习、稳定、举行、欢迎、农村、生活、促进、科技、投资、科学、环境、领域、公司、情况、充分⋯⋯</p></blockquote>
<p>    当然，我也没有忘记对人人网用户状态进行分析——人人网用户状态中最常出现的词是：</p>
<blockquote><p> 哈哈、什么、今天、怎么、现在、可以、知道、喜欢、终于、这样、觉得、因为、如果、感觉、开始、回家、考试、老师、幸福、朋友、时间、发现、东西、快乐、为什么、睡觉、生活、已经、希望、最后、各种、状态、世界、突然、手机、其实、那些、同学、孩子、尼玛、木有、然后、以后、学校、所以、青年、晚安、原来、电话、加油、果然、学习、中国、最近、应该、需要、居然、事情、永远、特别、北京、他妈、伤不起、必须、呵呵、月亮、毕业、问题、谢谢、英语、生日快乐、工作、虽然、讨厌、给力、容易、上课、作业、今晚、继续、努力、有木有、记得⋯⋯</p></blockquote>
<p>    事实上，程序从人人网的状态数据中一共抽出了大约 1200 个词，里面大多数词也确实都是标准的现代汉语词汇。不过别忘了，我们的目标是新词抽取。将所有抽出来的词与已有词库作对比，于是得到了人人网特有的词汇（同样按频数从高到低排序）：</p>
<blockquote><p>尼玛、伤不起、给力、有木有、挂科、坑爹、神马、淡定、老爸、卧槽、牛逼、肿么、苦逼、无语、微博、六级、高数、选课、悲催、基友、蛋疼、很久、人人网、情何以堪、童鞋、哇咔咔、脑残、吐槽、猥琐、奶茶、我勒个去、刷屏、妹纸、胃疼、飘过、考研、弱爆了、太准了、搞基、忽悠、羡慕嫉妒恨、手贱、柯南、狗血、秒杀、装逼、真特么、碎觉、奥特曼、内牛满面、斗地主、腾讯、灰常、偶遇、拉拉、屌丝、九把刀、高富帅、阿内尔卡、魔兽世界、线代、三国杀、林俊杰、速速、臭美、花痴⋯⋯</p></blockquote>
<p> <br>
    我还想到了更有意思的玩法。为什么不拿每一天状态里的词去和前一天的状态作对比，从而提取出这一天里特有的词呢？这样一来，我们就能从人人网的用户状态中提取出每日热点了！从手里的数据规模看，这是完全有可能的。我选了 12 个比较具有代表性的词，并列出了它们在 2011 年 12 月 13 日的用户状态中出现的频数（左列的数），以及 2011 年 12 月 14 日的用户状态中出现的频数（右列的数）：</p>
<blockquote>
<table>
<tr>
<td style="width: 80px">下雪</td>
<td style="width: 60px">33</td>
<td style="width: 60px">92</td>
</tr>
<tr>
<td>那些年</td>
<td>139</td>
<td>146</td>
</tr>
<tr>
<td>李宇春</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>看见</td>
<td>145</td>
<td>695</td>
</tr>
<tr>
<td>魔兽</td>
<td>23</td>
<td>20</td>
</tr>
<tr>
<td>高数</td>
<td>82</td>
<td>83</td>
</tr>
<tr>
<td>生日快乐</td>
<td>235</td>
<td>210</td>
</tr>
<tr>
<td>今天</td>
<td>1416</td>
<td>1562</td>
</tr>
<tr>
<td>北半球</td>
<td>2</td>
<td>18</td>
</tr>
<tr>
<td>脖子</td>
<td>23</td>
<td>69</td>
</tr>
<tr>
<td>悲伤</td>
<td>61</td>
<td>33</td>
</tr>
<tr>
<td>电磁炉</td>
<td>0</td>
<td>3</td>
</tr>
</table>
</blockquote>
<p>    大家可以从直觉上迅速判断出，哪些词可以算作是 12 月 14 日的热词。比方说，“下雪”一词在 12 月 13 日只出现了 33 次，在 12 月 14 日却出现了 92 次，后者是前者的 2.8 倍，这不大可能是巧合，初步判断一定是 12 月 14 日真的有什么地方下雪了。“那些年”在 12 月 14 日的频数确实比 12 月 13 日更多，但相差并不大，我们没有理由认为它是当日的一个热词。</p>
<p>    一个问题摆在了我们面前：我们如何去量化一个词的“当日热度”？第一想法当然是简单地看一看每个词的当日频数和昨日频数之间的倍数关系，不过细想一下你就发现问题了：它不能解决样本过少带来的偶然性。 12 月 14 日“李宇春”一词的出现频数是 12 月 13 日的 4 倍，这超过了“下雪”一词的 2.8 倍，但我们却更愿意相信“李宇春”的现象只是一个偶然。更麻烦的则是“电磁炉”一行， 12 月 14 日的频数是 12 月 13 日的无穷多倍，但显然我们也不能因此就认为“电磁炉”是 12 月 14 日最热的词。</p>
<p>    忽略所有样本过少的词？这似乎也不太好，样本少的词也有可能真的是热词。比如“北半球”一词，虽然它在两天里的频数都很少，但这个 9 倍的关系确实不容忽视。事实上，人眼很容易看出哪些词真的是 12 月 14 日的热词：除了“下雪”以外，“看见”、“北半球”和“脖子”也应该是热词。你或许坚信后三个词异峰突起的背后一定有什么原因（并且迫切地想知道这个原因究竟是什么），但却会果断地把“李宇春”和“电磁炉”这两个“异常”归结为偶然原因。你的直觉是对的—— 2011 年 12 月 14 日发生了极其壮观的双子座流星雨，此乃北半球三大流星雨之一。白天网友们不断转发新闻，因而“北半球”一词热了起来；晚上网友们不断发消息说“看见了”、“又看见了”，“看见”一词的出现频数猛增；最后呢，仰望天空一晚上，脖子终于出毛病了，于是回家路上一个劲儿地发“脖子难受”。</p>
<p>    让计算机也能聪明地排除偶然因素，这是我们在数据挖掘过程中经常遇到的问题。我们经常需要对样本过少的项目进行“平滑”操作，以避免分母过小带来的奇点。这里，我采用的是一个非常容易理解的方法：一个词的样本太少，就给这个词的热度打折扣。为了便于说明，我们选出四个词为例来分析。</p>
<p>    下表截取了前四个词，右边四列分别表示各词在 12 月 13 日出现的频数，在 12 月 14 日出现的频数，在两天里一共出现的总频数，以及后一天的频数所占的比重。第三列数字是前两列数字之和，第四列数字则是第二列数字除以第三列数字的结果。最后一列应该是一个 0 到 1 之间的数，它表明对应的词有多大概率出现在了 12 月 14 日这一天。最后一列可以看作是各词的得分。可以看到，此时“下雪”的得分低于“李宇春”，这是我们不希望看到的结果。“李宇春”的样本太少，我们想以此为缘由把它的得分拖下去。</p>
<blockquote>
<table>
<tr>
<td style="width: 80px">下雪</td>
<td style="width: 60px">33</td>
<td style="width: 60px">92</td>
<td style="width: 60px">125</td>
<td style="width: 60px">0.736</td>
</tr>
<tr>
<td>那些年</td>
<td>139</td>
<td>146</td>
<td>285</td>
<td>0.512</td>
</tr>
<tr>
<td>李宇春</td>
<td>1</td>
<td>4</td>
<td>5</td>
<td>0.8</td>
</tr>
<tr>
<td>看见</td>
<td>145</td>
<td>695</td>
<td>840</td>
<td>0.827</td>
</tr>
<tr>
<td>（平均）</td>
<td></td>
<td></td>
<td>313.75</td>
<td>0.719</td>
</tr>
</table>
</blockquote>
<p>    怎么做呢？我们把每个词的得分都和全局平均分取一个加权平均！首先计算出这四个词的平均总频数，为 313.75 ；再计算出这四个词的平均得分，为 0.719 。接下来，我们假设已经有 313.75 个人预先给每个词都打了 0.719 分，换句话说每个词都已经收到了 313.75 次评分，并且所有这 313.75 个评分都是 0.719 分。“下雪”这个词则还有额外的 125 个人评分，其中每个人都给了 0.736 分。因此，“下雪”一词的最终得分就是：</p>
<blockquote>
<table>
<tr>
<td style="width: 80px">下雪</td>
<td>(0.736 × 125 + 0.719 × 313.75) / (125 + 313.75) ≈ 0.724</td>
</tr>
</table>
</blockquote>
<p>    类似地，其他几个词的得分依次为：</p>
<blockquote>
<table>
<tr>
<td style="width: 80px">那些年</td>
<td>(0.512 × 285 + 0.719 × 313.75) / (285 + 313.75) ≈ 0.62</td>
</tr>
<tr>
<td>李宇春</td>
<td>(0.8 × 5 + 0.719 × 313.75) / (5 + 313.75) ≈ 0.7202</td>
</tr>
<tr>
<td>看见</td>
<td>(0.827 × 840 + 0.719 × 313.75) / (840 + 313.75) ≈ 0.798</td>
</tr>
</table>
</blockquote>
<p>    容易看出，此时样本越大的词，就越有能力把最终得分拉向自己本来的得分，样本太小的词，最终得分将会与全局平均分非常接近。经过这么一番调整，“下雪”一词的得分便高于了“李宇春”。实际运用中， 313.75 这个数也可以由你自己来定，定得越高就表明你越在意样本过少带来的负面影响。这种与全局平均取加权平均的思想叫做 Bayesian average ，从上面的若干式子里很容易看出，它实际上是最常见的平滑处理方法之一——分子分母都加上一个常数——的一种特殊形式。</p>
<p>    利用之前的抽词程序抽取出人人网每一天内用户状态所含的词，把它们的频数都与前一天的作对比，再利用刚才的方法加以平滑，便能得出每一天的热词了。我手上的数据是人人网 2011 年 12 月上半月的数据，因此我可以得出从 12 月 2 日到 12 月 15 日的热词（选取每日前 5 名，按得分从高到低）。</p>
<blockquote><p>2011-12-02：第一场雪、北京、金隅、周末、新疆<br>
2011-12-03：荷兰、葡萄牙、死亡之组、欧洲杯、德国<br>
2011-12-04：那些年、宣传、期末、男朋友、升旗<br>
2011-12-05：教室、老师、视帝、体育课、质量<br>
2011-12-06：乔尔、星期二、摄影、经济、音乐<br>
2011-12-07：陈超、星巴克、优秀、童鞋、投票<br>
2011-12-08：曼联、曼城、欧联杯、皇马、冻死<br>
2011-12-09：保罗、月全食、交易、火箭、黄蜂<br>
2011-12-10：变身、罗伊、穿越、皇马、巴萨<br>
2011-12-11：皇马、巴萨、卡卡、梅西、下半场<br>
2011-12-12：淘宝、阿内尔卡、双十二、申花、老师<br>
2011-12-13：南京、南京大屠杀、勿忘国耻、默哀、警报<br>
2011-12-14：流星雨、许愿、愿望、情人节、几颗<br>
2011-12-15：快船、保罗、巴萨、昨晚、龙门飞甲 </p></blockquote>
<p>    看来， 12 月 14 日果然有流星雨发生。</p>
<p>    注意，由于我们仅仅对比了相邻两天的状态，因而产生了个别实际上是由工作日/休息日的区别造成的“热词”，比如“教室”、“老师”、“星期二”等。把这样的词当作热词可能并不太妥。结合上周同日的数据，或者干脆直接与之前整个一周的数据来对比，或许可以部分地解决这一问题。</p>
<p>    事实上，有了上述工具，我们可以任意比较两段不同文本中的用词特点。更有趣的是，人人网状态的大多数发布者都填写了性别和年龄的个人信息，我们为何不把状态重新分成男性和女性两组，或者 80 后和 90 后两组，挖掘出不同属性的人都爱说什么？要知道，在过去，这样的问题需要进行大规模语言统计调查才能回答！然而，在互联网海量用户生成内容的支持下，我们可以轻而易举地挖掘出答案来。</p>
<p>    我真的做了这个工作（基于另一段日期内的数据）。男性爱说的词有：</p>
<blockquote><p>兄弟、篮球、男篮、米兰、曼联、足球、蛋疼、皇马、比赛、国足、超级杯、球迷、中国、老婆、政府、航母、踢球、赛季、股市、砸蛋、牛逼、铁道部、媳妇、国际、美国、连败、魔兽、斯内德、红十字、经济、腐败、程序、郭美美、英雄、民主、鸟巢、米兰德比、官员、内涵、历史、训练、评级、金融、体育、记者、事故、程序员、媒体、投资、事件、社会、项目、伊布、主义、决赛、操蛋、纳尼、领导、喝酒、民族、新闻、言论、和谐、农民、体制、城管⋯⋯</p></blockquote>
<p>    下面则是女性爱说的词：</p>
<blockquote><p>一起玩、蛋糕、加好友、老公、呜呜、姐姐、嘻嘻、老虎、讨厌、妈妈、呜呜呜、啦啦啦、便宜、减肥、男朋友、老娘、逛街、无限、帅哥、礼物、互相、奶茶、委屈、各种、高跟鞋、指甲、城市猎人、闺蜜、巧克力、第二、爸爸、宠物、箱子、吼吼、大黄蜂、狮子、胃疼、玫瑰、包包、裙子、游戏、遇见、嘿嘿、灰常、眼睛、各位、妈咪、化妆、玫瑰花、蓝精灵、幸福、陪我玩、任务、怨念、舍不得、害怕、狗狗、眼泪、温暖、面膜、收藏、李民浩、神经、土豆、零食、痘痘、戒指、巨蟹、晒黑⋯⋯</p></blockquote>
<p>    下面是 90 后用户爱用的词：</p>
<blockquote><p>加好友、作业、各种、乖乖、蛋糕、来访、卧槽、通知书、麻将、聚会、补课、欢乐、刷屏、录取、无限、互相、速度、一起玩、啦啦啦、晚安、求陪同、基友、美女、矮油、巨蟹、五月天、第二、唱歌、老虎、扣扣、啧啧、帅哥、哈哈哈、尼玛、便宜、苦逼、斯内普、写作业、劳资、孩纸、哎哟、炎亚纶、箱子、无聊、求来访、查分、上课、果断、处女、首映、屏蔽、混蛋、暑假、吓死、新东方、组队、下学期、陪我玩、打雷、妹纸、水瓶、射手、搞基、吐槽、同学聚会、出去玩、呜呜、白羊、表白、做作业、签名、姐姐、停机、伏地魔、对象、哈哈、主页、情侣、无压力、共同、摩羯、碎觉、肿么办⋯⋯</p></blockquote>
<p>    下面则是 80 后用户爱用的词：</p>
<blockquote><p>加班、培训、周末、工作、公司、各位、值班、砸蛋、上班、任务、公务员、工资、领导、包包、办公室、校内、郭美美、时尚、企业、股市、新号码、英国、常联系、实验室、论文、忙碌、项目、部门、祈福、邀请、招聘、顺利、朋友、红十字、男朋友、媒体、产品、标准、号码、存钱、牛仔裤、曼联、政府、简单、立秋、事故、伯明翰、博士、辞职、健康、销售、深圳、奶茶、搬家、实验、投资、节日快乐、坚持、规则、考验、生活、体制、客户、发工资、忽悠、提供、教育、处理、惠存、沟通、团购、缺乏、腐败、启程、红十字会、结婚、管理、环境、暴跌、服务、变形金刚、祝福、银行⋯⋯</p></blockquote>
<p>    不仅如此，不少状态还带有地理位置信息，因而我们可以站在空间的维度对信息进行观察。这个地方的人都爱说些什么？爱说这个词的人都分布在哪里？借助这些包含地理位置的签到信息，我们也能挖掘出很多有意思的结果来。例如，对北京用户的签到信息进行抽词，然后对于每一个抽出来的词，筛选出所有包含该词的签到信息并按地理坐标的位置聚类，这样我们便能找出那些地理分布最集中的词。结果非常有趣：“考试”一词集中分布在海淀众高校区，“天津”一词集中出现在北京南站，“逛街”一词则全都在西单附近扎堆。北京首都国际机场也是一个非常特别的地点，“北京”、“登机”、“终于”、“再见”等词在这里出现的密度极高。</p>
<p>    从全国范围来看，不同区域的人也有明显的用词区别。我们可以将全国地图划分成网格，统计出所有签到信息在各个小格内出现的频数，作为标准分布；然后对于每一个抽出来的词，统计出包含该词的签到信息在各个小格内出现的频数，并与标准分布进行对比（可以采用余弦距离等公式），从而找出那些分布最反常的词。程序运行后发现，这样的词还真不少。一些明显具有南北差异的词，分布就会与整个背景相差甚远。例如，在节假日的时候，“滑雪”一词主要在北方出现，“登山”一词则主要在南方出现。地方特色也是造成词语分布差异的一大原因，例如“三里屯”一词几乎只在北京出现，“热干面”一词集中出现在武汉地区，“地铁”一词明显只有个别城市有所涉及。这种由当地人的用词特征反映出来的真实的地方特色，很可能是许多旅游爱好者梦寐以求的信息。另外，方言也会导致用词分布差异，例如“咋这么”主要分布在北方地区，“搞不懂”主要分布在南方城市，“伐”则非常集中地出现在上海地区。当数据规模足够大时，或许我们能通过计算的方法，自动对中国的方言区进行划分。</p>
<p>    其实，不仅仅是发布时间、用户年龄、用户性别、地理位置这四个维度，我们还可以对浏览器、用户职业、用户活跃度、用户行为偏好等各种各样的维度进行分析，甚至可以综合考虑以上维度，在某个特定范围内挖掘热点事件，或者根据语言习惯去寻找出某个特定的人群。或许这听上去太过理想化，不过我坚信，有了合适的算法，这些想法终究会被一一实现。</p>
			 ]]></content>
<pubDate>2012-08-10T18:03:55+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5044</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：构造更大的Brunnian link ]]></title>
<link>http://www.matrix67.com/blog/archives/5058</link>
<content><![CDATA[ 
		<p>    下图中的三个绳圈套在一起，没有哪一个绳圈能从中分离出来。不过，真正有趣的是，如果去掉其中任意一个绳圈，那么其他所有的绳圈都全部散开了。如果 n 个绳圈套在一起，并且任意去掉其中一个绳圈都会同时解开其他所有套着的绳圈，我们就把它叫做 n-component Brunnian link 。</p>
<p>      <img alt="image placeholder" >
<p>    你能想出一个 n = 4 的 Brunnian link 吗？ n = 5 呢？ n 可以任意大吗？</p>
<p><span id="more-5058"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    <a href="http://en.wikipedia.org/wiki/Brunnian_link">Wikipedia</a> 上给出了一个 n = 4 的 Brunnian link ，如下图所示：</p>
<p>      <img alt="image placeholder" >
<p> <br>
    <a href="http://www.mi.sanu.ac.rs/vismath/bor/bor7.htm">这个网页</a>中给出了两种方案，据此可以得到任意大的 n-component Brunnian link ：</p>
<p>      <img alt="image placeholder" >
<p>      <img alt="image placeholder" >
 </p>
			 ]]></content>
<pubDate>2012-10-07T15:37:23+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5058</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：由0和1构成的虫子 ]]></title>
<link>http://www.matrix67.com/blog/archives/5063</link>
<content><![CDATA[ 
		<p>    有一条虫子，它的整个身体由 n 节构成，每一节要么是有瑕疵的 1 ，要么是没有瑕疵的 0 ，因而整个虫子的身体结构就可以用一个 n 位 01 串来表示。你的目标是把整个虫子变成 000…00 的完美形式。每一次，你可以砍掉虫子最右侧的一节，同时虫子会在最左侧长出新的一节，以保持虫子的总长度不变。如果你砍掉的是一个 1 ，那么你可以指定虫子在最左侧长出的是 1 还是 0 ；但如果你砍掉的是一个 0 ，那么你无法控制虫子会在最左侧长出什么——它可能会长出 0 ，也可能会长出 1 ，因而你不得不假定，概率总是会和你做对，上天会竭尽全力地阻挠你。我们的问题是：不管虫子的初始状态是什么，你总能保证在有限步之内让虫子变成 000…00 吗？</p>
<p>    注意，这个问题可能没有你想的那么简单。显然，我们必须得把一些 1 变成 0 ，这样才能让 1 的数目逐渐减少并最终消失。但是，如果只是简单地每次都把 1 变成 0 ，最终也不见得就一定能取胜。比如，如果这条虫子是 101 ，那么去掉最右边的 1 并选择在左边长出一个 0 ，虫子会变成 010 ；再把 010 右边的 0 去掉后，如果不巧左边长出的是 1 ，那么整条虫子又会回到 101 的状态。如此反复，将永远也不能得到 000 。而更加聪明的方法则是先把 101 变成 110 ，下一步虫子将会变成 111 或者 011 ，不管是哪种情况，接下来只需要逐个把 1 变成 0 就能获胜了。运用恰当的策略才能走到终点，这无疑让问题变得更加有趣。</p>
<p><span id="more-5063"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    不管虫子一开始是什么样子的，我们总能够在有限步之内获胜。下面是 Peter Winkler 给出的证明。让我们把连续 n 次操作视为一轮操作，因而完成一轮操作正好让虫子的整个身体更新一次。于是，每一轮操作实际上相当于是从右到左依次考虑虫子的每一位，每遇到一个 1 时你都可以选择是否把它修改成 0 ，每遇到一个 0 时它都会随机地被修改成 1 。我们一轮一轮地改造虫子的身体，并且每一轮都采取这样的策略：从最右端开始，每次遇到 1 都把它改成 0 ，直到第一次有 0 被改成 1 ；在此之后，不管新遇到的 0 变没变，都保留所有的 1 不变。如果这一轮下来后，没有 0 被改成 1 ，那么我们将会把所有的 1 都替换成 0 ，从而得到 000…00 的形式，直接获得胜利；如果途中有 0 被改成了 1 ，那么整个虫子作为一个二进制数将会严格增加。每经过一轮后，只要虫子没有变成 000…00 ，整个二进制数都会变得更大，最终将会变成 111…11 的形式，此时再也不会有 0 变成 1 了，于是按照我们的策略，在下一轮中，所有的 1 都会变成 0 ，从而获得胜利。</p>
<p>    题目来源：<a href="http://www.cs.cmu.edu/puzzle/puzzle37.html">http://www.cs.cmu.edu/puzzle/puzzle37.html</a></p>
			 ]]></content>
<pubDate>2012-10-08T12:05:37+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5063</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：证明所有乘积的总和与分拆的方式无关 ]]></title>
<link>http://www.matrix67.com/blog/archives/5070</link>
<content><![CDATA[ 
		<p>    有 1000 枚硬币堆在一起。把它们任意分成两堆，并计算出这两堆的硬币数的乘积。然后，任意选择其中的一堆硬币，把它继续分成两个更小的堆，并计算出这两堆的硬币数的乘积。不断这样做下去，直到最后每堆都只剩一枚硬币为止。求证：把途中产生的所有乘积全部加在一起，结果是一个定值，它不随分法的改变而改变。</p>
<p><span id="more-5070"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    这是一个非常经典的问题。让我们把 1000 枚硬币换成 n 枚硬币，这样的话问题反而会更容易一些。如果初始时有 n 枚硬币，把它们分到底后，产生的所有乘积之和是多少呢？考虑一种特殊的分法：把 n 分成 1 和 n – 1 两堆，再把 n – 1 分成 1 和 n – 2 两堆……显然，由此得到的总和应该是 (n – 1) + (n – 2) + … + 2 + 1 = n(n – 1) / 2 。有了这个公式后，我们便很容易用数学归纳法证明，不管分法是什么，最终的结果一定是 n(n – 1) / 2 。首先验证，当 n = 1 时， n(n – 1) / 2 = 0 ，这是符合实际情况的：单独一枚硬币不会产生任何新的乘积。对于一般的 n ，把它分成 x 和 n – x 两堆，得到乘积 x(n – x) 。由归纳假设，这两堆硬币今后将各产生总和为 x(x – 1) / 2 的乘积，以及总和为 (n – x)(n – x – 1) / 2 的乘积。不难算出，x(n – x) + x(x – 1) / 2 + (n – x)(n – x – 1) / 2 正是 n(n – 1) / 2 。</p>
<p>    其实，这个问题有一个异常帅的秒杀方法。每次把一堆硬币分成两堆后，计算两堆硬币数量的乘积，实际上相当于是在计算有多少对硬币在这一步被分开了。最后所有乘积的总和，也就是在整个过程中被分开的硬币对的总数。然而， n 枚硬币之间共有 C(n, 2) = n(n – 1) / 2 个硬币对，所有的硬币对最终都被分开了，因而问题的答案就是 n(n – 1) / 2 ，这不随分法的变化而变化。</p>
<p> <br>
 <br>
    现在，让我们把问题变一下。假设有一根长度为 n 的线段。把它分成两条子线段，并计算这两条子线段的长度的乘积。选择其中一条子线段，并把它继续分成两条更小的子线段，求出这两条子线段的长度的乘积。不断这样细分下去，直到所有的子线段长度都趋于 0 。在此过程中，不断累加所得的乘积，其总和的极限是多少？（注意，这里的描述还需要更严谨一些，不过我们暂不追究。）</p>
<p>    显然，答案应该是一个比 n(n – 1) / 2 更大的数。因为根据前一个问题的解答，把长度为 n 的线段分成 n 个长度为 1 的线段，乘积的总和为 n(n – 1) / 2 ；但在此之后，我们还可以继续切分线段，让总和继续增加。那么，答案究竟是多少呢？我们也可以借助某个特殊的分法得出答案。假设我们按照如下方法把线段无穷细分：先把整条线段等分成两段，得到乘积 (n / 2)<sup>2</sup> ；再把所得的两条子线段都进行平分，得到两个 (n / 4)<sup>2</sup> ；再依次平分当前的四条子线段，得到四个 (n / 8)<sup>2</sup> ……以此类推，最后的总和将会是 (n / 2)<sup>2</sup> + 2 · (n / 4)<sup>2</sup> + 4 · (n / 8)<sup>2</sup> + 8 · (n / 16)<sup>2</sup> + … = n<sup>2</sup> / 4 + n<sup>2</sup> / 8 + n<sup>2</sup> / 16 + n<sup>2</sup> / 32 + … = n<sup>2</sup> / 2 。</p>
<p>    不过，我们如何证明，任意一种分法都会导致总和最终会趋于 n<sup>2</sup> / 2 ？升级版的问题变得不再离散，数学归纳法和组合方法似乎都派不上用场了。其实，借助几何构造，这个问题也有一个非常直观的秒杀方法。</p>
<p>      <img alt="image placeholder" >
<p>    如图，初始时线段的总长为 n ，那么我们就作一个边长为 n 的等腰直角三角形。如果把线段分成了 x 和 y 两段，由此产生的乘积 x · y 就对应于左图的等腰直角三角形中阴影矩形的面积。继续细分两个子线段，也就相当于递归地处理两个剩余的空白三角形。当所有子线段都被分到无穷短时，矩形面积的总和将会无穷接近于整个等腰直角三角形的总面积，也就是 n<sup>2</sup> / 2 。</p>
<p> <br>
题目来源：<a href="http://mindyourdecisions.com/blog/2012/10/22/monday-puzzle-piles-of-coins-hard-finance-interview-question/">mindyourdecisions.com</a><br>
查看更多：<a href="http://www.reddit.com/r/math/comments/11wm60/1000_coins_are_divided_into_piles_x_and_y_to_give/">reddit.com/r/math</a></p>
			 ]]></content>
<pubDate>2012-10-31T21:07:04+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5070</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 空间想象能力挑战：把左图连续地变换为右图 ]]></title>
<link>http://www.matrix67.com/blog/archives/5077</link>
<content><![CDATA[ 
		<p>    为了说明“同痕”这一概念直观上并不容易把握，《The Knot Book》一书中举了一个经典的例子。如下图，左图是一个有三个洞的立体图形，右图是被挖出了三条通道的立方体（但其中一个通道在另一个通道上缠绕了一圈）。令人难以置信的是，两者之间竟然是同痕的，换句话说前者可以连续地变形成为后者。你能想象出这个变换过程吗？</p>
<p>      <img alt="image placeholder" >
<p><span id="more-5077"></span><br>
    下面是其中一种想象的方法（选中显示）：<span style="color:#e5e5e5">从右图出发，让左起第一个通道的两头靠在第二个通道上，并在第二个通道上滑动。把上面的那头沿着第二个通道滑到底面，把下面的那头沿着第二个通道滑到顶面，你会发现此时立方体内的通道不再打结了。接下来，把通道都拉直，把整个立方体拍扁了捏一捏，很容易就变成左图了。</span></p>
			 ]]></content>
<pubDate>2012-11-01T19:44:36+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5077</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 难倒犹太人的五个数学问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/5083</link>
<content><![CDATA[ 
		<p>    这个 Blog 已经不止一次提到过难倒犹太人的“棺材问题”了。很多年以前，要想进入莫斯科国立大学的数学系，你必须通过四项入学考试；头两个都是数学考试，一个笔试，一个面试。在面试中，学生和考官都是一对一的，考官可以自由向学生提出任何他喜欢的问题。考官们都准备了很多“棺材问题”，这些问题的答案非常简单，但由于思路太巧妙了，以至于学生很难想到。考官便可以以“你连这个都没想到”为理由，光明正大地拒绝学校不想要的人（主要是犹太人）。之前我们曾经介绍过一个典型的“棺材问题”：<a href="http://www.matrix67.com/blog/archives/507">空间四边形外切于给定球，求证四切点共面</a>。去年的这个时候，我们还介绍了<a href="http://www.matrix67.com/blog/archives/4649">同样机智巧妙的 11 个问题</a>。</p>
<p>    民间还流传着很多其他的“棺材问题”列表。 Ilan Vardi 曾经写过一篇题为 Mekh-Mat Entrance Examinations Problems 的论文，收集了 25 个“棺材问题”，并给出了解答。这篇论文被收录进了 You Failed Your Math Test, Comrade Einstein 一书中。 Ilan Vardi 发现，这 25 个问题的“难法”有所不同。虽然其中不乏思路奇巧的好题，但也有不少步骤繁琐（当然也有可能是还没找到好的解法）、题意不清甚至结论错误的题目。这里，我选择了其中五个有趣的题目，写下来和大家一同分享。</p>
<p><span id="more-5083"></span><br>
 </p>
<blockquote><p>问题：是否存在无穷多个正整数对 (m, n) ，使得 m 和 n 用到的质因数完全相同，并且 m + 1 和 n + 1 用到的质因数也完全相同？</p></blockquote>
<p> </p>
<blockquote><p>答案：存在无穷多对这样的 (m, n) 。令 m = 2<sup>k</sup> – 2 ，不难看出 m 一定是偶数。再令 n = (m + 1)<sup>2</sup> – 1 。下面我们说明，这样的 (m, n) 是满足要求的。首先，由于 n + 1 = (m + 1)<sup>2</sup> ，显然 m + 1 和 n + 1 拥有完全相同的质因数。另外， n = (m + 1)<sup>2</sup> – 1 = m(m + 2) ，这表明 n 不但拥有 m 的所有质因数，还拥有 m + 2 的所有质因数。然而， m + 2 的所有质因数 m 都已经有过了，因为 m + 2 恰好是 2 的幂，所含的唯一质因数就是 2 ，而 m 是一个偶数，已经有质因数 2 了。因此， m 和 n 也拥有完全相同的质因数。<br>
 <br>
大家或许想问，除了这种形式以外，还有别的 (m, n) 也满足要求吗？有，不过不太好找了。例如， (m, n) = (75, 1215) 就是其中一个解。</p></blockquote>
<p> <br>
 </p>
<blockquote><p>问题：给出 y = x<sup>2</sup> 的函数图像，用直尺和圆规画出两条坐标轴。</p></blockquote>
<p> </p>
<blockquote><p>在函数图像上任取两点 A(a, a<sup>2</sup>) 和 B(b, b<sup>2</sup>) ，那么线段 AB 的斜率就是 (b<sup>2</sup> – a<sup>2</sup>) / (b – a) = a + b 。再在函数图像上取一个点 C(c, c<sup>2</sup>) ，过点 C 作 AB 的平行线，与函数图像交于另一点 D(d, d<sup>2</sup>) 。那么，线段 CD 的斜率也就是 c + d 。由于 CD 和 AB 平行，因而两条线段的斜率相同，由此可知 a + b = c + d 。现在，作出 AB 的中点 E ，作出 CD 的中点 F 。显然， E 和 F 的坐标分别为 ((a + b) / 2, (a<sup>2</sup> + b<sup>2</sup>) / 2) 和  ((c + d) / 2, (c<sup>2</sup> + d<sup>2</sup>) / 2) ，它们的横坐标是相同的。因此，线段 EF 和 y 轴平行。<br>
 <br>
   <img alt="image placeholder" >
 <br>
接下来就容易了。作一条垂直于 EF 的直线，与函数图像交于 P 、 Q 两点。取 PQ 的中点 M 。过 M 作 EF 的平行线，这就是我们 y 轴。假设它与函数图像交于点 N ，则过 N 且垂直于 EF 的直线就是 x 轴了。</p></blockquote>
<p> <br>
 </p>
<blockquote><p>问题：证明，如果 a 、 b 、 c 分别是三角形的三边， A 、 B 、 C 分别是它们所对的角，那么一定有 (a + b – 2c) / sin(C / 2) + (b + c – 2a) / sin(A / 2) + (a + c – 2b) / sin(B / 2) ≥ 0 。</p></blockquote>
<p> </p>
<blockquote><p>答案：不等式可以重新整理为 (a – b)(1 / sin(B / 2) – 1 / sin(A / 2)) + (a – c)(1 / sin(C / 2) – 1 / sin(A / 2)) + (b – c)(1 / sin(C / 2) – 1 / sin(B / 2)) ≥ 0 。下面我们说明不等式左边的每一项都是非负数，从而证明不等式恒成立。考虑到对称性，我们只说明不等式左边的第一项是非负的即可。由于三角形中大边对大角，小边对小角，因而若 a ≥ b ，则 ∠A ≥ ∠B ；另外注意到 ∠A 、 ∠B 的取值都在 0° 到 180° 之间，从而 A / 2 和 B / 2 都在 0° 到 90° 的范围内，于是 ∠A ≥ ∠B 可以推出 sin(A / 2) ≥ sin(B / 2) 。反过来， a &lt; b 就说明 ∠A &lt; ∠B ，也即 sin(A / 2) &lt; sin(B / 2) 。因此， a – b 和 1 / sin(B / 2) – 1 / sin(A / 2) 一定是同号的，它们的乘积一定大于等于 0 。</p></blockquote>
<p> <br>
 </p>
<blockquote>
<p>问题：已知三角形 ABC ， ∠A 和 ∠C 的外角的角平分线恰好交于该三角形的外接圆上。给定 AB 和 BC 的长度，求三角形外接圆的半径。注意，这是一个“有点特别”的问题。</p>
<p> <br>
   <img alt="image placeholder" >
 </p>
</blockquote>
<p> </p>
<blockquote><p>答案：这是一个错题，题目中的条件根本不可能达到。一个三角形的两条角平分线根本不可能交在外接圆上。原因很简单，注意到 ∠BAD = (180° – ∠A) / 2 + ∠A = 90° + ∠A / 2 &gt; 90° ，类似地 ∠BCD = (180° – ∠C) / 2 + ∠C = 90° + ∠C / 2 &gt; 90° ，因此 ∠BAD + ∠BCD &gt; 180° 。然而，如果 A 、 B 、 C 、 D 真的四点共圆，那么 ∠BAD + ∠BCD 应该等于 180° 才对，于是产生矛盾。</p></blockquote>
<p> <br>
 </p>
<blockquote><p>问题：已知 a<sup>2</sup> + 4 · b<sup>2</sup> = 4 ，c · d = 4 。求证： (a – d)<sup>2</sup> + (b – c)<sup>2</sup> ≥ 1.6 。</p></blockquote>
<p> </p>
<blockquote><p>答案：我们要证明的其实就是，平面直角坐标系中的 (a, b) 和 (d, c) 两点的距离的平方大于等于 1.6 ，其中点 (a, b) 在椭圆 a<sup>2</sup> + 4 · b<sup>2</sup> = 4 上，点 (d, c) 在双曲线 c · d = 4 上。由于整个图像关于原点中心对称，我们只看椭圆与双曲线的其中一支即可。<br>
 <br>
   <img alt="image placeholder" >
 <br>
不难验证，直线 y = – x/2 + √<span style="text-decoration:overline">2</span> 与椭圆相切，直线 y = – x/2 + 2 · √<span style="text-decoration:overline">2</span> 与双曲线相切。这两条直线的斜率相同，说明它们是平行的；这看上去就好像一条公路一样，椭圆位于公路的一侧，双曲线位于公路的另一侧。不难求出这条公路的宽度（即两条平行线之间的距离）为 2 · √<span style="text-decoration:overline">2</span> / √<span style="text-decoration:overline">5</span> ，从椭圆上的一点走到双曲线上的一点无论如何都必须要经过这条公路，因此其路程一定大于 2 · √<span style="text-decoration:overline">2</span> / √<span style="text-decoration:overline">5</span> 。这说明 (a, b) 和 (d, c) 之间的距离不会小于 2 · √<span style="text-decoration:overline">2</span> / √<span style="text-decoration:overline">5</span> 。这说明 (a, b) 和 (d, c) 之间的距离的平方不会小于 8 / 5 ，即 1.6 。</p></blockquote>
<p> </p>
			 ]]></content>
<pubDate>2012-11-13T01:09:16+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5083</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：Ptolemy定理的无字证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/5094</link>
<content><![CDATA[ 
		<p>    Ptolemy 定理是平面几何中非常漂亮的定理：圆内接四边形的对边乘积之和等于对角线的乘积。具体地说，如果把一个圆内接四边形的四条边顺次记为 a 、 b 、 c 、 d ，把两条对角线的长度记为 e 和 f ，那么一定有 a · c + b · d = e · f 。 Ptolemy 是一个非常重要的定理，由它出发可以得出很多推论。例如，在圆内接矩形上应用 Ptolemy 定理，可以立即得到勾股定理。下面是另外两个可以用 Ptolemy 定理来解决的问题：<a href="http://www.matrix67.com/blog/archives/2324">证明余弦定理</a>，以及<a href="http://www.matrix67.com/blog/archives/4018">构造两两间的距离都是整数的点集</a>。</p>
<p>     William Derrick 和 James Hirstein 在最近的 The College Mathematics Journal 上给出了下面这个 Ptolemy 定理的无字证明，你能看明白吗？</p>
<p>      <img alt="image placeholder" >
<p><span id="more-5094"></span><br>
 <br>
    左图是一个圆内接四边形，由于同弧所对的圆周角相等，因而图中会产生四对相等的角，我们用 α 、 β 、 γ 、 δ 来标记。由于圆内接四边形对角互补，因此有 α + β + γ + δ = 180° 。现在，把阴影三角形放大到原来的 f 倍，这个三角形的三边将会变为 a · f 、 b · f 、 e · f  。把红色三角形放大到原来的 b 倍，于是三条边的长度将会变为 b · a 、 b · d 、 b · f 。注意到两个放大后的三角形都有一条长为 b · f 的边。同样地，把蓝色三角形放大 a 倍，三边长将变为 a · b 、 a · c 、 a · f ，它和放大版的阴影三角形都有一条长度为 a · f 边。因此，我们可以像右图那样，把三个放大版的三角形拼到一起。由于 α + β + γ + δ = 180° ，因此右图中上面那三个点是共线的，整个图形是一个四边形。观察四边形四个内角的关系可以很快看出，这个四边形是一个平行四边形。因而，它的上下两条对边应该相等，于是有 a · c + b · d = e · f 。</p>
<p> <br>
来源：<a href="http://www.cut-the-knot.org/proofs/PtolemyTheoremPWW.shtml">http://www.cut-the-knot.org/proofs/PtolemyTheoremPWW.shtml</a></p>
			 ]]></content>
<pubDate>2012-11-14T22:48:25+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5094</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 跨越千年的RSA算法 ]]></title>
<link>http://www.matrix67.com/blog/archives/5100</link>
<content><![CDATA[ 
		<p>    数论，数学中的皇冠，最纯粹的数学。早在古希腊时代，人们就开始痴迷地研究数字，沉浸于这个几乎没有任何实用价值的思维游戏中。直到计算机诞生之后，几千年来的数论研究成果突然有了实际的应用，这个过程可以说是最为激动人心的数学话题之一。最近我在《程序员》杂志上连载了《跨越千年的 RSA 算法》，但受篇幅限制，只有一万字左右的内容。其实，从数论到 RSA 算法，里面的数学之美哪里是一万字能扯完的？在写作的过程中，我查了很多资料，找到了很多漂亮的例子，也积累了很多个人的思考，但最终都因为篇幅原因没有加进《程序员》的文章中。今天，我想重新梳理一下线索，把所有值得分享的内容一次性地呈现在这篇长文中，希望大家会有所收获。需要注意的是，本文有意为了照顾可读性而牺牲了严谨性。很多具体内容都仅作了直观解释，一些“显然如此”的细节实际上是需要证明的。如果你希望看到有关定理及其证明的严格表述，可以参见任意一本初等数论的书。把本文作为初等数论的学习读物是非常危险的。最后，希望大家能够积极指出文章中的缺陷，我会不断地做出修改。</p>
<p>======= 更新记录 =======</p>
<p>2012 年 12 月 15 日：发布全文。<br>
2012 年 12 月 18 日：修改了几处表达。<br>
2021 年 9 月 13 日：根据 Chang 的指正做了修改。</p>
<p>======== 目录 ========</p>
<p>（一）可公度线段<br>
（二）中国剩余定理<br>
（三）扩展的辗转相除<br>
（四）Fermat 小定理<br>
（五）公钥加密的可能性<br>
（六）RSA 算法</p>
<p><span id="more-5100"></span><br>
 <br>
 <br>
（一）可公度线段</p>
<p>    Euclid ，中文译作“欧几里得”，古希腊数学家。他用公理化系统的方法归纳整理了当时的几何理论，并写成了伟大的数学著作《几何原本》，因而被后人称作“几何学之父”。有趣的是，《几何原本》一书里并不全讲的几何。全书共有十三卷，第七卷到第十卷所讨论的实际上是数论问题——只不过是以几何的方式来描述的。在《几何原本》中，数的大小用线段的长度来表示，越长的线段就表示越大的数。很多数字与数字之间的简单关系，在《几何原本》中都有对应的几何语言。例如，若数字 a 是数字 b 的整倍数，在《几何原本》中就表达为，长度为 a 的线段可以用长度为 b 的线段来度量。比方说，黑板的长度是 2.7 米，一支铅笔的长度是 18 厘米，你会发现黑板的长度正好等于 15 个铅笔的长度。我们就说，铅笔的长度可以用来度量黑板的长度。如果一张课桌的长度是 117 厘米，那么 6 个铅笔的长度不够课桌长， 7 个铅笔的长度又超过了课桌长，因而我们就无法用铅笔来度量课桌的长度了。哦，当然，实际上课桌长相当于 6.5 个铅笔长，但是铅笔上又没有刻度，我们用铅笔来度量课桌时，怎么知道最终结果是 6.5 个铅笔长呢？因而，只有 a 恰好是 b 的整数倍时，我们才说 b 可以度量 a 。</p>
<p>    给定两条长度不同的线段 a 和 b ，如果能够找到第三条线段 c ，它既可以度量 a ，又可以度量 b ，我们就说 a 和 b 是可公度的（ commensurable ，也叫做可通约的）， c 就是 a 和 b 的一个公度单位。举个例子： 1 英寸和 1 厘米是可公度的吗？历史上，英寸和厘米的换算关系不断在变，但现在，英寸已经有了一个明确的定义： 1 英寸精确地等于 2.54 厘米。因此，我们可以把 0.2 毫米当作单位长度，它就可以同时用于度量 1 英寸和 1 厘米： 1 英寸将正好等于 127 个单位长度， 1 厘米将正好等于 50 个单位长度。实际上， 0.1 毫米、 0.04 毫米 、 (0.2 / 3) 毫米也都可以用作 1 英寸和 1 厘米的公度单位，不过 0.2 毫米是最大的公度单位。</p>
<p>    等等，我们怎么知道 0.2 毫米是最大的公度单位？更一般地，任意给定两条线段后，我们怎么求出这两条线段的最大公度单位呢？在《几何原本》第七卷的命题 2 当中， Euclid 给出了一种求最大公度单位的通用算法，这就是后来所说的 Euclid 算法。这种方法其实非常直观。假如我们要求线段 a 和线段 b 的最大公度单位，不妨假设 a 比 b 更长。如果 b 正好能度量 a ，那么考虑到 b 当然也能度量它自身，因而 b 就是 a 和 b 的一个公度单位；如果 b 不能度量 a ，这说明 a 的长度等于 b 的某个整倍数，再加上一个零头。我们不妨把这个零头的长度记作 c 。如果有某条线段能够同时度量 b 和 c ，那么它显然也就能度量 a 。也就是说，为了找到 a 和 b 的公度单位，我们只需要去寻找 b 和 c 的公度单位即可。怎样找呢？我们故技重施，看看 c 是否能正好度量 b 。如果 c 正好能度量 b ，c 就是 b 和 c 的公度单位，从而也就是 a 和 b 的公度单位；如果 c 不能度量 b ，那看一看 b 被 c 度量之后剩余的零头，把它记作 d ，然后继续用 d 度量 c ，并不断这样继续下去，直到某一步没有零头了为止。</p>
<p>      <img alt="image placeholder" >
<p>    我们还是来看一个实际的例子吧。让我们试着找出 690 和 2202 的公度单位。显然， 1 是它们的一个公度单位， 2 也是它们的一个公度单位。我们希望用 Euclid 的算法求出它们的最大公度单位。首先，用 690 去度量 2202 ，结果发现 3 个 690 等于 2070 ，度量 2202 时会有一个大小为 132 的零头。接下来，我们用 132 去度量 690 ，这将会产生一个 690 – 132 × 5 = 30 的零头。用 30 去度量 132 ，仍然会有一个大小为 132 – 30 × 4 = 12 零头。再用 12 去度量 30 ，零头为 30 – 12 × 2 = 6 。最后，我们用 6 去度量 12 ，你会发现这回终于没有零头了。因此， 6 就是 6 和 12 的一个公度单位，从而是 12 和 30 的公度单位，从而是 30 和 132 的公度单位，从而是 132 和 690 的公度单位，从而是 690 和 2202 的公度单位。</p>
<p>      <img alt="image placeholder" >
<p>    我们不妨把 Euclid 算法对 a 和 b 进行这番折腾后得到的结果记作 x 。从上面的描述中我们看出， x 确实是 a 和 b 的公度单位。不过，它为什么一定是最大的公度单位呢？为了说明这一点，下面我们来证明，事实上， a 和 b 的任意一个公度单位一定能够度量 x ，从而不会超过 x 。如果某条长为 y 的线段能同时度量 a 和 b ，那么注意到，它能度量 b 就意味着它能度量 b 的任意整倍数，要想让它也能度量 a 的话，只须而且必须让它能够度量 c 。于是， y 也就能够同时度量 b 和 c ，根据同样的道理，这又可以推出 y 一定能度量 d ……因此，最后你会发现， y 一定能度量 x 。</p>
<p>    用现在的话来讲，求两条线段的最大公度单位，实际上就是求两个数的最大公约数——最大的能同时整除这两个数的数。用现在的话来描述 Euclid 算法也会简明得多：假设刚开始的两个数是 a 和 b ，其中 a &gt; b ，那么把 a 除以 b 的余数记作 c ，把 b 除以 c 的余数记作 d ，c 除以 d 余 e ， d 除以 e 余 f ，等等等等，不断拿上一步的除数去除以上一步的余数。直到某一次除法余数为 0 了，那么此时的除数就是最终结果。因此， Euclid 算法又有一个形象的名字，叫做“辗转相除法”。</p>
<p>    辗转相除法的效率非常高，刚才大家已经看到了，计算 690 和 2202 的最大公约数时，我们依次得到的余数是 132, 30, 12, 6 ，做第 5 次除法时就除尽了。实际上，我们可以大致估计出辗转相除法的效率。第一次做除法时，我们是用 a 来除以 b ，把余数记作 c 。如果 b 的值不超过 a 的一半，那么 c 更不会超过 a 的一半（因为余数小于除数）；如果 b 的值超过了 a 的一半，那么显然 c 直接就等于 a – b ，同样小于 a 的一半。因此，不管怎样， c 都会小于 a 的一半。下一步轮到 b 除以 c ，根据同样的道理，所得的余数 d 会小于 b 的一半。接下来， e 将小于 c 的一半， f 将小于 d 的一半，等等等等。按照这种速度递减下去的话，即使最开始的数是上百位的大数，不到 1000 次除法就会变成一位数（如果算法没有提前结束的话），交给计算机来执行的话保证秒杀。用专业的说法就是，辗转相除法的运算次数是对数级别的。</p>
<p>    很长一段时间里，古希腊人都认为，任意两条线段都是可以公度的，我们只需要做一遍辗转相除便能把这个公度单位给找出来。事实真的如此吗？辗转相除法有可能失效吗？我们至少能想到一种可能：会不会有两条长度关系非常特殊的线段，让辗转相除永远达不到终止的条件，从而根本不能算出一个“最终结果”？注意，线段的长度不一定（也几乎不可能）恰好是整数或者有限小数，它们往往是一些根本不能用有限的方式精确表示出来的数。考虑到这一点，两条线段不可公度完全是有可能的。</p>
<p>    为了让两条线段辗转相除永远除不尽，我们有一种绝妙的构造思路：让线段 a 和 b 的比值恰好等于线段 b 和 c 的比值。这样，辗转相除一次后，两数的关系又回到了起点。今后每一次辗转相除，余数总会占据除数的某个相同的比例，于是永远不会出现除尽的情况。不妨假设一种最为简单的情况，即 a 最多只能包含一个 b 的长度，此时 c 等于 a – b 。解方程 a / b = b / (a – b) 可以得到 a : b = 1 : (√<span style="text-decoration:overline">5</span> – 1) / 2 ，约等于一个大家非常熟悉的比值 1: 0.618 。于是我们马上得出：成黄金比例的两条线段是不可公度的。</p>
<p>      <img alt="image placeholder" >
<p>    更典型的例子则是，正方形的边长和对角线是不可公度的。让我们画个图来说明这一点。如图，我们试着用辗转相除求出边长 AB 和对角线 AC 的最大公度单位。按照规则，第一步我们应该用 AB 去度量 AC ，假设所得的零头是 EC 。下一步，我们应该用 EC 去度量 AB ，或者说用 EC 去度量 BC （反正正方形各边都相等）。让我们以 EC 为边作一个小正方形 CEFG ，容易看出 F 点将正好落在 BC 上，同时三角形 AEF 和三角形 ABF 将会由于 HL 全等。因此， EC = EF = BF 。注意到 BC 上已经有一段 BF 和 EC 是相等的了，因而我们用 EC 去度量 BC 所剩的零头，也就相当于用 EC 去度量 FC 所剩的零头。结果又回到了最初的局面——寻找正方形的边长和对角线的公度单位。因而，辗转相除永远不会结束。线段 AB 的长度和线段 AC 的长度不能公度，它们处于两个不同的世界中。</p>
<p>      <img alt="image placeholder" >
<p>    如果正方形 ABCD 的边长 1 ，正方形的面积也就是 1 。从上图中可以看到，若以对角线 AC 为边做一个大正方形，它的面积就该是 2 。因而， AC 就应该是一个与自身相乘之后恰好等于 2 的数，我们通常把这个数记作 √<span style="text-decoration:overline">2</span> 。《几何原本》的第十卷专门研究不可公度量，其中就有一段 1 和 √<span style="text-decoration:overline">2</span> 不可公度的证明，但所用的方法不是我们上面讲的这种，而更接近于课本上的证明：设 √<span style="text-decoration:overline">2</span> = p / q ，其中 p / q 已是最简分数，但推着推着就发现，这将意味着 p 和 q 都是偶数，与最简分数的假设矛盾。</p>
<p>    用今天的话来讲， 1 和 √<span style="text-decoration:overline">2</span> 不可公度，实际上相当于是说  √<span style="text-decoration:overline">2</span> 是无理数。因此，古希腊人发现了无理数，这确实当属不争的事实。奇怪的是，无理数的发现常常会几乎毫无根据地归功于一个史料记载严重不足的古希腊数学家 Hippasus 。根据各种不靠谱的描述， Hippasus 的发现触犯了 Pythagoras （古希腊哲学家）的教条，最后被溺死在了海里。</p>
<p>    可公度线段和不可公度线段的概念与有理数和无理数的概念非常接近，我们甚至可以说明这两个概念是等价的——它们之间有一种很巧妙的等价关系。注意到，即使 a 和 b 本身都是无理数， a 和 b 还是有可能被公度的，例如 a = √<span style="text-decoration:overline">2</span> 并且 b = 2 · √<span style="text-decoration:overline">2</span> 的时候。不过，有一件事我们可以肯定： a 和 b 的比值一定是一个有理数。事实上，可以证明，线段 a 和 b 是可公度的，当且仅当 a / b 是一个有理数。线段 a 和 b 是可公度的，说明存在一个 c 以及两个整数 m 和 n ，使得 a = m · c ，并且 b = n · c 。于是 a / b = (m · c) / (n · c) = m / n ，这是一个有理数。反过来，如果 a / b 是一个有理数，说明存在整数 m 和 n 使得 a / b = m / n ，等式变形后可得 a / m = b / n ，令这个商为 c ，那么 c 就可以作为 a 和 b 的公度单位。</p>
<p>    有时候，“是否可以公度”的说法甚至比“是否有理”更好一些，因为这是一个相对的概念，不是一个绝对的概念。当我们遇到生活当中的某个物理量时，我们绝不能指着它就说“这是一个有理的量”或者“这是一个无理的量”，我们只能说，以某某某（比如 1 厘米、 1 英寸、 0.2 毫米或者一支铅笔的长度等等）作为单位来衡量时，这是一个有理的量或者无理的量。考虑到所选用的单位长度本身也是由另一个物理量定义出来的（比如 1 米被定义为光在真空中 1 秒走过的路程的 1 / 299792458 ），因而在讨论一个物理量是否是有理数时，我们讨论的其实是两个物理量是否可以被公度。</p>
<p> <br>
（二）中国剩余定理</p>
<p>    如果两个正整数的最大公约数为 1 ，我们就说这两个数是互质的。这是一个非常重要的概念。如果 a 和 b 互质，这就意味着分数 a / b 已经不能再约分了，意味着 a × b 的棋盘的对角线不会经过中间的任何交叉点，意味着循环长度分别为 a 和 b 的两个周期性事件一同上演，则新的循环长度最短为 a · b 。</p>
<p>      <img alt="image placeholder" >
<p>    最后一点可能需要一些解释。让我们来举些例子。假如有 1 路和 2 路两种公交车，其中 1 路车每 6 分钟一班，2 路车每 8 分钟一班。如果你刚刚错过两路公交车同时出发的壮景，那么下一次再遇到这样的事情是多少分钟之后呢？当然， 6 × 8 = 48 分钟，这是一个正确的答案，此时 1 路公交车正好是第 8 班， 2 路公交车正好是第 6 班。不过，实际上，在第 24 分钟就已经出现了两车再次同发的情况了，此时 1 路车正好是第 4 班， 2 路车正好是第 3 班。但是，如果把例子中的 6 分钟和 8 分钟分别改成 4 分钟和 7 分钟，那么要想等到两车再次同发，等到第 4 × 7 = 28 分钟是必须的。类似的，假如某一首歌的长度正好是 6 分钟，另一首歌的长度正好是 8 分钟，让两首歌各自循环播放， 6 × 8 = 48 分钟之后你听到的“合声”将会重复，但实际上第 24 分钟就已经开始重复了。但若两首歌的长度分别是 4 分钟和 7 分钟，则必须到第 4 × 7 = 28 分钟之后才有重复，循环现象不会提前发生。</p>
<p>    究其原因，其实就是，对于任意两个数，两个数的乘积一定是它们的一个公倍数，但若这两个数互质，则它们的乘积一定是它们的<strong>最小</strong>公倍数。事实上，我们还能证明一个更强的结论： a 和 b 的最大公约数和最小公倍数的乘积，一定等于 a 和 b 的乘积。在第四节中，我们会给出一个证明。</p>
<p>    很多更复杂的数学现象也都跟互质有关。《孙子算经》卷下第二十六问：“今有物，不知其数。三、三数之，剩二；五、五数之，剩三；七、七数之，剩二。问物几何？答曰：二十三。”翻译过来，就是有一堆东西，三个三个数余 2 ，五个五个数余 3 ，七个七个数余 2 ，问这堆东西有多少个？《孙子算经》给出的答案是 23 个。当然，这个问题还有很多其他的解。由于 105 = 3 × 5 × 7 ，因而 105 这个数被 3 除、被 5 除、被 7 除都能除尽。所以，在 23 的基础上额外加上一个 105 ，得到的 128 也是满足要求的解。当然，我们还可以在 23 的基础上加上 2 个 105 ，加上 3 个 105 ，等等，所得的数都满足要求。除了形如 23 + 105n 的数以外，还有别的解吗？没有了。事实上，不管物体总数除以 3 的余数、除以 5 的余数以及除以 7 的余数分别是多少，在 0 到 104 当中总存在唯一解；在这个解的基础上再加上 105 的整倍数后，可以得到其他所有的正整数解。后人将其表述为“中国剩余定理”：给出 m 个两两互质的整数，它们的乘积为 P ；假设有一个未知数 M ，如果我们已知 M 分别除以这 m 个数所得的余数，那么在 0 到 P – 1 的范围内，我们可以唯一地确定这个 M 。这可以看作是 M 的一个特解。其他所有满足要求的 M ，则正好是那些除以 P 之后余数等于这个特解的数。注意，除数互质的条件是必需的，否则结论就不成立了。比如说，在 0 到 7 的范围内，除以 4 余 1 并且除以 2 也余 1 的数有 2 个，除以 4 余 1 并且除以 2 余 0 的数则一个也没有。</p>
<p>    从某种角度来说，中国剩余定理几乎是显然的。让我们以两个除数的情况为例，来说明中国剩余定理背后的直觉吧。假设两个除数分别是 4 和 7 。下表显示的就是各自然数除以 4 和除以 7 的余数情况，其中 x mod y 表示 x 除以 y 的余数，这个记号后面还会用到。</p>
<table border="1" style="border-collapse:collapse; margin-left: 30px; width:auto;">
<tr>
<td>i</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
</tr>
<tr>
<td>i mod 4</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>i mod 7</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>i</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
<td>32</td>
<td>33</td>
<td>34</td>
<td>35</td>
<td>36</td>
<td>37</td>
<td>38</td>
<td>39</td>
</tr>
<tr>
<td>i mod 4</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>i mod 7</td>
<td>6</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</table>
<p>    i mod 4 的值显然是以 4 为周期在循环， i mod 7 的值显然是以 7 为周期在循环。由于 4 和 7 是互质的，它们的最小公倍数是 4 × 7 = 28 ，因而 (i mod 4, i mod 7) 的循环周期是 28 ，不会更短。因此，当 i 从 0 增加到 27 时， (i mod 4, i mod 7) 的值始终没有出现重复。但是， (i mod 4, i mod 7) 也就只有 4 × 7 = 28 种不同的取值，因而它们正好既无重复又无遗漏地分给了 0 到 27 之间的数。这说明，每个特定的余数组合都在前 28 项中出现过，并且都只出现过一次。在此之后，余数组合将产生长度为 28 的循环，于是每个特定的余数组合都将会以 28 为周期重复出现。这正是中国剩余定理的内容。</p>
<p>    中国剩余定理有很多漂亮的应用，这里我想说一个我最喜欢的。设想这样一个场景：总部打算把一份秘密文件发送给 5 名特工，但直接把文件原封不动地发给每个人，很难保障安全性。万一有特工背叛或者被捕，把秘密泄露给了敌人怎么办？于是就有了电影和小说中经常出现的情节：把绝密文件拆成 5 份， 5 名特工各自只持有文件的 1/5 。不过，原来的问题并没有彻底解决，我们只能祈祷坏人窃取到的并不是最关键的文件片段。因此，更好的做法是对原文件进行加密，每名特工只持有密码的 1/5 ，这 5 名特工需要同时在场才能获取文件全文。但这也有一个隐患：如果真的有特工被抓了，当坏人们发现只拿到其中一份密码没有任何用处的同时，特工们也会因为少一份密码无法解开全文而烦恼。此时，你或许会想，是否有什么办法能够让特工们仍然可以恢复原文，即使一部分特工被抓住了？换句话说，有没有什么密文发布方式，使得只要 5 个人中半数以上的人在场就可以解开绝密文件？这样的话，坏人必须要能操纵半数以上的特工才可能对秘密文件造成实质性的影响。这种秘密共享方式被称为 (3, 5) 门限方案，意即 5 个人中至少 3 人在场才能解开密文。</p>
<p>    利用中国剩余定理，我们可以得到一种巧妙的方案。回想中国剩余定理的内容：给定 m 个两两互质的整数，它们的乘积为 P ；假设有一个未知数 M ，如果我们已知 M 分别除以这 m 个数所得的余数，那么在 0 到 P – 1 的范围内，我们可以唯一地确定这个 M 。我们可以想办法构造这样一种情况， n 个数之中任意 m 个的乘积都比 M 大，但是任意 m – 1 个数的乘积就比 M 小。这样，任意 m 个除数就能唯一地确定 M ，但 m – 1 个数就不足以求出 M 来。 Mignotte 门限方案就用到了这样一个思路。我们选取 n 个两两互质的数，使得最小的 m 个数的乘积比最大的 m – 1 个数的乘积还大。例如，在 (3, 5) 门限方案中，我们可以取 53 、 59 、 64 、 67 、 71 这 5 个数，前面 3 个数乘起来得 200128 ，而后面两个数相乘才得 4757 。我们把文件的密码设为一个 4757 和 200128 之间的整数，比如 123456 。分别算出 123456 除以上面那 5 个数的余数，得到 19 、 28 、 0 、 42 、 58 。然后，把 (53, 19) 、 (59, 28) 、 (64, 0) 、 (67, 42) 、 (71, 58) 分别告诉 5 名特工，也就是说特工 1 只知道密码除以 53 余 19 ，特工 2 只知道密码除以 59 余 28 ，等等。这样，根据中国剩余定理，任意 3 名特工碰头后就可以唯一地确定出 123456 ，但根据 2 名特工手中的信息只能得到成百上千个不定解。例如，假设我们知道了 x 除以 59 余 28 ，也知道了 x 除以 67 余 42 ，那么我们只能确定在 0 和 59 × 67 – 1 之间有一个解 913 ，在 913 的基础上加上 59 × 67 的整倍数，可以得到其他满足要求的 x ，而真正的 M 则可以是其中的任意一个数。</p>
<p>    不过，为了让 Mignotte 门限方案真正可行，我们还需要一种根据余数信息反推出 M 的方法。换句话说，我们需要有一种通用的方法，能够回答《孙子算经》中提出的那个问题。我们会在下一节中讲到。</p>
<p> <br>
（三）扩展的辗转相除</p>
<p>    中国剩余定理是一个很基本的定理。很多数学现象都可以用中国剩余定理来解释。背九九乘法口诀表时，你或许会发现，写下 3 × 1, 3 × 2, …, 3 × 9 ，它们的个位数正好遍历了 1 到 9 所有的情况。 7 的倍数、 9 的倍数也是如此，但 2 、 4 、 5 、 6 、 8 就不行。 3 、 7 、 9 这三个数究竟有什么特别的地方呢？秘密就在于， 3 、 7 、 9 都是和 10 互质的。比如说 3 ，由于 3 和 10 是互质的，那么根据中国剩余定理，在 0 到 29 之间一定有这样一个数，它除以 3 余 0 ，并且除以 10 余 1 。它将会是 3 的某个整倍数，并且个位为 1 。同样地，在 0 到 29 之间也一定有一个 3 的整倍数，它的个位是 2 ；在 0 到 29 之间也一定有一个 3 的整倍数，它的个位是 3 ……而在 0 到 29 之间，除掉 0 以外， 3 的整倍数正好有 9 个，于是它们的末位就正好既无重复又无遗漏地取遍了 1 到 9 所有的数字。</p>
<p>    这表明，如果 a 和 n 互质，那么 a · x mod n = 1 、 a · x mod n = 2 等所有方程都是有解的。 18 世纪的法国数学家 Étienne Bézout 曾经证明了一个基本上与此等价的定理，这里我们姑且把它叫做“ Bézout 定理”。事实上，我们不但知道上述方程是有解的，还能求出所有满足要求的解来。</p>
<p>    我们不妨花点时间，把方程 a · x mod n = b 和中国剩余定理的关系再理一下。寻找方程 a · x mod n = b 的解，相当于寻找一个 a 的倍数使得它除以 n 余 b ，或者说是寻找一个数 M 同时满足 M mod a = 0 且 M mod n = b 。如果 a 和 n 是互质的，那么根据中国剩余定理，这样的 M 一定存在，并且找到一个这样的 M 之后，在它的基础上加减 a · n 的整倍数，可以得到所有满足要求的 M 。因此，为了解出方程 a · x mod n = b 的所有解，我们也只需要解出方程的某个特解就行了。假如我们找到了方程 a · x mod n = b 中 x 的一个解，在这个解的基础上加上或减去 n 的倍数（相当于在整个被除数 a · x 的基础上加上或者减去 a · n 的倍数，这里的 a · x 就是前面所说的 M ），就能得到所有的解了。</p>
<p>    更妙的是，我们其实只需要考虑形如 a · x mod n = 1 的方程。因为，如果能解出这样的方程， a · x mod n = 2 、 a · x mod n = 3 也都自动地获解了。假如 a · x mod n = 1 有一个解 x = 100 ，由于 100 个 a 除以 n 余 1 ，自然 200 个 a 除以 n 就余 2 ， 300 个 a 除以 n 就余 3 ，等等，等式右边余数不为 1 的方程也都解开了。</p>
<p>    让我们尝试求解 115x mod 367 = 1 。注意，由于 115 和 367 是互质的，因此方程确实有解。我们解方程的基本思路是，不断寻找 115 的某个倍数以及 367 的某个倍数，使得它们之间的差越来越小，直到最终变为 1 。由于 367 除以 115 得 3 ，余 22 ，因而 3 个 115 只比 367 少 22 。于是， 15 个 115 就要比 5 个 367 少 110 ，从而 16 个 115 就会比 5 个 367 多 5 。好了，真正巧妙的就在这里了： 16 个 115 比 5 个 367 多 5 ，但 3 个 115 比 1 个 367 少 22 ，两者结合起来，我们便能找到 115 的某个倍数和 367 的某个倍数，它们只相差 2 ： 16 个 115 比 5 个 367 多 5 ，说明 64 个 115 比 20 个 367 多 20 ，又考虑到 3 个 115 比 1 个 367 少 22 ，于是 67 个 115 只比 21 个 367 少 2 。现在，结合“少 2 ”和“多 5 ”两个式子，我们就能把差距缩小到 1 了： 67 个 115 比 21 个 367 少 2 ，说明 134 个 115 比 42 个 367 少 4 ，而 16 个 115 比 5 个 367 多 5 ，于是 150 个 115 比 47 个 367 多 1 。这样，我们就解出了一个满足 115x mod 367 = 1 的 x ，即 x = 150 。大家会发现，在求解过程，我们相当于对 115 和 367 做了一遍辗转相除：我们不断给出 115 的某个倍数和 367 的某个倍数，通过辗转对比最近的两个结果，让它们的差距从“少 22 ”缩小到“多 5 ”，再到“少 2 ”、“多 1 ”，其中 22, 5, 2, 1 这几个数正是用辗转相除法求 115 和 367 的最大公约数时将会经历的数。因而，算法的步骤数仍然是对数级别的，即使面对上百位上千位的大数，计算机也毫无压力。这种求解方程 a · x mod n = b 的算法就叫做“扩展的辗转相除法”。</p>
<p>    注意，整个算法有时也会以“少 1 ”的形式告终。例如，用此方法求解 128x mod 367 = 1 时，最后会得出 43 个 128 比 15 个 367 少 1 。这下怎么办呢？很简单， 43 个 128 比 15 个 367 少 1 ，但是 367 个 128 显然等于 128 个 367 ，对比两个式子可知， 324 个 128 就会比 113 个 367 多 1 了，于是得到 x = 324 。</p>
<p>    最后还有一个问题：我们最终总能到达“多 1 ”或者“少 1 ”，这正是因为一开始的两个数是互质的。如果方程 a · x mod n = b 当中 a 和 n 不互质，它们的最大公约数是 d &gt; 1 ，那么在 a 和 n 之间做辗转相除时，算到 d 就直接终止了。自然，扩展的辗转相除也将在到达“多 1 ”或者“少 1 ”之前提前结束。那怎么办呢？我们有一种巧妙的处理方法：以 d 为单位重新去度量 a 和 n （或者说让 a 和 n 都除以 d ），问题就变成我们熟悉的情况了。让我们来举个例子吧。假如我们要解方程 24 · x mod 42 = 30 ，为了方便后面的解释，我们来给这个方程编造一个背景：说一盒鸡蛋 24 个，那么买多少盒鸡蛋，才能让所有的鸡蛋 42 个 42 个地数最后正好能余 30 个？我们发现 24 和 42 不是互质的，扩展的辗转相除似乎就没有用了。不过没关系。我们找出 24 和 42 的最大公约数，发现它们的最大公约数是 6 。现在，让 24 和 42 都来除以 6 ，分别得到 4 和 7 。由于 6 已经是 24 和 42 的公约数中最大的了，因此把 24 和 42 当中的 6 除掉后，剩下的 4 和 7 就不再有大于 1 的公约数，从而就是互质的了。好了，现在我们把题目改编一下，把每 6 个鸡蛋视为一个新的单位量，比如说“ 1 把”。记住， 1 把鸡蛋就是 6 个鸡蛋。于是，原问题就变成了，每个盒子能装 4 把鸡蛋，那么买多少盒鸡蛋，才能让所有的鸡蛋 7 把 7 把地数，最后正好会余 5 把？于是，方程就变成了 4 · x mod 7 = 5 。由于此时 4 和 7 是互质的了，因而套用扩展的辗转相除法，此方程一定有解。可以解出特解 x = 3 ，在它的基础上加减 7 的整倍数，可以得到其他所有满足要求的 x 。这就是改编之后的问题的解。但是，虽说我们对原题做了“改编”，题目内容本身却完全没变，连数值都没变，只不过换了一种说法。改编后的题目里需要买 3 盒鸡蛋，改编前的题目里当然也是要买 3 盒鸡蛋。 x = 3 ，以及所有形如 3 + 7n 的数，也都是原方程的解。</p>
<p>    大家或许已经看到了，我们成功地找到了 24 · x mod 42 = 30 的解，依赖于一个巧合： 24 和 42 的最大公约数 6 ，正好也是 30 的约数。因此，改用“把”作单位重新叙述问题，正好最后的“余 30 个”变成了“余 5 把”，依旧是一个整数。如果原方程是 24 · x mod 42 = 31 的话，我们就没有那么走运了，问题将变成“买多少盒才能让最后数完余 5 又 1/6 把”。这怎么可能呢？我们是整把整把地买，整把整把地数，当然余数也是整把整把的。因此，方程 24 · x mod 42 = 31 显然无解。</p>
<p>    综上所述，如果关于 x 的方程 a · x mod n = b 当中的 a 和 n 不互质，那么求出 a 和 n 的最大公约数 d 。如果 b 恰好是 d 的整倍数，那么把方程中的 a 、 n 、 b 全都除以 d ，新的 a 和 n 就互质了，新的 b 也恰好为整数，用扩展的辗转相除求解新方程，得到的解也就是原方程的解。但若 b 不是 d 的整倍数，则方程无解。</p>
<p>    扩展的辗转相除法有很多应用，其中一个有趣的应用就是大家小时候肯定见过的“倒水问题”。假如你有一个 3 升的容器和一个 5 升的容器（以及充足的水源），如何精确地取出 4 升的水来？为了叙述简便，我们不妨把 3 升的容器和 5 升的容器分别记作容器 A 和容器 B 。一种解法如下：</p>
<p>      1. 将 A 装满，此时 A 中的水为 3 升， B 中的水为 0 升；<br>
      2. 将 A 里的水全部倒入 B ，此时 A 中的水为 0 升， B 中的水为 3 升；<br>
      3. 将 A 装满，此时 A 中的水为 3 升， B 中的水为 3 升；<br>
      4. 将 A 里的水倒入 B 直到把 B 装满，此时 A 中的水为 1 升， B 中的水为 5 升；<br>
      5. 将 B 里的水全部倒掉，此时 A 中的水为 1 升， B 中的水为 0 升；<br>
      6. 将 A 里剩余的水全部倒入 B ，此时 A 中的水为 0 升， B 中的水为 1 升；<br>
      7. 将 A 装满，此时 A 中的水为 3 升， B 中的水为 1 升；<br>
      8. 将 A 里的水全部倒入 B ，此时 A 中的水为 0 升， B 中的水为 4 升；</p>
<p>    这样，我们就得到 4 升的水了。显然，这类问题可以编出无穷多个来，比如能否用 7 升的水杯和 13 升的水杯量出 5 升的水，能否又用 9 升的水杯和 15 升的水杯量出 10 升的水，等等。这样的问题有什么万能解法吗？有！注意到，前面用 3 升的水杯和 5 升的水杯量出 4 升的水，看似复杂的步骤可以简单地概括为：不断将整杯整杯的 A 往 B 里倒，期间只要 B 被装满就把 B 倒空。由于 3 × 3 mod 5 = 4 ，因而把 3 杯的 A 全部倒进 B 里，并且每装满一个 B 就把水倒掉， B 里面正好会剩下 4 升的水。类似地，用容积分别为 a 和 b 的水杯量出体积为 c 的水，实际上相当于解方程 a · x mod b = c 。如果 c 是 a 和 b 的最大公约数，或者能被它们的最大公约数整除，用扩展的辗转相除便能求出 x ，得到对应的量水方案。特别地，如果两个水杯的容积互质，问题将保证有解。如果 c 不能被 a 和 b 的最大公约数整除，方程就没有解了，怎么办？不用着急，因为很显然，此时问题正好也没有解。比方说 9 和 15 都是 3 的倍数，那我们就把每 3 升的水视作一个单位，于是你会发现，在 9 升和 15 升之间加加减减，倒来倒去，得到的量永远只能在 3 的倍数当中转，绝不可能弄出 10 升的水来。这样一来，我们就给出了问题有解无解的判断方法，以及在有解时生成一种合法解的方法，从而完美地解决了倒水问题。</p>
<p>    最后，让我们把上一节留下的一点悬念给补完：怎样求解《孙子算经》中的“今有物，不知其数”一题。已知有一堆东西，三个三个数余 2 ，五个五个数余 3 ，七个七个数余 2 ，问这堆东西有多少个？根据中国剩余定理，由于除数 3 、 5 、 7 两两互质，因而在 0 到 104 之间，该问题有唯一的答案。我们求解的基本思路就是，依次找出满足每个条件，但是又不会破坏掉其他条件的数。我们首先要寻找一个数，它既是 5 的倍数，又是 7 的倍数，同时除以 3 正好余 2 。这相当于是在问， 35 的多少倍除以 3 将会余 2 。于是，我们利用扩展的辗转相除法求解方程 35x mod 3 = 2 。这个方程是一定有解的，因为 5 和 3 、 7 和 3 都是互质的，从而 5 × 7 和 3 也是互质的（到了下一节，这一点会变得很显然）。解这个方程可得 x = 1 。于是， 35 就是我们要找到的数。第二步，是寻找这么一个数，它既是 3 的倍数，又是 7 的倍数，同时除以 5 余 3 。这相当于求解方程 21x mod 5 = 3 ，根据和刚才相同的道理，这个方程一定有解。可以解得 x = 3 ，因此我们要找的数就是 63 。最后，我们需要寻找一个数，它能同时被 3 和 5 整除，但被 7 除余 2 。这相当于求解方程 15x mod 7 = 2 ，解得 x = 2 。我们想要找的数就是 30 。现在，如果我们把 35 、 63 和 30 这三个数加在一起会怎么样？它将会同时满足题目当中的三个条件！它满足“三个三个数余 2 ”，因为 35 除以 3 是余 2 的，而后面两个数都是 3 的整倍数，所以加在一起后除以 3 仍然余 2 。类似地，它满足“五个五个数余 3 ”，因为 63 除以 5 余 3 ，另外两个数都是 5 的倍数。类似地，它也满足“七个七个数余 2 ”，因而它就是原问题的一个解。你可以验证一下， 35 + 63 + 30 = 128 ，它确实满足题目的所有要求！为了得出一个 0 到 104 之间的解，我们在 128 的基础上减去一个 105 ，于是正好得到《孙子算经》当中给出的答案， 23 。</p>
<p>    已知 M 除以 m 个两两互质的数之后所得的余数，利用类似的方法总能反解出 M 来。至此，我们也就完成了 Mignotte 秘密共享方案的最后一环。</p>
<p> <br>
（四）Fermat 小定理</p>
<p>    很多自然数都可以被分解成一些更小的数的乘积，例如 12 可以被分成 4 乘以 3 ，其中 4 还可以继续地被分成 2 乘以 2 ，因而我们可以把 12 写作 2 × 2 × 3 。此时， 2 和 3 都不能再继续分解了，它们是最基本、最纯净的数。我们就把这样的数叫做“质数”或者“素数”。同样地， 2 、 3 、 5 、 7 、 11 、 13 等等都是不可分解的，它们也都是质数。它们是自然数的构件，是自然数世界的基本元素。 12 是由两个 2 和一个 3 组成的，正如水分子是由两个氢原子和一个氧原子组成的一样。只不过，和化学世界不同的是，自然数世界里的基本元素是无限的——质数有无穷多个。</p>
<p>    关于为什么质数有无穷多个，古希腊的 Euclid 有一个非常漂亮的证明。假设质数只有有限个，其中最大的那个质数为 p 。现在，把所有的质数全部乘起来，再加上 1 ，得到一个新的数 N 。也就是说， N 等于 2 · 3 · 5 · 7 · … · p + 1 。注意到， N 除以每一个质数都会余 1 ，比如 N 除以 2 就会商 3 · 5 · 7 · … · p 余 1 ， N 除以 3 就会商 2 · 5 · 7 · … · p 余 1 ，等等。这意味着， N 不能被任何一个质数整除，换句话说 N 是不能被分解的，它本身就是质数。然而这也不对，因为 p 已经是最大的质数了，于是产生了矛盾。这说明，我们刚开始的假设是错的，质数应该有无穷多个。需要额外说明的一点是，这个证明容易让人产生一个误解，即把头 n 个质数乘起来再加 1 ，总能产生一个新的质数。这是不对的，因为既然我们无法把全部质数都乘起来，那么所得的数就有可能是由那些我们没有乘进去的质数构成的，比如 2 · 3 · 5 · 7 · 11 · 13 + 1 = 30031 ，它可以被分解成 59 × 509 。</p>
<p>    从古希腊时代开始，人们就近乎疯狂地想要认识自然数的本质规律。组成自然数的基本元素自然地就成为了一个绝佳的突破口，于是对质数的研究成为了探索自然数世界的一个永久的话题。这就是我们今天所说的“数论”。</p>
<p>    用质数理论来研究数，真的会非常方便。 a 是 b 的倍数（或者说 a 能被 b 整除， b 是 a 的约数），意思就是 a 拥有 b 所含的每一种质数，而且个数不会更少。我们举个例子吧，比如说 b = 12 ，它可以被分解成 2 × 2 × 3 ， a = 180 ，可以被分解成 2 × 2 × 3 × 3 × 5 。 b 里面有两个 2 ，这不稀罕， a 里面也有两个 2 ； b 里面有一个 3 ，这也没什么， a 里面有两个 3 呢。况且， a 里面还包含有 b 没有的质数， 5 。对于每一种质数， b 里面所含的个数都比不过 a ，这其实就表明了 b 就是 a 的约数。</p>
<p>    现在，假设 a = 36 = 2 × 2 × 3 × 3 ， b = 120 = 2 × 2 × 2 × 3 × 5 。那么， a 和 b 的最大公约数是多少？我们可以依次考察，最大公约数里面可以包含哪些质数，每个质数都能有多少个。这个最大公约数最多可以包含多少个质数 2 ？显然最多只能包含两个，否则它就不能整除 a 了；这个最大公约数最多可以包含多少个质数 3 ？显然最多只能包含一个，否则它就不能整除 b 了；这个最大公约数最多可以包含多少个质数 5 ？显然一个都不能有，否则它就不能整除 a 了。因此， a 和 b 的最大公约数就是 2 × 2 × 3 = 12 。</p>
<p>    在构造 a 和 b 的最小公倍数时，我们希望每种质数在数量足够的前提下越少越好。为了让这个数既是 a 的倍数，又是 b 的倍数，三个 2 是必需的；为了让这个数既是 a 的倍数，又是 b 的倍数，两个 3 是必需的；为了让这个数既是 a 的倍数，又是 b 的倍数，那一个 5 也是必不可少的。因此， a 和 b 的最小公倍数就是 2 × 2 × 2 × 3 × 3 × 5 = 360 。</p>
<p>    你会发现， 12 × 360 = 36 × 120 ，最大公约数乘以最小公倍数正好等于原来两数的乘积。这其实并不奇怪。在最大公约数里面，每种质数各有多少个，取决于 a 和 b 当中谁所含的这种质数更少一些。在最小公倍数里面，每种质数各有多少个，取决于 a 和 b 当中谁所含的这种质数更多一些。因此，对于每一种质数而言，最大公约数和最小公倍数里面一共包含了多少个这种质数， a 和 b 里面也就一共包含了多少个这种质数。最大公约数和最小公倍数乘在一起，也就相当于是把 a 和 b 各自所包含的质数都乘了个遍，自然也就等于 a 与 b 的乘积了。这立即带来了我们熟悉的推论：如果两数互质，这两数的乘积就是它们的最小公倍数。</p>
<p>    第三节里，我们曾说到，“因为 5 和 3 、 7 和 3 都是互质的，从而 5 × 7 和 3 也是互质的”。利用质数的观点，这很容易解释。两个数互质，相当于是说这两个数不包含任何相同的质数。如果 a 与 c 互质， b 与 c 互质，显然 a · b 也与 c 互质。另外一个值得注意的结论是，如果 a 和 b 是两个不同的质数，则这两个数显然就直接互质了。事实上，只要知道了 a 是质数，并且 a 不能整除 b ，那么不管 b 是不是质数，我们也都能确定 a 和 b 是互质的。我们后面会用到这些结论。</p>
<p>    在很多场合中，质数都扮演着重要的角色。 1640 年，法国业余数学家 Pierre de Fermat （通常译作“费马”）发现，如果 n 是一个质数的话，那么对于任意一个数 a ， a 的 n 次方减去 a 之后都将是 n 的倍数。例如， 7 是一个质数，于是 2<sup>7</sup> – 2 、 3<sup>7</sup> – 3 ， 4<sup>7</sup> – 4 ，甚至 100<sup>7</sup> – 100 ，统统都能被 7 整除。但 15 不是质数（它可以被分解为 3 × 5 ），于是 a<sup>15</sup> – a 除以 15 之后就可能会出现五花八门的余数了。这个规律在数论研究中是如此基本如此重要，以至于它有一个专门的名字—— Fermat 小定理。作为一个业余数学家， Fermat 发现了很多数论中精彩的结论， Fermat “小”定理只是其中之一。虽然与本文无关，但有一点不得不提：以 Fermat 的名字命名的东西里，最著名的要数 Fermat 大定理了（其实译作“ Fermat 最终定理”更贴切）。如果你没听说过，上网查查，或者看看相关的书籍。千万不要错过与此相关的一系列激动人心的故事。</p>
<p>    言归正传。 Fermat 小定理有一个非常精彩的证明。我们不妨以“ 3<sup>7</sup> – 3 能被 7 整除”为例进行说明，稍后你会发现，对于其他的情况，道理是一样的。首先，让我来解释一下“循环移位”的意思。想象一个由若干字符所组成的字符串，在一块大小刚好合适的 LED 屏幕上滚动显示。比方说， HELLOWORLD 就是一个 10 位的字符串，而我们的 LED 屏幕不多不少正好容纳 10 个字符。刚开始，屏幕上显示 HELLOWORLD 。下一刻，屏幕上的字母 H 将会移出屏幕，但又会从屏幕右边移进来，于是屏幕变成了 ELLOWORLDH 。下一刻，屏幕变成了 LLOWORLDHE ，再下一刻又变成了 LOWORLDHEL 。移动到第 10 次，屏幕又会回到 HELLOWORLD 。在此过程中，屏幕上曾经显示过的 ELLOWORLDH, LLOWORLDHE, LOWORLDHEL, … ，都是由初始的字符串 HELLOWORLD 通过“循环移位”得来的。现在，考虑所有仅由 A 、 B 、 C 三个字符组成的长度为 7 的字符串，它们一共有 3<sup>7</sup> 个。如果某个字符串循环移位后可以得到另一个字符串，我们就认为这两个字符串属于同一组字符串。比如说， ABBCCCC 和 CCCABBC 就属于同一组字符串，并且该组内还有其他 5 个字符串。于是，在所有 3<sup>7</sup> 个字符串当中，除了 AAAAAAA 、 BBBBBBB 、 CCCCCCC 这三个特殊的字符串以外，其他所有的字符串正好都是每 7 个一组。这说明， 3<sup>7</sup> – 3 能被 7 整除。</p>
<p>    在这个证明过程中，“ 7 是质数”这个条件用到哪里去了？仔细想想你会发现，正因为 7 是质数，所以每一组里才恰好有 7 个字符串。如果字符串的长度不是 7 而是 15 的话，有些组里将会只含 3 个或者 5 个字符串。比方说， ABCABCABCABCABC 所在的组里就只有 3 个字符串，循环移动 3 个字符后，字符串将会和原来重合。</p>
<p>    Fermat 小定理有一个等价的表述：如果 n 是一个质数的话，那么对于任意一个数 a ，随着 i 的增加， a 的 i 次方除以 n 的余数将会呈现出长度为 n – 1 的周期性（下表所示的是 a = 3 、 n = 7 的情况）。这是因为，根据前面的结论， a<sup>n</sup> 与 a 的差能够被 n 整除，这说明 a<sup>n</sup> 和 a 分别都除以 n 之后将会拥有相同的余数。这表明，依次计算 a 的 1 次方、 2 次方、 3 次方除以 n 的余数，算到 a 的 n 次方时，余数将会变得和最开始相同。另一方面， a<sup>i</sup> 除以 n 的余数，完全由 a<sup>i-1</sup> 除以 n 的余数决定。比方说，假如我们已经知道 3<sup>3</sup> 除以 7 等于 3 余 6 ，这表明 3<sup>3</sup> 里包含 3 个 7 以及 1 个 6 ；因此，  3<sup>4</sup> 里就包含 9 个 7 以及 3 个 6 ，或者说 9 个 7 以及 1 个 18 。为了得到 3<sup>4</sup> 除以 7 的余数，只需要看看 18 除以 7 余多少就行了。可见，要想算出 a<sup>i-1</sup> · a 除以 n 的余数，我们不需要完整地知道 a<sup>i-1</sup> 的值，只需要知道 a<sup>i-1</sup> 除以 n 的余数就可以了。反正最后都要对乘积取余，相乘之前事先对乘数取余不会对结果造成影响（记住这一点，后面我们还会多次用到）。既然第 n 个余数和第 1 个余数相同，而余数序列的每一项都由上一项决定，那么第 n + 1 个、第 n + 2 个余数也都会跟着和第 2 个、第 3 个余数相同，余数序列从此处开始重复，形成长为 n – 1 的周期。</p>
<table border="1" style="border-collapse:collapse; margin-left:30px; width:auto;">
<tr>
<td>i</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
</tr>
<tr>
<td>3<sup>i</sup>
</td>
<td>3</td>
<td>9</td>
<td>27</td>
<td>81</td>
<td>243</td>
<td>729</td>
<td>2187</td>
<td>6561</td>
<td>19683</td>
<td>59049</td>
<td>177147</td>
<td>531441</td>
<td>1594323</td>
<td>4782969</td>
<td>14348907</td>
</tr>
<tr>
<td>3<sup>i</sup> mod 7</td>
<td>3</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>6</td>
</tr>
</table>
<p>    需要注意的是， n – 1 并不见得是最小的周期。下表所示的是 2<sup>i</sup> 除以 7 的余数情况，余数序列确实存在长度为 6 的周期现象，但实际上它有一个更小的周期， 3 。</p>
<table border="1" style="border-collapse:collapse; margin-left:30px; width:auto;">
<tr>
<td>i</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
</tr>
<tr>
<td>2<sup>i</sup>
</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>128</td>
<td>256</td>
<td>512</td>
<td>1024</td>
<td>2048</td>
<td>4096</td>
<td>8192</td>
<td>16384</td>
<td>32768</td>
</tr>
<tr>
<td>2<sup>i</sup> mod 7</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>1</td>
</tr>
</table>
<p>    那么，如果除数 n 不是质数，而是两个质数的乘积（比如 35 ），周期的长度又会怎样呢？让我们试着看看， 3<sup>i</sup> 除以 35 的余数有什么规律吧。注意到 5 和 7 是两个不同的质数，因而它们是互质的。根据中国剩余定理，一个数除以 35 的余数就可以唯一地由它除以 5 的余数和除以 7 的余数确定出来。因而，为了研究 3<sup>i</sup> 除以 35 的余数，我们只需要观察 (3<sup>i</sup> mod 5, 3<sup>i</sup> mod 7) 即可。由 Fermat 小定理可知，数列 3<sup>i</sup> mod 5 有一个长为 4 的周期，数列 3<sup>i</sup> mod 7 有一个长为 6 的周期。 4 和 6 的最小公倍数是 12 ，因此 (3<sup>i</sup> mod 5, 3<sup>i</sup> mod 7) 存在一个长为 12 的周期。到了 i = 13 时， (3<sup>i</sup> mod 5, 3<sup>i</sup> mod 7) 将会和最开始重复，于是 3<sup>i</sup> 除以 35 的余数将从此处开始发生循环。</p>
<table border="1" style="border-collapse:collapse; margin-left:30px; width:auto;">
<tr>
<td>i</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
<td>22</td>
</tr>
<tr>
<td>3<sup>i</sup> mod 5</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>3<sup>i</sup> mod 7</td>
<td>3</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td>3<sup>i</sup> mod 35</td>
<td>3</td>
<td>9</td>
<td>27</td>
<td>11</td>
<td>33</td>
<td>29</td>
<td>17</td>
<td>16</td>
<td>13</td>
<td>4</td>
<td>12</td>
<td>1</td>
<td>3</td>
<td>9</td>
<td>27</td>
<td>11</td>
<td>33</td>
<td>29</td>
<td>17</td>
<td>16</td>
<td>13</td>
<td>4</td>
</tr>
<tr>
<td>i</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
<td>32</td>
<td>33</td>
<td>34</td>
<td>35</td>
<td>36</td>
<td>37</td>
<td>38</td>
<td>39</td>
<td>40</td>
<td>41</td>
<td>42</td>
<td>43</td>
<td>44</td>
</tr>
<tr>
<td>3<sup>i</sup> mod 5</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3<sup>i</sup> mod 7</td>
<td>5</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>1</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>3<sup>i</sup> mod 35</td>
<td>12</td>
<td>1</td>
<td>3</td>
<td>9</td>
<td>27</td>
<td>11</td>
<td>33</td>
<td>29</td>
<td>17</td>
<td>16</td>
<td>13</td>
<td>4</td>
<td>12</td>
<td>1</td>
<td>3</td>
<td>9</td>
<td>27</td>
<td>11</td>
<td>33</td>
<td>29</td>
<td>17</td>
<td>16</td>
</tr>
</table>
<p>    类似地，假如某个整数 n 等于两个质数 p 、 q 的乘积，那么对于任意一个整数 a ，写出 a<sup>i</sup> 依次除以 n 所得的余数序列， p – 1 和 q – 1 的最小公倍数将成为该序列的一个周期。事实上， p – 1 和 q – 1 的任意一个公倍数，比如表达起来最方便的 (p – 1) × (q – 1) ，也将成为该序列的一个周期。这个规律可以用来解释很多数学现象。例如，大家可能早就注意过，任何一个数的乘方，其个位数都会呈现长度为 4 的周期（这包括了周期为 1 和周期为 2 的情况）。其实这就是因为， 10 等于 2 和 5 这两个质数的乘积，而 (2 – 1) × (5 – 1) = 4，因此任意一个数的乘方除以 10 的余数序列都将会产生长为 4 的周期。</p>
<table border="1" style="border-collapse:collapse; margin-left:30px; width:auto;">
<tr>
<td>i</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>3<sup>i</sup>
</td>
<td>3</td>
<td>9</td>
<td>27</td>
<td>81</td>
<td>243</td>
<td>729</td>
<td>2187</td>
<td>6561</td>
<td>19683</td>
<td>59049</td>
</tr>
<tr>
<td>3<sup>i</sup>的个位</td>
<td>3</td>
<td>9</td>
<td>7</td>
<td>1</td>
<td>3</td>
<td>9</td>
<td>7</td>
<td>1</td>
<td>3</td>
<td>9</td>
</tr>
<tr>
<td>4<sup>i</sup>
</td>
<td>4</td>
<td>16</td>
<td>64</td>
<td>256</td>
<td>1024</td>
<td>4096</td>
<td>16384</td>
<td>65536</td>
<td>262144</td>
<td>1048576</td>
</tr>
<tr>
<td>4<sup>i</sup>的个位</td>
<td>4</td>
<td>6</td>
<td>4</td>
<td>6</td>
<td>4</td>
<td>6</td>
<td>4</td>
<td>6</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>5<sup>i</sup>
</td>
<td>5</td>
<td>25</td>
<td>125</td>
<td>625</td>
<td>3125</td>
<td>15625</td>
<td>78125</td>
<td>390625</td>
<td>1953125</td>
<td>9765625</td>
</tr>
<tr>
<td>5<sup>i</sup>的个位</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
</table>
<p>    1736 年，瑞士大数学家 Leonhard Euler （通常译作“欧拉”）对此做过进一步研究，讨论了当 n 是更复杂的数时推导余数序列循环周期的方法，得到了一个非常漂亮的结果：在 1 到 n 的范围内有多少个数和 n 互质（包括 1 在内）， a 的 i 次方除以 n 的余数序列就会有一个多长的周期。这个经典的结论就叫做“ Euler 定理”。作为历史上最高产的数学家之一， Euler 的一生当中发现的定理实在是太多了。为了把上述定理和其他的“ Euler 定理”区别开来，有时也称它为“ Fermat – Euler 定理”。这是一个非常深刻的定理，它有一些非常具有启发性的证明方法。考虑到在后文的讲解中这个定理不是必需的，因此这里就不详说了。</p>
<p>    这些东西有什么用呢？没有什么用。几千年来，数论一直没有任何实际应用，数学家们研究数论的动力完全来源于数字本身的魅力。不过，到了 1970 年左右，情况有了戏剧性的变化。</p>
<p>    有的朋友可能要说了，你怎么赖皮呢，“没有任何实际应用”，那刚才的 Mignotte 秘密共享方案算什么？其实， Mignotte 秘密共享方案已经是很后来的事了。秘密共享本来远没那么复杂，为了使得只要 5 个人中半数以上的人在场就可以解开绝密文件，总部可以把绝密文件锁进一个特殊的机械装置里，装置上有三个一模一样的锁孔，并配有 5 把完全相同且不可复制的钥匙。只有把其中任意 3 把钥匙同时插进钥匙孔并一起转动，才能打开整个装置。把 5 把钥匙分发给 5 名特工，目的就直接达到了。因而，通常情况下我们并不需要动用 Mignotte 秘密共享方案。那么，利用中国剩余定理费尽周折弄出的 Mignotte 秘密共享方案，意义究竟何在呢？这种新的秘密共享方案直到 1983 年才被提出，想必是为了解决某个以前不曾有过的需求。 20 世纪中后期究竟出现了什么？答案便是——计算机网络。锁孔方案只适用于物理世界，不能用于网络世界。为了在网络世界中共享秘密，我们需要一种纯信息层面的、只涉及数据交换的新方法， Mignotte 秘密共享方案才应运而生。</p>
<p>    数论知识开始焕发新生，一切都是因为这该死的计算机网络。</p>
<p> <br>
（五）公钥加密的可能性</p>
<p>    计算机网络的出现无疑降低了交流的成本，但却给信息安全带来了难题。在计算机网络中，一切都是数据，一切都是数字，一切都是透明的。假如你的朋友要给你发送一份绝密文件，你如何阻止第三者在你们的通信线路的中间节点上窃走信息？其中一种方法就是，让他对发送的数据进行加密，密码只有你们两人知道。但是，这个密码又是怎么商定出来的呢？直接叫对方编好密码发给你的话，密码本身会有泄漏的风险；如果让对方给密码加个密再发过来呢，给密码加密的方式仍然不知道该怎么确定。如果是朋友之间的通信，把两人已知的小秘密用作密钥（例如约定密钥为 A 的生日加上 B 的手机号）或许能让人放心许多；但对于很多更常见的情形，比方说用户在邮件服务提供商首次申请邮箱时，会话双方完全没有任何可以利用的公共秘密。此时，我们需要一个绝对邪的办法……如果说我不告诉任何人解密的算法呢？这样的话，我就可以公开加密的方法，任何人都能够按照这种方法对信息进行加密，但是只有我自己才知道怎样给由此得到的密文解密。然后，让对方用这种方法给文件加密传过来，问题不就解决了吗？这听上去似乎不太可能，因为直觉上，知道加密的方法也就知道了解密的方法，只需要把过程反过来做就行了。加密算法和解密算法有可能是不对称的吗？</p>
<p>    有可能。小时候我经常在朋友之间表演这么一个数学小魔术：让对方任意想一个三位数，把这个三位数乘以 91 的乘积的末三位告诉我，我便能猜出对方原来想的数是多少。如果对方心里想的数是 123 ，那么对方就计算出 123 × 91 等于 11193 ，并把结果的末三位 193 告诉我。看起来，这么做似乎损失了不少信息，让我没法反推出原来的数。不过，我仍然有办法：只需要把对方告诉我的结果再乘以 11 ，乘积的末三位就是对方刚开始想的数了。你可以验证一下， 193 × 11 = 2123 ，末三位正是对方所想的秘密数字！其实道理很简单， 91 乘以 11 等于 1001 ，而任何一个三位数乘以 1001 后，末三位显然都不变（例如 123 乘以 1001 就等于 123123 ）。先让对方在他所想的数上乘以 91 ，假设乘积为 X ；我再在 X 的基础上乘以 11 ，其结果相当于我俩合作把原数乘以了 1001 ，自然末三位又变了回去。然而， X 乘以 11 后的末三位是什么，只与 X 的末三位有关。因此，对方只需要告诉我 X 的末三位就行了，这并不会丢掉信息。站在数论的角度来看，上面这句话有一个更好的解释：反正最后都要取除以 1000 的余数，在中途取一次余数不会有影响（还记得吗，“反正最后都要对乘积取余，相乘之前事先对乘数取余不会对结果造成影响”）。知道原理后，我们可以构造一个定义域和值域更大的加密解密系统。比方说，任意一个数乘以 500000001 后，末 8 位都不变，而 500000001 = 42269 × 11829 ，于是你来乘以 42269 ，我来乘以 11829 ，又一个加密解密不对称的系统就构造好了。这是一件很酷的事情，任何人都可以按照我的方法加密一个数，但是只有我才知道怎么把所得的密文变回去。在现代密码学中，数论渐渐地开始有了自己的地位。</p>
<p>    不过，加密和解密的过程不对称，并不妨碍我们根据加密方法推出解密方法来，虽然这可能得费些功夫。比方说，刚才的加密算法就能被破解：猜出对方心里想的数相当于求解形如 91x mod 1000 = 193 的方程，这可以利用扩展的辗转相除法很快求解出来，根本不需要其他的雕虫小技（注意到 91 和 1000 是互质的，根据 Bézout 定理，方程确实保证有解）。为了得到一个可以公开加密钥匙的算法，我们还需要从理论上说服自己，在只知道加密钥匙的情况下构造出解密钥匙是非常非常困难的。</p>
<p>    1970 年左右，科学家们开始认真地思考“公钥加密系统”的可能性。 1977 年，来自 MIT 的 Ron Rivest 、 Adi Shamir 和 Leonard Adleman 三个人合写了一篇论文，给出了一种至今仍然安全的公钥加密算法。随后，该算法以三人名字的首字母命名，即 RSA 算法。</p>
<p>    RSA 算法为什么会更加安全呢？因为 RSA 算法用到了一种非常犀利的不对称性——大数分解难题。</p>
<p>    为了判断一个数是不是质数，最笨的方法就是试除法——看它能不能被 2 整除，如果不能的话再看它能不能被 3 整除，这样不断试除上去。直到除遍了所有比它小的数，都还不能把它分解开来，它就是质数了。但是，试除法的速度太慢了，我们需要一些高效的方法。 Fermat 素性测试就是一种比较常用的高效方法，它基于如下原理： Fermat 小定理对一切质数都成立。回想 Fermat 小定理的内容：如果 n 是一个质数的话，那么对于任意一个数 a ， a 的 n 次方减去 a 之后都将是 n 的倍数。为了判断 209 是不是质数，我们随便选取一个 a ，比如 38 。结果发现，38<sup>209</sup> – 38 除以 209 余 114 （稍后我们会看到，即使把 209 换成上百位的大数，利用计算机也能很快算出这个余数来），不能被 209 整除。于是， 209 肯定不是质数。我们再举一个例子。为了判断 221 是不是质数，我们随机选择 a ，比如说还是 38 吧。你会发现 38<sup>221</sup> – 38 除以 221 正好除尽。那么， 221 是否就一定是质数了呢？麻烦就麻烦在这里：这并不能告诉我们 221 是质数，因为 Fermat 小定理毕竟只说了对一切质数都成立，但没说对其他的数成不成立。万一 221 根本就不是质数，但 a = 38 时碰巧也符合 Fermat 小定理呢？为了保险起见，我们不妨再选一个不同的 a 值。比方说，令 a = 26 ，可以算出 26<sup>221</sup> – 26 除以 221 余 169 ，因而 221 果然并不是质数。这个例子告诉了我们，如果运气不好的话，所选的 a 值会让不是质数的数也能骗过检测，虽然这个概率其实并不大。因此，我们通常的做法便是，多选几个不同的 a ，只要有一次没通过测试，被检测的数一定不是质数，如果都通过测试了，则被检测的数很可能是质数。没错， Fermat 素性测试的效率非常高，但它是基于一定概率的，有误报的可能。如果发现某个数 n 不满足 Fermat 小定理，它一定不是质数；但如果发现某个数 n 总能通过 Fermat 小定理的检验，只能说明它有很大的几率是质数。</p>
<p>    Fermat 素性测试真正麻烦的地方就是，居然有这么一种极其特殊的数，它不是质数，但对于任意的 a 值，它都能通过测试。这样的数叫做 Carmichael 数，最小的一个是 561 ，接下来的几个则是 1105, 1729, 2465, 2821, 6601, 8911… 虽然不多，但很致命。因此，在实际应用时，我们通常会选用 Miller-Rabin 素性测试算法。这个算法以 Gary Miller 的研究成果为基础，由 Michael Rabin 提出，时间大约是 1975 年。它可以看作是对 Fermat 素性测试的改良。如果选用了 k 个不同的 a 值，那么 Miller-Rabin 素性测试算法出现误判的概率不会超过 1 / 4<sup>k</sup> ，足以应付很多现实需要了。</p>
<p>    有没有什么高效率的、确定性的质数判定算法呢？有，不过这已经是很后来的事情了。 2002 年， Manindra Agrawal 、 Neeraj Kayal 和 Nitin Saxena 发表了一篇重要的论文 PRIMES is in P ，给出了第一个高效判断质数的确定性算法，并以三人名字的首字母命名，叫做 AKS 素性测试。不过，已有的质数判断算法已经做得很好了，因此对于 AKS 来说，更重要的是它的理论意义。</p>
<p>    有了判断质数的算法，要想生成一个很大的质数也并不困难了。一种常见的做法是，先选定一串连续的大数，然后去掉其中所有能被 2 整除的数，再去掉所有能被 3 整除的数，再去掉所有能被 5 整除的数……直到把某个范围内（比如说 65000 以内）的所有质数的倍数全都去掉。剩下的数就不多了，利用判断质数的算法对它们一一进行测试，不久便能找出一个质数来。</p>
<p>    怪就怪在，我们可以高效地判断一个数是不是质数，我们可以高效地生成一个很大的质数，但我们却始终找不到高效的大数分解方法。任意选两个比较大的质数，比如 19394489 和 27687937 。我们能够很容易计算出 19394489 乘以 27687937 的结果，它等于 536993389579193 ；但是，除了试除法以外，目前还没有什么本质上更有效的方法（也很难找到更有效的方法）能够把 536993389579193 迅速分解成 19394489 乘以 27687937 。这种不对称性很快便成了现代密码学的重要基础。让我们通过一个有趣的例子来看看，大数分解的困难性是如何派上用场的吧。</p>
<p>    假如你和朋友用短信吵架，最后决定抛掷硬币来分胜负，正面表示你获胜，反面表示对方获胜。问题来了——两个人如何通过短信公平地抛掷一枚硬币？你可以让对方真的抛掷一枚硬币，然后将结果告诉你，不过前提是，你必须充分信任对方才行。在双方互不信任的情况下，还有办法模拟一枚虚拟硬币吗？在我们生活中，有一个常见的解决方法：考你一道题，比如“明天是否会下雨”、“地球的半径是多少”或者“《新华字典》第 307 页的第一个字是什么”，猜对了就算你赢，猜错了就算你输。不过，上面提到的几个问题显然都不是完全公平的。我们需要一类能快速生成的、很难出现重复的、解答不具技巧性的、猜对猜错几率均等的、具有一个确凿的答案并且知道答案后很容易验证答案正确性的问题。大数分解为我们构造难题提供了一个模板。比方说，让对方选择两个 90 位的大质数，或者三个 60 位的大质数，然后把乘积告诉你。无论是哪种情况，你都会得到一个大约有 180 位的数。你需要猜测这个数究竟是两个质数乘在一起得来的，还是三个质数乘在一起得来的。猜对了就算正面，你赢；猜错了就算反面，对方赢。宣布你的猜测后，让对方公开他原先想的那两个数或者三个数，由你来检查它们是否确实都是质数，乘起来是否等于之前给你的数。</p>
<p>    大数分解难题成为了 RSA 算法的理论基础。</p>
<p> <br>
（六）RSA 算法</p>
<p>    所有工作都准备就绪，下面我们可以开始描述 RSA 算法了。</p>
<p>    首先，找两个质数，比如说 13 和 17 。实际使用时，我们会选取大得多的质数。把它们乘在一起，得 221 。再计算出 (13 – 1) × (17 – 1) = 192。根据前面的结论，任选一个数 a ，它的 i 次方除以 221 的余数将会呈现长度为 192 的周期（虽然可能存在更短的周期）。换句话说，对于任意的一个 a，a, a<sup>193</sup>, a<sup>385</sup>, a<sup>577</sup>, … 除以 221 都拥有相同的余数。注意到， 385 可以写成 11 × 35 ……嘿嘿，这下我们就又能变数学小魔术了。叫一个人随便想一个不超过 221 的数，比如 123 。算出 123 的 11 次方除以 221 的余数，把结果告诉你。如果他的计算是正确的，你将会得到 115 这个数。看上去，我们似乎很难把 115 还原回去，但实际上，你只需要计算 115 的 35 次方，它除以 221 的余数就会变回 123 。这是因为，对方把他所想的数 123 连乘了 11 次，得到了一个数 X ；你再把这个 X 乘以自身 35 次，这相当于你们合作把 123 连乘了 385 次，根据周期性现象，它除以 221 的余数仍然是 123 。然而，计算 35 个 X 连乘时，反正我们要取乘积除以 221 的余数，因此我们不必完整地获知 X 的值，只需要知道 X 除以 221 的余数就够了。因而，让对方只告诉你 X 取余后的结果，不会造成信息的丢失。</p>
<p>    不过这一次，只知道加密方法后，构造解密方法就难了。容易看出， 35 之所以能作为解密的钥匙，是因为 11 乘以 35 的结果在数列 193, 385, 577, … 当中，它除以 192 的余数正好是 1 。因此，攻击者可以求解 11x mod 192 = 1 ，找出满足要求的密钥 x 。但关键是，他怎么知道 192 这个数？要想得到 192 这个数，我们需要把 221 分解成 13 和 17 的乘积。当最初所选的质数非常非常大时，这一点是很难办到的。</p>
<p>    根据这个原理，我们可以选择两个充分大的质数 p 和 q ，并算出 n = p · q 。接下来，算出 m = (p – 1)(q – 1) 。最后，找出两个数 e 和 d ，使得 e 乘以 d 的结果除以 m 余 1 。怎么找到这样的一对 e 和 d 呢？很简单。首先，随便找一个和 m 互质的数（这是可以做到的，比方说，可以不断生成小于 m 的质数，直到找到一个不能整除 m 的为止），把它用作我们的 e 。然后，求解关于 d 的方程 e · d mod m = 1（就像刚才攻击者想要做的那样，只不过我们有 m 的值而他没有）。 Bézout 定理将保证这样的 d 一定存在。</p>
<p>    好了，现在， e 和 n 就可以作为加密钥匙公之于众， d 和 n 则是只有自己知道的解密钥匙。因而，加密钥匙有时也被称作公钥，解密钥匙有时也被称作私钥。任何知道公钥的人都可以利用公式 c = a<sup>e</sup> mod n 把原始数据 a 加密成一个新的数 c ；私钥的持有者则可以计算 c<sup>d</sup> mod n ，恢复出原始数据 a 来。不过这里还有个大问题： e 和 d 都是上百位的大数，怎么才能算出一个数的 e 次方或者一个数的 d 次方呢？显然不能老老实实地算那么多次乘法，不然效率实在太低了。好在，“反复平方”可以帮我们快速计算出一个数的乘方。比方说，计算 a<sup>35</sup> 相当于计算 a<sup>34</sup> · a ，也即 (a<sup>17</sup>)<sup>2</sup> · a ，也即 (a<sup>16</sup> · a)<sup>2</sup> · a，也即 ((a<sup>8</sup>)<sup>2</sup> · a)<sup>2</sup> · a……最终简化为 ((((a<sup>2</sup>)<sup>2</sup>)<sup>2</sup>)<sup>2</sup> · a)<sup>2</sup> · a ，因而 7 次乘法操作就够了。在简化的过程中， a 的指数以成半的速度递减，因而在最后的式子当中，所需的乘法次数也是对数级别的，计算机完全能够承受。不过，减少了运算的次数，并没有减小数的大小。 a 已经是一个数十位上百位的大数了，再拿 a 和它自己多乘几次，很快就会变成一个计算机内存无法容纳的超级大数。怎么办呢？别忘了，“反正最后都要对乘积取余，相乘之前事先对乘数取余不会对结果造成影响”，因此我们可以在运算过程中边算边取余，每做一次乘法都只取乘积除以 n 的余数。这样一来，我们的每次乘法都是两个 n 以内的数相乘了。利用这些小窍门，计算机才能在足够短的时间里完成 RSA 加密解密的过程。</p>
<p>    RSA 算法实施起来速度较慢，因此在运算速度上的任何一点优化都是有益的。利用中国剩余定理，我们还能进一步加快运算速度。我们想要求的是 a<sup>35</sup> 除以 n 的余数，而 n 是两个质数 p 和 q 的乘积。由于 p 和 q 都是质数，它们显然也就互质了。因而，如果我们知道 a<sup>35</sup> 分别除以 p 和 q 的余数，也就能够反推出它除以 n 的余数了。因此，在反复平方的过程中，我们只需要保留所得的结果除以 p 的余数和除以 q 的余数即可，运算时的数字规模进一步降低到了 p 和 q 所在的数量级上。到最后，我们再借助“今有物，不知其数”的求解思路，把这两条余数信息恢复成一个 n 以内的数。更神的是，别忘了， a<sup>i</sup> 除以 p 的余数是以 p – 1 为周期的，因此为了计算 a<sup>35</sup> mod p ，我们只需要计算 a<sup>35 mod (p-1)</sup> mod p 就可以了。类似地，由于余数的周期性现象，计算 a<sup>35</sup> mod q 就相当于计算 a<sup>35 mod (q-1)</sup> mod q 。这样一来，连指数的数量级也减小到了和 p 、 q 相同的水平， RSA 运算的速度会有明显的提升。</p>
<p>    需要注意的是， RSA 算法的安全性并不完全等价于大数分解的困难性（至少目前我们还没有证明这一点）。已知 n 和 e 之后，不分解 n 确实很难求出原始数据 a 。但我们并不能排除，有某种非常巧妙的方法可以绕过大数分解，不去求 p 和 q 的值，甚至不去求 m 的值，甚至不去求 d 的值，而直接求出原始数据 a 。不过，即使考虑到这一点，目前人们也没有破解原始数据 a 的好办法。 RSA 算法经受住了实践的考验，并逐渐成为了行业标准。如果 A 、 B 两个人想要建立会话，那么我们可以让 A 先向 B 索要公钥，然后想一个两人今后通话用的密码，用 B 的公钥加密后传给 B ，这将只能由 B 解开。因此，即使窃听者完全掌握了双方约定密码时传递的信息，也无法推出这个密码是多少来。</p>
<p>    上述方案让双方在不安全的通信线路上神奇地约定好了密码，一切看上去似乎都很完美了。然而，在这个漂亮的解决方案背后，有一个让人意想不到的、颇有些喜剧色彩的漏洞——中间人攻击。在 A 、 B 两人建立会话的过程中，攻击者很容易在线路中间操纵信息，让 A 、 B 两人误以为他们是在直接对话。让我们来看看这具体是如何操作的吧。建立会话时， A 首先呼叫 B 并索要 B 的公钥，此时攻击者注意到了这个消息。当 B 将公钥回传给 A 时，攻击者截获 B 的公钥，然后把他自己的公钥传给 A 。接下来， A 随便想一个密码，比如说 314159 ，然后用他所收到的公钥进行加密，并将加密后的结果传给 B 。 A 以为自己加密时用的是 B 的公钥，但他其实用的是攻击者的公钥。攻击者截获 A 传出来的信息，用自己的私钥解出 314159 ，再把 314159 用 B 的公钥加密后传给 B 。 B 收到信息后不会发现什么异样，因为这段信息确实能用 B 的私钥解开，而且确实能解出正确的信息 314159 。今后， A 、 B 将会用 314159 作为密码进行通话，而完全不知道有攻击者已经掌握了密码。</p>
<p>    怎么封住这个漏洞呢？我们得想办法建立一个获取对方公钥的可信渠道。一个简单而有效的办法就是，建立一个所有人都信任的权威机构，由该权威机构来储存并分发大家的公钥。这就是我们通常所说的数字证书认证机构，英文是 Certificate Authority ，通常简称 CA 。任何人都可以申请把自己的公钥放到 CA 上去，不过 CA 必须亲自检查申请者是否符合资格。如果 A 想要和 B 建立会话，那么 A 就直接从 CA 处获取 B 的公钥，这样就不用担心得到的是假的公钥了。</p>
<p>    新的问题又出来了：那么，怎么防止攻击者冒充 CA 呢？ CA 不但需要向 A 保证“这个公钥确实是 B 的”，还要向 A 证明“我确实就是 CA ”。</p>
<p>    把加密钥匙和解密钥匙称作“公钥”和“私钥”是有原因的——有时候，私钥也可以用来加密，公钥也可以用来解密。容易看出，既然 a 的 e 次方的 d 次方除以 n 的余数就回到了 a ，那么当然， a 的 d 次方的 e 次方除以 n 的余数也会变回 a 。于是，我们可以让私钥的持有者计算 a 的 d 次方除以 n 的余数，对原文 a 进行加密；然后公钥的持有者取加密结果的 e 次方除以 n 的余数，这也能恢复出原文 a 。但是，用我自己的私钥加密，然后大家都可以解密，这有什么用处呢？不妨来看看这样“加密”后的效果吧：第一，貌似是最荒谬的，大家都可以用我的公钥解出它所对应的原始文件；第二，很关键的，大家只能查看它背后的原文件，不能越过它去修改它背后的原文件；第三，这样的东西是别人做不出来的，只有我能做出来。</p>
<p>    这些性质正好完美地描述出“数字签名”的实质，刚才的 CA 难题迎刃而解。 CA 首先生成一个自己的公钥私钥对，然后把公钥公之于众。之后， CA 对每条发出去的消息都用自己的私钥加个密作为签名，以证明此消息的来源是真实的。收到 CA 的消息后，用 CA 的公钥进行解密，如果能恢复出 CA 的原文，则说明对方一定是正宗的 CA 。因为，这样的消息只有私钥的持有者才能做出来，它上面的签名是别人无法伪造的。至此为止，建立安全的通信线路终于算是有了一个比较完美的方案。</p>
<p>    实际应用中，建立完善的安全机制更加复杂。并且，这还不足以解决很多其他形式的网络安全问题。随便哪个简单的社交活动，都包含着非常丰富的协议内涵，在互联网上实现起来并不容易。比方说，如何建立一个网络投票机制？这里面的含义太多了：我们需要保证每张选票确实都来自符合资格的投票人，我们需要保证每个投票人只投了一票，我们需要保证投票人的选票内容不会被泄露，我们需要保证投票人的选票内容不会被篡改，我们还需要让唱票环节足够透明，让每个投票人都确信自己的票被算了进去。作为密码学与协议领域的基本模块， RSA 算法随时准备上阵。古希腊数学家对数字执着的研究，直到今天也仍然绽放着光彩。</p>
			 ]]></content>
<pubDate>2012-12-15T13:46:12+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5100</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 五个有趣的拓扑变换问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/5140</link>
<content><![CDATA[ 
		<p>    如果你喜欢上次的<a href="http://www.matrix67.com/blog/archives/5077">空间想象能力挑战</a>，你一定会喜欢 V. V. Prasolov 的 Intuitive Topology 一书。书中的第一章有五个非常经典的“拓扑变换”类谜题，在此与大家分享。注意游戏规则：我们假设所有物体都是用橡胶做成的，可以随意地拉伸、挤压、弯曲，但不允许切断、粘连等任何改变图形本质结构的操作。</p>
<p>    1. 能否把左图连续地变形为右图？</p>
<p>      <img alt="image placeholder" >
<p> <br>
    2. 能否把左图连续地变形为右图？</p>
<p>      <img alt="image placeholder" >
<p><span id="more-5140"></span> <br>
    3. 左图所示的立体图形表面画有一个圆。能否通过连续变换，把这个圆变到右图所示的位置？</p>
<p>      <img alt="image placeholder" >
<p> <br>
    4. 在一个轮胎的表面上打一个洞。能否通过连续变换，把这个轮胎的内表面翻到外面来？</p>
<p>      <img alt="image placeholder" >
<p> <br>
    5. 能否把左图连续地变形为右图？</p>
<p>      <img alt="image placeholder" >
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    1. 能否把左图连续地变为右图？</p>
<p>      <img alt="image placeholder" >
<p> <br>
    答案是可以的，如下图所示：</p>
<p>      <img alt="image placeholder" >
<p> <br>
    这意味着，假如人类的身体可以像橡胶人一样任意变形，那么用两手的拇指和食指做成两个套着的圆环之后，我们可以不放开手指，把圆环给解开来。 Algorithmic and Computer Methods for Three-Manifolds 一书里画了一张非常漂亮的示意图：</p>
<p>      <img alt="image placeholder" >
<p> <br>
    更加有趣的是，如果仅仅是手腕上多了一块手表，上述方案就不能得逞了：</p>
<p>      <img alt="image placeholder" >
<p> <br>
    2. 能否把左图连续地变为右图？</p>
<p>      <img alt="image placeholder" >
<p> <br>
    答案是可以的，如下图所示：</p>
<p>      <img alt="image placeholder" >
<p> <br>
    3. 左图所示的立体图形表面画有一个圆。能否通过连续变换，把这个圆变到右图所示的位置？</p>
<p>      <img alt="image placeholder" >
<p> <br>
    答案是可以的，如下图所示：</p>
<p>      <img alt="image placeholder" >
<p> <br>
    4. 在一个轮胎的表面上打一个洞。能否通过连续变换，把这个轮胎的内表面翻到外面来？</p>
<p>      <img alt="image placeholder" >
<p> <br>
    答案是可以的。首先，作出如下图所示的连续变换。可以看到，一个表面有洞的轮胎本质上等于两个粘在一起的纸圈！不过，注意纸圈 1 和纸圈 2 的地位不太一样：一个是白色的面（即最初轮胎的内表面）冲外，一个是阴影面（即最初轮胎的外表面）冲外。现在，把纸圈 2 当成原来的纸圈 1 ，把纸圈 1 当成原来的纸圈 2 ，倒着把它们变回轮胎形，轮胎的内外表面也就颠倒过来了。</p>
<p>      <img alt="image placeholder" >
<p> <br>
    有趣的是，把轮胎的内表面翻出来之后，轮胎上的“经线”和“纬线”（姑且这么叫吧）也将会颠倒过来：</p>
<p>      <img alt="image placeholder" >
<p> <br>
    <a href="http://en.wikipedia.org/wiki/File:Inside-out_torus_(animated,_small).gif">Wikipedia</a> 上有一个巨帅无比的动画，直接展示出了把一个圆环面的内表面翻到外面来的过程。此动画看着非常上瘾，小心一看就是 10 分钟！</p>
<p>      <img alt="image placeholder" >
<p> <br>
    5. 能否把左图连续地变为右图？</p>
<p>      <img alt="image placeholder" >
<p> <br>
    答案是可以的。首先，作出如下图所示的连续变换，于是就变成了问题 1 中的图 (a) 。再利用问题 1 的办法，即可变出我们想要的形状来。</p>
<p>      <img alt="image placeholder" >
<p><!-- 本文中用到了 Intuitive Topology 和 Algorithmic and Computer Methods for Three-Manifolds 两书中的图片，若版权方认为不妥，请邮件联系，本人愿支付薄酬 --></p>
			 ]]></content>
<pubDate>2012-12-18T14:46:27+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5140</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Hofstadter的非线性递推数列 ]]></title>
<link>http://www.matrix67.com/blog/archives/5152</link>
<content><![CDATA[ 
		<p>    在著名奇书 Gödel, Escher, Bach: An Eternal Golden Braid 的第五章中，为了展现出递推序列的神奇之处，作者 Douglas Hofstadter 定义了这么一个递推序列： G(n) = n – G(G(n – 1)) ，其中 G(1) = 1 。这个序列的前 30 项如下：</p>
<table border="1" width="600" style="border-collapse:collapse; margin-left: 30px;">
<tr>
<td>n</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
</tr>
<tr>
<td>G(n)</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>11</td>
<td>12</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>16</td>
<td>17</td>
<td>17</td>
<td>18</td>
<td>19</td>
</tr>
</table>
<p>      <img alt="image placeholder" >
<p>    这个数列通常被称作 Hofstadter G-sequence 。它有什么特别的地方呢？如上图，如果把每个标号为 n 的结点都连接到标号为 G(n) 的结点下方，这样的话你将会得到一棵树。从第二行开始算起，各行的结点个数依次为 1, 1, 2, 3, 5, 8, 13, … 正好是著名的 Fibonacci 数列（头两个数都是 1 ，从第三个数开始，每个数都是前两个数之和）。如果我们把第 i 个 Fibonacci 数记作 F<sub>i</sub> 的话，上面的规律可以重新表述为：当 n ≥ 2 时，这棵树的第 n 行的结点总个数为 F<sub>n-1</sub> 。另外，这棵树的前 n 行的结点总数（也就是第 n 行最右边那个结点的编号）正好等于 F<sub>n+1</sub> ，也是一个个的 Fibonacci 数。对照上面两个事实，你会惊奇地发现，莫非 F<sub>1</sub> + F<sub>2</sub> + … + F<sub>n-1</sub> + 1 总是等于 F<sub>n+1</sub> ？事实的确如此，上面这个式子对于所有大于等于 2 的正整数 n 均成立。</p>
<p><span id="more-5152"></span><br>
      <img alt="image placeholder" >
<p>    这棵树本身还有别的来头。现在，让我们去掉树中最顶上的那个结点，只保留红色方框里的部分。不妨把这部分的图叫做图 R 。有读者发现图 R 很眼熟吗？它正是经典的“兔子问题族谱图”。假如每一对刚生下的幼兔都会在一个月之后变为成兔，并且在此后的每个月里都会生一对新的兔子。如果刚开始有一对幼兔，那么接下来的各个月里将会有多少对兔子？第一个月，就只有一对兔子；第二个月，还是只有一对兔子（不过已经长大了）；第三个月，这对兔子生了一对，于是变为两对兔子；第四个月，这对兔子又生出了一对，于是变为三对兔子。到了第五个月，情况变得有些复杂了，第三个月出生的兔子已经长大了，因而此时一共有了两对成兔。它们将各产生一对新的兔子，从而让第五个月的兔子总数变为五对。继续往下绘制“兔子族谱图”，得到的图形（如下图，感谢 Geek 小美女 <a href="http://localhost-8080.com">localhost_8080</a> 带来的插图）将会和图 R 一模一样。各月的兔子对数形成了 Fibonacci 数列： 1, 1, 2, 3, 5, 8, 13, … 。</p>
<p>      <img alt="image placeholder" >
<p> </p>
<p>      <img alt="image placeholder" >
<p>    现在，让我们把图 R 中的最上面那个结点也去掉，只看图中蓝色方框内的部分。不妨把这部分的图叫做图 G 。图 G 具有一种让人更加震撼的结构：去掉 3 和 5 这两个结点后，你将会得到两棵分离的子树，这两棵子树的形状和整个图 G 完全一样，如右图所示。换句话说，图 G 是由它自身的两个拷贝高低错落地拼在一起得到的。 Hofstadter 在书里给出了一个更帅的描述：</p>
<p>      <img alt="image placeholder" >
<p>    现在，大家看到了同一棵树的好几种不同的描述方法，这些描述方法互相之间都是有联系的（其中有一些是非常明显的）。同时，每一种描述方法都给出了一个新的角度，来解释这棵树和 Fibonacci 数之间的联系。</p>
<p>    回到数列 G 本身，它也有很多漂亮的等价定义。</p>
<p>    任何一个正整数都可以唯一地表示成若干个两两不同并且两两不相邻的 Fibonacci 数之和。例如， 28 就可以写成 21 + 5 + 2 ，其中 21 、 5 和 2 是三个不同的 Fibonacci 数，并且它们是两两不相邻的。注意，为了把 28 写成若干个不同的 Fibonacci 数之和，我们可能还有一些其他的方法，比方说 28 = 13 + 8 + 5 + 2 ，但这里面包含有相邻的 Fibonacci 数，因而是不允许的。给定一个正整数后，为了找到满足要求的分解方案，我们可以简单地采用“贪心算法”：每次都选择尽可能大的 Fibonacci 数即可。例如，最大的不超过 28 的 Fibonacci 数是 21 ，选了 21 之后，我们就还剩下 7 ；最大的不超过 7 的 Fibonacci 数是 5 ，于是接下来我们选择 5 ，剩下一个 2 ；最大的不超过 2 的 Fibonacci 数就是 2 ，于是选完 2 之后，符合要求的分解方案就找到了： 28 = 21 + 5 + 2 。为什么这种算法得到的分解方案是符合要求的，以及为什么不会有其他满足要求的分解方案，可以参见 Wikipedia 的<a href="http://en.wikipedia.org/wiki/Zeckendorf%27s_theorem">相关条目</a>。这种用不重复并且不相邻的 Fibonacci 数之和表示正整数的方法就叫做正整数的 Zeckendorf 表达。好了，有趣的事情出现了，如果把正整数 n 的 Zeckendorf 表达中的每一个 Fibonacci 数都替换成它在 Fibonacci 序列中的前一个数，就会得到 G(n) ！例如， 28 = 21 + 5 + 2 ，把 21 、 5 、 2 分别替换成小一号的 Fibonacci 数，即 13 、 3 、 1 ，重新加起来便得到 13 + 3 + 1 = 17 ，这正好是 G(28) 的值！这可以看作是数列 G 的一个等价的定义。</p>
<p>      <img alt="image placeholder" >
<p>    观察数列 G ，容易看出很多其他的性质。例如，数列 G 从 1 开始逐渐递增，序列中的每个数要么出现了一次，要么出现了两次。考虑两个极端情况，数列 1, 2, 3, 4, 5, 6, … 将会是一个斜率为 1 的线性递增数列，数列 1, 1, 2, 2, 3, 3, 4, 4, … 则将是一个斜率为 0.5 的线性递增数列。因此，数列 G 也是线性递增的，平均增长速度将会介于 1 和 0.5 之间。那么，数列 G 的平均增长速度究竟是多少呢？为此，我们画出 G(n) / n 的图像，结果非常明确： G(n) / n 趋近于 0.618 附近的一个数，这让我们立即联想到黄金比例。</p>
<p>      <img alt="image placeholder" >
<p>      也就是说，数列 G 的平均增长速度是 (√<span style="text-decoration:overline">5</span> – 1) / 2 ？在 1984 年的一篇论文中， Downey 和 Griswold 证明了，事实上对于所有的 n ， G(n) 总是等于 ⌊ (n + 1) · (√<span style="text-decoration:overline">5</span> – 1) / 2 ⌋ ，其中 ⌊ x ⌋ 表示不超过 x 的最大整数。这可以看作是 G(n) 的另一个等价的定义。可见，数列 G 确实在以 (√<span style="text-decoration:overline">5</span> – 1) / 2 的速度增长。</p>
<p> <br>
 <br>
    故事远远没有结束。如果修改一下数列 G 的定义，我们又会得到什么呢？在那本庞大而诡异的奇书中， Hofstadter 定义了 G(n) 之后，立即介绍了一个新的数列： H(n) = n – H(H(H(n – 1))) ，其中 H(1) = 1 。注意它和 G(n) 的区别：仅仅是在递推时多嵌套了一层。新的序列的前 30 项如下：</p>
<table border="1" width="600" style="border-collapse:collapse; margin-left: 30px;">
<tr>
<td>n</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
</tr>
<tr>
<td>G(n)</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>13</td>
<td>14</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>17</td>
<td>18</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>20</td>
</tr>
</table>
<p>      <img alt="image placeholder" >
<p>    仍然把每个编号为 n 的结点连接到编号为 H(n) 的结点下边，我们将会得到一个新的树形图，不妨就叫做图 H 。从第二行开始，写下各行的结点数量，就会得到下面这个数列： 1, 1, 1, 2, 3, 4, 6, 9, 13, 19, … 。这是什么数列？如果大家经常玩找数列规律的游戏，一定会瞬间看出，这个数列可以看作是 Fibonacci 数列的一种推广：它的头三项都是 1 ，从第四项开始，每一项都是往前数一项和往前数三项这两个数之和。和之前一样，上面这棵树还会从另一方面和该数列发生联系：前 n 行的总结点数，或者说第 n 行的最右侧那个结点的编号，正好是数列中的第 n + 2 个数。如果我们把数列中的第 i 个数记作 C<sub>i</sub> 的话，我们将会得到下面这个恒等式： C<sub>1</sub> + C<sub>2</sub> + … + C<sub>n-1</sub> + 1 = C<sub>n+2</sub> 。</p>
<p>      <img alt="image placeholder" >
<p>    树形图 H 本身依旧有很多等价的描述。它仍然具有递归的性质，其构造方法可以简单地概括为上图。它仍然可以看作是一种族谱图，只需要稍加修改即可。据说， 14 世纪印度数学家 Narayana Pandit 曾经提出过“母牛生小牛问题”（做过基础编程练习的朋友或许很熟悉这个问题）：每一只小牛都在两年后长大，并在此之后每一年都会生产一只新的小牛，问今后每一年里都有多少牛。“母牛生小牛问题”和“兔子问题”非常类似，本质上只有一点不同：成熟期从一个单位的时长变成了两个单位的时长。这将导致新的族谱图中每条生命线都会延迟一层才开始出现分岔，于是便得到了新的树形图 H 。各年里牛的数量依次为 1, 1, 1, 2, 3, 4, 6, 9, 13, 19, …，正是刚才的数列 C 。在 <a href="http://oeis.org/A000930">OEIS</a> 上可以看到，这个数列有一个可爱的名字，叫做 Narayana 奶牛数列。</p>
<p>    Zeckendorf 分解的唯一性似乎不再适用于奶牛数列了，用这个数列里的数来表示 15 ，至少有 15 = 13 + 2 和 15 = 9 ＋ 4 ＋ 2 两种方案，这两种分解方案都是合法的，里面没有重复的或者相邻的数。但是，如果我们让选数的限制更加苛刻，要求任意两个所选的数在奶牛数列中都至少间隔两个数（或者说每三个连续的奶牛数当中最多只能选一个数），那么 15 的后一种分解方案就不合法了。事实上，可以证明，在新的限制下，任意整数在奶牛数列中的 Zeckendorf 分解仍然是唯一的，且同样可以用贪心算法获得这一分解方案。据此我们也能得出 H(n) 的等价定义：把正整数 n 的 Zeckendorf 分解方案中的每个数都变成它在奶牛数列中的前一个数，加起来就是 H(n) 的值。例如， 15 = 13 + 2 ，把 13 和 2 分别变成 9 和 1 ，而 9 + 1 = 10 ，这正好是 H(15) 的值。</p>
<p>      <img alt="image placeholder" >
<p>    H(n) / n 的图像显得稍微怪异一些，并趋向于一个约为 0.682 的值，它实际上是 x<sup>3</sup> + x = 1 的唯一正实数根。回想一下， G(n) / n 的图像会趋于黄金分割值 (√<span style="text-decoration:overline">5</span> – 1) / 2 ，它实际上是 x<sup>2</sup> + x = 1 的唯一正实数根！于是你会发现， H(n) 仍然满足 G(n) 所具有的各种性质，只是其中的某个参数在某种意义上平移了一位！</p>
<p>    我们自然期待， I(n) = n – I(I(I(I(n – 1)))) 能够继续延续这种规律。我们甚至会设想，如果往反方向走，定义新的数列 F(n) = n – F(n – 1) ，规律是否也在反方向上继续延续。不用怀疑，答案是肯定的。数列 F 将会退化到一种大家非常熟悉的情形，实际分析起来颇有一种亲切感，大家不妨自己试试。</p>
<p> <br>
 <br>
    这一切都是为什么呢？大家或许会相信，这背后一定存在一个漂亮而完美的组合解释，可以把刚才观察到的所有现象全都串在一起。不过， Hofstadter 似乎并不这样认为。他冷静地举了一个新的例子来告诉我们，非线性递推序列还可以表现出一些更不可预测的行为。考虑序列 Q(n) = Q(n – Q(n – 1)) + Q(n – Q(n – 2)) ，其中 Q(1) = Q(2) = 1 。这个序列和 Fibonacci 数列的精神非常相似。在 Fibonacci 数列中，为了寻找下一个数是多少，我们总是去看往前 1 个数是多少，往前 2 个数是多少，然后把这两个数加起来。数列 Q(n) 也是类似的，只不过刚才的 1 和 2 变成了变量，由 Q(n – 1) 和 Q(n – 2) 的值来决定。 Q(n) 的前 30 项为：</p>
<table border="1" width="600" style="border-collapse:collapse; margin-left: 30px;">
<tr>
<td>n</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
</tr>
<tr>
<td>Q(n)</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>10</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>11</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>16</td>
<td>14</td>
<td>14</td>
<td>16</td>
<td>16</td>
<td>16</td>
<td>16</td>
</tr>
</table>
<p>    Q(n) / n 的图像呢？这次就真的怪了：</p>
<p>      <img alt="image placeholder" >
<p>    目前，我们还不知道 Q(n) / n 会趋向于哪个值。事实上，我们还不知道 Q(n) / n 是否会趋向于某个值。事实上，我们甚至还不知道，数列 Q(n) 是否会无限继续下去。如果对于某个 n ， n – Q(n – 1) 或者 n – Q(n – 2) 是一个负数，那么 Q(n) = Q(n – Q(n – 1)) + Q(n – Q(n – 2)) 就不存在了。但目前，没有人能够证明，这样的事情不会发生。</p>
<p> <br>
    1988 年， John Conway 曾经发现过一个行为更奇怪的非线性递推序列： a(n) = a(a(n – 1)) + a(n – a(n – 1)) ，其中 a(1) = a(2) = 1 。数列的前 30 项为：</p>
<table border="1" width="600" style="border-collapse:collapse; margin-left: 30px;">
<tr>
<td>n</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
</tr>
<tr>
<td>a(n)</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>14</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>16</td>
<td>16</td>
<td>16</td>
</tr>
</table>
<p>    a(n) / n 的图像则如下图所示：</p>
<p>      <img alt="image placeholder" >
<p>    这个图像相当出人意料，它包含一段一段跨度逐渐倍增但高度逐渐递减的拱形，每个拱形的样子都有如分形图形一般，且起始坐标和终止坐标正好都是 2 的幂。事实上， Conway 证明了 a(n) / n 最终会无限接近于 1 / 2 ，但在那个计算机还不够强大的年代，我们很难检测出它的收敛速度。 Conway 希望能够找到一个（可能很大的）正整数 N ，使得当 n 增加到了 N 时，今后所有的 a(n) / n 与 1 / 2 的差都小于，比如说， 1 / 20 。 Conway 甚至还悬赏了 10000 美元，奖励给第一个找到满足要求的 N 的人。不久之后，这个奖金由 Collin Mallows 领走，他给出的 N 值为 6 083 008 742 （这段故事还有一个小插曲，感兴趣的读者不妨看看<a href="http://exp618.com/archives/864">这里</a>）。后来发现，其实 N 的值还可以小得多，最小的满足要求的 N 为 1489 。 a(1489) / 1489 = 0.55003358… ，此后的 a(n) / n 就再也没超过 0.55 了。事情传到 Hofstadter 那里之后， Hofstadter 宣称自己早在十多年前就已经发现了这个古怪而有趣的数列。因此，这个数列就叫做 Hofstadter–Conway $10,000 sequence 。</p>
<p>    在 MathWorld 上的 <a href="http://mathworld.wolfram.com/Hofstadter-Conway10000-DollarSequence.html">Hofstadter-Conway $10,000 Sequence</a> 页面当中还给出了一个额外的例子。考虑递推数列 b(n) = b(b(n – 1)) + b(n – b(n – 2) – 1) ， 其中 b(1) = b(2) = 1 。数列的前 30 项为：</p>
<table border="1" width="600" style="border-collapse:collapse; margin-left: 30px;">
<tr>
<td>n</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
</tr>
<tr>
<td>b(n)</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>11</td>
<td>13</td>
<td>15</td>
<td>15</td>
<td>14</td>
<td>15</td>
<td>16</td>
</tr>
</table>
<p>    b(n) / n 的图像则是我们今天看到的所有图像中最奇异的一个：</p>
<p>      <img alt="image placeholder" >
<p>    很难相信，上图竟然是用一个如此简单的递推式生成的。这种奇妙的感觉就如同 Hofstadter 在 Gödel, Escher, Bach: An Eternal Golden Braid 中第一次介绍 G 数列时所写的那样：“我在研究函数 G 的时候，试图很快地计算它的值，我想到了把已知的值表示成一棵树。使我惊讶的是，这棵树最后竟会有这种极其规则的递归几何描述……递归几何结构有着优美的规则性，恰好与递归代数结构对应在了一起。”</p>
			 ]]></content>
<pubDate>2013-01-11T22:38:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5152</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 2月14日：送给你的礼物 ]]></title>
<link>http://www.matrix67.com/blog/archives/5170</link>
<content><![CDATA[ 
		<p><script type="text/javascript" src="http://www.matrix67.com/data/three.min.js"></script><script type="text/javascript" src="http://www.matrix67.com/data/FirstPersonControls.js"></script><script type="text/javascript" src="http://www.matrix67.com/data/helvetiker_regular.typeface.js"></script><script type="text/javascript" src="http://www.matrix67.com/data/214game.js"></script>
</p>
<div id="game_area" style="width: 600px; height: 450px; margin-left: 20px;"></div>
<p style="margin-left: 500px; margin-top: 10px; ">* 需要 WebGL 支持</p>
			 ]]></content>
<pubDate>2013-02-14T14:40:40+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5170</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：Alice和Bob的等值交易 ]]></title>
<link>http://www.matrix67.com/blog/archives/5182</link>
<content><![CDATA[ 
		<p>    Alice 的手中有 n 件物品，每件物品的价值都是一个 1 到 n 之间的整数； Bob 的手中也有 n 件物品，每件物品的价值也都是 1 到 n 之间的整数。现在，两人想要进行一次等值的交易，即 Alice 从自己手中拿出至少一件物品， Bob 从自己手中拿出至少一件物品，使得两人所拿出的物品总价值相等。求证：这是总能办到的。</p>
<p><span id="more-5182"></span><br>
 <br>
 <br>
 <br>
 <br>
    我们可以假设两人手中所有物品的总价值不相等（否则问题就直接解决了）。无妨假设 A 手中的物品的总价值小于 B 手中的物品的总价值（否则的话，交换 A 、 B 的身份即可）。</p>
<p>    现在，从 A 开始，两人轮流从自己手中挑选物品摆在桌面上。在第 i 轮中， A 摆出自己的第 i 件物品， B 则适当地摆出零件、一件或多件物品，让桌面上 B 的物品总价值等于 A 的物品总价值，或者小于 A 的物品总价值，但差值不超过 n – 1 。注意到 B 所拥有的物品总价值比 A 更高，并且所有物品的价值数目都是 1 到 n 之间的数，因此这一点是一定能办到的。第 n 轮结束后， A 就已经把自己手中所有的物品都摆上桌面了，但 B 还没有把自己手中所有的物品都摆上去。让我们把第 i 轮结束后，两人摆在桌面上的物品的总价值差记作 R<sub>i</sub> 。</p>
<p>    如果存在某个 R<sub>i</sub> = 0 ，这就说明在某个时刻，桌面上的物品已经等值了，问题就解决了。如果所有的 R<sub>i</sub> 都不等于 0 呢？这样的话，数列 R<sub>1</sub>, R<sub>2</sub>, …, R<sub>n</sub> 中的所有数都只有 1 到 n – 1 共 n – 1 种可能的取值，然而数列中一共有 n 个数，因此其中必然会有两个相同的数，比方说 R<sub>x</sub> = R<sub>y</sub> （不妨假设 x &lt; y ）。这就说明，在第 x 轮结束后，桌面上 A 的物品总价值比 B 的物品总价值大多少，到第 y 轮结束后，桌面上 A 的物品总价值也就比 B 的物品总价值大多少。因此，在第 x + 1 轮到第 y 轮之间，两人各自摆上桌面的物品就是等值的了。</p>
<p>    注意，我们实际上证明了一个更强的结论：假如有两个长度均为 n 的正整数序列，其中每个数都不超过 n ，那么一定能从两个数列中各取一段连续子序列，使得它们的和相等。</p>
<p>    问题来源： <a href="http://www.cs.cmu.edu/puzzle/puzzle24.html">http://www.cs.cmu.edu/puzzle/puzzle24.html</a> ，答案有所重新叙述。</p>
			 ]]></content>
<pubDate>2013-02-28T00:42:59+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5182</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：证明边权递增的路径始终存在 ]]></title>
<link>http://www.matrix67.com/blog/archives/5167</link>
<content><![CDATA[ 
		<p>    一个树林里有 100 个村庄，它们之间有 1000 条小路，每条小路都连接着两个不同的村庄。每条小路 e 都有一条难度系数 l(e) ，所有小路的难度系数都不相同。现在有一个探险家，他想要选择一条长度为 20 的路径，使得所经过的小路的难度系数不断增加。求证：他总能找到这样的路径。</p>
<p>    探险家可以任意选择路径的起点和终点。</p>
<p><span id="more-5167"></span><br>
    为了证明这个结论，让我们在 100 个村庄里各放置一个探险家，然后按照难度系数从小到大的顺序依次清点树林中的 1000 条小路，每点到一条小路 u-v ，就交换小路两端的两个探险家的位置，让位于 u 的探险家移动到 v 去，让位于 v 的探险家移动到 u 去。遍历完所有的小路后，每个探险家的移动轨迹就都构成了一个难度系数不断递增的路径。由于每次点到一条小路时，我们都会让其中两个探险家各移动一步，因此最终所有探险家一共移动了 2000 步，换句话说所有 100 条路径的总长度是 2000 。显然，不可能每条路径的长度都小于 20 ，因而其中一定有一条路径，它的长度至少是 20 。</p>
<p>    这个谜题来自 Peter Winkler ，出处见<a href="http://www.cs.cmu.edu/puzzle/puzzle28.html">这里</a>。</p>
			 ]]></content>
<pubDate>2013-02-28T00:44:57+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5167</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：测量两根木棒长度的更优方案 ]]></title>
<link>http://www.matrix67.com/blog/archives/5165</link>
<content><![CDATA[ 
		<p>    这道题出自 Fifty Challenging Problems in Probability 一书中的第 49 个问题（有趣的是，这本书里其实一共有 56 个问题）。假设你有一个长度测量工具。在测量实际长度为 L 的物体时，由于不可避免的误差，你将会得到一个平均值为 L ，方差为 σ<sup>2</sup> 的随机结果。现在有两根长度未知的木棒，你需要用两次测量得出每根木棒的长度，使得所得结果的误差尽可能的小。除了分别测量每根木棒的长度以外，还有没有什么更好的方案？</p>
<p><span id="more-5165"></span><br>
 <br>
 <br>
 <br>
    答案是肯定的。假设两根木棒的真实长度分别为 A 和 B ，其中 A &gt; B 。把它们头尾相接摆在一起，测量 A + B 的长度；再把它们并排放在一块儿，其中一头对齐，测量 A – B 的长度。把这两次测量结果分别记作 S 和 D ，那么 (S + D) / 2 就是 A 的长度， (S – D) / 2 就是 B 的长度。</p>
<p>    注意到，测量结果 S 实际上是一个以 A + B 为中心波动的随机数，测量结果 D 实际上是一个以 A – B 为中心波动的随机数。可以证明， (S + D) / 2 就将会是一个以 A 为中心波动的随机数， (S – D) / 2 就将会是一个以 B 为中心波动的随机数。但是，为什么这样一来，误差就比直接测量 A 和 B 更小呢？</p>
<p>    不妨假设测量结果 S 的方差为 σ<sub>S</sub><sup>2</sup> ，测量结果 D 的方差为 σ<sub>D</sub><sup>2</sup> ，由于对于两个独立的随机变量来说，和的方差就等于方差的和，因此 S + D 的方差就是 σ<sub>S</sub><sup>2</sup> ＋ σ<sub>D</sub><sup>2</sup> ，进而 (S + D) / 2 的方差就是 (σ<sub>S</sub><sup>2</sup> ＋ σ<sub>D</sub><sup>2</sup>) / 4 ，它等于 (σ<sup>2</sup> ＋ σ<sup>2</sup>) / 4 ，也就是 σ<sup>2</sup> / 2 ，这显然比单独测量一次 A 更好。那么 (S – D) / 2 呢？注意到 – D 和 D 的方差是一样的，因此 (S – D) / 2 ，或者说 (S + (- D)) / 2 ，其方差也是 (σ<sup>2</sup> ＋ σ<sup>2</sup>) / 4 = σ<sup>2</sup> / 2 ，显然也优于单独测量 B 的结果。</p>
<p>    利用上面这种分析误差的模型，可以很好地解释为什么“多次测量求平均值”可以减小误差：在给 n 次测量结果之和除以 n 的时候，测量结果的方差也降为了原来的 1 / n 。而今天这个问题的“和差测量方案”巧妙就巧妙在，仍然只用两次测量，却同时给两根木棒的长度都提供了方差减半的机会，最终达到的精度相当于是为每根木棒各测量了两次。</p>
<p>    对于一组独立的随机变量，和的方差就等于方差的和。这是一个非常重要的结论，它还有很多有趣的应用。这里则是另一个我很喜欢的例子：<a href="http://www.matrix67.com/blog/archives/1810">http://www.matrix67.com/blog/archives/1810</a>。</p>
			 ]]></content>
<pubDate>2013-02-28T00:46:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5165</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：一个与含60度的三角形有关的性质 ]]></title>
<link>http://www.matrix67.com/blog/archives/5189</link>
<content><![CDATA[ 
		<p>      <img alt="image placeholder" >
<p>    有一个三角形，三边长分别为 a 、 b 、 c ，其中 a 、 b 两条边夹角为 60° 。分别以 a 、 b 、 c 为边向外作等边三角形。求证：前两个等边三角形的面积之和，减去第三个等边三角形的面积，将等于原三角形的面积。</p>
<p><span id="more-5189"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
      <img alt="image placeholder" >
<p>    我们提供两种方法。一个容易想到的传统做法便是，利用余弦定理求出 a 、 b 、 c 之间的关系。由于 c 所对的角是 60° ，因此有：</p>
<p>      2 · a · b · cos60° = a<sup>2</sup> + b<sup>2</sup> – c<sup>2</sup></p>
<p>    由于 cos60° = 1 / 2 ，上式化简为：</p>
<p>      a · b = a<sup>2</sup> + b<sup>2</sup> – c<sup>2</sup></p>
<p>    另外，由于 sin60° = √<span style="text-decoration:over line">3</span> / 2 ，因此我们在上式左边乘以 (1 / 2) sin60° ，在等式右边乘以 √<span style="text-decoration:overline">3</span> / 4 ，等式仍然成立：</p>
<p>      (1 / 2) · a · b · sin60° = (√<span style="text-decoration:overline">3</span> / 4) a<sup>2</sup> + (√<span style="text-decoration:overline">3</span> / 4) b<sup>2</sup> – (√<span style="text-decoration:overline">3</span> / 4) c<sup>2</sup></p>
<p>    注意到边长为 s 的等比三角形面积公式为 (√<span style="text-decoration:overline">3</span> / 4) s<sup>2</sup> ，另外等式左边的 (1 / 2) · a · b · sin60° 正是原三角形的面积，于是命题得证。</p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
      <img alt="image placeholder" >
<p>    我们给出另一种看起来更帅的做法，能够更直接地得到这个结论。容易证明，图中的水平线段 a 和水平线段 b 确实是在一条直线上，它们共同组成了一条长为 a + b 的线段。像上图那样，以这条长为 a + b 的线段为边，作一上一下两个大等边三角形。不难看出，所有的红色三角形都跟原三角形全等，而这又能推出，蓝色三角形就是一个边长为 c 的等边三角形。如果把原三角形的面积记作 X ，把边长为 s 的等边三角形的面积记作 A(s) ，于是有 A(a) + A(b) + 2 · X = A(a + b) = A(c) + 3 · X ，整理可得 X = A(a) + A(b) – A(c) ，命题得证。</p>
<p>题目来源：<a href="http://www.cut-the-knot.org/Curriculum/Geometry/GeoGebra/Eutrigon.shtml">http://www.cut-the-knot.org/Curriculum/Geometry/GeoGebra/Eutrigon.shtml</a></p>
			 ]]></content>
<pubDate>2013-03-08T16:02:52+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5189</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 网络流和棒球赛淘汰问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/5190</link>
<content><![CDATA[ 
		<p>    1996 年 9 月 10 日，《旧金山纪事报》的体育版上登载了《巨人队正式告别 NL 西区比赛》一文，宣布了旧金山巨人队输掉比赛的消息。当时，圣地亚哥教士队凭借 80 场胜利暂列西区比赛第一，旧金山巨人队只赢得了 59 场比赛，要想追上圣地亚哥教士队，至少还得再赢 21 场比赛才行。然而，根据赛程安排，巨人队只剩下 20 场比赛没打了，因而彻底与冠军无缘。</p>
<p>    有趣的是，报社可能没有发现，其实在两天以前，也就是 1996 年 9 月 8 日，巨人队就已经没有夺冠的可能了。那一天，圣地亚哥教士队还只有 78 场胜利，与洛杉矶道奇队暂时并列第一。此时的巨人队仍然是 59 场胜利，但还有 22 场比赛没打。因而，表面上看起来，巨人队似乎仍有夺冠的可能。然而，根据赛程安排，圣地亚哥教士队和洛杉矶道奇队互相之间还有 7 场比赛要打，其中必有一方会获得至少 4 场胜利，从而拿到 82 胜的总分；即使巨人队剩下的 22 场比赛全胜，也只能得到 81 胜。由此可见，巨人队再怎么努力，也不能获得冠军了。</p>
<p>    在美国职业棒球的例行赛中，每个球队都要打 162 场比赛（对手包括但不限于同一分区里的其他队伍，和同一队伍也往往会有多次交手），所胜场数最多者为该分区的冠军；如果有并列第一的情况，则用加赛决出冠军。在比赛过程中，如果我们发现，某支球队无论如何都已经不可能以第一名或者并列第一名的成绩结束比赛，那么这支球队就提前被淘汰了（虽然它还要继续打下去）。从上面的例子中可以看出，发现并且证明一个球队已经告败，有时并不是一件容易的事。为了说明这一点，我们展示一组虚构的数据（这是在 1996 年 8 月 30 日美国联盟东区比赛结果的基础上略作修改得来的），如下表所示。</p>
<table>
<tr>
<td>Team</td>
<td>胜</td>
<td>负</td>
<td>余</td>
<td>纽约</td>
<td>巴尔的摩</td>
<td>波士顿</td>
<td>多伦多</td>
<td>底特律</td>
</tr>
<tr>
<td>纽约</td>
<td>75</td>
<td>59</td>
<td>28</td>
<td>0</td>
<td>3</td>
<td>8</td>
<td>7</td>
<td>3</td>
</tr>
<tr>
<td>巴尔的摩</td>
<td>72</td>
<td>62</td>
<td>28</td>
<td>3</td>
<td>0</td>
<td>2</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td>波士顿</td>
<td>69</td>
<td>66</td>
<td>27</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>多伦多</td>
<td>60</td>
<td>75</td>
<td>27</td>
<td>7</td>
<td>7</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>底特律</td>
<td>49</td>
<td>86</td>
<td>27</td>
<td>3</td>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</table>
<p>    其中，纽约扬基队暂时排名第一，总共胜 75 场，负 59 场，剩余 28 场比赛没打，其中和巴尔的摩还有 3 场比赛，和波士顿还有 8 场比赛，和多伦多还有 7 场比赛，和底特律还有 3 场比赛（还有 7 场与不在此分区的其他队伍的比赛）。底特律暂时只有 49 场比赛获胜，剩余 27 场比赛没打。如果剩余的 27 场比赛全都获胜的话，是有希望超过纽约扬基队的；即使只有其中 26 场比赛获胜，也有希望与纽约扬基队战平，并在加赛中取胜。然而，根据表里的信息已经足以判断，其实底特律已经没有希望夺冠了，大家不妨自己来推导一下。</p>
<p><span id="more-5190"></span><br>
    有没有什么通用的方法，能够根据目前各球队的得分情况和剩余的场次安排，有效地判断出一个球队是否有夺冠的可能？ 1966 年， Schwartz 在一篇题为 Possible winners in partially completed tournaments 的论文中指出，其实刚才提出的问题，可以归结为一个简单而巧妙的网络流模型。</p>
<p> </p>
<p>      <img alt="image placeholder" >
<p>    让我们先来看一个似乎完全无关的问题。假设图 1 是一个交通网示意图，其中 s 点是出发点（或者说入口）， t 点是终点（或者说出口），其余所有的点都是交叉路口。点与点之间的连线代表道路，所有道路都是单行道，汽车只能沿着箭头方向行驶。由于道路的宽度、限速不同等原因，每条道路都有各自的最大车流量限制，我们已经把它们标在了图上。例如，道路 b → c 的最大车流量为 6 ，这就表示当你站在这条道路上的任意一点时，单位时间内最多可以有 6 辆汽车经过你所在的位置。假设在 s 点处源源不断地有汽车想要到达 t 点，这些汽车已经在 s 点处排起了长队。那么，应该怎样安排每条道路的实际流量，才能让整个交通网络的总流量最大化，从而最大程度地缓解排队压力呢？</p>
<p>    其中一种规划如图 2 所示，各道路上标有实际流量和最大流量，此时整个交通网络的流量为 6 。由 s 点出发的汽车平分两路，这两条路的实际流量均为 3 ，分别驶入 a 路口和 b 路口。在 b 路口处还有另外一条驶入的路，流量为 2 。从 s → b 和 a → b 这两条路上来的车合流后驶入 b → c ，因而 b → c 的实际流量就是 5 。这 5 个单位的车流量是 c 路口的驶入汽车的唯一来源，这些车分为两拨，其中 1 个单位的车流量进入 c → a 路，另外 4 个单位的车流量直接流向了终点。 a 路口的情况比较复杂，其中有两条路是驶入的，实际流量分别为 3 和 1 ；有两条路是驶出的，实际流量分别为 2 和 2 。注意，我们实际上并不需要关心从每条路上驶入的车都从哪儿出去了，也不需要关心驶往各个地方的车又都是从哪儿来的，只要总的流入量等于总的流出量，这个路口就不会发生问题。</p>
<p>      <img alt="image placeholder" >
<p>    有些朋友可能已经发现，我们的规划多少有些奇怪：图中存在 a → b → c → a 这么一个“圈”，搞得不好的话，有些车会在里面转圈，永远到不了 t 点。不过，我们只关心整个系统的总流量，并不关心实际上每个个体的命运。换句话说，我们可以假设汽车与汽车之间都是无差异的。事实上，如果把这个圈里的所有道路的实际流量都减 1 ，整个网络的总流量仍然不会发生变化，但得到的却是一个更简洁、更明晰的流量规划。不过，为了让后面的讲解更有趣一些，我们故意选取了一个复杂的规划。</p>
<p>    给定一个交通网络图，给出图中每条道路允许的最大流量，再指定一个点作为源点（通常用 s 表示），指定一个点作为汇点（通常用 t 表示）。如果为每条道路设定一个实际流量（通常可以假设流量值为整数），使得每条道路的实际流量都不超过这条道路的最大流量，并且除了s点和t点之外，其他每个点的总流入量都等于总流出量，我们就说这是一个网络流。由于制造流量的只有 s 点，消耗流量的只有 t 点，其他点的出入都是平衡的，因此很容易看出，在任意一个网络流中， s 点的总流出，一定等于 t 点的总流入。我们就把这个数值叫做网络流的总流量。我们通常关心的是，如何为各条道路设定实际流量，使得整个图的总流量最大。</p>
<p>    图 2 的流量显然还没有达到最大，因为我们还可以找出一条从 s 到 t 的路径，使得途中经过的每条道路的流量都还没满。例如， s → a → b → c → t 就是这样的一条路径。把这条路径上的每条道路的实际流量都加 1 ，显然能够得到一个仍然合法，但总流量比原来大 1 的网络流。新的网络流如图 3 所示。</p>
<p>      <img alt="image placeholder" >
<p>    我们还能进一步增加流量吗？还能，但是这一次就不容易看出来了。考虑路径 s → b → a → c → t ，注意这条路径中只有 s → b 段和 c → t 段是沿着道路方向走的，而 b → a 段和 a → c 段与图中所示的箭头方向正好相反。现在，我们把路径中所有与图中箭头方向相同的路段的实际流量都加 1 ，把路径中所有与图中箭头方向相反的路段的实际流量都减 1 。于是，整个网络变成了图 4 的样子。此时你会发现，这番调整之后， s 点的流出量增加了 1 个单位， t 点的流入量增加了 1 个单位，其他所有点的出入依旧平衡。因此，新的图仍然是一个合法的网络流，并且流量增加了 1 个单位。</p>
<p>      <img alt="image placeholder" >
<p>    现在，我们有了两种增加网络流流量的通用模式，考虑到前者实际上是后者的一个特例，因而它们可以被归结为一种模式。首先，从 s 点出发，寻找一条到 t 点的路径，途中要么顺着某条流量还没满的（还能再加流量的）道路走一步，要么逆着某条流量不为零的（能够减少流量的）道路走一步。我们把这样的路径叫做“增广路径”。找到一条增广路径之后，增加或者减少沿途道路的流量，从而在保证网络流仍然合法的前提下，增加网络流的总流量。</p>
<p>    1956 年，美国数学家 Lester Ford, Jr. 和 Delbert Fulkerson 共同发表了一篇题为 Maximal flow through a network 的论文，论文中指出，为了找出一个网络中的最大流量，我们只需要用到上面这种流量改进模式。换句话说，如果不能用上述模式增加某个网络流的流量，即如果图中不存在增广路径，那么此时的流量就一定达到最大值了。</p>
<p>    例如，在图 4 中，网络流的流量已经达到了 8 个单位，但我们再也找不到增广路径了。这就说明，图 4 中的流量已经不能再改进，流量最大就是 8 了。</p>
<p>    这个结论有一个非常漂亮的证明。假设现在有这么一个网络流，它里面不存在任何增广路径，这就意味着，从 s 点出发，沿着尚未满流的道路走，或者逆着尚有流量的道路走，是无法走到 t 点的。我们把从 s 点出发按此规则能够走到的所有点组成的集合记作 U 。根据集合 U 的定义，任何一条从 U 内走到 U 外的道路一定都已经满流了，任何一条从 U 外走进 U 内的道路流量一定都为零，否则的话集合 U 都还能进一步扩大。例如，在图 4 中，集合 U 就是 {s, a, b} 。驶出 U 的道路有两条，分别是 a → t 和 b → c ，它们都已经满流了；驶入 U 的道路只有 c → a ，它的流量一定为零。我们不妨把所有驶出 U 的道路都涂成红色，把所有驶入 U 的道路都涂成蓝色。</p>
<p>    现在，保持集合 U 的范围和道路的颜色不变，修改图中各道路的实际流量，使之成为任意一个合法的网络流。你会发现，下面这个重要的结论始终成立：红色道路里的总流量，减去蓝色道路里的总流量，总是等于整个网络流的流量。比如，把图 4 中的网络流改成图 2 或者图 3 的样子，那么道路 a → t 的流量加上道路 b → c 的流量，再减去道路 c → a 的流量，一定都等于整个网络流的总流量。为什么？其实道理很简单，别忘了，制造流量的只有 s 点，消耗流量的只有 t 点，其他点只负责转移流量，因而不管网络流长什么样，如果从 U 里边流出去的流量比从外边流入 U 的流量更多，多出来的部分就一定是 s 制造的那些流量。</p>
<p>    对于任意一个网络流，这些红色道路的总流量减去这些蓝色道路的总流量，就可以得出整个网络流的总流量，这实际上给出了网络流的流量大小的一个上限——如果在某个网络流中，所有的红色道路都满流，并且所有蓝色道路都无流量，那么流量值便达到上限，再也上不去了。然而，这个上限刚才已经实现了，因而它对应的流量就是最大的了。至此，我们便证明了 Ford 和 Fulkerson 的结论。</p>
<p>    根据这一结论，我们可以从零出发，反复寻找增广路径，一点一点增加流量，直到流量不能再增加为止。这种寻找最大流的方法就叫做 Ford–Fulkerson 算法。</p>
<p> </p>
<p>    在运筹学中，网络流问题有着大量直接的应用。然而，网络流问题还有一个更重要的意义——它可以作为一种强大的语言，用于描述很多其他的实际问题。很多乍看上去与图论八竿子打不着的问题，都可以巧妙地转化为网络流问题，用已有的最大流算法来解决。让我们来看一看， Schwartz 是如何用网络流来解决棒球赛淘汰问题的。</p>
<p>    一支队伍必然落败，意即这支队伍在最好的局面下也拿不到第一。让我们来分析一下底特律可能的最好局面。显然，对于底特律来说，最好的局面就是，剩余 27 场比赛全都赢了，并且其他四个队在对外队的比赛中全都输了。这样，底特律将会得到 76 胜的成绩，从而排名第一。但是，麻烦就麻烦在，剩下的四个队内部之间还会有多次比赛，其中必然会有一些队伍获胜。为了让底特律仍然排在第一，我们需要保证剩下的四个队内部之间比完之后都不要超过 76 胜的成绩。换句话说，在纽约、巴尔的摩、波士顿、多伦多之间的 3 + 8 + 7 + 2 + 7 + 0 = 27 场比赛中，纽约最多还能胜 1 次，巴尔的摩最多还能胜 4 次，波士顿最多还能胜 7 次，多伦多最多还能胜 16 次。只要这 27 场比赛所产生的 27 个胜局能够按照上述要求分给这四个队，底特律就有夺冠的希望。</p>
<p>      <img alt="image placeholder" >
<p>    网络流是描述这种“分配关系”的绝佳模型。为了简便起见，我们把这四个队分别记作 a 、 b 、 c 、 d 。我们为每支队伍都设置一个结点，并且为这四个结点各作一条指向汇点 t 的道路。 a 和 b 之间有 3 场比赛，于是我们设置一个名为 a-b 的结点，然后从源点 s 引出一条道路指向这个结点，并将其最大流量设定为 3 ；再从这个结点出发，引出两条道路，分别指向 a 和 b ，其最大流量可以均设为 3 ，或者任意比 3 大的值（一般设为无穷大，以表示无需限制）。因而，在一个网络流中，结点 a-b 将会从源点 s 处获得最多 3 个单位的流量，并将所得的流量再分给结点 a 和结点 b 。如果把每个单位的流量理解成一个一个的胜局，那么网络流也就可以理解为这些胜局的来源和去向。类似地，我们设置一个名为 a-c 的结点，从 s 到 a-c 有一条道路，最大流量为 8 ，从 a-c 再引出两条道路，分别指向右边的 a 和 c 。除了 c 和 d 之间没有比赛以外，其他任意两队之间都有比赛，因此在最终的网络当中，有 a-b 、 a-c 、 a-d 、 b-c 、 b-d 共 5 个代表比赛的结点。每一个合法的网络流，也就代表了这些比赛所产生的胜局的一种归派方案。我们希望找出一种胜局归派方案，使得 a 、 b 、 c 、 d 获得的胜局数量分别都不超过 1 、 4 、 7 、 16 。因而，我们给 a → t 、 b → t 、 c → t 、 d → t 四条道路的最大流量依次设为 1 、 4 、 7 、 16 。最后，我们利用 Ford–Fulkerson 算法寻找整个网络的最大流，若流量能够达到 27 ，这就说明我们能够仔细地安排四支队伍之间全部比赛的结果，使得它们各自获得的胜局数都在限制范围之内，从而把第一名的位置留给底特律；如果最大流的流量无法达到 27 ，这就说明四个队之间的比赛场数太多，无法满足各队获胜局数的限制，那么底特律也就不可能取胜了。</p>
<p>    事实上，在图 5 所示的网络中，可能的最大流量是 26 （其中一种网络流方案如图 6 所示），没有达到 27 ，因而底特律也就必败无疑了。类似地，我们也可以为其他队伍建立对应的网络，依次计算每个队伍的命运，从而完美解决了棒球赛淘汰问题。</p>
<p>      <img alt="image placeholder" >
<p>    网络流还有很多妙用。感兴趣的读者不妨了解一下二分图最大匹配问题和任务分配问题，继续欣赏网络流模型之美。最大流最小割定理是网络流理论中的一个极其重要的定理，它与上文中 Ford–Fulkerson 算法的正确性证明息息相关，读者朋友们也可以研究研究。</p>
<p> <br>
本文已发表在《程序员》 2013 年 3 月刊上，有改动。我是一个体育盲，文章中对棒球比赛的描述是我苦苦查了大半天的资料之后才写出来的，如有问题请指正。</p>
			 ]]></content>
<pubDate>2013-03-08T16:03:52+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5190</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ IMO2010趣题：用有限次操作得到2010^(2010^2010)枚硬币 ]]></title>
<link>http://www.matrix67.com/blog/archives/5205</link>
<content><![CDATA[ 
		<p>    下面这个问题来自于 IMO 2010 中的第 5 题。桌子上有 B<sub>1</sub> 、 B<sub>2</sub> 、 B<sub>3</sub> 、 B<sub>4</sub> 、 B<sub>5</sub> 、 B<sub>6</sub> 共六个盒子，初始时每个盒子里面都有一枚硬币。允许以下两种操作：</p>
<p>      (1) 选择一个非空的盒子 B<sub>j</sub> （1 ≤ j ≤ 5），从 B<sub>j</sub> 里拿走一枚硬币，然后在 B<sub>j+1</sub> 里添加两枚硬币。<br>
      (2) 选择一个非空的盒子 B<sub>k</sub> （1 ≤ k ≤ 4），从 B<sub>k</sub> 里拿走一枚硬币，然后交换 B<sub>k+1</sub> 和 B<sub>k+2</sub> 里面的硬币数（这两个盒子里的硬币数都有可能是 0 ）。</p>
<p>    是否有可能通过有限次操作，使得最后 B<sub>1</sub> 、 B<sub>2</sub> 、 B<sub>3</sub> 、 B<sub>4</sub> 、 B<sub>5</sub> 都是空的，并且 B<sub>6</sub> 里面恰好有 2010 ^ (2010 ^ 2010) 枚硬币（符号 ^ 表示乘方）？</p>
<p><span id="more-5205"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    我们把操作 1 简记作 [a, b] → [a – 1, b + 2] 。反复使用操作 1 便能把 [a, 0] 变成 [0, 2a] 。我们不妨把它视作一个新的复合操作，叫做 M1 。不断使用 M1 和换位，我们便可以把 [a, 0, 0] 变成 [0, 2<sup>a</sup>, 0] ：</p>
<blockquote><p>[a, 0, 0] → [a – 1, 2, 0] → [a – 1, 0, 4] → [a – 2, 4, 0] → [a – 2, 0, 8] → … → [1, 0, 2<sup>a</sup>] → [0, 2<sup>a</sup>, 0] </p></blockquote>
<p>    不妨把这个新的复合操作叫做 M2 。不断使用 M2 和换位，我们可以把 [a, 0, 0, 0] 变成 [0, <sup>a</sup>2, 0, 0] （其中 <sup>a</sup>2 表示 2 的 a 次超级幂，也就是 <img alt="image placeholder" >
<blockquote><p>[a, 0, 0, 0] → [a – 1, 2, 0, 0] → [a – 1, 0, 4, 0] → [a – 2, 4, 0, 0] → [a – 2, 0, 16, 0] → [a – 3, 16, 0, 0] → [a – 3, 0, 65536, 0] → … → [1, 0, <sup>a</sup>2, 0] → [0, <sup>a</sup>2, 0, 0]</p></blockquote>
<p>    我们把这个复合操作叫做 M3 。</p>
<p>    好了。现在，我们先把初始局面 [1, 1, 1, 1, 1, 1] 变成 [0, 0, 140, 0, 0, 0] ：</p>
<blockquote><p>[1, 1, 1, 1, 1, 1] → [0, 2, 2, 2, 2, 3] → [0, 2, 1, 1, 8, 3] → [0, 2, 1, 1, 0, 19] → [0, 1, 19, 0, 0, 0] → [0, 1, 1, 36, 0, 0] → [0, 1, 1, 1, 0, 140] → [0, 0, 140, 0, 0, 0]</p></blockquote>
<p>    然后，我们调用一次 M3 ，便会得到 [0, 0, 0, <sup>140</sup>2, 0, 0] 。 <sup>140</sup>2 是一个非常非常非常非常大的数，它远远大于我们题目中提到的数。接下来，不断对 <sup>140</sup>2 所在的盒子使用操作 2 ，每次都能白白耗掉一枚硬币，直到这个盒子里只剩下 2010 ^ (2010 ^ 2010) / 4 枚硬币，此时局面变为 [0, 0, 0, 2010 ^ (2010 ^ 2010) / 4, 0, 0] 。最后，两次使用 M1 操作，便能得到我们想要的最终局面 [0, 0, 0, 0, 0, 2010 ^ (2010 ^ 2010)] 。</p>
<p> <br>
    答案来自 <a href="http://michaelnielsen.org/polymath1/index.php?title=Imo_2010">http://michaelnielsen.org/polymath1/index.php?title=Imo_2010</a> ，叙述时有改动。很多简单的问题都可以迅速产生出一些连乘方也难以表达的巨大数字。对此感兴趣的读者不妨看看这里： <a href="http://www.matrix67.com/blog/archives/3857">3857</a> <a href="http://www.matrix67.com/blog/archives/925">925</a> <a href="http://www.matrix67.com/blog/archives/1738">1738</a> <a href="http://www.matrix67.com/blog/archives/4009">4009</a></p>
			 ]]></content>
<pubDate>2013-03-27T21:32:25+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5205</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 为什么Fibonacci数列相邻两项之比会趋于0.618？ ]]></title>
<link>http://www.matrix67.com/blog/archives/5221</link>
<content><![CDATA[ 
		<p>    你或许熟知一个非常经典的结论： Fibonacci 数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, … （头两项都是 1 ，此后每一项都是前两项之和）的相邻两项之比将会越来越接近黄金比例 0.618 ，不信请看：</p>
<p>      1 / 1 = 1.0000000…<br>
      1 / 2 = 0.50000000…<br>
      2 / 3 = 0.66666667…<br>
      3 / 5 = 0.60000000…<br>
      5 / 8 = 0.62500000…<br>
      8 / 13 = 0.61538462…<br>
      13 / 21 = 0.61904762…<br>
      21 / 34 = 0.61764706…<br>
      34 / 55 = 0.61818182…<br>
      55 / 89 = 0.61797753…<br>
      89 / 144 = 0.61805556…<br>
      144 / 233 = 0.61802575…<br>
      … …</p>
<p>    Fibonacci 数列究竟是怎么和黄金比例扯上关系的？一个简单的解释就是，假设相邻两项之比存在一个极限，那么到了无穷远的时候，连续的三个数 a, b, a + b 将会满足 a / b = b / (a + b) ，这正好就是黄金比例的定义。我最近用 Mathematica 做了一组动画，尝试着用图形化的方法更直观地展示 Fibonacci 数列和黄金比例之间的联系。</p>
<p><span id="more-5221"></span><br>
      <img alt="image placeholder" >
<p>    首先，让我们用另一种方式来定义黄金比例。如果在一个矩形中切掉一个正方形以后，剩下的小矩形的长宽比正好和原矩形相同（即大小两个矩形相似），我们就说这个矩形是一个黄金矩形，可以求出它的宽与长之比应该等于 (√<span style="text-decoration:overline">5</span> – 1) / 2 ，一个约为 0.618 的无限不循环小数，也就是我们所说的黄金比例。我们要说明的就是，分别以 (1, 1), (1, 2), (2, 3), (3, 5), (5, 8), (8, 13), … 为边的矩形序列，其长宽比将会越来越接近这个黄金比例。</p>
<p>      <img alt="image placeholder" >
<p> <br>
    注意到，在这个矩形序列中，每一个矩形都可以看作是由上一个矩形旋转 90 度后再拼接一个正方形得来的，例如下图。</p>
<p>      <img alt="image placeholder" >
<p> <br>
    现在，我们从 (1, 1) 开始，不断构造下一个矩形，并且保留作图痕迹。你会看到，随着尺度的增加，初始时的细节已经消失，于是整个矩形看起来和它左侧的小矩形具有完全相同的无限递归结构。渐渐地，大小两个矩形变得几乎完全相似，它们的长宽比变得几乎完全相同！这就说明，矩形的长宽比将会越来越接近黄金比例。</p>
<p>      <img alt="image placeholder" >
<p> <br>
    有趣的是，不管最初的那个矩形的长宽比是什么，随着尺度的增加，它对整个图形的结构产生的影响都会越来越小，就好像不断扩散的涟漪一样，最终在水面上完全消失。因而，不管数列的最初两个数是什么（比如说 2 和 7 ），只要今后每一个数都是前两个数之和，相邻两项之比总是会越来越接近 0.618 。这可以很好地解释一个我很喜欢的<a href="http://www.guokr.com/article/1858/">数学小魔术</a>。</p>
<p>      <img alt="image placeholder" >
			 ]]></content>
<pubDate>2013-03-30T10:04:28+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5221</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：任意三角形都能被分成n≥4个等腰三角形 ]]></title>
<link>http://www.matrix67.com/blog/archives/5270</link>
<content><![CDATA[ 
		<p>    证明：对于任意一个三角形和任意一个大于等于 4 的正整数 n ，都存在一种把这个三角形分割成 n 个等腰三角形的方案。这个问题曾经出现在 1976 年的 Crux Mathematicorum 上。 1977 年， Gali Salvatore 给出了一个非常漂亮的解答。</p>
<p><span id="more-5270"></span><br>
    首先，让我们来看一看如何把任意一个三角形分成 4 个等腰三角形。如图，作出三角形的高，把整个三角形分成两个小直角三角形。对于每一个直角三角形，作出斜边上的中线后都将会把它分成两个小等腰三角形。于是，我们就把整个三角形分成了 4 个小等腰三角形。</p>
<p>      <img alt="image placeholder" >
<p>    我们借此还能实现，把任意一个三角形分成 7 个等腰三角形：只需要先把它分成 4 个等腰三角形，然后再次套用上述方法，把其中一个小等腰三角形继续细分成 4 个更小的等腰三角形即可。事实上，我们还可以继续这样做下去，从而让等腰三角形的数目 3 个 3 个地增加。因此， n = 4, 7, 10, 13, … 的情况便全部解决了。</p>
<p>    由于我们可以让任意分割方案中的等腰三角形数目加 3 ，因而如果 n = 5 和 n = 6 的情况也解决了， n = 5, 8, 11, 14, … 和 n = 6, 9, 12, 15, … 的情况也都自动地解决了，结论也就证到了。所以，接下来我们只需要考虑 n = 5 和 n = 6 的情况。</p>
<p>    n = 6 的情况非常简单，如图，只需要把三角形分成两个直角三角形，再把其中一个直角三角形继续细分成两个更小的直角三角形，最后作出三个直角三角形各自斜边上的中线即可：</p>
<p>      <img alt="image placeholder" >
<p>    n = 5 的情况呢？我们有一个妙招：先在三角形里边分出一个等腰三角形来，然后把剩下的那个三角形分成四个小等腰三角形：</p>
<p>      <img alt="image placeholder" >
<p>    但是，上面这招有一个缺陷：它不能用于等边三角形。为了从原三角形中分出一个等腰三角形来，我们需要在某条边上截取一段，使得它等于另外一条边的长度。但是，如果三角形的三条边全都一样长，这一点就做不到了。因此，我们必须单独为等边三角形想一种把它分成 5 个等腰三角形的方案。好在这并不困难，我们有很多种办法，比方说，像下图这样：</p>
<p>      <img alt="image placeholder" >
<p>    <a href="http://www.matrix67.com/blog/archives/3113">Which Way Did the Bicycle Go</a> 一书中给出了更多不同的把等边三角形分成 5 个等腰三角形的方案：</p>
<p>      <img alt="image placeholder" >
<p>    至此为止，问题就全部解决了。</p>
<p> <br>
参考资料：Ross Honsberger, From Erdos to Kiev: Problems of Olympiad Caliber, pp. 13-17<br>
 </p>
			 ]]></content>
<pubDate>2013-05-02T05:47:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5270</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Borromean rings的另一个离奇的性质 ]]></title>
<link>http://www.matrix67.com/blog/archives/5285</link>
<content><![CDATA[ 
		<p>    下图中的图 (a) 是由三个绳圈组成的。这是一个非常经典的图形，叫做 Borromean rings 。 Borromean rings 有一个非常神奇的特点：它们是套在一起的，没有哪个绳圈能从中取出来；但是，仔细观察你会发现，每两个绳圈之间都并没有直接套在一起！</p>
<p>      <img alt="image placeholder" >
<p>    Borromean rings 还有一个听上去更离奇的性质：如图 (b) 所示，如果把其中任意两个绳圈真的套在一起，那么第三个绳圈就会自动脱落掉！为了看出这一点来，我们可以像图 (c) 那样，把其中一个绳圈缩小，让它紧紧地裹在另一个绳圈上，这下就很容易看出，它已经不再对第三个绳圈有任何限制作用了。</p>
<p><span id="more-5285"></span><br>
    为了增强演示时的效果，我们试着把 Borromean rings 中的其中两个绳圈先拉开来，此时第三个绳圈将会变成下图所示的样子。</p>
<p>      <img alt="image placeholder" >
<p>    于是，一个小魔术就诞生了。像下图中的左图那样，把一根细线圈缠绕在两个别针上，容易验证这个线圈是取不出来的。现在，把两个别针别在一起，线圈就奇迹般地自己脱落出来了。（你能看出来吗？）</p>
<p>      <img alt="image placeholder" >
<p>    这种违背直觉的东西应该引起大家的警惕。比方说，登山运动员就要小心了：有的时候，把两个绳扣扣在一起，反而会松开套在它们上面的绳子！</p>
<p> <br>
参考资料： V. V. Prasolov, Intuitive Topology, Chapter 2<br>
去掉任意一个绳圈，都会解开其他所有的绳圈，满足这种条件的绳圈组叫做 Brunnian link 。 Borromean rings 就是一个最简单的 Brunnian link 。构造更大的 Brunnian link 是一个非常有意思的问题，感兴趣的读者可以看看<a href="http://www.matrix67.com/blog/archives/5058">这里</a>。</p>
			 ]]></content>
<pubDate>2013-05-03T01:11:02+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5285</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：平行线之间的正方形 ]]></title>
<link>http://www.matrix67.com/blog/archives/5293</link>
<content><![CDATA[ 
		<p>    如图，把边长为 d 的正方形放在两条距离也为 d 的平行线之间，于是产生了四个交点。求证，把这四个点交叉相连产生的夹角为 45° 。</p>
<p>      <img alt="image placeholder" >
<p><span id="more-5293"></span><br>
 <br>
 <br>
 <br>
    只需要注意到，如果两条距离为 d 的平行线之间夹着一条线段，那么这条线段的长度唯一地确定了它与两条平行线的夹角。因而，下图中所标注的两个角的度数显然相等（我们也可以严格地证明这一点，只需要过点 P 分别作 l<sub>1</sub> 和 l<sub>3</sub> 的垂线段，并证明三角形全等即可）。</p>
<p>      <img alt="image placeholder" >
<p>    所以，在下图中，两个标有 α 的角是相等的，两个标有 β 的角也是相等的。接下来就简单了。由于 γ + δ = 90° ，并且 2α + 2β + γ + δ = 360° ，因此 2α + 2β = 270° ， 即 α + β = 135° 。那么，我们要求的角度就是 180° – 135° = 45° 了。</p>
<p>      <img alt="image placeholder" >
<p>题目来源： <a href="http://www.mathteacherctk.com/blog/2013/05/a-square-in-parallel-lines">http://www.mathteacherctk.com/blog/2013/05/a-square-in-parallel-lines</a></p>
<p><!-- abc ->
</p>
			</div><!-- .entry-content -->

	<footer class="entry-footer">
		<div class="entry-meta">
			<span class="posted-on"><a href="http://www.matrix67.com/blog/archives/5293" rel="bookmark"><time class="entry-date published" datetime="2013-05-24T22:48:50+00:00">2013 年 5 月 24 日</time></a></span>			/ <a href="http://www.matrix67.com/blog/archives/tag/%e5%87%a0%e4%bd%95" rel="tag">几何</a>, <a href="http://www.matrix67.com/blog/archives/tag/%e8%af%81%e6%98%8e" rel="tag">证明</a>, <a href="http://www.matrix67.com/blog/archives/tag/%e8%b6%a3%e9%a2%98" rel="tag">趣题</a>					</div>
<!-- .entry-meta -->

	</footer><!-- .entry-footer -->
<!-- #post-## -->
			</p>
<div id="rss"><a href="http://www.matrix67.com/blog/feed" target="_blank"></a></div>
			<!--php matrix67_post_nav(); -->

			
<div id="comments" class="comments-area">

	
			<h2 class="comments-title">
			23 条评论		</h2>

		
		<ul class="comment-list">
				<li class="comment even thread-even depth-1" id="comment-19763">
	<img alt="image placeholder" >
		<cite class="fn"><a href="http://localhost-8080.com" rel="external nofollow" class="url">localhost</a></cite>			
		<p>已阅。</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19763">
			2013年5月24日 22:56</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19763#respond" onclick='return addComment.moveForm( "div-comment-19763", "19763", "respond", "5293" )' aria-label="Reply to localhost">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-19764">
	<img alt="image placeholder" >
		<cite class="fn">蓝轩</cite>			
		<p>沙发</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19764">
			2013年5月24日 23:08</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19764#respond" onclick='return addComment.moveForm( "div-comment-19764", "19764", "respond", "5293" )' aria-label="Reply to 蓝轩">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-19765">
	<img alt="image placeholder" >
		<cite class="fn">三脚函鼠</cite>			
		<p>前排~~</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19765">
			2013年5月24日 23:49</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19765#respond" onclick='return addComment.moveForm( "div-comment-19765", "19765", "respond", "5293" )' aria-label="Reply to 三脚函鼠">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-19766">
	<img alt="image placeholder" >
		<cite class="fn">四叶喵kube</cite>			
		<p>好神奇</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19766">
			2013年5月25日 11:21</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19766#respond" onclick='return addComment.moveForm( "div-comment-19766", "19766", "respond", "5293" )' aria-label="Reply to 四叶喵kube">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-19767">
	<img alt="image placeholder" >
		<cite class="fn">Ernest</cite>			
		<p>補充一下，是中心重合的兩個全等正方形。<br>
語病甚麼的就不要吐槽了。。。</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19767">
			2013年5月25日 16:58</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19767#respond" onclick='return addComment.moveForm( "div-comment-19767", "19767", "respond", "5293" )' aria-label="Reply to Ernest">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-19768">
	<img alt="image placeholder" >
		<cite class="fn">Lcdtyph</cite>			
		<p>地下室！！~</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19768">
			2013年5月25日 20:37</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19768#respond" onclick='return addComment.moveForm( "div-comment-19768", "19768", "respond", "5293" )' aria-label="Reply to Lcdtyph">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-19769">
	<img alt="image placeholder" >
		<cite class="fn"><a href="http://blog.csdn.net/jasison" rel="external nofollow" class="url">jasison</a></cite>			
		<p>中学数学证明题。</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19769">
			2013年5月25日 22:32</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19769#respond" onclick='return addComment.moveForm( "div-comment-19769", "19769", "respond", "5293" )' aria-label="Reply to jasison">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-19770">
	<img alt="image placeholder" >
		<cite class="fn">Vincent</cite>			
		<p>命题的条件有点不够严谨吧，考虑极端的情况，正方形有一对平行的边正好与给定的两条平行线重合，此时产生的四个交点就是正方形的四个顶点，而正方形的对角线夹角是90度</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19770">
			2013年5月27日 14:47</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19770#respond" onclick='return addComment.moveForm( "div-comment-19770", "19770", "respond", "5293" )' aria-label="Reply to Vincent">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-19771">
	<img alt="image placeholder" >
		<cite class="fn">万万没有想到</cite>			
		<p>LS你说得那样有无穷多个交点。。。不是4个</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19771">
			2013年5月27日 17:14</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19771#respond" onclick='return addComment.moveForm( "div-comment-19771", "19771", "respond", "5293" )' aria-label="Reply to 万万没有想到">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-19772">
	<img alt="image placeholder" >
		<cite class="fn">elf</cite>			
		<p>看着题目，总是想画个圆怎么破？</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19772">
			2013年5月27日 17:34</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19772#respond" onclick='return addComment.moveForm( "div-comment-19772", "19772", "respond", "5293" )' aria-label="Reply to elf">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-19773">
	<img alt="image placeholder" >
		<cite class="fn">phykid</cite>			
		<p>已看过，留下痕迹</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19773">
			2013年5月29日 18:54</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19773#respond" onclick='return addComment.moveForm( "div-comment-19773", "19773", "respond", "5293" )' aria-label="Reply to phykid">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-19774">
	<img alt="image placeholder" >
		<cite class="fn">lousuan</cite>			
		<p>观察真仔细。。</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19774">
			2013年5月30日 13:42</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19774#respond" onclick='return addComment.moveForm( "div-comment-19774", "19774", "respond", "5293" )' aria-label="Reply to lousuan">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-19775">
	<img alt="image placeholder" >
		<cite class="fn"><a href="http://www.qubian.cn/" rel="external nofollow" class="url">松田导航</a></cite>			
		<p>这样的论证也太神奇咯</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19775">
			2013年6月2日 00:57</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19775#respond" onclick='return addComment.moveForm( "div-comment-19775", "19775", "respond", "5293" )' aria-label="Reply to 松田导航">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-19776">
	<img alt="image placeholder" >
		<cite class="fn">奔奔</cite>			
		<p>好题，巧妙地利用了两个距离相等的平行线的夹角相等。</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19776">
			2013年6月4日 11:41</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19776#respond" onclick='return addComment.moveForm( "div-comment-19776", "19776", "respond", "5293" )' aria-label="Reply to 奔奔">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-19777">
	<img alt="image placeholder" >
		<cite class="fn"><a href="http://blog.163.com/hasen_lee/" rel="external nofollow" class="url">Hasen_Lee</a></cite>			
		<p>漂亮。</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19777">
			2013年6月6日 19:17</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19777#respond" onclick='return addComment.moveForm( "div-comment-19777", "19777", "respond", "5293" )' aria-label="Reply to Hasen_Lee">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-19778">
	<img alt="image placeholder" >
		<cite class="fn">hualex</cite>			
		<p>真神奇</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19778">
			2013年6月12日 18:01</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19778#respond" onclick='return addComment.moveForm( "div-comment-19778", "19778", "respond", "5293" )' aria-label="Reply to hualex">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-19779">
	<img alt="image placeholder" >
		<cite class="fn">dingdd</cite>			
		<p>顾大神，我想问个问题，你的图形都是用什么画出来的</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19779">
			2013年7月10日 13:29</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19779#respond" onclick='return addComment.moveForm( "div-comment-19779", "19779", "respond", "5293" )' aria-label="Reply to dingdd">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-19780">
	<img alt="image placeholder" >
		<cite class="fn">cr</cite>			
		<p>哪有什么神奇的，正方形只是个幌子，其实中间的交叉线的任何一根，都其实只是由两组间距为d的平行线所决定，而两组间距相等的平行线组成的图形其实就是个菱形，对角线当然平分该角。</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19780">
			2013年7月24日 03:04</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19780#respond" onclick='return addComment.moveForm( "div-comment-19780", "19780", "respond", "5293" )' aria-label="Reply to cr">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-19781">
	<img alt="image placeholder" >
		<cite class="fn">cr</cite>			
		<p>更一般点，就是3组间距为d的平行线A,B,C，AB和AC所确定的交叉线夹角为α，BC的夹角为β，那么α和β满足：2α+β=180.</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19781">
			2013年7月24日 03:09</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19781#respond" onclick='return addComment.moveForm( "div-comment-19781", "19781", "respond", "5293" )' aria-label="Reply to cr">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-19782">
	<img alt="image placeholder" >
		<cite class="fn">cr</cite>			
		<p>如上，此题中α=45，β=90</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19782">
			2013年7月24日 03:11</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19782#respond" onclick='return addComment.moveForm( "div-comment-19782", "19782", "respond", "5293" )' aria-label="Reply to cr">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-19783">
	<img alt="image placeholder" >
		<cite class="fn">二货刺客</cite>			
		<p>其实第二个图不用证全等，角度转换就行了，直线180°</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-19783">
			2014年2月10日 17:56</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=19783#respond" onclick='return addComment.moveForm( "div-comment-19783", "19783", "respond", "5293" )' aria-label="Reply to 二货刺客">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-594146">
	<img alt="image placeholder" >
		<cite class="fn">infloop</cite>			
		<p>这个也还好吧，没什么神奇的。两个等距离的平行线中间形成了一个菱形。那条线刚好是菱形的对角线。</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-594146">
			2014年12月30日 15:21</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=594146#respond" onclick='return addComment.moveForm( "div-comment-594146", "594146", "respond", "5293" )' aria-label="Reply to infloop">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="comment-851107">
	<img alt="image placeholder" >
		<cite class="fn">Leo He</cite>			
		<p>巧妙</p>
	
		<div class="comment-meta commentmetadata">
<a href="http://www.matrix67.com/blog/archives/5293#comment-851107">
			2015年6月4日 20:25</a>
			 / <a rel="nofollow" class="comment-reply-link" href="http://www.matrix67.com/blog/archives/5293?replytocom=851107#respond" onclick='return addComment.moveForm( "div-comment-851107", "851107", "respond", "5293" )' aria-label="Reply to Leo He">回复</a>		</div>
	</div>
</li>
<!-- #comment-## -->
		</ul>
<!-- .comment-list -->

		
	
	
					<div id="respond" class="comment-respond">
			<h3 id="reply-title" class="comment-reply-title">发表评论 <small><a rel="nofollow" id="cancel-comment-reply-link" href="/blog/archives/5293#respond" style="display:none;">取消回复</a></small>
</h3>				<form action="http://www.matrix67.com/blog/wp-comments-post.php" method="post" id="commentform" class="comment-form">
					<div class="comment-form-comment">
<label for="comment">评论</label><div><textarea id="comment" name="comment" cols="45" rows="8" aria-required="true"></textarea></div>
</div>
<div class="comment-form-author">
<label for="author" class="ir">昵称<span class="required">*</span></label><input id="author" name="author" type="text" value="" size="30">
</div>
<div class="comment-form-email">
<label for="email" class="ir">邮箱<span class="required">*</span></label><input id="email" name="email" type="text" value="" size="30">
</div>
<div class="comment-form-url">
<label for="url" class="ir">网站</label><input id="url" name="url" type="text" value="" size="30">
</div>
<p class="form-submit"><input name="submit" type="submit" id="submit_comment" class="submit" value="提交"> <input type="hidden" name="comment_post_ID" value="5293" id="comment_post_ID">
<input type="hidden" name="comment_parent" id="comment_parent" value="0">
</p>
<p style="display: none;"><input type="hidden" id="akismet_comment_nonce" name="akismet_comment_nonce" value="1827efb347"></p>
<p style="display: none;"><input type="hidden" id="ak_js" name="ak_js" value="162"></p>				</form>
					</div>
<!-- #respond -->
		
</div>
<!-- #comments -->

		
		<!-- #main -->
	 ]]></content>
<pubDate>2013-05-24T22:48:50+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5293</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：一个n位数平均有多少个单调区间？ ]]></title>
<link>http://www.matrix67.com/blog/archives/5296</link>
<content><![CDATA[ 
		<p>    考虑这么一个 14 位数 02565413989732 ，如图所示，它的数字先逐渐变大，然后开始变小，再变大，再变小，再变大，再变小。我们就说，它一共包含了 6 个单调区间。我们的问题就是：一个 n 位数平均有多少个单调区间？为了避免歧义，我们假设任意两位相邻的数字都不相同，因而像 77765589911 这样的数我们就不考虑了。另外，大家可能已经注意到了，我们允许这个 n 位数以数字 0 开头。因而，更精确地说，我们的问题是：相邻数字都不相同的、允许以 0 开头的所有 n 位数当中，平均有多少个单调区间？</p>
<p>      <img alt="image placeholder" >
<p>    这个题目来自 1987 年 IMO 候选题。</p>
<p><span id="more-5296"></span><br>
 </p>
<p>    让我们把所有这种 n 位数的个数记作 N 。那么 N 等于多少？这个 n 位数的第一位有 10 种选择，今后的每一位都只有 9 种选择（因为要跟前一位不一样），因而 n 位数一共有 N = 10 · 9<sup>n-1</sup> 个。接下来，我们要求的就是，所有 n 位数当中的所有单调区间一共有多少个。我们换一种方法来累计这些单调区间：先算所有从第一位开始的单调区间，再算所有从第二位开始的单调区间，等等，最后算所有从第 n 位开始的单调区间。如果用 r<sub>i</sub> 来表示所有从第 i 位开始的单调区间的数目，那么我们要求的平均单调区间数就是 (r<sub>1</sub> + r<sub>2</sub> + … + r<sub>n</sub>) / N ，也就是 r<sub>1</sub> / N + r<sub>2</sub> / N + … + r<sub>n</sub> / N 。注意到其中的每一项 r<sub>i</sub> / N 其实就是从 N 个合法的 n 位数中任取一个后，存在以第 i 位数打头的单调区间的概率。因此，我们只需要求出这 n 个概率值，加起来便是我们想要的答案了。</p>
<p>    显然， r<sub>1</sub> / N = 1 ，因为第一位数字必然会引领一个单调区间。显然， r<sub>n</sub> / N = 0 ，因为最后一位数字不可能引领一个新的单调区间。那么，对于其他的 r<sub>i</sub> / N 呢？注意到，第 i – 1 位、第 i 位和第 i + 1 位的大小关系一共可能有以下四种情况：</p>
<p>      <img alt="image placeholder" >
<p>    其中，只有第三种情况和第四种情况下，第 i 位才会成为一个新的单调区间的开始。为了计算这两种情况发生的概率，我们只需要算出情况 1 和情况 2 发生的概率，再用 1 来减即可。情况 1 发生的概率有多大呢？三位数字串一共有 10 · 9<sup>2</sup> 个（第一位有 10 种选择，后面的每一位都只有 9 种选择，因为要跟前一位不一样）。为了得到递增的数字串，我们只需要选出三个不同的数字，然后把它们从小到大排列即可，这一共有 C(10, 3) 种方法。因此，情况 1 的发生概率就是 C(10, 3) / (10 · 9<sup>2</sup>) = 4/27 。同理，情况 2 的发生概率也是 4/27 ，两者加起来就是 8/27 ；反过来，情况 3 和情况 4 出现的概率就是 1 – 8/27 = 19/27 了。</p>
<p>    因此，我们最终要求的答案就是 1 + 19/27 + 19/27 + … + 19/27 + 0 = 1 + (n – 2) · 19/27 。</p>
<p> <br>
    这个结论还会引出很多有意思的问题。在一个 29 位数当中，平均会产生 20 个单调区间。我们似乎发现了一个很不合理的地方：这岂不意味着，平均每个单调区间的长度只有 29/20 = 1.45 个数字吗？考虑到单调区间的长度不可能恰好是 1.45 个数字，为了得到 1.45 这个平均长度，一定有些区间的长度比 1.45 小，有些区间的长度比 1.45 大。有些区间的长度比 1.45 小，这不就意味着这些区间的长度为 1 吗？而一个区间的长度显然是不可能为 1 的。怎么回事？</p>
<p>    其实， 29/20 = 1.45 这个算式是错的。在这 20 个单调区间中，除了最后一个区间以外，每一个区间的最后一个数与下一个区间的第一个数都是公共的。因此，这个 29 位数当中，有 19 个数被重复使用了。所以，在一个 29 位数当中，单调区间的平均长度应该是 (29 + 19) / 20 = 2.4 。</p>
<p>    类似的， n 位数的单调区间的平均长度为 (n + (19/27)(n – 2)) / (1 + (19/27)(n – 2)) = (46n – 38) / (19n – 11) = (46 – 38/n) / (19 – 11/n) 。当 n 无穷大时，其极限为 46/19 。</p>
<p> <br>
参考资料：Ross Honsberger, From Erdos to Kiev: Problems of Olympiad Caliber, pp. 29-33</p>
			 ]]></content>
<pubDate>2013-05-24T23:11:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5296</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
</channel>
</rss>
