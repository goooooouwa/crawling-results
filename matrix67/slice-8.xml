<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Matrix67: The Aha Moments</title>
<description></description>
<link>http://www.matrix67.com/blog</link>
<pubDate>2021-11-20T14:45:25+08:00</pubDate>
<!-- other elements omitted from this example -->
<item>
<title><![CDATA[ 趣题：同时等分三角形周长和面积的直线 ]]></title>
<link>http://www.matrix67.com/blog/archives/5313</link>
<content><![CDATA[ 
		<p>    求证：对于任意一个三角形，一定存在一条直线，它把这个三角形的周长和面积同时分成了两等分。</p>
<p> <br>
 <br>
    大家知道，三角形的三个内角的角平分线一定交于一点，这个点就是三角形的内心，它到三角形三边的距离是相等的。一个令人吃惊的结论是，经过内心的直线如果平分了三角形的面积，就一定平分了三角形的周长！</p>
<p>      <img alt="image placeholder" >
<p>    如图， I 是三角形 ABC 的内心， ID 、 IE 、 IF 是 I 到三角形三边的垂线段，它们的长度是相等的，不妨把这个长度值记作 r 。假设直线 PQ 经过点 I ，并且平分三角形的面积。这说明， PA · r / 2 + AQ · r / 2 = PB · r / 2 + BC · r / 2 + CQ · r / 2 ，也就是 PA + AQ = PB + BC + CQ 。因此，直线 PQ 也平分了三角形 ABC 的周长。</p>
<p><span id="more-5313"></span><br>
      <img alt="image placeholder" >
<p>    如果对于任意一个三角形，都存在一条经过内心并且平分面积的直线的话，我们的问题就解决了。事实上，对于任意一个三角形，以及三角形内的任意一个定点，都存在一条经过该点并且平分面积的直线的。这很容易看出来。首先，过该定点随便作一条直线。如果这条直线正好平分了三角形的面积，问题就直接解决了。否则，将这条直线绕着定点旋转 180 度，你会发现它回到了原来的位置，但是直线左侧的面积和直线右侧的面积却颠倒了过来。这意味着，假设最开始的时候，直线左侧的面积小于整个三角形面积的1/2，转完之后，直线左侧的面积就将大于整个三角形面积的1/2；反过来，假设最开始的时候，直线左侧的面积大于整个三角形面积的1/2，转完之后，直线左侧的面积就将小于整个三角形面积的1/2。然而，在旋转过程中，直线左侧的面积始终在发生连续的变化，因此必然有一刻，直线左侧的面积正好等于三角形面积的1/2。这就是一条平分三角形面积的直线。根据前面的结论，它也就同时平分了周长。</p>
<p> <br>
    我们不妨把一个三角形中，既平分周长又平分面积的直线叫做“均分线”。有的读者或许会很快发现，在一个三角形中，这样的均分线很可能不止一条。如下图，假如 PQ 是一条均分线，那么把 PQ 沿着图中所示的角平分线翻折到 P’Q’ ，容易证明三角形 PIQ’ 和 P’IQ 是全等的，于是线段 PQ’ 和线段 P’Q 的长度相等，并且两个三角形的面积相等。因此，原来 AP + AQ 是三角形周长的一半，现在 AP’ + AQ’ 仍然是三角形周长的一半；原来三角形 APQ 的面积是整个三角形面积的一半，现在三角形 AP’Q’ 的面积仍然是整个三角形面积的一半。可见， P’Q’ 也将是一条均分线。因此，这个三角形至少有两条均分线。</p>
<p>      <img alt="image placeholder" >
<p>    对于一些更特殊的三角形来说，均分线可能还会更多，例如在一个等边三角形当中，均分线至少有三条（它们也就是等边三角形的三条对称轴）。1997 年， George Berzsenyi 曾经猜想，一个三角形最多只能有三条均分线。这个猜想是正确的吗？ 2010 年 4 月， Dimitrios Kodokostas 在 Mathematics Magazine 上发表了一篇题为 Triangle Equalizers 文章，完美地解答了这个问题。</p>
<p> <br>
    刚才我们证明了，经过内心的直线如果平分了三角形的面积，就一定平分了三角形的周长。根据同样的道理，经过内心的直线如果平分了三角形的周长，就一定平分了三角形的面积。事实上，我们可以证明，三角形的均分线是一定经过内心的。假如下图中的直线 PQ 是一条不过 I 点的均分线，由于 BP + BQ 等于三角形周长的一半，因而三角形 BPI 的面积加上三角形 BQI 的面积就是整个三角形面积的一半，这与三角形 BPQ 的面积是一样的，可见 I 一定在直线 PQ 上。</p>
<p>      <img alt="image placeholder" >
<p>    因此，为了计算均分线的数目，我们只需要考虑过内心的直线就行了。受到前面“旋转法”的启发，我们尝试着去确定，在直线绕着内心旋转的过程中，直线两侧的面积究竟将会经历怎样的起伏变化？</p>
<p>      <img alt="image placeholder" >
<p>    除了三处例外点以外，这条直线通常会把整个三角形分成一个小三角形和一个四边形。一个非常有用的结论是，若这条直线与任意一条角平分线垂直时，小三角形的面积会达到极小值，四边形部分的面积会达到极大值。为什么呢？看上面这个图，假设 AD 是三角形的一条角平分线， PQ 垂直于 AD 。如果把 PQ 旋转到 XY 的位置，三角形 APQ 就变成了三角形 AXY ，下面我们来说明，这样变了之后，面积一定变大了。过点 P 作 AC 的平行线，与 XY 交于点 Z 。容易证明，图中的两个红色三角形全等，因此三角形 AXY 的面积比三角形 APQ 的面积更多，多了图中蓝色三角形那么大的面积。事实上，蓝色三角形的面积为 (1/2) · PX · PZ · sin∠XPZ = (1/2) · PX · YQ · sin∠BAC ，随着直线的继续转动，这是会不断增加的。当然，如果让 PQ 逆时针旋转，结果也是一样的：与 A 点构成的三角形面积会单调递增，与 B 、 C 两点构成的四边形面积则会单调递减。</p>
<p>      <img alt="image placeholder" >
<p>    因此，在直线绕着内心 I 旋转 180 度的过程中，一共会经过上图所示的六个关键节点：三条角平分线（红色表示），以及三条与角平分线垂直的线（蓝色表示）。假设直线从 X<sub>1</sub>Y<sub>1</sub> 出发，按照 X<sub>1</sub>Y<sub>1</sub> → BE → X<sub>2</sub>Y<sub>2</sub> → DA → X<sub>3</sub>Y<sub>3</sub> → CF → Y<sub>1</sub>X<sub>1</sub> 的顺序旋转 180 度。如果我们把刚开始直线的上方叫做它的左侧，那么在旋转的过程中，左侧的面积会怎么变化？刚开始的时候，直线左侧的面积是图中黄色部分的面积。从 X<sub>1</sub>Y<sub>1</sub> 到 BE ，直线左侧的面积不断增大；从 BE 到 X<sub>2</sub>Y<sub>2</sub> ，直线左侧的面积继续增大，并且达到极大值；从 X<sub>2</sub>Y<sub>2</sub> 到 DA ，直线左侧的面积开始缩小；从 DA 到 X<sub>3</sub>Y<sub>3</sub> ，直线左侧的面积继续缩小，并且达到极小值；接下来，直线左侧的面积又重新开始变大，最后变成图中的绿色面积。</p>
<p>    因此，一个典型的面积变化曲线如下图所示，其中横轴表示直线旋转过的度数，纵轴表示直线左侧面积占整个三角形面积的比例。由于这条曲线只有三个单调区间，因此这条曲线与 y = 1/2 最多只有三个交点。换句话说，最多只有三个时刻，直线左侧的面积等于整个三角形面积的一半。这说明，三角形的均分线最多只有三条。 Berzsenyi 的猜想是正确的。</p>
<p>      <img alt="image placeholder" >
<p>    前面我们已经说过，事实上，三角形的均分线确实是有可能达到三条的，等边三角形就是最简单的例子。那么，是否每个三角形都有三条均分线呢？不见得。有些三角形就只有两条均分线。如果刚开始的时候，直线左侧的面积恰好是 1/2 ，那么面积变化曲线将会从 1/2 开始，上升，下降，再回到 1/2 。于是，整条曲线和 y = 1/2 只有两个交点，三角形就只有两条均分线了。</p>
<p>        <img alt="image placeholder" >
<p>    为了给出一个确凿的例子，我们需要找出一个满足要求的三角形。比方说上图中的等腰三角形，如果三角形 APQ 和三角形 ABC 的相似比是 1 : √<span style="text-decoration:overline">2</span> ，那么刚开始直线左侧的面积就是 1/2 了。这要求 AI : AD = 1 : √<span style="text-decoration:overline">2</span> ，即 AI : ID = 1 : (√<span style="text-decoration:overline">2</span> – 1) ，即 AI : IE = 1 : (√<span style="text-decoration:overline">2</span> – 1) 。此时， ∠IAE = arcsin(√<span style="text-decoration:overline">2</span> – 1) ，三角形 ABC 中的 ∠A 则是 2 arcsin(√<span style="text-decoration:overline">2</span> – 1) 。根据前面的讨论，这个三角形就只有两条均分线。</p>
<p>    现在，保持 AB = AC 不变，继续缩小 ∠A 的度数，此时 ∠IAE 的正弦值会进一步缩小，从而让 AI 与 IE 之比（也就是 AI 与 ID 之比）进一步扩大，其结果就是，三角形 APQ 的面积大于整个三角形面积的 1/2 。这样的话，面积变化曲线将会从某个大于 1/2 的值出发，上升后再下降，最后再上升到一个小于 1/2 的、与初始值对称的位置。这条曲线将会仅与 y = 1/2 相交一次，因而三角形就只有一条均分线了。</p>
<p>    最终，我们得到了一个完整的结论：一个三角形里至少有一条均分线，最多有三条均分线，并且实际数目有可能是 1 条、 2 条或者 3 条中的任意一个。<br>
 </p>
<p>Dimitrios Kodokostas 还细致地讨论了三角形的均分线数量的判别条件，有兴趣的朋友可以查阅一下。如何用尺规作图作出三角形的均分线，这也是一个很有挑战性的问题。对这个问题感兴趣的读者可以看看这里： <a href="http://goo.gl/ZOpQH">http://goo.gl/ZOpQH</a> 。</p>
			 ]]></content>
<pubDate>2013-06-03T07:25:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5313</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：斜边上的动点 ]]></title>
<link>http://www.matrix67.com/blog/archives/5321</link>
<content><![CDATA[ 
		<p>      <img alt="image placeholder" >
<p>    这是一个非常经典的问题。如图，三角形 ABC 是一个直角三角形， ∠A = 90° 。 D 是斜边 BC 上的一个动点。过点 D 作 AB 和 AC 的垂线，垂足分别为 E 和 F 。问题：当 D 点运动到什么位置的时候，线段 EF 最短？</p>
<p><span id="more-5321"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>      <img alt="image placeholder" >
<p>    答案出人意料地简单：当 AD 垂直于 BC 时，线段 EF 最短。这是因为，四边形 AEDF 永远是一个矩形，它的两条对角线永远一样长。因此，为了让 EF 最短，我们只需要让 AD 最短即可。什么时候 AD 最短呢？显然，当 AD 垂直于 BC 时， AD 达到最短。</p>
<p> <br>
 <br>
      <img alt="image placeholder" >
<p>    下面是一个稍微有些挑战性的问题：如果去掉 ∠A = 90° 这个条件，其他条件都不变，那么这一次， D 点应该运动到什么地方，才能让 EF 最短呢？</p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>      <img alt="image placeholder" >
<p>    答案仍然是，当 AD 垂直于 BC 时 EF 最短，不过原因不太一样。注意到，由于 ∠AED = ∠AFD = 90° ，因此 A 、 E 、 D 、 F 四点共圆。在这个圆中， EF 所对的圆周角 ∠A 始终不变。因此，为了让线段 EF 达到最短，我们需要让整个圆越小越好，换句话说这个圆的直径越短越好（这也可以由正弦定理 EF / sinA = 2R 迅速看出）。但是， AD 就是这个圆的一条直径啊！因此，我们需要让 AD 越短越好。什么时候 AD 最短呢？显然，当 AD 垂直于 BC 时， AD 达到最短。</p>
<p>    后面这个问题来自 1987 年 IMO 候选题。</p>
<p>参考资料：Ross Honsberger, From Erdos to Kiev: Problems of Olympiad Caliber, pp. 43-45</p>
			 ]]></content>
<pubDate>2013-06-19T19:40:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5321</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ UyHiP趣题：用最少的称重次数验证硬币的重量 ]]></title>
<link>http://www.matrix67.com/blog/archives/5330</link>
<content><![CDATA[ 
		<p>    这是一个非常有趣的问题，它出自 <a href="http://www.brand.site.co.il/riddles/201305q.html">UyHiP May 2013</a> 的谜题。</p>
<p>    假设你有 n 枚外观完全相同的硬币，它们的重量分别为 1g, 2g, 3g, …, ng 。有意思的是，这一次，你已经知道了各枚硬币的重量，而且你也已经把重量值标在了这些硬币上。但是，由于我不知道各枚硬币的重量，因此我希望你能向我证明，你所标的重量值是正确的（我知道这些硬币的重量是从 1 克到 n 克，我只是不知道哪个硬币对应哪个重量）。</p>
<p>    你唯一能用的工具就是一架天平。每一次，你可以任意选择一枚或多枚硬币，放在天平的左侧，再从剩下的硬币中任意选择一枚或多枚硬币，放在天平的右侧（注意，你只能在天平上放硬币，不能放别的东西）。一个有意思的问题是，为了向我证明你所标的重量值都是对的，你最少需要使用多少次天平？</p>
<p>    显然，为了证明 n 枚硬币的重量标签的正确性，我们最多需要称 n – 1 次。先把硬币 1 放在左边，把硬币 2 放在右边，让对方看到硬币 1 确实比硬币 2 要轻。接下来，向对方验证硬币 2 确实比硬币 3 更轻，硬币 3 确实比硬币 4 更轻，等等。称完 n – 1 次后，我们就相当于给出了 n 枚硬币的轻重顺序，因而它们只有可能分别是 1 克 、 2 克 、 3 克……。</p>
<p>    我们还能做得更好吗？不妨让我们看看 n 比较小的情况。例如，当 n = 4 的时候，利用上述方法可以 3 次完成验证，那么只用 2 次可以完成验证吗？仔细一想，你会发现真的可以！其中一种方法就是，先把硬币 1 和硬币 2 放在左边，把硬币 4 放在右边。由于两枚硬币的重量之和小于第三枚硬币，这只可能是 1 + 2 &lt; 4 ，因此对方会相信，左边两枚硬币分别是 1 和 2 ，右边那枚硬币是 4 ，没放上去的那枚硬币是 3 。对方唯一不知道的就是，在左边两枚硬币中，究竟谁是 1 ，谁是 2 。于是，我们只需要再称一下硬币 1 和硬币 2 ，问题就解决了。</p>
<p>    不妨把证明 n 枚硬币重量标签的正确性最少需要的称重次数记作 B(n) 。我们的问题就是：判断 B(n) 是以什么级别增长的。</p>
<p><span id="more-5330"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    答案： B(n) 是以 Θ(log n) 的级别增长的。证明它的下界并不困难。每次称重的时候，一枚硬币要么被放在了左侧，要么被放在了右侧，要么压根儿就没上天平。因而，在 k 次称量当中，一枚硬币的“全程安排”将会有 3<sup>k</sup> 种不同的可能性。如果 n &gt; 3<sup>k</sup> ，这就意味着至少会有两枚硬币，它们全程都在一起，每次称重时要么都去左边了，要么都去右边了，要么都没上天平，因而我们就无法区分出谁是谁了。所以说，硬币数 n 必须小于等于 3<sup>k</sup> ，反过来称重次数 k 也就必须大于等于 log<sub>3</sub>n 了。</p>
<p>    比较麻烦的就是，我们要想出一种在 O(log n) 步验证硬币重量的算法。我们首先从验证下面的硬币关系开始：</p>
<blockquote><p>1 &lt; 2<br>
1 + 2 = 3<br>
1 + 2 + 3 = 6<br>
1 + 2 + 3 + 6 = 12<br>
……</p></blockquote>
<p>    不断这样做下去，直到没有这么重的硬币了为止。那么，对方看到了这一系列称量，他会得到些什么结论？他会发现，不管硬币的标称重量是否正确，硬币 6 的实际重量都是硬币 3 的实际重量的两倍，硬币 12 的实际重量也一定是硬币 6 的实际重量的两倍，等等。因而，如果硬币 1 和硬币 2 是正确的，那么硬币 3 也是正确的，接下来所有的硬币都是正确的了；如果硬币 1 或者硬币 2 标称有误，那么硬币 3 就会比标称的更重，于是后面的所有硬币都会比标称的更重。</p>
<p>    假设我们刚才用到的最后一枚硬币是 3 · 2<sup>k</sup> 。如果 3 · 2<sup>k</sup> 恰好等于 n ，那么对方就知道了，硬币 1 和硬币 2 是正确的，否则最后这枚硬币的实际重量就会比 n 还大，而这是不可能的。既然硬币 1 和硬币 2 是正确的了，那么刚才用到的所有硬币都是正确的了。</p>
<p>    如果 3 · 2<sup>k</sup> ≠ n 呢？那么，我们就从刚才用过的所有硬币中选出一些硬币来，让它们的重量之和正好等于 n 。这是总可以做到的。用所有不超过 3 · 2<sup>k</sup> 的形如 3 · 2<sup>i</sup> 的数，可以拼出 3 · 2<sup>k+1</sup> 以内的所有 3 的倍数，再加上 1 和 2 ，我们就可以拼出 3 · 2<sup>k+1</sup> 以内的所有正整数了。同时注意到， n 一定在这个范围以内，不然的话我们就有 3 · 2<sup>k+1</sup> ≤ n ，那刚才 3 · 2<sup>k</sup> 就不会是最后一枚硬币了。把选出来的这些硬币放到天平左边，把硬币 n 放到天平右边，让对方看到此时天平平衡。那么，对方就知道了，硬币 1 和硬币 2 是正确的，否则天平左边的那些硬币都会比标称的更重，从而让天平左边的实际总重量大于 n ，只在右边放一枚硬币是没法让天平平衡起来的。既然硬币 1 和硬币 2 是正确的了，那么刚才用到的所有硬币都是正确的了。</p>
<p>    无论怎样，我们都用 O(log n) 次称量，证明了 1, 2, 3, 6, 12, …, 3 · 2<sup>k</sup> 这些硬币的重量。我们把这些硬币叫做辅助币。接下来，我们将利用这些辅助币，用额外的 O(log n) 次称量证明其他所有硬币的重量。</p>
<p> <br>
    首先，把辅助币从这 n 枚硬币中拿出来。将剩下的硬币从轻到重排成一行，然后把它们分成连续的三段，得到三组硬币。我们需要尽可能保证，三组硬币各自的重量和尽可能一样。如果拿走辅助币之后，剩下的硬币依次是 4, 5, 7, 8, 9, 10, 11, 13, 14, 15 ，那么我会把 4, 5, 7, 8, 9 分成一组， 10, 11, 13 分成一组， 14, 15 分成一组，这三组的重量和分别为 33 、 34 和 29 。现在，把第一组放在天平左边，把第三组放在天平右边，再选出一些总重为 4 克的辅助币（别忘了，用辅助币可以拼出任意不超过 n 的正整数），放在天平的右边，使得天平平衡。于是，对方将会看到，第一组的 5 枚硬币只比第三组的 2 枚硬币重 4 克。他会立即发现，这个 4 克的差值卡得很死。事实上，第一组一定是最轻的 5 枚硬币，第三组一定是最重的 2 枚硬币，只有这样才能实现第一组只比第三组重 4 克。于是，对方就知道了，这三组硬币依次是最轻的 5 枚硬币、中间的 3 枚硬币和最重的 2 枚硬币。他将会知道每一组硬币具体都包含了哪些重量值。</p>
<p>    接下来，我们把每一组硬币继续分成三个小组，在分组时总是遵循下面的原则：第一小组总是最轻的几枚硬币，第三小组总是最重的几枚硬币，同时各个小组的硬币总重尽可能地接近。这里，我们选择把 4, 5, 7, 8, 9 分成 4, 5 | 7, 8 | 9 ，把 10, 11, 13 分成 10 | 11 | 13 ，把 14, 15 分成 14 | | 15 （我们允许某个小组为空）。然后，把每组硬币的第一小组都放到天平左边去，把每组硬币的第三小组都放到天平右边去，再借助辅助币让天平平衡。在我们的例子中， 4, 5, 10, 14 就被放到了左边， 9, 13, 15 就被放到了右边，此时左边比右边轻 4 克，于是在左边放总重 4 克的辅助币，使得天平平衡。对方能够看到，在每一组硬币中，有多少被放到了左边去，有多少被放到了右边去。和上次一样，他将会发现，左边比右边轻 4 克，这个差距是紧的，只能把每一组中最轻的硬币放到左边，把每一组中最重的硬币放到右边，左边才会比右边足足轻 4 克。这样，他就知道了每一组的每一小组硬币都含有哪一段重量值。</p>
<p>    接下来，我们不断地把目前得到的每一组硬币都继续细分成三个小组，同时利用刚才所说的方法向对方证明，每组硬币都被从小到大地分成了连续的三个小组，从而让对方得知每个小组所对应的重量值区间。如果某一组只剩一枚硬币了，对方就可以精确地知道这枚硬币的重量，此时便可以把它从这些硬币中移除了。</p>
<p>    我们在分组时，为什么要保证各小组的硬币总重尽可能接近呢？这是因为，当我们把每一组硬币中的第一小组放到天平左边，同时把每一组硬币中的第三小组放到天平右边后，我们希望天平两边的重量之差不超过 n ，这样我们才能借助辅助币让两边平衡。不过，由于我们在分组时不可能完全均分重量，因而难免出现重量之差仍然大于 n 的情况。此时，我们总可以对其中一些分组进行常数级别的微调（比如把第三小组中最轻的硬币划给第二小组，或者把第二小组中最重的硬币划给第三小组），从而把天平两边的重量之差缩小到 n 克以内。</p>
<p>    在任意时刻，任意一组硬币中的重量值总是一段线性增加的（基本上可以说是连续的）序列，因而把它们从小到大累加起来，其结果是平方级别增长的。因此，在对它进行分组时，从渐近意义上说，第一小组的硬币数量最多不超过该组硬币数量的 √<span style="text-decoration:overline">1/3</span> = 0.577… ，第三小组的硬币数量不会少于该组硬币数量的 1 – √<span style="text-decoration:overline">2/3</span> = 0.1835… 。可见，在检验硬币重量的过程中，各组硬币的数量呈指数级递减，这表明我们所需要的称重次数不超过 O(log n) 。</p>
<p> <br>
 <br>
 <br>
 </p>
<p>    数列 B(n) 有一个非常有趣的名字，叫做 Baron Münchhausen’s Omni-数列。</p>
<p>    Baron Münchhausen 是 18 世纪德国的一位著名的“吹牛大王”。他参军回家后，向人们讲述了很多“传奇经历”，比如他骑马陷入沼泽地后，抓着自己的头发，把自己连人带马从沼泽里拔了起来。 2000 年， Baron Münchhausen 的名字出现在了俄罗斯全国奥林匹克数学竞赛的分区赛中：</p>
<blockquote><p>8 枚硬币的重量分别是 1g, 2g, …, 8g ，但我们不知道哪枚硬币对应于哪个重量。 Baron Münchhausen 宣称他知道每一枚硬币的重量，而且他还说，只需要用天平称一次，他便能向众人验证出，至少有一枚硬币的重量正如他所言。这真的有可能，还是他又在说大话？</p></blockquote>
<p>    问题的答案是，这是有可能的。 Baron Münchhausen 可以把最轻的 5 枚硬币放在天平左边，把最重的 2 枚硬币放在天平右边，于是天平平衡。 5 枚硬币的总重和 2 枚硬币的总重相同，只有可能是 1 + 2 + 3 + 4 + 5 = 7 + 8 ，这就证明了没放上天平的那枚硬币确实是 6 克。</p>
<p>    后来， Tanya Khovanova 、 Konstantin Knop 和 Alexey Radul 合写了一篇论文，对这个问题进行了扩展：验证 n 枚硬币中至少一枚硬币的重量，最少需要使用多少次天平？他们把该问题的答案形成的数列叫做 Baron Münchhausen 数列，用 A(n) 来表示。他们利用很多与三角形数有关的性质，证明了一个非常令人吃惊的结论： A(n) 总是小于等于 2 的。并且，我们还能精确地知道，在哪些情况下 A(n) = 1 ：若 n 是一个三角形数，或者 n 等于某个三角形数加 1 ，或者第 n 个三角形数是一个平方数，或者第 n 个三角形数等于某个平方数加 1 ，则 A(n) = 1 。其他情况下， A(n) 都等于 2 。</p>
<p>    但是，如果我们要求用最少的称量次数检验出<strong>所有</strong>硬币的重量呢？于是，我们就把这个加强版问题的答案形成的数列叫做 Baron Münchhausen’s Omni-数列，这就是数列 B(n) 名字的由来。</p>
<p>    有意思的是，真要追溯起来，数列 B(n) 似乎比数列 A(n) 出现得更早。在 1991 年莫斯科奥林匹克数学竞赛中， Sergey Tokarev 提出了下面这个问题：</p>
<blockquote><p>有 6 枚硬币，它们的重量分别为 1 克、 2 克、 3 克、 4 克、 5 克、 6 克。它们看上去完全相同，只是上面的标签不一样。每一枚硬币上都标有 {1, 2, 3, 4, 5, 6} 中的一个数，它代表这枚硬币的重量。只用两次天平，如何判断出这些标签是否都是正确的？</p></blockquote>
<p>    其中一种可能的答案是，首先检验 1 + 2 + 3 = 6 ，然后检验 1 + 6 &lt; 3 + 5 。另一种方案则是检验 1 + 2 + 5 &lt; 3 + 6 和 1 + 3 &lt; 5 。两种方法都可以把 6 枚硬币的实际重量确定下来。另外，根据前面的论断，只用一次天平是无法把 6 枚硬币都区分开的，因此 B(6) 精确地等于 2 。这恐怕是序列 B(n) 在历史上的第一次出镜了。</p>
<p>    有趣的是，虽然我们已经成功破解了 A(n) ，但却始终没有揭开 B(n) 的面纱。目前，人们已经求出了数列 B(n) 的开头几项：</p>
<blockquote><p>0, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, …</p></blockquote>
<p>    UyHiP 是我非常喜欢的一个每月谜题活动，它的 puzzlemaster 是 Michael Brand 。 Michael Brand 本人对数列 B(n) 非常感兴趣，他已经发表了好几篇论文，在渐近意义上证明了一些与数列 B(n) 有关的性质。但是，正如刚才所说，我们对 B(n) 的了解仍然少得可怜；我们甚至还不知道， B(n) 是否是单调递增的。并且，在 Michael Brand 看来，这个硬币问题还只是“一整类尚未被探索过的数学问题中的冰山一角”。感兴趣的读者不妨做一些小小的研究，或许会有意想不到的发现。</p>
<p> </p>
			 ]]></content>
<pubDate>2013-06-19T21:36:08+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5330</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 通信复杂度问题：确定双方手中所有数的中位数 ]]></title>
<link>http://www.matrix67.com/blog/archives/5342</link>
<content><![CDATA[ 
		<p>    通信复杂度（communication complexity）主要研究这么一类问题： A 持有数据 x ， B 持有数据 y ，他们想要合作计算某个关于 x 和 y 的二元函数值 f(x, y) ，那么在渐近意义下，两人至少需要传输多少 bit 的数据。最近着迷于通信复杂度，看到了几个与通信复杂度有关的问题，和大家分享一下。下面就是其中之一。</p>
<p>    A 、 B 的手中各有一个 {1, 2, …, n} 的子集。两人想知道，如果把他们手中的数全都放在一块儿，那么这些数（可能会有重复的数）的中位数是多少。然而， A 、 B 两人远隔千里，他们之间通信的成本非常高。因此，他们想在通信线路上传输尽可能少的信息，使得最终两人都知道中位数的值。在这里，为了简便起见，我们直接定义 m 个数的中位数是第 ⌈ m / 2 ⌉ 小的数，因而如果 m = 2k ，那么中位数就应该直接取第 k 小的数。</p>
<p>    其中一种最笨的方法是， A 把手中的所有数全部发给 B 。由于发送一个不超过 n 的正整数最多会用到 log(n) 个 bit ，而 A 手里的数最多有 O(n) 个，因此 A 传给 B 的信息量就是 O(n · logn) 。于是， B 就得到了足够多的信息，可以直接计算中位数了，算好后再把结果告诉 A ，此时又要耗费 log(n) 个 bit （但它并不会成为通信量的瓶颈）。因此，在这种方案中，总的通信复杂度就是 O(n · logn) 。事实上，传送一个 {1, 2, …, n} 的子集只需要一个 n 位 01 串就够了，因而我们可以把通信复杂度降低到 O(n) 个 bit 。</p>
<p>    利用下面的办法，我们可以实现 O(logn · logn) 的通信复杂度。首先， A 、 B 分别告诉对方自己手中有多少个数，这一共会耗费 O(logn) 个 bit 。接下来，两人在区间 [1, n] 上进行二分查找。假设到了某一步，中位数被限定在了区间 [i, j] 里，那么 A 就计算出 k = (i + j) / 2 ，数一数自己手中有多少个数比 k 小，然后告诉 B ，由 B 再来数数自己这边又有多少个比 k 小的数，从而判断出 k 作为中位数来说是偏大了还是偏小了，并把判断出来的结果返回给 A 。根据情况，区间 [i, j] 将被更新为 [i, k] 或者 [k, j] ，两人在新的区间上继续二分下去。整个算法将会持续 O(logn) 轮，每一轮都会传输 O(logn) 的数据，因此总的通信复杂度是 O(logn · logn) 。</p>
<p>    另一方面，通信复杂度至少是 Ω(logn) 的。这是因为，如果规定 A 和 B 最多只能交流 k 个 bit ，那么整个交流历史最多就只有 k 次分岔的机会，到最后最多只能产生 2<sup>k</sup> 个不同的分支；但事实上中位数有可能是 1 到 n 中的任何一个，共有 n 种不同的可能，因此 2<sup>k</sup> 必须大于等于 n 。这说明 k 必须大于等于 log<sub>2</sub>(n) ，也就是说两个人总会有必须要交流 log<sub>2</sub>(n) 个 bit 才行的时候。</p>
<p>    一个有意思的问题自然而然地诞生了：我们所得的上界和下界仍然有差距。究竟是刚才的算法还不够经济，还是刚才证明的结论还不够强呢？</p>
<p>    还想说明一点的是，两个人商量算法的过程，或者其中一个人把算法告诉另一个人的过程，这可以不算进通信复杂度里。事实上，把它们算进通信复杂度里也没关系，因为它们反正都是 O(1) 的。</p>
<p><span id="more-5342"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    我们还能把通信复杂度进一步降低到 O(logn) ，从而完美地解决这个问题。为此，我们先给出另一种 O(logn · logn) 的算法，然后把它改进到 O(logn) 去。</p>
<p>    假设 A 和 B 手中的数分别有 |A| 个和 |B| 个，而且正好有 |A| = |B| = 2<sup>k</sup> ，其中 k 是某个正整数。如果不是的话，可以让 A 先花费 O(logn) 个 bit 把 |A| 告诉 B ，同样地， B 也花费 O(logn) 个 bit 把 |B| 告诉 A 。然后，两人找出一个最小的但是比 |A| 和 |B| 都大的 2<sup>k</sup> 。接下来，两个人都在自己的数据当中加入 1 和 n ，把各自手中的数填充到 2<sup>k</sup> 个。只要最后两个人总共加入了同样多的 1 和 n （或者加进去的 n 比加进去的 1 多一个，如果 |A| + |B| 是奇数的话），这都不会改变中位数的值。两人可以花费 O(logn) 个 bit 来约定，每个人都往自己的数据里加入多少个 1 和多少个 n 。注意，虽然两个人手中的数变多了，但从对数意义上看，这仅仅是常数级别的变化。</p>
<p>    现在，每个人手中都有 2<sup>k</sup> 个数了。每个人都给自己手中的所有数从小到大排个序。假设此时 A 手中所有数的中位数是 a ， B 手中所有数的中位数是 b 。两人用 O(logn) 个 bit 交换 a 和 b 的值。如果 a &lt; b ，那么 A 手中前面一半的数肯定不可能是中位数了， A 就把前面一半的数丢掉；同时， B 手中后面一半的数肯定也不可能是中位数，因此 B 就可以把他手中后面一半的数都丢掉。类似地，如果 a &gt; b ，那么 A 就可以把他后面一半的数丢掉， B 就可以把他前面一半的数丢掉。不管怎么样， A 、 B 两人手里的数都只剩下原来的一半了，并且如果把两个人手中的数合起来看，那么真正的中位数左右两边都被去掉了同样多的数，因而剩下的数将会保持中位数不变。接下来， A 算出新的 a 是多少， B 算出新的 b 是多少，然后两人再次比较 a 和 b ，并继续扔掉各自手里其中一半的数……不断这样做下去，那么每个人手中的数都会成半地减少。等到哪一步，两个人手里都只剩一个数了，小的那个数一定就是中位数了；或者某一步出现了 a = b 的情况，那么这个值就一定是中位数了。整个过程一共有 O(logn) 轮，每一轮都会传输 O(logn) 的数据，因此总的通信复杂度是 O(logn · logn) 。</p>
<p>    现在，我们把算法的通信复杂度改进到 O(logn) 。首先注意到，在每一轮当中，双方并不需要知道 a 和 b 的值，只需要知道 a 和 b 谁更大一些。因此，两个人可以从高到低轮流发送 a 和 b 的二进制位，一旦出现不同就可以立即停下来了。另外，如果这一轮逐位比较大小的时候，到了左起第 i 位才比出 a 和 b 的大小，那么对于今后的 a 和 b 来说，我们要么根本就不用比较，要么就可以直接从第 i 位开始比较。比方说，在这一轮里双方发现 a = 00100????? 并且 b = 00101????? ，这就说明 a &lt; b 。此时， A 会去掉前面一半的数，那些头几位就比 00100 小的数肯定都被去掉了，剩下的数只有可能以 00100, 00101, 00110, 00111, 01000, … 打头；类似地， B 则会去掉后面一半的数，剩下的数只能以 00101, 00100, 00011, 00010, … 打头。假如今后某一轮中的 a 值是以 00110 打头的，那么 A 不用跟 B 说话就能直接知道，这回肯定是 a 值更大一些 ，因为 B 的手里不可能有这么大的数，它们都已经被去掉了。此时， A 就可以用 O(1) 个 bit 直接告诉 B ，这回我的 a 肯定比你的 b 大，咱俩该怎么办就怎么办吧。类似地，今后 B 也可能会出现这样的情况：一看 b 值的头几位，直接就知道该怎么办了。除非 a 和 b 都以 00100 或者 00101 打头，我们才真的需要比较 a 和 b 的大小，因此我们可以直接从上次停止的数位开始继续往下比。</p>
<p>    如果某一轮当中比到了相同的位，那么这些位今后就再也不用交换了，而 a 和 b 都有 O(logn) 位，这说明两人一共交换了 O(logn) 次相同的位；如果某一轮当中比到了不同的位，那么这一轮比较就会立即停止，这说明每一轮里最多只会遇到一次不同的位，而整个算法有 O(logn) 轮，因而两人一共也就交换了 O(logn) 次不同的位。另外，整个算法开始前会有 O(logn) 的交流（为了把数据填充到 2<sup>k</sup> 个），每一轮也会产生 O(1) 的交流（告诉对方是否需要比较）。因而，最终总的通信复杂度就是 O(logn) 。</p>
<p>参考资料： Eyal Kushilevitz and Noam Nisan, Communication complexity.</p>
			 ]]></content>
<pubDate>2013-07-02T09:01:39+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5342</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：不用乘法实现 (1 + x + x^2 + x^4) mod 2233393 ]]></title>
<link>http://www.matrix67.com/blog/archives/5362</link>
<content><![CDATA[ 
		<p>    下面是 <a href="http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/challenges/May2013.html">IBM Ponder This</a> 2013 年 5 月的谜题：写一个程序来计算 f(x) = 1 + x + x<sup>2</sup> + x<sup>4</sup> (mod 2233393) 。你的程序只能使用以下三种语句，其中等号表示赋值，变量 2 和变量 3 的位置都可以用常量来代替：</p>
<blockquote><p>(1) 变量 1 = 变量 2 + 变量 3<br>
(2) 变量 1 = 变量 2 * 变量 3<br>
(3) 变量 1 = 变量 2 mod 变量 3</p></blockquote>
<p>    很容易想到，一种最基本的解法如下：</p>
<p><code>a = x * x<br>
b = a * a<br>
c = a + b<br>
d = c + x<br>
e = d + 1<br>
f = e mod 2233393</code></p>
<p>    这道谜题则要求你找到另外一种解法，它必须同时满足下面两个额外的要求：</p>
<p>      (1) 最多使用两次变量与变量之间的乘法运算（但允许多次变量与常量之间的乘法运算）<br>
      (2) 最后两次运算分别是一次变量与变量之间的乘法运算和一次取余运算</p>
<p><span id="more-5362"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    两次变量与变量之间的乘法运算正好能够产生四次多项式，而且其中一次乘法是在最后的取余运算之前进行的，这让我们想到了这样的思路：找出常数 a 、 b 、 c 、 d ，使得 (x<sup>2</sup> + a · x + b)(x<sup>2</sup> + c · x + d) 展开之后，从高到低各项系数除以 2233393 的余数正好是 1, 0, 1, 1, 1 。这样的话，我们就可以先用一次双变量的乘法产生 x<sup>2</sup> ，然后构造出 x<sup>2</sup> + a · x + b 和 x<sup>2</sup> + c · x + d ，在倒数第二步把它们乘在一起，在最后一步取整个结果除以 2233393 的余数，这就实现了我们的目标。</p>
<p>    但是，即使用计算机去搜索 a 、 b 、 c 、 d ，计算量也太大了。怎么办呢？一个非常巧妙的办法是，注意到 2233393 = 19 × 41 × 47 × 61 ，因此我们可以分别找出从 a<sub>1</sub> 到 d<sub>4</sub> 共 16 个常数，使得它们满足：</p>
<blockquote><p>(x<sup>2</sup> + a<sub>1</sub> · x + b<sub>1</sub>)(x<sup>2</sup> + c<sub>1</sub> · x + d<sub>1</sub>) = x<sup>4</sup> + x<sup>2</sup> + x + 1 (mod 19)<br>
(x<sup>2</sup> + a<sub>2</sub> · x + b<sub>2</sub>)(x<sup>2</sup> + c<sub>2</sub> · x + d<sub>2</sub>) = x<sup>4</sup> + x<sup>2</sup> + x + 1 (mod 41)<br>
(x<sup>2</sup> + a<sub>3</sub> · x + b<sub>3</sub>)(x<sup>2</sup> + c<sub>3</sub> · x + d<sub>3</sub>) = x<sup>4</sup> + x<sup>2</sup> + x + 1 (mod 47)<br>
(x<sup>2</sup> + a<sub>4</sub> · x + b<sub>4</sub>)(x<sup>2</sup> + c<sub>4</sub> · x + d<sub>4</sub>) = x<sup>4</sup> + x<sup>2</sup> + x + 1 (mod 61)</p></blockquote>
<p>    然后利用中国剩余定理便能得到 a 、 b 、 c 、 d 满足：</p>
<blockquote><p>(x<sup>2</sup> + a · x + b)(x<sup>2</sup> + c · x + d) = x<sup>4</sup> + x<sup>2</sup> + x + 1 (mod 2233393)</p></blockquote>
<p>    搜索前面 16 个常数的计算量已经很小了，即使是最后一个式子，我们也只需要枚举四个 0 到 60 之间的数的组合。结果如下：</p>
<blockquote><p>(x<sup>2</sup> + 7 · x + 10)(x<sup>2</sup> + 12 · x + 2) = x<sup>4</sup> + x<sup>2</sup> + x + 1 (mod 19)<br>
(x<sup>2</sup> + 7 · x + 22)(x<sup>2</sup> + 34 · x + 28) = x<sup>4</sup> + x<sup>2</sup> + x + 1 (mod 41)<br>
(x<sup>2</sup> + 4 · x + 26)(x<sup>2</sup> + 43 · x + 38) = x<sup>4</sup> + x<sup>2</sup> + x + 1 (mod 47)<br>
(x<sup>2</sup> + 19 · x + 6)(x<sup>2</sup> + 42 · x + 51) = x<sup>4</sup> + x<sup>2</sup> + x + 1 (mod 61)</p></blockquote>
<p>    注意到 19、 41、 47 、 61 都是质数，因而它们也就是两两互质的。利用中国剩余定理，我们可以找出从 0 到 19 × 41 × 47 × 61 – 1 之间的一个数 M ，使得 M 除以 19 、 41 、 47 和 61 的余数分别是 7 、 7 、 4 、 19 。这个数便是 1594620 。类似地， (10, 22, 26, 6) 对应于 1831287 ， (12, 34, 43, 42) 对应于 638773 ， (2, 28, 38, 51) 对应于 1613501 。于是我们就有了</p>
<blockquote><p>(x<sup>2</sup> + 1594620 x + 1831287)(x<sup>2</sup> + 638773 x + 1613501) = x<sup>4</sup> + x<sup>2</sup> + x + 1 (mod 2233393)</p></blockquote>
<p>    这正是 IBM Ponder This 给出的标准答案：</p>
<p><code>y = x * x<br>
a = 638773 * x<br>
a = y + a<br>
a = 1613501 + a<br>
b = 1594620 * x<br>
b = y + b<br>
b = b + 1831287<br>
z = a * b<br>
z = z mod 2233393</code></p>
<p> <br>
    受此启发， <a href="http://brand.site.co.il/riddles/201306q.html">Using your Head is Permitted</a>  2013 年 6 月提出了一个加强版的问题，瞬间完爆 IBM Ponder This 的原题。你仍然只能使用那三种语句，仍然是要实现 f(x) = 1 + x + x<sup>2</sup> + x<sup>4</sup> (mod 2233393) ，但这一次的限制条件更加苛刻：</p>
<p>      (1) 完全不能使用任何乘法运算<br>
      (2) 总共不能超过 10 次运算</p>
<p>    看上去，不用乘法就能算出一个四次多项式的值，这似乎根本就不可能。不过，我们也并不需要算出这个四次多项式的值，只需要算出这个四次多项式模 2233393 之后的值。我们或许可以在程序中使用一些非常大的常数，让它与 x 发生某种线性关系后，模 2233393 的余数正好与 1 + x + x<sup>2</sup> + x<sup>4</sup> 相同。</p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    事实上，我们只需要 4 次运算就足够了，而且方法出人意料地简单。令 A 为一个充分大的常数，比如 10<sup>40</sup> 。算出 B = 1 – A + A<sup>2</sup> + A<sup>4</sup> ，它将成为程序中的另一个常数。依次执行下面四条语句，最后就会得到 (1 + x + x<sup>2</sup> + x<sup>4</sup>) mod 2233393 。</p>
<p><code>a = x mod 2233393<br>
b = a + A<br>
c = B mod b<br>
d = c mod 2233393</code></p>
<p>    为什么？首先，我们要计算的是 (1 + x + x<sup>2</sup> + x<sup>4</sup>) mod 2233393 ，因此事先取 x 模 2233393 的余数，这不会对结果产生影响。那么，令 a = x mod 2233393 后，我们只需要算出 (1 + a + a<sup>2</sup> + a<sup>4</sup>) mod 2233393 即可。</p>
<p>    而在第三步结束之后， c 的值正是 1 + a + a<sup>2</sup> + a<sup>4</sup> ！为了解释这件事，我们只需要注意到以下两点：首先，由于 b = a + A ，因此 – a 和 A 模 b 的余数是相同的，而 c 是 1 – A + A<sup>2</sup> + A<sup>4</sup> 模 b 的余数，因而 c 也就等于 1 – (- a) + (- a)<sup>2</sup> + (- a)<sup>4</sup> 模 b 的余数，即 1 + a + a<sup>2</sup> + a<sup>4</sup> 模 b 的余数；其次， a 是一个不超过 2233393 的正整数，因而 1 + a + a<sup>2</sup> + a<sup>4</sup> 也就是一个大小有限的正整数。我们选取的常数 A 非常非常大，从而保证了 b = a + A 也非常非常大，并且远远超过了 1 + a + a<sup>2</sup> + a<sup>4</sup> 可能的最大值。所以说， 1 + a + a<sup>2</sup> + a<sup>4</sup> 模 b 的余数也就是 1 + a + a<sup>2</sup> + a<sup>4</sup> 本身。这就说明了， c 确实等于 1 + a + a<sup>2</sup> + a<sup>4</sup> 。</p>
<p>    既然 c 已经等于 1 + a + a<sup>2</sup> + a<sup>4</sup> 了，最后再来一个 d = c mod 2233393 ，问题就解决了。</p>
<p>    这个例子告诉了我们，引入大数运算会让计算能力出现意想不到的突破。事实上，假设计算机能瞬间完成任意大数之间的运算，我们就能做到 <a href="http://www.matrix67.com/blog/archives/1209">O(n) 时间的排序</a>，甚至 <a href="http://www.matrix67.com/blog/archives/1523">O(1) 时间的排序</a>。</p>
			 ]]></content>
<pubDate>2013-07-03T05:34:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5362</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：设计多边形围墙使得对于某一观察点所有的墙都不完全可见 ]]></title>
<link>http://www.matrix67.com/blog/archives/5382</link>
<content><![CDATA[ 
		<p>    下面是趣题集 Which Way Did the Bicycle Go 中的第 71 个问题。如下图，在这个六边形的围墙中，如果站在图中圆点的位置，那么有两面墙不能被完全看见（其中一面墙完全看不见）。能否设计出一个多边形围墙，使得站在围墙里面的某个地方后，所有的墙都至少有一部分是不可见的？</p>
<p>      <img alt="image placeholder" >
<p><span id="more-5382"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    是的，如下图。真正有趣的是， Which Way Did the Bicycle Go 一书上还给了一个附加题：能否设计出一个多边形围墙，使得站在围墙<strong>外面</strong>的某个地方后，所有的墙都至少有一部分是不可见的？继续阅读下去前，不妨先想一下。</p>
<p>      <img alt="image placeholder" >
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    是的，如下图。你花了多少时间才想到了这一招？在可见性问题的研究中，这是一种很常用的技巧。</p>
<p>      <img alt="image placeholder" >
			 ]]></content>
<pubDate>2013-07-19T12:28:07+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5382</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：如何在数据库中秘密地查询隐私数据 ]]></title>
<link>http://www.matrix67.com/blog/archives/5387</link>
<content><![CDATA[ 
		<p>    日常生活中经常会出现这样的场景：你想在数据库上查询某个东西，但却不希望留下线索，让别人知道你查询了什么。比方说，投资人可能会在数据库上查询某支股票的信息，但却不希望任何人知道他感兴趣的股票究竟是哪一支。看上去，似乎唯一的办法就是把整个数据库全部拷回家。然而，这些数据往往都拥有非常庞大的体积，全部拷走通常都是很不现实的；另外，考虑到数据内容的隐私性和数据本身的宝贵价值，数据的持有者通常也不允许其他人把整个数据全盘拷走。不过，随着分布式数据库的广泛应用，上面的难题有了一个两全其美的好办法：假设有两个内容完全相同的数据库，投资人可以先在第一个数据库上执行一个不会透露目的的查询，再在另一个数据库上执行另一个不会透露目的的查询，两次查询结合起来便能推出想要的结果。只要没有人刻意去收集并且对比两个数据库的查询记录，那么谁也不会知道投资人真正想要查询的是什么。在这个背景下，我们有了下面这个有趣的问题。</p>
<p>    服务器随机产生了一个 {1, 2, …, 100} 的子集 S ，并且同时发送给了 A 和 B 两名前台工作人员。 A 、 B 两名前台都接受其他人的提问，但为了保护数据，两个人都只能用“是”或者“否”来回答问题，并且都不允许同一个人重复提问。你非常关心某个数 n 是否在这个子集里。其实，你本来可以直接问 A 和 B 中的任何一个人“数字 n 是否在集合 S 里”，但是这样一来，对方就知道了你想要查询的是什么。为此，你可以向 A 和 B 各问一个问题（结合两人的回答便能推出集合 S 里是否包含数字 n ），但却不能让 A 和 B 当中的任何一个人知道你查询的是哪个数（我们假设 A 、 B 两人不会串通起来，把他们各自收到的问题联系在一起）。事实上，你需要保证 A 和 B 两人都不能从你的问题中获取到任何信息，也就是说，对于 A 和 B 当中的任何一个人来说，各种问题出现的概率不会随着 n 值的改变而改变。再换句话说，如果 n 的值变了，那么 A 和 B 各自将会听到的问题应该拥有和原来相同的概率分布。</p>
<p><span id="more-5387"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    答案：首先，自己随机生成一个 {1, 2, …, 100} 的子集 T<sub>1</sub> （每个数都有 1/2 的概率被选进 T<sub>1</sub> ）。如果 T<sub>1</sub> 里面正好包含数字 n ，那么就把 T<sub>1</sub> 里的数字 n 去掉，把所得的结果记作 T<sub>2</sub> ；如果 T<sub>1</sub> 里面没有数字 n ，那么就在 T<sub>1</sub> 中加入数字 n ，从而得到 T<sub>2</sub> 。现在，将  T<sub>1</sub> 发送给 A ，并询问  T<sub>1</sub>  里面是否有偶数个数正好也在 S 里。类似地，再将  T<sub>2</sub> 发送给 B ，并且询问同样的问题：在 T<sub>2</sub>  里面是否有偶数个数同时也属于 S 。注意， T<sub>1</sub> 和 T<sub>2</sub> 的唯一差别，就是一个里面有 n 一个里面没有 n 。因此，如果 A 和 B 的回答是一致的，就说明数字 n 不在 S 里面；如果 A 和 B 的回答不一致，就说明数字 n 在 S 里面。另外，容易看出，不管是 T<sub>1</sub> 还是 T<sub>2</sub> ，从 1 到 100 每个数在里面出现的概率都是 1/2 。因此，不管是 A 还是 B ，他被问到的问题都总是具有完全相同的概率分布，这不随 n 的变化而变化。</p>
<p> <br>
 <br>
    这种方案的缺陷就是，每条询问都非常长。为了描述 T<sub>1</sub> 或者 T<sub>2</sub> ，我们需要使用一个 100 位的 01 串，它一共有 100 个 bit 。如果 S 不是 {1, 2, …, 100} 的子集，而是 {1, 2, …, N} 的子集，那么在上述方案中，我们需要给 A 、 B 各发送 O(N) 个 bit 的数据。在 N 非常大的情况下，这么做同样是不现实的。有趣的是，如果前台不止两个人，而是四个人的话，那么我们可以做得更好：我们可以给四个人都只发送 O(√<span style="text-decoration:overline">N</span>) 个 bit 的数据，并且同样保证每个人都不能从中推出任何信息来。</p>
<p>    为了便于说明，我们现在假设 S 是 {0, 1, 2, …, 99} 的一个子集。假设你想要知道， 67 是否在集合 S 里。于是，你首先随机生成一个 {0, 1, 2, …, 9} 的子集 T<sub>1</sub> ，然后在里面加上数字 6 （如果 T<sub>1</sub> 里没有 6 的话）或者去掉数字 6 （如果 T<sub>1</sub> 里有 6 的话），得到 T<sub>2</sub>；再生成另一个 {0, 1, 2, …, 9} 的子集 T<sub>3</sub> ，然后在里面加上数字 7 （如果 T<sub>3</sub> 里没有 7 的话）或者去掉数字 7 （如果 T<sub>3</sub> 里有 7 的话），得到子集 T<sub>4</sub> 。接下来，向 A 、 B 、 C 、 D 依次询问下面四个问题</p>
<p>      A ：在所有十位数属于 T<sub>1</sub> 并且个位数属于 T<sub>3</sub> 的数当中，是否有偶数个数在集合 S 里。<br>
      B ：在所有十位数属于 T<sub>1</sub> 并且个位数属于 T<sub>4</sub> 的数当中，是否有偶数个数在集合 S 里。<br>
      C ：在所有十位数属于 T<sub>2</sub> 并且个位数属于 T<sub>3</sub> 的数当中，是否有偶数个数在集合 S 里。<br>
      D ：在所有十位数属于 T<sub>2</sub> 并且个位数属于 T<sub>4</sub> 的数当中，是否有偶数个数在集合 S 里。</p>
<p>    如果 T<sub>1</sub> 等于 {2, 4, 7, 8, 6} ，那么 T<sub>2</sub> 就应该等于 {2, 4, 7, 8}  ；如果 T<sub>3</sub> 等于 {2, 3, 5} ，那么 T<sub>4</sub> 就应该等于 {2, 3, 5, 7} 。四次询问之后我们便可得知，在下图各种颜色的方框中，属于集合 S 的数有奇数个还是偶数个。结合 A 、 B 的回答（蓝色方框和黄色方框），我们就能推出，在集合 S 当中，十位数属于 T<sub>1</sub> 并且个位数恰好为 7 的数有奇数个还是偶数个；结合 C 、 D 的回答（红色方框和绿色方框），我们就能推出，在集合 S 当中，十位数属于 T<sub>2</sub> 并且个位数恰好为 7 的数有奇数个还是偶数个。于是，我们就可以知道，十位数恰好为 6 并且个位数恰好为 7 的数是否在集合 S 当中了。</p>
<p>      <img alt="image placeholder" >
<p>    类似地，如果集合 S 是 {1, 2, …, N} 的子集，那么我们可以对这 N 个数进行重新编码，使得每个数都由高位和低位组成。那么，高位和低位的取值范围都是从 1 到 √<span style="text-decoration:overline">N</span> 。在整个协议中，我们需要给每个人发送两个 {1, 2, …, √<span style="text-decoration:overline">N</span>} 的子集，这相当于两个 √<span style="text-decoration:overline">N</span> 位的 01 串，因此其数据量为  2√<span style="text-decoration:overline">N</span> 个 bit ，也就是 O(√<span style="text-decoration:overline">N</span>) 个 bit 。</p>
<p>    不过，请注意，虽然与每个人交流的数据量少了，但这次却有四个人了，因而你需要发送四个这么大的数据。当 N 很小的时候， 4 · 2√<span style="text-decoration:overline">N</span> 很可能反而比 2 · N 更大。</p>
<p>    同样地，如果我们有 2<sup>d</sup> 个人，我们就可以把 1 到 N 里面的所有数都看作 d 位数，每一位的取值范围是从 1 到 N<sup>1/d</sup> 。为了完成一次查询，我们需要给每个人发送 d 个 {1, 2, …,  N<sup>1/d</sup>} 的子集，因此总共需要发送 2<sup>d</sup> · d · N<sup>1/d</sup> 个 bit 。对于不同的 N ，我们可以选取最合适的 d ，使得 2<sup>d</sup> · d · N<sup>1/d</sup> 最小。例如，下图所示的就是 N = 1 000 000 时函数 f(d) = 2<sup>d</sup> · d · N<sup>1/d</sup> 的图像，可见 d = 4 时的通信成本是最低的。因此，如果查询点足够多的话，我们可以选择在 16 个不同的地方进行查询。</p>
<p>      <img alt="image placeholder" >
<p>参考资料： B. Chor, O. Goldreich, E. Kushilevitz, M. Sudan, Private Information Retrieval, Journal of the ACM (JACM), 1998</p>
			 ]]></content>
<pubDate>2013-07-19T12:47:37+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5387</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：不用三角函数求出∠BAC的度数 ]]></title>
<link>http://www.matrix67.com/blog/archives/5398</link>
<content><![CDATA[ 
		<p>    今天看到了一道很有趣的几何题。如图，四边形 ABCD 中，连接对角线 AC 、 BD ，若 ∠ABD = 40° ， ∠ADB = 80° ， ∠CBD = 70° ， ∠CDB = 50° ，求 ∠BAC 的度数。</p>
<p>      <img alt="image placeholder" >
<p>    这道题看上去似乎非常简单，但稍作尝试你就会发现，仅仅是在这几个角度之间来回倒腾，是没法求出 ∠BAC 的度数的。听说过 <a href="http://www.matrix67.com/blog/archives/382">Langley 问题</a>（就是那个臭名昭著的 20-80-80 三角形）的人就会知道，这种类型的题目往往会非常非常地复杂。据说这是 1989 – 1990 年加拿大亚伯达省中学数学竞赛中的一道题目，当时只有一个人做对，并且解答过程用到了非常繁琐的三角函数运算。然而，这道题实际上有一个非常漂亮的秒杀方法，完全不需要使用三角函数。你能想到吗？</p>
<p><span id="more-5398"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
      <img alt="image placeholder" >
<p>    答案：把注意力集中在三角形 ABD 上。容易看出， ∠A = 180° – 40° – 80° = 60° 。另外， CB 平分 ∠B 的外角， CD 平分 ∠D 的外角，因而 C 就是三角形 ABD 的一个旁心。这说明， CA 也将平分 ∠A 。因此， ∠BAC = 60° / 2 = 30° 。</p>
<p>参考资料： Andy Liu, “A Better Angle From Outside”, Mathematical Horizons, November 1997</p>
			 ]]></content>
<pubDate>2013-07-22T14:25:44+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5398</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：上哪儿找一个含60度的三角形？ ]]></title>
<link>http://www.matrix67.com/blog/archives/5406</link>
<content><![CDATA[ 
		<p>      <img alt="image placeholder" >
<p>    四边形 ABCD 是一个正方形，在 BC 上取一个点 M ，在 CD 上取一个点 N ，使得 BM = CN 。连接 AM 、 AN ，与对角线 BD 分别交于 P 、 Q 两点。求证： BP 、 PQ 、 QD 三条线段一定能组成一个三角形，并且这个三角形的其中一个角等于 60° 。</p>
<p><span id="more-5406"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    其中一种思路就是，借助一些辅助线，在图中弄出一个含 60 度的三角形来，并说明它的三边长度就是 BP 、 PQ 、 QD 。但问题的难点就是，我们上哪儿找一个含 60 度的三角形？在很多平面几何问题中，把图形扩展到三维空间中去，反而会带来意想不到的突破（可以参见<a href="http://www.matrix67.com/blog/archives/58">这里</a>和<a href="http://www.matrix67.com/blog/archives/3965">这里</a>）。现在，我们又有了一个绝好的例子。</p>
<p>      <img alt="image placeholder" >
<p>    如图，作一个边长与正方形相等的正方体 A<sub>1</sub>B<sub>1</sub>C<sub>1</sub>D<sub>1</sub> – A<sub>2</sub>B<sub>2</sub>C<sub>2</sub>D<sub>2</sub> ，在 A<sub>1</sub>B<sub>1</sub> 上截取 A<sub>1</sub>M’ = BM ，在A<sub>1</sub>D<sub>1</sub> 上截取 A<sub>1</sub>N’ = DN 。假设 A<sub>1</sub>B<sub>2</sub> 和 A<sub>2</sub>M’ 交于点 P’ ， A<sub>1</sub>D<sub>2</sub> 和 A<sub>2</sub>N’ 交于 Q’ 。注意到三角形 A<sub>1</sub>B<sub>2</sub>D<sub>2</sub> 的三条边都相等，因而它是一个等边三角形， ∠B<sub>2</sub>A<sub>1</sub>D<sub>2</sub> = 60° 。如果图中阴影三角形的三边长度分别等于 BP 、 PQ 和 QD ，问题就解决了。显然， A<sub>1</sub>P’ = BP ， A<sub>1</sub>Q’ = QD ，因此我们只需要说明 P’Q’ = PQ 。</p>
<p>    容易证明， M’N’ = MN ， A<sub>2</sub>M’ = AM ， A<sub>2</sub>N’ = AN ，因此三角形 A<sub>2</sub>M’N’ 和三角形 AMN 全等，于是 ∠M’A<sub>2</sub>N’ = ∠MAN 。另外，容易看出 A<sub>2</sub>P’ = AP ， A<sub>2</sub>Q’ = AQ ，而刚才我们已经证明了 ∠M’A<sub>2</sub>N’ = ∠MAN ，于是三角形 A<sub>2</sub>P’Q’ 与三角形 APQ 全等。于是， P’Q’ = PQ 。</p>
<p>题目出自单遵《平面几何中的小花》。</p>
			 ]]></content>
<pubDate>2013-08-03T18:32:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5406</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用单位圆覆盖平面上的10个点 ]]></title>
<link>http://www.matrix67.com/blog/archives/5409</link>
<content><![CDATA[ 
		<p>    证明：对于平面上的任意一个大小为 10 的点集，我们总能在平面上不重叠地放置若干个单位圆，使得它们合起来可以覆盖到所有这 10 个点。</p>
<p><span id="more-5409"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
<!--more--></p>
<p>      <img alt="image placeholder" >
<p>    让我们先把充分多的单位圆放在平面上，并像上图那样紧密地排列在一起，则它们将覆盖这个平面 π / (2 · √<span style="text-decoration:overline">3</span>) ≈ 0.9069 的面积。这是因为，整个图形可以看作是由虚线所示的正六边形平铺得来的，而每个正六边形的面积为 6 · √<span style="text-decoration:overline">3</span> （六个边长为 2 的等边三角形），其中被覆盖的部分正好可以拼成三个完整的单位圆，其面积为 3 · π ，占整个正六边形的 (3 · π) / (6 · √<span style="text-decoration:overline">3</span>) = π / (2 · √<span style="text-decoration:overline">3</span>)  ≈ 0.9069 。</p>
<p>    不过，这并不能保证点集中的每个点都被这组圆覆盖到了。现在，随机地对这组圆进行平移，得到一系列概率均等的圆盘放置方案。在这些圆盘放置方案中，每个点都有 0.9069 的概率被覆盖到，换句话说每个点被覆盖到的期望次数都是 0.9069 ；因此，在这 10 个点中，发生覆盖的期望次数就是 9.069 ，这是一个大于 9 的数。那么，这里面一定有一种圆盘放置方案，它至少产生了 10 次覆盖，这就表明所有的 10 个点都被覆盖到了。</p>
<p>问题来源：<a href="http://www.cs.cmu.edu/puzzle/puzzle38.html">http://www.cs.cmu.edu/puzzle/puzzle38.html</a></p>
			 ]]></content>
<pubDate>2013-08-03T18:41:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5409</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：为什么n=5时不存在Leech树？ ]]></title>
<link>http://www.matrix67.com/blog/archives/5418</link>
<content><![CDATA[ 
		<p>    在一棵树中，任意两个顶点之间的路径都是唯一的。如果一棵树有 n 个顶点，那么这棵树总共会有 n(n-1)/2 条路径（每两个顶点都会确定出一条路径来）。 1975 年， John Leech 提出了这么一个问题：有多少顶点数为 n 且边上带权的树，使得图中所有 n(n-1)/2 条路径的权值之和正好是 1, 2, …, n(n-1)/2 ？Leech 本人给出了五个这样的例子，其中四个如下图所示，顶点数 n 分别为 2 、 3 、 4 、 4 。第五棵满足要求的树拥有 6 个顶点，把它找出来将会是一个不小的挑战，感兴趣的读者不妨尝试一下，本文最后会公布答案。 Leech 注意到了 n = 5 时是无解的，但却并没有给出一个解释。</p>
<p>      <img alt="image placeholder" >
<p>    1977 年， Herbert Taylor 给出了一个非常漂亮的解释：如果一棵树满足上述要求，那么顶点数 n 一定是形如 m<sup>2</sup> 或者 m<sup>2</sup> + 2 的数。让我们来看一看这个精妙的证明。</p>
<p><span id="more-5418"></span><br>
    给定一棵树后，首先按照下述原则对所有顶点进行红蓝二染色：如果某条边的权值为偶数，则两端的顶点同色；如果某条边的权值为奇数，则两端的顶点异色。这是总能办到的，比如我们可以先随便选一个顶点，把它染成红色，然后从这个顶点出发，按照规则一点一点地推出其他顶点的颜色。由于整个图是一棵树，图中没有回路，因此往外推理的过程中不会走回已经染过色的地方，因而不会有矛盾产生。如果用 r 来表示所有红色顶点的数目，用 b 来表示所有蓝色顶点的数目，则 r + b = n 。</p>
<p>    注意到，如果一条路径的权值之和为奇数，就说明这条路中有奇数条权值为奇数的边，也就说明沿着这条路径行走的过程中，顶点的颜色改变了奇数次。因此，两个顶点之间的路径权值之和为奇数，当且仅当这两个顶点是异色的。这说明，权值之和为奇数的路径一共有 rb 条。</p>
<p>    如果所有 n(n-1)/2 条路径的权值之和依次是 1, 2, …, n(n-1)/2 ，那么当 n(n-1)/2 是偶数的时候，权值之和为奇数的路径应该有 (n(n-1)/2)/2 条；当 n(n-1)/2 是奇数的时候，权值之和为奇数的路径应该有 (n(n-1)/2 + 1)/2 条。</p>
<p>    在前一种情况中， rb = (n(n-1)/2)/2 ，即 4rb = n(n-1) 。于是：</p>
<p>      n = n<sup>2</sup> – 4rb<br>
         = (r + b)<sup>2</sup> – 4rb<br>
         = r<sup>2</sup> + b<sup>2</sup> + 2rb – 4rb<br>
         = r<sup>2</sup> + b<sup>2</sup> – 2rb<br>
         = (r – b)<sup>2</sup></p>
<p>    在后一种情况中， rb = (n(n-1)/2 + 1)/2 ，即 2 · (2rb – 1) = n(n-1)。于是：</p>
<p>      n = n<sup>2</sup> – 4rb + 2<br>
         = (r + b)<sup>2</sup> – 4rb + 2<br>
         = r<sup>2</sup> + b<sup>2</sup> + 2rb – 4rb + 2<br>
         = r<sup>2</sup> + b<sup>2</sup> – 2rb + 2<br>
         = (r – b)<sup>2</sup> + 2</p>
<p>    由于数字 5 既不是一个平方数，也不具有平方数加 2 的形式，因而 n = 5 是无解的。下图则是 Leech 找到的那个 n = 6 时的解：</p>
<p>      <img alt="image placeholder" >
<p>    有趣的是，目前除了 Leech 本人找到的这五个解以外，还没有人找到任何新的解。人们猜想 Leech 树的数目是有限的，但目前还没有人证明这一点。</p>
<p> <br>
参考资料：<a href="http://www.cut-the-knot.org/arithmetic/combinatorics/LeechTrees.shtml">http://www.cut-the-knot.org/arithmetic/combinatorics/LeechTrees.shtml</a></p>
			 ]]></content>
<pubDate>2013-08-21T12:46:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5418</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：为什么n=5时不存在Langford数列？ ]]></title>
<link>http://www.matrix67.com/blog/archives/5424</link>
<content><![CDATA[ 
		<p>    还记得小时候有一道经典奥数题，大概是让你把两个数字 1 、两个数字 2 、两个数字 3 和两个数字 4 排成一个 8 位数，使得其中两个数字 1 之间正好夹着 1 个数字，两个数字 2 之间正好夹着 2 个数字，两个数字 3 之间正好夹着 3 个数字，两个数字 4 之间正好夹着 4 个数字。稍作尝试便可得出正确答案： 4, 1, 3, 1, 2, 4, 3, 2 。如果把逆序后的数列视作本质相同的数列，那么上面这个答案是唯一的。这个问题是由 C. Dudley Langford 在 1958 年提出的，因此我们把它叫做 Langford 数列。</p>
<p>    当 n = 3 时， Langford 数列也是唯一的： 2, 3, 1, 2, 1, 3 。我小时候曾经没日没夜地试图寻找 n = 5 时的 Langford 数列，结果却怎么也找不到。后来才知道， n = 5 时的 Langford 数列根本就不存在。这是为什么？你能证明这一点吗？</p>
<p><span id="more-5424"></span><br>
    Donald Knuth 的 The Art of Computer Programming 第四卷开篇就提到了 Langford 数列问题。书中有一段非常精彩的证明。</p>
<p>    为了把 {1, 1, 2, 2, 3, 3, 4, 4, 5, 5} 按照要求放进 _ _ _ _ _ _ _ _ _ _ 这 10 个格子里，我们需要让两个数字 1 要么都在奇数编号的格子里，要么都在偶数编号的格子里。类似地，两个数字 3 的位置编号也具有相同的奇偶性，两个数字 5 的位置编号也具有相同的奇偶性，而两个数字 2 的位置编号则会一奇一偶，两个数字 4 的位置编号也会一奇一偶。然而，我们一共有 5 个奇数编号的格子和 5 个偶数编号的格子，你会发现它们无论如何也不可能既无重复又无遗漏地被填满。</p>
<p>    事实上，在 2n 个格子中，奇数编号的格子和偶数编号的格子总是各占一半，因此我们总是要求 {1, 1, 2, 2, …, n, n} 占据相同数目的奇数编号格子和偶数编号格子。其中，每一对偶数都会非常听话地占据奇偶格子各一个，因而填满格子的艰巨任务就落在了奇数身上。由于每一对奇数只占据其中一种格子，因此我们必须要有偶数对奇数才行。这意味着，在 1, 2, …, n 当中必须有偶数个奇数才行。由此可知，只有 n = 3, 4, 7, 8, 11, 12, … 时，即形如 4m – 1 或者 4m 时， Langford 数列才存在。</p>
<p>    不过，当 n = 4m – 1 或者 n = 4m 时， Langford 数列一定存在吗？换句话说，刚才的条件同时也是充分的吗？ 1959 年， Roy Davies 给出了一种构造解，从而证明了这一点。让我们首先来看一下 n = 4m 时 Langford 数列的构造方法。我把整个构造过程分成 6 步，如下图所示。图中显示的是 n = 100 时的例子，其中 _____(x)_____ 表示连续 x 个还没有填数进去的空格，省略号表示连续奇数或者连续偶数。</p>
<p>   <img alt="image placeholder" >
<p>    每一步我们都会把还没有用过的数成对地填进剩余的空格里。各个步骤的文字说明如下：</p>
<p>      （1）填入两个 4m – 4 和两个 4m ；<br>
      （2）填入两个 2m – 1 ；<br>
      （3）用连续奇数和连续偶数填充部分空白；<br>
      （4）填入两个 4m – 2 ；<br>
      （5）再次用连续奇数和连续偶数填充部分空白；<br>
      （6）在最后剩下的两个空格中填入两个 4m – 1 。</p>
<p>    当 n = 4m – 1 时，只需要在 n = 4m 时的构造上做一点修改即可：把最后两项（分别是 4m 和 2m – 1 ）去掉，然后把中间的那项 4m 改成 2m – 1 。不过，这个构造解并不是唯一解。当 n = 12 时，一共有 108144 个解，上述构造解只是其中之一。</p>
			 ]]></content>
<pubDate>2013-08-21T13:29:28+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5424</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 动画演示：Euler线定理的直观理解 ]]></title>
<link>http://www.matrix67.com/blog/archives/5448</link>
<content><![CDATA[ 
		<p>    任意一个三角形的三条中线都会交于一点，这个点就叫做三角形的“重心”。任意一个三角形的三条高都会交于一点，这个点就叫做三角形的“垂心”。任意一个三角形三边的垂直平分线都会交于一点，这个点就叫做三角形的“外心”。 1765 年，大数学家 Euler 指出：任意一个三角形的重心、垂心和外心都在一条直线上，并且重心会把垂心和外心的连线分成 2 : 1 两段。这个结论虽然有很多<a href="http://www.matrix67.com/blog/archives/4340">很漂亮的证明</a>，但作为一个非常基本的结论，它还有一种非常直观的解释方法。最近在做一个课件的时候，需要用到这种直观理解的动画演示，结果在网上找了半天也没找到，最终决定自己做了一个。</p>
<p>      <img alt="image placeholder" >
<p>    上图中，红色的点是三角形三条高的交点，也就是垂心；蓝色的点是三角形三条中线的交点，也就是重心。现在，把整个三角形绕着重心旋转 180 度，同时以重心为中心把图形缩小到原来的一半。于是，每个点都会跑到重心的正对面去，同时到重心的距离也会缩短到原来的一半。你会发现，由此得到的小三角形，三个顶点都在大三角形各边的中点处（因为它们是大三角形的顶点转过来得到的，而重心在各中线的 2 : 1 处）；同时，小三角形的三条高分别与大三角形的各边垂直（因为它们是大三角形的高转了 180 度得到的）。你会发现，小三角形的垂心正好就是大三角形的外心！而小三角形的垂心就是由大三角形的垂心转过来得到的，这两个点与重心应该在一条线上，并且到重心的距离有 1 : 2 的关系。这样一来，我们就相当于证明了 Euler 线定理。</p>
			 ]]></content>
<pubDate>2013-08-24T15:45:07+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5448</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 线性代数的妙用：怎样在Windows画图软件中实现28度旋转？ ]]></title>
<link>http://www.matrix67.com/blog/archives/5453</link>
<content><![CDATA[ 
		<p>    在早期的小型图像编辑软件中，考虑到时间空间的限制，再加上算法本身的难度，很多看似非常简单的功能都无法实现。比如说，很多图像编辑软件只允许用户把所选的内容旋转 90 度、 180 度或者 270 度，不支持任意度数的旋转。毕竟，如果我们只是旋转 90 度的整数倍，那么所有像素仅仅是在做某些有规律的轮换，这甚至不需要额外的内存空间就能完成。但是，如果旋转别的度数，那么在采样和反锯齿等方面都将会有不小的挑战。</p>
<p>    不过， Windows 自带的画图软件聪明地用 skew 功能（中文版翻译成“扭曲”）部分地填补了无法自由变形的缺陷。随便选中图中的一块区域，再在菜单栏上选择“图像”→“拉伸/扭曲”，然后在“水平扭曲”那儿填写一个 -89 到 89 之间的整数（表示一个角度值），再按一下确定，于是整个图形就会像下图所示的那样被拉斜，其中 θ 就是你刚才填的度数。如果你填入的 θ 是负数值，则倾斜的方向会与下图方向相反。类似地，“垂直扭曲”功能会在竖直方向上对图形进行拉扯，如果角度值为正数，则整个图形会变得左低右高，如果角度值为负数，则整个图形会变得左高右低。</p>
<p>      <img alt="image placeholder" >
<p>    不过，这玩意儿对于我们来说似乎完全没用。估计 99% 的人在使用画图软件的时候就从来没用过这个功能吧。如果真是这样，那么今天的问题恐怕将会是大家最近一段时间见过的最有趣的问题了：想办法利用 Windows 画图中的扭曲功能（近似地）实现 28 度旋转。</p>
<p><span id="more-5453"></span><br>
 <br>
 <br>
    答案：如下图，首先水平扭曲 -14 度，然后垂直扭曲 25 度，最后再水平扭曲 -14 度即可。这样的话，画板中被选中的内容将会被逆时针旋转 28 度。</p>
<p>      <img alt="image placeholder" >
<p>    为什么？这是因为，扭曲的本质其实就是在原图上进行一个线性变换。水平扭曲实际上相当于是对图像各行进行平移，平移量与纵坐标的位置成正比。而这又可以看作是对每个点执行了下图所示的矩阵乘法操作：</p>
<p>      <img alt="image placeholder" >
<p>    类似地，垂直扭曲则相当于对每个点执行了这么一个矩阵乘法的操作：</p>
<p>      <img alt="image placeholder" >
<p>    另外，由于</p>
<p>      <img alt="image placeholder" >
<p>    因此</p>
<p>      <img alt="image placeholder" >
<p>    而最后一行就是大家非常熟悉的旋转矩阵！</p>
<p>    也就是说，连续执行上式中的三次扭曲，就可以实现旋转 θ 度了。其中，第一次扭曲和第三次扭曲都是水平扭曲 -θ/2 度，当 θ = 28° 时，我们应该填写的度数就是 -14 。麻烦的就是第二次扭曲：它看上去并不符合垂直扭曲矩阵的标准形式。垂直扭曲矩阵中，左下角那一项应该是 tan(θ) ，而并非 sin(θ) 。不过，我们完全可以用正切值去模拟 sin(θ) 呀！利用计算机可以解得，当 θ = 28° 时， sin(28°) 约为 0.469 ，离它最近的正切值是 tan(25°) ≈ 0.466 。因此，我们在第二步的时候填入了垂直扭曲 25 度。</p>
<p>    值得一提的是，实际上我们已经得到了一种非常高效并且非常容易编写的图像旋转算法：只需要连续调用三次扭曲操作即可。而每次扭曲操作本质上都是对各行或者各列的像素进行平移，因而整个算法完全不需要任何额外的内存空间！根据 <a href="http://en.wikipedia.org/wiki/Shear_mapping#cite_note-4">Wikipedia</a> 的描述，这种方法是由 Alan Paeth 在 1986 年提出的。</p>
<p>    由于 tan(25°) 并不精确地等于 sin(28°) ，因而这里实现的 28 度旋转也并不是绝对精确的。不过，画图软件本身还提供了水平缩放和垂直缩放的功能，把它们也加进来的话，线性变换的复合将会变得更加灵活，或许我们就能设计出一些更复杂但却更精确的旋转方案了。这些问题就留给感兴趣的读者继续探究吧。</p>
<p> <br>
参考资料：<a href="http://datagenetics.com/blog/august32013/index.html">http://datagenetics.com/blog/august32013/index.html</a></p>
			 ]]></content>
<pubDate>2013-08-25T02:56:58+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5453</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 数学之美：Marden定理 ]]></title>
<link>http://www.matrix67.com/blog/archives/5480</link>
<content><![CDATA[ 
		<p>    如果叫我说出一个我最喜欢的数学定理，之前我可能会说 Monge 定理；不过现在，我可能会说 Marden 定理了：</p>
<blockquote><p>         <img alt="image placeholder" >
 <br>
设 p(z) 是一个复数域上的三次多项式， z<sub>1</sub> 、 z<sub>2</sub> 、 z<sub>3</sub> 是 p(z) 的三个根，它们在复平面上不共线。那么，在这个复平面上存在唯一的椭圆，使得它与三角形 z<sub>1</sub>z<sub>2</sub>z<sub>3</sub> 的各边都相切，并且都切于各边的中点处。并且，这个椭圆的两个焦点是 p'(z) 的两根。</p></blockquote>
<p>    读完这个结论以后，你一定会被数学之美深深地打动。这个结论出现在了 Morris Marden 于 1945 年发表的一篇论文里，因而被 Dan Kalman 称为 Marden 定理。 Marden 本人则认为，这个结论最早是由 Jörg Siebeck 在 1864 年发现并证明的。下面我们简单地来证明一下这个结论，证明过程出自 Dan Kalman 在 2008 年发表的获奖论文 <a href="http://www.maa.org/sites/default/files/pdf/upload_library/22/Ford/Kalman.pdf">An Elementary Proof of Marden’s Theorem</a> 。</p>
<p><span id="more-5480"></span><br>
    其实，结论的前半部分并不奇怪，对于任意一个三角形，内切于各边中点的椭圆本来就是唯一的。这是很容易证明的，其中一种证明方法是，通过线性变换把这个三角形变形成一个等边三角形，那么内切于各边中点的椭圆现在仍然是内切于各边中点的椭圆，然而在一个等边三角形中，内切于各边中点的椭圆只有一个，就是这个等边三角形的内切圆。关于这一点，详细的证明可以参见<a href="http://www.maa.org/external_archive/joma/Volume8/Kalman/MaxEllipse.html">这里</a>。</p>
<p>    因此， Marden 定理的核心就是：为什么这个椭圆的两个焦点就是 p'(z) 的两根。</p>
<p>    首先，让我们来说明，为了证明 Marden 定理，我们可以把三角形 z<sub>1</sub>z<sub>2</sub>z<sub>3</sub> 放置在复平面上的任意一个对我们有利的位置。因为，如果对于复平面上的某一个三角形来说命题是成立的，那么任意地对这个三角形进行缩放、旋转、平移，命题仍然是成立的。为什么？这是因为，对三角形的缩放、旋转、平移，说白了就是对三角形中的各个点进行变换操作 M(z) = αz + β ，其中 α 和 β 是两个固定的复数常数，并且 α ≠ 0 。让 z 与 α 相乘的结果就是对 z 进行缩放和旋转，而 β 则表示在此之后平移量的大小。假设我们的命题对三角形 z<sub>1</sub>z<sub>2</sub>z<sub>3</sub> 成立，对整个复平面进行上述变换后，三角形的三个顶点就分别移到了 M(z<sub>1</sub>) 、 M(z<sub>2</sub>) 、 M(z<sub>3</sub>) 。同时，三角形的内切椭圆以及椭圆的两个焦点也都被顺带着移动了过去，内切椭圆还是内切椭圆，椭圆的焦点也还是椭圆的焦点。另外，原来的多项式是 p(x) = (z – z<sub>1</sub>)(z – z<sub>2</sub>)(z – z<sub>3</sub>) ，变换之后，新的多项式 p<sub>M</sub>(x) 就变成了 (z – M(z<sub>1</sub>))(z – M(z<sub>2</sub>))(z – M(z<sub>3</sub>)) 。假设原椭圆的两个焦点分别是 f<sub>1</sub> 和 f<sub>2</sub> ，我们已经知道了它们正好是 p'(z) 的两根。我们想要确认的就是，新椭圆的两个焦点 M(f<sub>1</sub>) 和 M(f<sub>2</sub>) 正好就是 p<sub>M</sub>‘(z) 的两个根。</p>
<p>    把 p<sub>M</sub>(z) 中的 z 全部用 M(z) 代换，得到：</p>
<p>         p<sub>M</sub>(M(z)) = (M(z) – M(z<sub>1</sub>))(M(z) – M(z<sub>2</sub>))(M(z) – M(z<sub>3</sub>))</p>
<p>    注意到 M(z) – M(z<sub>1</sub>) 就等于 α(z – z<sub>1</sub>) （因为 β 被抵消了），同理，上式的后面两个因式也分别等于 α(z – z<sub>2</sub>) 和 α(z – z<sub>3</sub>) 。于是，整个上式化简为：</p>
<p>         p<sub>M</sub>(M(z)) = α<sup>3</sup>(z – z<sub>1</sub>)(z – z<sub>2</sub>)(z – z<sub>3</sub>)</p>
<p>    即：</p>
<p>         p<sub>M</sub>(M(z)) = α<sup>3</sup> · p(z)</p>
<p>    现在，在等式两边同时取导数（注意到 M'(z) = α ），于是得到：</p>
<p>         α · p<sub>M</sub>‘(M(z)) = α<sup>3</sup> · p'(z)</p>
<p>    也就是：</p>
<p>         p<sub>M</sub>‘(M(z)) = α<sup>2</sup> · p'(z)</p>
<p>    这说明，如果 f<sub>1</sub> 是 p'(z) 的根，那么 M(f<sub>1</sub>) 也将是 p<sub>M</sub>‘(z) 的根；类似地，如果 f<sub>2</sub> 是 p'(z) 的根，那么 M(f<sub>2</sub>) 也将是 p<sub>M</sub>‘(z) 的根。这正是我们刚才想要说明的事情。</p>
<p> </p>
<p>         <img alt="image placeholder" >
<p>    为了证明 Marden 定理，我们还有一个准备工作要做。让我们来证明下面这个引理：如图， F<sub>1</sub> 、 F<sub>2</sub> 是给定椭圆的两个焦点，过椭圆外的一点 A 向椭圆作两条切线，切点分别为 G<sub>1</sub> 和 G<sub>2</sub> ，则有 ∠F<sub>1</sub>AG<sub>1</sub> = ∠F<sub>2</sub>AG<sub>2</sub> 。其实，这个引理包含了两种不同的情况，如果把上面的 G<sub>1</sub> 和 G<sub>2</sub> 两个点反过来标，我们将会得到另外一种情况。不过，如果我们证明了在第一种情况下结论始终成立，第二种情况也就自动地获证了。因此，我们可以直接假设 G<sub>1</sub> 和 G<sub>2</sub> 的标法就如上图所示。</p>
<p>         <img alt="image placeholder" >
<p>    证明这个引理需要用到与椭圆有关的一个非常经典的结论：从其中一个焦点出发的光线，射向椭圆内壁的任意一个位置，反射光线总会经过这个椭圆的另外一个焦点。换句话说，在上图当中，过椭圆上的点 T 作切线，则 ∠1 将会等于 ∠2 。你可以在<a href="http://www.matrix67.com/blog/archives/470">这里</a>看到与椭圆的这个性质有关的更多讨论。</p>
<p>         <img alt="image placeholder" >
<p>    现在，沿着切线 AG<sub>1</sub> 将 F<sub>1</sub> 翻折到 H<sub>1</sub> ，那么 H<sub>1</sub> 、 G<sub>1</sub> 、 F<sub>2</sub> 将会共线。类似地，沿着切线 AG<sub>2</sub> 将 F<sub>2</sub> 翻折到 H<sub>2</sub> ，那么 H<sub>2</sub> 、 G<sub>2</sub> 、 F<sub>1</sub> 也将会共线。为了证明 ∠F<sub>1</sub>AG<sub>1</sub> = ∠F<sub>2</sub>AG<sub>2</sub> ，我们只需要证明 ∠F<sub>1</sub>AH<sub>1</sub> = ∠F<sub>2</sub>AH<sub>2</sub> 即可。</p>
<p>    由于 H<sub>1</sub>F<sub>2</sub> = H<sub>1</sub>G<sub>1</sub> + G<sub>1</sub>F<sub>2</sub> = F<sub>1</sub>G<sub>1</sub> + G<sub>1</sub>F<sub>2</sub> = F<sub>1</sub>G<sub>2</sub> + G<sub>2</sub>F<sub>2</sub> = F<sub>1</sub>G<sub>2</sub> + G<sub>2</sub>H<sub>2</sub> = F<sub>1</sub>H<sub>2</sub> ，另外由刚才的翻折可知 F<sub>1</sub>A = H<sub>1</sub>A ，并且 F<sub>2</sub>A = H<sub>2</sub>A ，于是三角形 AH<sub>1</sub>F<sub>2</sub> 和三角形 AF<sub>1</sub>H<sub>2</sub> 全等。这告诉我们 ∠H<sub>1</sub>AF<sub>2</sub> = ∠F<sub>1</sub>AH<sub>2</sub> ，同时减去一个公共部分后即得 ∠F<sub>1</sub>AH<sub>1</sub> = ∠F<sub>2</sub>AH<sub>2</sub> ，引理也就证到了。</p>
<p> </p>
<p>    现在，我们已经准备好证明 Marden 定理了。我们首先说明，以 p'(z) 的两根为焦点的椭圆，如果经过三角形 z<sub>1</sub>z<sub>2</sub>z<sub>3</sub> 某条边上的中点，则它一定会与这条边相切。为此，我们把三角形的三个顶点摆放到复平面上的 -1 、 1 和 w = a + bi 三个位置，其中 b &gt; 0 ，于是 p(z) = (z – 1)(z + 1)(z – w) = z<sup>3</sup> – w · z<sup>2</sup> – z + w 。对 p(z) 求导后得 p'(z) = 3 · z<sup>2</sup> – 2 · w · z – 1 。</p>
<p>         <img alt="image placeholder" >
<p>    假设 p'(z) 的两根是 f<sub>1</sub> 和 f<sub>2</sub> ，则两根之和 f<sub>1</sub> + f<sub>2</sub> = 2 · w / 3 ，两根之积 f<sub>1</sub> · f<sub>2</sub> = – 1 / 3 。前一个式子说明了 f<sub>1</sub> 和 f<sub>2</sub> 当中至少有一个在 x 轴上方，而在后一个式子中， f<sub>1</sub> · f<sub>2</sub> 居然没有虚数部分，这就说明了 f<sub>1</sub> 和 f<sub>2</sub> 其实都在 x 轴上方，并且 θ<sub>1</sub> + θ<sub>2</sub> = 180° 。因而，如果以 f<sub>1</sub> 和 f<sub>2</sub> 为焦点，作一个过原点 0 的椭圆，则 x 轴就是一条经过该点的直线，它满足 ∠1 = ∠2 ，这表明 x 轴就是椭圆在该点处的切线。而 x 轴其实就是三角形的底边，原点 0 正是三角形底边的中点！</p>
<p>    由于以同一对点为焦点只能作出一个与给定直线相切的椭圆，因而这就顺便说明了，以 p'(z) 的两根为焦点的椭圆，如果与三角形 z<sub>1</sub>z<sub>2</sub>z<sub>3</sub> 的某条边相切，则它一定会与这条边切于中点处。</p>
<p> </p>
<p>    最后我们来说明，以 p'(z) 的两根为焦点的椭圆，如果与三角形 z<sub>1</sub>z<sub>2</sub>z<sub>3</sub> 的其中一条边相切了，则它一定会与三角形的三条边都相切。由刚才的推论可知，所有的切点都将会是中点， Marden 定理就证到了。这一次，让我们把三角形的三个顶点放在 0 、 1 、 w = a + bi 三个位置，其中 b &gt; 0 。稍后我们将会看到，以 p'(z) 的两根为焦点并且切于底边的椭圆也会与 0w 相切。由对称性，它一定也会和第三条边相切。</p>
<p>    取 p(z) = z(z – 1)(z – w) = z<sup>3</sup> – (1 + w) · z<sup>2</sup> + w · z 。求导得： p'(z) = 3 · z<sup>2</sup> – 2 · (1 + w) · z + w 。</p>
<p>         <img alt="image placeholder" >
<p>    假设 p'(z) 的两根是 f<sub>1</sub> 和 f<sub>2</sub> 。刚才我们已经知道了， f<sub>1</sub> 和 f<sub>2</sub> 一定都在 x 轴的上方。不过这一次，两根之积 f<sub>1</sub> · f<sub>2</sub> 等于 w / 3 。这告诉了我们什么？这告诉了我们， θ<sub>1</sub> + θ<sub>2</sub> = θ ，换句话说， ∠1 = ∠2 ！假设以  f<sub>1</sub> 和 f<sub>2</sub> 为焦点作了一个椭圆， x 轴正好是一条切线，那么根据前面我们证过的那个结论，经过原点的另一条切线将会满足 ∠1 = ∠2 ，这说明它与 0w 这条线重合。因而， 0w 就是这另外一条切线。这就完成了 Marden 定理的最后一环。</p>
			 ]]></content>
<pubDate>2013-08-31T01:29:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5480</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：把比萨分成若干等份使得至少有一份不含边 ]]></title>
<link>http://www.matrix67.com/blog/archives/5495</link>
<content><![CDATA[ 
		<p>    请你把一个圆形的比萨分成若干个大小形状都相同的部分，使得其中至少有一部分不含有比萨的边儿。换句话说，你需要把一个圆分成若干个全等的部分，其中至少有一个部分不包含任何一段圆周。</p>
<p>         <img alt="image placeholder" >
<p><span id="more-5495"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    答案：如图，首先用 6 条同样半径的 1/6 圆弧把整个圆分成 6 个形如鱼尾的全等图形，然后再沿着对称轴把每个鱼尾分成两半即可。这样，我们便把整个圆分成了大小形状都相等的 12 个部分，其中 6 个部分都不含有任何一段圆周（虽然有一个点在圆周上）。</p>
<p>         <img alt="image placeholder" >
<p>    在这种方案中，分出来的 12 个小块虽然都是全等的，但其中某些小块需要经过翻折后才能彼此重合。我们的下一个问题就是：请你再设计出一种圆的分割方案，使得每个小块都全等，至少有一个小块不含边，并且所有小块都可以仅通过旋转和平移就能与其他小块重合。</p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 </p>
<p>    答案：如图，首先用 12 条同样半径的 1/6 圆弧把整个圆分成 12 个全等的图形。这说明，刚才的每个鱼尾形都还有另一种平分方案。现在，把每个鱼尾形翻过来摆放，就得到满足要求的方案了。</p>
<p>         <img alt="image placeholder" >
<p>题目来源：<a href="http://math.stackexchange.com/questions/481527/slice-of-pizza-with-no-crust">http://math.stackexchange.com/questions/481527/slice-of-pizza-with-no-crust</a></p>
			 ]]></content>
<pubDate>2013-09-03T16:37:35+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5495</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一个与球内接多面体体积有关的问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/5503</link>
<content><![CDATA[ 
		<p>    在所有周长相等的长方形中，正方形拥有最大的面积；在所有周长相等的平面图形中，圆拥有最大的面积；在所有表面积相等的长方体中，正方体拥有最大的体积；在所有表面积相等的立体图形中，球拥有最大的体积。所有这类问题的答案都是越对称的图形越好吗？ George Pólya 在 Mathematical Discovery 一书中的第 15 章里举了下面这个例子。</p>
<p>    在给定圆周上选取四个点构成一个四边形，那么正方形的面积一定是最大的吗？答案是肯定的。只要有哪个点不在相邻两点之间的圆弧的中点处，我们都可以把它移动到这段圆弧的中点处，使得整个图形的面积变得更大。好了，我们现在的问题是，在球面上选取八个点构成一个顶点数为 8 的多面体，那么正方体一定是体积最大的吗？</p>
<p><span id="more-5503"></span><br>
    答案居然是否定的。单位球中的内接正方体，体对角线将会等于球的直径 2 ，那么这个正方体的边长 x 就应该满足 x<sup>2</sup> + x<sup>2</sup> + x<sup>2</sup> = 2<sup>2</sup> ，解得 x = 2 / √<span style="text-decoration:overline">3</span> 。因而，这个正方体的体积就是 (8 / 9) · √<span style="text-decoration:overline">3</span> 。现在，让我们再想象这样一种单位球中的内接多面体：作出赤道面上的内接正六边形，再把它的各个顶点与南北极相连，构成一种由两个正六棱锥拼接而成的立体图形。每一个正六棱锥的底面都是一个边长为 1 的正六边形，其面积为 (3 / 2) · √<span style="text-decoration:overline">3</span> ；由于棱锥的高也是 1 ，因此棱锥的体积就是 (1 / 3) · (3 / 2) · √<span style="text-decoration:overline">3</span> = (1 / 2) · √<span style="text-decoration:overline">3</span> 。两个这样的棱锥拼在一起，总体积就是 √<span style="text-decoration:overline">3</span> ，这比单位球里的内接正方体体积更大。看来，在与几何图形相关的最值问题中，并不是最对称的那个图形就是最好的。</p>
<p>    为什么会出现这种情况呢？其中一种原因是，立方体虽然非常对称，但它的面太少了。可以想象，如果两个多面体内接于同一个球里，并且它们的顶点数相同，那么谁的面更多一些，谁就有希望占据更大的空间。事实上，我们可以推出，对于顶点数目一定的多面体，如果面数达到最大，则每个面都将会是三角形。根据 Euler 公式，多面体的顶点数 V 、棱数 E 和面数 F 满足 E = F + V – 2 ，另外注意到多面体所有面的边数之和为 2 · E （因为每条棱都被算了两次），因而平均每个面的边数就可以表示为 2 · E / F = 2 · (F + V – 2) / F = 2 + (2 · V – 4) / F 。从这个式子中可以看出，当顶点数目一定时，随着面数的增加，多面体平均每个面的边数将会减少。面数最多的情况，也就是多面体平均每个面的边数最少的情况，也就是每个面都是三角形的情况。</p>
<p>    其实，刚才那个双棱锥仍然不是最优解。下图所示的单位球内接多面体也拥有八个顶点，但它的体积更大，约为 1.8157161 。根据我能查到的资料显示，这应该就是体积最大的解了。</p>
<p>      <img alt="image placeholder" >
			 ]]></content>
<pubDate>2013-09-24T22:02:42+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5503</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 怎样把一个钝角三角形分成若干个锐角三角形 ]]></title>
<link>http://www.matrix67.com/blog/archives/5515</link>
<content><![CDATA[ 
		<p>    这是我最喜欢的几何谜题之一：你能否在纸上画一个钝角三角形，然后把它分割成若干个锐角三角形？令人难以置信的是，这竟然是可以办到的！继续看下去之前，大家不妨先自己想一会儿。</p>
<p>      <img alt="image placeholder" >
<p>    每次我在课堂上提出这个问题的时候，学生们总会疯狂而盲目地进行尝试。根据我的观察，绝大多数人都会先画一个不那么钝的钝角三角形（其实这本质上并不会简化我们的问题），然后作出一系列类似于图 1 的尝试，但最后都以失败告终。此时我往往会反复强调：要有方法啊，要有方法！首先，想必很多人已经注意到了，我们必须在钝角里引出一条线（如图 2 所示），这样才能把钝角给消除掉。接下来，则是很少有人意识到的一点：我们不能让这条线一直延伸到对边，否则原三角形将会被分成一个锐角三角形和一个钝角三角形（或者两个直角三角形），这并不能解决根本问题。也就是说，这条线在到达对边前就必须得分岔。最后一个关键的问题就是，分成几岔？显然，分成三岔（如图 3 所示）是不够的，因为这样只能把一个周角分成四份，它们不可能都是锐角。为了让所有的角都是锐角，我们至少要让这条线分成四岔（如图 4 所示）。最后，再把一些没有连起来的点连起来，我们就得到一个像模像样的答案了（如图 5 所示）。</p>
<p><span id="more-5515"></span><br>
    有的读者或许会说，等等，等等，你怎么敢肯定，图 5 中的每个小三角形都是锐角三角形呢？其实，我也不敢肯定。不过，我并没有说图 5 就是最终的答案。为了证明确实有一个钝角三角形能被分成若干个锐角三角形，我们需要给出一个确凿的、能供他人进行验证的例子。图 5 并不是一个确凿的例子，但它给我们提供了构造这种例子的思路，或者更贴切地说，构造这种例子的模板。借助这个模板，我们很容易得到下面这种构造方案。</p>
<p>      <img alt="image placeholder" >
<p>    如图，首先，画一个正五边形 ADEFG 。然后，找出它的中心 O ，将它分别与 A 、 D 、 E 、 F 、 G 相连。最后，延长 AD 和 FE 并交于点 B ，延长 AG 和 EF 并交于点 C 。那么，整个大三角形 ABC 将会成为一个顶角为 108° 的等腰三角形。这就是一个绝对让人信服的例子，我们能精确地算出这里面的每个小三角形的每个内角的度数，从而说明每个小三角形的确都是锐角三角形。</p>
<p> <br>
    那么，能否把任意一个钝角三角形都分割成若干个锐角三角形呢？这下子，问题就变得复杂得多了。为了给出一个肯定的答案，我们必须想出一种能够适用于所有钝角三角形的通用分割方案，并且证明由此产生的小三角形确实都是锐角三角形。这个有名的问题最早出现在 1960 年 3 月的 The American Mathematical Monthly 上，同年 11 月，美国的一位中学数学老师 Wallace Manheimer 给出了下面这个解答。</p>
<p>      <img alt="image placeholder" >
<p>    如图，假设 △ABC 中， ∠BAC 是钝角。作出 △ABC 的内心 I 以及内切圆，将 BI 、 CI 与圆的交点分别记作 M 、 N 。过点 M 作圆的切线，分别与 AB 、 BC 交于 D 、 E ；过点 N 作圆的切线，分别与 AC 、 BC 交于 G 、 F 。最后，把 D 、 E 、 F 、 G 都和内心 I 相连，我们就把整个大三角形分成了 7 个小三角形。</p>
<p>    现在，我们来证明，这些小三角形都是锐角三角形。由于圆的半径垂直于切线，因此 BI⊥DE ；同时， BI 又是 ∠B 的角平分线，因此 △BDE 就是一个等腰三角形。等腰三角形的两个底角一定都是锐角，而这个等腰三角形的顶角 ∠B 也是一个锐角，因此它就是一个锐角三角形。类似地， △CGF 也是一个锐角三角形。另外，五边形 ADEFG 的每个角都是钝角，而容易看出 AI 、 DI 、 EI 、 FI 、 GI 正好都是这些钝角的角平分线，它们把每个钝角都分成了两个大于 45 度的锐角。然而，如果一个三角形有两个大于 45 度的锐角，这个三角形就一定是锐角三角形。因此，五边形 ADEFG 里的五个小三角形也都是锐角三角形了。这样，我们便得到了一种把任意钝角三角形分成 7 个小锐角三角形的方法。</p>
<p> <br>
    1961 年，美国数学家 Verner Hoggatt Jr. 在 The American Mathematical Monthly 上发表了一篇论文，给出了一个更出人意料的结论：不但任意一个钝角三角形都能被分割成若干个锐角三角形，而且任意一个钝角三角形都能被分割成若干个<strong>等腰</strong>锐角三角形（即使这个钝角三角形本身不是等腰的）！让我们来看一看他是怎么做到的。</p>
<p>      <img alt="image placeholder" >
<p>    如图，仍然假设 △ABC 中， ∠BAC 是钝角。还是作出 △ABC 的内心 I ，还是以 I 为圆心，不过这一次，让我们以 IA 为半径作圆。这个圆一定会和 △ABC 交于另外四个点，不妨依次记作 D 、 E 、 F 、 G （注意，这四个交点为什么一定存在，这是需要严格说明的，不过这里我们暂且略去）。显然， IA = ID = IE = IF = IG ，因而圆里的五个小三角形都是等腰三角形。过 I 作三角形三边的垂线段 IH<sub>1</sub> 、 IH<sub>2</sub> 、 IH<sub>3</sub> ，由于内心 I 到三角形三边的距离都相等，因此 IH<sub>1</sub> = IH<sub>2</sub> = IH<sub>3</sub> 。那么， △IAD 、 △IAG 、 △IEF 就成为了这么一组等腰三角形，它们拥有相同的腰长，并且底边上的高也都相等。由此可以推出，它们是一组全等三角形。另外，容易证明 △BIH<sub>1</sub> 和 △BIH<sub>3</sub> 全等，于是 BH<sub>1</sub> = BH<sub>3</sub> ；同时， EH<sub>1</sub> 也是等于 DH<sub>3</sub> 的，因而 BE 是等于 BD 的，可见 △BDE 是一个以 B 为顶点的等腰三角形。根据同样的道理， △CFG 也是一个以 C 为顶点的等腰三角形。由此可知，图中的所有小三角形都是等腰三角形。</p>
<p>    不过，为什么每个小三角形都是锐角三角形呢？别忘了，等腰三角形的两个底角一定都是锐角，因此，我们只需要说明每个小三角形的顶角也都是锐角就行了。 ∠B 和 ∠C 都是锐角，因而 △BDE 和 △CFG 都是锐角三角形了。不难算出， ∠AID 和 ∠AIG 都等于 180° – ∠BAC ，因而 △IAD 和 △IAG 也都是锐角三角形了。 △IEF 和它俩全等，自然也是一个锐角三角形。那么， △IDE 和 △IFG 呢？仔细算一算你会发现， ∠DIE = ∠BAC – ∠B ， ∠FIG = ∠BAC – ∠C ，我们不能保证它们都是锐角。因此，最终我们只得到了一个暂时还不太完美的结果：如果三角形 △ABC 中， ∠A 是钝角，并且 ∠A – ∠B 和 ∠A – ∠C 都小于 90°，那么我们就可以把它分割成 7 个等腰锐角三角形。</p>
<p>      <img alt="image placeholder" >
<p>    如果 ∠A – ∠B 和 ∠A – ∠C 当中至少有一个大于等于 90° ，分割方案就会失效，这时又该怎么办呢？ Verner Hoggatt Jr. 想到了极其聪明的一招。如图，仍然假设 ∠BAC 是钝角。剩下的两个角 ∠B 和 ∠C 都是锐角。不妨假设其中 ∠B ≤ ∠C 。我们先在 BC 上截取 BD ，使得 BD = BA （由于大角对大边， BC &gt; BA ，因此这是一定能办到的）。 △BAD 便成了一个以 B 为顶点的等腰三角形。由于顶角 ∠B 是锐角，因而 △BAD 是锐角三角形。有人或许会说，刚才不是说过，这样不能解决根本问题吗？ △DAC 仍然是一个钝角三角形呀？不过，这次就不一样了： △DAC 将会满足， ∠1 – ∠2 和 ∠1 – ∠3 都小于 90° ！这是因为：</p>
<p>      ∠1 – ∠2 = (180° – ∠4) – ∠2 = (180° – ∠5) – ∠2 = 180° – (∠5 + ∠2) = 180° – ∠BAC &lt; 90°</p>
<p>    并且由 ∠B ≤ ∠C 可知：</p>
<p>      ∠1 – ∠3 ≤ ∠1 – ∠B = (180° – ∠4) – ∠B = 180° – (∠4 + ∠B) = ∠5 &lt; 90°</p>
<p>    套用刚才的分割方案，我们就可以把 △DAC 分成 7 个等腰锐角三角形，从而把整个三角形 △ABC 分成 8 个等腰锐角三角形了。到此为止， Verner Hoggatt Jr. 就完整地证明了，任意一个钝角三角形都可以被分成最多 8 个等腰锐角三角形。</p>
<p> <br>
      <img alt="image placeholder" >
<p>    从最初的问题出发，我们还可以提出很多其他的扩展问题。比方说，一个正方形最少能被分成多少个锐角三角形？数学趣题大师 Martin Gardner 曾经考虑过这个问题。他“想了好几天，一度以为分成 9 个是最少的，然后就突然想到了一种分成 8 个的方法”，如上图所示。他觉得 8 个锐角三角形应该是最少的了，但却不能证明这一点。随后，数学圈子里出现了好几个严密程度不同的证明。值得一提的是，这个问题还曾经作为一道题目，出现在了 1967 年的 IMO 候选题里。</p>
<p>      <img alt="image placeholder" >
<p>    同样地，我们也可以问，一个正方形最少能被分成多少个等腰的锐角三角形？我们可以先像上图那样把正方形分成四个等腰三角形。其中三个等腰三角形已经是锐角三角形了，利用 Verner Hoggatt Jr. 的方法则可以把最下面那个钝角三角形分成 8 个等腰锐角三角形，于是最终把正方形分成了 11 个等腰锐角三角形。然而，注意到最下面那个钝角三角形其实本来就是等腰的，这对于我们来说非常有利；或许把它分成等腰锐角三角形时，分成 8 个并不是必需的。事实上，利用下图所示的方法，我们可以把它分成 7 个等腰锐角三角形，因而最终把正方形分成了 10 个等腰锐角三角形。不过， 10 个究竟是不是最少的，这似乎还有待进一步探讨。</p>
<p>      <img alt="image placeholder" >
<p>    类似地，对于任意矩形，或者任意凸四边形，或者任意四边形，或者任意 n 边形来说，如何把它们分成尽可能少的锐角三角形，或者把它们分成尽可能少的等腰锐角三角形，这些问题都还有待继续研究。在计算机图形处理中，我们往往需要对图形进行三角剖分；如果所有三角形都是锐角三角形的话，这会给我们带来很多有用的性质。因此，直到现在，人们仍然有足够的动机和热情去研究图形的锐角三角形剖分。关于最近几年这方面的一些进展以及仍然有待解决的问题，可以参见 Carol Zamfirescu 的这篇论文： <a href="http://math.tricube.de/CTZamfirescu-08.pdf">Survey of two-dimensional acute triangulations</a> 。</p>
			 ]]></content>
<pubDate>2013-10-25T11:48:54+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5515</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 两两接触的等粗且无限长的圆柱体 ]]></title>
<link>http://www.matrix67.com/blog/archives/5521</link>
<content><![CDATA[ 
		<p>    大家在吃饭喝酒时是否注意到了这样的事情：三个人碰杯时，每个人的杯子都能同时和其他两个人的杯子相接触，很完美；但是四个人碰杯时，任一时刻总会有两个人碰不到杯，非常尴尬。有一次和三个好朋友吃饭，四人碰杯时又发生了这种尴尬的情况，突然有一个人异想天开，把他的杯子放到了另外三个杯子的上面，从而实现了四个杯子两两接触！我们自然引出了这样一个问题：如果 n 个全等的圆柱体两两相接触，则 n 最大是多少？</p>
<p>      <img alt="image placeholder" >
<p>    对于不同形状的圆柱体，答案可能是不一样的。 Martin Gardner 在 Hexaflexagons and other mathematical diversions 一书中提到，我们可以精巧地摆放 5 枚硬币，使得它们两两相接触，如上图所示（注意，最底下还藏着一枚硬币）。同时， Martin Gardner 问到，能否摆放 6 支香烟让它们两两接触？一个经典的答案如下：</p>
<p>      <img alt="image placeholder" >
<p><span id="more-5521"></span><br>
    令 Martin Gardner 本人也感到吃惊的是， George Rybicki 和 John Reynolds 指出， 7 支香烟两两接触也是有可能的。他们给出的构造如下：</p>
<p>      <img alt="image placeholder" >
<p>    两两接触的全等圆柱体最多可以有多少个？ 7 个已经是最多的了吗？如果圆柱体的高度与半径之比有所限制，这会对问题的答案产生怎样的影响？这些问题都还有待解决。</p>
<p> <br>
    1968 年， John Littlewood 提出了这样一个问题：在空间中，是否存在 7 个单位半径的<strong>无限长</strong>圆柱体，使得它们两两相接触？这个问题显然更难一些，因为我们没法利用圆柱体的顶面和底面了。</p>
<p>    根据 <a href="http://www.mathpuzzle.com">MathPuzzle</a> 的消息，最近， Sándor Bozóki 、 Tsung-Lin Lee 和 Lajos Rónyai <a href="http://arxiv.org/abs/1308.5164">解决了</a>这个问题。他们建立了一个非常非常庞大的方程组，里面有 20 个未知数以及 20 个方程：</p>
<p>      <img alt="image placeholder" >
<p>    通过某些数值计算方法，他们得到了两组不同的解。其中一组解如下：</p>
<p>      <img alt="image placeholder" >
<p>    下面则是另外一组解：</p>
<p>      <img alt="image placeholder" >
<p>    2005 年， András Bezdek 证明了任意 25 个无限长的等粗圆柱体中，总存在两个相离的圆柱体，从而说明了满足要求的圆柱体数目 n 存在一个上界。那么， n 的最大值是否就是 7 呢？这个问题目前也没有定论。</p>
			 ]]></content>
<pubDate>2013-11-18T16:34:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5521</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：庄家的秘密序列 ]]></title>
<link>http://www.matrix67.com/blog/archives/5523</link>
<content><![CDATA[ 
		<p>    下面是 2013 年 9 月 <a href="http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/challenges/September2013.html">IBM Ponder This</a> 的谜题。</p>
<p>    A 和 B 在赌场玩一个游戏，他们要协同作战与庄家对抗。游戏一轮一轮地进行，每一轮的规则都是一样的：首先 A 赌 0 和 1 当中的某个数字，然后 B 再赌 0 和 1 当中的某个数字，最后庄家给出 0 和 1 当中的某个数字；如果所有的三个数字都相同，则 A 和 B 获胜，否则庄家获胜。游戏前， A 和 B 可以商量一个对策，但游戏一旦开始，除了下赌注本身之外，两人不能再有其他任何形式的交流了。</p>
<p>    容易看出，如果 A 和 B 都随机下注，他们只有 25% 的获胜概率。然而，如果两人事先约定，在每一轮中， B 总是跟着 A 下注， A 赌什么 B 就赌什么，那么他们获胜的概率就会提高到 50% 。但是，不管采用哪种方案，在最坏情况下，两人都有可能一次也不能获胜。</p>
<p>    有意思的事情出现了。在游戏开始前两人商量策略的时候，两人突然意识到， B 有办法偷到庄家将会在游戏中使用的 01 序列。也就是说，游戏开始后，每一轮里庄家要出什么， B 都将会知道。但是，一旦 B 拿到了这个 01 序列， B 就不能和 A 交流了。在这样的条件下，两人能做得比刚才更好吗？能！比如说，两人可以保证在最坏情况下也有至少 50% 的获胜次数： B 可以在第 1, 3, 5, 7, … 轮游戏中赌下一轮庄家将会出的那个数（这相当于暗示了 A 下一轮赌什么），两人便能保证在第 2, 4, 6, 8, … 轮游戏中获胜了。</p>
<p>    我们的问题是：假设游戏一共有 9 轮，设计一种策略使得 A 和 B 能够保证至少 6 次胜利。</p>
<p><span id="more-5523"></span></p>
<p> <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    下面是 Michael Brand 给出的答案。</p>
<p>    首先，我们将给出一种这样的策略，使得当游戏共有 n = 3k + 1 轮的时候，两人可以保证至少 m = 2k 轮获胜。我们把这 3k + 1 轮游戏分成 k + 1 节：第一轮单独一节，接下来每三轮一节。只要 A 和 B 能做到每一节最多只错一个，就能保证 2k 轮的胜利了。 A 和 B 的基本策略就是，如果某一轮中 A 赌的数字和庄家相同，那么 B 就跟着 A 赌一样的，从而在本轮获胜；仅当 A 赌的数字和庄家不同，此轮已经必败无疑了的时候， B 才利用这一机会向 A 发信号。两人约定，此时 B 赌的数字就是下一节里出现得更多的数字。等这一轮结束后，如果 A 发现自己赌的数字是错误的，他就知道了 B 刚才是在发信号；在下一节游戏里， A 就全赌 B 刚才说的那个数字。容易看出，如果第一轮中 A 瞎赌的数字正好与庄家不符，并且今后每一节里庄家都会出两个 0 一个 1 或者两个 1 一个 0 ，那么每一节都会恰好输一次。</p>
<p>    麻烦就麻烦在，如果 A 瞎猜猜对了，依照策略 B 也会跟着往对的猜，则他们可能会毫无准备地进入全新的、还没被暗示过的一节，这反而会打乱我们的计划。不过没关系，只要每节里面仍然只有最多一个错误就行。因此，如果两人在新的一节中继续瞎猜并且实现了三连胜，这对我们没有影响；即使两人靠瞎猜赢得了前两轮，这对我们也没有影响。但是，如果 A 在本节的第一轮或者第二轮就出错了，问题就麻烦了。如果发生了这种情况，则 B 立即修改策略：利用此次错误向 A 发送信号，告诉 A <strong>这一节</strong>还剩下的两轮或者一轮中哪个数字出现得更多（如果这一节还剩下两轮，并且庄家会出两个不同的数字，此时无所谓哪个数字出现得更多，那么 B 就随便告诉 A 一个数字）。不过，这样一来，本节里可能会出现多达两次的错误。</p>
<p>    不过，想一想，两人是怎么走到这一节的：两人是因为在前一节里全猜对了，才走到这一节的。因此，虽然这一节里会出现两次错误，但前一节里是全对的，因而平均每节的错误次数仍然不超过 1 ，这对我们仍然没有影响。有可能这一节的前一节也发生过错误吗？有可能！但只有这样一种可能：前一节本身也是事先没被暗示过的，他们在那一节里发生了一次错误，并且 B 宣布了那一节剩下几轮里出现得更多的数字，但由于剩下几轮里庄家的数字都是相同的，因而两人在剩下的几轮里全对。然而，走到这个前一节也是由于更前一节发生了类似的情况，等等等等，不断倒推过去，最终总能找到某个全对的一节（有可能是第一节），是它引发了这条特殊的链。在这条链中，各节的错误次数是 0, 1, 1, 1, …, 2 ，平均每节的错误次数仍然不超过 1 。</p>
<p>    这样，我们就有了一种在  n = 3k + 1 轮中保证 m = 2k 轮获胜的策略，它可以适用于任意情形。事实上，当 n = 3k + 2 时， m = 2k + 1 也是可以保证的。我们可以把最后多出来的那一轮看作是新的一节，那么两人走到这一节时，要么这一节已经被暗示过了（两人便会在这一节里取胜），要么这一节没被暗示过（两人便有可能在这一节里出错）。然而，如果这节没被暗示过，那么两人最多只会发生一次错误（因为这一节总共就只有一轮），因而它所在的链中，各节的错误次数依次是 0, 1, 1, 1, …, 1 。不管怎样，我们都能做到每节最多一处错误，且存在某一节全对。考虑到当 n = 3k + 2 时如此分节能得到 k + 2 节，因而错误数最多 k + 1 个，获胜的次数也就有至少 2k + 1 次了。</p>
<p>    好了，现在回到 n = 9 ， m = 6 的情形。目前，它不属于我们之前解决过的任意一种情形。我们还是把这 9 轮游戏分成 4 节，第 1 轮一节，第 2 到 4 轮一节，第 5 到 7 轮一节，第 8 轮和第 9 轮一节。我们还能像刚才那样，保证 4 节当中只有 3 节会出错（且最多出一次错），剩余一节全对吗？这回不行了。刚才的最后一节只含一轮，如果有暗示则必然全对；但现在的最后一节包含两轮，这两轮的数字相同的话还好说，如果正好是有一个 0 有一个 1 的话，暗示了也拿不到全对。</p>
<p>    不过，只要之前出现过某一节全对的情况，事情都是可以弥补的。比方说，如果两人在第一节就全对了，两人就可以把剩余的 8 轮看作是一次新的游戏，利用 n = 3k + 2 时的策略保证 5 次胜利，加上第一节猜对的那一个，一共就是 6 次胜利了；或者，两人在第二节首次全对，两人便能利用 n = 3k + 2 时的策略在剩余的 5 轮中获得 3 次胜利，加上刚才第二节里的 3 连胜，于是又得到了 6 次胜利。如果两人在第三节才出现全对呢？两人将会在无暗示的情况下闯入最后一节，他们可以在这一节中赢得至少一轮，加上第二节的 2 次胜利和第三节的 3 次胜利，总共依然是 6 次胜利。</p>
<p>    怕就怕这样的情况：最后一节是两个相异的数字，并且每一节都已经在上一节中暗示过了。换句话说，现在唯一解决不了的情况是： A 在第一轮猜错了，并且第 2 到 4 轮的三个数字不全相同，并且第 5 到 7 轮的三个数字也不全相同，并且第 8 轮和第 9 轮是两个不同的数字。在这种情况下，两人会在每一节都出错一次，无法保证 6 次胜利。</p>
<p>    怎么办呢？最强大的部分就来了：此时， B 通过违背策略来给 A 发信号！如果 A 发现 B 违背了策略， A 就知道两人现在正处于这种唯一无法处理的情况；究竟是怎么违背策略的，这本身就会构成一种暗示。两人具体的做法如下。</p>
<p>    如果在第 5 到 7 轮中，只出现了一次的数字是第 5 轮中的数字，那么 B 就在第 2 到 4 轮里本来可以获胜的两轮中故意搞错一次（这一轮结束后 A 将会立即发现 B 违背了策略）。 B 可以选择在哪一轮里搞错，从而暗示第 8 轮和第 9 轮的两个数字是 01 还是 10 。结合目前两人所处的情形， A 就能推出第 5 轮到第 9 轮的全部数字。</p>
<p>    如果在第 5 到 7 轮中，只出现了一次的数字是第 6 轮中的数字，那么 B 在第 1 轮中改为发送第 2 到 4 轮中出现次数更<strong>少</strong>的数字（第 4 轮后 A 将会发现 B 违背了策略）。在第 2 轮到第 4 轮中， B 跟着 A 一道把只出现了一次的那个数字弄对，另外两轮则用来发信号，分别指示第 5 到 7 轮中出现次数更多的是哪个数字，以及第 8 到 9 轮是 01 和 10 中的哪种情况。</p>
<p>    如果在第 5 到 7 轮中，只出现了一次的数字是第 7 轮中的数字（这说明第 5 轮和第 6 轮是本来应该获胜的两轮），那么 B 就在第 5 轮和第 6 轮当中故意搞错一次，究竟在哪一次搞错，则暗示了第 8 到 9 轮的数字是 01 还是 10 。 A 将会立即知道 B 违背了策略，并且根据已有信息，推出第 7 轮到第 9 轮的正确数字。</p>
<p>    不管是哪种情况，两人都能保证 6 次胜利。</p>
<p>    在写这篇文章时， Michael Brand 本人给予了很大的帮助，特此感谢。</p>
<p> <br>
    [附注] 在答案当中，“怕就怕这样的情况”之前的部分其实完全可以替换成一些更简单的方案，比如说：如果某一轮中 A 赌对了， B 就跟着赌一样的；如果某一轮中 A 出错了， B 就在该轮里暗示最近的还没被暗示过的三轮中出现次数更多的数字（如果剩下还没被暗示过的轮数只有一轮或者两轮了，那么就暗示这一轮或者两轮里出现次数更多的数字）。这意味着，当 A 进入瞎猜的状态时，如果他碰巧猜错了， B 暗示的将会是接下来的三轮中出现得更多的数字。这种方案会简单得多，并且由此带来的胜率往往会大于 2/3 。但是，它的不足之处就在于，在轮数有限的情况下，这种策略的实施情况捉摸不定，变数太多。当 n = 9 时，不能实现 6 次胜利的情况仍然是唯一的（即上面提到的那种情况），但我们很难证明这一点（如果你想到了很好的证明方法，请记得告诉我）。因而，上述答案中实际采用的是一个看上去更加曲折复杂的策略，它的好处就是实施过程会更有规律，更有利于后面的分析。</p>
			 ]]></content>
<pubDate>2013-11-20T03:27:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5523</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：Kontsevich的单人跳棋游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/5546</link>
<content><![CDATA[ 
		<p>      <img alt="image placeholder" >
<p>    有一个无限大的棋盘，棋盘左下角有一个大小为 n 的阶梯形区域，其中最左下角的那个格子里有一枚棋子，如左图所示。你每次可以把一枚棋子“分裂”成两枚棋子，分别放在原位置的上边一格和右边一格。你的目的是通过有限次的操作，让整个阶梯里不再有任何棋子。下图所示的是 n = 2 时的一种解法。我们的问题是：对于那些 n ，这个游戏是有解的？</p>
<p>      <img alt="image placeholder" >
<p><span id="more-5546"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    当 n = 1 时，第一步直接就解了。刚才我们已经展示了 n = 2 时的解法。不可思议的是，对于其他所有的 n ，这个游戏都是无解的！下面我们就来证明这一点。</p>
<p>      <img alt="image placeholder" >
<p>    像上图那样给棋盘中的格子赋值，这样的话，每一步操作都会把棋子从赋值为 x 的格子裂变到两个赋值为 x/2 的格子里，这不会改变所有棋子所在格子的数字之和。因此，所有棋子所在格子的数字之和就是一个不变量，这个值初始时是 1 ，今后则永远都是 1 。接下来，我们能立即得出，所有 n ≥ 4 的情况都是无解的。容易看出第一行所有格子的数字之和是 2 ，第二行所有格子的数字之和是 1 ，接下来几行的数字之和则依次为 1/2, 1/4, 1/8, …，因而整个棋盘上的所有数字之和是 2 + 1 + 1/2 + 1/4 + 1/8 + … = 4 。然而，当 n = 4 时，阶梯区域里的所有数之和为 1 + (1/2) × 2 + (1/4) × 3 + (1/8) × 4 = 13/4 ，空白区域里的所有数之和仅为 4 – 13/4 = 3/4 。因此，我们不可能把所有棋子都移到空白区域里。当然，当 n &gt; 4 时，空白区域里的数字之和会更小，把所有棋子都移到空白区域里就更不可能了。</p>
<p>      <img alt="image placeholder" >
<p>    但是，上面的推理并不能直接适用于 n = 3 时的情况：所有空白区域的数字之和为 4 – 1 – (1/2) × 2 – (1/4) × 3 = 5/4 &gt; 1 ，这么看上去，把所有棋子都移到空白区域似乎是有可能的。然而注意到，不管怎么操作，第一行都只有一枚棋子，第一列也只能有一枚棋子。考虑到这一点，空白区域里的数字之和似乎就又不够了。为了让棋局所对应的数值尽可能地大，最理想的情况便是，第一行的那个棋子正好位于标有 1/8 的格子里，第一列的那个棋子也位于标有 1/8 的格子里，此时第一行和第一列的其他格子都不能再有棋子了，因而我们还得从 5/4 当中减去两个 (1/16 + 1/32 + … ) ，结果等于 5/4 – (1/8) × 2 = 1 。另外，有限次操作不可能让棋子占满中间那片无限大的空白区域，因而棋局可以达到的数字之和严格地小于 1 。如果第一行的那个棋子更靠右，或者第一列的那个棋子更靠上，棋局可以达到的数字之和还会更小。因此，当 n = 3 时，游戏是保证无解的。</p>
<p>    上述游戏是由 Maxim Kontsevich 在 1981 年提出的。有一个类似的跳棋游戏叫做 <a href="http://www.matrix67.com/blog/archives/4595">Conway 的士兵</a>，解决方法也是赋值法，并且更神奇的是，在赋值的过程当中竟然出现了黄金分割 φ 的身影！</p>
			 ]]></content>
<pubDate>2014-01-30T00:03:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5546</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：免分割线的多米诺骨牌覆盖方案 ]]></title>
<link>http://www.matrix67.com/blog/archives/5550</link>
<content><![CDATA[ 
		<p>    问题：能否用多米诺骨牌既无重复又无遗漏地覆盖一个 6 × 6 的棋盘，使得棋盘上的每一条水平线和每一条竖直线都会穿过至少一个多米诺骨牌？举个例子，下图所示的棋盘覆盖方案就是不满足要求的，因为棋盘的第二条水平线不会切断任何一个多米诺骨牌。</p>
<p>      <img alt="image placeholder" >
<p><span id="more-5550"></span><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
    满足要求的棋盘覆盖是不存在的。我们有一个非常漂亮的证明。注意到，任意一条水平线都会把整个棋盘分成上下两部分，这两部分所包含的小正方形的个数都是偶数。那些完全在这条线上面的多米诺骨牌会占据其中偶数个格子，那些完全在这条线下面的多米诺骨牌也会占据其中偶数个格子，因而棋盘的上下两部分各剩下了偶数个格子，这些格子就留给了那些穿过了这条水平线的多米诺骨牌来占据。每一个穿过了这条线的多米诺骨牌都会在上下两部分棋盘各占据一个格子，因此为了完全覆盖棋盘，这样的多米诺骨牌必须得有偶数个才行。结论就是：在一个满足要求的棋盘覆盖方案中，每条水平线都会穿过至少两个多米诺骨牌。同理，每条竖直线也都会穿过至少两个多米诺骨牌。然而，在 6 × 6 的棋盘中，水平线和竖直线一共有 10 条，每条线上都有两个多米诺骨牌，这显然是不现实的，因为整个棋盘里一共也只能放下 18 个多米诺骨牌。</p>
<p>    有趣的是，棋盘再稍微大一些，这种推理就失效了。在一个 8 × 8 的棋盘中，水平线和竖直线一共有 14 条，它们对应于 28 个多米诺骨牌，这却并不会导致矛盾，因为棋盘里一共能放下 32 个多米诺骨牌。那么， 8 × 8 的棋盘是否存在满足要求的覆盖方案呢？更一般地，对于哪些正整数 M 和 N ，在一个 M × N 的棋盘里存在满足要求的覆盖方案呢？注意， M 和 N 这两个数当中至少得有一个数是偶数，否则整个棋盘将会有奇数个小方格，这根本不可能被多米诺骨牌既无重复又无遗漏地覆盖住。</p>
<p>    不妨假设 M ≤ N 。 M = 1 和 M = 2 的情况基本上可以直接被排除了（不过，这里面有一个特例，即 (M, N) = (1, 2) 可以算作是一个平凡解）。 M = 3 的情况基本上也可以直接被排除，但这可能不大容易看出来。假如一个棋盘只有 3 行，最左边那一列肯定不能全用横向的多米诺骨牌覆盖，否则将会立即产生一条通畅的竖直线，如左图所示。那么，最左边那一列肯定有一个纵向的多米诺骨牌，比如右图中的 1 号多米诺骨牌。于是，覆盖方案会被迫地向右图所示的方向发展，最终会不可避免地出现一条通畅的水平线。</p>
<p>      <img alt="image placeholder" >
<p>    M = 4 的情况也能被排除。最左边的那一列不能全被横着的多米诺骨牌占据，也不能全被竖直的多米诺骨牌占据，剩下的本质不同的可能性就只有下面两种了，这最终都会被迫失败。</p>
<p>      <img alt="image placeholder" >
<p>    接下来该研究的就是 M = 5 的情况。由于 M 、 N 都等于 5 的情况已经被我们排除了（ M 、 N 不能都是奇数），因此我们应该开始考虑 M = 5 并且 N = 6 的情况。这是第一次出现有解的情况：在 5 × 6 的棋盘上，满足要求的覆盖方案是存在的！下图就是其中一种方案，你可以考虑先自己想一会儿再查看答案：</p>
<p>      <img alt="image placeholder" >
<p> <br>
    令人意想不到的是，对于其他所有的情况，满足要求的覆盖方案都是存在的！也就是说，如果我们能用多米诺骨牌既无重复又无遗漏地覆盖 M × N 的棋盘，使得棋盘中的每一条水平线和竖直线都会穿过至少一个多米诺骨牌，则 M 和 N 必须而且只须同时满足下面这些条件：</p>
<p>      (1) M 和 N 至少有一个是偶数；<br>
      (2) M 和 N 都大于 4 ；<br>
      (3) M 和 N 不同时等于 6 。</p>
<p>    刚才，我们已经给出了 M 、 N 分别等于 5 和 6 时的方案。我们便能很快得出，只要 M 、 N 这两个数一个是奇数一个是偶数，满足要求的覆盖方案都是存在的。这是因为，对于任意一个合法的覆盖方案，我们都能按照下面的模式，把它扩展成一个新棋盘下的覆盖方案，使得棋盘的其中一条边的长度不变，另一条边的长度比原来增加 2 个单位。</p>
<p>      <img alt="image placeholder" >
<p>    我们详细解说一下这种扩展模式吧。首先注意到，原覆盖方案的最后一列不可能都是用横向的多米诺骨牌覆盖的，也不可能都是用纵向的多米诺骨牌覆盖的（否则会立即产生一条通畅的竖直线）。因此，最后一列的多米诺骨牌一定是有横有竖的。把这些多米诺骨牌向右移动两个单位，然后用横向的多米诺骨牌填充由此所得的空白，就得到了一个新的方案。新方案的每条线为什么都穿过了至少一个多米诺骨牌呢？为了说明这一点，我们只需要考察新的棋盘中最后那几条竖直线即可。这很容易看出来——刚才的那个“有横有竖”的结论可以保证这些竖直线都不会是畅通的。</p>
<p>    现在，估计大家已经看出来了，为了填上之前埋下的所有坑，我们只差最后一环了：在一个 6 × 8 的棋盘上设计一种满足要求的覆盖方案。这样一来，我们便能从 5 × 6 和 6 × 8 这两个基础布局出发，不断套用刚才的扩展模式，从而为所有应该有解的棋盘提供一个满足要求的解。给出一个 6 × 8 的布局并不容易，但也不算太难，你也可以考虑先想一想，再查看下图所示的答案：</p>
<p>      <img alt="image placeholder" >
<p>    原问题是一道非常经典的问题了，经典的组合数学教材《Introductory Combinatorics》开篇就提过这个例子。后面的探讨则出自 Solomon Wolf Golomb 的《Polyominoes》一书。</p>
			 ]]></content>
<pubDate>2014-01-30T13:11:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5550</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 连分数的一个性质以及它的一个组合解释 ]]></title>
<link>http://www.matrix67.com/blog/archives/5556</link>
<content><![CDATA[ 
		<p>    你知道吗？连分数</p>
<p>      <img alt="image placeholder" >
<p>    而连分数</p>
<p>      <img alt="image placeholder" >
<p>    这两个连分数的分子竟然是相同的！这是为什么呢？《Proofs that Really Count》里面给出了一个有意思的组合学解释。</p>
<p><span id="more-5556"></span><br>
    为了叙述方便，接下来我们统一用下图所示的符号来表示连分数：</p>
<p>      <img alt="image placeholder" >
<p>    我们用 p(a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) 来表示 [a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>] 的最简分数形式的分子，用 q(a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) 来表示 [a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>] 的最简分数形式的分母。于是，我们有</p>
<p>      <img alt="image placeholder" >
<p>    注意到，最后的那个分数已经是最简的了。如果不是的话，这就意味着 p(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) 和 a<sub>1</sub> · p(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) + q(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) 之间有公共的因数，这进一步表明 p(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) 和 q(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) 之间必须要有公共的因数；然而 p(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) 和 q(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) 是 [a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>] 的最简分数形式的分子和分母，它们已经没有公共的因数了。</p>
<p>    因此，连分数的分母就应该满足</p>
<p>      q(a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) = p(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>)</p>
<p>    而连分数的分子则应该满足</p>
<p>         p(a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>)<br>
      = a<sub>1</sub> · p(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) + q(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>)<br>
      = a<sub>1</sub> · p(a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>) + p(a<sub>3</sub>, …, a<sub>n</sub>)</p>
<p>    再结合初始条件 p(a<sub>n</sub>) = a<sub>n</sub> 以及 p(a<sub>n-1</sub>, a<sub>n</sub>) = a<sub>n-1</sub> ·  a<sub>n</sub> + 1 ，我们就得到了连分数分子的一个完整的递推公式。接下来，我们要为这个递推公式赋予一个组合数学上的意义。考虑一个 n × 1 的棋盘，你可以在这个棋盘上放置一些 1 × 1 的砖块或者 2 × 1 的砖块。 1 × 1 的砖块可以叠放起来，但第 i 个位置上的砖块数目不能超过 a<sub>i</sub>； 2 × 1 的砖块则只能单独放置，它的上面和下面都不能有任何别的砖块。我们规定，棋盘的每个位置上都必须放有砖块，不允许出现任何空的位置。假如 n = 6 ，并且 a<sub>1</sub> 到 a<sub>6</sub> 的值依次是 3, 1, 4, 1, 5, 9 ，那么我们的棋盘就如左图所示，右图则是一个合法的砖块放置方案。</p>
<p> <br>
      <img alt="image placeholder" >
<p>    给定 n 的值以及序列 a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub> 后，如何计算满足要求的砖块放置方案数呢？我们可以尝试着采用递推的办法。我们可以把所有的方案分为两大类。其中一个大类就是，第一个位置放有 1 到 a<sub>1</sub> 个 1 × 1 的砖块，这类方案的总数等于 a<sub>1</sub> 乘以在后面 n – 1 个位置放置砖块的方案数；另一个大类则是，第一个位置被一个 2 × 1 的砖块所覆盖，这类方案的总数就直接等于在后面 n – 2 个位置放置砖块的方案数。你会发现，这个组合问题的递推公式与刚才的 p(a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub>) 完全一致，而且容易验证，只在第 n 个位置放砖块有 a<sub>n</sub> 种方式，只在第 n – 1 和第 n 个位置放砖块则有 a<sub>n-1</sub> ·  a<sub>n</sub> + 1 种方式，这也与 p(a<sub>n</sub>) 和 p(a<sub>n-1</sub>, a<sub>n</sub>) 的值是相符的。因而， p(a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub>) 的值正好就是在高度限制分别为 a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub> 的棋盘上放置砖块的方案总数！</p>
<p>    回到本文最初的问题：为什么连分数 [a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>] 和 [a<sub>n</sub>, …, a<sub>3</sub>, a<sub>2</sub>, a<sub>1</sub>] 的分子是相同的呢？现在看来几乎是显然的：因为这两个连分数的分子表示的是两个左右镜像的棋盘的砖块放置方案数，而两个左右镜像的棋盘本质上是相同的，它们的砖块放置方案数显然应该相等。</p>
			 ]]></content>
<pubDate>2014-02-03T00:38:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5556</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 立方和公式的一个组合数学证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/5562</link>
<content><![CDATA[ 
		<p>    观察下面几个式子：</p>
<p>      1<sup>3</sup> = 1； (1)<sup>2</sup> = 1<br>
      1<sup>3</sup> + 2<sup>3</sup> = 9； (1 + 2)<sup>2</sup> = 9<br>
      1<sup>3</sup> + 2<sup>3</sup> + 3<sup>3</sup> = 36； (1 + 2 + 3)<sup>2</sup> = 36<br>
      1<sup>3</sup> + 2<sup>3</sup> + 3<sup>3</sup> + 4<sup>3</sup> = 100； (1 + 2 + 3 + 4)<sup>2</sup> = 100<br>
      …… ……</p>
<p>    大家应该可以猜到，事实上，对于任意正整数 n ，下述等式永远成立：</p>
<p>      1<sup>3</sup> + 2<sup>3</sup> + … + n<sup>3</sup> = (1 + 2 + … + n)<sup>2</sup></p>
<p>    这个恒等式的证明方法有很多很多，今天我看到了一种有趣的组合证明方法，来源于《Proofs that Really Count》的第 8 章。</p>
<p><span id="more-5562"></span><br>
    首先，让我们考虑所有这样的数列：它由 0 到 n 之间的整数组成，长度为 4 ，并且最后一个数严格大于前面所有的数。我们把所有满足要求的数列所组成的集合叫做集合 A 。也就是说：</p>
<p>      A = {(a, b, c, d) | 0 ≤ a, b, c &lt; d ≤ n}

    集合 A 里面有多少元素呢？我们可以这样来计算：最后一个数 d 的值可以从 1 到 n 当中选择，只要 d 选定了，前面的数都可以从 0 到 d - 1 之间任意选择，这一共会产生 d<sup>3</sup> 种选法。于是，集合 A 的元素个数就是 1<sup>3</sup> + 2<sup>3</sup> + … + n<sup>3</sup>。</p>
<p>    接下来，让我们考虑所有这样的数列：它由 0 到 n 之间的整数组成，长度为 4 ，并且第 2 个数严格大于第 1 个数，第 4 个数严格大于第 3 个数。我们把所有满足要求的数列所组成的集合叫做集合 B 。也就是说：</p>
<p>      B = {(x, y, z, w) | 0 ≤ x &lt; y ≤ n 并且 0 ≤ z &lt; w ≤ n}

    集合 B 里面有多少元素呢？我们可以按照下面这种方式来计算。如果 x 选的是 n - 1，那么 y 有 1 种选法；如果 x 选的是 n - 2，那么 y 有 2 种选法……如果 x 选的是 0，那么 y 有 n 种选法。总之，选择合适的 x 和 y 就有 1 + 2 + … + n 种选法。类似地，选择合适的 z 和 w 也有 1 + 2 + … + n 种选法，因而满足要求的数列一共有 (1 + 2 + … + n)<sup>2</sup> 个。</p>
<p>    接下来，我们在 A 、 B 两个集合之间建立一种一一对应的关系，从而证明 1<sup>3</sup> + 2<sup>3</sup> + … + n<sup>3</sup> = (1 + 2 + … + n)<sup>2</sup> 。对于 A 当中的任意一个元素 (a, b, c, d) ：如果 a &lt; b ，那么数列保持原形不变，仍然是 (a, b, c, d) ；如果 a &gt; b ，那么把数列变为 (c, d, b, a) ；如果 a = b ，那么把数列变为 (b, d, c, d) 。容易看出，集合 A 当中的每一个元素都会唯一地对应于集合 B 当中的某个合法的元素。举三个例子：</p>
<p>      (1, 2, 3, 4) → (1, 2, 3, 4)<br>
      (2, 1, 3, 4) → (3, 4, 1, 2)<br>
      (1, 1, 2, 4) → (1, 4, 2, 4)</p>
<p>    反过来，对于 B 当中的任意一个元素 (x, y, z, w) ：如果 y &lt; w ，那么数列保持原形不变，仍然是 (x, y, z, w) ；如果 y &gt; w ，那么把数列变为 (w, z, x, y) ；如果 y = w ，那么把数列变为 (x, x, z, w) 。容易看出，集合 B 当中的每一个元素都能变回为集合 A 当中的元素。因此，集合 A 和集合 B 里的元素确实是一样多的。</p>
			 ]]></content>
<pubDate>2014-02-04T00:02:49+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5562</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Thue-Morse 序列与免平方字符串 ]]></title>
<link>http://www.matrix67.com/blog/archives/5822</link>
<content><![CDATA[ 
		<p>字符串 hello 当中连续出现了两个 l 。字符串 prototype 当中连续出现了两个 ot 。字符串 nonsense 当中连续出现了两个 nse 。如果某个字符串中连续出现了两个相同的片段，换句话说这个字符串里面含有形如 XX 的模式（其中 X 代表一个子串），我们就说这个字符串中含有一个“平方”（square）。如果某个字符串中没有平方出现，我们就说这个字符串是“免平方”的（square-free）。</p>
<p>如果只使用两种字符，比方说字符 0 和字符 1 的话，我们只能构造出一些长度非常有限的免平方字符串。事实上，我们只能构造出以下 6 个免平方字符串： 0 、 1 、 01 、 10 、 010 、 101 。然而，如果允许使用三种字符，比方说字符 0 、 1 、 2 的话，我们不但能够构造出任意长的免平方字符串，还能构造出无限长的免平方字符串。在继续阅读下去之前，你不妨先自己试试看。</p>
<p><span id="more-5822"></span></p>
<p> </p>
<p>让我们先来看一个与刚才的讨论似乎毫不相关的问题。你能找出下面这个序列的规律吗？（考虑到字符串本质上就是一个字符序列，因此下面我们会经常混用“字符串”和“序列”这两个概念。）</p>
<p style="text-align:center">0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1 …</p>
<p>答案：它们分别表示 0, 1, 2, 3, 4, … 的二进制表达中有多少个数字 1 ，其中 0 代表有偶数个数字 1 ， 1 代表有奇数个数字 1 。如果我还没说清楚的话，看看下表你应该就明白了。</p>
<table>
<tr>
<td style="width: 70px">十进制数</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>…</td>
</tr>
<tr>
<td style="width: 70px">二进制数</td>
<td>0</td>
<td>1</td>
<td>10</td>
<td>11</td>
<td>100</td>
<td>101</td>
<td>110</td>
<td>111</td>
<td>1000</td>
<td>1001</td>
<td>1010</td>
<td>1011</td>
<td>…</td>
</tr>
<tr>
<td style="width: 70px">1 的个数</td>
<td>偶数</td>
<td>奇数</td>
<td>奇数</td>
<td>偶数</td>
<td>奇数</td>
<td>偶数</td>
<td>偶数</td>
<td>奇数</td>
<td>奇数</td>
<td>偶数</td>
<td>偶数</td>
<td>奇数</td>
<td>…</td>
</tr>
<tr>
<td style="width: 70px">序列</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>…</td>
</tr>
</table>
<p>我们不妨把这个序列用 t 表示。序列 t 还有很多等价的定义，比方说，我们可以递归地定义，当 n 为偶数时， t(n) = t(n/2) ，当 n 为奇数时，t(n) = 1 – t(n-1) ；最后再规定 a(0) = 0 ，整个序列就唯一地确定了。你会发现，定义方式虽然是新的，但是背后的实质仍然没变。如果 n 是偶数，那么 n 的二进制表达的最后一位就是数字 0 ，除以 2 其实就相当于是去掉这个数字 0 ，数字 1 的个数的奇偶性显然没变。如果 n 是奇数，那么 n 的二进制表达的最后一位就是数字 1，而 n – 1 的二进制表达的最后一位则是数字 0 ，这两个二进制数仅在最后一位有所不同，因此数字 1 的个数的奇偶性肯定是相反的。因而，不断这样递推下去，最后得到的序列与刚才的序列 t 一模一样。由于对于所有的偶数 n ， t(n) = t(n/2) 始终成立，因此这个序列还有一个非常炫的性质：把序列中的 t(1), t(3), t(5), … 都去掉，仅保留 t(0), t(2), t(4), … ，由此得到了一个新的无穷序列，它和原来的序列完全相同！另外，由于对于所有的奇数 n ， t(n) = 1 – t(n-1) = 1 – t((n-1)/2) 始终成立，你也可以选择去掉 t(0), t(2), t(4), … ，保留 t(1), t(3), t(5), … ，由此得到一个新的无穷序列，它和原序列的每一项都正好相反。</p>
<p>在介绍序列 t 时，很多地方会采用另一种等价的定义方式：从 0 出发，不断执行“取反并后置”的操作，最终得到的序列就是序列 t 。所谓“取反”，就是把所有的 0 全部变成 1 ，把所有的 1 全部变成 0 ；所谓“后置”，就是把所得的字符串接在当前字符串的后面。从 0 出发，取反后得 1 ，把它加在 0 后面便得到 01 ； 01 取反后得 10 ，把它加在 01 后面便得到 0110 ； 0110 取反后得到 1001 ，把它加在 0110 后面便得到 01101001 ……不断这样下去，我们就会得到序列 t 。</p>
<p style="text-align:center">0 → 01 → 0110 → 01101001 → 0110100110010110 → …</p>
<p>为什么？因为这种序列生成法的本质仍然是在统计二进制数的数字 1 的个数。我们不断地根据二进制数的规律，利用 t(0) 到 t(2<sup>n</sup> – 1) 的值，推出 t(2<sup>n</sup>) 到 t(2<sup>n+1</sup> – 1) 的值。比方说，序列 t 的前 4 个数分别代表 00, 01, 10, 11 这 4 个二进制数中数字 1 的个数的奇偶性，那么序列 t 接下来的 4 个数就应该分别代表 100, 101, 110, 111 这 4 个二进制数中数字 1 的个数的奇偶性。前 4 个二进制数与后 4 个二进制数的区别仅仅在于最前面的那个数字 1 ，因而它们所含的数字 1 的个数的奇偶性应该正好相反。因此，如果序列 t 的前 4 个数分别是 0, 1, 1, 0 ，那么序列 t 接下来的 4 个数就应该完全反过来，分别是 1, 0, 0, 1 了。</p>
<p> </p>
<p>从 1906 年到 1914 年，挪威数学家 Axel Thue 发表了一系列论文，第一次对这个序列进行了细致的研究，成为了 combinatorics on words 这个新的数学分支的开山之作。 1921 年，美国数学家 Marston Morse 把 Thue 提出的序列用在了微分拓扑上，因而这个序列最终被命名为了 Thue-Morse 序列。</p>
<p>Thue-Morse 序列有很多非常漂亮的性质。如果某个字符串中连续出现了两个相同的片段，但它们有一个字符的交叉，换句话说这个字符串当中出现了形如 aXaXa 的模式，其中 X 代表一个子串， a 代表一个字符，那么我们就说 aXa 在这个字符串当中发生了“重叠”（overlap）。例如，单词 banana 当中的 ana 就出现了重叠，单词 Mississippi 中的 issi 也出现了重叠。如果某个字符串中没有重叠出现，我们就说这个字符串是“免重叠”的（overlap-free）。下面我们就来证明 Thue-Morse 序列的一个最为重要的性质：它是免重叠的。</p>
<p>我们采用反证法。假如 Thue-Morse 序列存在重叠子串，那么在所有的重叠子串中一定有一个最短的重叠子串。这意味着， Thue-Morse 序列将会包含 aXaXa 的模式，其中 X 表示某个子串， a 表示某个字符，并且 X 的长度已经达到最小。首先我们证明， X 的长度不可能是奇数。否则，三个 a 的位置编号的奇偶性相同，因而如果我们从第一个 a 开始，间隔地读出各个字符，就会得到形如 aX’aX’a 的结果，其中 X’ 就是从 X 当中抽出的字符串，长度是 X 的一半（取下整）。然而，前面我们已经提到过 Thue-Morse 序列的性质了：间隔地抽取字符，得到的新字符串要么就是 Thue-Morse 序列，要么取反后就是 Thue-Morse 序列。这说明， aX’aX’a ，或者它取反后的结果，其实就是 Thue-Morse 序列的子串。因而， Thue-Morse 序列当中存在比 aXaXa 更短的重叠现象，这与 X 的长度的最小性矛盾。</p>
<p>接下来我们证明， X 的长度也不可能是偶数。首先注意到， 4n, 4n + 1, 4n + 2, 4n + 3 的二进制表达中，只有最后两位数字不一样，它们依次是 00, 01, 10, 11 。因此， t(4n), t(4n + 1), t(4n + 2), t(4n + 3) 的值要么依次是 0, 1, 1, 0 ，要么依次是 1, 0, 0, 1 。所以，如果我们把 Thue-Morse 序列四个数四个数地看作一组，你会发现 Thue-Morse 序列就是由一个一个的 (0, 1, 1, 0) 和 (1, 0, 0, 1) 组成的。</p>
<p>如果 X 的长度是大于等于 4 的偶数，那么不管 aXaXa 在 Thue-Morse 序列中的什么地方出现，前一个 aXa 里必然会包含某个四元组的中间两项，不妨假设这是 aXa 中的第 i 项和第 i + 1 项。另外，别忘了 X 的长度是一个偶数，因此前一个 aXa 需要向右移动奇数个单位才能和后一个 aXa 重合。这就矛盾了：向右移动奇数个单位后， aXa 的第 i 项和第 i + 1 项将会对应于另一个四元组的前面两项或者后面两项，于是前一个 aXa 的第 i 项和第 i + 1 项是两个相同的数字，后一个 aXa 中的第 i 项和第 i + 1 项是两个不同的数字，这显然是荒谬的。</p>
<p style="text-align:center"><img alt="image placeholder" >
<p>如果 X 的长度等于 2 ， aXa 的长度会非常短，以至于会发生这样的情况：没有任何一个四元组的中间两项落在了前一个 aXa 的范围里，此时前面的推理就失效了。不过没关系，如果真的发生了这种情况， aXaXa 的位置只可能像下图这样，此时前一个 aXa 的第 1 项和第 2 项对应于某个四元组的后两项，但后一个 aXa 的第 1 项和第 2 项就会对应于下一个四元组的中间两项，矛盾依然存在。</p>
<p style="text-align:center"><img alt="image placeholder" >
<p>最后，如果 X 的长度为 0 呢？这就更不可能了。在 Thue-Morse 序列中，任意三个连续的字符都会涵盖到某个四元组的前面两项或者后面两项，因而包含两个不同的数字。因此，在 Thue-Morse 序列中绝不可能有形如 aaa 的子串出现。</p>
<p>综上所述， Thue-Morse 序列中不可能包含形如 aXaXa 的子串，即 Thue-Morse 序列是免重叠的。</p>
<p> </p>
<p>有了这个结论之后，我们就能解决本文最初提到的问题了。借助 Thue-Morse 序列，我们可以得到一个无限长的免平方字符串，其中只含 0 、 1 、 2 三种字符。方法很简单：只需要依次列出 Thue-Morse 序列中相邻两个 0 之间有多少个 1 即可。在 Thue-Morse 序列中，第 1 个数字 0 和第 2 个数字 0 之间夹着 <span style="color: #5fb4e5">2</span> 个数字 1 ，第 2 个数字 0 和第 3 个数字 0 之间夹着 <span style="color: #5fb4e5">1</span> 个数字 1 ，第 3 个数字 0 和第 4 个数字 0 之间夹着 <span style="color: #5fb4e5">0</span> 个数字 1 ，第 4 个数字 0 和第 5 个数字 0 之间夹着 <span style="color: #5fb4e5">2</span> 个数字 1 ……于是，我们就得到了一个以 2, 1, 0, 2 开头的无限字符串。注意，由于 Thue-Morse 序列中不可能出现三个或者三个以上的连续数字 1 ，因此所得字符串中不会出现大于等于 3 的数字，只有数字 0 、 1 和 2 。</p>
<p class="indent">Thue-Morse 序列： 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0…<br>
新的序列：2, 1, 0, 2, 0, 1, 2, …</p>
<p>为什么由此得到的序列是免平方的呢？很简单。如果新的序列里面出现了某个平方，比如 a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>…a<sub>n</sub>a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>…a<sub>n</sub> ，这就意味着 Thue-Morse 序列里出现了 0 1<sup>a1</sup> 0 1<sup>a2</sup> 0 1<sup>a3</sup> 0 … 0 1<sup>an</sup> 0 1<sup>a1</sup> 0 1<sup>a2</sup> 0 1<sup>a3</sup> 0 … 0 1<sup>an</sup> 0 （其中 1<sup>a1</sup> 表示连续 a<sub>1</sub> 个数字 1 ，以此类推），于是形成了重叠子串，与 Thue-Morse 序列的免重叠性矛盾。</p>
<p> </p>
<p>从 Thue-Morse 序列的免重叠性出发，我们还能得出很多有趣的推论。例如， Thue-Morse 序列一定是免立方的，即 Thue-Morse 序列中不存在形如 XXX 的子串。原因很简单：不妨假设 X = aX’ ，那么 XXX 实际上就是 aX’aX’aX’ ，其中 aX’aX’a 形成了重叠子串，又与 Thue-Morse 序列的免重叠性矛盾了。由此可以进一步推出， Thue-Morse 序列永远不会发生循环。原因很简单：如果 Thue-Morse 序列从某处开始发生循环，这就直接与 Thue-Morse 序列的免立方性矛盾了。</p>
<p>同时， Thue-Morse 序列是一个“复现序列”（recurrent sequence），意即 Thue-Morse 序列中的<strong>每一个子串</strong>都会出现无穷多次。这个事实背后的原因也很简单。比方说，我们在 Thue-Morse 序列当中取出 t(6) 到 t(10) 这么一段，它们是 0, 1, 1, 0, 0 ，表示二进制数 0110, 0111, 1000, 1001, 1010 的数字 1 的个数的奇偶性。那么， 0, 1, 1, 0, 0 今后一定会出现无数多次。在数到二进制数 <em>11</em>0110, <em>11</em>0111, <em>11</em>1000, <em>11</em>1001, <em>11</em>1010 时，我们会再一次得到 0, 1, 1, 0, 0 ；在数到二进制数 <em>101</em>0110, <em>101</em>0111, <em>101</em>1000, <em>101</em>1001, <em>101</em>1010 时，我们会再一次得到 0, 1, 1, 0, 0 。这样的机会显然还有无穷多，例如，在数到二进制数 <em>110100100</em>0110, <em>110100100</em>0111, <em>110100100</em>1000, <em>110100100</em>1001, <em>110100100</em>1010 时，我们会再一次得到 0, 1, 1, 0, 0 。</p>
<p>构造一个复现序列很简单，任何一个循环序列即满足要求，比如 0, 1, 0, 1, 0, 1, … 。而 Thue-Morse 序列则告诉了我们：存在不是循环序列的复现序列。</p>
<p> </p>
<p>最后，我们再不加证明地给出两个与 Thue-Morse 序列有关的神奇结论。对于哪些正整数 k ≥ 2 ，存在两个大小相等的整数集合 A = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>} 和 B = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>, …, b<sub>n</sub>} ，使得</p>
<p class="indent">a<sub>1</sub> + a<sub>2</sub> + a<sub>3</sub> + … + a<sub>n</sub> = b<sub>1</sub> + b<sub>2</sub> + b<sub>3</sub> + … + b<sub>n</sub><br>
a<sub>1</sub><sup>2</sup> + a<sub>2</sub><sup>2</sup> + a<sub>3</sub><sup>2</sup> + … + a<sub>n</sub><sup>2</sup> = b<sub>1</sub><sup>2</sup> + b<sub>2</sub><sup>2</sup> + b<sub>3</sub><sup>2</sup> + … + b<sub>n</sub><sup>2</sup><br>
……<br>
a<sub>1</sub><sup>k</sup> + a<sub>2</sub><sup>k</sup> + a<sub>3</sub><sup>k</sup> + … + a<sub>n</sub><sup>k</sup> = b<sub>1</sub><sup>k</sup> + b<sub>2</sub><sup>k</sup> + b<sub>3</sub><sup>k</sup> + … + b<sub>n</sub><sup>k</sup></p>
<p>即集合 A 里的所有数与集合 B 里的所有数从 1 次方和到 k 次方和全都相等？当然，集合 A 和集合 B 必须是两个不同的集合。答案是，对于所有的正整数 k ≥ 2 ，满足要求的解都是存在的。利用 Thue-Morse 序列，我们可以得出一种 n = 2<sup>k</sup> 的构造解，方法如下：取出 Thue-Morse 序列的前 2<sup>k+1</sup> 位，即 t(0), t(1), …, t(2<sup>k+1</sup> – 1)，如果 t(i) = 0 ，就把 i 放进集合 A 里，如果 t(i) = 1 ，就把 i 放进集合 B 里。</p>
<table>
<tr>
<td style="width: 42px">i</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
</tr>
<tr>
<td style="width: 42px">t(i)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>当 k = 3 时，如上表所示，根据规则，我们应该把 0, 3, 5, 6, 9, 10, 12, 15 分为一组，把 1, 2, 4, 7, 8, 11, 13, 14 分为另一组。神奇的事情出现了：下面三个等式真的是成立的！</p>
<p class="indent">0 + 3 + 5 + 6 + 9 + 10 + 12 + 15 = 1 + 2 + 4 + 7 + 8 + 11 + 13 + 14<br>
0<sup>2</sup> + 3<sup>2</sup> + 5<sup>2</sup> + 6<sup>2</sup> + 9<sup>2</sup> + 10<sup>2</sup> + 12<sup>2</sup> + 15<sup>2</sup> = 1<sup>2</sup> + 2<sup>2</sup> + 4<sup>2</sup> + 7<sup>2</sup> + 8<sup>2</sup> + 11<sup>2</sup> + 13<sup>2</sup> + 14<sup>2</sup><br>
0<sup>3</sup> + 3<sup>3</sup> + 5<sup>3</sup> + 6<sup>3</sup> + 9<sup>3</sup> + 10<sup>3</sup> + 12<sup>3</sup> + 15<sup>3</sup> = 1<sup>3</sup> + 2<sup>3</sup> + 4<sup>3</sup> + 7<sup>3</sup> + 8<sup>3</sup> + 11<sup>3</sup> + 13<sup>3</sup> + 14<sup>3</sup></p>
<p>Thue-Morse 序列还能帮忙构造幻方。 1977 年， Adler Allan 和 Shuo-Yen Robert Li 给出了一种算法，可以利用 Thue-Morse 序列构造 2<sup>n</sup> × 2<sup>n</sup> 的幻方（其中 n ≥ 2 ）。首先，从左至右从上至下地把 1 到 2<sup>2n</sup> 的数填入 2<sup>n</sup> × 2<sup>n</sup> 的方格里。然后，如果 Thue-Morse 序列中的第 i 个数是 0 （即 t(i – 1) = 0 ），就把 i 从方格里拿出来。最后，把所有拿出来的数倒序放回方格，我们就得到了一个幻方。下图所示的是 n = 2 时的例子。由于 Thue-Morse 序列中的第 1, 4, 6, 7, 10, 11, 13, 16 个数是 0 ，因而我们把这些数从 4 × 4 的方阵中取出来；把它们以相反的顺序放回去后，可以验证，方阵中的每一行、每一列和两条对角线上的数字之和都是 34 。</p>
<table>
<tr>
<td style="width: 42px">i</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
</tr>
<tr>
<td style="width: 42px">t(i – 1)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p><img alt="image placeholder" >
<p> </p>
<p>网上闲逛时偶然看到 Thue-Morse 序列，于是陷入 <a href="http://en.wikipedia.org/wiki/Thue%E2%80%93Morse_sequence">Wikipedia</a> 的相关词条不能自拔，随后又找来了这些词条后面提到的参考文献，狠狠地过了一把 combinatorics on words 的瘾。其实， Thue-Morse 序列还有很多东西值得摆谈，但是精力有限，也就只写到这里了。感兴趣的读者不妨看一看 Combinatorics on Words: Christoffel Words and Repetitions in Words 和 Automatic Sequences: Theory, Applications, Generalizations 这两本书。</p>
			 ]]></content>
<pubDate>2014-03-07T17:39:18+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5822</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 通信复杂度问题：利用特殊机器判断公共元素的存在性 ]]></title>
<link>http://www.matrix67.com/blog/archives/5850</link>
<content><![CDATA[ 
		<p>某个导师要和 A 、 B 两名学生玩一个游戏。导师会把 A 、 B 两名学生分别放进两间小黑屋里，每间屋子里都有一台电脑，这两台电脑之间只有一条通信线路。然后，导师会想一个正整数 n （可能会非常非常大），把它的值告诉这两名学生；再构造出集合 {1, 2, …, n} 的两个子集，分别交给这两名学生。于是，每个人都知道了 n 的值和 {1, 2, …, n} 的一个子集。两人需要合作确定出，他们手中的集合是否包含公共的元素。他们之间交流信息的唯一途径就是那条通信线路，但他们能够使用的流量是有限的。具体能够使用多少 bit 的流量，这可以由他们自己决定，但必须在游戏开始之前（也就是 n 的值确定之前）就定好并告诉导师。</p>
<p>和其他类似的问题一样，在游戏开始之前，两人可以商量一个对策。不过，这一回，两人商量了很久，始终无法找到一个必胜的对策。就在两人快放弃的时候，他们突然发现，两人的通信线路上存在一个“漏洞”：两人都可以不计流量地访问一台特殊的第三方机器，我们不妨把它叫做机器 O 。不过，机器 O 只能做一件事情：从 A 那儿读取一个 1 到 n 的排列，从 B 那儿读取一个 1 到 n 的排列，然后计算出这两个排列复合之后是否恰好含有一个循环，并将计算结果分别告知 A 和 B 。然后，机器 O 就会自动关机，再也不能访问了。也就是说，A 和 B 只能使用机器 O 一次。注意， A 、 B 两人是无法看到对方传给机器 O 的数据的，另外机器 O 只能用于处理 1 到 n 之间的排列，不能处理其他大小的排列。</p>
<p><span id="more-5850"></span> </p>
<p>这里我们简单说明一下复合排列以及循环数量的意思。我们可以把一个排列想象成是 {1, 2, …, n} 到 {1, 2, …, n} 的一种映射关系， A 、 B 两个排列的复合，也就可以看作是每一个数经过 A 、 B 两次映射后的结果。举个例子，假如 n = 7 ， A 给机器 O 发送的是</p>
<p style="text-align:center">(2, 3, 5, 1, 7, 6, 4)</p>
<p>B 给机器 O 发送的是</p>
<p style="text-align:center">(1, 4, 6, 2, 7, 3, 5)</p>
<p>那么机器 O 就会计算这两个排列复合之后的结果：</p>
<p style="text-align:center"><img alt="image placeholder" >
<p style="text-align:center">(2, 3, 5, 1, 7, 6, 4) · (1, 4, 6, 2, 7, 3, 5) = (4, 6, 7, 1, 5, 3, 2)</p>
<p>如果在某个排列当中出现了 a 映射到 b 、 b 映射到 c 、 c 映射到 d 、 d 又映射到 a 一类的情况，我们就说这个排列里有一个循环。注意到 (4, 6, 7, 1, 5, 3, 2) 里面包含 3 个循环： 1 → 4 → 1 ， 2 → 6 → 3 → 7 → 2 ， 5 → 5 。因此，机器 O 将会给 A 、 B 两人各发送一条信息：“复合排列并非只含一个循环”。根据规则，紧接着，机器 O 将会立即关机，永久性地停止服务。</p>
<p>在这样的条件下， A 、 B 两人有必胜的策略吗？</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>A 和 B 有必胜策略。首先，让我们来看一个非常朴素的策略。每个人都按照下面的规则构造一个 1 到 n 的排列：先把自己集合里的所有数都放入正确的位置，再把其余数依次放进往右数第一个空位里（最右边的那个数则放进最左边的空位里）。比方说，当 n = 10 时，如果某个人手中的集合是 {3, 4, 7} ，那么他首先应该把 3, 4, 7 这三个数放进正确的位置里，得到 (_, _, 3, 4, _, _, 7, _, _, _) ，然后再把其他数循环向右挪动一位，于是得到 (10, 1, 3, 4, 2, 5, 7, 6, 8, 9) 。容易看出，如果 A 、 B 两人都这么做了的话，那么对由此得到的两个排列进行复合之后，每一个公共元素都会映射到自己，从而成为一个长度为 1 的循环。此时，机器 O 返回的必然是“含有多个循环”。</p>
<p> </p>
<p>只可惜，这种策略没法保证，当两个集合没有公共元素时，复合排列一定只有一个循环。怎么办呢？没关系。下面我们来证明这样一个有用的结论：此时，如果两个人手中都没有的数正好有奇数个，那么复合排列一定只有一个循环！记住，下面这一大段文字有一个最基本的假设：假设两个集合没有公共元素。</p>
<p>我们用一种新的方法表示 A 和 B 提交的排列。首先，在左右两边都写下 1, 2, 3, …, n 这么一列数。如果 A 的排列中的第 i 个数是 j ，就从左边的 i 出发，画一个箭头指向右边的 j ；如果 B 的排列中的第 i 个数是 j ，就从右边的 i 出发，画一个箭头指向左边的 j 。于是，对于这 2n 个数里的每一个数来说，都有且仅有一个从它出发的箭头，也都有且只有一个指向它的箭头。为了考察 A 、 B 两个排列复合的结果，只需要看一看左边的每个数沿着箭头走到右边，再沿着箭头走回左边后，会到达哪个数即可。当 n = 10 时，如果 A 手中的集合是 {3, 4, 7} ， B 手中的集合是 {1, 10} ，那么整个图就如左图所示。如果 B 手中的集合不是 {1, 10} ，而是 {1, 9, 10} ，那么整个图就如右图所示。</p>
<p style="text-align:center"><img alt="image placeholder" >
<p>现在，假设我们任意找一个数（不管是左边的还是右边的），从这个数出发，沿着箭头不断地走，最终结果会怎样呢？容易看出，我们永远不会走死（因为对于每个数来说，都有一条从这里出发的路），也不会突然走到一个刚才在半途中经过的数（因为对于每个数来说，都只有<strong>一条</strong>通向这里的路），因而最终一定会回到出发点。这说明，图中的任何一个数都在某个“圈”里。但是，根据 A 和 B 构造排列的策略，左边最多只有一个数会指向比自己大的数，右边也最多只有一个数会指向比自己大的数，而这种从小数指向大数的箭头是任何一个圈里必须具有的（除非是那种在两个相同的数之间来回一次形成的长度为 2 的圈，但由于 A 、 B 手中没有公共的数，因而这样的圈是不存在的）。因此，我们得出，整个图里最多只能有两个圈。接下来我们证明，如果两个人手中都没有的数有奇数个，那么整个图里必定只有一个圈。注意到以下三点：</p>
<ol>
<li>一个圈的长度总是偶数。这是因为，每个圈里的元素都是按照“左→右→左→右”的顺序交替的，因而这里面显然含有偶数个元素。</li>
<li>如果数字 i 是 A 有 B 无或者 A 无 B 有的数，那么左边那个 i 和右边那个 i 一定都在同一个圈里。这是因为，如果 A 手中有数字 i ，这就意味着存在一根从左边那个 i 指向右边那个 i 的箭头；如果 B 手中有数字 i ，这就意味着存在一根从右边那个 i 指向左边那个 i 的箭头，不管怎样，这两个 i 都必定在同一个圈里。</li>
<li>假设图中有两个圈。如果数字 i 是两个人手中都没有的数，那么图中的两个 i 一定分属两个不同的圈。这是因为，假设图中有两个圈，这就意味着每个圈里都只有一次从小数走向大数的机会，其余时候都是单向地从大数走到小数，没有回头的机会，要想同时包含这两个 i ，必须借助一个横向连接这两个 i 的箭头。然而，考虑到两个人手中都没有 i ，因此左右两个 i 之间没有任何箭头连接。可见，这两个 i 不可能属于同一个圈，只可能分别位于两个圈里。</li>
</ol>
<p>我们几乎可以立即得出，假设图中有两个圈，那么两个人手中都没有的数一定有偶数个。根据第 2 点，那些一方持有的数总是两个两个地计入同一个圈里，因而每个圈里都已经有偶数个元素了。剩下的数则是两人手中都没有的数，根据第 3 点，每个数都会在两个圈里各出现一次。然而，根据第 1 点，每个圈里的总元素个数必须有偶数个，因而那些两人手中都没有的数一定有偶数个。</p>
<p>反过来，如果两个人手中都没有的数有奇数个，那么整个图中就只有一个圈了。有一个圈说明什么？这说明，从左边的任意一个元素出发，可以先按照 A 所构造的排列转移到右边的某个元素，再按照 B 所构造的排列回到左边的某个元素，不断这么做下去，便可遍历左边的所有元素。这就说明了，两个排列的复合结果一定只含一个循环。我们把这个结论再完整地叙述一下：若两人手中不存在公共元素，并且两人手中都没有的数有奇数个，那么按照之前讲过的方法构造排列，复合结果一定只含一个循环。</p>
<p> </p>
<p>如果 A 和 B 能够合作推出，它们两人手上都没有的数到底是奇数个还是偶数个，问题就解决了。如果两人手中都没有的数有奇数个，两人可以直接使用上述策略，机器 O 回答“多个循环”，当且仅当两人手中有公共的元素。如果两人手中都没有的数有偶数个呢？两人就互相通告一下数字 1 在不在自己手中。如果两人手中都没有数字 1 ，那么 A 就修改自己的集合，把数字 1 添加进去；如果某个人手中有数字 1 ，另一个人手中没有数字 1 ，那么前者就把数字 1 从自己的集合中去掉。如此修改集合不会改变公共元素的存在性，但两人手中都没有的数就会变为奇数个，之前的策略就又可以使用了。当然，这里还有一种可能性：两个人手中都有数字 1 。此时，两人根本无需任何策略，直接宣布存在公共元素即可。</p>
<p>因此，我们最后的问题就是：两人如何合作推出他们手上都没有的数究竟有奇数个还是偶数个？这乍看上去非常困难，不过注意到，两人可以假设他们手上没有公共的元素，然而在这个假设下，刚才的任务是很容易完成的： A 和 B 可以互相通告一下自己手中有多少个数，然后用 n 减去 A 手中的元素个数，再减去 B 手中的元素个数，得到的就是两个人手中都没有的元素个数了。由于 n 的值有可能非常大，每个人手中的数都有可能很多很多，因此互相通告元素个数的时候究竟会花费多少流量，事先是没法预估出来的。不过没关系，两人只需要推出双方都没有的元素个数的奇偶性，因此两人只需要互相通告自己手中的元素个数的奇偶性即可。</p>
<p>因而，我们就得到了一个完整的必胜策略：</p>
<ol>
<li>A 、 B 两人互相给对方发送一个 bit 的信息，告诉对方数字 1 在不在自己的集合当中。</li>
<li>如果两人手中都有数字 1 ，则表明两人手中有公共元素，协议立即结束；否则，协议继续进行。</li>
<li>A 、 B 两人互相给对方发送一个 bit 的信息，告诉对方自己的手中有奇数个数还是偶数个数。</li>
<li>如果刚才互发的两个 bit 相同并且 n 为偶数，或者刚才互发的两个 bit 不同并且 n 为奇数，则两人按照下述约定修改自己的集合：有数字 1 的人把数字 1 去掉，都没有的话 A 就把数字 1 给加进去。</li>
<li>A 、 B 两人按照之前说过的方法构造排列，然后发送给机器 O 。</li>
<li>若机器 O 返回“存在多个循环”，则表明两人手中有公共元素；若机器 O 返回“只有一个循环”，则表明两人手中没有公共元素。</li>
</ol>
<p>排除掉与机器 O 之间的通信，整个协议最多只会耗费 4 个 bit 的流量。换句话说， A 、 B 两人只需要向导师申请 4 个 bit 的流量就够了。</p>
<p>题目来源：<a href="http://www.brand.site.co.il/riddles/201010q.html">http://www.brand.site.co.il/riddles/201010q.html</a></p>
<p>如果你对这个问题有兴趣，你一定会喜欢：<a href="http://www.matrix67.com/blog/archives/5342">http://www.matrix67.com/blog/archives/5342</a></p>
			 ]]></content>
<pubDate>2014-03-18T16:45:00+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5850</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 保加利亚单人纸牌游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/5865</link>
<content><![CDATA[ 
		<p>保加利亚单人纸牌游戏（Bulgarian solitaire）的玩法如下：</p>
<blockquote><p>取出 45 张牌，然后把它们随意分成若干堆。接下来，从每一堆里各取一张牌，叠在一起形成一堆新的牌。不断这样做下去，如果某个时候桌面上正好有 9 堆牌，并且各堆牌数分别为 1, 2, 3, 4, …, 9 ，你就获胜了。</p></blockquote>
<p>乍看上去，如果初始局面设定不佳，游戏很可能会陷入某个循环，从而永远无法获胜。然而， 1981 年，丹麦数学家 Jørgen Brandt 证明了，对于任意一个初始局面（包括把所有牌摆成 1 堆，以及把所有牌分成 45 堆这样的极端局面），游戏都能在有限步之内获胜。事实上，如果把 45 换成任意一个三角形数 n = 1 + 2 + … + k ，结论仍然成立。</p>
<p><span id="more-5865"></span><br>
在证明这个结论之前，大家不妨先来看两个例子。下图演示的是 n = 10 时的一种情形。我们把这 10 张牌分成了 (1, 3, 5, 1) 四堆，最终在第 6 次操作之后获得胜利。这里，我们用蓝色小圆点来表示扑克牌，并且规定新的牌堆总是加在原有牌堆的左边。</p>
<p style="text-align:center"><img alt="image placeholder" >
<p>来看一个稍微复杂一些的例子吧。下图演示的是 n = 15 时的一种情形。我们把这 15 张牌分成了 (7, 8) 两堆，最终在第 14 次操作之后获得胜利。</p>
<p style="text-align:center"><img alt="image placeholder" >
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>我们无妨把每次操作等价地想象成下面这样。首先，把所有牌堆按照牌数多少从左至右排开，最左边那个牌堆的牌数最多，最右边那个牌堆的牌数最少。接下来，从最左边的那一个牌堆开始，依次从各个牌堆的最底下取出一张牌，并且叠成新的一堆，先取出来的放在下面，后取出来的放在上面。最后，把新的牌堆放在最左边。如果这个时候，它右边那个牌堆里的牌数更多，我们就要在此添加新的步骤：让它不断和它右边的牌堆交换位置，直到它右边那个牌堆的牌数和它相同或者比它更少。此时，牌堆再次变得有序，我们便可以重复刚才的过程，完成一次又一次的操作。按照这个约定，刚才的第一个例子，也就是 (1, 3, 5, 1) 那个例子，具体的游戏过程就变成了下面这样。我们把每一次构造新的牌堆和每一次交换两个牌堆都算作是单独的一步，于是整个过程一共有 7 步。</p>
<p style="text-align:center"><img alt="image placeholder" >
<p>不断执行这样的操作，游戏局面将会逐次发生变化，得到一个又一个新的状态，最终必将会和之前的某个状态发生重复，此时便会产生循环。其中一种最简单的循环就是形如 (k, k-1, …, 2, 1) → (k, k-1, …, 2, 1) 的循环，这是一个长度仅为 1 的循环。接下来我们将证明，这是唯一可能出现的循环。</p>
<p>注意一个很有意思的事情：构造新堆的过程，其实就相当于是让每条对角线上的所有字母循环向下移动一位。例如，从第 1 幅图变到第 2 幅图，第 3 条对角线上的 c, g, i 就变成了 i, c, g ，第 4 条对角线上的 d, h, _, j 就变成了 j, d, h, _ 。所以，如果让每个字母都报出自己在第几条对角线上，再把所得的数字全部加起来，这个总和在构造新堆的前后是不会变化的。然而，每次交换牌堆的操作都会让这个总和严格地减小。具体地说，如果把牌数为 x 的牌堆与牌数为 y 的牌堆进行交换，那么在所有受到影响的 x + y 张牌中，有 2x 张牌会成对地左右互换位置，其余 y – x 张牌则会移动到前一条对角线上，于是所有字母所在对角线的编号之和将会减小 y – x 。这说明，在牌局变换的过程中，一旦出现了交换牌堆的操作，这个总和都会单向地减小，今后再也没法回到原来的水平。由此我们立即得出：一个循环里面绝不可能有交换牌堆的操作。</p>
<p>这意味着，在一个合法的循环中，所有的操作都是构造新堆的操作，本质上都是在循环移动各个对角线上的元素。下面我们来证明：在一个合法的循环当中，如果某条对角线上存在非空元素，那么它的前一条对角线上一定不能有空格。这是因为，如果第 i 条对角线上有某个字母 x ，并且第 i – 1 条对角线上有一个空格，那么经过 i – 1 步之后，这个空格会回到原位，此时 x 会出现在原位往上一格的位置（如上图的第 1 幅图和第 5 幅图，注意观察第 4 条对角线和第 5 条对角线）。不断这样下去，第 i 条对角线上的字母 x 一定会追上第 i – 1 条对角线上的那个空格，使得两者到达同一水平高度（即使刚开始两者所在的水平高度差异甚大）。这将会引发一次交换牌堆的操作（如上图中的第 7 幅图），而刚才我们已经说明了，一个合法的循环里不会出现交换牌堆的操作。</p>
<p>这说明，在一个合法的循环所涉及到的所有对角线当中，除了最外层的那条对角线以外，其余对角线必须都得填满。我们一共有 n = 1 + 2 + … + k 张牌，把这些牌按此要求进行摆放，可能性只有一种：依次填满第 1, 2, …, k 条对角线（如果要在第 k + 1 条对角线甚至更外层的对角线上填充元素，那么前面 k 条对角线必须被填满，牌数就不够了）。因而， (k, k-1, …, 2, 1) → (k, k-1, …, 2, 1) 就成了唯一可能的循环。</p>
<p>既然状态的演变过程中必然会产生循环，而 (k, k-1, …, 2, 1) → (k, k-1, …, 2, 1) 又是唯一可能的循环，于是我们就得到了本文最初提到的结论：一切初始状态最终都会变成 (k, k-1, …, 2, 1) 。</p>
<p>1983 年， Martin Gardner 在他的专栏上介绍了保加利亚单人纸牌游戏，随后又收录在了 The Last Recreations: Hydras, Eggs, and Other Mathematical Mystifications 一书中。我则是在 Algorithmic Puzzles 一书中看到的这个问题，上述证明方法也来源于此。</p>
			 ]]></content>
<pubDate>2014-03-26T00:52:12+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5865</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 杨辉三角中的自然底数 e ]]></title>
<link>http://www.matrix67.com/blog/archives/5881</link>
<content><![CDATA[ 
		<p style="text-align:center"><img alt="image placeholder" >
<p>你相信吗，杨辉三角里竟然也有自然底数 e 的身影。 2012 年， Harlan Brothers 发现了杨辉三角中的一个有趣的事实。不妨把杨辉三角第 n 行的所有数之积记作 s<sub>n</sub> ，那么随着 n 的增加， s<sub>n</sub> · s<sub>n+2</sub> / s<sub>n+1</sub><sup>2</sup> 会越来越接近 e ≈ 2.718 。事实上，我们有：</p>
<p style="text-align:center"><img alt="image placeholder" >
<p>这是为什么呢？ John Baez 在<a href="http://johncarlosbaez.wordpress.com/2014/02/12/triangular-numbers/">这个网页</a>上给出了一个漂亮的解释。</p>
<p><span id="more-5881"></span><br>
 </p>
<p style="text-align:center"><img alt="image placeholder" >
<p>首先，让杨辉三角 (A) 里面的每个数都除以它左下角的那个数，于是得到了图 (B) 所示的三角形数阵。你会发现，这个数阵里有一个很明显的模式，即第 n 行的所有数分母都是 n ，分子则分别是 n, n-1, …, 2, 1 。这并不是巧合。这是因为：</p>
<p style="text-align:center"><img alt="image placeholder" >
<p>接下来，让图 (B) 里的所有数都除以它右下角的那个数，于是得到了图 (C) 所示的三角形数阵。容易看出，这个数阵第 n 行的所有 n 个数应该都是 (n + 1) / n = 1 + 1/n ，它们乘起来等于 (1 + 1/n)<sup>n</sup> 。随着 n 的增加，这个数会越来越接近 e 。最后，让我们追溯一下图 (C) 中每个数的来源。图 (C) 中第 n 行的每个数都等于图 (B) 中第 n 行的某个数除以第 n + 1 行的某个数，进而等于图 (A) 中第 n 行的某个数除以第 n + 1 行的某个数的结果，除以第 n + 1 行的某个数除以第 n + 2 行的某个数的结果。因此，图 (C) 中第 n 行的所有数乘起来，结果正是 s<sub>n</sub> · s<sub>n+2</sub> / s<sub>n+1</sub><sup>2</sup></p>
			 ]]></content>
<pubDate>2014-04-03T17:59:43+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5881</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：圆中的两个相切的半圆 ]]></title>
<link>http://www.matrix67.com/blog/archives/5883</link>
<content><![CDATA[ 
		<p>下面这个结论是 Andrew Jobbings 在 2011 年指出的：</p>
<blockquote>
<p class="indent"><img alt="image placeholder" >
<p>AB 是圆 O 的一条直径， CD 、 EF 是两条垂直于 AB 的弦，并且以 CD 为直径的半圆和以 EF 为直径的半圆正好切于点 T 。那么，两个半圆的面积之和一定等于圆 O 的面积的一半。</p>
</blockquote>
<p>你能证明这个结论吗？</p>
<p><span id="more-5883"></span><br>
 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p class="indent"><img alt="image placeholder" >
</p>
<p>下面是 <a href="http://www.cut-the-knot.org/proofs/Semicircles.shtml">cut-the-knot</a> 网站上给出的一种证明方法。如果把两个半圆的半径分别记作 r<sub>1</sub> 和 r<sub>2</sub> ，把整个大圆的半径记作 R ，那么我们只需要证明</p>
<p style="text-align:center">π r<sub>1</sub><sup>2</sup> / 2 + π r<sub>2</sub><sup>2</sup> / 2 = π R<sup>2</sup> / 2</p>
<p>即</p>
<p style="text-align:center">r<sub>1</sub><sup>2</sup> + r<sub>2</sub><sup>2</sup> = R<sup>2</sup></p>
<p>由于 △MCO 是直角三角形，由勾股定理可知</p>
<p style="text-align:center">MO<sup>2</sup> + MC<sup>2</sup> = OC<sup>2</sup></p>
<p>其中 MC 就是其中左边那个半圆的半径， OC 就是整个圆 O 的半径，因而我们只需要证明 MO 就是右边那个半圆的半径即可。现在，连接 CT 、 FT ，你会发现 △MCT 和 △NFT 都是等腰直角三角形，并且 C 、 T 、 F 在一条直线上。由于圆心角的度数是圆周角的两倍，因此 ∠COE = 2 ∠CFE = 90° ，由此可知 ∠1 + ∠2 = 90° 。而 ∠2 + ∠3 = 90° ，于是 ∠1 = ∠3 。根据同样的道理，我们还可以得到 ∠2 = ∠4 。再加上整个大圆的半径 OC = OE ，就足以判定 △MCO 和 △NOE 全等了。这说明 MO = NE ，而后者正是右边那个半圆的半径。</p>
			 ]]></content>
<pubDate>2014-04-04T04:47:26+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5883</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用 k × 1 的矩形覆盖 n × n 的正方形棋盘 ]]></title>
<link>http://www.matrix67.com/blog/archives/5900</link>
<content><![CDATA[ 
		<p>用 k × 1 的小矩形覆盖一个 n × n 的正方形棋盘，往往不能实现完全覆盖（比如，有时候 n × n 甚至根本就不是 k 的整倍数）。不过，在众多覆盖方案中，总有一种覆盖方案会让没有覆盖到的方格个数达到最少，我们就用 m(n, k) 来表示这个数目。求证：不管 n 和 k 是多少， m(n, k) 一定是一个完全平方数。</p>
<p><span id="more-5900"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>如果 n &lt; k ，那么很明显，棋盘里一个小矩形也放不下，因而 m(n, k) = n<sup>2</sup> ，这是一个完全平方数。下面我们就只考虑 n ≥ k 了。</p>
<p class="indent"><img alt="image placeholder" >
<p>我们先来证明这样一个事实：如果某个覆盖方案当中，仅剩下一个 s × s 的小正方形区域没有覆盖到，其中 s ≤ k / 2 ，那么这样的方案一定是最优的。首先，在棋盘中的每个格子里都填上一个数，使得从最左下角出发，各个对角线上的数依次为 0, 1, 2, …, k – 1, 0, 1, 2, …, k – 1, … （上图所示的是 k = 6 的情况）。那么，把一个 k × 1 的小矩形放在棋盘中的任意位置，它总会覆盖每种数字各一个。假设某个覆盖方案当中，仅剩下一个 s × s 的小正方形区域没有覆盖到。注意到，任意一个 s × s 的小正方形区域里最多只会出现 2s – 1 种不同的数，因此如果 s ≤ k / 2 ，那么这个 s × s 的小正方形区域里一定会缺失至少一种数，比方说 x （在上图中，右上角的那个 3 × 3 的空白区域里就缺数字 5 ，因而我们可以取 x = 5 ）。由此可以推出，此时小矩形的数目已经达到了最大值，任何其他覆盖方案都不可能包含更多的小矩形，因为每个小矩形都必然会覆盖到一个 x ，然而在刚才的覆盖方案中，所有的 x 都已经被覆盖到了。</p>
<p> </p>
<p style="text-align:center"><img alt="image placeholder" >
<p>有趣的是，当 n ≥ k 时，让整个棋盘仅剩一个边长不超过 k / 2 的小正方形区域没有覆盖到，这是一定能做到的。不妨把 n 除以 k 的余数记作 r 。如果 r ≤ k / 2 ，那么我们可以直接用横着的小矩形从左向右填充棋盘，再用竖着的小矩形填充余下的部分，最终会剩下 r × r 的小正方形区域。上图所示的就是 n = 22 并且 k = 5 的情况，注意到 22 除以 5 的余数为 2 ，确实小于等于除数 5 的一半。可见，对于这类情况，我们都有 m(n, k) = r<sup>2</sup> ，这是一个完全平方数。</p>
<p> </p>
<p style="text-align:center"><img alt="image placeholder" >
<p>如果 r &gt; k / 2 呢？我们可以用和刚才类似的方法填充棋盘，使得棋盘右上角仅剩一个 (r + k) × (r + k) 的正方形区域。然后再用 4r 个小矩形像风车一样填充这个 (r + k) × (r + k) 的区域，使得正中间只剩下一个边长为 k – r 的小正方形区域。由于 k – r &lt; k / 2 ，因而此时的覆盖方案再次达到最优。上图所示的就是 n = 22 并且 k = 6 的情况，注意到 22 除以 6 的余数为 4 ，确实大于除数 6 的一半。可见，对于这类情况，我们有 m(n, k) = (k – r)<sup>2</sup> ，这仍然是一个完全平方数。</p>
<p>题目来源：<a href="http://www.brand.site.co.il/riddles/201403q.html">http://www.brand.site.co.il/riddles/201403q.html</a></p>
			 ]]></content>
<pubDate>2014-04-07T06:13:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5900</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 多边形外角和等于 360° 的一种直观解释 ]]></title>
<link>http://www.matrix67.com/blog/archives/5910</link>
<content><![CDATA[ 
		<p class="indent"><img alt="image placeholder" >
<p>来源：<a href="http://math.stackexchange.com/questions/733754/visually-stunning-math-concepts-which-are-easy-to-explain">Mathematics Stack Exchange</a></p>
			 ]]></content>
<pubDate>2014-04-08T03:48:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5910</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：2014 年 INMO 中的一个问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/5919</link>
<content><![CDATA[ 
		<p>这是 2014 年印度全国奥林匹克数学竞赛（INMO）的第 2 题：求证，对于任意正整数 n ，</p>
<p style="text-align:center">[n/1] + [n/2] + [n/3] + … + [n/n] + [√<span style="text-decoration:overline">n</span>]</p>
<p>总是偶数。这里， [x] 表示不超过 x 的最大整数。</p>
<p><span id="more-5919"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>官方给出的解答采用的是数学归纳法。不妨令</p>
<p style="text-align:center">f(n) = [n/1] + [n/2] + [n/3] + … + [n/n] + [√<span style="text-decoration:overline">n</span>]</p>
<p>容易算出 f(1) = 2 ，这是一个偶数。接下来我们只需要证明，对于所有的正整数 k ， f(k+1) – f(k) 的结果都是一个偶数。注意，如果 i 正好是 k+1 的一个约数，那么 [(k+1)/i] – [k/i] 将会等于 1 ，否则 [(k+1)/i] – [k/i] 都会等于 0 。于是我们有</p>
<p style="text-align:center">f(k+1) – f(k) = σ(k+1) + [√<span style="text-decoration:overline">k+1</span>] – [√<span style="text-decoration:overline">k</span>]</p>
<p>其中 σ(k+1) 表示 k+1 的约数个数。由于一个数的约数总是成对地出现，因而 σ(k+1) 几乎总是一个偶数，除非 k+1 恰好是一个完全平方数；另外， [√<span style="text-decoration:overline">k+1</span>] – [√<span style="text-decoration:overline">k</span>] 的值几乎总是为 0 ，只有当 k+1 恰好是一个完全平方数时才等于 1 。也就是说，当 k+1 不是完全平方数时， σ(k+1) 是一个偶数，并且 [√<span style="text-decoration:overline">k+1</span>] – [√<span style="text-decoration:overline">k</span>] = 0 ；当 k+1 正好是完全平方数时， σ(k+1) 是一个奇数，并且 [√<span style="text-decoration:overline">k+1</span>] – [√<span style="text-decoration:overline">k</span>] = 1 。不管怎样， f(k+1) – f(k) = σ(k+1) + [√<span style="text-decoration:overline">k+1</span>] – [√<span style="text-decoration:overline">k</span>] 的结果都是一个偶数。至此，结论也就证到了。</p>
<p>有趣的是，当网友在 <a href="http://math.stackexchange.com/questions/698562/to-prove-that-n-1-n-2n-3-dots-n-n-sqrtn-is-even">StackExchange</a> 上提出了这个问题后， David Angell 给出了一个更具启发性的证明。容易看出， [n/1] + [n/2] + [n/3] + … + [n/n] 的值，其实就是第一象限里位于函数 y = n/x 及其下方的整数格点的个数。我们把这些点分成两类：位于一三象限角平分线以外的，以及恰好位于一三象限角平分线上的。前一类的点总是成对地出现，因而一定有偶数个。但是，后一类点并不是成对出现的。那么，这些点一共有多少个呢？注意到，这些点也就是所有形如 (i, i) 的点，其中 i<sup>2</sup> 不能超过 n 。因而，这样的点一共有 [√<span style="text-decoration:overline">n</span>] 个。</p>
<p class="indent"><img alt="image placeholder" >
<p>因此， [n/1] + [n/2] + [n/3] + … + [n/n] + [√<span style="text-decoration:overline">n</span>] 的值，其实就等于这两类点的总个数，其中后一类点被重复计算了两次。这个值显然应该是偶数。</p>
<p>题目来源：<a href="http://www.cut-the-knot.org/m/NumberTheory/OlympiadProblemWithFloorFunction.shtml">Cut-The-Knot</a></p>
			 ]]></content>
<pubDate>2014-05-06T21:33:48+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5919</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 在 2048 里能够得到的最大的数是多少？ ]]></title>
<link>http://www.matrix67.com/blog/archives/5941</link>
<content><![CDATA[ 
		<p>Michael Brand 在 Using your Head is Permitted 趣题站 2014 年 4 月的<a href="http://www.brand.site.co.il/riddles/201404q.html">谜题</a>中提出了一个这样的问题：在最近非常流行的小游戏 <a href="http://gabrielecirulli.github.io/2048/">2048</a> 中，你能得到的最大的数是多少？</p>
<p>在这里，我们简单描述一下游戏的规则。游戏在一个 4 × 4 的棋盘上进行，棋盘里填有一个个的“数块”，每个数块上都写有某个形如 2<sup>n</sup> 的正整数。每一步，你需要从上、下、左、右四个方向中选取一个方向，按下对应的方向键之后，所有的数块都会“落”到这个方向；若有两个同种的数块在此过程中发生碰撞，则它们的值会相加起来，并合成一个新的数块。然后，系统会在棋盘中随机选择一个空白位置，并在此生出一个新的数块，上面写有数字 2 或者数字 4 （两种情况之比为 9 : 1）。游戏开始时，棋盘上会自动生成两个随机的数块，你的目标就是通过有限步的操作，得出一个写有 2048 的数块。当然，即使得到了 2048 这个数块，游戏也不会自动结束，你还可以向更大的数发起挑战。于是就有了我们刚才的问题：理论上，这个游戏当中能够得到的最大的数是多少？</p>
<p><span id="more-5941"></span> </p>
<p>可以证明，我们永远不可能在 2048 当中玩出 2<sup>18</sup> 这个数。 </p>
<p>让我们把棋盘上的所有数全部加起来，并在累加过程中不断关注当前总和的二进制表达。如果棋盘里的数分别是 2, 4, 16, 64, 16, 2 的话，累加结果的二进制表达依次为 10 → 110 → 10110 → 1010110 → 1100110 → 1101000 。你会发现，由于棋盘上的每个数都是形如 2<sup>n</sup> 的正整数，因而把它加进总和之后，这个总和的二进制表达里最多只会多出<strong>一个</strong>数字 1 （如果发生了进位，数字 1 的个数可能会不变甚至减少）。这意味着，如果最终棋盘上的所有数之和的二进制表达当中一共有 k 个数字 1 ，那就说明刚才至少有 k 个数在相加，换句话说棋盘里至少有 k 个数块。</p>
<p>容易看出，每走一步之后，棋盘上的所有数之和都会增加 2 或者 4 。如果最终棋盘上出现了一个 2<sup>18</sup> ，就说明棋盘上的所有数之和至少是 2<sup>18</sup> ，那么在此之前棋盘上的所有数之和一定经历过 2<sup>18</sup> – 2 或者 2<sup>18</sup> – 4 。前者的二进制表达为 11 1111 1111 1111 1110 ，这里面有 17 个数字 1 ，超过了棋盘里总的格子数，因而显然是不可能的。后者的二进制表达是 11 1111 1111 1111 1100 ，这里面有 16 个数字 1 ，正好是棋盘里总的格子数。这说明，此时棋盘刚好被填满， 2<sup>2</sup>, 2<sup>3</sup>, 2<sup>4</sup>, …, 2<sup>17</sup> 这 16 种不同的数块各有一个。这意味着棋盘里不但没有空白的格子，也没有相同种类的数块可以合并，此时玩家直接就死掉了！因而，我们是没有办法得到 2<sup>18</sup> 的。</p>
<p>因此， 2<sup>17</sup> = 131072 成为了 2048 这个游戏中数块大小的一个理论上限。但是，我们真的能弄出 131072 吗？看上去，我们好像只需要构造出下图所示的局面就行了，但这个局面本身能否实现，还有待进一步讨论。 Michael Brand 猜测，理论上 131072 也是无法得到的，但他不能证明这一点。我虽然在网上看见过很多网友宣称自己打出过 131072 ，甚至有的网友发出了最后几步的视频（比如<a href="https://www.youtube.com/watch?v=MDkZkweB5lM">这里</a>），但由于我从来没有看到过完整的演示过程，因而也持怀疑态度。期待万能的网友们能够提供一种简洁有效的构造解，来说明当运气足够好的情况下，我们有办法打出 131072 ；或者找到一个更好的证明方法，足以说明 131072 也是理论上不可能实现的。</p>
<p class="indent"><img alt="image placeholder" >
<p>最后补充一句： 2048 的游戏概念来源于另一款叫做 <a href="http://threesgame.com">Threes!</a> 的游戏。如果你喜欢 2048 的话，建议你去购买 Threes! ，它无疑比 2048 更加精致，更加有趣。我的 iPad 上只装了一个游戏，就是 Threes! 。</p>
			 ]]></content>
<pubDate>2014-05-08T01:21:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5941</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 子串复杂度、平衡 01 串与 Sturmian 串 ]]></title>
<link>http://www.matrix67.com/blog/archives/5955</link>
<content><![CDATA[ 
		<p>让我们先从两个小问题开始说起。第一个问题是，是否存在某个无限不循环的 01 串，使得对于任意一个正整数 n ，该 01 串中长度为 n 的子串都有且仅有 n + 1 种？</p>
<p>或许这个问题来得有些突然。让我们慢慢解释一下，这个问题是怎么来的。衡量一个 01 串的复杂程度有很多办法，比方说，我们可以去考察它的“子串复杂度”（subword complexity），即子串的种类有多丰富。我们用 p<sub>w</sub>(n) 来表示，在一个（有可能无限长的）数字串 w 当中，长度为 n 的子串一共有多少种。例如，对于无限 01 串 α = 000000… 来说，不管 n 是多少， p<sub>α</sub>(n) 永远都等于 1 ；而对于无限 01 串 β = 001001001… 来说，我们有 p<sub>β</sub>(1) = 2 ，并且 p<sub>β</sub>(2) = p<sub>β</sub>(3) = p<sub>β</sub>(4) = … = 3 。</p>
<p>注意，虽然 α 和 β 这两个 01 串都是无限的，但是当 n 的值变得很大时， p<sub>α</sub>(n) 和 p<sub>β</sub>(n) 的值始终很小。当然，这一点也不奇怪，因为 α 和 β 是一种特殊的无限 01 串——无限循环 01 串。对于那些无限不循环的 01 串来说，这种事情就不大可能了。在数字串 γ = 01001000100001… 里，长度为 1 的子串只有 {0, 1} 共 2 种，长度为 2 的子串有 {00, 01, 10} 共 3 种，长度为 3 的子串有 {000, 001, 010, 100} 共 4 种，长度为 4 的子串有 {0000, 0001, 0010, 0100, 1000, 1001} 共 6 种……像这样继续计算下去，我们可以得到序列 p<sub>γ</sub>(1), p<sub>γ</sub>(2), p<sub>γ</sub>(3), p<sub>γ</sub>(4), … 的前面若干项：</p>
<p style="text-align: center">2, 3, 4, 6, 9, 12, 16, 20, 25, 30, 36, 42, 49, 56, 64, 72, 81, 90, 100, 110, …</p>
<p>趋势非常明显：随着 n 的增加， p<sub>γ</sub>(n) 的值也会跟着增加，最终可以增加到任意大。换句话说， p<sub>γ</sub>(n) 的值没有一个上限。那么，能否找到某个无限不循环的 01 串 w ，使得 p<sub>w</sub>(n) 的值存在上限呢？不可能！下面我们就来说明，对于任意一个无限不循环的 01 串 w 来说，不管 n 是多少，不等式 p<sub>w</sub>(n) ≥ n + 1 始终成立。</p>
<p><span id="more-5955"></span><br>
容易想到，在任意一个无限 01 串 w 当中，长度为 n + 1 的子串种数都不会少于长度为 n 的子串种数。换句话说，在序列 p<sub>w</sub>(1), p<sub>w</sub>(2), p<sub>w</sub>(3), … 中，从第二项开始，每一项都一定大于等于前一项。不过，如果无限 01 串 w 不是循环的，那么后一项必然会严格地大于前一项，不可能等于前一项。为什么呢？想一想，如果存在某个 m 使得 p<sub>w</sub>(m) = p<sub>w</sub>(m + 1) ，这会意味着什么？这意味着，在无限 01 串 w 当中，每一种长度为 m 的子串都满足：它在 w 中的每一次出现，后面跟着的数字都是相同的（要么都是 0 ，要么都是 1 ）。现在，找出 w 中的两个相同的并且长度都为 m 的子串（由于 w 的长度是无限的，而 m 的值是有限的，因此这是一定能办到的），比如说第 i 个数字到第 i + m – 1 个数字所组成的子串，以及第 j 个数字到第 j + m – 1 个数字所组成的子串（无妨假设 i &lt; j）。于是，第 i + m 个数字也就必然和第 j + m 个数字相同，进而第 i + m + 1 个数字必然和第 j + m + 1 个数字相同，进而第 i + m + 2 个数字必然和第 j + m + 2 个数字相同……不断这样下去，直到我们最后推出，第 i + m + (j – i) 个数字，也就是第 j + m 个数字，和第 j + m + (j – i) 个数字相同，此时循环产生。可见， w 将会成为一个循环长度为 j – i 的无限循环 01 串。</p>
<p>我们证明了，对于任意一个无限不循环 01 串 w 来说， p<sub>w</sub>(1), p<sub>w</sub>(2), p<sub>w</sub>(3), … 中的后一项都严格大于前一项。然而，在一个无限不循环 01 串当中，一定既有 0 出现，又有 1 出现，因而 p<sub>w</sub>(1) = 2 。于是， p<sub>w</sub>(2) 至少是 3 ， p<sub>w</sub>(3) 至少是 4 ，等等。换句话说， p<sub>w</sub>(n) ≥ n + 1 始终成立。</p>
<p>于是就有了本文开头提出的问题：是否存在某个无限不循环 01 串 w ，使得对于所有正整数 n 来说， p<sub>w</sub>(n) 正好都等于 n + 1 ？如果真的存在这样的无限不循环 01 串，那么可以想象，它将会是一个非常基本、非常简约的无限不循环 01 串！</p>
<p> </p>
<p>在这里，我们规定一下无限 01 串、无限循环 01 串、无限不循环 01 串的意思。大家知道，小数分为有限小数和无限小数，其中无限小数分为循环小数和不循环小数，而循环小数又分为两种：纯循环小数和混循环小数。举些例子： 1/4 = 0.25 就是有限小数， 1/7 = 0.142857142857142857… 就是无限循环小数中的纯循环小数， 57/110 = 0.5181818… 就是无限循环小数中的混循环小数， π/10 = 0.31415926… 则是无限不循环小数。我们不妨借用这个概念来描述 01 串。因此， 110110 就是有限 01 串， 110110110110… 就是无限循环 01 串当中的纯循环 01 串， 0000000110110110110… 就是无限循环 01 串当中的混循环 01 串， 01001000100001… 则是无限不循环 01 串。因此，那些刚开始不循环，后来才开始发生循环的 01 串，也归为了无限循环 01 串当中。</p>
<p> </p>
<p>等等，本文开头说到“让我们先从两个小问题开始说起”，第二个小问题是什么呢？第二个小问题是：是否存在某个无限不循环的 01 串，使得在任意两个长度相等的子串当中，数字 1 的个数最多只差一个？</p>
<p>这个问题似乎也来得比较突然。让我们也稍作一番讨论吧。</p>
<p>如果在某个（有可能无限长的） 01 串当中，对于任意两个长度相同的子串，它们当中数字 1 的个数都最多相差一个，我们就说这个 01 串是一个“平衡 01 串”（balanced word）。比方说， 01010 就是一个平衡 01 串，而 00011 就不是一个平衡 01 串。一个无限长的 01 串有可能是平衡 01 串吗？当然有可能，比如在无限循环 01 串 01010101… 当中，任意一个长度为 2k 的子串总是含有 k 个 1 ，任意一个长度为 2k + 1 的子串总是含有 k 或 k + 1 个 1 ，因而这个无限 01 串显然是平衡的。我们还能构造出一些更复杂的例子，比如无限循环 01 串 110101101011010… （以 11010 为循环节），可以验证，它也是平衡的。</p>
<p>注意，并不是所有循环的无限 01 串都是平衡的，比如 000111000111… 就是一例。那么反过来，是否所有平衡的无限 01 串都是循环的呢？这个问题就不太好回答了。其实，这个问题就等价于我们刚才提出的问题二：能否找到某个无限不循环的 01 串，使得它也满足平衡性？</p>
<p> </p>
<p>不可思议的是，第一个问题的答案是肯定的：确实有这么一个无限不循环的 01 串 w ，使得 w 的子串复杂度的每一项都能达到理论下限。不可思议的是，第二个问题的答案也是肯定的：确实有这么一个无限不循环的 01 串 w ，使得 w 同时也是一个平衡 01 串。更加不可思议的是：居然有这么一个无限不循环的 01 串 w ，它同时满足上面这两个条件！天哪，这该是一个多么精致有型的 01 串呀！</p>
<p>这确实是一个非常美妙的 01 串。令 S<sub>0</sub> = 0, S<sub>1</sub> = 01, S<sub>n</sub> = S<sub>n-1</sub>S<sub>n-2</sub> ：</p>
<p class="indent">S<sub>0</sub> = 0<br>
S<sub>1</sub> = 01<br>
S<sub>2</sub> = 010<br>
S<sub>3</sub> = 01001<br>
S<sub>4</sub> = 01001010<br>
S<sub>5</sub> = 0100101001001<br>
S<sub>6</sub> = 010010100100101001010<br>
S<sub>7</sub> = 0100101001001010010100100101001001<br>
……</p>
<p>像这样无限地迭代下去，最终所得的串就叫做 Fibonacci 串。这就是一个可以同时回答上述两个问题的 01 串。很容易看出它和 Fibonacci 数的关系：它们拥有相同的递推关系，只不过一个是作用在数字串的连接运算上的，另一个是作用在正整数的加法运算上的。</p>
<p>Fibonacci 串有很多有趣的性质，比方说，对于任意正整数 n ≥ 1 ， S<sub>n</sub> 都可以看作是在 S<sub>n-1</sub> 的基础上按照替换规则 {0 → 01, 1 → 0} 变换得来的。利用数学归纳法可以迅速证明这一点。显然，当 n = 1 和 n = 2 时，结论是成立的。另外，假设结论对于所有小于 k 的正整数都成立，现在对 S<sub>k-1</sub> 使用替换规则，这实质上相当于是对 S<sub>k-2</sub>S<sub>k-3</sub> 使用替换规则，其结果相当于 S<sub>k-1</sub>S<sub>k-2</sub> ，也就是 S<sub>k</sub> 。至此我们便完成了全部归纳证明。</p>
<p>因此，我们得到了 Fibonacci 串的另一种更简洁的定义方式：从数字 0 出发，不断套用替换规则 {0 → 01, 1 → 0} ，最终得到的就是 Fibonacci 串。事实上，我们甚至可以把 Fibonacci 串等价地定义为：唯一一个在替换规则 {0 → 01, 1 → 0} 下保持不变的无限 01 串。首先，这样的 01 串必然以 0 开头，否则一经替换，第一位就已经变了。接下来，这个 01 串必然以 01 开头，否则一经替换，第二位将会不同。由此又可推出，这个 01 串必然以 010 开头，进而必然以 01001 开头，进而必然以 01001010 开头……最终你会发现，如果整个串在替换规则 {0 → 01, 1 → 0} 下保持不变，那么 Fibonacci 串是唯一的可能。</p>
<p class="indent"><img alt="image placeholder" >
<p>Fibonacci 数与黄金比例 (√<span style="text-decoration: overline">5</span>  – 1) / 2 ≈ 0.618 有着密不可分的联系， Fibonacci 串也不例外。 Fibonacci 串还有一个非常神奇的等价定义。作出正比例函数 y = k · x 的图像，其中斜率 k = (√<span style="text-decoration: overline">5</span>  – 1) / 2 。每次图像穿过一条竖直的网格线，就记一个数字 0 ；每次图像穿过一条水平的网格线，就记一个数字 1 。由此得到一个无限 01 串，它就是 Fibonacci 串！</p>
<p>让我们简单解释一下这是为什么。首先考虑这么一个问题：如果函数图像的斜率从 k 变为了 k + 1 ，由此所得的 01 串会发生怎样的变化？你会发现，原来函数图像与第 i 条竖直线交于 (i, k · i) ，现在函数图像与第 i 条竖直线就交于了 (i, (k + 1) · i) = (i, k · i + i) 。也就是说，函数图像与第 1 条直线的交点升高了 1 个单位，与第 2 条直线的交点升高了 2 个单位，与第 3 条直线的交点升高了 3 个单位，以此类推。容易看出，这将会导致，每两个相邻的 0 之间都会多出一个 1 。举个例子，假如原函数图像与第 3 条竖直线和第 4 条竖直线分别交于 (3, 1.854) 和 (4, 2.472) ，由于 1.854 和 2.472 之间夹着一个整数，因而在这里会产生一个 1 ；然而，在新的函数图像中，交点 (3, 1.854) 变成了 (3, 4.854) ，交点 (4, 2.472) 变成了 (4, 6.472) ，现在 4.854 和 6.472 之间夹着两个整数了，因而在这里产生的是两个 1 。我们可以总结一下：如果函数图像的斜率从 k 变为了 k + 1 ，那么原来 01 串当中的每个 0 前面都会多一个 1 ，或者说，原来 01 串当中的每个 0 都会变成 10 。</p>
<p class="indent"><img alt="image placeholder" >
<p>然后我们来考虑这么一个问题：如果函数图像的斜率从 k 变为了 1/k ，由此得到的 01 串会发生怎样的变化？很简单：所有的 0 都会变成 1 ，所有的 1 都会变成 0 。这是因为，前后两个函数图像一定是关于直线 y = x 轴对称的，因此原函数图像每次穿过一条水平线，新函数图像都会穿过一条竖直线，原函数图像每次穿过一条竖直线，新函数图像都会穿过一条水平线。这就意味着，在前后两个函数图像所对应的 01 串当中， 0 和 1 的角色正好互换。</p>
<p>那么，如果把函数图像的斜率从 k 变为 1/(k + 1) ，对应的 01 串会怎么样呢？根据刚才的讨论，这个 01 串会分两步发生变化：首先，所有的 0 都变成 10 ，所有的 1 都不变 ；然后，所有的 0 变成 1 ，所有的 1 变成 0 。最终的效果便相当于把所有的 0 都变成 01 ，并把所有的 1 都变成 0 。有趣的是，如果 k 正好等于 1/(k + 1) ，换句话说 k = (√<span style="text-decoration: overline">5</span>  – 1) / 2 时（舍去负数解），那么函数 y = k · x 的图像所对应的 01 串就会满足这么一个神奇性质：把所有的 0 变成 01 ，并把所有的 1 变成 0 后，整个 01 串保持不变。然而，之前我们已经说过了， Fibonacci 串是唯一满足上述性质的 01 串。至此我们便证明了，斜率为 (√<span style="text-decoration: overline">5</span>  – 1) / 2 的正比例函数图像切割网格线所得的 01 串，确实就是 Fibonacci 串。</p>
<p>我们刚才介绍了 Fibonacci 串的诸多等价定义。 Fibonacci 串的很多重要性质，都可以由其中一种或者几种定义很快得出。比如说， Fibonacci 串当中的每个子串都会出现无穷多次；再比方说， Fibonacci 串当中不会出现连续两个 1 ，也不会出现连续三个 0 ；再比方说， Fibonacci 串当中数字 0 的个数所占比例就是黄金比例 (√<span style="text-decoration: overline">5</span>  – 1) / 2 ≈ 0.618 。最后一点可以顺便告诉我们， Fibonacci 串是无限不循环的，因为很容易证明，在任何一个无限循环的 01 串当中，数字 0 的个数所占的比例都应该是一个有理数。</p>
<p>不过，前面还有两个巨大的坑没有填上：为什么 Fibonacci 串当中，长度为 n 的子串恰好有 n + 1 种？为什么 Fibonacci 串当中，任意两个长度相同的子串里数字 1 的数目最多只差一个？由于这两件事情证明起来并不容易，因此我就省略了。不但如此，接下来，我还要挖一个更大的坑。</p>
<p> </p>
<p>回想一下 Fibonacci 串的最后一种定义，你会发现它有一种很自然的扩展。任取一个大于 0 的无理数 k 作为斜率 ，任取一个大于等于 0 小于 1 的实数 b 作为截距，我们都会得到一个一次函数 y = k · x + b ，它的图像是一条直线。这条直线将会穿过一条一条的网格线，和刚才一样，如果穿过了一条竖直线，我们就写下一个数字 0 ，如果穿过了一条水平线，我们就写下一个数字 1 。这样，我们便会得到一个无限 01 串。下图所示的就是当 k = π / 2 并且 b = 2 / 3 的情况，这将会生成一个以 11010110 开头的无限 01 串。注意，这里的 k 值必须是一个无理数，这保证了 01 串不是循环的。我们把这样的 01 串通通叫做 Sturmian 串（这种叫法最早出自 Marston Morse 和 Gustav Hedlund 在 1940 年发表的一篇论文）。</p>
<p class="indent"><img alt="image placeholder" >
<p>最令人震撼的地方到了。不但 Fibonacci 串满足上面两个性质，事实上所有的 Sturmian 串都满足上面两个性质。 Jean-Paul Allouche 和 Jeffrey Shallit 把这一切总结为下面这个精彩的定理。</p>
<blockquote><p>如果 w 是一个仅由 0 和 1 组成的数字串，那么下面三个条件是完全等价的：<br>
(1) 对于所有正整数 n 都有 p<sub>w</sub>(n) = n + 1 ；<br>
(2) w 是一个无限不循环的平衡 01 串；<br>
(3) w 是一个 Sturmian 串。</p></blockquote>
<p>我打算略去证明过程，因为结论本身远比证明过程更加激动人心。感兴趣的读者可以参考 Automatic Sequences: Theory, Applications, Generalizations 的第 10 章。</p>
			 ]]></content>
<pubDate>2014-06-09T03:34:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5955</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 将立方体绕其体对角线旋转一周后会得到什么图形？ ]]></title>
<link>http://www.matrix67.com/blog/archives/5981</link>
<content><![CDATA[ 
		<p>最近看到一道小学数学题，非常考验人的空间想象能力：将一个立方体绕着它的对角线 AC<sub>1</sub> 旋转一周，会得到下面的哪一种立体图形？</p>
<p><img alt="image placeholder" >
<p><span id="more-5981"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>答案是 D 。下面是我自己做的一个演示动画。</p>
<p><img alt="image placeholder" >
<p>你猜对了吗？</p>
			 ]]></content>
<pubDate>2014-06-11T02:45:50+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/5981</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Penney 的游戏：正所谓后发制人，先发制于人 ]]></title>
<link>http://www.matrix67.com/blog/archives/6015</link>
<content><![CDATA[ 
		<p>让我们来玩一个游戏。连续抛掷硬币，直到最近三次硬币抛掷结果是“正反反”或者“反反正”。如果是前者，那么我获胜，你需要给我 1 元钱；如果是后者，那么你获胜，我会给你 1 元钱。你愿意跟我玩这样的游戏吗？换句话说，这个游戏是公平的吗？</p>
<p>乍看上去，你似乎没有什么不同意这种玩法的理由，毕竟“正反反”和“反反正”的概率是均等的。连续抛掷三次硬币可以产生 8 种不同的结果，上述两种各占其中的 1/8 。况且，序列“正反反”和“反反正”看上去又是如此对称，获胜概率怎么看怎么一样。</p>
<p>实际情况究竟如何呢？实际情况是，这个游戏并不是公平的——我的获胜概率是你的 3 倍！虽然“正反反”和“反反正”在一串随机硬币正反序列中出现的频率理论上是相同的，但别忘了这两个序列之间有一个竞争的关系，它们要比赛看谁先出现。一旦抛掷硬币产生出了其中一种序列，游戏即宣告结束。这样一来，你就会处于一个非常窘迫的位置：不管什么时候，只要掷出了一个正面，如果你还没赢的话，你就赢不了了——在出现“反反正”之前，我的“正反反”必然会先出现。</p>
<p>事实上，整个游戏的前两次硬币抛掷结果就已经决定了两人最终的命运。只要前两次抛掷结果是“正正”、“正反”、“反正”中的一个，我都必胜无疑，你完全没有翻身的机会；只有前两次掷出的是“反反”的结果，你才会赢得游戏的胜利。因此，我们两人的获胜概率是 3:1 ，我的优势绝不止是一点。</p>
<p>你或许想问，如果已知我的硬币序列是“正反反”，那么你应该选择一个怎样的硬币序列，就能保证获胜概率超过我呢？研究表明，你可以选择“正正反”，这样一来，我们两人的获胜概率将会变为 1:2 ，换句话说你将会有 2/3 的概率获胜。 <a href="http://www.brand.site.co.il/riddles/201405q.html">Using your Head is Permitted</a> 趣题站 2014 年 5 月的趣题对此进行了更深一步的探究。</p>
<p>A 、 B 两人打算玩这么一个游戏。首先， A 选择一个长度为 n 的正反序列，然后 B 再选择另一个长度为 n 的正反序列。之后，不断抛掷硬币，哪名玩家所选的正反序列最先出现，哪名玩家就获胜。我们的问题是，假如两名玩家都采取最优策略的话，对于哪些 n ，游戏对玩家 A 更有利一些（换句话说，玩家 A 拥有超过 50% 的胜率），对于哪些 n ，游戏对玩家 B 更有利一些（换句话说，玩家 B 拥有超过 50% 的胜率）。今后，为了方便起见，我们用数字 1 代表“正面”，用数字 0 代表“反面”。</p>
<p><span id="more-6015"></span></p>
<p> </p>
<p>当 n = 1 时，两名玩家的获胜概率显然相同。当 n = 2 时，可以验证，除了 00 打 10 以及 11 打 01 的胜率之比是 1:3 以外，其他所有情况（包括 00 打 11 、 00 打 01 、 01 打 10 、 11 打 10 等四种）的胜率之比都是 1:1 。因而，如果两名玩家都采用最优策略的话， A 一定会选择 01 和 10 之一，从而避免 B 获得 3 倍于自己的胜率。最终结果便是，两人的胜率之比维持在 1:1 的位置，获胜概率仍然相同。令人意想不到的是，当 n &gt; 2 时，游戏总是对玩家 B 更有利的。换句话说，我们要证明，当 n &gt; 2 时，不管 A 选择的 01 串是什么，玩家 B 总能有针对性地选择一个恰当的 01 串，使得他获胜的概率大于 50% 。事实上，我们会证明这样一个结论：玩家 B 总可以截取 A 所选的 01 串的前 n – 1 位，再在前面加上一个数字 0 或者数字 1 作为自己的 01 串，从而使得自己获胜的概率至少有 (2 – (1/2)<sup>n-1</sup>)/3 。</p>
<p>不妨把 A 选择的 01 串记作 Py （其中 P 是一个长度为 n – 1 的 01 串， y 则表示数字 0 或者数字 1 ），我们先来看看，如果 B 选择的 01 串是 0P ，结果将会怎样。</p>
<p>不断抛掷硬币，直到最近 n – 1 次硬币抛掷结果正好是序列 P 。这有三种情况：情况一，最近 n 次硬币抛掷结果是 0P ；情况二，最近 n 次硬币抛掷结果是 1P ；情况三，目前硬币抛掷次数还不足 n 次。情况三是最为特殊的，它意味着整个游戏的前 n – 1 次硬币抛掷结果正好就是序列 P ，其概率为 (1/2)<sup>n-1</sup> 。让我们假设情况一出现的概率是 p<sub>1</sub> ，则情况二出现的概率就是 1 – (1/2)<sup>n-1</sup> – p<sub>1</sub> 。</p>
<p>如果出现了情况一，那么玩家 B 就直接获胜了，游戏结束；如果出现了情况二或者情况三，那么游戏仍需继续进行下去。不妨把此时的游戏局面叫做节点 X 。现在，玩家 A 离胜利已经非常接近了。如果下一次抛掷硬币的结果正好是 y ，那么玩家 A 就获胜了，游戏结束；如果下一次抛掷硬币的结果是 <span style="text-decoration: overline">y</span> （这里 <span style="text-decoration: overline">y</span> 表示与 y 相反的数字），那么游戏将会到达另外一个关键的中间状态：最近 n 次硬币抛掷结果为 P<span style="text-decoration: overline">y</span> 。对于两名玩家来说，这是全新的起跑线。如果下一次出现 P 的时候，它前面的那个数字是 0 ，那么玩家 B 就直接获胜了，游戏结束；如果下一次出现 P 的时候，它前面的那个数字是 1 ，那么游戏状态又会回到节点 X ，玩家 A 将会再次得到一个制胜的绝佳机会。不妨假设以 P<span style="text-decoration: overline">y</span> 打头的随机 01 序列中，下一个 P 的前面正好是数字 0 的概率为 p<sub>2</sub> ，那么下一个 P 的前面正好是数字 1 的概率就是 1 – p<sub>2</sub> 。于是，整个游戏的状态转移图如下图所示。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>玩家 B 获胜的概率就可以用 p<sub>1</sub> 和 p<sub>2</sub> 表示出来了。首次出现 P 的时候玩家 B 就获胜的概率为 p<sub>1</sub> ，有另外 1 – p<sub>1</sub> 的概率进入节点 X 。进入节点 X 以后， A 将会有 1/2 的概率获胜， B 将会有 (1/2) · p<sub>2</sub> 的概率获胜，其余情况下游戏局面将会回到节点 X ，刚才的各种事件会以相同比例的概率再次发生，并且有可能一遍一遍地重复下去。因此，总的来说，进入节点 X 以后，两名玩家的获胜概率之比是 (1/2) : ((1/2) · p<sub>2</sub>) ；进而得出，进入节点 X 以后，玩家 B 获胜的概率就是 ((1/2) · p<sub>2</sub>) / (1/2 + (1/2) · p<sub>2</sub>) = p<sub>2</sub> / (1 + p<sub>2</sub>) 。</p>
<p>综上所述，玩家 B 的获胜概率应为：</p>
<p style="text-align: center">W<sub>0</sub> = p<sub>1</sub> + (1 – p<sub>1</sub>) · p<sub>2</sub> / (1 + p<sub>2</sub>)</p>
<p>别忘了，上述概率值仅仅是 A 在选择了 01 串 Py 之后， B 以 0P 应对时获胜的概率。如果 B 选择以 1P 应对呢？整个游戏的状态转移图将会变成下面这样。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>前面我们说过，硬币序列里第一次出现 P 的时候，最近 n 次硬币抛掷结果是 0P ，最近 n 次硬币抛掷结果是 1P ，目前硬币抛掷次数还不足 n 次，这三种情况的发生概率分别为 p<sub>1</sub> 、 1 – (1/2)<sup>n-1</sup> – p<sub>1</sub> 和 (1/2)<sup>n-1</sup> 。然而，这次玩家 B 选择的 01 串变成了 1P ，因而游戏开始时进入两条支线的概率就成为了图中所示的那样。另外，从 P<span style="text-decoration: overline">y</span> 出发随机产生 01 串，下次出现 P 时它的前面正好是数字 1 的概率为 1 – p<sub>2</sub> ，因而我们需要把第一幅状态转移图当中的所有 p<sub>2</sub> 都替换成 1 – p<sub>2</sub> 。可以计算出，进入节点 X 以后，两人的胜率之比为 (1/2) : ((1/2) · (1 – p<sub>2</sub>)) ，其中 B 的获胜概率为</p>
<p style="text-align: center">((1/2) · (1 – p<sub>2</sub>)) / (1/2 + (1/2) · (1 – p<sub>2</sub>)) = (1 – p<sub>2</sub>) / (2 – p<sub>2</sub>)</p>
<p>玩家 B 的总获胜概率就是：</p>
<p style="text-align: center">W<sub>1</sub> = 1 – (1/2)<sup>n-1</sup> – p<sub>1</sub> + ((1/2)<sup>n-1</sup> + p<sub>1</sub>) · (1 – p<sub>2</sub>) / (2 – p<sub>2</sub>)</p>
<p>我们要证明的即是， W<sub>0</sub> 和 W<sub>1</sub> 总有一个大于等于 (2 – (1/2)<sup>n-1</sup>)/3 。注意到，如果固定 p<sub>2</sub> 不变，把 W<sub>0</sub> 和 W<sub>1</sub> 都看作是关于 p<sub>1</sub> 的函数，那么 W<sub>0</sub> 将会是一个线性递增函数， W<sub>1</sub> 则是一个线性递减函数，因此最坏的情况将会发生在 W<sub>0</sub> = W<sub>1</sub> 的时候，此时 W<sub>0</sub> 和 W<sub>1</sub> 中的较大值达到最小。解得</p>
<p style="text-align: center">p<sub>1</sub> = (1/3) · (2 – (1/2)<sup>n-1</sup> – p<sub>2</sub> – (1/2)<sup>n-1</sup> · p<sub>2</sub>)</p>
<p>把上式代回 W<sub>0</sub> 或者 W<sub>1</sub> 当中的任意一个，得到的是一个与 p<sub>2</sub> 无关的数，它正是 (2 – (1/2)<sup>n-1</sup>)/3 。下图是 n = 3 时 W<sub>0</sub> 和 W<sub>1</sub> 的图像，可以看到两个图像相交在一起，形成了一条高度大约为 0.58 的交线。至此，我们便成功地证明了，当 n &gt; 2 时，不管 A 选的 01 串是什么， B 总能有针对性地选择另一个 01 串，使得获胜概率可以高达 50% 以上。</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p>事实上，如果把玩家 A 的选择记作 Py ，那么玩家 B 的最优策略一定就是 0P 和 1P 之一。这个结论是由 Leonidas Guibas 和 Andy Odlyzko 在 1978 年合写的一篇论文里证明的。当 n = 3 时，玩家 B 的最优策略可以归纳如下：</p>
<table>
<tr>
<td>如果 A 选的是</td>
<td>那么 B 应该选</td>
<td>两人的胜率之比</td>
</tr>
<tr>
<td>000</td>
<td>100</td>
<td>1:7</td>
</tr>
<tr>
<td>001</td>
<td>100</td>
<td>1:3</td>
</tr>
<tr>
<td>010</td>
<td>001</td>
<td>1:2</td>
</tr>
<tr>
<td>011</td>
<td>001</td>
<td>1:2</td>
</tr>
<tr>
<td>100</td>
<td>110</td>
<td>1:2</td>
</tr>
<tr>
<td>101</td>
<td>110</td>
<td>1:2</td>
</tr>
<tr>
<td>110</td>
<td>011</td>
<td>1:3</td>
</tr>
<tr>
<td>111</td>
<td>011</td>
<td>1:7</td>
</tr>
</table>
<p>掌握了上面这个表格的话，你就拥有了一个骗小女生的绝好工具。 YouTube 的 <a href="https://www.youtube.com/watch?v=IMsa-qBlPIE">Scam School</a> 系列视频上就介绍了这个 bar trick ：把游戏规则告诉小女生，让她先选一个长度为 3 的硬币序列，然后你再按照上表选择一个对应的硬币序列，你便能保证获得至少 2 倍于她的胜率。重复多次游戏，你将会以很惊人的大比分获胜。你甚至不需要刻意去背表格，只需要记住：如果对方的选择是 wxy ，那么你选择 <span style="text-decoration: overline">x</span>wx 就行了。</p>
<p>当然，玩家 B 的最优选择也并不总是把 Py 的第 2 位取反后加在 P 的前面。当 n = 5 时，如果 A 选择了 10110 ，那么 B 选择 11011 会得到 7/12 ≈ 58% 的胜率，而选择 01011 则会得到 17/24 ≈ 71% 的胜率，后者才是他的最优选择。 Leonidas Guibas 和 Andy Odlyzko 认为，玩家 B 究竟是选 0P 更好还是选 1P 更好，这并没有一个明显的规律。</p>
<p>有人或许想问，这些概率值都是怎么计算出来的呀？ John Conway 在 Winning Ways for Your Mathematical Plays 的第 4 卷中提到了一种方法。假如 a 和 b 是两个 n 位 01 串。如果 a 和 b 完全相等，那么记一个数字 1 ，如果不相等，那么记一个数字 0 。接下来，比较 a 的后面 n – 1 位以及 b 的前面 n – 1 位，如果相等，那么接着记一个数字 1 ，如果不相等，那么接着记一个数字 0 。接下来，比较 a 的后 n – 2 位以及 b 的前 n – 2 位，并根据比较结果记下数字 0 或者数字 1 。不断这样做下去，直到最后比较 a 的最后面 1 位和 b 的最前面 1 位，并产生新的数字。在整个过程中，你会依次记下 n 个数字，最终会得到一个 n 位的 01 串。把它当作一个二进制数，并转换成十进制。我们把最终的结果记为 L(a, b) 。举几个例子：</p>
<ul>
<li>L(10110, 10110) = (10010)<sub>2</sub> = 18</li>
<li>L(10110, 01011) = (00001)<sub>2</sub> = 1</li>
<li>L(01011, 01011) = (10000)<sub>2</sub> = 16</li>
<li>L(01011, 10110) = (01001)<sub>2</sub> = 9</li>
</ul>
<p>那么， 01 串 a 和 b 的胜率之比就是</p>
<p style="text-align: center">(L(b, b) – L(b, a)) : (L(a, a) – L(a, b))</p>
<p>因此， 10110 和 01011 的胜率之比就是 (16 – 9) : (18 – 1) ，也就是 7:17 。刚才玩家 B 的获胜概率 17/24 ≈ 71% 就是用这种方法算出来的。不过， John Conway 本人似乎从未发表过这个神奇公式的正确性证明。</p>
<p> </p>
<p>其实，之前在证明这个游戏对 B 更有利的时候，证明过程当中有一个小漏洞，我们有意没说：如果 Py = 000…00 的话，那么 0P 将会等于 Py ；类似地，如果 Py = 111…11 的话，那么 1P 将会等于 Py 。这违反了游戏的规则（两人不能选取相同的 01 串），而且也没法套在刚才的状态转移图里。好在，这两种情况单独分析起来非常容易。事实上，我们很容易证明， A 永远不应该选择 000…00 或者 111…11 ，因为这是最笨的策略。如果 A 选择的是 000…00 ，那么 B 只需要选择 100…00 即可。容易看出，只有开局后的前 n 位硬币序列恰好是 000…00 的情况下， A 才能获胜，如果第 n 次抛掷硬币以后 A 还没获胜的话，那么 B 就锁定胜局了——在出现 000…00 之前， 100…00 必然会先出现。因此， A 的胜率仅为 (1/2)<sup>n</sup> ，而 B 的胜率则为 1 – (1/2)<sup>n</sup> 。为什么说这是 A 最笨的策略呢？这是因为，不管 A 选择了什么 01 串，他获胜的概率至少也有 (1/2)<sup>n</sup> （即开局后的前 n 位硬币序列恰好如 A 所选的情况），因而刚才那种策略的获胜概率已经达到下限，糟糕得不能再糟糕了。类似地，如果 A 选择 111…111 ，那么 B 可以选择 011…11 ，这同样能让 A 的获胜概率降到最低。</p>
<p>讨论到这里，大家肯定想要问：那么， A 的最优策略又是什么呢？</p>
<p>1992 年， János Csirik 在一篇论文中指出，当 n &gt; 3 时， A 的最优策略之一是 1000…0011 （中间有 n – 3 个数字 0 ），此时 B 应该选择 01000…001 来应对，两人的胜率之比将会变成 (2<sup>n-2</sup> + 1) : (2<sup>n-1</sup> + 1) 。当 n = 3 时，查阅上面给出的表格可知， A 的最优策略可以是 010, 011, 100, 101 当中的任意一个。当然， A 的最优策略并不能让 A 的获胜概率大于 50% ，只能让 A 的损失尽可能地小罢了。</p>
<p> </p>
<p>对了，这个有趣的游戏叫做 Penney’s game ，它是由 Walter Penney 在 1969 年提出来的。</p>
			 ]]></content>
<pubDate>2014-07-10T21:36:51+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6015</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：寻找四个共圆的点 ]]></title>
<link>http://www.matrix67.com/blog/archives/6035</link>
<content><![CDATA[ 
		<p>5 张矩形的纸片和 6 张圆形的纸片散落在桌面上，如下图所示（其中一张矩形纸片被撕掉了一个角）。考虑所有露在外面的矩形顶点以及纸张边缘处的交点，你能否从中找出四个保证共圆的点？很简单，右下角那个绿色矩形的四个顶点就满足要求，因为矩形的四个顶点显然是共圆的。其实，在这个图里，还有另外三组满足要求的点，你能找到吗？</p>
<p class="indent"><img alt="image placeholder" >
<p><span id="more-6035"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>首先， A 、 B 、 C 、 D 这四个点显然是另一组满足要求的点。另一组不太容易找到的点则是 E 、 F 、 G 、 H 这四个点：由于 ∠EFG = ∠EHG = 90° ，因而 E 、 F 、 G 、 H 四点共圆。原题的答案本来到这里就结束了，但有趣的是，题目的原作者自己都没想到，满足要求的点还有一组：由于 ∠EMN = ∠EHN = 90° ，因而 E 、 M 、 H 、 N 四点也是共圆的。</p>
<p class="indent"><img alt="image placeholder" >
<p>这道题的修改版（用一个额外的圆形纸片盖住了 M 点）收录在了 Stephen Barr 的 Second Miscellany of Puzzles 一书中。我则是在 Martin Gardner 的 The Colossal Book of Short Puzzles and Problems 一书中看到的这道题。</p>
			 ]]></content>
<pubDate>2014-08-12T04:11:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6035</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 用三段 140 字符以内的代码生成一张 1024×1024 的图片 ]]></title>
<link>http://www.matrix67.com/blog/archives/6039</link>
<content><![CDATA[ 
		<p>Kyle McCormick 在 StackExchange 上发起了一个叫做 <a href="http://codegolf.stackexchange.com/questions/35569/tweetable-mathematical-art">Tweetable Mathematical Art</a> 的比赛，参赛者需要用三条推这么长的代码来生成一张图片。具体地说，参赛者需要用 C++ 语言编写 RD 、 GR 、 BL 三个函数，每个函数都不能超过 140 个字符。每个函数都会接到 i 和 j 两个整型参数（0 ≤ i, j ≤ 1023），然后需要返回一个 0 到 255 之间的整数，表示位于 (i, j) 的像素点的颜色值。举个例子，如果 RD(0, 0) 和 GR(0, 0) 返回的都是 0 ，但 BL(0, 0) 返回的是 255 ，那么图像的最左上角那个像素就是蓝色。参赛者编写的代码会被插进下面这段程序当中（我做了一些细微的改动），最终会生成一个大小为 1024×1024 的图片。</p>
<p><code>// NOTE: compile with g++ filename.cpp -std=c++11<br>
 <br>
#include &lt;iostream&gt;<br>
#include &lt;cmath&gt;<br>
#include &lt;cstdlib&gt;<br>
#define DIM 1024<br>
#define DM1 (DIM-1)<br>
#define _sq(x) ((x)*(x))                           // square<br>
#define _cb(x) abs((x)*(x)*(x))                    // absolute value of cube<br>
#define _cr(x) (unsigned char)(pow((x),1.0/3.0))   // cube root<br>
 <br>
unsigned char GR(int,int);<br>
unsigned char BL(int,int);<br>
 <br>
unsigned char RD(int i,int j){<br>
   // YOUR CODE HERE<br>
}<br>
unsigned char GR(int i,int j){<br>
   // YOUR CODE HERE<br>
}<br>
unsigned char BL(int i,int j){<br>
   // YOUR CODE HERE<br>
}<br>
 <br>
void pixel_write(int,int);<br>
FILE *fp;<br>
int main(){<br>
    fp = fopen("MathPic.ppm","wb");<br>
    fprintf(fp, "P6\n%d %d\n255\n", DIM, DIM);<br>
    for(int j=0;j&lt;DIM;j++)<br>
        for(int i=0;i&lt;DIM;i++)<br>
            pixel_write(i,j);<br>
    fclose(fp);<br>
    return 0;<br>
}<br>
void pixel_write(int i, int j){<br>
    static unsigned char color[3];<br>
    color[0] = RD(i,j)&amp;255;<br>
    color[1] = GR(i,j)&amp;255;<br>
    color[2] = BL(i,j)&amp;255;<br>
    fwrite(color, 1, 3, fp);<br>
}</code></p>
<p><span id="more-6039"></span></p>
<p>我选了一些自己比较喜欢的作品，放在下面和大家分享。</p>
<p> </p>
<p>首先是一个来自 Martin Büttner 的作品：</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p>它的代码如下：</p>
<p><code>unsigned char RD(int i,int j){<br>
<em>return (char)(_sq(cos(atan2(j-512,i-512)/2))*255);</em><br>
}<br>
 <br>
unsigned char GR(int i,int j){<br>
<em>return (char)(_sq(cos(atan2(j-512,i-512)/2-2*acos(-1)/3))*255);</em><br>
}<br>
 <br>
unsigned char BL(int i,int j){<br>
<em>return (char)(_sq(cos(atan2(j-512,i-512)/2+2*acos(-1)/3))*255);</em><br>
}</code></p>
<p> </p>
<p> </p>
<p>同样是来自 Martin Büttner 的作品：</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p>这是目前暂时排名第一的作品。它的代码如下：</p>
<p><code>unsigned char RD(int i,int j){<br>
<em>#define r(n)(rand()%n)<br>
static char c[1024][1024];return!c[i][j]?c[i][j]=!r(999)?r(256):RD((i+r(2))%1024,(j+r(2))%1024):c[i][j];</em><br>
}<br>
 <br>
unsigned char GR(int i,int j){<br>
<em>static char c[1024][1024];return!c[i][j]?c[i][j]=!r(999)?r(256):GR((i+r(2))%1024,(j+r(2))%1024):c[i][j];</em><br>
}<br>
 <br>
unsigned char BL(int i,int j){<br>
<em>static char c[1024][1024];return!c[i][j]?c[i][j]=!r(999)?r(256):BL((i+r(2))%1024,(j+r(2))%1024):c[i][j];</em><br>
}</code></p>
<p> </p>
<p> </p>
<p>下面这张图片仍然出自 Martin Büttner 之手：</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p>难以想象， Mandelbrot 分形图形居然可以只用这么一点代码画出：</p>
<p><code>unsigned char RD(int i,int j){<br>
<em>float x=0,y=0;int k;for(k=0;k++&lt;256;){float a=x*x-y*y+(i-768.0)/512;y=2*x*y+(j-512.0)/512;x=a;if(x*x+y*y&gt;4)break;}return log(k)*47;</em><br>
}<br>
 <br>
unsigned char GR(int i,int j){<br>
<em>float x=0,y=0;int k;for(k=0;k++&lt;256;){float a=x*x-y*y+(i-768.0)/512;y=2*x*y+(j-512.0)/512;x=a;if(x*x+y*y&gt;4)break;}return log(k)*47;</em><br>
}<br>
 <br>
unsigned char BL(int i,int j){<br>
<em>float x=0,y=0;int k;for(k=0;k++&lt;256;){float a=x*x-y*y+(i-768.0)/512;y=2*x*y+(j-512.0)/512;x=a;if(x*x+y*y&gt;4)break;}return 128-log(k)*23;</em><br>
}</code></p>
<p> </p>
<p> </p>
<p>Manuel Kasten 也制作了一个 Mandelbrot 集的图片，与刚才不同的是，该图描绘的是 Mandelbrot 集在某处局部放大后的结果：</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p>它的代码如下：</p>
<p><code>unsigned char RD(int i,int j){<br>
<em>double a=0,b=0,c,d,n=0;<br>
while((c=a*a)+(d=b*b)&lt;4&amp;&amp;n++&lt;880)<br>
{b=2*a*b+j*8e-9-.645411;a=c-d+i*8e-9+.356888;}<br>
return 255*pow((n-80)/800,3.);</em><br>
}<br>
 <br>
unsigned char GR(int i,int j){<br>
<em>double a=0,b=0,c,d,n=0;<br>
while((c=a*a)+(d=b*b)&lt;4&amp;&amp;n++&lt;880)<br>
{b=2*a*b+j*8e-9-.645411;a=c-d+i*8e-9+.356888;}<br>
return 255*pow((n-80)/800,.7);</em><br>
}<br>
 <br>
unsigned char BL(int i,int j){<br>
<em>double a=0,b=0,c,d,n=0;<br>
while((c=a*a)+(d=b*b)&lt;4&amp;&amp;n++&lt;880)<br>
{b=2*a*b+j*8e-9-.645411;a=c-d+i*8e-9+.356888;}<br>
return 255*pow((n-80)/800,.5);</em><br>
}</code></p>
<p> </p>
<p> </p>
<p>这是 Manuel Kasten 的另一作品：</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p>生成这张图片的代码很有意思：函数依靠 static 变量来控制绘画的进程，完全没有用到 i 和 j 这两个参数！</p>
<p><code>unsigned char RD(int i,int j){<br>
<em>static double k;k+=rand()/1./RAND_MAX;int l=k;l%=512;return l&gt;255?511-l:l;</em><br>
}<br>
 <br>
unsigned char GR(int i,int j){<br>
<em>static double k;k+=rand()/1./RAND_MAX;int l=k;l%=512;return l&gt;255?511-l:l;</em><br>
}<br>
 <br>
unsigned char BL(int i,int j){<br>
<em>static double k;k+=rand()/1./RAND_MAX;int l=k;l%=512;return l&gt;255?511-l:l;</em><br>
}</code></p>
<p> </p>
<p> </p>
<p>这是来自 githubphagocyte 的作品：</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p>它的代码如下：</p>
<p><code>unsigned char RD(int i,int j){<br>
<em>float s=3./(j+99);<br>
float y=(j+sin((i*i+_sq(j-700)*5)/100./DIM)*35)*s;<br>
return (int((i+DIM)*s+y)%2+int((DIM*2-i)*s+y)%2)*127;</em><br>
}<br>
 <br>
unsigned char GR(int i,int j){<br>
<em>float s=3./(j+99);<br>
float y=(j+sin((i*i+_sq(j-700)*5)/100./DIM)*35)*s;<br>
return (int(5*((i+DIM)*s+y))%2+int(5*((DIM*2-i)*s+y))%2)*127;</em><br>
}<br>
 <br>
unsigned char BL(int i,int j){<br>
<em>float s=3./(j+99);<br>
float y=(j+sin((i*i+_sq(j-700)*5)/100./DIM)*35)*s;<br>
return (int(29*((i+DIM)*s+y))%2+int(29*((DIM*2-i)*s+y))%2)*127;</em><br>
}</code></p>
<p> </p>
<p> </p>
<p>这是来自 githubphagocyte 的另一个作品：</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p>这是一张使用 diffusion-limited aggregation 模型得到的图片，程序运行起来要耗费不少时间。代码很有意思：巧妙地利用宏定义，打破了函数与函数之间的界限，三段代码的字数限制便能合在一起使用了。</p>
<p><code>unsigned char RD(int i,int j){<br>
<em>#define D DIM<br>
#define M m[(x+D+(d==0)-(d==2))%D][(y+D+(d==1)-(d==3))%D]<br>
#define R rand()%D<br>
#define B m[x][y]<br>
return(i+j)?256-(BL(i,j))/2:0;</em><br>
}<br>
 <br>
unsigned char GR(int i,int j){<br>
<em>#define A static int m[D][D],e,x,y,d,c[4],f,n;if(i+j&lt;1){for(d=D*D;d;d--){m[d%D][d/D]=d%6?0:rand()%2000?1:255;}for(n=1<br>
return RD(i,j);</em><br>
}<br>
 <br>
unsigned char BL(int i,int j){<br>
<em>A;n;n++){x=R;y=R;if(B==1){f=1;for(d=0;d&lt;4;d++){c[d]=M;f=f&lt;c[d]?c[d]:f;}if(f&gt;2){B=f-1;}else{++e%=4;d=e;if(!c[e]){B=0;M=1;}}}}}return m[i][j];</em><br>
}</code></p>
<p> </p>
<p> </p>
<p>最后这张图来自 Eric Tressler ：</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p>这是由 logistic 映射得到的 Feigenbaum 分岔图。和刚才一样，对应的代码也巧妙地利用了宏定义来节省字符：</p>
<p><code>unsigned char RD(int i,int j){<br>
<em>#define A float a=0,b,k,r,x<br>
#define B int e,o<br>
#define C(x) x&gt;255?255:x<br>
#define R return<br>
#define D DIM<br>
R BL(i,j)*(D-i)/D;</em><br>
}<br>
 <br>
unsigned char GR(int i,int j){<br>
<em>#define E DM1<br>
#define F static float<br>
#define G for(<br>
#define H r=a*1.6/D+2.4;x=1.0001*b/D<br>
R BL(i,j)*(D-j/2)/D;</em><br>
}<br>
 <br>
unsigned char BL(int i,int j){<br>
<em>F c[D][D];if(i+j&lt;1){A;B;G;a&lt;D;a+=0.1){G b=0;b&lt;D;b++){H;G k=0;k&lt;D;k++){x=r*x*(1-x);if(k&gt;D/2){e=a;o=(E*x);c[e][o]+=0.01;}}}}}R C(c[j][i])*i/D;</em><br>
}</code></p>
			 ]]></content>
<pubDate>2014-08-12T04:54:11+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6039</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 寻找相邻两项之比不趋于 1.618 的广义 Fibonacci 数列 ]]></title>
<link>http://www.matrix67.com/blog/archives/6063</link>
<content><![CDATA[ 
		<p>大家或许知道 Fibonacci 数列 1, 1, 2, 3, 5, 8, … 有一个非常漂亮的性质：数列中的相邻两项之比将会越来越接近黄金比例 (1 + √<span style="text-decoration: overline">5</span>) / 2 ≈ 1.618 。事实上，如果我们用 F(n) 来表示第 n 个 Fibonacci 数的话，那么当 n → ∞ 时，我们有 F(n + 1) / F(n) → (1 + √<span style="text-decoration: overline">5</span>) / 2 。</p>
<p>不过，可能有人并不知道，如果把 Fibonacci 数列的前两项换成两个其他的正整数（但保持 Fibonacci 数列的递推关系不变），由此所得的广义 Fibonacci 数列当中，相邻两项之比仍然会趋近于 (1 + √<span style="text-decoration: overline">5</span>) / 2 。比方说，如果数列的前两项为 7, 2 ，那么整个数列的前 15 项以及相邻两项之比的情况如下：</p>
<blockquote><p>7, 2, 9, 11, 20, 31, 51, 82, 133, 215, 348, 563, 911, 1474, 2385, …<br>
 <br>
2 / 7 = 0.28571429…<br>
9 / 2 = 4.5<br>
11 / 9 = 1.2222222…<br>
20 / 11 = 1.8181818…<br>
31 / 20 = 1.55<br>
51 / 31 = 1.6451613…<br>
82 / 51 = 1.6078431…<br>
133 / 82 = 1.6219512…<br>
215 / 133 = 1.6165414…<br>
348 / 215 = 1.6186047…<br>
563 / 348 = 1.6178161…<br>
911 / 563 = 1.6181172…<br>
1474 / 911 = 1.6180022…<br>
2385 / 1474 = 1.6180461…</p></blockquote>
<p>更神奇的是，即使最前面这两个数当中有一个负数或者都是负数，相邻两项之比的趋势依旧不变！举个例子，若数列的开头两项是 20 和 -13 ，则有：</p>
<blockquote><p>20, -13, 7, -6, 1, -5, -4, -9, -13, -22, -35, -57, -92, -149, -241, …<br>
 <br>
(-13) / 20 = -0.65<br>
7 / (-13) = -0.53846154<br>
(-6) / 7 = -0.85714286<br>
1 / (-6) = -0.16666667<br>
(-5) / 1 = -5<br>
(-4) / (-5) = 0.8<br>
(-9) / (-4) = 2.25<br>
(-13) / (-9) = 1.4444444<br>
(-22) / (-13) = 1.6923077<br>
(-35) / (-22) = 1.5909091<br>
(-57) / (-35) = 1.6285714<br>
(-92) / (-57) = 1.6140351<br>
(-149) / (-92) = 1.6195652<br>
(-241) / (-149) = 1.6174497</p></blockquote>
<p>事实上，不管数列的开头两项是多么奇怪的两个实数（比如 -7/2, √<span style="text-decoration: overline">2</span>, … 或者 π/10, -√<span style="text-decoration: overline">e</span>, … 等等），按照 Fibonacci 式的递推关系算出后面各项，相邻两项之比几乎总会趋于 (1 + √<span style="text-decoration: overline">5</span>) / 2 ！注意，刚才我们使用了“几乎”一词，因为这个结论其实并不总是成立。今天的题目就是：请你找出至少一个反例。也就是说，你需要找出至少一个由递推关系 a(i) = a(i – 1) + a(i – 2) 生成的数列，使得当 n 趋于无穷大时 a(n + 1) / a(n) 并不趋于 (1 + √<span style="text-decoration: overline">5</span>) / 2 。</p>
<p>对了， 0, 0, 0, 0, 0, … 这种情况自然不算。</p>
<p><span id="more-6063"></span></p>
<p> </p>
<p>为了方便起见，接下来我们把 (1 + √<span style="text-decoration: overline">5</span>) / 2 记作 φ ，它约等于 1.618 ；再把 (1 – √<span style="text-decoration: overline">5</span>) / 2 记作 φ’ ，它约等于 -0.618 。容易看出， φ 和 φ’ 是方程 1 + x = x<sup>2</sup> 的两根。如果数列的开头两项是 1 和 φ’ 的话，这个数列会是什么样呢？由于 1 + φ’ = φ’<sup>2</sup> ，因此数列的下一项是 φ’<sup>2</sup> ；由于 φ’ + φ’<sup>2</sup> = φ’ · (1 + φ’) = φ’ · φ’<sup>2</sup> = φ’<sup>3</sup> ，因此数列的下一项是 φ’<sup>3</sup>；由于 φ’<sup>2</sup> + φ’<sup>3</sup> = φ’<sup>2</sup> · (1 + φ’) = φ’<sup>2</sup> · φ’<sup>2</sup> = φ’<sup>4</sup> ，因此数列的下一项是 φ’<sup>4</sup> ……不断这样推下去，大家很快便会发现，整个数列其实就是这样：</p>
<p class="indent">1, φ’, φ’<sup>2</sup>, φ’<sup>3</sup>, φ’<sup>4</sup>, φ’<sup>5</sup>, φ’<sup>6</sup>, …</p>
<p>毫无疑问，这个数列的相邻两项之比永远是 φ’ = (1 – √<span style="text-decoration: overline">5</span>) / 2 ，并不会慢慢趋近于 φ = (1 + √<span style="text-decoration: overline">5</span>) / 2 。这就是一个满足要求的反例。万事开头难，有了第一个反例，再找更多的反例就不是难事了。比方说，所有以 c, c · φ’, … 开头的数列全都一并成为了反例，其中 c 可以是任意一个非 0 实数。</p>
<p>有趣的是，除此之外，再也没有其他的反例了。换句话说，如果你把相差一个系数的广义 Fibonacci 数列看作本质上相同的数列，那么刚才我们给出的反例是唯一的。下面我们就来证明这一点。</p>
<p> </p>
<p>首先注意到，让广义 Fibonacci 数列里的每一项都乘上非 0 实数 c ，得到的仍然是一个广义 Fibonacci 数列。也就是说，如果数列</p>
<p class="indent">a(1), a(2), a(3), a(4), a(5), …</p>
<p>是一个由 a(1) 和 a(2) 生成的广义 Fibonacci 数列，那么</p>
<p class="indent">c · a(1), c · a(2), c · a(3), c · a(4), c · a(5), …</p>
<p>就是一个由 c · a(1) 和 c · a(2) 生成的广义 Fibonacci 数列。</p>
<p>另外，两个广义 Fibonacci 数列之和必然也是一个广义 Fibonacci 数列。也就是说，如果数列</p>
<p class="indent">a(1), a(2), a(3), a(4), a(5), …</p>
<p>是一个由 a(1) 和 a(2) 生成的广义 Fibonacci 数列，并且数列</p>
<p class="indent">b(1), b(2), b(3), b(4), b(5), …</p>
<p>是一个由 b(1) 和 b(2) 生成的广义 Fibonacci 数列，那么数列</p>
<p class="indent">a(1) + b(1), a(2) + b(2), a(3) + b(3), a(4) + b(4), a(5) + b(5), …</p>
<p>就是一个由 a(1) + b(1) 和 a(2) + b(2) 生成的广义 Fibonacci 数列。</p>
<p>最后别忘了，刚才我们说过， φ 和 φ’ 是方程 1 + x = x<sup>2</sup> 的两根，因而数列</p>
<p class="indent">1, φ, φ<sup>2</sup>, φ<sup>3</sup>, φ<sup>4</sup>, φ<sup>5</sup>, φ<sup>6</sup>, …</p>
<p>和</p>
<p class="indent">1, φ’, φ’<sup>2</sup>, φ’<sup>3</sup>, φ’<sup>4</sup>, φ’<sup>5</sup>, φ’<sup>6</sup>, …</p>
<p>就成了两个非常特别的广义 Fibonacci 数列。</p>
<p> </p>
<p>把上面三点结合起来，我们将会得出结论：一切广义 Fibonacci 数列都可以表示成</p>
<p class="indent">k + l, k · φ + l · φ’, k · φ<sup>2</sup> + l · φ’<sup>2</sup>, k · φ<sup>3</sup> + l · φ’<sup>3</sup>, k · φ<sup>4</sup> + l · φ’<sup>4</sup>, k · φ<sup>5</sup> + l · φ’<sup>5</sup>, …</p>
<p>的形式，其中 k 和 l 是两个适当的常数。例如，为了把经典的 Fibonacci 数列</p>
<p class="indent">1, 1, 2, 3, 5, 8, … </p>
<p>表示成刚才那种形式，我们只需要找出合适的 k 和 l ，使得它们同时满足</p>
<p class="indent">k + l = 1, k · φ + l · φ’ = 1</p>
<p>这两个方程。解得 k = φ / √<span style="text-decoration: overline">5</span>, l = – φ’ / √<span style="text-decoration: overline">5</span> ，因而 Fibonacci 数列实际上就是</p>
<p class="indent">(φ / √<span style="text-decoration: overline">5</span>) – (φ’ / √<span style="text-decoration: overline">5</span>), (φ / √<span style="text-decoration: overline">5</span>) · φ – (φ’ / √<span style="text-decoration: overline">5</span>) · φ’, (φ / √<span style="text-decoration: overline">5</span>) · φ<sup>2</sup> – (φ’ / √<span style="text-decoration: overline">5</span>) · φ’<sup>2</sup>, (φ / √<span style="text-decoration: overline">5</span>) · φ<sup>3</sup> – (φ’ / √<span style="text-decoration: overline">5</span>) · φ’<sup>3</sup>, …</p>
<p>或者干脆写作</p>
<p class="indent">(φ – φ’) / √<span style="text-decoration: overline">5</span>, (φ<sup>2</sup> – φ’<sup>2</sup>) / √<span style="text-decoration: overline">5</span>, (φ<sup>3</sup> – φ’<sup>3</sup>) / √<span style="text-decoration: overline">5</span>, (φ<sup>4</sup> – φ’<sup>4</sup>) / √<span style="text-decoration: overline">5</span>, …</p>
<p>这正是 Fibonacci 数列的通项公式。类似地，为了求出广义 Fibonacci 数列</p>
<p class="indent">20, -13, 7, -6, 1, -5, -4, -9, -13, -22, …</p>
<p>的通项公式，我们只需要求解关于 k 和 l 的二元一次方程组</p>
<p class="indent">k + l = 20, k · φ + l · φ’ = -13</p>
<p>解得 k = 10 – 23 / √<span style="text-decoration: overline">5</span>, l = 10 + 23 / √<span style="text-decoration: overline">5</span> ，因而该数列其实就是</p>
<p class="indent">(10 – 23 / √<span style="text-decoration: overline">5</span>) + (10 + 23 / √<span style="text-decoration: overline">5</span>), (10 – 23 / √<span style="text-decoration: overline">5</span>) · φ + (10 + 23 / √<span style="text-decoration: overline">5</span>) · φ’, (10 – 23 / √<span style="text-decoration: overline">5</span>) · φ<sup>2</sup> + (10 + 23 / √<span style="text-decoration: overline">5</span>) · φ’<sup>2</sup>, (10 – 23 / √<span style="text-decoration: overline">5</span>) · φ<sup>3</sup> + (10 + 23 / √<span style="text-decoration: overline">5</span>) · φ’<sup>3</sup>, …</p>
<p> </p>
<p>注意， φ 是一个绝对值大于 1 的数， φ’ 是一个绝对值小于 1 的数，因而随着 n 的增加， φ<sup>n</sup> 很快便会变得非常非常大，同时 φ’<sup>n</sup> 也会很快变得非常非常接近于 0 。因此，就算 k 的绝对值再小，就算 l 的绝对值再大， k · φ<sup>n</sup> + l · φ’<sup>n</sup> 的值也会很快变得和 k · φ<sup>n</sup> 几乎相同，相邻两项之比基本上就相当于是 k · φ<sup>n+1</sup> 和 k · φ<sup>n</sup> 之比，自然也就等于 φ 了。除非……除非 k 等于 0 ！因此，广义 Fibonacci 数列的相邻两项之比不趋于 φ 的情况仅此一种，此时整个数列实际上为：</p>
<p class="indent">l, l · φ’, l · φ’<sup>2</sup>, l · φ’<sup>3</sup>, l · φ’<sup>4</sup>, l · φ’<sup>5</sup>, …</p>
<p> </p>
<p>最近在 reddit 上看到了<a href="http://www.reddit.com/r/math/comments/2cvuh7/fibonacci_sequence_approaches_the_golden_ratio/">这个帖子</a>，网友 Gro-Tsen 的<a href="http://www.reddit.com/r/math/comments/2cvuh7/fibonacci_sequence_approaches_the_golden_ratio/cjjlcmr">回复</a>让人有醍醐灌顶之感，故写此文记之。</p>
			 ]]></content>
<pubDate>2014-08-14T20:18:31+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6063</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：竞技场里的狮子能否保证抓住最高速度相同的小明？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6090</link>
<content><![CDATA[ 
		<p>小明和狮子同被关在一个半径为 10 米的竞技场里，狮子位于竞技场的圆心处，小明则在距离圆心 1 米的地方。两者的最大运动速度都是每秒 1 米。狮子有没有什么必胜策略，使得不管小明怎么跑，它总能在有限的时间里抓住小明？</p>
<p>根据 <a href="http://mathworld.wolfram.com/LionandManProblem.html">MathWorld</a> 相关词条的描述，这个问题是由 R. Rado 在 1925 年时提出的。一个经典的“答案”是，狮子只需要始终保持自己与小明在圆盘的同一半径上即可。直觉上看，由于狮子总是处在“内圈”上，因而不管小明跑到了哪里，狮子总能轻松地与小明继续保持在同一半径上；并且，狮子总有足够的余力向小明靠近，严格减小它与小明之间的距离，除非小明是沿着半径方向径直向外跑。由于竞技场的大小是有限的，小明不可能无限地向外跑，因而狮子最终总会追上小明。但是，后来人们发现，这个解法其实是错误的，原因很简单：能不断靠近小明，不一定就能在有限的时间里抓住小明，正如 1/2 + 1/4 + 1/8 + 1/16 + … 永远不会超过 1 一样。最终， A. S. Besicovitch 为小明构造出了一个极其巧妙的策略，使得狮子无论如何都抓不到小明，从而完美地解决了这个问题。不过， MathWorld 的词条里并没有提到这个解法。你能想到这个解法吗？</p>
<p><span id="more-6090"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>A. S. Besicovitch 为小明设计的策略如下。游戏开始后，小明首先把接下来的时间分成一小段一小段的，这些时间段的长度依次为 t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>, t<sub>4</sub>, … 。不妨把竞技场的圆心记作 O ，把小明当前的位置记作 M 。每个时间段开始的时候，小明都会看看此时此刻线段 OM 的位置，并且沿着垂直于 OM 的方向，以最高速度往没有狮子的那一侧跑去（如果狮子的位置恰好位于 OM 所在直线上，则向任意一侧跑去）。容易看出，不管在哪个时间段里，狮子都不可能追到小明。如果把第 i 个时段结束后小明与圆心的距离 OM 记作 r<sub>i</sub> ，那么由勾股定理可知：</p>
<p class="indent">r<sub>i</sub><sup>2</sup> = r<sub>i-1</sub><sup>2</sup> + (t<sub>i</sub> · 1)<sup>2</sup> = r<sub>i-1</sub><sup>2</sup> + t<sub>i</sub><sup>2</sup></p>
<p>其中 r<sub>0</sub> = 1 。</p>
<p class="indent"><img alt="image placeholder" >
<p>因此，当 t<sub>1</sub> + t<sub>2</sub> + t<sub>3</sub> + … + t<sub>n</sub> 这么多的时间过去以后，小明与圆心的距离 OM 满足</p>
<p class="indent">OM<sup>2</sup> = r<sub>n</sub><sup>2</sup> = 1<sup>2</sup> + t<sub>1</sub><sup>2</sup> + t<sub>2</sub><sup>2</sup> + t<sub>3</sub><sup>2</sup> + … + t<sub>n</sub><sup>2</sup></p>
<p>最巧妙的地方来了。令 t<sub>i</sub> = 1/i ，那么 t<sub>1</sub> + t<sub>2</sub> + t<sub>3</sub> + … 是发散的，但 t<sub>1</sub><sup>2</sup> + t<sub>2</sub><sup>2</sup> + t<sub>3</sub><sup>2</sup> + … 却是收敛的。具体地说：</p>
<blockquote><p>   t<sub>1</sub> + t<sub>2</sub> + t<sub>3</sub> + t<sub>4</sub> + t<sub>5</sub> + …<br>
= 1 + 1/2 + 1/3 + 1/4 + 1/5 + 1/6 + 1/7 + 1/8 + 1/9 + …<br>
&gt; 1 + 1/2 + 1/4 + 1/4 + 1/8 + 1/8 + 1/8 + 1/8 + 1/16 + …<br>
= 1 + 1/2 + (1/4) × 2 + (1/8) × 4 + (1/16) × 8 + …<br>
= 1 + 1/2 + 1/2 + 1/2 + 1/2 + …</p></blockquote>
<p>它显然可以达到任意大。而</p>
<blockquote><p>   t<sub>1</sub><sup>2</sup> + t<sub>2</sub><sup>2</sup> + t<sub>3</sub><sup>2</sup> + t<sub>4</sub><sup>2</sup> + t<sub>5</sub><sup>2</sup> + …<br>
= 1 + 1/2<sup>2</sup> + 1/3<sup>2</sup> + 1/4<sup>2</sup> + 1/5<sup>2</sup> + …<br>
&lt; 1 + 1/(1×2) +  1/(2×3) +  1/(3×4) +  1/(4×5) + …<br>
= 1 + (1 – 1/2) + (1/2 – 1/3) + (1/3 – 1/4) + (1/4 – 1/5) + …<br>
= 1 + 1 – 1/2 + 1/2 – 1/3 + 1/3 – 1/4 + 1/4 – 1/5 + …<br>
≤ 2</p></blockquote>
<p>因而 OM<sup>2</sup> 始终不超过 1 + 2 = 3 ， OM 的长度也就始终不超过 √<span style="text-decoration: overline">3</span> ≈ 1.732，这远远小于竞技场的半径（事实上， OM<sup>2</sup> 的极限是 1 + π<sup>2</sup> / 6 ，可以算出 OM 的极限约为 1.63 ）。这说明，不管时间过去了多久，小明始终在坚持运动，并且运动路线始终在可活动范围以内。既然每一个时间段里狮子都无法抓到小明，狮子自然也就永远抓不到小明了。</p>
<p>题目和解答最早应该出自 John Littlewood 的 A Mathematician’s Miscellany 一书当中。图片中的小狮子图标来自<a href="http://www.iconarchive.com/show/ultrabuuf-icons-by-mattahan/Young-Lion-icon.html">这里</a>，小明图标则来自<a href="http://www.iconarchive.com/show/face-avatars-icons-by-hopstarter/Male-Face-B5-icon.html">这里</a>。题目里的“策略”一词缺乏形式化的描述，这使得本文的内容非常不严谨，同时还会引发很多其他有趣的讨论，感兴趣的读者可以见<a href="http://www.maths.qmul.ac.uk/~walters/papers/lion-and-man-journal.pdf">这里</a>。</p>
			 ]]></content>
<pubDate>2014-08-30T03:38:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6090</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 利用重心推导平方和公式 ]]></title>
<link>http://www.matrix67.com/blog/archives/6105</link>
<content><![CDATA[ 
		<p>假设平面上有 1 + 2 + 3 + … + n 个小球，每个小球的质量都是 1kg 。它们排成了一个三角形阵，具体地说，它们排成了一个倒置的、以 (0, 1) 为顶点的等边三角形。这个三角形阵作为一整个物体，它的重心的 y 坐标是多少？我们有两种不同的求解方法。</p>
<p class="indent"><img alt="image placeholder" >
<p><span id="more-6105"></span><br>
第一种方法是暴力方法。这个物体的重心的 y 坐标，一定等于所有小球的 y 坐标的平均值，即</p>
<p class="indent">(1 × 1 + 2 × 2 + 3 × 3 + … + n × n) / (1 + 2 + 3 + … + n)</p>
<p>或者写作</p>
<p class="indent">(1<sup>2</sup> + 2<sup>2</sup> + 3<sup>2</sup> + … + n<sup>2</sup>) / (n · (n + 1) / 2)</p>
<p>另一种方法则是利用图形的对称性。由对称性，整个三角形阵的重心显然应该位于这个三角形各边中线的交点上，一些经典的几何结论可以告诉我们，这个交点正好把每条中线都分成了 1 : 2 两段。因而，这个点的 y 坐标就是</p>
<p class="indent">1 + 2 · (n – 1) / 3 = (2 n + 1) / 3</p>
<p>这两种方法求出来的答案应该相等。于是，我们得到了等式</p>
<p class="indent">(1<sup>2</sup> + 2<sup>2</sup> + 3<sup>2</sup> + … + n<sup>2</sup>) / (n · (n + 1) / 2) = (2 n + 1) / 3</p>
<p>即</p>
<p class="indent">1<sup>2</sup> + 2<sup>2</sup> + 3<sup>2</sup> + … + n<sup>2</sup> = n · (n + 1) · (2 n + 1) / 6</p>
<p>这个方法是我在 Proofs Without Words II – More Exercises in Visual Thinking 一书里看到的。</p>
			 ]]></content>
<pubDate>2014-09-01T03:45:31+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6105</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：圆内接八边形的面积 ]]></title>
<link>http://www.matrix67.com/blog/archives/6116</link>
<content><![CDATA[ 
		<p>一个圆内接八边形，各边长度依次为 2, 2, 2, 2, 3, 3, 3, 3 。求这个八边形的面积。</p>
<p class="indent"><img alt="image placeholder" >
<p><span id="more-6116"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>假设圆的半径为 R 。整个八边形是由 4 个三边分别为 3, R, R 的三角形和 4 个三边分别为 2, R, R 的三角形组成。如果我们重新摆放这 8 个三角形，让这两种三角形交替出现的话，整个图形的面积是不会变的。然而，新的八边形相当于是一个边长为 3 + 2√<span style="text-decoration: overline">2</span> 的正方形去掉了 4 个直角边为 √<span style="text-decoration: overline">2</span> 的等腰直角三角形以后所得的图形。它的面积是 (3 + 2√<span style="text-decoration: overline">2</span>)<sup>2</sup> – 4 = 13 + 12√<span style="text-decoration: overline">2</span> 。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>这是 1978 年 Putnam 数学竞赛的 B1 题。我是在 Proofs Without Words II – More Exercises in Visual Thinking 一书里看到的题目及其解法。</p>
			 ]]></content>
<pubDate>2014-09-22T21:09:25+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6116</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 45 道 Bongard 问题：寻找图形分类的依据 ]]></title>
<link>http://www.matrix67.com/blog/archives/6124</link>
<content><![CDATA[ 
		<p>如果让你设计一种用于人工智能测试的谜题，你会怎么设计？俄国计算机科学家 Mikhail Moiseevich Bongard 在 1967 年出版的 Проблема Узнавания 一书中提出了一种“图形分类依据”型的谜题。谜题的规则很简单：现已按照某种依据把 12 张图片分成了左右两组（每组各 6 张），问依据是什么。在 Проблема Узнавания 的附录中， Bongard 自己出了 100 道题，并把它们依次编号为 1, 2, 3, …, 100 。很多题目对于人类来说非常简单，分类依据几乎是一目了然；但是，要想设计某种算法让计算机自动解出，则是一件看上去几乎不可能完成的任务。下面这张图是书上第 283 页的三个谜题。第 7 号谜题的答案是，左边的图形都是竖着的，右边的图形都是横着的；第 8 号谜题的答案是，左边的图形都在右边，右边的图形都在左边；第 9 号谜题的答案是，左边的图形都是平滑的线条，右边的图形都是波浪形线条。</p>
<p class="indent"><img alt="image placeholder" >
<p><span id="more-6124"></span>这 100 道题里还有很多难题，可能是人类也要看半天才能看出来的。下面这张图是书上第 298 页的三个谜题。第 52 号谜题的答案是，左边的图形箭头方向相反，右边的图形箭头方向相同；第 53 号谜题的答案是，左边的图形中外面那个多边形拥有更多的边，右边的图形中里面那个多边形拥有更多的边；第 54 号谜题的答案是，左边的图形顺时针依次是＋○△，右边的图形逆时针依次是＋○△。</p>
<p class="indent"><img alt="image placeholder" >
<p>1970 年，这本书的英译版 Pattern Recognition 登陆美国。认知科学专家 Douglas Hofstadter 对附录中的这些谜题产生了极大的兴趣。他把这些问题叫做 Bongard 问题，并且还自编了 56 道新的问题。在他的神作 Gödel, Escher, Bach: An Eternal Golden Braid 一书中， Bongard 问题也没少出镜。</p>
<p class="indent"><img alt="image placeholder" >
<p>Harry Foundalis 对 Bongard 问题也非常感兴趣。他在已有题库的基础上又增加了 44 道题目，从而把问题的编号扩展到了 200 。你可以在 Foundalis 的<a href="http://www.foundalis.com/res/bps/bpidx.htm">个人网站</a>上看到这些谜题。</p>
<p>最近，我也迷上了 Bongard 问题。我从这 200 道题目中选择了 45 道题，并把它们分成了简单、中等、困难三个难度，每个难度各 15 道题。很多简单题都会让我产生一种超越机器的自豪感，同时也会让我由衷地敬佩题目作者变着法子虐人工智能的能力。个别难题则真的非常非常难，足够荒废大家一下午的时间了。希望大家能够喜欢。</p>
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 01. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 02. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 03. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 04. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 05. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 06. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 07. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 08. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 09. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 10. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 11. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 12. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 13. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 14. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">EASY 15. </span><img alt="image placeholder" >
<p>答案：</p>
<ol class="indent">
<li>无 | 有</li>
<li>空 | 实</li>
<li>大 | 小</li>
<li>直边 | 曲边</li>
<li>歪斜 | 对称</li>
<li>封闭 | 有缺口</li>
<li>顺时针 | 逆时针</li>
<li>渐强 | 渐弱</li>
<li>一条线 | 两条线</li>
<li>方向统一 | 方向杂乱</li>
<li>两侧数量相等 | 两侧数量不等</li>
<li>实心圆在内部 | 实心圆在端点</li>
<li>竖纹 | 横纹</li>
<li>三角形 | 圆形</li>
<li>三 | 四</li>
</ol>
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 01. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 02. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 03. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 04. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 05. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 06. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 07. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 08. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 09. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 10. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 11. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 12. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 13. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 14. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">MEDIUM 15. </span><img alt="image placeholder" >
<p>答案：</p>
<ol class="indent">
<li>凸图形 | 凹图形</li>
<li>水平通道 | 竖直通道</li>
<li>末梢逐渐变小 | 末梢逐渐变大</li>
<li>三角形在圆形上 | 三角形在圆形下</li>
<li>三角形比圆大 | 三角形比圆小</li>
<li>空心图形覆盖实心图形 | 实心图形覆盖空心图形</li>
<li>两点连线成 \ 形 | 两点连线成 / 形</li>
<li>四个交点 | 两个交点</li>
<li>圆圈在不同分支上 | 圆圈在同一分支上</li>
<li>实心物体更多 | 空心物体更多</li>
<li>框内的三个圆圈距离很近 | 框外的三个圆圈距离很近</li>
<li>加号到两个圆点距离相等 | 加号到两个圆点距离不等</li>
<li>图形嵌套可达两层 | 图形嵌套最多一层</li>
<li>三线延长后交于一点 | 三线延长后不交于一点</li>
<li>左分支的顶端比右分支低 | 左分支的顶端比右分支高</li>
</ol>
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 01. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 02. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 03. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 04. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 05. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 06. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 07. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 08. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 09. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 10. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 11. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 12. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 13. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 14. </span><img alt="image placeholder" >
<p><span style="color: #009bdf; font-size: 24px; padding-top: 5px; ">HARD 15. </span><img alt="image placeholder" >
<p>答案：</p>
<ol class="indent">
<li>线条两端距离很远 | 线条两端距离很近</li>
<li>线条首段和尾段平行 | 线条首段和尾段垂直</li>
<li>有三条简单型的边 | 有三条修饰型的边</li>
<li>实心部分正往宽处漫延 | 实心部分正往窄处漫延</li>
<li>连接后成等腰三角形 | 连接后成斜三角形</li>
<li>三角形指向圆心 | 三角形不指向圆心</li>
<li>多边形以某条边为底 | 多边形以某个顶点为底</li>
<li>实心圆离空心圆更近 | 实心圆离三角形更近</li>
<li>两个小物体之间的连线不被阻挡 | 两个小物体之间的连线会被阻挡</li>
<li>三个点的横坐标等距 | 三个点的纵坐标等距</li>
<li>四个点构成平行四边形 | 四个点不构成平行四边形</li>
<li>边数和点数相等 | 边数和点数不等</li>
<li>圆圈在加号构成的凸包内 | 圆圈在加号构成的凸包外</li>
<li>去掉共线三点后剩下两点呈 : 状 | 去掉共线三点后剩下两点呈 · · 状</li>
<li>依据性质进行分类 | 依据数量进行分类</li>
</ol>
			 ]]></content>
<pubDate>2014-09-23T19:20:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6124</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用两枚硬币随机生成 1 到 n 之间的整数 ]]></title>
<link>http://www.matrix67.com/blog/archives/6151</link>
<content><![CDATA[ 
		<p>为了随机地并且概率均等地生成一个 1 到 6 之间的整数，通常的做法就是抛掷一个正方体的骰子。不过，这并不是唯一的办法。如果你有一枚公正的、正反概率相同的硬币，以及一枚不公正的、正反概率之比为 1 : 2 的硬币，那么你也能概率均等地生成一个 1 到 6 之间的整数。首先抛掷那枚不公正的硬币，那么结果有 1/3 的概率是正面朝上，有 2/3 的概率是反面朝上。如果出现了正面朝上的情况，那么令 i = 1 ；如果出现了反面朝上的情况，那么就再抛掷那枚公正的硬币，掷出正面则令 i = 2 ，掷出反面则令 i = 3 。最后，再抛掷一次公正的硬币，如果正面朝上则令 j = 0 ，如果反面朝上则令 j = 3 。容易看出， i + j 的值有 1, 2, 3, 4, 5, 6 这六种可能，它们出现的概率是均等的，都是 1/6 。</p>
<p>有人或许会说，用硬币模拟骰子哪有那么复杂，只用一枚公正的硬币就能办到：连续抛掷三次硬币，并且规定掷出“正正正”代表数字 1 ，掷出“正正反”代表数字 2 ，“正反正”为 3 ，“正反反”为 4 ，“反正正”为 5 ，“反正反”为 6 ，掷出“反反正”和“反反反”则重来，这不就行了吗？不过，这种方法有一个局限性：它不能保证整个过程在有限步之内完成。而我们刚才的方法中，总的步骤数有一个上限：三步之内必然完成。</p>
<p>我们的问题是：是否对于所有的正整数 n ，都能找到两枚合适的硬币，使得借助它们便能在有限步之内概率均等地产生一个 1 到 n 之间的整数？</p>
<p><span id="more-6151"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>答案是肯定的。接下来，我们将会构造性地证明，不管 n 是多少，我们总能使用正反出现概率分别为 1:1 和 1:(n-1) 的两枚硬币，在有限的步数内达成目的。不妨先以 n = 11 时的做法为例，来说明我们的大致思路。</p>
<p>当 n = 11 时，首先把 1:1 的那枚硬币连续抛掷五次，这会出现 32 种等概率的正反组合，然后抛掷 1:10 的那枚硬币，出现正面和出现反面的概率分别为 1/11 和 10/11 。</p>
<p>抛完这六次硬币后，一共会产生 64 种不同的情况，其中 32 种情况出现的概率都是 (1/32) × (1/11) = 1/352 ，另外 32 种情况出现的概率则都是 (1/32) × (10/11) = 10/352 。我们可以在一个单位正方形里直观地表示出这 64 种情况：先用一系列横线把整个正方形划分成 32 个等宽横条，再在左起 1/11 的地方画一条竖线，把每个横条都分成 1:10 两份。图中的这 64 个区域就对应着可能出现的 64 种情况，每个区域的面积占整个正方形的多少，就表示与之对应的情况出现的概率是多少。我们可以把整个正方形看作是由 32 × 11 = 352 个小格子组成的，那么每个格子的面积都占整个正方形的 1/352 ，左边每个区域都只包含 1 个格子，右边每个区域则都包含 10 个格子。</p>
<p class="indent"><img alt="image placeholder" >
<p>如果我们能把某些区域指派给数字 1 ，把另一些区域指派给数字 2 ，等等，最后把剩下的区域指派给 11 ，使得分给每个数字的区域都包含 32 个格子，即都占正方形总面积的 1/11 的话，问题就解决了。在上面这个图中，这件事情是可以办到的。每 2 个左边的区域和 3 个右边的区域加在一起，正好组成 32 个格子。这样推算下去，划分出 1, 2, 3, …, 10 的地盘，就会用掉左边的 20 个区域和右边的 30 个区域。最后，左边还剩下 12 个区域，右边还剩下 2 个区域，正好又组成了 32 个格子，它们正好成了 11 的地盘。像刚才所说的那样完成六次抛掷后，看看出现的情况位于哪个数的地盘里，便能等概率地产生 1 到 11 之间的整数了。</p>
<p>同样的思路可以适用于任意正整数 n 。取一枚公平的硬币并连续抛掷 k 次，再抛掷一枚正反概率为 1:(n-1) 的硬币，整个概率空间就被分成了 2<sup>k</sup> × 2 个区域，左边每个区域都占 1 小格，右边每个区域都占 n-1 小格，所有区域加在一起一共有 2<sup>k</sup> · n 个小格。我们的目标便是把这些区域重新组合成 n 份，使得每份正好都是 2<sup>k</sup> 个小格。令 q 等于 2<sup>k</sup> 除以 n-1 的商，令 r 等于 2<sup>k</sup> 除以 n-1 的余数，那么每次选择 q 个右边的区域和 r 个左边的区域相搭配，正好就是 2<sup>k</sup> 小格，可供 1 到 n 中的其中一个数使用。如果 q = r ，那么右边的区域和左边的区域会同时用完，于是大功告成。如果 q &gt; r ，那么右边的区域会率先出现不够用的局面，不过这没有关系：右边的每一个区域都可以等效地用左边的 n-1 个区域来代替，因而不够的话总是能从左边找补回来的。如果 q &lt; r 的话，这就真的不好办了，不过幸运的是，我们还留有一手：我们可以精心选择 k 的值，来避免 q &lt; r 。</p>
<p>比方说，刚才 n = 11 时，我们选择的 k 值为 5 ，此时 2<sup>k</sup> 除以 n-1 的商 q = 3 ，余数 r = 2 。对于其他的正整数 n ，我们总能选择一个合适的 k ，使得 2<sup>k</sup> 除以 n-1 的商和余数满足 q ≥ r 吗？是的。我们至少可以这么做：注意到余数 r 始终小于除数 n-1 ，因此我们只需要让商数 q 至少是 n-1 即可；因而，选取足够大的 k ，使得 2<sup>k</sup> ≥ (n-1)<sup>2</sup> ，便能保证 q ≥ r 了。</p>
<p>题目来源：<a href="http://www.brand.site.co.il/riddles/201410q.html">http://www.brand.site.co.il/riddles/201410q.html</a></p>
			 ]]></content>
<pubDate>2014-11-05T00:25:21+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6151</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 高度对称的多面体和它们的对偶多面体 ]]></title>
<link>http://www.matrix67.com/blog/archives/6161</link>
<content><![CDATA[ 
		<p>正四面体、正方体、正八面体、正十二面体、正二十面体，这是古希腊人就发现的五种正多面体，它们拥有最高标准的对称性。这五种正多面体又叫做 Platonic 体，它们在古希腊的哲学观念中占据着至关重要的地位。 Leonhard Euler 发现，多面体的顶点数 V 、棱数 E 和面数 F 一定满足公式 V – E + F = 2 ，这叫做 Euler 多面体公式。利用这个公式，我们可以证明正多面体只有五种。假设一个正多面体的每个面都是正 p 边形，那么所有 F 个面一共就有 p · F 条边；每两条边拼在一起形成了一条棱，因而总的棱数就是 E = p · F / 2 。反过来， F 就应该等于 2 · E / p 。不妨再假设每个顶点处都汇集了 q 条棱，那么总的棱数似乎应有 q · V 个；但这样计算的话，每条棱都被重复算了两次，因而总的棱数实际上应该是 E = q · V / 2 。反过来， V 就应该等于 2 · E / q 。另外， Euler 的多面体公式告诉我们， V – E + F = 2 始终成立。</p>
<p>把上面几个式子合在一起，于是得到：</p>
<p class="indent">2 · E / q – E + 2 · E / p = 2</p>
<p>整理可得：</p>
<p class="indent">1/p + 1/q – 1/2 = 1/E</p>
<p>因此， 1/p + 1/q 一定大于 1/2 。但是，正多面体每个面至少都有三条边，每个顶点也至少汇集了三条棱，因此 p 和 q 都是大于等于 3 的整数。要想 1/p + 1/q &gt; 1/2 ，只有以下五种可能：</p>
<ol>
<li>p = 3 ， q = 3</li>
<li>p = 3 ， q = 4</li>
<li>p = 4 ， q = 3</li>
<li>p = 3 ， q = 5</li>
<li>p = 5 ， q = 3</li>
</ol>
<p>这正好对应于那五种正多面体。最近 <a href="http://localhost-8080.com/2014/11/mathematica-wolframalpha-logo-origami/">Localhost-8080</a> 沉迷于折纸，我也因此学习了不少与多面体相关的东西。想不到，这些看似老生常谈的东西，里面的水可深着呢。这五种正多面体表面上只是问题的五个不同的解，但互相之间却有着出人意料的联系。我们再列一个更加完整的表格，有意思的东西会慢慢呈现出来：</p>
<table>
<tr>
<td width="15%">名称</td>
<td width="15%">面数 F</td>
<td width="15%">顶点数 V</td>
<td width="15%">棱数 E</td>
<td width="20%">每个面的边数 p</td>
<td width="20%">每个顶点处的棱数 q</td>
</tr>
<tr>
<td>正四面体</td>
<td>4</td>
<td>4</td>
<td>6</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>正方体</td>
<td>6</td>
<td>8</td>
<td>12</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>正八面体</td>
<td>8</td>
<td>6</td>
<td>12</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>正十二面体</td>
<td>12</td>
<td>20</td>
<td>30</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>正二十面体</td>
<td>20</td>
<td>12</td>
<td>30</td>
<td>3</td>
<td>5</td>
</tr>
</table>
<p><span id="more-6161"></span>很容易看出，这五种多面体是成对出现的。你会发现，正方体和正八面体的面数 F 和顶点数 V 互相颠倒， p 值和 q 值也互相颠倒，棱数 E 则相同。其实，这并不是巧合。如果作出正方体的每个面的中心，再把相邻的面所对应的中心连在一起，就会得到一个正八面体；再作出正八面体的每个面的中心，和刚才一样把它们连起来，又会变回正方体。我作了一个动画，直观地表明了它们之间的关系。</p>
<p class="indent"><img alt="image placeholder" >
<p>容易看出，每次变换前后，原图形的每个面与新图形的每个顶点一一对应，原图形的每个顶点与新图形的每个面一一对应，因此两种图形的面数 F 和顶点数 V 是互相颠倒的。同时，原图形中的两个相邻的面，就变成了新图形中的两个相邻的顶点，因而原图形的每个面有多少条边，新图形的每个顶点处就会引出多少条棱；原图形中的两个相邻的顶点，也会变成新图形中的两个相邻的面，因而原图形的每个顶点有多少条棱，在新图形中它就会被多少条边框住。这也就解释了 p 和 q 互相颠倒的原因。最后，原图形的每条棱和新图形的每条棱也都是一一对应的，而且每两条对应的棱在空间中正好垂直。我们把变换前后的两个多面体叫做一对“对偶多面体”（dual polyhedron）。</p>
<p>类似地，正十二面体和正二十面体也拥有互相颠倒的 F 和 V ，以及互相颠倒的 p 和 q ，以及同样数目的 E ，这也是因为它们互为对方的对偶多面体。我也作了一个动画来演示这一点。</p>
<p class="indent"><img alt="image placeholder" >
<p>那么，正四面体怎么办呢？这就是我觉得最好玩的事情了：它和它自己对偶！</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p>有一件事情刚才我们有意一直没提：究竟什么叫做正多面体。简单地说，正多面体（regular polyhedron）指的是这样的多面体：它的所有顶点都是一样的，所有的棱都是一样的，所有的面也都是一样的。所谓“所有顶点都一样”，意思就是，这些顶点之间没有本质上的差异，每个顶点都能充当其他任何顶点的角色。换句话说，你可以把任意一个顶点挪到任意另一个顶点所在的位置，然后利用平移、旋转和镜像这几种操作，让整个图形和原来完全重合。类似地，“所有棱都一样”就表示每条棱都可以变到每条棱的位置，“所有面都一样”也就表示每个面都可以等价地替换每个面。正多面体同时满足“所有顶点都一样”、“所有棱都一样”和“所有面都一样”，因此我们才说，正多面体拥有最高标准的对称性。</p>
<p>为了精确地刻画出正多面体，“所有顶点都一样”、“所有棱都一样”和“所有面都一样”，这三个条件缺一不可。如果去掉“所有顶点都一样”，但保留另外两个条件不变的话，会出现一些不是正多面体的图形。比如说，把一个正方体分成六个全等的四棱锥，再分别粘到另一个同样的正方体的六个面上，就会得到一种所有棱和所有面都一样，但顶点与顶点却有区分的图形（如左图）。如果去掉“所有棱都一样”，但保留另外两个条件不变的话，也会出现一些不是正多面体的图形。比如说，作出一个长方体各个面上的对角线，会组成一个四面体，它的所有顶点和所有面都一样，但棱与棱是有区分的（如中图）。最后，只去掉“所有面都一样”，保留另外两个条件不变，也会出现问题。标出一个正方体每条棱上的中点，然后据此切掉正方体的所有八个角，就会得到这么一个图形，它的所有顶点和所有棱都一样，但面与面是有区分的（如右图）。这是三个非常经典的多面体，一会儿我们再提到它们时，不妨把它们叫做“三个代表”吧。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>正多面体的定义虽然容不得丝毫删减，但却有很多修改和替换的余地。如果在刚才对正多面体的定义中，把“所有棱都一样”和“所有面都一样”换成“各个面是全等的正多边形”，满足要求的立体图形还是只有那五个。因此，正多面体还有一个等价的定义：由若干个完全相同的正多边形拼成的，且所有顶点完全相同的多面体就是正多面体。</p>
<p>古希腊人还研究了“半正多面体”（semiregular polyhedron），即由两种或多种不同的正多边形拼成的，且所有顶点完全相同的多面体。长方体就不是一个半正多面体，虽然它的各个顶点完全相同，但各个面却不都是正多边形。由一个正方形和四个等边三角形组成的四棱锥（就像金字塔那样）也不是一个半正多面体，因为它的顶角和四个底角显然是有区别的。三个侧面都是正方形的正三棱柱则是一个典型的半正多面体，它同时满足半正多面体的两个条件。容易想到，每个侧面都是正方形的正五棱柱、正六棱柱、正七棱柱等等，它们也都是半正多面体了（排除掉正四棱柱的原因是，四个侧面都是正方形的正四棱柱其实就是正方体，它是正多面体，不是半正多面体）。因而，我们立即得知，半正多面体有无穷多个。另外，把棱柱的底面稍稍旋转，与顶面错开，再用一个个上下交错的三角形充当侧面，还能得到一类叫做“反棱柱”（antiprism）的多面体。如果反棱柱的顶面和底面是全等的正多边形，每个侧面正好都是等边三角形，那么整个多面体也会成为半正多面体。如果你把正二十面体从上到下分作三层，中间那层其实就是一个这样的多面体。显然，这样的多面体也有无穷多个，如下图的第二行所示。大家会注意到，三角反棱柱没有纳入这一行当中，因为它实际上就是正八面体。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>除了棱柱和反棱柱以外，还有别的半正多面体吗？这个问题就非常有意思了。古希腊数学家 Pappus 曾在自己的著作中详尽地列出了问题的 13 个解，并认为这些解最早是由 Archimedes 发现的。因此，这些非平凡的半正多面体就被后人称作 Archimedean 体。欧洲文艺复兴时期，这些简洁对称的立体图形重新引起了人们的关注，不同的人在不同的时期重新发现了不同的 Archimedean 体。左图是 Leonardo da Vinci 为数学家 Luca Pacioli 的著作所作的插图。右图是 Wenzel Jamnitzer 的作品，右上角那个立体图形就是一个 Archimedean 体。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>在这段时期里，第一个把所有 Archimedean 体当作一个整体概念，对其进行系统的分析研究的人，应该是德国数学家、天文学家 Johannes Kepler （是的，就是那位提出行星运动三大定律的“天空立法者”）。他在《世界的和谐》（Harmonices Mundi）一书中列出了 13 种 Archimedean 体，画出了每个 Archimedean 体的样子，给它们起了不同的名字，并且证明了， Archimedean 体一共就只有这 13 种：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>为了方便大家观察，我也重新作了一张图：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p> </p>
<p>这里面有很多图形想必大家都会非常熟悉。第一行的第一个图形，其实就是刚才那“三个代表”中最右边的图形，也就是 Wenzel Jamnitzer 的作品中右上角的那个图形，是去掉正方体的八个角得来的。对正方体进行去角操作后，原来的每个角都变成了一个等边三角形，原来的每个面都只剩一个内接的小正方形，最终得到的正是第一行的第一个 Archimedean 体。不过，有一件事情刚才我们没说：这个图形同样也可以看作是对正八面体进行去角操作得来的。原来的每个角都会变成一个正方形，原来的每个面都只剩下一个内接的小等边三角形，最终得到的也是第一行的第一个 Archimedean 体。为什么正方体和正八面体的去角结果是相同的呢？其中一个重要的原因就是，因为正方体和正八面体是对偶的。正方体去角后的每一个面，都对应于正八面体去掉的每一个角，不管从哪个角度看，一共都是 6 个正方形；正方体去掉的每一个角，则都对应于正八面体去角后的每一个面，不管从哪个角度看，一共都是 8 个等边三角形。最终所得的，就是这么一个由 6 个正方形和 8 个等边三角形组成的图形。</p>
<p>类似地，由于正十二面体和正二十面体互为对偶图形，因此它们的去角结果也是相同的。所得的图形就是第二行的第二个 Archimedean 体，它由 20 个等边三角形和 12 个正五边形组成。每一个等边三角形都是正十二面体被去掉的一个角，也可以看作是正二十面体去角后的一个面；每一个正五边形都是正十二面体去角后的一个面，也可以看作是正二十面体被去掉的一个角。</p>
<p>值得注意的是，去角后的正四面体却不在 13 个 Archimedean 体当中，因为去角后的正四面体其实就是一个正八面体。不过，适当减小去角的幅度，正四面体也能变成 Archimedean 体。标出正四面体每条棱上的两个三等分点，然后从这些地方下刀，于是每个角都会变成一个等边三角形，每个面都会变成一个正六边形，整个图形会变成第一行的第二个 Archimedean 体。</p>
<p>对正多面体进行去角操作，是构造 Archimedean 体的基本途径之一。刚才，我们至少已经看到了两种去角的模式，这里我们有必要区分一下。不妨把之前从中点处开刀的那种去角方式叫做“全截角”（complete truncation）或者“截半”（rectification），此时原多面体的每条棱都只剩下一个点。后面那种精心选择下刀处，使得每条棱所剩的长度都和截面边长相等的去角方式，则叫做“均匀截角”（uniform truncation）。如果只说“截角”（truncation），尤其是当对象为某个高度对称的多面体时，通常指的就是均匀截角。</p>
<p>对正方体进行均匀截角后，也会变成一个 Archimedean 体，即第一行的最后一个图形。均匀截角后的正八面体，会变成第一行的第三个图形。均匀截角后的正十二面体，则会变成第二行的最后一个图形。均匀截角后的正二十面体呢？正二十面体有 12 个顶点，每个顶点处都有五条棱。把它们全都削掉，就会得到 12 个正五边形。正二十面体有 20 个面，每个面都是一个等边三角形。把所有顶点全都削掉，它们就会变成 20 个正六边形。因此，最终得到的图形就有 12 个正五边形和 20 个正六边形，如第三行的第一个图所示。有没有觉得， 12 个正五边形和 20 个正六边形，这几个数字让人非常亲切？没错，这正是足球表面黑白色块的分布情况。 1962 年，丹麦的体育用品生产商 Select Sport 首先想到了把这种结构用在足球上。随后， Adidas 生产的 Telstar 把这种设计发扬光大，并成为了 1970 年墨西哥世界杯的官方用球。此后，这个 Archimedean 体便成为了足球的象征。</p>
<p>至此， 13 个 Archimedean 体的来历已经讲了 7 个。对刚才的两个全截角图形再做全截角或者均匀截角，其结果可以近似地看作是另外 4 个 Archimedean 体。第一行的第一个图形是对正方体或者正八面体进行全截角得来的。如果对它再来一次全截角，就会近似地得到第一行的第四个图形，它包含 8 个等边三角形和 18 个正方形；如果对它做的是均匀截角，就会近似地得到第二行的第三个图形，它包含 12 个正方形、 8 个正六边形和 6 个正八边形。第二行的第二个图形则是对正十二面体或者正二十面体进行全截角得来的。如果对它再来一次全截角，就会近似地得到第二行的第四个图形，它包含 20 个等边三角形、 30 个正方形和 12 个正五边形；如果对它做的是均匀截角，你将会近似地得到最后一行的最后一个图形。这是最大的一个 Archimedean 体，它由 30 个正方形、 20 个正六边形和 12 个正十边形组成，里面一共有 120 个顶点、 180 条棱和 62 个面。需要注意的是，这 4 个 Archimedean 体都有更准确的生成方式，利用截角法只能得到拓扑结构相同的近似图形。这些近似图形的各个面不保证都是正多边形，需要再做调整才能变成真正的 Archimedean 体（不妨看看 Wenzel Jamnitzer 的作品中最下面一行的两个图形）。</p>
<p>至此， 13 个 Archimedean 体的来历已经讲了 11 个。在 Multidimensional Transformations Unit Origami 一书的附录里，作者 Tomoko Fuse 用一张图清楚地画出了 5 个 Platonic 体和 13 个 Archimedean 体之间的关联。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>这一页里还画着两个孤立的 Archimedean 体，正好也就是我们还没提到的 Archimedean 体，即第二行的第一个图形，以及第三行的第二个图形。这两个图形的生成方式很难描述。把一个正方体的六个面向外拉出，再让它们同时顺时针或者逆时针旋转某个特定的度数，并用 32 个等边三角形填补中间的空隙，就会得到第二行的第一个图形。类似地，把一个正十二面体的十二个面向外拉出，再让它们同时顺时针或者逆时针旋转某个特定的度数，并用 80 个等边三角形填补中间的空隙，就会得到第三行的第二个图形。这两种图形的生成方式中都涉及到了“顺时针或者逆时针旋转”，因而每个物体都没法和自己的镜像重合（就像你的左鞋和右鞋没法重合一样，如下图所示）。换句话说，这两种图形都有“手性”（chirality）之分。如果把左手系的物体和右手系的物体算作两个不同的物体，那么 Archimedean 体一共就有 15 个了。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>说到 Archimedean 体的数量，还有一件事情不得不提。接下来，我们要构造一个非常非常非常特殊的多面体。取出第一行第四个 Archimedean 体（如下面的左图所示），把它分成上中下三层，然后保持中层和下层不动，仅仅让上层旋转 45° （如下面的右图所示）。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>整个图形无缝拼接，和之前的样子似乎并无太大的区别。它的所有面也都是正多边形，它的所有顶点也都是由三个正方形和一个等边三角形以相同的方式汇聚而成的。但是，它却不是 Archimedean 体。作为半正多面体， Archimedean 体的对称性要求也是非常高的，它要求“所有顶点都一样”，而不仅仅是“所有顶点看起来都一样”。右边的那个图形中，虽然从局部来看，各个顶点的性质完全相同，但站在全局的角度来看，这些点并不能随意扮演其他点的角色。比方说，注意到整个图形只有一条由正方形连成的“腰带”，它上面的点显然不能被其他的点所取代。而它的原版图形有三个互相垂直的腰带，每个顶点都位于其中两个腰带上。在所有由正多边形拼成的图形当中，这是唯一一个“所有顶点看起来都一样但其实不一样”的图形。因此，有的人也会把它称作第 14 个 Archimedean 体。 Johannes Kepler 本人很可能也发现了这一点。他曾经说过 Archimedean 体一共有 14 个，虽然最终只在《世界的和谐》里写了 13 个。</p>
<p> </p>
<p>根据 Archimedean 体的定义，每个 Archimedean 体都满足“所有顶点都一样”，并且都不满足“所有面都一样”（因为 Archimedean 体要求由两种或两种以上的正多边形构成）。但是，光从定义来看，我们无法得出与棱的对称性相关的信息。逐一分析可以发现，在 13 个 Archimedean 体当中，有 2 个满足“所有棱都一样”：对正方体或者正八面体进行全截角所得的图形，以及对正十二面体或者正二十面体进行全截角所得的图形。和其他半正多面体相比，这 2 个多面体显然距离真正的正多面体更近一些，人们把它们叫做“拟正多面体”（quasiregular polyhedron）。早些时候，为了说明正多面体的定义缺一不可，我们构造了“三个代表”。当时，我们想要在最右边展示出舍去“所有面都一样”这项条件的后果，所使用的例子就是前一个拟正多面体。</p>
<p>现在，让我们来看一看，我们已经见过多少种多面体的对称模式了：</p>
<table>
<tr>
<td width="110">所有点都一样</td>
<td width="110">所有棱都一样</td>
<td width="110">所有面都一样</td>
<td>例子</td>
</tr>
<tr>
<td>×</td>
<td>×</td>
<td>×</td>
<td>各种随意的图形，比如一个四棱锥</td>
</tr>
<tr>
<td>×</td>
<td>×</td>
<td>√</td>
<td>？？？</td>
</tr>
<tr>
<td>×</td>
<td>√</td>
<td>×</td>
<td>？？？</td>
</tr>
<tr>
<td>×</td>
<td>√</td>
<td>√</td>
<td>“三个代表”的左例</td>
</tr>
<tr>
<td>√</td>
<td>×</td>
<td>×</td>
<td>长方体，或大多数半正多面体</td>
</tr>
<tr>
<td>√</td>
<td>×</td>
<td>√</td>
<td>“三个代表”的中例</td>
</tr>
<tr>
<td>√</td>
<td>√</td>
<td>×</td>
<td>“三个代表”中的右例，或称拟正多面体</td>
</tr>
<tr>
<td>√</td>
<td>√</td>
<td>√</td>
<td>有且仅有五个，即五种正多面体</td>
</tr>
</table>
<p>目前，人们已经证明，第三类多面体是不存在的。也就是说，一个棱与棱无差异的多面体，要么顶点也是无差异的，要么面也是无差异的（当然也有可能顶点和面都是无差异的）。所以，我们只差最后一种对称模式需要研究了：顶点有区别，棱也有区别，面都是一样的。其实，这样的多面体并不难构造。或许有人已经意识到了——其实，第二类和第四类多面体，分别是第五类和第七类多面体的对偶多面体。</p>
<p>在构造一般多面体的对偶多面体时，我们不能照搬正多面体的处理方法，把各个面的中心连接起来。其中一个原因就是，对于一般多面体的顶点来说，它周围的各个面并不是完全相同的，因而这些面的中心会参差交错地环绕于该顶点，连起来很可能并不在同一个平面上，因而也就无法形成一个对应的面了。如果多面体的顶点正好是无差异的，那么我们可以过多面体的各个顶点作出整个多面体的外接球的切面。由于多面体的顶点和顶点之间无差异，因此所有顶点到多面体中心的距离都是相等的，这保证了外接球的存在性。最后，所有切面围出的图形，就是原多面体的对偶多面体。对于那些没有外接球的多面体，生成对偶图形还有更一般的方法：把多面体内的某个点，通常是这个多面体的对称中心（如果有的话），记作点 O ，然后对于多面体的每个顶点 P ，作一个垂直于 OP 的面，使得 O 到 P 的距离与 O 到这个面的距离的乘积为某个定值。虽然生成对偶多面体的方法有所变化，但对偶概念最核心的东西始终没变：原图形的顶点与新图形的面一一对应，原图形的面与新图形的顶点一一对应。</p>
<p>长方体的所有顶点都一样，但棱和棱有差异，面和面也有差异；它的对偶图形就满足所有面都一样，但棱和棱有差异，点和点也有差异。以正方形为侧面的正棱柱不但所有顶点都一样，而且每个面都是正多边形；因此，它的对偶图形不但满足所有面都一样，而且每个顶点处的各个二面角都相等。这样的正棱柱有无穷多个，与之对偶的多面体也就有无穷多个。还有无穷多个反棱柱也是顶点无差异的，因而也就还有无穷多个多面体也是面与面无差异的。当然， 13 个 Archimedean 体也都有各自的对偶多面体：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>这些多面体是比利时数学家 Eugène Catalan （是的，就是提出 Catalan 数的那个 Catalan ）在 1865 年首次描述的，因而又叫做 Catalan 体。在所有的 Archimedean 体当中，其中 11 个是点无差异，棱和面都有差异的，因而在所有的 Catalan 体当中，其中 11 个的面无差异（但注意，这并不意味着每个面都是正多边形，只能说明这些面互相之间全等而已），并且棱和点都有差异。这 11 个 Catalan 体中的任何一个都可以填补刚才的第三类多面体那项空白。在这一部分的 Archimedean 体中，又有 2 个是分手性的，因而刚才这部分 Catalan 体中，也有 2 个是分手性的。最后还有 2 个 Archimedean 体同时满足点无差异和棱无差异（但面和面仍然有不同），所以就还有 2 个 Catalan 体同时满足面无差异和棱无差异（但顶点和顶点仍然不同）。在“三个代表”中，最左边的那个图形和最右边的那个图形，其实就是一组互为对偶的、棱无差异的 Catalan 体和 Archimedean 体：</p>
<p class="indent"><img alt="image placeholder" >
<p>这 13 个 Catalan 体有一个非常出人意料的应用价值：由于它们的面和面之间完全无差异，因此用它们来制作异形而又公正的骰子可谓是再适合不过了。之前我们曾经弄出过一个最大的 Archimedean 体，里面一共有 120 个顶点；因而，我们就能制作一个足足有 120 个面的大骰子了。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p> </p>
<p>写到这里，我终于有点累了，打算就此打住。不过，我最后还想表达的一点就是，对称多面体的水实在是太深了，这篇文章也只能谈到微不足道的冰山一角。 1966 年，美国数学家 Norman Johnson 决定寻找除了 5 个正多面体、无穷多个棱柱、无穷多个反棱柱和 13 个 Archimedean 体以外，其他所有由正多边形拼成的多面体，结果一共找到了 92 个。他猜测自己已经找全了，这一点后来被证明是正确的。这 92 个 Johnson 体如下：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>在 Peter Cromwell 所著的 Polyhedra 一书中，则有一张非常伟大的插图，对所有每个面都是正多边形的多面体作了一个分类：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>然而，刚才我们说的仅仅是凸多面体，仅仅是亏格为 0 的多面体，仅仅是不与自身相交的多面体，仅仅是三维空间中的多面体……</p>
<p> </p>
<p>文章中个别图片的来源：<br>
<a href="https://www.cs.drexel.edu/~crorres/Archimedes/Solids/Pappus.html">https://www.cs.drexel.edu/~crorres/Archimedes/Solids/Pappus.html</a><br>
<a href="http://www.georgehart.com/virtual-polyhedra/leonardo.html">http://www.georgehart.com/virtual-polyhedra/leonardo.html</a><br>
<a href="http://homepages-fb.thm.de/boergens/marken/briefmarke066.htm">http://homepages-fb.thm.de/boergens/marken/briefmarke066.htm</a><br>
<a href="http://www.dicecollector.net/JM/D120.HTM">http://www.dicecollector.net/JM/D120.HTM</a></p>
			 ]]></content>
<pubDate>2014-11-09T17:43:01+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6161</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：构造点集使得每条直线上的点都一样多 ]]></title>
<link>http://www.matrix67.com/blog/archives/6204</link>
<content><![CDATA[ 
		<p>我们很容易在平面内放置很多点，使得任意两点确定的直线都只经过这两个点——你需要做的，仅仅是让任意三点都不共线就行了。那么，能否在平面内放置若干个点，使得任意两点确定的直线总是恰好经过三个点呢？更一般地，对于任意正整数 n &gt; 2 ，能否在平面内放置若干个点，使得任意两点确定的直线总是恰好经过 n 个点呢？当然，我们要排除掉所有点都共线这种平凡的情况。</p>
<p>记得我很小的时候就想过这个问题。小时候有一种经典的智力题，大致就是叫你把多少多少棵树种成多少多少行，使得每行都有多少多少棵树。比方说，如何把 9 棵树种成 10 行，使得每行都有 3 棵树？答案如下图所示。但请注意，其实图中还有不少直线上只有 2 棵树，比如那条蓝色的虚线。</p>
<p class="indent"><img alt="image placeholder" >
<p>当时，我就曾经想过，如果树苗足够多，能否让<strong>每条</strong>可能的直线上都种有 3 棵树呢？于是，我没事儿就来尝试一番，但每一次都以失败告终。后来我才知道，这是不可能的。根据 Sylvester–Gallai 定理，在任意一个有限点集中，一定有一条直线恰好只经过两个点，除非所有的点都是共线的。这个定理有一个非常漂亮的证明，这里不得不提。假设存在某个点集，满足任意两点确定的直线上都存在其他的点。画出所有可能的直线，作出每一个点到每一条直线的垂线段，然后找出所有这些垂线段中最短的一条。不妨假设这条最短的垂线段是点 P 到某条直线 l 的垂线段，垂足点记作 H 。由假设， l 上至少有三个点，因此至少有两个点分布在垂足 H 的同一侧（允许和垂足重合）。不妨把这两个点记作 R 、 Q ，如下图所示。由于我们画出了所有可能的直线，因此 P 、 R 两点之间也有一条直线；此时， Q 到 PR 的垂线段就是更短的垂线段，于是产生矛盾。要想避免这样的矛盾，唯一的方法就是，所有的垂线段长度都为 0 ，换句话说我们根本作不出所谓的垂线段。这也就是所有点全都共线的情况。</p>
<p class="indent"><img alt="image placeholder" >
<p>我们刚才证明了，在一个点集中，只经过两点的直线一定存在，除非所有点全都共线；因此，当 n &gt; 2 时，我们自然就无法让每条可能的直线上都有 n 个点，除非所有点全都共线。</p>
<p><span id="more-6204"></span></p>
<p>1971 年，U. S. R. Murty 提出了这么一个问题：如果允许有重合的点，那么刚才的问题有解吗？答案是肯定的。如下图，每个写有数字 1 的圆盘表示一个点，那个写有数字 4 的圆盘则表示一个四重点。你会发现，每条可能的直线上都经过了恰好 5 个点。类似地，把 n 个点摆成一条直线，再在直线外放置一个 n – 1 重点，那么每条可能的直线都会经过恰好 n 个点。另外，对于一个合法的解来说，如果把每个点的重数都扩大到原来的 k 倍，所得图形自然也满足要求；但我们认为，它和原图形是本质上相同的解。</p>
<p class="indent"><img alt="image placeholder" >
<p>我们今天的问题就是： Murty 的问题还有什么本质上不同的解吗？</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>答案仍然是肯定的，如下图所示。容易看出，每条可能的直线上都有恰好 4 个点。利用刚才提到的翻倍法修改每个点的重数，还会得到又一批本质相同的解。</p>
<p class="indent"><img alt="image placeholder" >
<p>有趣的是， Murty 再也找不到其他的解了。他猜测，这个问题确实没有别的答案了。换句话说， Murty 认为，如果平面内有若干个点，每个点都有一个权重，且任意两点确定的直线所经过的点的权重之和都相等，则可能的情况只有以下四种：</p>
<ol>
<li>点集中的任意三点都不共线；</li>
<li>所有点都在一条直线上；</li>
<li>除一点外，其余所有点都在一条直线上；</li>
<li>上图所示的情况。</li>
</ol>
<p>2007 年， Eyal Ackerman 、 Kevin Buchin 、 Christian Knauer 、 Rom Pinchasi 和 Günter Rote 证明了， Murty 的猜想是正确的。你可以在<a href="http://page.mi.fu-berlin.de/rote/Papers/pdf/There+are+not+too+many+magic+configurations.pdf">这里</a>看到他们的论文。</p>
			 ]]></content>
<pubDate>2014-11-26T17:27:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6204</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：这个图形有什么独特的性质？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6206</link>
<content><![CDATA[ 
		<p>下图是由 288 个相同的小立方体拼成的一个立体图形，它有一个非常独特，非常难能可贵的性质。要想用若干个相同的小立方体构造出一个具有同样性质的立体图形，这绝对不是一件容易的事情。事实上，下图已经是目前已知的满足该性质的立体图形中所用小立方体个数最少的了。你能猜出这个性质是什么吗？</p>
<p class="indent"><img alt="image placeholder" >
<p><span id="more-6206"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>答案：这个立体图形的每个面都是由 6 个小正方形构成。这是由 George Sicherman 构造出来的，我则是在<a href="http://www2.stetson.edu/~efriedma/mathmagic/0614.html">这里</a>看见的这个构造。</p>
			 ]]></content>
<pubDate>2014-11-27T04:36:57+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6206</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典证明：向量叉积的几何意义 ]]></title>
<link>http://www.matrix67.com/blog/archives/6217</link>
<content><![CDATA[ 
		<p>为什么以向量 (a, b) 和 (c, d) 为邻边，构成的平行四边形的面积正好是 ad – bc 呢？下图是一个非常漂亮的无字证明。</p>
<p class="indent"><img alt="image placeholder" >
<p>这是我在阅读 The Mathematical Mechanic: Using Physical Reasoning to Solve Problems 一书时受到启发并制作完成的。</p>
			 ]]></content>
<pubDate>2014-11-28T12:59:52+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6217</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：顶点数为多少的图有可能和自己互补 ]]></title>
<link>http://www.matrix67.com/blog/archives/6221</link>
<content><![CDATA[ 
		<p>若干个顶点以及某些顶点和顶点之间的连线，就构成了一个“图”。如果对某个图进行变换，使得原来任意两个有连线的顶点之间都不再有连线，原来任意两个没有连线的顶点之间现在都有连线了，那么所得到的图就是原来那个图的“补图”。如果一个图和它的补图具有本质上完全相同的结构（这意味着，把其中一个图的顶点以适当的方式与另一个图的顶点建立一一对应的关系，那么对于谁和谁之间有连线、谁和谁之间没有连线这样的问题，两个图的情况是完全一样的），我们就说这个图和它自己是互补的。下图显示了一个顶点数为 5 的图以及它的补图，容易看出，它们的本质结构是相同的。这说明，顶点数为 5 的图有可能和自己互补。</p>
<p class="indent"><img alt="image placeholder" >
<p>下图显示了一个顶点数为 8 的图，它和它的补图也具有同样的本质结构（你能看出来吗）。这说明，顶点数为 8 的图也有可能和自己互补。</p>
<p class="indent"><img alt="image placeholder" >
<p>我们今天的问题是：对于那些正整数 n ，存在顶点数为 n 的与自己互补的图？</p>
<p><span id="more-6221"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>如果一个图有 n 个顶点，那么它总共就有 n(n-1) / 2 条可能的连线。显然，一个图要想和自己互补，它里面的连线数必然是 n(n-1) / 2 的一半，因此 n(n-1) / 2 必须得是偶数。这说明， n 只能等于 1, 4, 5, 8, 9, 12, 13, 16, 17, … ，即那些形如 4k 和 4k + 1 的数。</p>
<p>接下来，我们将会构造性地说明，对于上述的每一个 n ，顶点数为 n 的图都确实有可能和自己互补。当 n = 1 时，整个图只有 1 个顶点，没有任何连线，根据定义，它和它自己是互补的。当 n = 4 时，一条简单的“链”便满足要求：不妨把这 4 个顶点分别记作 x 、 y 、 z 、 w ，那么 x – y – z – w 的补图就是 y – w – x – z ，整个图的本质结构并未发生改变。</p>
<p>另外，对于任意一个有 k 个顶点的且与自己互补的图，在它外面添加一根由 4 个新顶点组成的链条 x – y – z – w ，再把顶点 x 与所有 k 个顶点都相连，把 w 也与所有 k 个顶点都相连。容易看出，整个图现在就有 k + 4 个顶点了，并且这个新的图也和自己是互补的。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>因此，我们就可以从 n = 1 和 n = 4 的情形出发，借助上面的扩展方法，依次得到 n = 5, n = 8, n = 9, n = 12, … 的构造。这立即说明，对于所有形如 4k 和 4k + 1 的正整数 n ，顶点数为 n 的图都确实有可能和自己互补。</p>
<p>问题及解答出自 2000 年 Stephan C. Carlson 在 Mathematics Magazine 的一篇文章。我是在 Proofs Without Words 2: More Exercises in Visual Thinking 一书中看到这个问题的。</p>
			 ]]></content>
<pubDate>2014-12-01T21:22:43+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6221</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 7 个分形图形的动画演示 ]]></title>
<link>http://www.matrix67.com/blog/archives/6231</link>
<content><![CDATA[ 
		<p>最近沉迷于用 Mathematica 制作动画。受到<a href="http://i.imgur.com/gL0U75t.gifv">这个动画</a>的启发，我决定自己制作一些动画，来演示分形图形的进化过程。下面就是我这一周的成果。</p>
<p><a href="http://en.wikipedia.org/wiki/Koch_snowflake">Koch curve</a>：</p>
<p style="text-align:center"><img alt="image placeholder" >
<p><span id="more-6231"></span> </p>
<p><a href="http://en.wikipedia.org/wiki/H-fractal">H-fractal</a>：</p>
<p style="text-align:center"><img alt="image placeholder" >
<p> </p>
<p><a href="http://en.wikipedia.org/wiki/Sierpinski_triangle">Sierpinski triangle</a>：</p>
<p style="text-align:center"><img alt="image placeholder" >
<p> </p>
<p><a href="http://en.wikipedia.org/wiki/Vicsek_fractal">Vicsek fractal</a>：</p>
<p style="text-align:center"><img alt="image placeholder" >
<p> </p>
<p><a href="http://en.wikipedia.org/wiki/L%C3%A9vy_C_curve">Lévy C curve</a>：</p>
<p style="text-align:center"><img alt="image placeholder" >
<p> </p>
<p><a href="http://en.wikipedia.org/wiki/Dragon_curve">Dragon curve</a>：</p>
<p style="text-align:center"><img alt="image placeholder" >
<p> </p>
<p><a href="http://en.wikipedia.org/wiki/Pythagoras_tree_(fractal)">Pythagoras tree</a>：</p>
<p style="text-align:center"><img alt="image placeholder" >
<p> </p>
<p>本来只做了 7 个，但是 <a href="http://localhost-8080.com">Localhost-8080</a> 说她还想要一个，于是专门为她定制了一大片雪花。</p>
<p><a href="http://en.wikipedia.org/wiki/Hexaflake">Hexaflake</a>：</p>
<p style="text-align:center"><img alt="image placeholder" >
			 ]]></content>
<pubDate>2014-12-08T01:41:07+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6231</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：能否把长方形分成奇数个全等的非长方形小块？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6258</link>
<content><![CDATA[ 
		<p>1969 年， David Klarner 提出了这样一个问题：能否把一个长方形划分成奇数个全等的小块，并且这些小块不能是小长方形？如果把问题改为偶数个小块，这件事情是很容易做到的，如下图所示。对于奇数个小块的情况，问题显然就没有那么简单了。继续阅读下去之前，你不妨先想一想。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p><span id="more-6258"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>答案是肯定的。 David Klarner 自己给出了两个这样的例子：</p>
<p class="indent"><img alt="image placeholder" >
<p class="indent"><img alt="image placeholder" >
<p>我是在 Unsolved Problems in Geometry 一书里看到这个问题的。</p>
			 ]]></content>
<pubDate>2014-12-25T19:34:29+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6258</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：根据释义猜出一对声韵母相同的词 ]]></title>
<link>http://www.matrix67.com/blog/archives/6263</link>
<content><![CDATA[ 
		<p>昨晚， <a href="http://localhost-8080.com">Localhost-8080</a> 想要知道“痢疾”和“腹泻”之间的关系是什么。于是，我故作认真地打开词典，字正腔圆地念道：“牛、羊、猪等的脊椎骨内侧的嫩肉，呈条状。” 她过了好半天才反应过来，原来我故意念了“里脊”的释义。于是我改口道：“哦，念错了，念错了，应该是这个——儒家经典之一，是秦汉以前各种礼仪论著的选集。”随后，我又念了“对自己有利”和“立刻”这么两条。她很快答出，它们实际上分别是“礼记”、“利己”、“立即”的释义。我们突然觉得这个游戏还蛮有意思，于是制作了下面 32 道题。</p>
<p>在下面的每一道题中，你需要根据释义猜出 A 、 B 两个词语，其中 B 词的两个字分别是由 A 词的两个字改变声调得来的。为了让游戏更有意思，在我们的题目中，每个词里面的字都不会出现在这个词的释义当中。例如，第 1 题的答案是“失业”和“视野”。</p>
<p><span id="more-6263"></span></p>
<p>01A 有劳动能力的人找不到工作。<br>
01B 眼睛看到的空间范围。</p>
<p>02A 重新烘烤。<br>
02B 用财物买通别人。</p>
<p>03A 军事上防守用的建筑物，多用砖、石、钢筋混凝土等建成。<br>
03B 暗中用假的换真的或用坏的换好的。</p>
<p>04A 毁坏的年代较久的建筑物所在的地方。<br>
04B 为了达到既定的目的而自觉地努力的心理状态。</p>
<p>05A 长于烹调并以此为专业的人。<br>
05B 在社会上活动，跟人往来。</p>
<p>06A 不愿让外人知道的。<br>
06B 东、南、西、北，泛指各处。</p>
<p>07A 有发言权和表决权的成员参加会议。<br>
07B 一年最后一天的夜晚，也泛指一年最后的一天。</p>
<p>08A 把消息、事物等传出去。<br>
08B 打赢了的战役或战斗。</p>
<p>09A 头尖或刃薄，容易刺入或切入物体。<br>
09B 多年生草本植物，果肉味甜酸，有很浓的香味。</p>
<p>10A 庄严地说出表示决心的话或对某事提出保证。<br>
10B 对和尚或道士的尊称。</p>
<p>11A 帮助产妇分娩。<br>
11B 使可能被耗费掉的不被耗费掉或少耗费掉。</p>
<p>12A 单纯地。<br>
12B 紧靠在一起。</p>
<p>13A 对人类或国家的大事了解得较早的人。<br>
13B 搁在一边不用。</p>
<p>14A 一种小型的坐具，腿交叉，上面绷帆布或麻绳等，可以合拢，便于携带。<br>
14B 昆虫，体细长，绿色或黄褐色。主要危害禾本科植物，是农业害虫。</p>
<p>15A 泛指古代图书。<br>
15B 心里老想着，放不下心。</p>
<p>16A 从容不迫，稳重。<br>
16B 照相机的一部分，关闭时不透光，前部装镜头、快门，后部装胶片。</p>
<p>17A 固定的词组，只能整个应用，不能随意变动其中成分。<br>
17B 归某一方面或为某方所有。</p>
<p>18A 多种原料制成或多种花样的。<br>
18B 用力。</p>
<p>19A 事物呈现出来的样子。<br>
19B 为事情意外地得到好的结局而感到高兴。</p>
<p>20A 对事物容纳而不拒绝。<br>
20B 排泄大便或小便。</p>
<p>21A 举行典礼或召开大会时报告进行程序的人。<br>
21B 不顾一切由着自己的性子去做。</p>
<p>22A 作战时双方军队接近的地带。<br>
22B 字句、内容简明容易懂。</p>
<p>23A 坚固耐用。<br>
23B 分析阐明。</p>
<p>24A 辨别是非、利害关系以及控制自己行为的能力。<br>
24B 常绿乔木，果实球形或卵形，是我国的特产。</p>
<p>25A 程度上不能再超过的界限。<br>
25B 为死去的人举行仪式，表示追念。</p>
<p>26A 离开原来所在的地方到别的地方去。<br>
26B 使犯错误或犯罪的人受到政治或经济上的损失而有所警戒。</p>
<p>27A 仇视的心理。<br>
27B 排列在最前面的。</p>
<p>28A 掸掉或擦掉尘土。<br>
28B 指下饭的鱼肉蔬菜等。</p>
<p>29A 使蒙受严重损害。<br>
29B 形容珠玉等光彩鲜明。</p>
<p>30A 过问别人的事。<br>
30B 有决心，有勇气。</p>
<p>31A 勉强过得去。<br>
31B 用尽心思。</p>
<p>32A 跟原来一样。<br>
32B 形容仇恨等达到极点。</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>答案：</p>
<table>
<tr>
<td>01. 失业、视野</td>
<td>02. 回炉、贿赂</td>
<td>03. 碉堡、掉包</td>
<td>04. 遗址、意志</td>
</tr>
<tr>
<td>05. 厨师、处世</td>
<td>06. 私房、四方</td>
<td>07. 出席、除夕</td>
<td>08. 声张、胜仗</td>
</tr>
<tr>
<td>09. 锋利、凤梨</td>
<td>10. 发誓、法师</td>
<td>11. 接生、节省</td>
<td>12. 一味、依偎</td>
</tr>
<tr>
<td>13. 先知、闲置</td>
<td>14. 马扎、蚂蚱</td>
<td>15. 典籍、惦记</td>
<td>16. 安详、暗箱</td>
</tr>
<tr>
<td>17. 熟语、属于</td>
<td>18. 什锦、使劲</td>
<td>19. 情形、庆幸</td>
<td>20. 接受、解手</td>
</tr>
<tr>
<td>21. 司仪、肆意</td>
<td>22. 前线、浅显</td>
<td>23. 结实、解释</td>
<td>24. 理智、荔枝</td>
</tr>
<tr>
<td>25. 极点、祭奠</td>
<td>26. 出发、处罚</td>
<td>27. 敌意、第一</td>
<td>28. 拂拭、副食</td>
</tr>
<tr>
<td>29. 摧残、璀璨</td>
<td>30. 干预、敢于</td>
<td>31. 可以、刻意</td>
<td>32. 如故、入骨</td>
</tr>
</table>
<p>如果你喜欢这些问题的话，或许你也会喜欢 <a href="http://www.matrix67.com/blog/archives/4922">趣题：填写两个声母互相颠倒的词</a> 。</p>
			 ]]></content>
<pubDate>2015-01-08T05:34:49+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6263</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：四边形的最长三边之和一定大于两对角线长度之和吗？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6284</link>
<content><![CDATA[ 
		<p>众所周知，三角形当中的任意两边之和始终大于第三边。在四边形中，我们还有类似的结论吗？ 2015 年 2 月的 <a href="http://www.brand.site.co.il/riddles/201502q.html">UyHiP</a> 谜题就是：证明或推翻，四边形的三条最长边之和始终大于两条对角线的长度之和。</p>
<p><span id="more-6284"></span></p>
<p> </p>
<p>这个结论是正确的。下面的证明是由 Daniel Bitin 给出的。</p>
<p>首先，让我们先来证明一个引理：若 △ABC 中， ∠C ≥ 90° ，则 AB + CH &gt; AC + BC ，其中 CH 是 AB 边上的高。不妨先来考虑 ∠C = 90° 的情况。</p>
<p class="indent"><img alt="image placeholder" >
<p>由勾股定理可知：</p>
<p class="indent">AB<sup>2</sup> = AC<sup>2</sup> + BC<sup>2</sup></p>
<p>另外，由于这个三角形的面积有两种不同的计算方法，于是我们有：</p>
<p class="indent">AB · CH = AC · BC</p>
<p>前一个式子加上后一个式子的两倍，于是得到：</p>
<p class="indent">AB<sup>2</sup> + 2 · AB · CH = AC<sup>2</sup> + 2 · AC · BC + BC<sup>2</sup></p>
<p>所以说</p>
<p class="indent">AB<sup>2</sup> + 2 · AB · CH + CH<sup>2</sup> &gt; AC<sup>2</sup> + 2 · AC · BC + BC<sup>2</sup></p>
<p>即</p>
<p class="indent">(AB + CH)<sup>2</sup> &gt; (AC + BC)<sup>2</sup></p>
<p>因此</p>
<p class="indent">AB + CH &gt; AC + BC</p>
<p>如果 ∠C &gt; 90° 呢？我们可以在 AB 边上找一个点 B′ ，使得  ∠ACB′ = 90° 。</p>
<p class="indent"><img alt="image placeholder" >
<p>我们已经证明了</p>
<p class="indent">AB′ + CH &gt; AC + B′C</p>
<p>而由于三角形两边之和大于第三边，我们有</p>
<p class="indent">BB′ + B′C &gt; BC</p>
<p>两个不等式相加，于是得到</p>
<p class="indent">AB′ + CH + BB′ + B′C &gt; AC + B′C + BC</p>
<p>即</p>
<p class="indent">AB + CH &gt; AC + BC</p>
<p>引理也就证到了。</p>
<p> </p>
<p>接下来就让我们来证明，在四边形 ABCD 中，三条最长边之和始终大于两条对角线的长度之和。</p>
<p class="indent"><img alt="image placeholder" >
<p>作平行四边形 ABDE 和 BCFD 。由于四边形 ABDE 是平行四边形，因而 AE 和 BD 是平行且相等的；由于四边形 BCFD 是平行四边形，因而 BD 和 CF 也是平行且相等的。因此， AE 和 CF 也就是平行且相等的了。这说明，四边形 ACFE 也是一个平行四边形。</p>
<p>注意，在平行四边形 ACFE 中， D 点到各个顶点的距离正好分别等于四边形 ABCD 的四边之长，并且 AE 和 CF 的长度都等于 BD ， EF 的长度则等于 AC 。为了证明本文最开头的结论，我们只需要说明，在 DA 、 DC 、 DF 和 DE 中，其中三条边的长度之和大于平行四边形 ACFE 的两条邻边之和。由于这个平行四边形的两组对角分别相等，因而其中一组对角必然都是大于等于 90°  的，比如例图中的 ∠AEF 和 ∠ACF 。连接 AF 后，这个四边形就会被分割成两个直角三角形或者两个钝角三角形。在这两个三角形中，找出那个不含 D 点的三角形（如果 D 点在 AF 上，则随便选取一个三角形），比如例图中的 △ACF ，并作出该三角形 AF 边上的高 CH 。根据引理可得：</p>
<p class="indent">AF + CH &gt; AC + FC</p>
<p>由于 △ADF 中两边之和大于第三边，因此 AD + DF &gt; AF ；由于 H 点已经是线段 AF 上距离 C 点最近的点了，而 D 点还在线段 AF 的另一侧，因此 CD &gt; CH 。所以，我们有</p>
<p class="indent">AD + DF + CD &gt; AF + CH &gt; AC + FC</p>
<p>即原四边形 ABCD 中，其中三条边的长度之和大于两条对角线的长度之和。</p>
			 ]]></content>
<pubDate>2015-03-05T01:40:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6284</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 实数、超实数和博弈游戏：数学的结构之美 ]]></title>
<link>http://www.matrix67.com/blog/archives/6333</link>
<content><![CDATA[ 
		<p><strong>（一）一个博弈游戏</strong></p>
<p>让我们来玩一个游戏。下面有五行石子，白色的石子都是我的，黑色的石子都是你的。我们轮流拿走一个自己的石子，并且规定如果一个石子被拿走了，它后面的所有石子都要被扔掉。谁先没有拿的了，谁就输了。</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○●●○●●○●●○<br>
●○○●○●●○●<br>
○○○○<br>
●●●○●●●<br>
●</p></blockquote>
<p><span id="more-6333"></span>比如说，如果你先走的话，你可以把第四行的第三个石子拿走，按规定第四行将会只剩下前面两个石子：</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○●●○●●○●●○<br>
●○○●○●●○●<br>
○○○○<br>
●●<br>
●</p></blockquote>
<p>现在轮到我走了。我可以拿走第二行倒数第二个石子，于是整个棋局变成了这样：</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○●●○●●○●●○<br>
●○○●○●●<br>
○○○○<br>
●●<br>
●</p></blockquote>
<p>现在，假如说你拿走了第二行中的第一个石子（于是第二行就没了），那么我就赢定了。我可以拿走第一行中的第一个石子，从而让整个棋局只剩下后面三行：</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○○○○<br>
●●<br>
●</p></blockquote>
<p>这三行中有四个白石子，有三个黑石子，并且每一行都是同种石子。于是整个局面完全变成了一个拼石子个数的游戏，我只需要一个一个地拿走白色石子，你必然将会率先无路可走。受此启发，我们自然地想到了一种刻画棋局的方式：把每个白色石子记作 +1 ，把每个黑色石子记作 -1 。于是 ○○○○ + ●● + ● = 4 – 2 – 1 = 1 ，结果是一个正数，这就表明该局面下我将必胜，即使此时轮到我先走。</p>
<p>你会发现上面的说法很有道理。毕竟白色的石子越多，对我越有利，给我带来的效用为正；而黑色的石子会减小我获胜的希望，当然应该给它赋上一个负的值。四白三黑算出来的结果为正 1 ，直观意义就是我能以一步的优势获胜。如果棋局是这样：</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○○<br>
●●●●</p></blockquote>
<p>那么 ○○ + ●●●● = 2 – 4 = -2 ，是一个负数，这就意味着不管谁先走，你都能必胜，因为你能比我多走两步。我们不妨把一个棋局对应的数叫做棋局的“特征值”。特征值为正，就表明不管谁先走我都能必胜；特征值为负，就表明不管谁先走你都能必胜；而特征值的绝对值，则直观地量化了胜负的悬殊。现在，考虑下面这个棋局：</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○○<br>
●●</p></blockquote>
<p>那么 ○○ + ●● = 2 – 2 = 0 ，这表明此时的情形介于“我必胜”和“你必胜”之间。事实上也是这样——如果我先走你后走，你就赢定了；如果你先走我后走，我就赢定了。这是因为，这个棋局的特征值为 0 ，双方能够走的步数相同，当然谁后走谁就赢定了。</p>
<p>真正有趣的事情出现了。考虑下面的棋局：</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○●</p></blockquote>
<p>它的特征值应该是多少呢？容易看出，它的特征值是一个正数，因为不管谁先走，显然我都能赢。同时，它的特征值也应该比 1 小，因为只有一个 ○ 要比 ○● 赢得更爽一些。事实上，单看 ○● 黑方确实无论如何都会输，但在某些场合下， ○ 后面的这个 ● 能让黑方喘上一口气。比如下面这个棋局：</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○●<br>
●</p></blockquote>
<p>如果我先走，显然你必胜无疑。如果你先走呢？先走的人获胜的难度更大，你可要好好想想策略。你可以拿走那个单独成行的 ● ，但当我拿走 ○ 之后，你就得眼睁睁地看着自己剩下的那个 ● 被一并收走。此时，你或许会意识到，你本来还能多走一步的，可惜这一步被浪费掉了。因此，你更好的做法就是，一上来先拿走 ○ 后面的 ● 。运用这种策略，显然你也会必胜无疑。可见，不管是我先走还是你先走，整个棋局对于你来说都是必胜的，从而有 ○● + ● = ○● – 1 &lt; 0 ，这再次说明了 ○● 是一个小于 1 的数。那么， ○● 是否等于 1/2 呢？

答案是肯定的，考虑下面这个棋局：


</p>
<blockquote style="font-family: Helvetica, Times, Arial;">○●<br>
○●<br>
●</blockquote>
<p>如果我先走，本质上不同的走法只有一种，并且局面将会立即变成刚才那种你必胜的情形，因而你将必胜。如果是你先走呢？拿走那个单独成行的 ● 会让你提前锁定败局，更好的选择则是像刚才一样，先拿走某个 ○ 后面的 ● ，为自己多赢得一步。现在，石子只剩下了 ○● 、 ○ 、 ● 这么三行。那么，我应该拿走哪一个 ○ 呢？拿走那个单独成行的 ○ 会让局面再次变回刚才那种你必胜的情形，更好的选择则是拿走后面有 ● 的 ○ ，这样我便能让你损失一步。掌握了这个技巧后，我就能做到必胜了。综上所述，整个棋局是一个谁后走谁就赢定了的局面。于是 ○● + ○● + ● = 0，也就是 ○● + ○● – 1 = 0 ，可以解得 ○● 等于 1/2 。也就是说，在 ○● 中，我将以半步的优势获胜。对应地， ●○ 就等于 -1/2 ，此时你将以半步的优势获胜。</p>
<p>注意，目前并没有任何理论告诉我们，这么加减是合理的。不过我们却发现，这么加减出来的结果真的是对的。比如说， ○● + ○● + ○● + ● = 1/2 + 1/2 + 1/2 – 1 = 1/2，而棋局</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○●<br>
○●<br>
○●<br>
●</p></blockquote>
<p>对于我来说真的就是必胜的局面！</p>
<p>这背后一定有一个更深层次的原因：棋局之间的加减和数与数之间的加减一定存在着某些共通的地方。也就是说，为了解释“为什么棋局的加法和数的加法如此之像”，我们需要证明，两者具有完全相同的代数结构。我们需要建立一个从棋局到实数的映射法则，然后说明全体棋局（或者全体棋局的一部分）与全体实数（或者全体实数的一部分）是同构的。</p>
<p>正如 Poincaré 所说，诗歌的艺术在于给相同的东西取不同的名字，数学的艺术在于给不同的东西取相同的名字。两个看似毫不相关的东西竟然是同构的，这在数学中是最令人激动的事情之一。</p>
<p> </p>
<p><strong>（二）熟悉而又陌生的算术</strong></p>
<p>为了说明棋局就是算术，我们首先要定义，什么是算术。我们需要站在系统之外，对算术的本质做一个描述。算术，就是对一些数做加减乘除的运算。这似乎对我们完全没有帮助——什么是数，什么是加减乘除？其实，数，就是一些具有大小关系的元素，这些元素可以按照它们的大小关系串成一根链条。这意味着，首先，任意两个数都是可以比较大小的，并且对于两个不同的数 x 和 y 来说， x 要么大于 y ，要么小于 y 。然后，大小关系必须具有传递性，如果 x 小于 y ， y 又小于 z ，那么 x 一定小于 z 。形式化地说，我们要求元素之间存在某种暂且记作 ≤ 的关系，使得它们满足：</p>
<ol>
<li>完全性：对于任意的 x 和 y ，x ≤ y 和 y ≤ x 当中至少有一个成立。</li>
<li>反对称性：对于任意的 x 和 y ，如果 x ≤ y 和 y ≤ x 同时成立，那么 x 和 y 一定是同一个元素。（今后我们用符号 x = y 表示 x 和 y 是同一个元素，注意这个新符号和 ≤ 的区别：前者是一个真实的符号，它用来表达“是同一个元素”这个概念；后者则是我们假想的一种抽象符号，它不见得有什么具体的意义。）</li>
<li>传递性：对于任意的 x 、 y 和 z ，如果 x ≤ y 和 y ≤ z 同时成立，那么一定有 x ≤ z。</li>
</ol>
<p>这样的话，所有的元素都被 ≤ 穿成了一条绳子。我们就说，这些元素构成了一个“全序关系”。</p>
<p>我们还需要元素之间的“加法”和“乘法”满足一系列的性质：</p>
<ol>
<li value="4">对加法封闭：对于任意的 x 和 y ， x + y 也仍然是某一个元素</li>
<li>对乘法封闭：对于任意的 x 和 y ， x · y 也仍然是某一个元素</li>
<li>加法交换律：对于任意的 x 和 y ， x + y = y + x</li>
<li>乘法交换律：对于任意的 x 和 y ， x · y = y · x</li>
<li>加法结合律：对于任意的 x 、 y 和 z ， (x + y) + z = x + (y + z)</li>
<li>乘法结合律：对于任意的 x 、 y 和 z ， (x · y) · z = x · (y · z)</li>
<li>乘法对加法的分配律：对于任意的 x 、 y 和 z ， x · (y + z) = x · y + x · z</li>
<li>存在加法单位：存在某一个特殊的元素，通常记作 0 ，使得对于任意的 x ，都有 x + 0 = x</li>
<li>存在乘法单位：存在某一个特殊的元素，通常记作 1 ，使得对于任意的 x ，都有 x · 1 = x</li>
<li>存在加法逆元：对于任意的 x ，总能找到某一个特殊的元素，通常记作 -x ，使得 x + (-x) = 0</li>
<li>存在乘法逆元：对于任意不为 0 的 x ，总能找到某一个特殊的元素，通常记作 x<sup>-1</sup> ，使得 x · x<sup>-1</sup> = 1</li>
<li>对于任意的 x 、 y 和 z ，如果 x ≤ y ，那么一定有 x + z ≤ y + z</li>
<li>对于任意的 x 、 y ，如果 0 ≤ x 和 0 ≤ y 同时成立，那么一定有 0 ≤ x · y</li>
</ol>
<p>有几点需要注意。我们虽然只说了加法单位满足 x + 0 等于 x ，但其实由于加法交换律， 0 + x 也等于 x 。乘法单位也是如此。我们说“存在加法单位”，而没说“存在唯一的加法单位”，这是因为加法单位最多只能有一个，如果存在，必定唯一。假如 a 和 b 是两个加法单位的话，你会发现因为 a 是加法单位，所以 a + b 等于 b ，又因为 b 是加法单位，所以 a + b 等于 a ，因而 a = b 。我们说“存在加法逆元”，而没说“存在唯一的加法逆元”，也是因为同一个元素的加法逆元最多只能有一个，如果存在，必定唯一。假设 a 有两个加法逆元 b 和 c ，那么就有 b = b + 0 = b + (a + c) = (b + a) + c = 0 + c = c ，因此 b 其实就是 c 。乘法单位和乘法逆元也是如此。</p>
<p>这基本上刻画出了作为一个算术系统所有需要满足的性质。第 4 条和第 5 条告诉了我们，加法和乘法并没有那么玄妙，它们不过是从元素对到元素的映射。第 6 条到第 10 条列举了加法和乘法的基本性质。第 11 条和第 12 条定义了 0 和 1 这两个特殊的数。第 13 条中出现了“加法逆元”一词，不过“相反数”一词或许会更亲切一些。第 14 条中出现了“乘法逆元”一词，不过“倒数”一词或许也会更亲切一些。第 13 条和第 14 条实际上定义了减法和除法。减去 x ，就相当于加上 -x ；除以 x ，就相当于乘以 x<sup>-1</sup> 。这两条性质保证了，我们可以自由地做减法，我们可以自由地做除法，得到的数也仍然是一个合法的元素，不会出现不够减、不允许减、不够除、不允许除的情况（除以 0 除外）。因为，每一个元素都有相反数，每一个非 0 元素都有倒数。</p>
<p>等等，这些性质就能刻画算术系统了？似乎漏掉了不少其他关键的性质吧。比如， 0 乘以任何数都等于 0 ，这条性质哪儿去了？其实，剩下的没有写出的性质，包括 (-1) · x = -x 、 0 ≤ 1 、 0 ≤ x · x 等等，都是已有性质的推论。我们可以从已有性质出发，完全不关心它们的实际意义，抽象地证明出算术系统应该具有的其他性质。例如，为了证明 0 · x = 0 ，只需要注意到：</p>
<blockquote><p>0 · x = (0 + 0) · x = 0 · x + 0 · x</p></blockquote>
<p>两边同时加上 0 · x 的加法逆元，等式仍然成立（这是因为，如果 a = b ，那么加法运算将会把 a + c 和 b + c 映射到同一个数）：</p>
<blockquote><p>0 · x + (- 0 · x) = (0 · x + 0 · x) + (- 0 · x)<br>
0 = 0 · x + (0 · x + (- 0 · x))<br>
0 = 0 · x + 0<br>
0 = 0 · x</p></blockquote>
<p>同时满足第 4 条到第 14 条的话，这些元素就构成了一个“域”。如果还满足第 15 条和第 16 条（当然还有第 1 条到第 3 条），这就是一个“有序域”。最小的有序域是有理数域。如果把上面所说的元素想成是全体有理数，把小于等于、加法和乘法解读为我们平常所说的小于等于、加法和乘法，那么整个系统满足上面所有 16 条性质。实数域则是一个更“大”的有序域，而有理数域只是它的其中一个“子有序域”。当然，还有一些有序域，它里面的元素根本不是常规意义上的数，它们之间的大小关系、加法乘法也根本不是常规意义上的大小关系和加法乘法。不过，人们已经证明了，任何一个有序域里一定都包含有一个子有序域，它和有理数域同构——它里面的一切都和有理数一样，只是各个元素的名字不一样罢了。也就是说，在任何一个有序域中，我们都可以从加法单位和乘法单位出发，把全部的或者部分的、本来有可能并不是数的元素看成是一个个的数，得到一个与有理数等价的系统：加法单位就是 0 ，乘法单位就是 1 ，等于 1 + 1 的那个元素就是 2 ， 等于 2 + 1 的那个元素就是 3 ， 2 的加法逆元就是 -2 ， 2 的乘法逆元就是 1/2 ，等等，而且这些元素确实是不同的元素，它们之间的小于等于、加法乘法的运算结果也确实符合有理数之间的运算结果。正因为这样，我们才说，这 16 个有序域条件比较完整地描述了算术系统的要素，足以刻画算术系统了。</p>
<p>这里，我们突然有了一个非常激动人心的问题：一个有序域有没有可能比实数域更大（实数域只和它的某个子有序域同构）？有理数域已经封闭了，但加进去一系列新的元素之后，我们有可能得到一个封闭的、更大的实数域；那么，能否在实数域里面也加进去一些新的元素，让实数域进一步扩张成某个更大的有序域？不不不，答案没有“复数域”那么简单——复数域不是有序域，因为它不是有序的。也就是说，我们无法为所有复数安排 ≤ 关系，使得它能满足有序域的全部条件。在这个比实数域更大的有序域中，我们不但能继续加减乘除，还要能继续做大小比较，每一个新的数和每一个原有的实数之间都有一个确定的大小关系。直观上，这似乎是不大可能的，因为实数已经把那根“线”填满了。</p>
<p> </p>
<p><strong>（三）外星人的数学</strong></p>
<p>对算术结构的形式化，让我想起了一些更折磨人的哲学问题：我们的数学体系为什么是这样的？一个文明的数学体系一定是这个样子的吗？比方说，如果人类没有视觉这种感官，我们还会创立几何这门学科吗？同时，人类是否会因为缺乏某种独特的感官，而没能建立起一个更加神奇的数学分支？</p>
<p>同样地，我们总会认为，自然数是最自然的概念，是每一种文明都不可避免会遇到的概念。是这样吗？会不会有某一种外星文明，他们也有一套自己的算术系统，虽然也有加减，虽然也有乘除，虽然跟我们正在使用的算术系统是同构的，但其直观意义和表示方法都跟我们完全不同。或许，在我们这里很难表达的数，在他们那里看来几乎是平凡的；或许，在我们这里很直观很自然的数，在他们的体系里却需要异常复杂的记号来表示。</p>
<p>作为一个科幻迷，我甚至马上想到了，这应该是一个绝佳的科幻素材：数学家发现了地外生命的某种全新的数学系统，并且一步一步尝试去解读它。为此，数学家们必须抛弃任何已有的假设，忘掉什么是自然数，什么是零，什么是加减，什么是乘除，从一片空白开始，尝试理解外星算术系统，逐渐搭建起外星数学的大厦。《你一生的故事》的数学版，多么激动人心的一件事情啊！</p>
<p>这样的小说已经有了。你猜谁写的？ Donald Knuth ！第一次听说这个时，第一反应除了膜拜还是膜拜： Knuth 简直是太牛了，他竟然写过一本小说！这本 100 多页的小说叫做 Surreal Numbers （中译《研究之美》，电子工业出版社 2012 年 1 月出版，顺便吐槽中译名），中文意思大致就是“超现实的数”。我打算直接把它叫做“超实数”——正如“实数”就是“现实的数”一样，“超实数”也就是“超现实的数”了（其实，不得不说的是，“超实数”这个译名有一个很大的弊端：它可能会与另一个叫做 hyperreal numbers 的概念发生混淆）。小说的副标题则是 How Two Ex-Students Turned on to Pure Mathematics and Found Total Happiness 。小说讲述了 Alice 和 Bill ，一对年轻男女，逃到一个漂亮的孤岛上“寻找自我”。他们在岛上发现了一块古老的石板，石板上用希伯来语写着一些数学公理。然后，我们将跟随 Alice 和 Bill 的思路，逐渐探索这些公理的意义，期间会走不少的弯路，历经一些失败的尝试，到最后终于成功恢复出了一个完整的算术系统。根据 Wikipedia 的描述，一个全新的数学概念竟然首先出自于一本小说，这是极罕见的例子。</p>
<p>在下面的讨论中，时刻记住：我们在学习外星数学。我们不能有任何先入为主的概念。请忘记“数”的概念，忘记“小于等于”的概念。下面所说的“数”是某种全新的物体，它可能与我们熟知的数有某种对应的关系，也可能与我们熟知的数没有任何关系。“小于等于”也是一种全新的概念，这四个字整个儿是一个新词，它不是由“小于”和“等于”合成的。它的意思有可能和我们的小于等于相吻合，也有可能和我们的小于等于不吻合，甚至有可能根本就没有什么合理的“意思”。“大于等于”只是一个与“小于等于”对称的说法。如果 x 小于等于 y ，我们就说 y 大于等于 x 。偶尔我们会用 ≤ 代替“小于等于”，用 ≥ 代替“大于等于”，不过也请假装这些符号对你来说是完全陌生的。</p>
<p>石板上的公理只有两个。</p>
<ol>
<li>每个数都是用两个（由已有的数构成的）集合表示的，其中左边集合里不存在这样的数，它大于等于右边集合里的某个数。假如 a 、 b 、 c 、 d 、 e 都是已经构造出来的数，并且从 a 、 b 里任取一个数，从 c 、 d 、 e 里任取一个数，前者都不会大于等于后者，那么把 a 、 b 放入左边的集合，把 c 、 d 、 e 放入右边的集合，我们就能得到一个新的数，比如 f 。我们把它记作 f = {a, b | c, d, e} 。</li>
<li>一个数小于等于另一个数，当且仅当前者的左集合里不存在大于等于后者的数，并且后者的右集合里不存在小于等于前者的数。比如，如果 x = {a, b | c} ， y = {d | e}  ，那么 x 小于等于 y ，当且仅当 a 、 b 都不大于等于 y ，并且 e 不小于等于 x 。</li>
</ol>
<p>可以看出，所有的数，包括它们之间的 ≤ 、 ≥ 关系，都是递归地表达出来的。不过，我们每次都需要用已有的数来定义新的数，那我们从什么地方开始呢？答案是，我们从空集开始。左集合和右集合都为空，记作 { | } ，这是我们能够得到的第一个数。再次提醒，这个数或许能被等价地理解为我们世界中的某个数，或许不能。我们暂时不做这些假设。我们把这个数记作 α 。也就是说， α = { | } 。容易看出， α ≤ α ，因为 α 的左集合里确实没有哪个数大于等于 α ，并且 α 的右集合里确实没有哪个数小于等于 α （事实上 α 的左集合里和右集合里根本就没有数）。既然 α ≤ α ，反过来看，也可以说成是 α ≥ α 了。在接下来的过程中时刻记住， α 既小于等于自己，又大于等于自己。</p>
<p>接下来，我们可以构造两个新的数 { | α} 和 {α | } ，不妨把它们俩分别叫做 β 和 γ 。注意， {α | α} 是不合法的，它违反了公理 1 ：左集合里的数不能大于等于右集合里的数。可以验证， β ≤ α ，而 α ≤ γ 。另外， β 也是小于等于 γ 的，不过请注意，这并不是根据“小于等于”的传递性推出的，而是根据“小于等于”的定义直接验证的。我们还不知道“小于等于”满足传递性。事实上，我们还不知道“小于等于”有什么直观意义。</p>
<blockquote><p>x 小于等于 y 当且仅当 x 的左集合里不存在大于等于 y 的数，并且 y 的右集合里不存在小于等于 x 的数<br>
β = { | α} ， α = { | } ⇒ β 小于等于 α ，或者说 α 大于等于 β<br>
α = { | } ， γ = {α | } ⇒ α 小于等于 γ ， 或者说 γ 大于等于 α<br>
β = { | α} ， γ = {α | } ⇒ β 小于等于 γ ， 或者说 γ 大于等于 β</p></blockquote>
<p>接下来，我们完全不理会 ≤ 背后有何直观意义，而是纯粹利用刚才的两个公理来证明，刚才看到的传递现象其实并不是巧合。换句话说，在这个神秘的算术系统中，如果 x ≤ y ，并且 y ≤ z ，那么 x ≤ z 。证明的基本方法是数学归纳法。</p>
<p>我们对三元组 (x, y, z) 施加归纳。假设传递性对于更早产生的三元组都是成立的。根据定义，如果 x ≤ y ，那么对于 x 的左集合中的任意一个元素 x<sup>L</sup> 来说， y ≤ x<sup>L</sup> 都不成立。这立即表明， z ≤ x<sup>L</sup> 是绝对不可能发生的，因为我们已经有了 y ≤ z ，如果还有 z ≤ x<sup>L</sup> 的话，根据归纳假设，就会有 y ≤ x<sup>L</sup> ，矛盾。于是我们知道了， x 的左集合里不存在大于等于 z 的元素。用类似的方法可以推出，不可能出现 z<sup>R</sup> ≤ x 的情况，其中 z<sup>R</sup> 是 z 的右集合中的任意一个元素。理由和刚才相仿：如果 x ≤ y 和 z<sup>R</sup> ≤ x 同时成立，由归纳假设就会得到 z<sup>R</sup> ≤ y ，这与 y ≤ z 相矛盾。于是我们知道了， z 的右集合里不可能出现小于等于 x 的数。综合上述两条便有 x ≤ z 。</p>
<p>由于超实数所具有的递归本质，在研究超实数的性质时，最基本的方法就是数学归纳法。为了证明某个结论对任意一个数 x 都成立，我们通常会假设这个结论对所有可能的 x<sup>L</sup> 和 x<sup>R</sup> 都已经成立了；类似地，为了证明某个结论对任意一个二元组 (x, y) 都成立，我们通常会假设这个结论对所有可能的 (x<sup>L</sup>, y) 、 (x<sup>R</sup>, y) 、 (x, y<sup>L</sup>) 、 (x, y<sup>R</sup>) 都已经成立了。让我们来做几个练习吧。首先，让我们试着用数学归纳法来证明，对于任意一个数 x 都有：</p>
<ol>
<li>x ≰ x<sup>L</sup> ，其中 x<sup>L</sup> 是 x 的左集合中的任意一个元素</li>
<li>x ≱ x<sup>R</sup> ，其中 x<sup>R</sup> 是 x 的右集合中的任意一个元素</li>
<li>x ≤ x</li>
</ol>
<p>证明过程并不复杂。假设这几条性质对于更早产生的数都成立。为了证明对于任意 x<sup>L</sup> 都有 x ≰ x<sup>L</sup> ，我们只需要说明，在 x 的左集合中存在一个大于等于这个 x<sup>L</sup> 的数即可。这样的数是显然存在的，因为由归纳假设， x<sup>L</sup> ≤ x<sup>L</sup> 或者说 x<sup>L</sup> ≥ x<sup>L</sup> 始终成立。证明对于任意 x<sup>R</sup> 都有 x ≱ x<sup>R</sup> 的方法也是类似的。好了，既然 x<sup>L</sup> 都不大于等于 x ，并且 x<sup>R</sup> 都不小于等于 x ，就说明 x ≤ x 了。我们不妨把这三个结论分别叫做补充性质 1 、补充性质 2 和补充性质 3 。我们今后会反复用到这三个补充性质。</p>
<p>有人或许会说：x ≰ x<sup>L</sup>，岂不意味着 x ≥ x<sup>L</sup> 吗？为什么要说得那么麻烦呢？别急，别急，我们目前还不知道 x ≰ y 能否推出 x ≥ y 呢。不过，不管怎么说， x ≥ x<sup>L</sup> 还真是成立的。我们可以证明这一点，基本思路仍然是数学归纳法。为了证明对于任意 x<sup>L</sup> 都有 x ≥ x<sup>L</sup> ，我们只需要说明，这个 x<sup>L</sup> 的左集合里不存在大于等于 x 的数，并且 x 的右集合里不存在小于等于这个 x<sup>L</sup> 的数。根据公理 1 的规定，后者显然是成立的。前者的正确性则不太容易看出来：根据归纳假设，这个 x<sup>L</sup> 大于等于它的左集合里的所有元素，如果这个 x<sup>L</sup> 的左集合里存在大于等于 x 的数，由传递性便可推出 x<sup>L</sup> ≥ x ，与刚才的补充性质 1 矛盾。类似地，补充性质 2 也有一个推论，即对于任意 x<sup>R</sup> 都有 x ≤ x<sup>R</sup> 。证明方法几乎完全相同： x ≤ x<sup>R</sup> 的意思就是 x 的左集合里不存在大于等于 x<sup>R</sup> 的数，并且 x<sup>R</sup> 的右集合里不存在小于等于 x 的数，两者可以分别由公理 1 和归纳假设推出。</p>
<p>补充性质 1 和补充性质 2 拥有这样的推论，这使我们开始猜测：会不会在任何情况下，由 x ≰ y 都能推出 x ≥ y 呢？的确是这样，而且证明过程很简单。 x ≰ y 意味着某个 x<sup>L</sup> 大于等于 y ，或者某个 y<sup>R</sup> 小于等于 x 。如果有某个 x<sup>L</sup> 大于等于 y  ，但刚才我们证明了 x 大于等于一切 x<sup>L</sup> ，两者结合便有了 x ≥ y ；如果有某个 y<sup>R</sup> 小于等于 x ，但刚才我们证明了 y 小于等于一切 y<sup>R</sup> ，两者结合也能推出 x ≥ y 。所以，不管是哪种情况， x ≥ y 都是成立的。</p>
<p>或许有人会无比兴奋地说：这个结论太有用了，之前很多别扭的说法这下都能大大简化了。例如，公理 1 原本说的是，一个数是合法的，当且仅当它的左集合里的每一个数都不大于等于右集合里的每一个数。现在，我们是不是就能把它重新叙述为，一个数是合法的，当且仅当它的左集合里的每一个数都小于等于右集合里的每一个数？且慢！我们目前只知道 x ≰ y 可以推出 x ≥ y ，但并不知道 x ≥ y 能否反过来推出 x ≰ y ，因而也就不知道 x ≰ y 和 x ≥ y 是否是完全等价的说法。对已有的数进行试验，你会觉得 x ≥ y 似乎真的能够推出 x ≰ y 。之前我们验证过 β ≤ α 、 α ≤ γ 和 β ≤ γ ，你会心安地发现，它们反过来真的都不成立。</p>
<blockquote><p>x 小于等于 y 当且仅当 x 的左集合里不存在大于等于 y 的数，并且 y 的右集合里不存在小于等于 x 的数<br>
α = { | } ， β = { | α} ⇒ α 不小于等于 β ，或者说 β 不大于等于 α<br>
γ = {α | } ， α = { | } ⇒ γ 不小于等于 α ，或者说 α 不大于等于 γ<br>
γ = {α | } ， β = { | α} ⇒ γ 不小于等于 β ，或者说 β 不大于等于 γ</p></blockquote>
<p>但是，如果再多生成一些数，问题就出来了。考虑这个数 {β | γ} ，由于 β 确实不大于等于 γ ，因此这个数是合法的。把这个数叫做 δ 。现在，考虑 δ 和 α 的大小关系：</p>
<blockquote><p>x 小于等于 y 当且仅当 x 的左集合里不存在大于等于 y 的数，并且 y 的右集合里不存在小于等于 x 的数<br>
α = { | } ， δ = {β | γ} ⇒ α 小于等于 δ ，或者说 δ 大于等于 α<br>
δ = {β | γ} ， α = { | } ⇒ δ 小于等于 α ，或者说 α 大于等于 δ</p></blockquote>
<p>结果， α ≤ δ 和 α ≥ δ 同时成立。这说明，虽然 x ≰ y 可以推出 x ≥ y ，但是 x ≥ y 不能推出 x ≰ y ，两者并不是等价的。换言之， x ≤ y 和 y ≤ x 不可能都不成立，但却有可能同时成立。</p>
<p>现在，让我们来回顾一下“小于等于”这个关系所满足的性质。它满足传递性，即 x ≤ y 和 y ≤ z 可以推出 x ≤ z 。它满足完全性，即 x ≤ y 和 y ≤ x 至少有一个成立。但是，它不满足反对称性。反对称性的意思是，如果 x ≤ y 并且 y ≤ x ，那么 x 和 y 必然是同一个元素。然而，我们刚才已经看到了， α = { | } 和 δ = {β | γ} 互相之间都具有 ≤ 关系，但它们并不是同一个元素。我们刚才反复强调，这里的“小于等于”是一个全新的概念，不要把它想象成我们熟知的那个小于等于；现在看来，这是一个无比正确的决定——这里的“小于等于”就是不能看成是我们熟知的那个小于等于。这里的“小于等于”不满足反对称性，但我们熟知的那个小于等于却得满足这一点。</p>
<p>先别管它。我们继续。在 Knuth 的小说中， Alice 和 Bill 又发现了一块新的石板，石板上定义了一种叫做“加法”的二元运算，用符号 + 表示。也请暂时不要和大家熟知的加法联系在一起。定义 x + y 的结果是一个新的数：它的左集合是由 x 的左集合的所有元素分别加 y ，以及 x 分别加上 y 的左集合的所有元素构成的；它的右集合是由 x 的右集合的所有元素分别加 y ，以及 x 分别加上 y 的右集合的所有元素构成的。如果把 x 的左集合和右集合分别记作 L(x) 和 R(x) ，把 y 的左集合和右集合分别记作 L(y) 和 R(y) ，那么 x + y 的左集合 L 和右集合 R 分别是</p>
<blockquote><p>L = { u + y | u ∈ L(x) } ∪ { x + v | v ∈ L(y) }<br>
R = { u + y | u ∈ R(x) } ∪ { x + v | v ∈ R(y) }</p></blockquote>
<p>例如，若 x = {a, b | c} ， y = {d, e, f | g, h} ，那么 x + y 就是 {a + y, b + y, x + d, x + e, x + f | c + y, x + g, x + h} 。显然，加法也是递归地定义出来的。在研究加法所具备的性质之前，我们必须要先做一件事情：证明如此加出来的数一定是满足公理 1 的，换句话说加出来的一定都是合法的数。这个证明是很有必要的，它直接关系到加法运算的封闭性。然而，这件事情却很容易被人忽略。 Knuth 的书中有一段情节我非常喜欢，讲的就是 Alice 和 Bill 突然意识到自己忘了做这件事情。在第 12 章《灾难》的开头， Alice 说：“一小时前我醒来，发现我们昨天的证明有一个很大很大的漏洞，就是我们忘了证明 x + y 是一个数了。”听了这话之后， Bill 说：“开玩笑吧，这是两个数之和，当然是一个数咯！等等，我想想……哦，我们还要检查它是否满足公理 1 。”接下来的 11 页则都是 Alice 和 Bill 对这个问题的探究，可见证明这件事还真不容易。这里，我们略去证明。</p>
<p>这么定义加法，效果如何呢？还是用我们刚才的那些数来做试验： α = { | } 、 β = { | α} 、 γ = {α | } 。容易看出：α + α = α ， α + β = { | α + α} = { | α} = β ， α + γ = {α + α | } = {α | } = γ 。利用数学归纳法不难证明，事实上， α 加上任意一个数 x 都仍然等于 x 。如果 x = {a, b | c} ，那么 α + x 就等于 {α + a, α + b | α + c} ，根据归纳假设，这就是 {a, b | c} 。根据同样的道理，任意一个数 x 加上 α 也都仍然等于 x 。如果 x = {a, b | c} ，那么 x + α 就等于 {a + α, b + α | c + α} ，根据归纳假设，这就是 {a, b | c} 。也就是说，假如我们这里所说的“加法”真的符合我们现实意义中的加法的话， α = { | } 其实就应该是那个 0 ！</p>
<p>在我们给出 α + x = x 始终成立的结论后，立即又说 x + α = x 也是始终成立的，这并不是废话，因为我们并不知道这里的加法是否满足交换律。那么，这里的加法是否满足交换律呢？让我们试着比较一下 β + γ 和 γ + β 的结果，来做一番探究吧。由于任何数加上 α 都不变，并且 α 加上任何数也都不变，因而：</p>
<blockquote><p>β + γ = { | α} + {α | } = {β + α | α + γ} = {β | γ} = δ<br>
γ + β = {α | } + { | α} = {α + β | γ + α} = {β | γ} = δ</p></blockquote>
<p>这样看来，这里的加法似乎是满足交换律的。</p>
<p>再次利用数学归纳法，我们可以很快得出，这里的加法就是满足交换律的。若 x = {a, b | c} ， y = {d, e, f | g, h} ，那么 x + y 就是 {a + y, b + y, x + d, x + e, x + f | c + y, x + g, x + h} ，而 y + x 就是 {d + x, e + x, f + x, y + a, y + b | g + x, h + x, y + c} ，根据归纳假设，两个数内部的组成元素是完全一致的。</p>
<p>同样是利用数学归纳法，我们还可以得出，这里的加法也是满足结合律的。 (x + y) + z 的左集合，归根结底是由以下三类数组成： (x<sup>L</sup> + y) + z 、 (x + y<sup>L</sup>) + z 、 (x + y) + z<sup>L</sup> 。而 x + (y + z) 的左集合，则是由以下三类数组成： x<sup>L</sup> + (y + z) 、 x + (y<sup>L</sup> + z) 、 x + (y + z<sup>L</sup>) 。根据归纳假设，你会发现， (x + y) + z 的左集合和 x + (y + z) 的左集合本质上是一样的。类似地， (x + y) + z 的右集合和 x + (y + z) 的右集合本质上也是一样的，因而 (x + y) + z = x + (y + z) 始终成立。</p>
<p>这里的加法还满足有序域条件列表中的第 15 条，即 x ≤ y 可推出 x + z ≤ y + z 。事实上，我们会证明一个更强的结论： x ≤ y 当且仅当 x + z ≤ y + z ，两者互相之间都是可推导的。事实上，我们会证明一组比这还要强的结论：</p>
<ol>
<li>若 x ≤ y ，并且 z ≤ w ，则 x + z ≤ y + w</li>
<li>若 x + z ≤ y + w ，但是 z ≥ w ，则 x ≤ y</li>
</ol>
<p>就像之前证明那三个补充性质一样，我们会把这两个结论捆绑到一块儿，共同施加数学归纳法。首先，我们来证明结论 1 ，即已知 x ≤ y 和 z ≤ w 可推出 x + z ≤ y + w 。根据加法的定义， x + z 的左集合由所有可能的 x<sup>L</sup> + z 和 x + z<sup>L</sup> 组成， y + w 的右集合由所有可能的 y<sup>R</sup> + w 和 y + w<sup>R</sup> 组成。别忘了，一个数小于等于另一个数，当且仅当前者的左集合里不存在大于等于后者的数，并且后者的右集合里不存在小于等于前者的数。因此，如果 x + z ≤ y + w 不成立，这就意味着 x<sup>L</sup> + z ≥ y + w 、 x + z<sup>L</sup> ≥ y + w 、 y<sup>R</sup> + w ≤ x + z 、 y + w<sup>R</sup> ≤ x + z 这四种情况当中至少会有一种出现。结果你会发现，这四个式子中的任何一个式子都会引出矛盾。例如，在第一个式子当中， x<sup>L</sup> + z ≥ y + w ，但我们有 z ≤ w ，根据结论 2 的归纳假设便有 x<sup>L</sup> ≥ y 。但是我们还有 y ≥ x ，由传递性便得到 x<sup>L</sup> ≥ x ，这与之前的补充性质 1 矛盾。类似地，从后面三个式子出发，可以分别得出 z<sup>L</sup> ≥ z 、 y<sup>R</sup> ≤ y 和 w<sup>R</sup> ≤ w ，这都与之补充性质相矛盾。</p>
<p>接下来，让我们看看结论 2 ，即已知 x + z ≤ y + w 和 z ≥ w 可推出 x ≤ y 。如果 x ≤ y 不成立，这就意味着 x<sup>L</sup> ≥ y 和 y<sup>R</sup> ≤ x 这两种情况当中至少会有一种出现。结果你会发现，这两个式子中的任何一个式子都会引出矛盾。例如，在第一个式子当中， x<sup>L</sup> ≥ y ，但我们有 z ≥ w ，根据结论 1 的归纳假设便有 x<sup>L</sup> + z ≥ y + w ，这与已知的 x + z ≤ y + w 矛盾。类似地，从第二个式子出发，可以得出 y<sup>R</sup> + w ≤ x + z ，这也与已知的 x + z ≤ y + w 矛盾。</p>
<p>让我们来回顾一下，这里定义的加法和我们熟知的那个加法究竟有多少差距。这里定义的加法满足加法交换律、加法结合律。这里定义的加法还满足 x ≤ y ⇒ x + z ≤ y + z 。这里定义的加法甚至存在加法单位。我们刚刚引入加法时就发现了， α = { | } 就是加法单位，任何数加上它的结果都不变。不过，我们目前还不知道的是，是否每个元素都存在加法逆元？换句话说，是否对于每一个数，我们都能找出一个相应的数，使得两者相加等于那个加法单位？结果你会发现，这是根本不可能的。除非两个加数都是 α ，否则根据加法的定义，两数之和的左右集合不可能都是空的，自然也就不可能等于加法单位 α 了。</p>
<p>此时，又该轮到谜一般的石板登场了。 Alice 和 Bill 发现，石板上还写有 x 的“逆元”的定义。递归地定义 x 的“逆元”为，将 x 的左右集合颠倒，并把集合里的每个数都变为“逆元”所得的新数。如果把 x 的左右集合分别记作 L(x) 和 R(x) ，把 x 的“逆元”记作 -x ，那么 -x 的左右集合就应该是：</p>
<blockquote><p>L = { -u | u ∈ R(x) }<br>
R = { -u | u ∈ L(x) }</p></blockquote>
<p>因此，如果 x = {a, b | c} ，那么 -x 就等于 {-c | -a, -b} 。可以证明，一个合法的数的“逆元”一定是满足公理 1 的，换句话说，一个合法的数的“逆元”一定也是合法的数。这里略去证明。容易看出， α 的“逆元”就是它本身。  { | α} 的“逆元”为 {-α | } ，也就是 {α | } ；  {α | } 的“逆元”为 { | -α} ，也就是 { | α} 。这表明，我们刚才的 β 和 γ 互为“逆元”。这里，我们给所有的“逆元”一词都加上了引号，因为它并不是真正的逆元，不满足加法逆元的要求。如果这里的“逆元”是真正的逆元，那么 β + γ 应该等于 α ，但实际情况却并不是这样。翻翻前文你会发现，之前我们算过 β + γ ，它等于 {β | γ} ，也就是后来被我们记作 δ 的数。此时，一件非常有趣的事情出现了： β + γ 的结果虽然不等于 α ，但却和 α 之间有一个极其特别的关系——它既小于等于 α ，又大于等于 α 。</p>
<p>事实上，我们可以证明，任何一个数加上它的“逆元”后，都既小于等于 α ，又大于等于 α 。我们先来证明这个结论的前半部分，即 x + (-x) 一定是小于等于 α 的。再次回想一下，一个数小于等于另一个数，当且仅当前者的左集合里不存在大于等于后者的数，并且后者的右集合里不存在小于等于前者的数。反证，如果 x + (-x) 不小于等于 α ，这就意味着， x + (-x) 的左集合里有大于等于 α 的元素，或者 α 的右集合里有小于等于 x + (-x) 的元素。由于 α 的右集合是空的，因此上述两种可能性中，后者显然是不可能的，我们只需要考虑前者即可。根据加法的定义， x + (-x) 的左集合是由所有可能的 x<sup>L</sup> + (-x) 和 x + (-x)<sup>L</sup> 构成，但很容易看出，它们也都不可能大于等于 α 。以 x = {a, b | c} 为例，根据定义有 -x = {-c | -a, -b} 。把所有可能的 x<sup>L</sup> + (-x) 和 x + (-x)<sup>L</sup> 都列出来，就是 a + (-x) 、 b + (-x) 、 x + (-c) ，而它们显然都不可能大于等于 α ，因为它们的右集合里都存在小于等于 α 的数—— a + (-x) 的右集合里有一个 a + (-a) ， b + (-x) 的右集合里有一个 b + (-b) ， x + (-c) 的右集合里有一个 c + (-c) ，根据归纳假设，它们都小于等于 α 。这样，我们就证明了 x + (-x) 必然小于等于 α 。同样的方法可以证明 x + (-x) 一定也是大于等于 α 的：否则， x + (-x) 的右集合里将会存在小于等于 α 的元素，即所有可能的 x<sup>R</sup> + (-x) 和 x + (-x)<sup>R</sup> 当中存在小于等于 α 的数，但这是不可能的，因为这些数的左集合里总会有形如 a + (-a) 、 b + (-b) 、 c + (-c) 的数，根据归纳假设，它们都是大于等于 α 的。</p>
<p>这个算术世界中的数没有真正的加法逆元，只有与之相加之后既小于等于加法单位，又大于等于加法单位的数；同时，回想我们之前曾经说过的，正是这种一个数既能小于等于另一个数，又能大于等于另一个数的特性，才使得这里的“小于等于”与我们现实生活中的小于等于不符。此时，一个神奇的想法突然冒了出来：如果我们把任意两个互相之间都存在 ≤ 关系的数视为同一个元素，上面两个问题不就一并解决了吗？</p>
<p>更具体地说，如果 a 和 b 同时满足 a ≤ b 和 b ≤ a ，我们就说 a 和 b 是同一类数。补充性质 3 告诉我们对于任意一个数 x 都有 x ≤ x ，因而一个数一定和自己同类；由于 ≤ 满足传递性，因而如果 a 和 b 同类， b 和 c 同类，则 a 和 c 也一定同类。于是，这个算术世界里的所有数就被划分成了一个一个不交叉的类。站在类上来看，刚才的一切都和我们现实生活中的算术系统相符了，仅有的两点区别也被消除了：对于任何一个类 A ，都存在另一个类 -A ，使得两者之和等于加法单位类；任何两个不同的类 A 和 B 不但满足 A ≤ B 和 B ≥ A 至少有一个成立，而且还满足，它们不可能同时成立（否则它们就不是不同的类了）。既然这样，我们何不把每一个类当作一个元素，把之前那些运算全都搬到类上，从而得到一个更合我们意的算术系统呢？</p>
<p>呃……我们可以这么做吗？且慢，这里面有个问题：究竟如何把之前那些运算全都搬到类上？这个“搬”字用得太随意了，我们要严谨地刻画一下。当然，我们可以规定，为了得出 A 和 B 两个类的运算结果，只需要从 A 中选一个 a ，从 B 中选一个 b ，看看 a 和 b 的运算结果在哪个类里。但是，你怎么知道，不同的选法一定对应相同的结果呢？</p>
<p>好在，利用小于等于的传递性以及 x ≤ y ⇔ x + z ≤ y + z 的性质，我们可以证明，这种事情是不会发生的。大家可以自己试着证明下面这些事实：如果 a 和 b 是同类的数，那么 -a 和 -b 也是同类的数，a + (-a) 、 b + (-b) 、 a + (-b) 、 (-a) + b 也都是和 α 同类的数；如果 a 和 b 是同类的数，并且 c 和 d 也是同类的数，那么 a ≤ c 就一定意味着 b ≤ d ， a + c 和 b + d 也一定是同类的数。事实上，在任何一个由 ≤ 、 ≥ 、 + 、 – 组成的表达式中，把某些数替换为与之同类的数，表达式都仍然是正确的。也就是说， ≤ 、 ≥ 、 + 、 – 都可以应用在类的级别上，都可以变成类与类之间的运算，不会出现有矛盾、有冲突的情况。这个以类为元素的结构完全符合有序域的定义中所有涉及到小于等于和加法运算的条件，包括之前不成立的小于等于的反对称性和加法逆元的存在性！</p>
<p>为了完成这个有序域的构造，我们只需要定义一个满足有序域条件的乘法就行了。这件事是可以办到的。规定 x 和 y 的乘积 x · y 的左集合 L 和右集合 R 分别是：</p>
<blockquote><p>L = { u · y + x · v – u · v | u ∈ L(x), v ∈ L(y) } ∪ { u · y + x · v – u · v | u ∈ R(x), v ∈ R(y) }<br>
R = { u · y + x · v – u · v | u ∈ L(x), v ∈ R(y) } ∪ { u · y + x · v – u · v | u ∈ R(x), v ∈ L(y) }</p></blockquote>
<p>这里，“ – u · v ”是一种简写记号，它表示的是“加上 u · v 的‘加法逆元’”。如果 x = {a, b | c} ， y = {d, e, f | g, h} ，那么 x · y 的左集合就是下表中所有红色区域里的数，右集合就是所有黄色区域里的数。可以证明，这种乘法的定义满足交换律、结合律以及对加法的分配律，这里我们略去证明。</p>
<table>
<tr>
<td style="text-align: center; width: 5%"> </td>
<td style="text-align: center">d</td>
<td style="text-align: center">e</td>
<td style="text-align: center">f</td>
<td style="text-align: center">g</td>
<td style="text-align: center">h</td>
</tr>
<tr>
<td style="text-align: center">a</td>
<td style="text-align: center;background-color:#ffd1d2">a · y + x · d – a · d</td>
<td style="text-align: center;background-color:#ffd1d2">a · y + x · e – a · e</td>
<td style="text-align: center;background-color:#ffd1d2">a · y + x · f – a · f</td>
<td style="text-align: center;background-color:#fff7d1">a · y + x · g – a · g</td>
<td style="text-align: center;background-color:#fff7d1">a · y + x · h – a · h</td>
</tr>
<tr>
<td style="text-align: center">b</td>
<td style="text-align: center;background-color:#ffd1d2">b · y + x · d – b · d</td>
<td style="text-align: center;background-color:#ffd1d2">b · y + x · e – b · e</td>
<td style="text-align: center;background-color:#ffd1d2">b · y + x · f – b · f</td>
<td style="text-align: center;background-color:#fff7d1">b · y + x · g – b · g</td>
<td style="text-align: center;background-color:#fff7d1">b · y + x · h – b · h</td>
</tr>
<tr>
<td style="text-align: center">c</td>
<td style="text-align: center;background-color:#fff7d1">c · y + x · d – c · d</td>
<td style="text-align: center;background-color:#fff7d1">c · y + x · e – c · e</td>
<td style="text-align: center;background-color:#fff7d1">c · y + x · f – c · f</td>
<td style="text-align: center;background-color:#ffd1d2">c · y + x · g – c · g</td>
<td style="text-align: center;background-color:#ffd1d2">c · y + x · h – c · h</td>
</tr>
</table>
<p>容易看出， α 乘以任意数都还是 α 。再来试试 β 乘以 γ ，它应该是 { | α} · {α | } = { | α · γ + β · α – α · α} = { | α + α – α} = { | α} = β 。事实上，用数学归纳法很容易证明，用任何一个数 x 来乘以 γ ，结果都仍然是 x ：让 x = {a, b | c} 去乘以 γ = {α | } ，将会得到 {a · γ, b · γ | c · γ} ，根据归纳假设它就是 {a, b | c} 。于是， γ 就成为了乘法单位。最后，我们还可以证明，对于任意的 x 、 y 都有，若 α ≤ x 和 α ≤ y ，则 α ≤ x · y 。“乘法逆元” x<sup>-1</sup> 的公式则是：</p>
<blockquote><p>L = { 0 } ∪ { (1 + (u – x) · v) / u | u ∈ R(x), v ∈ L(x<sup>-1</sup>) } ∪ { (1 + (u – x) · v) / u | u ∈ L(x), v ∈ R(x<sup>-1</sup>)}<br>
R = { (1 + (u – x) · v) / u | u ∈ L(x), v ∈ L(x<sup>-1</sup>) } ∪ { (1 + (u – x) · v) / u | u ∈ R(x), v ∈ R(x<sup>-1</sup>)}</p></blockquote>
<p>其中“ / u ”也是一种简写记号，它表示“乘以 u 的‘乘法逆元’”。可以证明，每个数的“乘法逆元”都是一个合法的数，两者相乘都既小于等于 γ ，又大于等于 γ 。类似地，我们可以把它们全都搬到类上，可以证明，这么做不会产生冲突。这些证明冗长而乏味，我们都略去了。这样一来，外星数学的数类，以及它们之间的小于等于、加法运算、乘法运算，就完全符合有序域的 16 个要求了。外星算术系统就是一个有序域！根据之前提到的结论，我们世界里的有理数运算可以被放进这个外星系统当中， α 所在的类就是那个 0 ， γ 所在的类就是那个 1 。</p>
<p>这种“把类当作元素”的算术结构建立方法并不怪异。其实，我们世界中的有理数域也是用这种方法建立起来的。有理数可以看作是一个一个的整数对。不妨用 a 、 b 、 c 、 d 来表示整数，用  0 、 + 、 – 、 · 、 ≤ 来表示整数世界里的零、加法、减法、乘法、小于等于，那么规定 (a, b) 加上 (c, d) 的结果为 (a · d + b · c, b · d) ，规定 (a, b) 乘以 (c, d) 的结果为 (a · c, b · d) ，再规定 (a, b) 小于等于 (c, d) 当且仅当 (0 ≤ b · d ∧ a · d ≤ b · c) ∨ (b · d ≤ 0 ∧ b · c ≤ a · d) ，其中 ∧ 和 ∨ 分别表示“并且”和“或者”。这种定义会带来很多问题，比如两个不同的元素可能互相之间都存在小于等于的关系，比如不是所有元素都有加法逆元，不是所有元素都有乘法逆元。然而，如果我们定义 (a, b) 和 (c, d) 同类当且仅当 a · d – b · c = 0 （这里的 · 、 – 、 = 、 0 也都取它们平常的意义），那么所有元素就会被划分成一个一个的类，这些类以及它们之间的运算就满足有序域的条件了。</p>
<p>由于这个外星有序域是建立在数类之上的，因此严格地讲，我们不能说 α 相当于我们世界中的 0 ，而只能说 α 所在的类相当于我们世界中的 0 。为了叙述简便，我们今后就用上横线来表示“所在的类”， <span style="text-decoration: overline">x</span> 意即 x 所在的类。有了这个记号，我们就可以这么说了： <span style="text-decoration: overline">α</span> 对应于我们世界中的 0 ， <span style="text-decoration: overline">γ</span> 对应于我们世界中的 1 。之前已经说过， <span style="text-decoration: overline">β</span> 和 <span style="text-decoration: overline">γ</span> 互为加法逆元，看来 <span style="text-decoration: overline">β</span> 就应该对应于我们世界中的 -1 了吧。因此， <span style="text-decoration: overline">β · β</span> 与 <span style="text-decoration: overline">γ</span> 就应该是同一个数类咯？简单验证一下，嘿，还真是！事实上，不但 β · β 与 γ 属于同一个数类，而且它们是同一个数： β · β = { | α} · { | α} = {α · β + β · α – α · α | } = {α + α – α | } = {α | } = γ 。其实，我们完全不必担心算着算着会出现不一致的现象，因为我们已经知道了，外星系统中的加减乘除与我们的数域是相吻合的（至少在有理数的范围内是相吻合的）。因此，接下来，我们就直接使用 0 、 -1 、 1 来代表 α 、 β 、 γ 了。</p>
<p><span style="text-decoration: overline">{1 | }</span> 相当于我们的什么数呢（注意，现在的以及接下来将会出现的所有构造，都是符合公理 1 的）？它相当于我们的 2 ，因为 {1 | } = 1 + 1 。 <span style="text-decoration: overline">{0, 1 | }</span> 相当于我们的什么数呢？它也相当于我们的 2 ，因为可以验证， {0, 1 | } 既小于等于 {1 | } ，又大于等于 {1 | } ，两者所在的类是同一个数类。接下来，我们会直接使用 2 来代表 {1 | } 。类似地， {2 | } = 2 + 1 ，因而它所在的类相当于我们的 3 ；可以验证， {1, 2 | } 和 {0, 1, 2 | } 所在的类也都是这个类，它们也都相当于我们的 3 。 <span style="text-decoration: overline">{ | -1}</span> 则相当于我们的 -2 ，你有很多种不同的方法看出这一点来： { | -1} = (-1) + (-1) ，同时也确实是 2 的相反数。 <span style="text-decoration: overline">{0 | 1}</span> 呢？它相当于我们的 1/2 ，可以验证，拿 {0 | 1} 和它自身相加，或者拿 {0 | 1} 乘以 2 ，都将会得到一个既小于等于 1 又大于等于 1 的数。很容易想到， <span style="text-decoration: overline">{-1 | 0}</span> 当然也就相当于我们的 -1/2 了。</p>
<p>进一步了解外星有序域之后，为了让接下来的叙述更加简洁，我们将彻底省略“所在的类”的提法，并放宽各种运算符号的用法。其实，在我们的世界里，我们也是这么做的。我们不会说 1/2 所在的类和 2/4 所在的类是同一个数类，而是说 1/2 和 2/4 是同一个数的两种不同的表示方法，并以 1/2 = 2/4 记之。类似地，我们今后也认为， {1 | } 和 {0, 1 | } 是同一个数的两种不同的表示方法，并以 {1 | } = {0, 1 | } 记之。另外，我们世界里的符号和外星世界里的符号之间的界限也将越来越模糊。数字 2 既可以代表我们世界里的数，也可以代表外星世界里对应的数，还可以代表这个数的任何一种特定的表示方法。这样，我们便能方便地给出更多的例子，来揭示两个世界之间的联系：</p>
<blockquote><p>{0 | 1/2} = {0 | 1/2, 1} = {0 | 1/2, 1, 2} = {-1, 0 | 1/2} = 1/4<br>
{0 | 1/4} = {0 | 1/4, 1/2} = {0 | 1/4, 1} = {-1, 0 | 1/4} = 1/8<br>
{1/2 | 1} = {0, 1/2 | 1} = {1/2 | 1, 2} = {0, 1/2 | 1, 2} = 3/4<br>
{1 | 2} = {0, 1 | 2} = {3/4, 1 | 2, 3} = {0, 1/2, 1 | 2, 3} = 3/2<br>
{1 | 3/2} = {0, 1 | 3/2, 2} = {1/4, 1/2, 1 | 3/2, 2, 3} = 5/4<br>
{0 | 2} = {1/2 | 2} = {3/4 | 3} = {0, 1/2 | 5/4, 3/2, 2} = 1</p></blockquote>
<p>由之前证明过的补充性质 1 和补充性质 2 可知，用左右集合表达出来的数，其数值一定大于左集合里的最大数，小于右集合里的最小数。事实上，可以证明，这个数值一定就是下图所示的树里所有大小夹在左右集合之间的数中最上层的那一个。图中所示的树只画了前面几层，实际上这棵树会无穷伸展下去。</p>
<p><img alt="image placeholder" >
<p>大家或许会敏锐地发现，这里面漏掉了好多数。比如说， 1/3 到哪里去了？既然外星系统是一个有序域，它里面包含有理数域，那应该有 1/3 呀？为了得出 1/3 的表达式，我们不妨把 3 = {2 | } 代入到之前给出的 x<sup>-1</sup> 的公式里去。由于 {2 | } 的左集合只有一个 2 ，右集合是空的，因此代入后的式子并不复杂：</p>
<blockquote><p>L = { 0 } ∪ { (1 + (u – x) · v) / u | u ∈ R(x), v ∈ L(x<sup>-1</sup>) } ∪ { (1 + (u – x) · v) / u | u ∈ L(x), v ∈ R(x<sup>-1</sup>)} = { 0 } ∪ { (1 + (2 – 3) · v) / 2 | v ∈ R(1/3)}<br>
R = { (1 + (u – x) · v) / u | u ∈ L(x), v ∈ L(x<sup>-1</sup>) } ∪ { (1 + (u – x) · v) / u | u ∈ R(x), v ∈ R(x<sup>-1</sup>)} = { (1 + (2 – 3) · v) / 2 | v ∈ L(1/3) }</p></blockquote>
<p>等等，这不对呀？怎么 1/3 的表达式里面还有 1/3 呢？其实，第一次介绍 x<sup>-1</sup> 的公式时，我们有意没提这件诡异的事情，也不知道大家是否已经注意到了。实际上，这个公式的含义是需要另作说明的。它并不是什么循环定义，而是让我们从 {0 | } 开始，根据规则不断地迭代下去。刚开始 L 里只有 0 ，而 R 里什么都没有。把 L 中的这个 0 代入 R 中的 (1 + (2 – 3) · v) / 2 ，于是得到 1/2 ，它便成了 R 里的成员；再把 R 中的 1/2 代入 L 中的 (1 + (2 – 3) · v) / 2 ，于是得到了 1/4 ，它便成了 L 里的新成员；再把 L 中的 1/4 代入 R 中的 (1 + (2 – 3) · v) / 2 ，于是得到了 3/8 ，它便成了 R 里的新成员……你会很快意识到，这样迭代下去是没个完的。因而，最后得到的结果当中，左右集合里都有无穷多个项。如果非要把它写出来，那大致就是 {0, 1/4, 5/16, 21/64, … | 1/2, 3/8, 11/32, 43/128, …} 。当然，这只是 1/3 的其中一种表示方法罢了，不过大家可以立即看到其原理，本质上就是把已有的小于 1/3 但越来越接近 1/3 的数放在左边，把已有的大于 1/3 但越来越接近 1/3 的数放在右边，就像 Dedekind 分割那样。根据刚才提到的结论，如此得来的数将夹在左集合的最大数和右集合的最小数之间，它就只能是 1/3 了。注意，石板上的公理并没有告诉我们，左集合和右集合内是否允许含有无穷多个元素。但是，为了得到一个有序域，为了写出一个 x<sup>-1</sup> 的公式，左集合和右集合内必须允许含有无穷多个元素。我们也就这么规定了。</p>
<p>允许集合里有无穷个数，这不得了。我们可以用同样的方法产生包括无理数在内的所有实数。可以证明这些实数的行为与我们通常所说的实数也是一致的。因此，实数域也是外星系统的一个子有序域。同时，我们还能构造出一系列更匪夷所思的数。比如， {0, 1, 2, 3, … | } 等于多少？根据公理 1 ，这是一个合法的数。根据刚才的结论，它的数值大于左集合里的所有数。因此， {0, 1, 2, 3, … | } 将会是实实在在等于无穷大的一个数！不妨把它记作 ω 。故事远没到此结束。 ω 只是第一个比所有数都更大的数。你可以利用 ω 构造出 {ω | } 。它等于多少呢？你会发现，它等于 ω + 1 。你可以根据加法的定义写出 ω + 1 的结果，并检验它和 {ω | } 互相之间的 ≤ 关系，从而证实 {ω | } 和 ω + 1 的确是同一个数。类似地， {ω, ω + 1 | } 将会是 ω + 2 ， {ω, ω + 1, ω + 2 | } 将会是 ω + 3 。等到 ω + 4 、 ω + 5 也都有了之后，接下来或许该考虑的就是 {ω, ω + 1, ω + 2, ω + 3, … | } 了，它应该等于 ω + ω ，也就是 ω · 2 ！类似地， {ω · 2 | } 就是 ω · 2 + 1 ， {ω · 2, ω · 2 + 1 | } 就是 ω · 2 + 2 ，而 {ω · 2, ω · 2 + 1 , ω · 2 + 2, … | } 就是 ω · 3 了。等到 ω · 4 、 ω · 5 也都有了之后，接下来或许该考虑的就是 {ω, ω · 2, ω · 3, … | } 了，它应该等于 ω · ω ，也就是 ω<sup>2</sup> ！你不妨想象一下 ω<sup>3</sup> 、 ω<sup>4</sup> 的构造过程，等你想好了之后，我们便有了 {ω, ω<sup>2</sup>, ω<sup>3</sup>, … | } ，它就是 ω<sup>ω</sup> ！</p>
<p>熟悉序数理论的朋友可能知道，这里的 ω 借用自第一个极限序数符号。但是，和序数里的 ω 不一样，这里的 ω 是一个实实在在的数。在序数理论中， 1 + ω 和 ω + 1 是不同的， ω · 2 和 2 · ω 也是不同的；但在这里，我们有 1 + ω = ω + 1 ，并且 ω · 2 = 2 · ω 。因为，这里的 ω 是一个实实在在的数，它仍然满足加法交换律、乘法交换律等一切有序域应该具有的性质。</p>
<p>更奇怪的则是 {0, 1, 2, 3, … | ω} ，它将等于 ω – 1 ；而 {0, 1, 2, 3, … | ω, ω – 1} 则等于 ω – 2 。那么， {0, 1, 2, 3, … | ω, ω – 1, ω – 2, … } 呢？它将等于 ω/2 。而 {0, 1, 2, 3, … | ω, ω/2, ω/4, ω/8, … } 将会带来 √<span style="text-decoration:overline">ω</span> 。当然，从另一个方向上看，我们还有 { | 0, -1, -2, … } ，它显然应该等于 -ω 。别忘了，作为一个有序域，每个数不但都有自己的相反数，还有自己的倒数。 {0 | 1, 1/2, 1/4, 1/8, …} 将等于 1/ω ，直观地说也就是无穷小量。 {0 | 1/ω} 则等于 1/(ω · 2) ，而 {1/ω | 1, 1/2, 1/4, 1/8, … } 则等于 2/ω 。我们刚才创造的所有数都是合法的，它们确实都是一个个的数，它们依旧能比较大小，依旧能参与运算。不过，它们明显超出了实数的范围。看来，一个有序域完全有可能比实数域更大。</p>
<p><img alt="image placeholder" >
<p>所以说，Knuth 才把这个外星系统叫做“超实数”。可以证明，由超实数构成的有序域是最大的有序域，其他所有可能的有序域，都只是超实数域里的一个子有序域。</p>
<p>我们把石板上描述的数学对象解读为了我们熟知的数字（以及我们不熟知的数字），因为两者具有相同的代数结构。但实际上，别忘了，这些数学对象其实可以被我们解读成任何东西，可能是对我们有用的，可能是对我们没用的。</p>
<p> </p>
<p><strong>（四）并行的棋局</strong></p>
<p>事实上，这个全新的算术系统是 Knuth 从另一位数学大神 John Conway 那儿听来的。 Knuth 对此非常感兴趣，他把 TAOCP 的写作计划搁置了一周，完成了这部 100 多页的小说，并在 1974 年出版。“超实数”这个词是 Knuth 自己杜撰的。 Conway 非常喜欢这个词，并把它用到了他在 1976 年出版的专著 On Numbers and Games 中。这是一本非常有特色，非常 geek 的书。书的内容分成了第零部分 On Numbers 和第一部分 and Games ，全书的第一句是， This book is in two = {zero, one | } parts 。在这本书中， Conway 给出了超实数背后的直观意义：博弈游戏。</p>
<table>
<tr>
<td style="height:60px"> </td>
<td><img alt="image placeholder" >
<td><img alt="image placeholder" >
<td><img alt="image placeholder" >
<td><img alt="image placeholder" >
</tr>
<tr>
<td>图 1</td>
<td>图 2</td>
<td>图 3</td>
<td>图 4</td>
<td>图 5</td>
</tr>
</table>
<p>让我们来考虑这样一个游戏，游戏的名字叫做 Domineering 。两个玩家轮流在一个形状不规则的棋盘上放置多米诺骨牌。不妨把这两个玩家分别记作“左玩家”和“右玩家”。左玩家只允许在棋盘上放置竖直的多米诺骨牌，右玩家只允许在棋盘上放置水平的多米诺骨牌。谁先不能放了，谁就输了。显然，有的棋局可能会对左玩家更有利，有的棋局可能会对右玩家更有利。让我们来分析几种局面吧。图 1 显示的是一个“空棋盘”。显然，这是一个“中立棋局”，先走的人直接就输了，后走的人直接就赢了。图 2 所示的棋局虽然与空棋盘不同，但本质上一样——这仍然是一个谁后走谁赢的公平局面。图 3 所示的棋局则明显对右玩家更有利一些，事实上不管谁先走，右玩家一定都会获胜。图 4 所示的棋局则偏向了左玩家，不管谁先走，左玩家都会获胜。</p>
<p>Conway 给出了两个棋局相加的含义。定义两个棋局的和为同时包含这两个棋局的新棋局。如果说有两个棋局，棋局 A 和棋局 B ，那么 A + B 的意思就是两个玩家同时在棋局 A 和棋局 B 上游戏。轮到某个玩家行动时，这个玩家可以选择在 A 上走一步，也可以选择在 B 上走一步，只要 A 和 B 当中至少一个还能走，他就不算输。例如，我们可以让两个玩家同时在图 3 和图 4 上游戏，这个游戏就记作</p>
<blockquote><p><img alt="image placeholder" >
<p>不难看出，它的效果等价于一个空的棋局——谁后走谁赢。</p>
<p>图 5 所示的 L 形棋盘就更有意思了。如果左玩家先行，他有两种走法。其中一种走法将刚好给右玩家留下一步，把自己送上了绝路；更聪明的走法则是把棋盘弄断，从而形成 □ + □ 的局面，让右玩家直接死掉。如果是右玩家先行，他只有一步可走，但走完之后就再也无计可施，而左玩家还能多走一步。因此，不管谁先走，这个 L 形棋盘都是左玩家必胜的。</p>
<p>一个有趣的问题：图 4 的 I 形棋盘和图 5 的 L 形棋盘都是左玩家必胜的局面，都是对左玩家有利的局面，那么哪个局面对左玩家<strong>更</strong>有利一些？换句话说，哪个局面会让左玩家赢得更爽一些？大家或许会说，当然是 I 形棋盘更爽。凭什么这么说？有什么理由吗？注意这里我们实际上在做的事情：我们希望能找出一种（对于左玩家来说）棋局优劣的判断标准。其中一种绝妙的想法是，让 I 和 L 两个棋局同时进行，不过左玩家要在 L 中扮演右玩家的角色。换句话说，考虑这样的复合棋盘：</p>
<blockquote><p><img alt="image placeholder" >
<p>两个玩家仍然轮流放置多米诺骨牌，不过规则稍有修改：在 I 形棋盘上，左玩家仍然竖直地放牌，右玩家仍然水平地放牌；但在 L 形棋盘上，两个玩家的身份颠倒了：左玩家只能放水平的牌，右玩家则改放竖直的牌。此时，左玩家在 I 形棋盘上有优势，右玩家在 L 形棋盘上有优势。最终整个棋局更偏向于谁？这显然是一场赤裸裸的“优势绝对值”之战。不难验证，事实上整个棋局仍然是左玩家必胜，不管谁先走谁后走。这说明，左玩家在 I 形棋盘中具有更大的优势，因而 I 形棋盘比 L 形棋盘更好。</p>
<p>对于一个棋局 A ，如果我们完全交换左玩家和右玩家的地位，得到的新棋局就叫做棋局 A 的“反棋局”，记作 -A 。我们规定，对于棋局 A 和棋局 B 来说，如果棋局 A 和棋局 B 的反棋局同时进行（即游戏在 A + (-B) 上进行），左玩家必胜（不管谁先走），那么对于左玩家来说，棋局 A 比棋局 B 更好，或者说棋局 A 优于棋局 B ；反之，如果右玩家必胜（不管谁先走），那么对于左玩家来说，棋局 A 比棋局 B 更差，或者说棋局 A 劣于棋局 B 。如果 A + (-B) 是一个谁后走谁必胜的中立局面，我们就认为，棋局 A 和棋局 B 对于左玩家来说优劣相同，或者说棋局 A 平于棋局 B 。注意，今后不做特殊说明时，棋盘的优劣都是针对左玩家所说的。</p>
<p>棋局 A 劣于棋局 B 的另一个等价的定义就是，如果棋局 B 优于棋局 A ，我们就说棋局 A 劣于棋局 B 。如果棋局 B 优于棋局 A ，说明 B + (-A) 是左玩家必胜的，因而整个复合棋局的反棋局将会是右玩家必胜的。整个复合棋局的反棋局是什么？就是 B 的反棋局，加上 A 的反棋局的反棋局，也就是 A + (-B) 了。而 A + (-B) 对于右玩家必胜，这正好符合之前给出的 A 劣于 B 的定义。</p>
<p>不过目前，没有任何东西可以向我们保证，这些定义是合理的。按照这个优劣定义，没准会出现 A 优于 B 、 B 优于 C 、 C 优于 A 的荒唐一幕，或者棋局 A 优于棋局 B 但 A + C 劣于 B + C 的悖理情形。不过，或许我们能证明，这些情况都不会出现。至少我们可以证明一些最基本的事实，比如根据上面的定义，一个棋局一定和它自身的优劣程度相同。为此，我们只需要说明棋局 A + (-A) 是一个中立局面即可。其实， A + (-A) 显然是谁后走谁必胜的，因为后走的人有一个绝妙的无敌必胜招数：它只需要完全模仿对方的行为即可。先走的人每走一步，他都能在另一个棋盘上照着走一步，从而永远不可能先无路可走。</p>
<p>左玩家必胜（不管谁先走）的棋局 A 也一定优于任意一个中立棋局。我们也可以证明这一点，只需要说明棋局 A 加上中立棋局的反棋局后，左玩家能必胜即可。他显然是能获胜的，他可以在 A 上该怎么走就怎么走，除非回应右玩家在中立棋局上的行动。反过来，右玩家必胜（不管谁先走）的棋局也就一定劣于中立棋局。</p>
<p>现在开始，就是真正神奇的地方了。我们把左玩家走一步之后可能形成的所有局面构成的集合叫做左集合，把右玩家走一步之后可能形成的所有局面构成的集合叫做右集合。看看图 4 的 I 形棋盘：左玩家无论走哪一步，剩余的棋盘都是图 2 的样子；同时，右玩家没有可以走的空间，右集合是一个空集。一个棋局的左集合和右集合完整地描述了再走一步之后这个棋局所有可能的结果，于是我们可以用这两个集合来刻画该棋局。我们就说：</p>
<blockquote><p><img alt="image placeholder" >
<p>图 1 和图 2 的棋局实质上是相同的：左右集合都是空集。它们都应该表示成 { | } 。图 3 所示的棋盘需要引起额外的注意：“不能走”和“可以走到空棋盘状态”是两个完全不同的概念。因此，图 3 的棋盘应该被表示为</p>
<blockquote><p><img alt="image placeholder" >
<p>类似地，</p>
<blockquote><p><img alt="image placeholder" >
<p>图 5 的 L 形棋盘则可以表示为</p>
<blockquote><p><img alt="image placeholder" >
<p>下面我们来看看，在这种棋局表示法下，如何形式化地定义棋局的加法、棋局的反棋局以及棋局的优劣。</p>
<p>如果棋局 A 和棋局 B 同时进行，那么左玩家走一步后可以得到的局面，有可能是在棋局 A 当中走一步（同时棋局 B 保持不动）所得，也可能是在棋局 B 当中走一步（同时棋局 A 保持不动）所得；类似的，右玩家能走出的局面，则是由棋局 A 的所有右集合元素都加上棋局 B ，以及棋局 B 的所有右集合元素都加上棋局 A 构成的。如果把棋局 A 的左右集合分别记作 L(A) 和 R(A) ，把棋局 B 的左右集合分别记作 L(B) 和 R(B) ，那么 A + B 的左右集合就应该分别是：</p>
<blockquote><p>L = { u + B | u ∈ L(A) } ∪ { A + v | v ∈ L(B) }<br>
R = { u + B | u ∈ R(A) } ∪ { A + v | v ∈ R(B) }</p></blockquote>
<p>左玩家在 -A 中的合法移动，也就是 A 的右集合中的元素；右玩家在 -A 中的合法移动，也就是 A 的左集合中的元素。别忘了，移动完之后，双方的决策继续保持反着的状态。如果棋局 A 的左右集合分别记作 L(A) 和 R(A) ，那么 A 的反棋局的左右集合就应该是：</p>
<blockquote><p>L = { -u | u ∈ R(A) }<br>
R = { -u | u ∈ L(A) }</p></blockquote>
<p>最后，我们给出“劣于或平于”的形式化描述。如果棋局 A 劣于或者平于棋局 B ，这意味着 A + (-B) 有两种可能：右玩家必胜，或者谁后走谁必胜。总之，左玩家先走是绝不可能有必胜策略的。反过来，如果左玩家先走真的没有必胜策略（从而右玩家后走将必胜），这正好对应着那两种情况：如果此时再已知右玩家先走也没有必胜策略，那就是谁后走谁必胜；如果此时右玩家先走将必胜，那就属于右玩家必胜的情况。因此， A + (-B) 是右玩家必胜或者谁后走谁必胜的，当且仅当左玩家先走没有必胜策略。这等于是说，左玩家不会在 A + (-B) 上走出一种谁后走谁必胜或者左玩家必胜的局面。如果左玩家在 A 上面走一步，结果一定不会优于或平于 B ；同时， A 也一定不会优于或平于左玩家在 -B 上任意走一步（相当于右玩家在 B 上走一步）的结果。换句话说 A 的左集合中的元素不会优于或平于 B，同时 B 的右集合中的元素不会劣于或者平于 A 。至此为止，大家已经发现，棋局的加法运算，棋局的反棋局运算，以及棋局之间的“劣于或平于”关系，完全等同于超实数的公理和定义！为了保证所有的棋局都是超实数，我们强行规定，所有棋局也都必须满足超实数本身的构造限制，即左集合中没有元素优于或平于右集合中的某个元素。换句话说，对于左玩家来说，左玩家走了一步后所得的棋局，局势一定比右玩家走了一步后所得的棋局更险恶。更直观地说，我们这里考虑的都是先走比后走更不利、每多走一步就更接近死亡的游戏。</p>
<p>为了让棋局完全符合超实数，安全地继承所有超实数中的结论，我们可以生硬地、脱离实际意义地定义棋局的乘法：</p>
<blockquote><p>L = { u · y + x · v – u · v | u ∈ L(A), v ∈ L(B) } ∪ { u · y + x · v – u · v | u ∈ R(A), v ∈ R(B) }<br>
R = { u · y + x · v – u · v | u ∈ L(A), v ∈ R(B) } ∪ { u · y + x · v – u · v | u ∈ R(A), v ∈ L(B) }</p></blockquote>
<p>这样便能把谁是 1 确定下来。现在，超实数的所有公理和定义，都能用来描述棋局的世界了。于是，超实数的一切定理一切性质，包括小于等于的传递性，加法乘法的交换率，乃至整个系统是一个有序域，也都将适用于棋局。事实上，棋局和超实数将会变得同构，它们之间存在最为深入的对应关系。每一个棋局都将对应一个数，棋局之间的加法就是数与数之间的加法，我们完全不必担心棋局的运算结果不符合数的运算结果。和超实数一样，更准确地说，应该是每一个棋局类都将对应一个数，棋局类之间的加法就是数与数之间的加法。不过，和之前讲超实数时一样，为了简便起见，接下来我们都省去“类”字。</p>
<p>空棋盘 ＝ { | } ，也就是 0 ，我们的中立棋局。根据我们之前的结论，左玩家必胜的棋局都将优于中立棋局，从而对应一个大于 0 的数；右玩家必胜的棋局都将劣于中立棋局，从而对应一个小于 0 的数。因此，看看棋局所对的数是正是负，就能判断棋局究竟对谁有利。举例来说：</p>
<blockquote><p><img alt="image placeholder" >
<p>这个值比 0 小，说明该棋局中右玩家必胜。而</p>
<blockquote><p><img alt="image placeholder" >
<p>这个值比 0 大，说明该棋局中左玩家必胜。 L 形棋盘</p>
<blockquote><p><img alt="image placeholder" >
<p>说明它也是对于左玩家来说必胜的。注意到 I 形棋盘的值大于 L 形棋盘，这说明 I 形棋盘优于 L 形棋盘，是一个左玩家能赢得更痛快的棋局。一个直观意义就是，在 I 形棋盘中，左玩家能以一步领先的优势获胜，这个步数优势比 L 形棋盘更大。在 L 形棋盘上，左玩家只能以半步的优势险胜。注意 1/2 + 1/2 + (-1) = 0 ，而</p>
<blockquote><p><img alt="image placeholder" >
<p>真的就是一个中立棋局！</p>
<p>在我们给出棋局的形式化描述时，我们并没有关心实际的游戏规则。这是一个非常一般的棋局理论，它还可以用到很多其他的游戏中。回到本文最开头最开头的地方。我们当时留下了一个问题。 ○● 真的等于 1/2 吗？我们现在可以很轻易地回答了。如果把白方想成是左玩家，那么 ○● = {空棋盘 | ○} = {0 | 1} = 1/2 。我们之前曾经用 ○● + ○● + ● = 0 的办法推出了 ○● = 1/2 ，这也是完全有道理的。</p>
<p>有了这套理论，我们便能用纯代数的方法对新的棋局进行分析。考虑下面这个问题：对于左玩家来说，棋局 ○● 和 ○●● 相比，哪个的优势更大？为了解决这个问题，我们只需要计算一下 ○●● 的值：</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○●● = {空棋盘 | ○, ○●} = {0 | 1, 1/2} = 1/4</p></blockquote>
<p>而 ○● = 1/2 ，它的优势更大一些。由此可以进一步推出，棋局</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○●●<br>
●○</p></blockquote>
<p>的值为 1/4 + (-1/2) = -1/4 ，即右玩家必胜。而棋局</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p>○●●<br>
○●●<br>
●○</p></blockquote>
<p>的值则为 1/4 + 1/4 + (-1/2) = 0 ，即这是一个中立棋局，谁后走谁就能必胜。事实上也确实是这样，你可以自己分析一下。</p>
<p>更厉害的是，由于超实数的左右集合都允许有无穷多个元素，因此这里所说的棋局也允许是无限的。例如，我们可以算出 ○●○●○●○●○●… = 2/3 ，而棋局</p>
<blockquote style="font-family: Helvetica, Times, Arial;"><p> ○●○●○●○●○●…<br>
○●○●○●○●○●…<br>
○●○●○●○●○●…<br>
●<br>
●</p></blockquote>
<p>真的就是一个中立棋局！</p>
<p>这还没结束。由于超实数的值有可能是无穷大量，因而棋局的值也有可能是无穷大量。 ○○○○○… 显然等于 ω ，而 ○○○○○…○ 则等于 ω + 1 。把这样的行加入任何一个原本有限的棋局里，都会使得左玩家必胜。由于超实数的值有可能是无穷小量，因而棋局的值也有可能是无穷小量。 ○●●●●●… 等于 1/ω ，而 ○●●●●●…● 则等于 1/(ω · 2) 。把这样的行加入任何一个原本有限的并且右玩家必胜的棋局里，都不可能使局面发生逆转；但把这样的行加入任何一个中立棋局里，左玩家就会因为获得一个无穷小的步数优势而必胜。</p>
<p>需要补充的是，并不是所有的棋局都能用数来衡量。让我们回到 Domineering 游戏，看一看下图所示的棋盘：</p>
<blockquote><p><img alt="image placeholder" >
<p>它既不属于左玩家必胜的情况，又不属于右玩家必胜的情况，当然也不是中立棋局。这是一种全新的情况——谁先走谁就赢。那这个棋盘的值是多少呢？答案是，这个棋盘不对应任何数值，因为它被排除在了我们的考虑范围之外。为了让棋局都是超实数，我们规定了棋局左集合的元素不能优于或平于右集合的元素，这将会漏掉很多棋局。事实上，</p>
<blockquote><p><img alt="image placeholder" >
<p>大家可以立即看出，它并不是一个合法的数。在 On Numbers and Games 中， Conway 建议用符号 ∗ 来表示这种特殊的棋局 {0 | 0} 。棋局 ∗ 扮演着很重要的角色，例如不难验证等式 ∗ + ∗ = 0 成立。Conway 用符号 ↑ 表示棋局 {0 | ∗} ，容易看出这是一个左玩家必胜的棋局。可以证明，存在等式 {0 | ↑} = ↑ + ↑ + ∗ 。可见，这个里面的水非常地深，继续挖掘下去还大有文章可作。在书中， Conway 还分析了很多其他的游戏以及其他的棋局运算，感兴趣的朋友不妨深入阅读下去。下面这张漂亮的图片来自 Winning Ways for Your Mathematical Plays 一书，直观地展示了各种各样的棋盘及其对应的数。</p>
<p class="indent"><img alt="image placeholder" >
<p> </p>
<p><strong>（五）后记</strong></p>
<p>经常听人问，什么是数学之美？最终发现，还是数学大神 Paul Erdős 的回答犀利：“问什么是数学之美，就像问什么是贝多芬第九交响曲之美一样。”没人能给你讲明白，除非你自己去经历它。</p>
<p>几年前，我就对超实数这一话题特别感兴趣，在看到一个个奇迹般的同构时，感觉全身热血沸腾，沉浸在数学的结构之美当中。最近终于下定决心，写完了整个超实数理论的介绍。这可能是我写过的单篇文章中耗时最久的了，期间我曾经纠结了很多细节问题，一次又一次地被搞晕，一次又一次地陷入哲学思考。我希望能够通过这篇长文，把我这段时间学到的和想到的分享给更多的人，让更多的人理解到数学的乐趣。开篇的博弈游戏出自 <a href="https://www.maths.nottingham.ac.uk/personal/anw/Research/Hack/">Hackenstrings, and the 0.999… ?= 1 FAQ</a> （链接已死，但可在 <a href="http://web.archive.org/web/20061211225310/http://www.maths.nottingham.ac.uk/personal/anw/Research/Hack/">archive.org</a> 上查看），对超实数的描述参考了 Gretchen Grimm 的 <a href="http://www.whitman.edu/Documents/Academics/Mathematics/Grimm.pdf">An Introduction to Surreal Numbers</a> 和 Claus Tøndering 的 <a href="http://www.tondering.dk/main/index.php/surreal-numbers">Surreal Numbers – An Introduction</a> ，多米诺游戏的例子出自 On Numbers and Games ，但对棋局的形式化整理来自于自己的思考，这里面可能存在大量不严谨的地方，希望网友们提出。</p>
			 ]]></content>
<pubDate>2015-05-13T13:11:25+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6333</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 整数分拆中的一个出人意料的结论 ]]></title>
<link>http://www.matrix67.com/blog/archives/6348</link>
<content><![CDATA[ 
		<p>把 6 分成一个或多个正整数之和，本质不同的方案只有以下 11 种：</p>
<table>
<tr>
<td><strong>分拆方案</strong></td>
<td><strong>含有多少种不同的数</strong></td>
</tr>
<tr>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td>5 + 1</td>
<td>2</td>
</tr>
<tr>
<td>4 + 2</td>
<td>2</td>
</tr>
<tr>
<td>4 + 1 + 1</td>
<td>2</td>
</tr>
<tr>
<td>3 + 3</td>
<td>1</td>
</tr>
<tr>
<td>3 + 2 + 1</td>
<td>3</td>
</tr>
<tr>
<td>3 + 1 + 1 + 1</td>
<td>2</td>
</tr>
<tr>
<td>2 + 2 + 2</td>
<td>1</td>
</tr>
<tr>
<td>2 + 2 + 1 + 1</td>
<td>2</td>
</tr>
<tr>
<td>2 + 1 + 1 + 1 + 1</td>
<td>2</td>
</tr>
<tr>
<td>1 + 1 + 1 + 1 + 1 + 1</td>
<td>1</td>
</tr>
</table>
<p>其中，每一行右边的那个数表示，该分拆方案中含有多少种不同的数。把右列的所有数全部加起来，结果是 19 。神奇的是，如果你数一数所有分拆方案中 1 出现的总次数，你会发现结果也是 19 。</p>
<p>这并不是巧合。事实上，对于任意一个正整数来说，各个分拆方案中不同的数的个数之和，一定都等于所有方案中 1 出现的总次数。这是为什么呢？这个结论还有一个比较直接的推广，你能想到吗？</p>
<p><span id="more-6348"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>这个结论可以推广为，对于任意一个正整数 n 来说，各个分拆方案中出现了至少 k 次的数的个数之和，一定等于所有方案中 k 出现的总次数。以 n = 6, k = 2 为例：</p>
<table>
<tr>
<td><strong>分拆方案</strong></td>
<td><strong>含有多少种至少出现了 2 次的数</strong></td>
</tr>
<tr>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>5 + 1</td>
<td>0</td>
</tr>
<tr>
<td>4 + 2</td>
<td>0</td>
</tr>
<tr>
<td>4 + 1 + 1</td>
<td>1</td>
</tr>
<tr>
<td>3 + 3</td>
<td>1</td>
</tr>
<tr>
<td>3 + 2 + 1</td>
<td>0</td>
</tr>
<tr>
<td>3 + 1 + 1 + 1</td>
<td>1</td>
</tr>
<tr>
<td>2 + 2 + 2</td>
<td>1</td>
</tr>
<tr>
<td>2 + 2 + 1 + 1</td>
<td>2</td>
</tr>
<tr>
<td>2 + 1 + 1 + 1 + 1</td>
<td>1</td>
</tr>
<tr>
<td>1 + 1 + 1 + 1 + 1 + 1</td>
<td>1</td>
</tr>
</table>
<p>右列的总和是 8 ，这正好是所有分拆方案中 2 出现的总次数。再比如，上面的分拆方案列表中一共只出现了一个 6 ，同时也确实只发生了一次某个方案中的某个数出现 6 次的情况。这说明结论对于 n = 6, k = 6 的情形也成立。前文给出的结论，其实就是 k = 1 时的特殊情形。</p>
<p>接下来，我们将直接证明推广之后的结论。不妨让我们以 n = 6, k = 2 的情形为例来说明吧。我们先列出所有在某个分拆方案中出现了至少 2 次的数：</p>
<blockquote><p>(4, 1, 1) 里的 1<br>
(3, 3) 里的 3<br>
(3, 1, 1, 1) 里的 1<br>
(2, 2, 2) 里的 2<br>
(2, 2, 1, 1) 里的 2<br>
(2, 2, 1, 1) 里的 1<br>
(2, 1, 1, 1, 1) 里的 1<br>
(1, 1, 1, 1, 1, 1) 里的 1</p></blockquote>
<p>然后，我们再用分拆方案加下标的方式，列出所有含有 2 的分拆方案。一个分拆方案中含有多少个 2 ，该方案就要重复列出多少次，并用下标 1, 2, 3, … 来区分。</p>
<blockquote><p>(4, 2) <sub>1</sub><br>
(3, 2, 1) <sub>1</sub><br>
(2, 2, 2) <sub>1</sub><br>
(2, 2, 2) <sub>2</sub><br>
(2, 2, 2) <sub>3</sub><br>
(2, 2, 1, 1) <sub>1</sub><br>
(2, 2, 1, 1) <sub>2</sub><br>
(2, 1, 1, 1, 1) <sub>1</sub></p></blockquote>
<p>我们要做的，就是在这两个列表之间建立一一对应的关系。很简单：如果某个分拆方案中出现了至少 2 次 i ，我们就把其中 2 个 i 换成 i 个 2 ，并为所得的分拆方案添加下标 i 。容易看出，把 2 个 i 换成 i 个 2 ，所有数的总和不变，因而所得的仍然是一个合法的分拆方案；并且由于所得的分拆方案中已经有至少 i 个 2 了，因而添加的下标 i 确实在应有的范围内。因此，前一个列表里的任意一项都可以用这种方法变换为后一个列表里的其中一项。反过来，后一个列表里的任意一项也都可以反过去变成前一个列表里的其中一项，你只需要把下标所示的这么多个 2 换成 2 个下标所示的这个数即可。这就证明了，两个列表之间存在一一对应的关系。</p>
<blockquote><p>(4, 1, 1) 里的 1   ——   (4, 2) <sub>1</sub><br>
(3, 3) 里的 3   ——   (2, 2, 2) <sub>3</sub><br>
(3, 1, 1, 1) 里的 1   ——   (3, 2, 1) <sub>1</sub><br>
(2, 2, 2) 里的 2   ——   (2, 2, 2) <sub>2</sub><br>
(2, 2, 1, 1) 里的 2   ——   (2, 2, 1, 1) <sub>2</sub><br>
(2, 2, 1, 1) 里的 1   ——   (2, 2, 2) <sub>1</sub><br>
(2, 1, 1, 1, 1) 里的 1   ——   (2, 2, 1, 1) <sub>1</sub><br>
(1, 1, 1, 1, 1, 1) 里的 1   ——   (2, 1, 1, 1, 1) <sub>1</sub></p></blockquote>
<p>这个结论叫做 Elder 定理，它是由滑铁卢大学的一名学生 Paul Elder 在 1984 年证明的。有趣的是， Richard Stanley 早在 1972 年便发现了这个结论，并把它提交到了 The American Mathematical Monthly 的 Problems and Solutions 栏目，没想到却被编辑拒绝了。 Stanley 猜测，这可能是因为编辑没有看懂题目的意思。 Stanley 跟 Daniel Cohen 讲过这个题目，后者在 1978 年出版的 Basic Techniques of Combinatorial Theory 当中把 k = 1 的情形用作了一道练习题，并提到了 Stanley 的名字。因而， k = 1 的这种特殊情形有时也会叫做 Stanley 定理。上述证明方法则来自 Richard Stanley 本人的 Enumerative Combinatorics 一书。</p>
			 ]]></content>
<pubDate>2015-05-17T17:39:35+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6348</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：下一根枕木应该画在哪儿？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6371</link>
<content><![CDATA[ 
		<p>一位画家正在画画。画布上是一望无际的平原，一条笔直的铁路向无限远的地方延伸。画家画了铁路上的两根相邻的枕木，它们在画面上呈两条平行的线段，并且都与地平线平行。这时，画家突然犯难了：根据透视的原理，下一根枕木应该画在哪儿呢？你能帮他确定出下一根枕木的位置吗？</p>
<p><img alt="image placeholder" >
<p>这里，我们假设陆地是一个无限大的平面，并且铁路上的相邻枕木之间的间距相等。</p>
<p><span id="more-6371"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>假设两根枕木分别是 AB 和 CD 。容易想到，如果地面上的两条直线交于地平线处，就说明这两条直线是平行的。另外，注意到相邻枕木之间构成了一个个全等的矩形，它们的对角线应该是平行的。于是，我们就有了这样一个方案：延长 BC 与地平线交于点 P ，然后连接 PD ，与左边的铁轨线交于 E 。现在，只需要作一条与已有枕木平行的线段 EF 。线段 EF 就是铁路中的下一根枕木。</p>
<p><img alt="image placeholder" >
<p>这个问题来自 Ross Honsberger 的 More Mathematical Morsels 一书。</p>
			 ]]></content>
<pubDate>2015-05-19T12:03:16+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6371</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：无限多层嵌套的逻辑推理 ]]></title>
<link>http://www.matrix67.com/blog/archives/6377</link>
<content><![CDATA[ 
		<p>大家一定见过很多“我不知道，我也不知道，我还是不知道，我还是不知道，我知道了，我也知道了”的问题。但是，我想大家一定没有见过下面这样的问题。</p>
<p>A 、 B 两人在主持人 C 的带领下玩一个游戏。 C 向两人宣布游戏规则：“一会儿我会随机产生两个不同的形如 n – 1/2<sup>k</sup> – 1/2<sup>k+r</sup> 的数，其中 n 、 k 是正整数， r 是非负整数。然后，我会把这两个数分别交给你们。你们每个人都只知道自己手中的数是多少，但不知道对方手中的数是多少。你们需要猜测，谁手中的数更大一些。”这里，我们假设所有人的逻辑推理能力都是无限强的，并且这一点本身也成为了共识。 C 按照规则随机产生了两个数，把它们交给了 A 和 B ，然后问他们是否知道谁手中的数更大。于是有了这样的一段对话。 <span id="more-6377"></span></p>
<blockquote><p>A ：我不知道。<br>
B ：我也不知道。<br>
A ：我还是不知道。<br>
B ：我也还是不知道。<br>
C ：这样下去是没有用的！可以告诉你们，不管你们像这样来来回回说多少轮，你们仍然都没法知道，谁手中的数更大一些。<br>
A ：哇，这个信息量好像有点儿大！不过，即使知道了这一点，我还是不知道谁手中的数更大。<br>
B ：我也还是不知道。<br>
A ：我继续不知道。<br>
B ：我也继续不知道。<br>
C ：还是套用刚才的话，不管你们像这样继续说多少轮，你们仍然没法知道谁手中的数更大。<br>
A ：哦……不过，我还是不知道谁手中的数更大。<br>
B ：而且我也还是不知道。我们究竟什么时候才能知道呢？<br>
C ：事实上啊，如果我们三个就像这样继续重复刚才的一切——你们俩互相说一堆不知道，我告诉你们这样永远没用，然后你们继续互说不知道，我继续说这不管用——那么不管这一切重复多少次，你们仍然不知道谁手中的数更大！<br>
A ：哇，这次的信息量就真的大了。只可惜，我还是不知道谁的数更大一些。<br>
B ：我也还是不知道。<br>
A ：是吗？好，那我现在终于知道谁的数更大了。<br>
B ：这样的话，那我也知道了。而且，我还知道我们俩手中的数具体是多少了。<br>
A ：那我也知道了。</p></blockquote>
<p>那么 ， C 究竟把哪两个数给了 A 和 B ？</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>上面的题目明显来自于这样一个老题： C 随机产生了两个不同的正整数，分别交给了 A 、 B ，并让两人猜测谁手中的数更大。然后 A 说不知道， B 说不知道， A 说还是不知道， B 也说还是不知道，然后 A 说知道了， B 说不但知道了，而且这两个数具体是多少都知道了。问这两个数是多少。</p>
<p>解答过程并不复杂。首先， A 说了一个“不知道”。这当然不奇怪，一开始就说“知道了”才奇怪呢。我们不妨反过来想想，什么情况下 A 一开始就会说“知道了”呢？容易想到，这一定是因为 A 手中的数是 1 。由于 C 产生了两个<strong>不同</strong>的<strong>正</strong>整数，因此当 A 手中的数是 1 时，他就知道了 B 手中的数必然更大。然而， A 实际上说的是“不知道”，这说明 A 手中拿到的数不是 1 。也就是说， A 手中的数至少是 2 。</p>
<p>B 听到了 A 的回答后，也推出了这一点。那么，什么情况下 B 会立即说“知道了”呢？当然，如果 B 手中的数是 1 ，他就立即知道 A 手中的数更大了，因为 A 手中的数至少是 2 。另外，如果 B 手中的数是 2 ，他也会立即知道 A 手中的数更大——既然 A 手中的数至少是 2 ，并且又不等于自己手中的数，因而必然更大一些。当然， B 说的实际上是“不知道”，这说明 B 手中的数至少是 3 。</p>
<p>A 听到了 B 的回答后，也推出了这一点。但是， A 又说了个“不知道”。这说明， A 拿到的既不是 2 ，也不是 3 ，否则他都能推出 B 手中的数更大。因此， A 手中的数至少是 4 。同理，根据 B 的下一个“不知道”可以推出， B 手中的数既不是 3 ，也不是 4 ，至少是 5 。此时， A 说“知道了”。这说明， A 手中的数肯定是 4 和 5 当中的一个，他据此推出了 B 手中的数更大。但是， B 为什么能紧接着推出 A 手中的数具体是多少呢？这一定是因为， B 手中的数就是 5 ，因而能断定 A 手中的数只可能是 4 。所以， A 、 B 两人手中的数分别是 4 和 5 。</p>
<p>这就是旧版的题目。它和本文最开头的那个新版的题目有什么联系呢？用下面两张图来说明真是再合适不过了。在旧版的题目中，把两人手中可能的数（也就是 C 能产生出来的数）全都标在数轴上，那大概是这样：</p>
<p><img alt="image placeholder" >
<p>而在新版的题目中，把两人手中可能的数（也就是 C 能产生出来的数）全都标在数轴上，则大概是这样：</p>
<p><img alt="image placeholder" >
<p>你会发现这种情况非常有意思。最小的一批数是 0, 1/4, 3/8, 7/16, … ，这样数下去会有无穷多个数。但是，这无穷多个数的后面还有 1/2, 5/8, 11/16 等数，而且这一系列数本身又是无穷多的；在这无穷多个数的后面又还有 3/4, 13/16 等数，它们也有无穷多个……事实上，我们会遇到无穷多个类似于这样的无穷多个数，而最关键的就是，在这无穷多个无穷的后面，还有 1, 5/4, 11/8 等数。在新版的题目中， A 、 B 、 C 之间的游戏就是在这样的“场所”上进行的。</p>
<p>和旧题类似，在新题中，两人一遍又一遍地宣称自己“不知道”，本质上就是对序列 0, 1/4, 3/8, 7/16, … 从前往后进行排除。然而， C 跳出来说“这样下去是没有用的”，就意味着任何一方手上的数都不可能是该序列里的数，本质上相当于帮两人一下子排除掉了这无穷多种可能。如果此时 A 说自己“知道了”，那一定是因为他手里拿着的是除掉这无穷多个数之后剩下的最小的数，即 1/2 。然而， A 仍然说自己“不知道”，并且 B 也继续说自己“不知道”，并如此往复。此时，他们就相当于是在序列 1/2, 5/8, 11/16, … 上斗智了。而 C 又说了一遍刚才的话，本质上相当于又帮两人把这一系列数都排除掉了。两人继续开始考虑下一系列数的可能。</p>
<p>最后， C 告诉两人，这个模式重复多少次都不管用。于是，再下一系列的数，再下一系列的数，以及后面无穷多个系列的数，都被排除掉了。两人都知道了，他们手上的数都至少是 1 。当 A 再次说“不知道”的时候，说明他手中的数不是 1 ； B 再次说“不知道”，说明他手中的数既不是 1 也不是 5/4 ； A 说“知道了”，说明他手中的数是 5/4 和 11/8 中的一个； B 连具体的数也推出来了，说明此时 B 手上的数就是 11/8 。所以，两人手上的数分别是 5/4 和 11/8 。</p>
<p>本文的问题出自<a href="http://jdh.hamkins.org/transfinite-epistemic-logic-puzzle-challenge/">这里</a>，有改动。知道序数理论的朋友或许会意识到，这是引入序数概念的一个绝佳的例子。文中的很多细节之处缺乏形式化描述，这使得题目和解答都有商讨的空间。</p>
			 ]]></content>
<pubDate>2015-05-22T18:13:03+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6377</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：不等式背后的直观意义 ]]></title>
<link>http://www.matrix67.com/blog/archives/6386</link>
<content><![CDATA[ 
		<p>有时，为了说明某个式子始终成立，我们会为它构造一个情境。例如，为了说明</p>
<p class="indent">C(m, 0) · C(w, r) + C(m, 1) · C(w, r – 1) + … + C(m, r) · C(w, 0) = C(m + w, r)</p>
<p>始终成立，只需要注意到，等号的左边和右边计算的都是同一个东西：假如一个班上有 m 个男生 w 个女生，从中选出 r 个人有多少种方案。等号左边的计算方式是，分别计算 0 男 r 女、 1 男 r – 1 女、 2 男 r – 2 女等 r + 1 种情况的方案数，然后把它们加起来。等号右边则是直接算出了从这 m + w 个人中选出 r 个人的方案数。两种算法所得的答案应该是相等的。</p>
<p>现在，请你构造一个情境，来说明不等式</p>
<p class="indent">(1 – p<sup>m</sup>)<sup>n</sup> + (1 – q<sup>n</sup>)<sup>m</sup> ≥ 1</p>
<p>总成立，其中 m 、 n 是任意正整数， p 、 q 是任意正实数，并且满足 p + q ≤ 1 。</p>
<p><span id="more-6386"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>假设有一个三角形 ABC ，其中从 B 顶点引出 n 条射线，与 AC 边交于 n 个点，又从 C 顶点引出 m 条射线，与 AB 边交于 m 个点。所有这些线条在三角形内一共产生了 mn 个交点。现在，在每一个交点处都画一个小圆，于是每个小圆内都会有两条小线段。对于每一个小圆，我们都随机从下述三个操作中选择一个来执行。</p>
<ul>
<li>擦去 C 点所引射线上的小线段，仅保留 B 点所引射线上的小线段</li>
<li>擦去 B 点所引射线上的小线段，仅保留 C 点所引射线上的小线段 </li>
<li>擦去圆内的全部两条小线段</li>
</ul>
<p>三种操作各自被选中的概率分别为 p 、 q 和 1 – p – q 。于是，每一个小圆里都最多只留下了一条小线段。</p>
<p class="indent"><img alt="image placeholder" >
<p>每条从 B 点出发的线上都有 m 个小圆，这条线在 m 个小圆内都被保留下来了的概率是 p<sup>m</sup> ，因而整条线有断掉之处的概率就是 1 – p<sup>m</sup> 。从 B 点出发的线一共有 n 条，每条线都有断掉之处的概率就是 (1 – p<sup>m</sup>)<sup>n</sup> 。因此，至少有一条线完好无缺的概率就是 1 – (1 – p<sup>m</sup>)<sup>n</sup> 。类似地，从 C 点出发的 m 条线当中，至少有一条线完好无缺的概率就是 1 – (1 – q<sup>n</sup>)<sup>m</sup> 。</p>
<p>但是，从 B 点出发的线条只要有一条是完全连通的，都会使得从 C 点出发的所有线条都断掉；从 C 点出发的线条只要有一条是完全连通的，都会使得从 B 点出发的所有线条都断掉。因此，存在某条从 B 点出发的完好的线，与存在某条从 C 点出发的完好的线，这两个事件是互斥的。这说明</p>
<p class="indent">(1 – (1 – p<sup>m</sup>)<sup>n</sup>) + (1 – (1 – q<sup>n</sup>)<sup>m</sup>) ≤ 1</p>
<p>整理可得</p>
<p class="indent">(1 – p<sup>m</sup>)<sup>n</sup> + (1 – q<sup>n</sup>)<sup>m</sup> ≥ 1</p>
<p>这个问题来自 Ross Honsberger 的 More Mathematical Morsels 一书。</p>
			 ]]></content>
<pubDate>2015-05-24T09:07:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6386</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Sierpiński 的初等数论问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/6405</link>
<content><![CDATA[ 
		<p>波兰数学家 Wacław Sierpiński 对数论有很多研究。在他一生出版的 50 多本书里， 250 Problems of Elementary Number Theory 一书显得格外有趣。这里面不但有各种出人意料的数学事实，还有很多精妙的证明和大胆的构造，让人大呼过瘾。我从中选择了一些问题，在这里和大家一块儿分享。下面的文字没有完全照搬书中的内容，而是做了大量的改动和扩展；若有出错的地方，还请大家指正。个别题目会涉及一些初等数论中的著名定理，它们都可以在<a href="http://www.matrix67.com/blog/archives/5100">这篇文章</a>里找到。</p>
<p><span id="more-6405"></span> </p>
<p><strong>找出所有的正整数 n ，使得 n<sup>2</sup> + 1 能被 n + 1 整除。</strong></p>
<p>满足要求的解只有一个： n = 1 。原因很简单：如果 n<sup>2</sup> + 1 = n(n + 1) – (n – 1) 是 n + 1 的整倍数，那么 n – 1 也必须是 n + 1 的整倍数，这只有一种可能性，即 n – 1 = 0 。</p>
<p> </p>
<p><strong>证明：对于任意大于 6 的偶数 n ，我们都能找到两个质数 p 和 q ，使得 n – p 和 n – q 互质。</strong></p>
<p>不管 n 是多少，令 p = 3, q = 5 即可。这样一来， n – p 和 n – q 就是两个相邻的奇数，它们必然互质。</p>
<p> </p>
<p><strong>找出所有公差为 100 的等差数列，使得里面的所有项都是质数。</strong></p>
<p>满足要求的等差数列不存在。这是因为，在 p, p + 100, p + 200 这三个数当中，至少有一个数能被 3 整除，因而 p 只能等于 3 。此时， p + 200 = 3 + 200 = 203 = 7 × 29 ，这就说明满足要求的等差数列不存在。</p>
<p> </p>
<p><strong>找出所有这样的质数，它既能表示成两个质数之和，也能表示成两个质数之差。</strong></p>
<p>满足要求的数只有 5 ，它可以表示成 3 + 2 和 7 – 2 。下面我们证明，这个问题没有别的解了。如果质数 r 能表示成两个质数之和，那么显然 r &gt; 2 ，因而 r 只能是奇数。两个质数之和是一个奇数，则其中一个质数一定是 2 ；两个质数之差是一个奇数，则其中一个质数也一定是 2 。因此， r 只有可能被表示成 p + 2 和 q – 2 ，其中 p 和 q 都是质数。这说明， p, r, q 是三个连续奇数。三个连续奇数当中，必然有一个能被 3 整除。如果它们都是质数，那么一定有一个数就是 3 。因此， (p, r, q) = (3, 5, 7) 是唯一的可能。</p>
<p> </p>
<p><strong>33 = 3 × 11 ， 34 = 2 × 17 ， 35 = 5 × 7 。它们组成了三个连续的正整数，其中每个数都是两个不同的质数之积。是否存在四个连续的正整数，使得每个数都是两个不同的质数之积？</strong></p>
<p>不存在。任意四个连续的正整数中，一定有一个能被 4 整除，它显然不是两个不同的质数之积。</p>
<p> </p>
<p><strong>证明：方程 xy + x + y = 2<sup>32</sup> 存在正整数解。</strong></p>
<p>原方程相当于 xy + x + y + 1 = 2<sup>32</sup> + 1 ，即 (x + 1) · (y + 1) = 2<sup>2<sup>5</sup></sup> + 1 ，而后者是 n = 5 时的 Fermat 数，众所周知，它是能被分解成两个大于 1 的整数之积的。</p>
<p> </p>
<p><strong>证明：方程 x<sup>2</sup> + y<sup>2</sup> + 1 = z<sup>2</sup> 有无穷多组正整数解。</strong></p>
<p>对于任意正整数 n ， (2n)<sup>2</sup> + (2n<sup>2</sup>)<sup>2</sup> + 1 = (2n<sup>2</sup> + 1)<sup>2</sup> 都成立。</p>
<p> </p>
<p><strong>证明：对于任意一个无限小数（不一定是无限循环小数），我们都能找到一个任意长的数字串，使得它会在这个无限小数的小数展开当中出现无穷多次。</strong></p>
<p>令 m 为任意大的正整数。把小数点后的数字每 m 位分成一组，从而得到无穷多个 m 位数字串。由于不同的 m 位数字串只有 10<sup>m</sup> 种，因而必然有一种数字串会出现无穷多次。</p>
<p> </p>
<p><strong>证明：对于任意正整数 m ，总存在一个关于 x 和 y 的整系数方程 ax + by = c ，使得方程恰好有 m 个正整数解。</strong></p>
<p>不管 m 是多少，令 c = m + 1 ，则方程 x + y = c 满足要求。这个方程显然有且仅有 m 个解，它们分别是 (1, m), (2, m – 1), …, (m, 1) 。</p>
<p> </p>
<p><strong>证明：对于任意正整数 m 、 n ，总存在一个关于 x 和 y 的整系数方程 ax + by = c ，使得 x = m, y = n 是方程的唯一正整数解。</strong></p>
<p>令 a 和 b 为两个不同的大于 m + n 的质数，令 c = am + bn ，则方程 ax + by = c 满足要求。为什么呢？不管是 x ≥ m, y &gt; n ，还是 x &gt; m, y ≥ n ，都会使得 ax + by &gt; am + bn = c 。所以，如果方程有不同的正整数解，则要么 x &lt; m ，要么 y &lt; n 。如果 x &lt; m 的话，那么 m – x 就是一个小于 m 的正整数。注意到 by = c – ax = am + bn – ax = a(m – x) + bn ，其中 by 是 b 的倍数， bn 是 b 的倍数，因而 a(m – x) 也是 b 的倍数；但 a 和 b 是两个不同的质数，于是 a(m – x) 是 b 的倍数就意味着 m – x 是 b 的倍数。但这是不可能的，因为 m – x &lt; m &lt; b 。用类似的方法可以说明， y &lt; n 也是不可能的。</p>
<p> </p>
<p><strong>给出一个多项式 f(x) ，它可以被分解成两个因式的乘积，但却存在 100 个不同的正整数，使得每一个数代入 f(x) 后，得到的值都是一个质数。</strong></p>
<p>假设 p<sub>1</sub>, p<sub>2</sub>, …, p<sub>100</sub> 是 100 个不同的质数，则多项式</p>
<p class="indent">f(x) = [(x – p<sub>1</sub>)(x – p<sub>2</sub>)…(x – p<sub>100</sub>) + 1] · x</p>
<p>显然满足要求。当 x 取 p<sub>1</sub>, p<sub>2</sub>, …, p<sub>100</sub> 时， f(x) 的值分别为 p<sub>1</sub>, p<sub>2</sub>, …, p<sub>100</sub> ，它们都是质数。</p>
<p> </p>
<p><strong>如果 f(x) 是一个整系数多项式，那么 f(x) = 0 有整数解，就意味着对于所有的质数 p ， f(x) = 0 (mod p) 也都有整数解。这个命题反过来成立吗？如果某个整系数多项式 f(x) 满足，对于所有的质数 p ， f(x) = 0 (mod p) 都有整数解，那么 f(x) = 0 也一定有整数解吗？这里， f(x) = 0 (mod p) 的意思是，如果只看 f(x) 除以 p 的余数，则在这个意义下它等于 0 。</strong></p>
<p>4x + 2 = 0 显然没有整数解，但对于任意质数 p ，4x + 2 = 0 (mod p) 都有整数解。当 p = 2 时，任何 x 都是一个解；当 p 为其他质数时， p 必然具有 2k + 1 的形式，此时 x = k 即为一个解。</p>
<p> </p>
<p><strong>有人宣称，任意给定一个正整数，如果它不是质数，那么最多改动其中一个数字，就能把它变成质数。这个说法对吗？</strong></p>
<p>这个说法是错误的。 200 不是一个质数。为了让它变成一个质数，你必须要把末位的 0 改成某个奇数。然而， 201, 203, 205, 207, 209 都不是质数。事实上，我们可以证明，像这样的反例有无穷多个，例如所有形如 2310k – 210 的数都可以用作反例。为了让它变成一个质数，你必须要把末位的 0 改成某个奇数，然而：</p>
<ul>
<li>2310k – 210 + 1 = 2310k – 209 = 11 · (210k – 19)</li>
<li>2310k – 210 + 3 = 2310k – 207 = 3 · (770k – 69)</li>
<li>2310k – 210 + 5 = 2310k – 205 = 5 · (462k – 41)</li>
<li>2310k – 210 + 7 = 2310k – 203 = 7 · (330k – 29)</li>
<li>2310k – 210 + 9 = 2310k – 201 = 3 · (770k – 67)</li>
</ul>
<p> </p>
<p><strong>证明：存在任意大的正整数 x 、 y ，使得 x 不能整除 y ，但 x<sup>x</sup> 能整除 y<sup>y</sup> 。</strong></p>
<p>选取一个任意大的正整数 k ，再选取一个大于 k · 2<sup>k – 1</sup> 的质数 p 。令 x = 2<sup>k</sup> ，令 y = 2p ，则 x 和 y 满足要求。这是因为只要 k &gt; 1 ，那么 x 显然都不能整除 y ；同时，我们有 x<sup>x</sup> = (2<sup>k</sup>)<sup>2<sup>k</sup></sup> = 2<sup>k · 2<sup>k</sup></sup> ，并且 y<sup>y</sup> = (2p)<sup>2p</sup> = 2<sup>2p</sup> · p<sup>2p</sup> ，由于 2p &gt; k · 2<sup>k</sup> ，因而 x<sup>x</sup> 能够整除 y<sup>y</sup> 。</p>
<p> </p>
<p><strong>证明：对于任意正整数 n ，我们都能找到一个适当的正整数 x ，使得序列 x + 1, x<sup>x</sup> + 1, x<sup>x<sup>x</sup></sup> + 1, … 里的所有数都能被 n 整除。</strong></p>
<p>很简单， x = 2n – 1 就满足要求。由于 x 是一个奇数，而奇数的奇数次方一定还是奇数，因而序列 x, x<sup>x</sup>, x<sup>x<sup>x</sup></sup>, … 里的所有数都是奇数。另外再注意到，对于任意一个奇数 m 来说， a<sup>m</sup> + 1 都能被 a + 1 整除。因此，序列 x + 1, x<sup>x</sup> + 1, x<sup>x<sup>x</sup></sup> + 1, … 里的所有数都能被 2n = x + 1 整除，它们自然也就都能被 n 整除了。</p>
<p>为什么对于任意一个奇数 m 来说， a<sup>m</sup> + 1 都能被 a + 1 整除呢？由于 a = -1 是方程 a<sup>m</sup> + 1 = 0 的一个解，因而多项式 a<sup>m</sup> + 1 一定能被分解成 (a + 1)( … … ) 的样子，这就说明了 a<sup>m</sup> + 1 能被 a + 1 整除。在下一题中，我们还会用到这个结论。</p>
<p>类似地，对于任意一个正整数 m 来说， a<sup>m</sup> – 1 都能被 a – 1 整除。由于 a = 1 是方程 a<sup>m</sup> – 1 = 0 的一个解，因而多项式 a<sup>m</sup> – 1 一定能被分解成 (a – 1)( … … ) 的样子，这就说明了 a<sup>m</sup> – 1 能被 a – 1 整除。在再下一题中，我们会用到这个结论。</p>
<p> </p>
<p><strong>证明：存在无穷多个正整数 n ，使得 2<sup>n</sup> + 1 能被 n 整除。</strong></p>
<p>首先， 2<sup>3</sup> + 1 能被 3 整除。另外，如果 2<sup>n</sup> + 1 能被 n 整除，那么 2<sup>2<sup>n</sup> + 1</sup> + 1 一定能被 2<sup>n</sup> + 1 整除。这是为什么呢？不妨假设 2<sup>n</sup> + 1 = n · k 。考虑到 2<sup>n</sup> + 1 是奇数，因而 k 也一定是奇数。根据上题使用过的结论， (2<sup>n</sup>)<sup>k</sup> + 1 就能被 2<sup>n</sup> + 1 整除，即 2<sup>n · k</sup> + 1 = 2<sup>2<sup>n</sup> + 1</sup> + 1 能被 2<sup>n</sup> + 1 整除。综合上面两条便可得到，存在无穷多个满足要求的 n 。</p>
<p>大家可能会想，那么，有多少个正整数 n ，使得 2<sup>n</sup> – 1 能被 n 整除呢？答案是，只有一个满足要求的解，即 n = 1 。证明比较复杂，这里略去。</p>
<p> </p>
<p><strong>人们已经知道了，质数有无穷多个。一个经典的结论是，相邻质数之间的间隔也可以达到任意大，或者说存在任意长的连续正整数，使得里面的所有数都是合数。例如， n! + 2, n! + 3, …, n! + n 就是连续 n – 1 个正整数，由于它们分别能被 2, 3, …, n 整除，因而它们都是合数。 Mersenne 质数是形如 2<sup>n</sup> – 1 的质数，例如 3, 7, 31, 127 等等。目前人们还不知道， Mersenne 质数是否有无穷多个。一个有意思的问题是，在所有形如 2<sup>n</sup> – 1 的数里面，相邻的 Mersenne 质数之间的间隔也能达到任意大吗？换句话说，在数列 1, 3, 7, 15, 31, … 中，是否存在任意长的连续项，使得里面的所有数都是合数？</strong></p>
<p>我们首先证明，如果 b 能被 a 整除，那么 2<sup>b</sup> – 1 也一定能被 2<sup>a</sup> – 1 整除。不妨假设 b = a · k ，于是 2<sup>b</sup> – 1 = (2<sup>a</sup>)<sup>k</sup> – 1 ，根据上上题末尾引申的结论，它能被 2<sup>a</sup> – 1 整除。证明这件事情还有一个有趣的方法。 2<sup>b</sup> – 1 的二进制表达就是 b 个数字 1 相连， 2<sup>a</sup> – 1 的二进制表达就是 a 个数字 1 相连，如果 b 能被 a 整除的话，让这两个数在二进制的世界里做除法，显然能够除尽，比如 111111 除以 11 就等于 10101 。</p>
<p>因此， 2<sup>n! + 2</sup> – 1, 2<sup>n! + 3</sup> – 1, …, 2<sup>n! + n</sup> – 1 分别能被 2<sup>2</sup> – 1, 2<sup>3</sup> – 1, …, 2<sup>n</sup> – 1 整除，因而在所有形如 2<sup>n</sup> – 1 的数里面，相邻的 Mersenne 质数之间的间隔能达到任意大。</p>
<p>“存在任意长的并且全是合数的连续正整数”真的是一个很经典的结论，除了可以平行地扩展到其他的场合，其本身也还有很多加强版。下面这个可以算是我所见过的最终极的加强版了。证明：对于任意的正整数 n 和 s ，我们都能找到任意长的连续正整数，使得对于这里面的每一个数来说，它里面都含有至少 n 个不同的质因数，其中的每个质因数都出现了至少 s 次。</p>
<p>下面，我们就来构造一段满足要求的并且长度为 m 的连续正整数，其中 m 是任意大的正整数。假设 p<sub>1</sub>, p<sub>2</sub>, …, p<sub>mn</sub> 是 mn 个不同的质数。令 a<sub>1</sub> 为前 n 个质数的 s 次方之积，即 a<sub>1</sub> = p<sub>1</sub><sup>s</sup> · p<sub>2</sub><sup>s</sup> · … · p<sub>n</sub><sup>s</sup> 。类似地，令 a<sub>2</sub> 为下 n 个质数的 s 次方之积，令 a<sub>3</sub> 为再下 n 个质数的 s 次方之积，以此类推，一直到令 a<sub>m</sub> 为最后 n 个质数的 s 次方之积。</p>
<p>显然， a<sub>1</sub>, a<sub>2</sub>, …, a<sub>m</sub> 两两互质。根据中国剩余定理，我们能够找到一个 x ，使得 x 除以 a<sub>1</sub> 余 a<sub>1</sub> – 1 ，并且 x 除以 a<sub>2</sub> 余 a<sub>2</sub> – 2 ，等等，一直到 x 除以 a<sub>m</sub> 余 a<sub>m</sub> – m 。于是， x + 1, x + 2, …, x + m 分别能被 a<sub>1</sub>, a<sub>2</sub>, …, a<sub>m</sub> 整除，这 m 个连续正整数就满足要求了。</p>
<p> </p>
<p><strong>证明：存在无穷多组不同的正整数 x 、 y 、 z ，使得 x(x + 1), y(y + 1), z(z + 1) 构成等差数列。</strong></p>
<p>令 y = 5x + 2， z = 7x + 3 ，于是我们有</p>
<ul>
<li>x(x + 1) = x<sup>2</sup> + x</li>
<li>y(y + 1) = 25x<sup>2</sup> + 25x + 6</li>
<li>z(z + 1) = 49x<sup>2</sup> + 49x + 12</li>
</ul>
<p>它们构成了一个公差为 24x<sup>2</sup> + 24x + 6 的等差数列。</p>
<p>有趣的是，如果进一步问，是否能让 x(x + 1), y(y + 1), z(z + 1), w(w + 1) 构成一个等差数列，答案就是否定的了。这个证明比较复杂，这里略去。</p>
<p> </p>
<p><strong>给出一个无限长的递增等差数列，使得里面的所有项都不能表示为两个质数之和。</strong></p>
<p>数列 11, 17, 23, 29, … 即符合要求。这些数都是形如 6k + 5 的数。如果 6k + 5 = p + q ，考虑到 6k + 5 是一个奇数，因而 p 和 q 必然有一个是偶数。无妨假设 p 是偶数，如果它又是质数的话，那么 p = 2 。于是， q = 6k + 3 将会成为 3 的倍数。</p>
<p>借助这个思路，我们还能构造一个无限长的递增等差数列，使得里面的所有项都既不能表示为两个质数之和，也不能表示为两个质数之差。例如，数列 37, 67, 97, 127, … 即符合要求。这些数都是形如 30k + 7 的数。如果 30k + 7 = p + q ，考虑到 30k + 7 是一个奇数，因而 p 和 q 必然有一个是偶数。无妨假设 p 是偶数，如果它又是质数的话，那么 p = 2 。于是， q = 30k + 5 将会成为 5 的倍数。类似地，如果 30k + 7 = p – q ，那么 q 必然等于 2 ，于是 p = 30k + 9 将会成为 3 的倍数。</p>
<p> </p>
<p><strong>给出一个无限长的递增等差数列，使得里面不含任何一个 Fibonacci 数。</strong></p>
<p>数列 4, 12, 20, 28, 36, … 符合要求。这些数都是除以 8 余 4 的数，而我们一会儿将会看到，任何一个 Fibonacci 数除以 8 都不可能余 4 。为了计算 a + b 除以 8 的余数，我们可以把 a 替换成它除以 8 的余数，把 b 也替换成它除以 8 的余数，再计算两者相加除以 8 的余数即可。例如， 23 除以 8 的余数是 7 ， 67 除以 8 的余数是 3 ，因而 23 + 67 除以 8 的余数就等于 7 + 3 除以 8 的余数，也就是 2 。根据这个原理，我们很容易算出 Fibonacci 数列各项除以 8 的余数：</p>
<p class="indent">1, 1, 2, 3, 5, 0, 5, 5, 2, 7, 1, 0, 1, 1, …</p>
<p>第 13 项和第 14 项除以 8 的余数又变回了 1 和 1 ，而下一项除以 8 的余数完全取决于前两项除以 8 的余数，因而后面所有 Fibonacci 数除以 8 的余数就会发生循环。这就说明了，一个 Fibonacci 数除以 8 的余数只可能是 0, 1, 2, 3, 5, 7 ，不可能是 4 。因此，由所有除以 8 余 4 的数构成的等差数列里，一定不会含有任何一个 Fibonacci 数。</p>
<p>用类似的方法可以说明，对于所有小于 8 的正整数 m ， Fibonacci 数除以 m 的余数都可以取遍 0, 1, 2, …, m – 1 所有的可能。因而，如果一个无限长的递增等差数列不含任何一个 Fibonacci 数，它的公差至少是 8 。</p>
<p> </p>
<p><strong>证明：对于任意一个无限长的递增等差数列，我们都能找出任意长的一段连续项，使得它们都是合数。</strong></p>
<p>假设这个等差数列是 a + b, 2a + b, 3a + b, … 。假设 n 是一个足够大的正整数。任取 n 个大于 a 的质数 p<sub>1</sub>, p<sub>2</sub>, …, p<sub>n</sub> 。容易看出， a, p<sub>1</sub><sup>2</sup>, p<sub>2</sub><sup>2</sup>, …, p<sub>n</sub><sup>2</sup> 两两互质。根据中国剩余定理，存在一个整数 m ，使得 m 除以 a 的余数为 0， 并且它除以 p<sub>1</sub><sup>2</sup> 的余数为 p<sub>1</sub><sup>2</sup> – a – b ，除以 p<sub>2</sub><sup>2</sup> 的余数为 p<sub>2</sub><sup>2</sup> – 2a – b ，除以 p<sub>3</sub><sup>2</sup> 的余数为 p<sub>3</sub><sup>2</sup> – 3a – b ，以此类推。于是， m + a + b, m + 2a + b, m + 3a + b, …, m + n · a + b 就是等差数列的连续 n 项，并且由于第 i 项能被 p<sub>i</sub><sup>2</sup> 整除，因而这里面的每一项都是合数。</p>
<p> </p>
<p><strong>证明：存在任意长的递增等差数列，使得里面的任意两项都是互质的。</strong></p>
<p>假设 m 为某个足够大的正整数。于是， m! + 1, 2 · m! + 1, 3 · m! + 1, …, m · m! + 1 就成为了一个含有 m 项的公差为 m! 的等差数列。这里面的任意两项都是互质的。如果对于某两个不超过 m 的正整数 k 和 l ， k · m! + 1 和 l · m! + 1 都是 d 的倍数（无妨假设 k &lt; l ），那么 l · (k · m! + 1) – k · (l · m! + 1) = l – k 也应该是 d 的倍数，这说明 d ≤ l – k &lt; m ，因而 d 能整除 m! 。但是 d 也能整除 k · m! + 1 ，因而 d = 1 。</p>
<p> </p>
<p><strong>证明：存在任意长的递增等差数列，使得里面的每一项都是乘方数。这里，“乘方数”的意思是形如 n<sup>k</sup> 的数，其中 n 、 k 都是正整数，且 k &gt; 1 。</strong></p>
<p>假设 p<sub>1</sub>, p<sub>2</sub>, …, p<sub>s</sub> 是任意 s 个不同的质数。根据中国剩余定理，对于每一个不超过 s 的正整数 t ，我们都能找到一个大整数 a<sub>t</sub> ，使得 a<sub>t</sub> 除以 p<sub>t</sub> 余 p<sub>t</sub> – 1 ，并且除以其他 s – 1 个质数都余 0 。现在，令 Q = 1<sup>a<sub>1</sub></sup> · 2<sup>a<sub>2</sub></sup> · … · s<sup>a<sub>s</sub></sup> ，那么 Q, 2 · Q, 3 · Q, …, s · Q 就是一个等差数列。我们来证明，这个等差数列满足要求。对于这个等差数列中的任意一项 t · Q ，我们都有 t · Q = 1<sup>a<sub>1</sub></sup> · 2<sup>a<sub>2</sub></sup> · … · t<sup>a<sub>t</sub> + 1</sup> · … · s<sup>a<sub>s</sub></sup> ，根据 a<sub>1</sub>, …, a<sub>s</sub> 的构造方法可知，这里面的每一个指数都是 p<sub>t</sub> 的倍数。因而， t · Q 可以写成某个数的 p<sub>t</sub> 次方。由于 s 的值可以达到任意大，因而满足要求的等差数列也可以达到任意长。</p>
<p>那么，是否存在无限长的递增等差数列，使得里面的每一项都是乘方数呢？这回，答案就是否定的了。我们可以证明，在任何一个无限长的递增等差数列 a + b, 2a + b, 3a + b, … 中，总存在一个不是乘方数的数。首先，找出一个比 a + b 更大的质数 p 。由于 a 和 p<sup>2</sup> 互质，因此根据中国剩余定理，我们一定能够找到一个数 m ，使得 m 除以 a 余 0 ，并且除以 p<sup>2</sup> 余 1 。令 k = (p – b) · m / a 。由于 m 除以 a 余 0 ，因此 k 是个整数；由于 p &gt; b ，因此 k 是一个正整数。于是 k · a + b = (p – b) · m + b = (p – b) · m – (p – b) + p = (p – b)(m – 1) + p 。由于 m 除以 p<sup>2</sup> 余 1 ，因而最后这个式子的前一项是 p<sup>2</sup> 的倍数；但最后这个式子的后一项却只是 p 的倍数，因而两者之和能被 p 整除，却不能被 p<sup>2</sup> 整除。这说明，它不能表示成任何一个数的 1 次以上的乘方。</p>
<p> </p>
<p><strong>是否存在四个连续正整数，使得它们都是乘方数？这里，“乘方数”的意思和上题一样，即形如 n<sup>k</sup> 的数，其中 n 、 k 都是正整数，且 k &gt; 1 。</strong></p>
<p>不存在。在任意四个连续正整数中，必然有一个数是形如 4k + 2 的数。这样的数能被 2 整除，却不能被 4 整除，因而永远不可能是一个乘方数。</p>
<p>那么，是否存在三个连续正整数，使得每一个数都是乘方数呢？ 1962 年， A. Mąkowski 证明了，这也是不可能的，不过证明过程就没那么简单了。那么，是否存在两个相邻的正整数，使得它们都是乘方数呢？这次就有了，例如 8 = 2<sup>3</sup>, 9 = 3<sup>2</sup> 。1844 年， Eugène Catalan 猜想，除了 8 和 9 以外，没有别的相邻乘方数了。 2002 年，这个猜想终于被 Preda Mihăilescu 证明。</p>
<p> </p>
<p><strong>31, 331, 3331, 33331 都是质数。难道数列 31, 331, 3331, 33331, … 中的所有数都是质数吗？其实并不是这样。证明：数列 31, 331, 3331, 33331, … 中含有无穷多个合数。</strong></p>
<p>数列的通项公式是 (10<sup>n + 1</sup> – 7) / 3 。容易验证， 10<sup>1</sup>, 10<sup>2</sup>, …, 10<sup>17</sup> 除以 17 的余数分别是</p>
<p class="indent">10, 15, 14, 4, 6, 9, 5, 16, 7, 2, 3, 13, 11, 8, 12, 1, 10</p>
<p>其中 10<sup>17</sup> 和 10<sup>1</sup> 除以 17 的余数相同，因此再往后， 10 的乘方除以 17 的余数便会开始循环，循环节的长度为 16 。由于 10<sup>9</sup> 除以 17 余 7 ，这就说明所有的 10<sup>16k + 9</sup> 除以 17 都余 7 。因此，所有的 (10<sup>16k + 9</sup> – 7) / 3 都是 17 的倍数。</p>
<p>事实上， 31, 331, 3331, 33331, 333331, 3333331, 33333331 都是质数，首次出现的合数为 333333331 = 17 × 19607843 ，这正是 k = 0 时 (10<sup>16k + 9</sup> – 7) / 3 的值。我们自然会问，除了所有的 (10<sup>16k + 9</sup> – 7) / 3 以外，数列 31, 331, 3331, 33331, … 当中还有别的合数吗？答案是，确实还有。用和刚才类似的方法可以推出，所有的 (10<sup>18k + 12</sup> – 7) / 3 都能被 19 整除，例如 (10<sup>12</sup> – 7) / 3 = 333333333331 = 19 × 83 × 211371803 。其实，数列 31, 331, 3331, 33331, … 里的质数没那么多。在前 100 项中，只有第 1, 2, 3, 4, 5, 6, 7, 17, 39, 49, 59, 77, 100 项是质数。</p>
<p> </p>
<p><strong>247 的各位数字之和是 13 ，正好 247 也是 13 的倍数。 399 的各位数字之和是 21 ，正好 399 也是 21 的倍数。是否对于任意正整数 s ，我们都能找到一个正整数 N ，使得 N 的各位数字之和为 s ，并且它也正好是 s 的整倍数？</strong></p>
<p>答案是肯定的。把 s 表示成 2<sup>α</sup> · 5<sup>β</sup> · t 的形式，其中 t 里面不再含有因数 2 和 5 。根据 Euler 定理， 10<sup>φ(t)</sup> 除以 t 余 1 。现在，令 N = 10<sup>α + β</sup> · (10<sup>φ(t)</sup> + 10<sup>2 · φ(t)</sup> + … + 10<sup>s · φ(t)</sup>) ，则 N 就是一个满足要求的数。首先， N 的十进制表达中含有 s 个数字 1 ，其余的数字全是 0 ，因而它的各位数字之和确实是 s 。另外，上式括号里一共有 s 项，其中每一项除以 t 都余 1 ，因此它们的和除以 t 就余 s ；而 s 是 t 的整倍数，除以 t 余 s 也就相当于是除以 t 余 0 了。这说明，上式括号的计算结果是 t 的整倍数。再加上 10<sup>α + β</sup> 显然是 2<sup>α</sup> · 5<sup>β</sup> 的整倍数，于是便得到了 N 是 s 的整倍数。</p>
<p> </p>
<p><strong>证明：当 n 趋于无穷时， 2<sup>n</sup> 的各位数字之和也将随之趋于无穷。</strong></p>
<p>下面这个证明是由 Andrzej Schinzel 给出的。我们先来定义一个数列 a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, … ，其中 a<sub>0</sub> = 0 ，并且 a<sub>i + 1</sub> 为最小的使得 2<sup>a<sub>i + 1</sub></sup> 大于 10<sup>a<sub>i</sub></sup> 的正整数。在所有 2 的乘方中，最小的比 10<sup>0</sup> 更大的是 2 的 1 次方，因此 a<sub>1</sub> = 1 ；在所有 2 的乘方中，最小的比 10<sup>1</sup> 更大的是 2 的 4 次方，因此 a<sub>2</sub> = 4 ；在所有 2 的乘方中，最小的比 10<sup>4</sup> 更大的是 2 的 14 次方，因此 a<sub>3</sub> = 14 ……容易看出， a<sub>0</sub> &lt; a<sub>1</sub> &lt; a<sub>2</sub> &lt; … 。</p>
<p>下面我们来证明，如果 n 大于等于某个 a<sub>k</sub> ，那么 2<sup>n</sup> 的右起第 a<sub>k – 1</sub> + 1 到第 a<sub>k</sub> 位里至少有一个非 0 数字。不妨让我们以 k = 3 为例来说明这一点，你会发现下面的推理过程适用于一切其他的 k 。当 k = 3 时，我们要证明的就是，如果 n ≥ a<sub>3</sub> = 14 ，那么 2<sup>n</sup> 的右起第 a<sub>2</sub> + 1 = 5 位到第 a<sub>3</sub> = 14 位里至少有一个非 0 数字。反证，假设 2<sup>n</sup> 等于 abc0000000000defg ，其中 a 、 b 、 c 、 d 、 e 、 f 、 g 都是一位数字。注意到 2 的任何乘方的个位都不可能是 0 ，这说明 g 肯定不为 0 。由于 2<sup>14</sup> 可以整除 10<sup>14</sup> ，因而 2<sup>14</sup> 可以整除 abc00000000000000 ；由于 n 大于等于 14 ，因而 2<sup>14</sup> 也可以整除 2<sup>n</sup> = abc0000000000defg 。所以， 2<sup>14</sup> 必然能整除 abc0000000000defg – abc00000000000000 = defg 。虽然 d 、 e 、 f 都可能为 0 ，但我们刚才说过， g 是肯定不为 0 的，因而 defg 是一个最多 4 位的正整数。但是，2<sup>14</sup> 能整除一个最多 4 位的正整数，这是不可能的，因为根据数列 a<sub>i</sub> 的定义， 2<sup>14</sup> &gt; 10<sup>4</sup> ，也就是说 2<sup>14</sup> 至少有 5 位数，它不可能整除一个比自己小的正整数。</p>
<p>所以，如果 n 大于等于某个 a<sub>k</sub> ，那么 2<sup>n</sup> 的右起第 a<sub>k – 1</sub> + 1 到第 a<sub>k</sub> 位里至少有一个非 0 数字。事实上，如果 n 大于等于某个 a<sub>k</sub> ，那它也大于 a<sub>1</sub>, a<sub>2</sub>, …, a<sub>k – 1</sub> ，因而对于所有不超过 k 的正整数 i 来说， 2<sup>n</sup> 的右起第 a<sub>i – 1</sub> + 1 到第 a<sub>i</sub> 位里都含有至少一个非 0 数字。可见， 2<sup>n</sup> 里至少有 k 个非 0 数字，即它的各位数字之和至少为 k 。这表明，随着 n 的增加， 2<sup>n</sup> 的各位数字之和可以达到任意大。我们的结论也就证到了。</p>
<p>注意， 2<sup>n</sup> 的各位数字之和趋于无穷大，并不意味着 2<sup>n</sup> 的各位数字之和是不断递增的。当 n = 1, 2, .., 20 时， 2<sup>n</sup> 的各位数字之和为</p>
<p class="indent">2, 4, 8, 7, 5, 10, 11, 13, 8, 7, 14, 19, 20, 22, 26, 25, 14, 19, 29, 31</p>
<p>可以看到，下一项比上一项更小的现象时有发生。</p>
<p> </p>
<p><strong>证明：对于任意两个不同的正整数 a 、 b ，我们都能找到无穷多个正整数 n ，使得 a + n 和 b + n 互质。</strong></p>
<p>不妨假设 a &lt; b 。令 n = (b – a)k + 1 – a 。只要 k 的值足够大， n 都是正整数。现在，假设 a + n 和 b + n 都是 d 的倍数，那么 (b + n) – (a + n) = b – a 必然也是 d 的倍数。同时，注意到 a + n = (b – a)k + 1 是 d 的倍数，因此 1 一定是 d 的倍数，说明 d 只能等于 1 。</p>
<p>大家肯定会进一步追问，那是否对于任意三个不同的正整数 a 、 b 、 c ，我们都能找到无穷多个正整数 n ，使得 a + n 、 b + n 、 c + n 两两互质呢？答案是，这也是能办到的。不过，这个证明比较复杂，我们就略去了。</p>
<p>那么，是否对于任意四个不同的正整数 a 、 b 、 c 、 d ，我们都能找到无穷多个正整数 n ，使得 a + n 、 b + n 、 c + n 、 d + n 两两互质呢？这就不行了。事实上，我们能够找到一组特殊的 (a, b, c, d) ，使得满足要求的 n 一个也没有。比方说 (a, b, c, d) = (1, 2, 3, 4) 。这样一来，如果 n 是奇数，那么 a + n 和 c + n 显然不互质；如果 n 是偶数，那么 b + n 和 d + n 显然不互质。</p>
<p> </p>
<p><strong>证明：任意一个大于 6 的正整数都可以表示成两个互质的数的和。</strong></p>
<p>如果 n 是一个大于 6 的奇数，那么把 n 拆成 2 和 n – 2 显然符合要求。这是因为， 2 和任何一个奇数都是互质的。接下来，我们分别考虑 n = 4k 和 n = 4k + 2 两种情况。当 n = 4k 时，把 n 拆成 2k – 1 和 2k + 1 符合要求。这是因为，如果 2k – 1 和 2k + 1 都是 d 的倍数，则 (2k + 1) – (2k – 1) = 2 也是 d 的倍数，但 2k – 1 和 2k + 1 都是奇数，因而 d = 1 。当 n = 4k + 2 时，把 n 拆成 2k – 1 和 2k + 3 显然符合要求。这是因为，如果 2k – 1 和 2k + 3 都是 d 的倍数，那么 (2k + 3) – (2k – 1) = 4 也是 d 的倍数，但 2k – 1 和 2k + 3 都是奇数，因而 d = 1 。</p>
<p>我们可以用类似的分类讨论的方法来证明，任意大于 17 的正整数都可以表示成三个两两互质的数的和。我们把 n 为偶数的情况分为 n = 6k, n = 6k + 2 和 n = 6k + 4 这三类，它们都有自己的拆分方案：</p>
<ul>
<li>6k = 2 + 3 + (6(k – 1) + 1)</li>
<li>6k + 2 = 3 + 4 + (6(k – 1) + 1)</li>
<li>6k + 4 = 2 + 3 + (6k – 1)</li>
</ul>
<p>当 n 为奇数时，我们分 n = 12k + 1, n = 12k + 3, n = 12k + 5, n = 12k + 7, n = 12k + 9, n = 12k + 11 六类情况讨论。</p>
<ul>
<li>12k + 1 = (6(k – 1) – 1) + (6(k – 1) + 5) + 9</li>
<li>12k + 3 = (6k – 1) + (6k + 1) + 3</li>
<li>12k + 5 = (6k – 5) + (6k + 1) + 9</li>
<li>12k + 7 = (6k + 5) + (6k – 1) + 3</li>
<li>12k + 9 = (6k – 1) + (6k + 1) + 9</li>
<li>12k + 11 = (6(k + 1) – 5) + (6(k + 1) + 1) + 3</li>
</ul>
<p>题目给出的结论还有一些有趣的推论。例如，我们可以据此证明，若用 p<sub>k</sub> 表示第 k 个质数，则对于任意 k ≥ 3 都有 p<sub>k + 1</sub> + p<sub>k + 2</sub> ≤ p<sub>1</sub> · p<sub>2</sub> · … · p<sub>k</sub> 。由于 k ≥ 3 ，因而 p<sub>1</sub> · p<sub>2</sub> · … · p<sub>k</sub> ≥ 2 · 3 · 5 &gt; 6 ，根据题目给出的结论，它可以表示成两个互质的数 a 和 b 之和。 a 和 a + b 的任何一个公约数也一定是 a 和 b 的公约数，但 a 和 b 没有大于 1 的公约数，说明 a 和 a + b 也没有大于 1 的公约数。这说明， a 和 a + b 也是互质的，即 a 和 p<sub>1</sub> · p<sub>2</sub> · … · p<sub>k</sub> 是互质的。</p>
<p>令 p 为 a 的任意一个质因数，令 q 为 b 的任意一个质因数。由于 a 和 b 互质，它们拥有完全不同的质因数，因此 p ≠ q 。无妨假设 p &lt; q 。由于 a 和 p<sub>1</sub> · p<sub>2</sub> · … · p<sub>k</sub> 互质，因此 p ≥ p<sub>k + 1</sub> ；由于 p &lt; q ，因此 q ≥ p<sub>k + 2</sub> 。于是，我们有</p>
<p class="indent">p<sub>k + 1</sub> + p<sub>k + 2</sub> ≤ p + q ≤ a + b = p<sub>1</sub> · p<sub>2</sub> · … · p<sub>k</sub></p>
<p> </p>
<p><strong>证明：存在无穷多个正整数满足，它可以用至少两种不同的方法表示成四个正整数的平方和。</strong></p>
<p>可以验证， (t – 8)<sup>2</sup> + (t – 1)<sup>2</sup> + (t + 1)<sup>2</sup> + (t + 8)<sup>2</sup> = (t – 7)<sup>2</sup> + (t – 4)<sup>2</sup> + (t + 4)<sup>2</sup> + (t + 7)<sup>2</sup> 恒成立，因而当 t &gt; 8 时，每一个 t 都对应一个满足要求的正整数，结论便证到了。</p>
<p>我们还可以证明，存在无穷多个正整数满足，它可以用至少两种不同的方法表示成四个正整数的<strong>立方</strong>和。可以验证， (t – 8)<sup>3</sup> + (t – 1)<sup>3</sup> + (t + 1)<sup>3</sup> + (t + 8)<sup>3</sup> = (t – 7)<sup>3</sup> + (t – 4)<sup>3</sup> + (t + 4)<sup>3</sup> + (t + 7)<sup>3</sup> 恒成立，因而当 t &gt; 8 时，每一个 t 都对应一个满足要求的正整数，结论便证到了。</p>
<p> </p>
<p><strong>证明：任意一个整数都可以用无穷多种方法表示成五个整数的立方和。</strong></p>
<p>首先，可以验证， 6t = (t + 1)<sup>3</sup> + (t – 1)<sup>3</sup> + (-t)<sup>3</sup> + (-t)<sup>3</sup> 。这说明，任何一个 6 的倍数都可以表示成四个立方数之和。</p>
<p>现在，把任意一个整数写成 6k + r 的形式，其中 r 为 0 、 1 、 2 、 3 、 4 、 5 之一。你会发现，对于任意一个整数 n 来说， 6k + r – (6n + r)<sup>3</sup> 都是 6 的倍数。这是因为</p>
<p class="indent">6k + r – (6n + r)<sup>3</sup> = 6k + r – 216 · n<sup>3</sup> – 108 · n<sup>2</sup> · r – 18 · n · r<sup>2</sup> – r<sup>3</sup></p>
<p>这里面除了 r 和 – r<sup>3</sup> 以外，其他所有项都是 6 的倍数。而 r – r<sup>3</sup> = – (r – 1) · r · (r + 1) 显然也是 6 的倍数—— r – 1, r, r + 1 相当于三个连续整数，其中至少有一个是 2 的倍数，且必然有一个是 3 的倍数，因而它们的乘积也就是 6 的倍数。</p>
<p>好了，既然 6k + r – (6n + r)<sup>3</sup> 总是 6 的倍数，那我们就可以把 6k + r 拆成</p>
<p class="indent">(6k + r – (6n + r)<sup>3</sup>) + (6n + r)<sup>3</sup></p>
<p>其中前者可以表示成四个立方数之和，后者本身就是一个立方数。这样，我们就成功地把 6k + r 表示成了五个立方数之和。每取一个不同的 n 都会得到一种不同的表示方法，因而表示方法也就有无穷多种。</p>
<p> </p>
<p><strong>证明：对于任意一个整数 k ，我们都有无穷多种方法把它表示成 ± 1<sup>2</sup> ± 2<sup>2</sup> ± 3<sup>2</sup> ± … ± m<sup>2</sup> 的形式。</strong></p>
<p>显然，我们只需要考虑所有的非负整数 k 即可，因为把所有的符号全都反过来，就能把正数 k 的表达方法转换成负数 k 的表达方法。首先我们来证明，任何 k ≥ 0 都有至少一种表示方法。容易验证：</p>
<ul>
<li>0 = 1<sup>2</sup> + 2<sup>2</sup> – 3<sup>2</sup> + 4<sup>2</sup> – 5<sup>2</sup> – 6<sup>2</sup> + 7<sup>2</sup>
</li>
<li>1 = 1<sup>2</sup>
</li>
<li>2 = – 1<sup>2</sup> – 2<sup>2</sup> – 3<sup>2</sup> + 4<sup>2</sup>
</li>
<li>3 = – 1<sup>2</sup> + 2<sup>2</sup>
</li>
</ul>
<p>由于对于任意 m 都有</p>
<p class="indent">(m + 1)<sup>2</sup> – (m + 2)<sup>2</sup> – (m + 3)<sup>2</sup> + (m + 4)<sup>2</sup> = 4</p>
<p>因而对于任何非负整数 k 的任何一种表达方法 ± 1<sup>2</sup> ± 2<sup>2</sup> ± 3<sup>2</sup> ± … ± m<sup>2</sup> ，我们都有</p>
<p class="indent">k + 4 = ± 1<sup>2</sup> ± 2<sup>2</sup> ± 3<sup>2</sup> ± … ± m<sup>2</sup> + (m + 1)<sup>2</sup> – (m + 2)<sup>2</sup> – (m + 3)<sup>2</sup> + (m + 4)<sup>2</sup></p>
<p>这意味着，只要 k 有表达方法， k + 4 就有表达方法。既然 k = 0, 1, 2, 3 时都有表达方法，那么对于一切的非负整数 k ，表达方法也都存在了。</p>
<p>因此，我们也就证明了，对于任意一切整数 k ，表达方法都是存在的。但是，为什么表达方法有无穷多种呢？只需要注意到</p>
<p class="indent">(m + 1)<sup>2</sup> – (m + 2)<sup>2</sup> – (m + 3)<sup>2</sup> + (m + 4)<sup>2</sup> – (m + 5)<sup>2</sup> + (m + 6)<sup>2</sup> + (m + 7)<sup>2</sup> – (m + 8)<sup>2</sup> = 0</p>
<p>所以我们可以在任何整数 k 的任何一种表达方法后面添加 8 项，然后再添上 8 项，然后再添上 8 项……从而得到无穷多种表达方法。</p>
<p> </p>
<p><strong>证明：除了 (2, 3) 、 (4, 3) 、 (8, 9) 三种情况以外， 2 的某个乘方和 3 的某个乘方不可能成为两个相邻数。</strong></p>
<p>首先考虑 2<sup>m</sup> = 3<sup>n</sup> + 1 的情况。容易看出，随着 n 的增加， 3<sup>n</sup> 除以 8 的余数是按照 1, 3, 1, 3, 1, 3, … 的规律循环的。因而 3<sup>n</sup> + 1 除以 8 的余数是按照 2, 4, 2, 4, 2, 4, … 的规律循环的。这说明，不管正整数 n 为多少， 3<sup>n</sup> + 1 都不可能被 8 整除。如果 2<sup>m</sup> = 3<sup>n</sup> + 1 ，则 2<sup>m</sup> 也不能被 8 整除，这说明 m ≤ 2 。检验可知 (m, n) = (2, 1) 是唯一可能的情况。</p>
<p>接下来考虑 2<sup>m</sup> = 3<sup>n</sup> – 1 的情况。借助之前讨论的结果可以看出， 3<sup>n</sup> – 1 除以 8 的余数是按照 0, 2, 0, 2, 0, 2, … 的规律循环的，因而当 n 是奇数时， 3<sup>n</sup> – 1 不能被 8 整除。如果 2<sup>m</sup> = 3<sup>n</sup> – 1 ，则 2<sup>m</sup> 也不能被 8 整除，这说明 m ≤ 2 。检验可知 (m, n) = (1, 1) 是唯一可能的情况。那么，如果 n 是偶数呢？刚才的方法就不管用了。不过，我们还有别的招。不妨假设 n = 2k ，于是 2<sup>m</sup> = 3<sup>n</sup> – 1 = 3<sup>2k</sup> – 1 = (3<sup>k</sup> – 1)(3<sup>k</sup> + 1) ，这说明 3<sup>k</sup> – 1 和 3<sup>k</sup> + 1 都只含因数 2 ，或者说 3<sup>k</sup> – 1 和 3<sup>k</sup> + 1 都是 2 的整数次幂。这只有一种可能： 3<sup>k</sup> – 1 = 2 ， 3<sup>k</sup> + 1 = 4 。据此，我们得到了该问题的最后一组解： (m, n) = (3, 2) 。</p>
<p> </p>
<p><strong>证明：在任意三个大于 7 的连续正整数之中，一定有至少一个数，它包含至少两种不同的质因数。</strong></p>
<p>首先，任何一个形如 6k 的数都必然包含至少两种不同的质因数。其次，当 k &gt; 1 时， 6k + 2 和 6k + 3 不可能都只包含一种质因数。这是因为， 6k + 2 是 2 的倍数，如果它只包含一种质因数，则必是 2 的某个乘方； 6k + 3 是 3 的倍数，如果它只包含一种质因数，则必是 3 的某个乘方；但根据上题的结论，除去少数数值很小的情况以外， 2 的某个乘方和 3 的某个乘方都不可能成为两个相邻整数。类似地，当 k ≥ 1 时， 6k + 3 和 6k + 4 也不可能都只包含一种质因数。这是因为，前者必然是 3 的某个乘方，后者必然是 2 的某个乘方，但根据上题的结论，这是不可能的。</p>
<p>然而，在任意三个大于 7 的连续正整数当中，要么包含形如 6k 的数，要么包含形如 6k + 2 和 6k + 3 的两个相邻数（其中 k &gt; 1 ），要么包含形如 6k + 3 和 6k + 4 的两个相邻数（其中 k ≥ 1 ）。所以，这里面至少有一个数，它包含至少两种不同的质因数。</p>
<p> </p>
<p><strong>证明：存在无穷多对不同的正整数 (m, n) ，使得 m 和 n 拥有完全相同的质因数（仅每个质因数的次数可能有所不同），并且 m + 1 和 n + 1 也拥有完全相同的质因数（仅每个质因数的次数可能有所不同）。</strong></p>
<p>对于任意大于 1 的正整数 k ， (m, n) = (2<sup>k</sup> – 2, 2<sup>k</sup>(2<sup>k</sup> – 2)) 显然都满足要求。 m 和 n 分解质因数之后的唯一差异就是， n 比 m 多了一堆 2 ，而 2 本来就是两者都已经有了的质因数。另外， m + 1 = 2<sup>k</sup> – 1 ， n + 1 = 2<sup>k</sup>(2<sup>k</sup> – 2) + 1 = (2<sup>k</sup> – 1)<sup>2</sup> ，两者显然也拥有完全相同的质因数。</p>
<p>Paul Erdős 曾问，是否还有别的满足要求的 (m, n) 。答案是肯定的，例如 (75, 1215) 满足要求。 75 = 3 × 5<sup>2</sup> ， 1215 = 3<sup>5</sup> × 5 ； 76 = 2<sup>2</sup> × 19 ， 1216 = 2<sup>6</sup> × 19 。</p>
<p> </p>
<p><strong>找出所有的正整数组 (x, y, z) ，使得分数 x / y 、 y / z 、 z / x 都是最简分数，并且它们的和是一个正整数。</strong></p>
<p>假设 x / y + y / z + z / x = m ，其中 m 是一个正整数。等式可以变为 x<sup>2</sup>z + y<sup>2</sup>x + z<sup>2</sup>y = mxyz 。等号左边的后面两项都是 y 的倍数，等号右边的结果也是 y 的倍数，这说明等号左边的第一项也必然是 y 的倍数。也就是说， x<sup>2</sup>z 是 y 的倍数。类似地， y<sup>2</sup>x 是 z 的倍数， z<sup>2</sup>y 是 x 的倍数。但是，分数 x / y 、 y / z 、 z / x 都是最简分数，这说明 x 、 y 、 z 两两互质，因而 x<sup>2</sup>z 和 y 是互质的， y<sup>2</sup>x 和 z 是互质的， z<sup>2</sup>y 和 x 是互质的。由此可知 y = 1, z = 1, x = 1 ，因而 1 / 1 + 1 / 1 + 1 / 1 = 3 是这个问题的唯一解。</p>
<p> </p>
<p><strong>证明： x / y + y / z + z / x = 1 和 x / y + y / z + z / x = 2 都没有正整数解。</strong></p>
<p>第一个问题很简单。 x / y 、 y / z 和 z / x 的乘积为 1 ，说明三者必有一个大于等于 1 ，因而 x / y + y / z + z / x &gt; 1 。第二个问题则稍微复杂一些。由于任意三个正数的算术平均数一定大于等于它们的几何平均数，因而 (x / y + y / z + z / x) / 3 ≥ ((x / y) · (y / z) · (z / x))<sup>1/3</sup> = 1 ，这说明 x / y + y / z + z / x ≥ 3 。</p>
<p>容易看出， x / y + y / z + z / x = 3 是有正整数解的，例如 x = y = z =  1 。 x / y + y / z + z / x = 5 的其中一组正整数解为 x = 1, y = 2, z = 4 。 x / y + y / z + z / x = 6 的其中一组正整数解为 x = 2, y = 12, z = 9 。如果所涉及的数更大一些，找出相应的解就不太容易了。 Woody Dudley 发现 x / y + y / z + z / x = 41 是有正整数解的，其中一组正整数解为 x = 350, y = 196, z = 5 。究竟对于哪些正整数 n ，方程 x / y + y / z + z / x = n 有正整数解，这是一个非常困难的问题。</p>
<p> </p>
<p><strong>证明：对于任意正整数 s ≥ 3 ，方程 1 / x<sub>1</sub> + 1 / x<sub>2</sub> + … + 1 / x<sub>s</sub> = 1 都有满足 x<sub>1</sub> &lt; x<sub>2</sub> &lt; … &lt; x<sub>s</sub> 的正整数解，且随着 s 的增加，满足要求的解的数量也随之增加。</strong></p>
<p>当 s = 3 时， x<sub>1</sub> = 2, x<sub>2</sub> = 3, x<sub>3</sub> = 6 是一组满足要求的解。另外，如果对于某个 s ≥ 3 ， (x<sub>1</sub>, x<sub>2</sub>, …, x<sub>s</sub>) 是一组满足要求的解，那么 x<sub>1</sub> 必然大于 1 。于是，我们有 </p>
<p class="indent">  1 / 2 + 1 / (2x<sub>1</sub>) + 1 / (2x<sub>2</sub>) + … + 1 / (2x<sub>s</sub>)<br>
= 1 / 2 + (1 / 2) · (1 / x<sub>1</sub> + 1 / x<sub>2</sub> + … + 1 / x<sub>s</sub>)<br>
= 1 / 2 + (1 / 2) · 1<br>
= 1</p>
<p>并且 2 &lt; 2x<sub>1</sub> &lt; 2x<sub>2</sub> &lt; … &lt; 2x<sub>s</sub> 。它们就成为了 s 增加 1 之后的一组解。这就立即说明了，随着 s 的增加，满足要求的解的个数不会减少，至少会保持不变。但是，我们需要证明的是，随着 s 的增加，满足要求的解的个数会严格增加。怎么办呢？</p>
<p>很简单。如果对于某个 s ≥ 3 ， (x<sub>1</sub>, x<sub>2</sub>, …, x<sub>s</sub>) 是一组满足要求的解。于是，我们有 </p>
<p class="indent">  1 / 2 + 1 / 3 + 1 / (6x<sub>1</sub>) + 1 / (6x<sub>2</sub>) + … + 1 / (6x<sub>s</sub>)<br>
= 5 / 6 + (1 / 6) · (1 / x<sub>1</sub> + 1 / x<sub>2</sub> + … + 1 / x<sub>s</sub>)<br>
= 5 / 6 + (1 / 6) · 1<br>
= 1</p>
<p>并且 2 &lt; 3 &lt; 6x<sub>1</sub> &lt; 6x<sub>2</sub> &lt; … &lt; 6x<sub>s</sub> 。它们就成为了 s 增加 2 之后的一组解。而且，用这种方法生成的解肯定和用前一种方法生成的解是不同的——前一种方法中，所有的分母都是偶数；但在这里的方法中，第二项的分母是 3 。于是， s = 5 的解数至少等于 s = 4 的解数加上 s = 3 的解数，s = 6 的解数至少等于 s = 5 的解数加上 s = 4 的解数……因而，随着 s 的增加，解的数量一定是严格增加的。</p>
<p>且慢！这只能说明， s = 5 时的解数大于 s = 4 时的解数， s = 6 时的解数大于 s = 5 时的解数，等等，但为什么 s = 4 时的解数大于 s = 3 时的解数呢？这一点是刚才的推理覆盖不到的，我们还需要额外证明一下。</p>
<p>首先我们证明，当 s = 3 时， x<sub>1</sub> = 2, x<sub>2</sub> = 3, x<sub>3</sub> = 6 是唯一的一组解。如果 x<sub>1</sub> ≥ 3 ，则 x<sub>2</sub> ≥ 4 ， x<sub>3</sub> ≥ 5 ，于是 1 / x<sub>1</sub> + 1 / x<sub>2</sub> + 1 / x<sub>3</sub> ≤ 1 / 3 + 1 / 4 + 1 / 5 = 47 / 60 &lt; 1 。这说明， x<sub>1</sub> 不能大于等于 3 ，因而只能等于 2 。类似地，由于 1 / 2 + 1 / 4 + 1 / 5 = 19 / 20 &lt; 1 ，这说明 x<sub>2</sub> 不能大于等于 4 ，只能等于 3 。因而，当 s = 3 时， x<sub>1</sub> = 2, x<sub>2</sub> = 3, x<sub>3</sub> = 6 是唯一的一组解。</p>
<p>可以验证，当 s = 4 时，我们至少有以下六组解：</p>
<ul>
<li>1 / 2 + 1 / 3 + 1 / 7 + 1 / 42 = 1</li>
<li>1 / 2 + 1 / 3 + 1 / 8 + 1 / 24 = 1</li>
<li>1 / 2 + 1 / 3 + 1 / 9 + 1 / 18 = 1</li>
<li>1 / 2 + 1 / 3 + 1 / 10 + 1 / 15 = 1</li>
<li>1 / 2 + 1 / 4 + 1 / 5 + 1 / 20 = 1</li>
<li>1 / 2 + 1 / 4 + 1 / 6 + 1 / 12 = 1</li>
</ul>
<p>因此，当 s 从 3 增加到 4 时，解的数量也是严格增加的。</p>
<p> </p>
<p><strong>证明：对于任意正整数 n ，方程 x<sub>1</sub> + x<sub>2</sub> + … + x<sub>n</sub> = x<sub>1</sub> · x<sub>2</sub> · … · x<sub>n</sub> 至少有一组正整数解。</strong></p>
<p>当 n = 1 时，我们有 1 = 1 。当 n = 2 时，我们有 2 + 2 = 2 × 2 。当 n ≥ 3 时， 1 + 1 + … + 1 + 2 + n = 1 × 1 × … × 1 × 2 × n 总成立（等号左右两边各有 n – 2 个 1 ）。</p>
<p>对于某些特定的 n ，有没有可能还有其他的解呢？这里，我们规定 x<sub>1</sub> ≤ x<sub>2</sub> ≤ … ≤ x<sub>n</sub> ，从而排除掉一些本质相同的解。答案是肯定的。例如，当 n = 5 时，除了 1 + 1 + 1 + 2 + 5 = 1 × 1 × 1 × 2 × 5 以外，我们还有以下两组解：</p>
<ul>
<li>1 + 1 + 1 + 3 + 3 = 1 × 1 × 1 × 3 × 3</li>
<li>1 + 1 + 2 + 2 + 2 = 1 × 1 × 2 × 2 × 2</li>
</ul>
<p>因此，当 n = 5 时，方程一共有至少三组正整数解。可以证明，当 n = 5 时，方程确实也只有这三组正整数解。</p>
<p>当 n = 13 时，将会首次出现有四组解的情况：</p>
<ul>
<li>1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 2 + 13 = 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 2 × 13</li>
<li>1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 3 + 7 = 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 3 × 7</li>
<li>1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 4 + 5 = 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 4 × 5</li>
<li>1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 2 + 3 + 3 = 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 2 × 3 × 3</li>
</ul>
<p>由此产生了一个有趣的问题：到了 n 足够大的时候，会不会出现有 5 组解、 6 组解甚至 100 组解的情况？答案仍然是肯定的。首先注意到，(2<sup>a</sup> + 1)(2<sup>b</sup> + 1) = 2<sup>a + b</sup> + 2<sup>a</sup> + 2<sup>b</sup> + 1，它应该等于 2<sup>a + b</sup> – 1 个 1 、一个 2<sup>a</sup> + 1 和一个 2<sup>b</sup> + 1 相加的结果。因此，当 n = 2<sup>200</sup> + 1 时，至少会有这么 100 组解：前面 2<sup>200</sup> – 1 个数都是 1 ，最后两个数是 2 + 1 和 2<sup>199</sup> + 1 ，或者 2<sup>2</sup> + 1 和 2<sup>198</sup> + 1 ，或者 2<sup>3</sup> + 1 和 2<sup>197</sup> + 1 ，一直到 2<sup>100</sup> + 1 和 2<sup>100</sup> + 1 。利用这种思路，我们总能找到适当的 n ，使得满足要求的解的个数达到任意你想要的数目。</p>
<p>另一方面，不管 n 是多少，解的个数都是有限的。我们可以用一种非常简单的方法证明这一点。考虑到这 n 个数当中最大的那个数是 x<sub>n</sub> ，因而我们有</p>
<p class="indent">x<sub>1</sub> · x<sub>2</sub> · … · x<sub>n</sub> = x<sub>1</sub> + x<sub>2</sub> + … + x<sub>n</sub> ≤ n · x<sub>n</sub></p>
<p>这说明 x<sub>1</sub> · x<sub>2</sub> · … · x<sub>n – 1</sub> ≤ n ，进而说明 x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n – 1</sub> 都不能超过 n 。所以， (x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n – 1</sub>) 的取值组合只有有限多种情况。由于每一种情况最多只能对应一个解，因而总的解数就是有限的了。等等，为什么每一种情况最多只能对应一个解呢？假设 x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n – 1</sub> 的值已经确定了，不妨设它们的和为 S ，积为 P ，那么 x<sub>n</sub> 就应该满足方程 S + x<sub>n</sub> = P · x<sub>n</sub> ，于是 x<sub>n</sub> 只能等于 S / (P – 1) 。这是否对应了一个满足要求的解，则取决于 S / (P – 1) 的值是不是正整数，以及它和 x<sub>n – 1</sub> 的大小关系。</p>
<p>让我们用 f(n) 来表示 n 个正整数之和等于它们的乘积有多少种不同的情况。我们已经证明了， f(n) 的值可以达到任意大，但却始终是有限的。但是，我们却很难刻画出关于数列 f(n) 的具体特征。 2002 年，经过一番计算机搜索后， Michael Ecker 作出了这么一个猜测：只有有限多个 n 满足 f(n) = 1 ，它们分别是 2, 3, 4, 6, 24, 114, 174, 444 。这个猜想是否正确，至今仍然未知。</p>
			 ]]></content>
<pubDate>2015-05-30T17:46:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6405</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：正方形能被画成什么样？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6433</link>
<content><![CDATA[ 
		<p>房间的正中间悬浮着一个正方形的金属框。五位画家看到这般奇迹后，立即拿出纸和笔，把这个金属框的样子画了下来。但是，由于五位画家观察这个金属框的角度不同，它们画出来的结果也互不相同。请问，这五位画家画出来的结果都是对的吗？换句话说，有没有哪一幅图或者哪几幅图根本不可能是一个正方形的透视图？</p>
<p style="text-align: center"><img alt="image placeholder" >
<p><span id="more-6433"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>首先，我们简单解释一下透视图背后的数学模型。假设人眼和实物之间有一个矩形的画布。将实物中的任意一点 X<sub>0</sub> 与人眼相连，都会与画布有一个交点 X ，那么在人眼看来，实物上的 X<sub>0</sub> 点和画布上的 X 点是完全重合的。我们就说，这个 X 点是 X<sub>0</sub> 点在画布上的像。把实物中的每一个点在画布上的像都描出来，我们就能得到实物在这块矩形画布上的透视图了。假设实物上有一条线段 A<sub>0</sub>B<sub>0</sub> ，那么人眼、 A<sub>0</sub> 点、 B<sub>0</sub> 点就确定了空间当中的一个平面。由于线段 A<sub>0</sub>B<sub>0</sub> 上的任意一点与人眼的连线都在这个平面上，因而这条线段的像一定在这个平面与矩形画布的交线上。这说明，任意一条直线在画布上的像仍然是一条直线。</p>
<p class="indent"><img alt="image placeholder" >
<p>在这个意义下， A 、 B 、 C 、 D 、 E 这五幅图究竟画得对不对呢？我们先来说明，图 D 和图 E 是对的。事实上，我们将会证明，任意一个两组对边都不平行的凸四边形 ABCD 都可以看作是从某个角度观察正方形所得到的透视图。假设这个四边形的对角线 AC 和 BD 交于点 O ，再假设它的两组对边分别交于点 P 和点 Q ，如下图所示。过点 A 作平行于 PQ 的直线 l ，令 PO 、 QO 、 BD 所在直线分别与直线 l 交于 M 、 N 、 S 。现在，过直线 l 作与四边形 ABCD 所在平面垂直的平面 γ 。分别以 AS 、 MN 为直径，在平面 γ 上作半圆，两个半圆交于点 O<sub>0</sub> 。过 PQ 所在直线也作一个与四边形 ABCD 所在平面垂直的平面 π ，显然平面 π 和平面 γ 平行。反向延长 OO<sub>0</sub> ，与平面 π 交于点 Z 。延长 ZB 、 ZC 、 ZD ，与平面 γ 交于 B<sub>0</sub> 、 C<sub>0</sub> 、 D<sub>0</sub> 。根据刚才讲到的透视图理论，如果人眼在 Z 处观察平面 γ 上的四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> ，得到的就是四边形 ABCD 了。下面我们证明，四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 是一个正方形。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>首先注意到， Z 、 B<sub>0</sub> 、 C<sub>0</sub> 构成了一个平面，且线段 QCB 也在这个平面上。这个平面与 γ 交于 B<sub>0</sub>C<sub>0</sub> ，与 π 交于 ZQ 。然而，平面 γ 和平面 π 是平行的，这就说明 B<sub>0</sub>C<sub>0</sub> 与 ZQ 平行。同理， AD<sub>0</sub> 也与 ZQ 平行。既然 B<sub>0</sub>C<sub>0</sub> 和 AD<sub>0</sub> 都与 ZQ 平行，因此 B<sub>0</sub>C<sub>0</sub> 与 AD<sub>0</sub> 互相之间也是平行的。</p>
<p>类似地，我们可以说明 D<sub>0</sub>C<sub>0</sub> 和 AB<sub>0</sub> 都与 ZP 平行，因此 D<sub>0</sub>C<sub>0</sub> 与 AB<sub>0</sub> 互相之间也是平行的。这说明，四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 是一个平行四边形。在透视图中， B 、 O 、 D 在一条直线上， A 、 O 、 C 也在一条直线上；因此，在实物中， B<sub>0</sub> 、 O<sub>0</sub> 、 D<sub>0</sub> 在一条直线上， A 、 O<sub>0</sub> 、 C<sub>0</sub> 也在一条直线上。这意味着， O<sub>0</sub> 是平行四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 的中心。</p>
<p>线段 QON 和 ZOO<sub>0</sub> 确定了一个平面，这个平面与 γ 和 π 分别交于 NO<sub>0</sub> 和 ZQ ，再次结合 γ ∥ π 便可得出， 线段 NO<sub>0</sub> 平行于 ZQ ，从而也就平行于 B<sub>0</sub>C<sub>0</sub> 、 AD<sub>0</sub> 了。同样地，线段 MO<sub>0</sub> 平行于 ZP ，从而也平行于 D<sub>0</sub>C<sub>0</sub> 、 AB<sub>0</sub> 。然而，由于直径所对的圆周角为 90° ，因此 ∠MO<sub>0</sub>N = 90° ，即 NO<sub>0</sub> 与 MO<sub>0</sub> 垂直。这说明平行四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 的两组对边互相之间也是垂直的，进而说明这个平行四边形实际上是一个矩形。</p>
<p>最后注意到，在透视图中， O 、 B 、 S 在一条直线上，因此在实物中， O<sub>0</sub> 、 B<sub>0</sub> 、 S 也在一条直线上。由于直径所对的圆周角为 90° ，因此 ∠AO<sub>0</sub>S = 90° ，即 ∠AO<sub>0</sub>B<sub>0</sub> = 90° 。考虑到 O<sub>0</sub> 是平行四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 的中心，因而 ∠AO<sub>0</sub>B<sub>0</sub> = 90° 就意味着这个平行四边形的对角线互相垂直。这说明，这个平行四边形实际上是一个菱形。</p>
<p>把上面两段的结论结合起来，我们便得到了，四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 的确是一个正方形。这表明，任何一个两组对边都不平行的凸四边形，比如图 D 和图 E ，都可以看作是某个正方形的透视图。</p>
<p>利用前面的这些技巧，我们很快可以说明，任何一个梯形，比如图 C ，也都可以看作是某个正方形的透视图。事实上，我们几乎可以把刚才的构造原封不动地套用在梯形上，只不过点 B 、点 B<sub>0</sub> 、点 S 重合在了一起，并且点 P 和点 M 跑到了无穷远处。整个构造过程也大大简化了。假设 AD 与 BC 交于点 Q ， AC 与 BD 交于点 O ，延长 QO 与 AB 交于点 N 。过 AB 作与四边形 ABCD 所在平面垂直的平面 γ ，过 Q 作平行平面 π 。此时，以 AS 为直径的半圆也就变成了以 AB 为直径的半圆，以 MN 为直径的半圆也就变成了过点 N 且垂直于 AB 的直线，令两者的交点为 O<sub>0</sub> 。反向延长 OO<sub>0</sub> ，它与 π 的交点便是人眼的位置 Z 。延长 ZC 、 ZD ，分别与平面 γ 交于 C<sub>0</sub> 、 D<sub>0</sub> ，则四边形 ABC<sub>0</sub>D<sub>0</sub> 即为所求。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>为什么 ABC<sub>0</sub>D<sub>0</sub> 一定是正方形呢？证明方法和刚才几乎完全相同，只不过更简单一些。这里，我们就不重复叙述了。</p>
<p> </p>
<p>现在，我们已经证明了，图 C 、图 D 、图 E 都是正确的透视图。那么，图 A 和图 B 呢？图 A 显然也是正确的透视图。如果把正方形金属框平行地放在画布的一侧，人眼在画布另一侧的任意位置，那么容易看出，这个正方形里的每条线段，包括对角线，都与它在画布上留下的像平行。于是，原正方形的两组对边分别平行，像的两组对边也分别平行；原正方形的邻边是互相垂直的，像的邻边也是互相垂直的；原正方形的对角线是互相垂直的，像的对角线也是互相垂直的。这足以说明，画布上像也是正方形。容易想到，事实上，把任意平面图形搬到一个与之平行的画布上，不管人眼的位置在哪里，所得到的都是这个平面图形的一个相似形。</p>
<p class="indent"><img alt="image placeholder" >
<p>下面我们说明，图 B 不可能是某个正方形的透视图。注意到图 B 的特征：每一组对边经过透视之后都仍然是平行的。我们来看一看，如果实物上的平行线在画布上也是平行的，这意味着什么。</p>
<p>假设 l<sub>0</sub> 、 m<sub>0</sub> 是实物上的两条平行线， Z 是人眼的位置。那么， Z 和 l<sub>0</sub> 确定了一个平面， Z 和 m<sub>0</sub> 也确定了一个平面。不妨把这两个平面分别叫做 α 和 β ，它们的交线为 i 。容易看出， i 与 l<sub>0</sub> 、 m<sub>0</sub> 都平行。再假设 l<sub>0</sub> 、 m<sub>0</sub> 在画布上的像分别是 l 、 m 。容易看出， l 和 m 所在的直线其实就是画布与 α 和 β 的交线，它们的交点也就是画布与 i 的交点。所以，为了让 l 和 m 平行，即为了让 l 和 m 不相交，我们必须保证画布和 i 也不能相交，即画布和 i 平行，即画布和 l<sub>0</sub> 、 m<sub>0</sub> 都平行。</p>
<p class="indent"><img alt="image placeholder" >
<p>如果正方形的第一组对边经过透视之后仍然是平行的，这就说明画布平行于第一组对边；如果正方形的第二组对边经过透视之后仍然是平行的，这就说明画布平行于第二组对边。可见，此时画布将会平行于整个正方形所在的平面。但是，我们刚才说过，这种情况下，画布上显示的应该是一个正方形。</p>
<p>所以，正方形的透视图要么是一个正方形，要么是一个至少有一组对边不平行的四边形。所以，图 A 、图 C 、图 D 、图 E 都是合法的正方形透视图，图 B 则不是一个正方形的透视图。</p>
<p> </p>
<p>在刚才的文字中，我们避免使用了消失点、消失线等词，但很多地方实际上都触及了这些概念。如果你对这些概念非常熟悉的话，你会发现前面那些神一般的构造其实来得都很自然，而且论证过程也不必如此大费周章。利用一些与仿射变换、射影变换相关的知识，这个问题的解答还可以变得更加简单。这篇文章部分参考了 100 Great Problems of Elementary Mathematics: Their History and Solution 一书中的第 72 题，同时也参考了 Analytic Projective Geometry 一书中的附录 A ，但完整而初等的解答过程则是自己整理出来的，若有问题，还请大家及时指正。</p>
<p>在写这篇文章的时候，我还做了一个消失点的演示动画，用于更直观地展示 Wikipedia 上的<a href="https://commons.wikimedia.org/wiki/File:Vanishing_Point.jpg">这张图</a>的意思，但最后并没有用到。想着觉得有点可惜，因此还是放上来吧。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>这个动画表明，如果实物上有 l<sub>0</sub>, m<sub>0</sub>, n<sub>0</sub>, … 等一系列无限长的平行线，那么它们在画布的像 l, m, n, … 将会交于一点（即使这些平行线之间的间隔很稀疏，即使这些平行线被平移到了人眼侧方很远的位置）。这个点就叫做这些平行线的“消失点”（vanishing point）。这个消失点究竟在哪儿呢？我们很容易把它找出来。过人眼作出与这些平行线都平行的线，它与画布的交点就是消失点。由此可见，如果画布本身就与这些平行线平行，消失点就不存在了。此时，这些平行线在画布上的像不会交于一点，而是依旧呈现出彼此平行的形态。</p>
<p>在描绘机器、建筑等物体时，我们经常会发现，物体上有三组平行线，它们分别与 X 轴、 Y 轴、 Z 轴平行。如果画布所在的平面与 X 轴、 Y 轴、 Z 轴都不平行，那么对于每一组平行线来说，把它们画在画布上并且延长之后，都应该汇聚于一点。这就是美术当中的三点透视原理。如果画布与某条轴平行，那么其中一组平行线的像将会依旧平行，不会形成任何消失点。这种绘画模式就叫做两点透视。如果画布与其中两条轴都平行，那么其中两组平行线的像都将会依旧平行，只剩下一组拥有消失点的平行线。这种绘画模式就叫做一点透视。刚才我们曾让画布与直线 i 平行，这样做的效果就是减去一个消失点，从而把三点透视变为两点透视，或者把两点透视变为一点透视。</p>
<p>消失点还有另一个更加直观的意义：呈现出一条直线是如何消失在无穷远处的。直线 l<sub>0</sub> 在画布上的消失点，其实就是直线 l<sub>0</sub> 的无穷远点在画布上所对的点。类似地，如果实物上有一个无限大的平面，那么它的无穷远处就对应于画布上的一条线。这条线就叫做这个平面的“消失线”（vanishing line）。如果你站在一望无垠的水平地面上，你所看到的地平线就是地面的消失线，它和你的眼睛齐平。地面上的任何一条无限向前延伸的线，在画布上的消失点都位于消失线上。</p>
<p>所以，之前在解释 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 为何是平行四边形的时候，我们完全可以这么说：画布上的直线 PQ 和人眼齐平，这说明它是平面 γ 的消失线。由于四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 的两组对边在画布上的像都汇聚在了消失线上，这说明这个四边形的每一组对边都是平行的，所以它是一个平行四边形。</p>
			 ]]></content>
<pubDate>2015-06-23T22:48:23+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6433</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ IMO2015 趣题：平衡的但无中心的点集 ]]></title>
<link>http://www.matrix67.com/blog/archives/6463</link>
<content><![CDATA[ 
		<p>2015 年 IMO 的第 1 题很有意思。假设 S 是平面上的某个点集。如果对于 S 中的任意两点 A 、 B ，我们都能在 S 中找到一个点 C 满足 AC = BC ，我们就说这个点集 S 是平衡的。如果对于 S 中的任意三点 A 、 B 、 C ，我们都无法在 S 中找到一个点 P 满足 PA = PB = PC ，我们就说这个点集 S 是无中心的。这道题有两个小问。</p>
<ol>
<li>证明：对于所有大于等于 3 的正整数 n ，都存在一个由 n 个点构成的平衡点集。</li>
<li>对于哪些大于等于 3 的正整数 n ，存在由 n 个点构成的平衡的但无中心的点集？</li>
</ol>
<p><span id="more-6463"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>在第一小问中，如果 n 为奇数，我们只需要在圆周上取 n 个间隔相等的点即可。这 n 个点把圆周分成了 n 段等长的小圆弧。由于 n 为奇数，因此对于任意两点 A 、 B 来说，在优弧 AB 和劣弧 AB 当中，必然是一个包含奇数段小圆弧，一个包含偶数段小圆弧，其中后者上的中点一定也在点集里，不妨把它记作点 C 。由于弧 AC 的长度等于弧 BC ，因此线段 AC 的长度等于线段 BC 。这说明，这 n 个点满足平衡性的要求。</p>
<p>当 n = 4 时，以 O 为圆心作圆，在圆上找出 A 、 B 、 C 三个点，使得 △OAB 、 △OBC 都是等边三角形。容易验证，这四个点是满足要求的。在此基础上，每次再在圆上找两个与点 O 构成等边三角形的点，就能得到 n = 6, 8, 10, 12, … 时的方案。对于圆周上的任意两点，圆心 O 到它们俩等距；对于圆心和圆周上的任意一点，都有至少一个和它们配对的等边三角形，这个等边三角形的第三个顶点到它们俩等距。因此，如此得到的方案都是满足要求的。</p>
<p>所以，对于任意大于等于 3 的正整数 n ，满足要求的方案都是存在的。</p>
<p> </p>
<p>在第二小问中，若 n 为奇数，那么圆周上的 n 个间隔相等的点即满足要求。我们刚才已经说明了，这样的点集是平衡的。对于圆周上的任意三点来说，到它们距离相等的点都是这个圆的圆心，而圆心并不在点集中，因此这个点集也是无中心的。</p>
<p>接下来，我们将要证明，对于所有的偶数 n = 2k ，满足要求的点集都是不存在的。由于点集满足平衡性，因此对于点集中的任意两个点 A 、 B ，我们都能找到一个与它们等距的点 C 。我们就说，点 C 平衡了 (A, B) 这一对点。显然，任意一个点最多都只能平衡掉 k – 1 对点，否则被它平衡的点将会有重复，从而不满足无中心的条件。然而，所有可能的点对数量为 2k · (2k – 1) / 2 = 2 · k<sup>2</sup> – k ，这里面最多只有 2k · (k – 1) = 2 · k<sup>2</sup> – 2 · k 个点对能被平衡掉。这就说明，满足要求的点集是不存在的。</p>
			 ]]></content>
<pubDate>2015-07-19T11:16:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6463</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ WOM 编码与一次写入型存储器的重复使用 ]]></title>
<link>http://www.matrix67.com/blog/archives/6443</link>
<content><![CDATA[ 
		<p>计算机历史上，很多存储器的写入操作都是一次性的。 Wikipedia 的 <a href="https://en.wikipedia.org/wiki/Write_once_read_many">write once read many</a> 词条里提到了两个最经典的例子，一个是大家熟悉的 CD-R 和 DVD-R ，另一个则是更早的打孔卡片和打孔纸带。在介绍后者时，文章里说：“虽然第一次打孔之后，没有孔的区域还能继续打孔，但这么做几乎没有任何实际用处。”因此，打孔卡片和打孔纸带通常也被看成是只能写入一次的存储设备。</p>
<p>事实上真的是这样吗？ 1982 年， Ronald Rivest 和 Adi Shamir 发表了一篇题为《怎样重复使用一次写入型存储器》（How to Reuse a “Write-Once” Memory）的论文，提出了一个很有意思的想法。大家有觉得 Ronald Rivest 和 Adi Shamir 这两个人名都很眼熟吗？没错，这两个人之前曾经和 Leonard Adleman 一道，共同建立了 RSA 公钥加密系统。其中， Ronald Rivest 就是 RSA 中的那个 R ， Adi Shamir 就是 RSA 中的那个 S 。</p>
<p>在这篇论文的开头， Ronald Rivest 和 Adi Shamir 举了一个非常简单的例子。假设初始时存储器里的所有 bit 全是 0 。存储器的写入操作是单向的，它只能把 0 变成 1 ，却不能把 1 变成 0 。我们可以把存储器里的每 3 个 bit 分为一组，每一组都只表达 2 个 bit 的值，其中 000 和 111 都表示 00 ， 100 和 011 都表示 01 ， 010 和 101 都表示 10 ， 001 和 110 都表示 11 。好了，假设某一天，你想用这 3 个 bit 表示出 01 ，你就可以把这 3 个 bit 从 000 改为 100 ；假设过了几天，你想再用这 3 个 bit 表示出 10 ，你就可以把这 3 个 bit 从 100 改为 101 。事实上，容易验证，对于 {00, 01, 10, 11} 中的任意两个不同的元素 a 、 b ，我们都能找到两个 3 位 01 串，使得前者表示的是 a ，后者表示的是 b ，并且前者能仅仅通过变 0 为 1 而得到后者。因此，每组里的 bit 都能使用两遍，整个存储器也就具备了“写完还能再改一次”的功能。</p>
<p>不可思议的是，两次表达出 {00, 01, 10, 11} 中的元素，其信息量足足有 4 个 bit ，这却只用 3 个 bit 的空间就解决了。这乍看上去似乎有些矛盾，但仔细一想你就会发现，这并没有什么问题。在写第二遍数据的时候，我们会把第一遍数据抹掉，因此总的信息量不能按照 4 个 bit 来算。利用这种技术，我们便能在 300KB 的一次写入型存储器里写入 200 KB 的内容，再把这 200KB 的内容改写成另外 200KB 的内容。这听上去似乎是神乎其神的“黑科技”，然而原理却异常简单。</p>
<p><span id="more-6443"></span> </p>
<p>由于“一次写入型存储器”（write-once memory）的首字母缩写为 WOM ，因此重复多次使用一次写入型存储器的编码方案也就叫做 WOM 编码了。上面展示的编码系统就是一个 WOM 编码，它可以重复 2 次利用 3 个 bit 的空间，每次都能写入 2 个 bit 的数据。 Ronald Rivest 和 Adi Shamir 把这个 WOM 编码扩展为了一系列更大的 WOM 编码，使得我们能重复 2<sup>k – 2</sup> + 1 次利用 2<sup>k</sup> – 1 个 bit 的空间，每次都能写入 k 个 bit 的数据。不妨让我们以 k = 5 为例，对此做一个简单的介绍吧。</p>
<p>所以，我们现在要说明的就是，如何重复 9 次利用 31 个 bit 的空间，每次都能写入 5 个 bit 的数据。首先，把这 31 个 bit 的位置分别编号为 00001, 00010, 00011, …, 11110, 11111 。然后我们规定，一个 31 位 01 串究竟表示哪 5 个 bit ，就看数字 1 的位置编号全都合在一起，各个位置上究竟有奇数个 1 还是偶数个 1 。假设某个 31 位 01 串的第 1 位、第 3 位和第 31 位是 1 ，其余的地方都是 0 。把这 3 个位置的编号列出来，就得到 00001, 00011, 11111 。在这 3 个编号中，左起第 1 位上的数字 1 共有 1 个，左起第 2 位上的数字 1 共有 1 个，左起第 3 位上 1 个，左起第 4 位上 2 个，左起第 5 位上 3 个。其中，左起第 1 、 2 、 3 、 5 位上都是奇数个 1 ，左起第 4 位上共有偶数个 1 。因此，这个 31 位 01 串最终表达的值就是 11101 。</p>
<p>我们将会说明，只要这个 31 位 01 串里还有至少 16 个数字 0 ，我们都能把最多两个 0 改成 1 ，使得整个 31 位 01 串转而表达任意一个我们想要的新的值。不妨假设这个 31 位 01 串当前表达的是 11101 ，而我们现在想让它表达 10110 。显然，如果在这个 31 位 01 串中，编号 01011 对应位置上的是数字 0 ，我们把它改成数字 1 就行了。如果在这个 31 位 01 串中，编号 01011 对应位置上的是数字 1 ，这又该怎么办呢？我们可以按照“同-异-同-异-异”的原则，把除了 01011 以外的 30 个编号分成 15 组：</p>
<table>
<tr>
<td>(00001, 01010)</td>
<td>(00010, 01001)</td>
<td>(00011, 01000)</td>
<td>(00100, 01111)</td>
<td>(00101, 01110)</td>
</tr>
<tr>
<td>(00110, 01101)</td>
<td>(00111, 01100)</td>
<td>(10000, 11011)</td>
<td>(10001, 11010)</td>
<td>(10010, 11001)</td>
</tr>
<tr>
<td>(10011, 11000)</td>
<td>(10100, 11111)</td>
<td>(10101, 11110)</td>
<td>(10110, 11101)</td>
<td>(10111, 11100)</td>
</tr>
</table>
<p>于是，每一组里的两个编号都满足，左起第 1 位一共有 0 个或 2 个数字 1 ，左起第 2 位一共有恰好 1 个数字 1 ，左起第 3 位一共有 0 个或 2 个数字 1 ，左起第 4 位一共有恰好 1 个数字 1 ，左起第 5 位一共有恰好 1 个数字 1 。其实， 01011 本来应该和 00000 配对，但 00000 并不在我们的编号范围里。所以， 01011 也就没在上面的列表里出现。</p>
<p>但别忘了，这个 31 位 01 串里至少有 16 个数字 0 。由于编号 01011 所对应的是数字 1 ，因此所有的数字 0 都落在了上面 30 个编号上，其中必然会有两个数字 0 落到了同一组里。把这两个 0 都改成 1 ，整个 31 位 01 串所表达的值就能从 11101 变为 10110 了。</p>
<p>初始时，这个 31 位 01 串为 000…00 。只要里面还有至少 16 个数字 0 ，我们就可以对数据进行改写。第一次改写显然只需要把一个 0 变成 1 即可，今后的每次改写也最多只会把两个 0 变成 1 。因此，这个 31 位 01 串可以被我们重复使用 9 次。根据同样的道理，一个 2<sup>k</sup> – 1 位 01 串就能被我们重复使用 2<sup>k – 2</sup> + 1 次，每次写入的都是 k 个 bit 的数据。这正是由 Ronald Rivest 和 Adi Shamir 扩展出来的 WOM 编码，它对于一切大于等于 2 的整数 k 都适用。之前那个把 300KB 当两个 200KB 用的“黑科技”，其实不过是 k = 2 时的一个特例罢了。</p>
<p>随着 k 值的增加，这个科技是“越来越黑”呢，还是“越来越不黑”呢？在这类 WOM 编码中，我们可以把每 2<sup>k</sup> – 1 个 bit 当作 k · (2<sup>k – 2</sup> + 1) 个 bit 来用，其比值为 k · (2<sup>k – 2</sup> + 1) / (2<sup>k</sup> – 1) 。这个比值越高，就代表每个 bit 的利用率越高。当 k = 2 时，这个比值只有 1.333… ；当 k = 5 时，这个比值为 1.4516… ；当 k = 10 时，这个比值增加到了 2.51222… 。可见，这个科技是“越来越黑”的。事实上，我们有 (2<sup>k – 2</sup> + 1) / (2<sup>k</sup> – 1) &gt; 2<sup>k – 2</sup> / 2<sup>k</sup> = 1 / 4 ，因此不管 k 是多少，整个比值都大于 k / 4 了。这立即证明了，在 WOM 编码中，单个 bit 的利用率可以达到任意大。</p>
<p> </p>
<p>不过， k / 4 虽然成为了一个下界，但同时也成为了一个“槛”。当 k = 20 时，单个 bit 的利用率为 5.00002384… ；当 k = 50 时，单个 bit 的利用率为 12.5000000000000555… 。随着 k 的增加，单个 bit 的利用率最终稳定在了 k / 4 的水平。单个 bit 的利用率能超越 k / 4 的水平吗？能！</p>
<p>我们可以让每个编号下都有多个 bit 。例如，我们干脆用 3100 个 bit 的存储空间来表示 5 个 bit 的值，其中前 100 位的编号都是 00001 ，下 100 位的编号都是 00010 ，等等。为了确定出这个 3100 位 01 串究竟表达了哪 5 个 bit 的值，我们就要先找出哪些编号所对应的 100 位 01 串里含有奇数个数字 1 ，再把这些编号全都合在一起，看看各个位置上究竟有奇数个 1 还是偶数个 1 。编码过程也就变得更简单了。刚开始，这个 3100 位 01 串全是 0 ，代表的值也就是 00000 。如果你想写入数据 00010 ，即对左起第 4 位取反，你就把编号为 00010 的那 100 个 bit 中的其中一个 0 改成 1 ；如果你想把它改写成 01101 ，即对左起第 2 位、第 3 位、第 4 位、第 5 位都取反，你就把编号为 01111 的那 100 个 bit 中的其中一个 0 改成 1 ；如果你想再把它改写成 01111 ，即再次对左起第 4 位取反，你就从编号为 00010 的那 100 个 bit 中再选一个 0 ，并把它改成 1 ……但是，这种新的 WOM 编码方案没什么实质性的意义，重复写入次数成倍增加了的同时，所用的存储空间也成倍增加了，单个 bit 的利用率仍然没有提高。这里面有个原因：频繁用到某个编号，对应的数字 0 将会很快用光。为了解决这个问题，我们再出奇招：允许用户根据需要给某个编号里再“充”一些的 0 。把这些想法结合起来，我们就得到了一类更加“黑”的“表格式 WOM 编码”。</p>
<p>我们列一个大表格，表格里一共有 100 行，每一行都是 105 个 bit ，其中前 5 个 bit 表示编号，后 100 个 bit 则用于标记这个编号是否被选中，有奇数个数字 1 代表该编号要选，有偶数个数字 1 代表该编号不选。所有选中的编号里，各个位置上究竟有奇数个 1 还是偶数个 1 ，就决定了这 10500 个 bit 的存储空间究竟表达了哪 5 个 bit 的值。每次改写本质上都是选中某个没选中的编号，或者取消掉某个选中了的编号。如果这个编号所在的行里还有空余的 0 ，我们只需要把其中一个 0 改成 1 即可；如果这个编号所在的行都满了，或者整个表格里根本还没出现这个编号（比如初始时），我们就把新的一行的前 5 个 bit 设为这个编号，再把它后面的某个 0 改成 1 。注意到，所有可能的编号也就只有 00001, 00010, …, 11111 共 31 种，并且每种编号都是用满一行才会再开一行。这说明，我们每次都能顺利完成改写操作，直到表格中没填满的行不足 31 行为止。在此之前，我们已经成功改写了 (100 – 31) × 100 = 6900 次。总共 10500 个 bit 的存储空间，竟能 6900 次写入 5 个 bit 的数据，可见单个 bit 的利用率为 5 × 6900 / 10500 = 3.2857… 。</p>
<p>进一步增加行数和列数，可以进一步增加单个 bit 的利用率。如果整个表格一共有 r 行，每一行里都有 5 + s 个 bit ，我们就能重复使用至少 (r – 31) · s 次，每次都能写入 5 个 bit 的数据。因此，单个 bit 的利用率就是 5 · (r – 31) · s  / (r · (5 + s)) 。当 r 和 s 足够大时， (r – 31) / r 会非常接近 1 ， s / (5 + s) 也会非常接近 1 ，因而整个分数就会非常接近 5 。类似地，如果把 5 换成更大的 k ，单个 bit 的利用率也就能跟着上升为 k ，这优于之前的那个 k / 4 。</p>
<p> </p>
<p>但是，如此高的 bit 利用率，是由极其庞大的存储空间以及极其庞大的重写次数来支撑的，这很难有什么实际用途。在生活中，我们可能更关心的是：为了写入 t 次数据，每次数据量都是 k 个 bit ，至少需要几个 bit 的空间？这个问题分析起来就非常困难了。不妨让我们先从一些最简单的情形出发，一点一点开始探究。为了重复 2 次写入 2 个 bit 的数据，我们可以只用 3 个 bit 的空间（即本文最开始讲到的 WOM 编码）；那么，同样是每次写入 2 个 bit 的数据，为了把写入次数从 2 次提升到 3 次，我们需要几个 bit 的空间呢？我们先给出一个下界： 4 个 bit 的空间是不够的。事实上，我们将会证明，当 t ≥ 3 时，要想重复 t 次写入 2 个 bit 的数据，只用 t + 1 个 bit 的空间是办不到的。</p>
<p>首次写入的数据有 00 、 01 、 10 、 11 共四种可能，初始时的 01 串 000…00 最多只能表达其中一种可能，其他情况下我们都必须要往存储器里写数字 1 。不妨假设首次写入数据 a 和数据 b 时，我们必须要往存储器里写数字 1 ，其中 a 和 b 是 {00, 01, 10, 11} 中的两个不同的元素。在这段文字和下段文字中，我们假设，首次写入的总是 a 和 b 之一。那么，下一步改写时写入的有可能是什么呢？首次写入 a 后，接下来我们可以把它改写成 b 、 c 、 d ；首次写入 b 后，接下来我们可以把它改写成 a 、 c 、 d 。这里， c 、 d 是 {00, 01, 10, 11} 中的另外两个不同的元素。这意味着，下一步改写时写什么都有可能。容易看出，今后每次改写时更是写什么的都有了。由于每次改写都会把至少一个 0 改成 1 ，因此这就说明了，不管第 t – 1 次写入的是 {00, 01, 10, 11} 中的哪个元素，存储器里都有至少 t – 1 个 1 。</p>
<p>为了给最后一次改写留下足够的空间，此时存储器里还得有至少两个 0 。如果存储器一共只有 t + 1 个 bit 的空间的话，你会发现这一切都抵得非常死：不管第 t – 1 次写入的是什么，存储器里都只能有恰好 t – 1 个 1 ，并且在最后一次改写时，把其中一个 0 改成 1 ，把另外一个 0 改成 1 ，以及把剩下的两个 0 都改成 1 ，必须正好对应三种可能的改写值。这说明，如果第 t – 1 次写入的是 a ，把剩下的两个 0 都改成 1 就会得到一个与 a 不同的值；如果第 t – 1 次写入的是 b ，把剩下的两个 0 都改成 1 就会得到一个与 b 不同的值；对于 c 和 d 也是同理。因而，当存储器里写满了 1 时，它所表达的值既不能是 a ，也不能是 b ，也不能是 c 和 d 。这个矛盾就表明，存储器里只有 t + 1 个 bit 的空间的话是不够的。</p>
<p>别忘了我们正在探究的问题：同样是每次写入 2 个 bit 的数据，为了把写入次数从 2 次提升到 3 次，我们需要几个 bit 的空间？现在我们知道了， 4 个 bit 的空间是不够的。那么， 5 个 bit 的空间够不够呢？答案是肯定的。我们可以把这 5 个 bit 分成两部分，前面一部分有 2 个 bit ，后面一部分有 3 个 bit 。注意到，利用 2 个 bit 的空间可以写入 1 次 2 个 bit 的数据，利用 3 个 bit 的空间可以写入 2 次 2 个 bit 的数据，按照下面给出的方法把两者结合起来，我们就能利用 5 个 bit 的空间写入 1 + 2 = 3 次数据了。下面，我们将会说明，假设每次所写的数据量都相同，如果重写 t<sub>1</sub> 次可以用 r 个 bit 的空间办到，重写 t<sub>2</sub> 次可以用 s 个 bit 的空间办到，那么重写 t<sub>1</sub> + t<sub>2</sub> 次一定可以用 r + s 个 bit 的空间办到。</p>
<p>这看起来似乎非常简单：把 r 个 bit 和 s 个 bit 并排放置，先在前 r 个 bit 里使用前一种子编码系统，把 t<sub>1</sub> 次重写用光了之后，再在后 s 个 bit 里使用后一种子编码系统，直到把 t<sub>2</sub> 次重写用光。解码时，我们就视情况只看前 r 个 bit 或者只看后 s 个 bit ：如果后 s 个 bit 为空，则解码结果完全以前 r 个 bit 为准；如果后 s 个 bit 里有东西，则解码结果完全以后 s 个 bit 为准。太简单了，不是吗？只可惜，这个办法有个问题。如果在后一种子编码系统中， 000…00 正好对应了某个值（正如本文最开始讲到的 WOM 编码一样， 000 表示 00 ），那么首次往后 s 个 bit 里写数据时就有可能让后 s 个 bit 仍然为空，解码也就出错了。当然，我们可以额外用一个 bit ，专门用来表示刚才是在哪边写的数据。但是，这样我们就用了 r + s + 1 个 bit 的空间了。</p>
<p>那怎么办呢？之前那些奇数个 1 偶数个 1 之类的思路，现在就又派上用场了。我们仍然像刚才那样，前 t<sub>1</sub> 次都在前 r 个 bit 里写，后 t<sub>2</sub> 次都在后 s 个 bit 里写，但解码的方法有所变化：假设前 r 个 bit 表示的值为 a ，假设后 s 个 bit 表示的值为 b ，那么所有 r + s 个 bit 表示什么值，就看 a 和 b 的各个位置上的数字 1 的总数的奇偶性。举个例子吧：假如在前一个子编码系统中， 1101 表示的值是 10 ；假设在后一个子编码系统中， 001 表示的值是 11 ；由于 10 和 11 的左起第 1 位上一共有偶数个 1 ，左起第 2 位上一共有奇数个 1 ，因此在整个编码系统中， 1101001 就表示 01 。在编码时，不管是往哪边写东西，我们都只消写入要表达的值和另一边当前表达出的值在哪些位置上有差即可。</p>
<p>由于仅写 1 次 2 个 bit 的数据只需要 2 个 bit 的空间，重复 2 次写入 2 个 bit 的数据只需要 3 个 bit 的空间，因此重复 3 次写入 2 个 bit 的数据就只需要 2 + 3 = 5 个 bit 的空间了。</p>
<p>我们还可以把这种“合成式编码”继续用于 t 值更大的情况。重复 4 次写入 2 个 bit 的数据需要多少个 bit 的空间呢？我们可以把这 4 次拆成 1 次加上 3 次，也可以把这 4 次拆成 2 次加上 2 次，从而得到两种不同的 WOM 编码。前一种需要 2 + 5 = 7 个 bit 的空间，后一种需要 3 + 3 = 6 个 bit 的空间，因而后者更优。类似地，重复 5 次写入 2 个 bit 的数据可以用 2 + 6 = 8 个 bit 的空间办到，也可以用 3 + 5 = 8 个 bit 的空间办到，两者的效果相同。</p>
<p>我们来总结一下目前的发现。不妨用 f(t) 来表示，为了重复 t 次写入 2 个 bit 的数据，目前已知的最优方案用了多少 bit 的空间。当 t = 1, 2, 3, 4, 5 时， f(t) 的值分别为：</p>
<table>
<tr>
<td>t</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>f(t)</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>8</td>
</tr>
</table>
<p>仅写 1 次 2 个 bit 的数据，显然 1 个 bit 的空间是不够的，我们至少要用 2 个 bit 的空间。为了重复 2 次写入 2 个 bit 的数据，显然 2 个 bit 的空间是不够的，我们至少要用 3 个 bit 的空间。回想我们之前证明过的结论：当 t ≥ 3 时，要想重复 t 次写入 2 个 bit 的数据，只用 t + 1 个 bit 的空间是办不到的，我们至少需要 t + 2 个 bit 的空间。不妨用 g(t) 来表示，为了重复 t 次写入 2 个 bit 的数据，目前已知的理论最少所需空间是多少 bit 。当 t = 1, 2, 3, 4, 5 时， g(t) 的值分别为：</p>
<table>
<tr>
<td>t</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>g(t)</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</table>
<p>容易看出，当 t = 1, 2, 3, 4 时，上界与下界是一致的，对应的最优化问题也就有了圆满的回答。但是， t = 5 时的情形就不尽人意了：我们有了一种只使用 8 个 bit 的方案，但只证明了 7 个 bit 是必需的。那么，究竟是我们给出的方案还不够好，还是我们证明的结论还不够强呢？</p>
<p> </p>
<p>Ronald Rivest 和 Adi Shamir 给出了 t = 5 时的一种只需要 7 个 bit 的编码方案，从而把 t = 5 时的情形也完美地解决了。</p>
<p>为了说明这种新的编码是怎么工作的，我们不妨先讲一下它的解码过程。我们把这 7 个 bit 看作一个 7 位 01 串，假设它是 abcdefg 。如果这个 01 串中，数字 1 的个数小于等于 4 ，则按照下述过程确定整个 01 串所表达的值。</p>
<ul>
<li>初始值为 00 。</li>
<li>如果 ab 为 10 ，则左边那一位取反。</li>
<li>如果 ab 为 11 ，并且 cd 或 ef 之一为 01 ，则左边那一位取反。</li>
<li>如果 cd 为 10 ，则右边那一位取反。</li>
<li>如果 cd 为 11 ，并且 ab 或 ef 之一为 01 ，则右边那一位取反。</li>
<li>如果 ef 为 10 ，则左右两位都取反。</li>
<li>如果 ef 为 11 ，并且 ab 或 cd 之一为 01 ，则左右两位都取反。</li>
</ul>
<p>如果数字 1 的个数大于 4 ，则按照下述过程确定整个 01 串所表达的值。</p>
<ul>
<li>如果 a 、 c 、 e 、 g 中有偶数个 1 ，则左边那一位为 0 。</li>
<li>如果 a 、 c 、 e 、 g 中有奇数个 1 ，则左边那一位为 1 。</li>
<li>如果 b 、 d 、 f 、 g 中有偶数个 1 ，则右边那一位为 0 。</li>
<li>如果 b 、 d 、 f 、 g 中有奇数个 1 ，则右边那一位为 1 。</li>
</ul>
<p>然后我们再来叙述一下，如何利用这个 7 位 01 串， 5 次得出任何我们想要表达的值。首先注意到，最开始 abcdefg = 0000000 所表达的值就是 00 。表达一个新的值，本质上就是对当前的值进行下述三种操作之一：左边那一位取反，右边那一位取反，左右两位都取反。接下来我们就来说明，我们可以连续五次实现任何一种取反操作。</p>
<p>在数字 1 的个数小于等于 4 的时候， ab 、 cd 、 ef 各对应一种取反操作。刚开始， ab 、 cd 、 ef 都为 00 。如果把其中一个 00 变为 10 ，就相当于执行了对应的取反操作；如果再把这个 10 变成 11 ，则相当于第二次执行该取反操作（即消除第一次取反的效果）；如果再把剩下的某个 00 变成 01 ，则相当于第三次执行该取反操作；如果再把这个 01 也变成 11 ，则相当于第四次执行该取反操作（即消除第三次取反的效果）。注意，取反的标记是 10 ，让别人再次取反的标记是 01 ，我们很容易把两者区分开来。另外， ab 、 cd 、 ef 当中一定是先出现 11 再出现 01 ，并且不会出现两个 11 一个 01 的情况（否则数字 1 的个数就超过 4 个了）。这说明， 01 作为一种辅助性的标记，将会恰好只为一个 11 服务，因而使用时不会产生什么连带的影响。</p>
<p>所以，如果前面四次取反操作中，每种操作最多出现两次，我们只需要相应地做某些 00 → 10 或者 00 → 10 → 11 的修改就行了。如果前面四次取反操作全是同一种操作，我们只需要对相应的 00 做 00 → 10 → 11 的修改，再选一个剩下的 00 做 00 → 01 → 11 的修改。如果前面四次取反操作中，有一种操作出现了三次，另一种操作出现了一次，我们就用 00 → 10 实现那次单独的操作，用 00 → 10 → 11 实现前两次的重复操作，最后一定还剩有一个 00 ，把它变为 01 便能实现第三次的重复操作了。举例来说，假如前面四次取反操作分别是左位取反、两位都取反、左位取反、左位取反，那么我们就把 abcdefg 按照 0000000 → 1000000 → 1000100 → 1100100 → 1101100 的方式修改即可。</p>
<p>不管是哪种情况，前面四次取反操作都各只改变 abcdefg 中的一位。此时， abcdefg 里一共将会有 4 个数字 1 ， abcdef 中还有两位是 0 ，而且 g 一定是 0 。在此基础上，任意改动其中一位，都会让 abcdefg 中数字 1 的个数增加到 5 个或 5 个以上，解码方法就变了：解码结果的左位为 0 ，当且仅当 a 、 c 、 e 、 g 中有偶数个 1 ；解码结果的右位为 0 ，当且仅当 b 、 d 、 f 、 g 中有偶数个 1 。现在，我们需要再把某一个或某一些 0 改成 1 ，让整个 7 位 01 串最后一次表达出任意一个我们想要的值。</p>
<p>假设 abcdef 当中，有一个 0 在 a 、 c 、 e 当中，有一个 0 在 b 、 d 、 f 中。无妨假设 a 和 b 都是 0 。那么，不管现在 a 、 c 、 e 、 g 中数字 1 的个数是奇是偶，也不管现在 b 、 d 、 f 、 g 中数字 1 的个数是奇是偶，把 a 改成 1 就能改变前者的奇偶性，把 b 改成 1 就能改变后者的奇偶性，把 g 改成 1 就能同时改变两者的奇偶性，把 a 、 b 、 g 都改成 1 则能保持两者的奇偶性都不变。</p>
<p>假设 abcdef 当中，两个 0 都在 b 、 d 、 f 当中。无妨假设 b 和 d 都是 0 。那么，不管现在 a 、 c 、 e 、 g 中数字 1 的个数是奇是偶，也不管现在 b 、 d 、 f 、 g 中数字 1 的个数是奇是偶，把 b 和 g 都改成 1 就能改变前者的奇偶性，只把 b 改成 1 就能改变后者的奇偶性，把 g 改成 1 就能同时改变两者的奇偶性，把 b 、 d 都改成 1 则能保持两者的奇偶性都不变。当然，如果两个 0 都在 a 、 c 、 e 当中，处理方法也是类似的（其实，两个 0 都在 a 、 c 、 e 当中，这种情况根本不会出现）。</p>
<p>这套 WOM 编码太完美了，对吗？其实，刚才的编码流程里有一个巨大的漏洞，不知道你发现了没有：万一前面四次取反操作中，有一种操作出现了三次，另一种操作出现了一次，并且出现了一次的操作是最后才出现的，那该怎么办呢？举例来说，假如前面四次取反操作分别是左位取反、左位取反、左位取反、两位都取反，那么我们应该怎么做呢？我们可以先把 0000000 变为 1000000 ，再把 1000000 变为 1100000 。接下来，我们应该把某个 00 变为 01 。麻烦的地方来了：我们应该把哪个 00 变为 01 呢？当然，你应该把 cd 从 00 变为 01 ，从而为下一步的“两位都取反”留下空间。但是，你事先怎么知道，下一步是“两位都取反”呢？在不知道这一点的情况下，你有可能不小心把 ef 改为 01 ，此时 7 位 01 串变成了 1100010 ；接下来，你会发现发现下一步是“两位都取反”，需要把 ef 改为 10 ，然后就彻底傻眼了。这该怎么办呢？遇到这种情况时， a 、 c 、 e 当中一定有正好一个 1 ， b 、 d 、 f 中一定有正好两个 1 ，并且最后的 g 一定为 0 。我们可以按照下面的指示，把 abcdefg 中的其中两个 0 改为 1 ，从而让整个 7 位 01 串提前进入数字 1 的个数大于 4 的状态，并表达出任何一个我们想要表达的值。</p>
<ul>
<li>如果把 a 、 c 、 e 当中剩下的两个 0 都改成 1 ，整个 7 位 01 串表达的值就是 10 。此时， b 、 d 、 f 当中还有一个 0 ，另外 g 也仍然是 0 ，利用它们就能再表达一个新的值了。不管你是想要左位取反，还是想要右位取反，还是想要两位都取反，都可以通过把其中一个 0 改成 1 或者把两个 0 都改成 1 来实现。</li>
<li>如果把 a 、 c 、 e 当中剩下的某一个 0 改成 1 ，再把 b 、 d 、 f 当中剩下的那个 0 改成 1 ，整个 7 位 01 串表达的值就是 01 。此时， a 、 c 、 e 当中还有一个 0 ，另外 g 也仍然是 0 ，利用它们就能再表达一个新的值了。不管你是想要左位取反，还是想要右位取反，还是想要两位都取反，都可以通过把其中一个 0 改成 1 或者把两个 0 都改成 1 来实现。 </li>
<li>如果把 a 、 c 、 e 当中剩下的某一个 0 改成 1 ，再把 g 从 0 改成 1 ，整个 7 位 01 串表达的值就是 11 。此时，  a 、 c 、 e 当中还有一个 0 ， b 、 d 、 f 当中也还有一个 0 ，利用它们就能再表达一个新的值了。不管你是想要左位取反，还是想要右位取反，还是想要两位都取反，都可以通过把其中一个 0 改成 1 或者把两个 0 都改成 1 来实现。 </li>
<li>如果把 b 、 d 、 f 当中剩下的那个 0 改成 1 ，再把 g 从 0 改成 1 ，整个 7 位 01 串表达的值就是 00 。此时，  a 、 c 、 e 当中还有两个 0 ，其他地方都没有 0 了。这不足以让我们表达出所有可能的新的值。这可怎么办呢？幸运的是，如果前面四次取反操作中，有一种操作出现了三次，另一种操作出现了一次，所得的值不可能是 00 。这意味着，我们根本就不会碰到要表达出 00 的情况，自然也就不会碰到刚才的难题了。</li>
</ul>
<p> </p>
<p>前面这些杂乱无章的内容，已经唰唰唰地用掉了一万多字。如果你能一字一句地读到这里，那我真的很佩服你。刚才讲过的东西太多了，我们有必要整理一下线索。</p>
<p>不妨用符号 k × t / n 来表示每次写入的数据量为 k 个 bit ，总的写入次数为 t ，存储器空间为 n 个 bit 的 WOM 编码（注意到，这个符号作为一个算术表达式，算出来正好等于该 WOM 编码的单个 bit 利用率）。我们最开始给出了一种 2 × 2 / 3 的 WOM 编码，紧接着把它扩展为了一类 k × (2<sup>k – 2</sup> + 1)  / (2<sup>k</sup> – 1) 的 WOM 编码，其中 k 是任意大于等于 2 的正整数。随后，我们进一步把它扩展为了一类 k × ((r – (2<sup>k</sup> – 1)) · s)  / (r · (k + s)) 的 WOM 编码。但我们旋即指出，这样的扩展虽然会带来更高的空间利用率，却因为过于庞大而难以用于实际。</p>
<p>所以，我们转而开始研究另一类更具实际意义，同时也更加困难的问题。不妨用 w(k, t) 来表示所有可行的 k × t / n 当中最小的 n 。那么，当各种正整数 k 和各种正整数 t 组合在一起时， w(k, t) 的值各是多少呢？首先， 2 × 2 / 3 的可行性说明了 w(2, 2) ≤ 3 。紧接着，我们证明了，当 t ≥ 3 时， w(2, t) ≥ t + 2 。随后，我们构造性地证明了 w(k, t<sub>1</sub> + t<sub>2</sub>) ≤ w(k, t<sub>1</sub>) + w(k, t<sub>2</sub>) 。利用 w(2, 1) ≤ 2 以及 w(2, 2) ≤ 3 ，我们得出了 w(2, 3) ≤ 5, w(2, 4) ≤ 6, w(2, 5) ≤ 8 。另外，我们不加证明地给出了两个显然成立的结论： w(2, 1) ≥ 2 ，以及 w(2, 2) ≥ 3 。综合所有这些信息，我们得到：</p>
<ul>
<li>w(2, 1) = 2</li>
<li>w(2, 2) = 3</li>
<li>w(2, 3) = 5</li>
<li>w(2, 4) = 6</li>
<li>w(2, 5) = 7 或 8</li>
</ul>
<p>最后，我们给出了一种 2 × 5 / 7 的 WOM 编码，从而证明了 w(2, 5) = 7 。</p>
<p>寻找 w(k, t) 的精确值果然不是一件易事。我们费了好大的劲儿，结果不但完全没动 k &gt; 2 的情况，就连 k = 2 的情况也只搞出了 5 个准确值。当然，所有的 w(1, t) 显然都等于 t ，所有的 w(k, 1) 显然都等于 k ，因为它们太平凡了，我们一直没提。除此之外，我们能不能再搞出几个新的准确值来呢？</p>
<p>由于 w(3, 1) = 3 ，这说明，要想写入 1 次 3 个 bit 的数据，存储器里至少需要留有 3 个数字 0 。据此容易得出， w(3, 2) ≥ 5 。这是因为，如果存储器里只有 4 个 bit 的话，为了给第 2 次写入数据留下足够的空间，不管第 1 次写入的是什么，我们都最多只能使用 4 个 0 中的 1 个 0 。然而， C(4, 0) + C(4, 1) = 5 &lt; 2<sup>3</sup> ，这说明，最多只用 4 个 0 中的 1 个 0 ，无法表达出 2<sup>3</sup> 种不同的值。因此， w(3, 2) 至少是 5 。</p>
<p>另一方面，只需要简单地把 k<sub>1</sub> × t / n<sub>1</sub> 和 k<sub>2</sub> × t / n<sub>2</sub> 连接起来使用，我们便能得到 (k<sub>1</sub> + k<sub>2</sub>) × t / (n<sub>1</sub> + n<sub>2</sub>) 。这说明， w(k<sub>1</sub> + k<sub>2</sub>, t) ≤ w(k<sub>1</sub> , t) + w(k<sub>2</sub>, t) 。（注意，这和之前的 w(k, t<sub>1</sub> + t<sub>2</sub>) ≤ w(k, t<sub>1</sub>) + w(k, t<sub>2</sub>) 是两个不同的结论。）由于 w(1, 2) = 2 ， w(2, 2) = 3 ，因而 w(3, 2) ≤ 5 。结合上一段的结论，我们就得到了， w(3, 2) = 5 。</p>
<p>类似地，由于 C(5, 0) + C(5, 1) = 6 &lt; 2<sup>4</sup> ，这说明 w(4, 2) ≥ 6 ；另一方面， w(4, 2) = w(2 + 2, 2) ≤ w(2, 2) + w(2, 2) = 3 + 3 = 6 。因此， w(4, 2) = 6 。</p>
<p>我们还能继续把 w(5, 2) 的准确值给搞出来吗？试试看吧。由于 C(6, 0) + C(6, 1) = 7 &lt; 2<sup>5</sup> ，这说明 w(5, 2) ≥ 7 。事实上，由于 C(7, 0) + C(7, 1) + C(7, 2) = 29 &lt; 2<sup>5</sup> ，这说明 w(5, 2) ≥ 8 。另一方面， w(5, 2) = w(2 + 3, 2) ≤ w(2, 2) + w(3, 2) = 3 + 5 = 8 。因此， w(5, 2) = 8 。</p>
<p>这条路还能走多远？让我们继续。由于 C(8, 0) + C(8, 1) + C(8, 2) = 37 &lt; 2<sup>6</sup> ，这说明 w(6, 2) ≥ 9 。另一方面， w(6, 2) = w(2 + 4, 2) ≤ w(2, 2) + w(4, 2) = 3 + 6 = 9 。因此， w(6, 2) = 9 。</p>
<p>难不成我们能把所有的 w(k, 2) 的准确值都搞出来？由于 w(1, 2) + w(6, 2) = w(2, 2) + w(5, 2) = w(3, 2) + w(4, 2) = 11 ，因此我们只能得出 w(7, 2) ≤ 11 。要是 C(10, 0) + C(10, 1) + C(10, 2) + C(10, 3) &lt; 2<sup>7</sup> ，我们就能说明 10 个 bit 的空间不够， w(7, 2) 的准确值也就出来了。只可惜， C(10, 0) + C(10, 1) + C(10, 2) + C(10, 3) = 176 &gt; 2<sup>7</sup> 。刚才的那条路到这里就被堵死了。</p>
<p>在《怎样重复使用一次写入型存储器》中， Ronald Rivest 和 Adi Shamir 说道：“对于较小的 k 和 t ，我们能推导出 w(k, t) 的值，如下表所示。我们尚不知道表中空白处的准确值。”</p>
<table>
<tr>
<td>k  ╲  t</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td> </td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>5</td>
<td>7</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>6</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>8</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>9</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
</table>
<p>这个表中的每一项的来历，都是我们刚才讲过的。呃……等等……好像并不是这样…… w(3, 3) 是怎么来的？为什么 w(3, 3) = 7 ？好像就只有这一项是怎么来的我们还不太清楚。</p>
<p>我们首先证明 w(3, 3) ≥ 7 。由于 w(3, 2) = 5 ，这说明，要想写入 2 次 3 个 bit 的数据，存储器里至少需要留有 5 个数字 0 。如果存储器里只有 6 个 bit 的话，为了给后 2 次写入数据留下足够的空间，不管第 1 次写入的是什么，我们都最多只能使用 6 个 0 中的 1 个 0 。然而， C(6, 0) + C(6, 1) = 7 &lt; 2<sup>3</sup> ，这说明，最多只用 6 个 0 中的 1 个 0 ，无法表达出 2<sup>3</sup> 种不同的值。因此， w(3, 3) 至少是 7 。</p>
<p>但是，不管使用 w(k<sub>1</sub> + k<sub>2</sub>, t) 的构造法，还是 w(k, t<sub>1</sub> + t<sub>2</sub>) 的构造法，我们都只能得出 w(3, 3) ≤ 8 。怎么办呢？别忘了，之前我们还讲过很多其他 WOM 编码，比如一类 k × (2<sup>k – 2</sup> + 1) / (2<sup>k</sup> – 1) 的 WOM 编码。当 k = 3 时，它就成为了一种 3 × 3 / 7 的 WOM 编码。因此，我们有 w(3, 3) ≤ 7 。结合上一段的结论，我们就得到了， w(3, 3) = 7 。 Ronald Rivest 和 Adi Shamir 列出的表格里的所有项，至此就全部解说完毕了。</p>
<p> </p>
<p>显然，对 w(k, t) 的探讨远未就此结束，我们还留下了很多的未解之谜。不仅如此， w(k, t) 这个记号本身也还可以推广，比如 k 甚至不一定是整数。在实际应用中，每次写入的数据量并不总是满满的 k 个 bit 。假如我们想要用打孔卡片或者打孔纸带记录英文句子，那么每次写入的就是 26 个英文字母中的一个，数据量也就是 log<sub>2</sub>26 了。容易证明，为了重复使用 2 次纸带，每次写入的都是 26 个字母之一，只用 6 个 bit 的空间是不够的。 Ronald Rivest 和 Adi Shamir 则给出了一种只用 7 个 bit 的方案。为了方便地表示出编码方案，他们把这 26 字母排成了下面这个表格：</p>
<table>
<tr>
<td>A</td>
<td>H</td>
<td>G</td>
<td>G</td>
<td>F</td>
<td>Y</td>
<td>L</td>
<td>w</td>
<td>E</td>
<td>Z</td>
<td>Y</td>
<td>r</td>
<td>X</td>
<td>f</td>
<td>p</td>
<td>n</td>
<td>D</td>
<td>W</td>
<td>V</td>
<td>z</td>
<td>U</td>
<td>d</td>
<td>j</td>
<td>o</td>
<td>T</td>
<td>w</td>
<td>k</td>
<td>e</td>
<td>l</td>
<td>t</td>
<td>d</td>
<td>u</td>
</tr>
<tr>
<td>C</td>
<td>S</td>
<td>R</td>
<td>c</td>
<td>Q</td>
<td>i</td>
<td>o</td>
<td>z</td>
<td>P</td>
<td>p</td>
<td>i</td>
<td>h</td>
<td>u</td>
<td>e</td>
<td>x</td>
<td>y</td>
<td>O</td>
<td>z</td>
<td>s</td>
<td>j</td>
<td>s</td>
<td>n</td>
<td>i</td>
<td>w</td>
<td>v</td>
<td>c</td>
<td>q</td>
<td>g</td>
<td>f</td>
<td>k</td>
<td>b</td>
<td>m</td>
</tr>
<tr>
<td>B</td>
<td>N</td>
<td>M</td>
<td>z</td>
<td>L</td>
<td>b</td>
<td>g</td>
<td>m</td>
<td>K</td>
<td>u</td>
<td>t</td>
<td>b</td>
<td>n</td>
<td>g</td>
<td>f</td>
<td>w</td>
<td>J</td>
<td>w</td>
<td>r</td>
<td>h</td>
<td>k</td>
<td>v</td>
<td>x</td>
<td>y</td>
<td>m</td>
<td>j</td>
<td>p</td>
<td>s</td>
<td>o</td>
<td>q</td>
<td>c</td>
<td>i</td>
</tr>
<tr>
<td>I</td>
<td>k</td>
<td>m</td>
<td>q</td>
<td>l</td>
<td>c</td>
<td>k</td>
<td>u</td>
<td>w</td>
<td>t</td>
<td>e</td>
<td>o</td>
<td>s</td>
<td>d</td>
<td>j</td>
<td>v</td>
<td>u</td>
<td>d</td>
<td>b</td>
<td>f</td>
<td>g</td>
<td>e</td>
<td>t</td>
<td>p</td>
<td>y</td>
<td>x</td>
<td>n</td>
<td>l</td>
<td>h</td>
<td>r</td>
<td>z</td>
<td>a</td>
</tr>
</table>
<p>这个表格一共有 4 行，每行的编号分别是 00, 01, 10, 11 ；这个表格一共有 32 列，每列的编号分别是 00000, 00001, 00010, …, 11110, 11111 。每个位置上的字母是什么，则对应的行号与列号相连后，所得的 7 位 01 串就对应哪个字母。其中，大写字母表示第 1 次写入，小写字母表示第 2 次写入。例如， 0011000 表示的就是字母 T ，把它的左起第 1 位、第 2 位、第 5 位改为 1 之后，就能得到 1111100 ，表示的是字母 h 。</p>
<p>WOM 编码是一个很有趣的课题。最后，我们再介绍两种有趣的 WOM 编码，来结束这篇两万字的长文吧。</p>
<p>David Leavitt 给出了一种 log<sub>2</sub>5 × 3 / 5 的 WOM 编码，它可以重复 3 次使用 5 个 bit 的空间，每次写入的都是 5 个符号中的任意一个，其单个 bit 利用率约为 1.393 。不妨把这 5 个符号分别记作 a 、 b 、 c 、 d 、 e 。第 1 次写入时，用 10000 来表示符号 a ；第 2 次写入时，用 01001 和 00110 之一来表示符号 a ；第 3 次写入时，用 01111 、 10110 、 11001 之一来表示符号 a 。其他符号所对应的编码，则是由符号 a 的编码分别向右循环移动 1 位、 2 位、 3 位、 4 位所得。例如， 00110 表示 a ，那么 00011 就表示 b ， 10001 就表示 c ， 11000 就表示 d ， 01100 就表示 e 。对于符号 a 的另外 5 种编码，则也是用这种方法变成其他各个符号的编码。由于 01 串的长度 5 是一个质数，因此循环移动后得到的编码不会发生重复。</p>
<table>
<tr>
<td> </td>
<td>第 1 次写入</td>
<td colspan="2">第 2 次写入</td>
<td colspan="3">第 3 次写入</td>
</tr>
<tr>
<td>a 的编码</td>
<td>10000</td>
<td>01001</td>
<td>00110</td>
<td>01111</td>
<td>10110</td>
<td>11001</td>
</tr>
<tr>
<td>b 的编码</td>
<td>01000</td>
<td>10100</td>
<td>00011</td>
<td>10111</td>
<td>01011</td>
<td>11100</td>
</tr>
<tr>
<td>c 的编码</td>
<td>00100</td>
<td>01010</td>
<td>10001</td>
<td>11011</td>
<td>10101</td>
<td>01110</td>
</tr>
<tr>
<td>d 的编码</td>
<td>00010</td>
<td>00101</td>
<td>11000</td>
<td>11101</td>
<td>11010</td>
<td>00111</td>
</tr>
<tr>
<td>e 的编码</td>
<td>00001</td>
<td>10010</td>
<td>01100</td>
<td>11110</td>
<td>01101</td>
<td>10011</td>
</tr>
</table>
<p>可以验证，如果第 1 次写入的是 a ，第 2 次想把它改写成 b 、 c 、 d 、 e 都是有办法的；如果第 2 次写入的是 a （不管是哪种形式），第 3 次想把它改写成 b 、 c 、 d 、 e 都是有办法的。再考虑到所有的编码都是循环移动生成的，因此符号 a 能被顺利改写，所有符号都能被顺利改写了。</p>
<p>Frans Merkx 给出了一种 log<sub>2</sub>7 × 4 / 7 的 WOM 编码，它可以重复 4 次使用 7 个 bit 的空间，每次写入的都是 7 个符号中的任意一个，其单个 bit 利用率约为 1.604 。不妨把这 7 个符号分别记作 a 、 b 、 c 、 d 、 e 、 f 、 g 。 Frans Merkx 把它们写成了 7 组，每组三个符号：</p>
<table>
<tr>
<td>(a, b, d)</td>
<td>(a, c, g)</td>
<td>(a, e, f)</td>
<td>(b, c, e)</td>
<td>(b, f, g)</td>
<td>(c, d, f)</td>
<td>(d, e, g)</td>
</tr>
</table>
<p>可以验证，每个符号都正好出现在了三个不同的组里，并且对于任意两个符号，都有且仅有一个组同时包含它们。接下来，我们将给大家演示，通过选中越来越多的符号，如何一次又一次地表示新的符号。</p>
<ul>
<li>初始时，所有的符号都没有被选中，因此我们要表示谁就选中谁。</li>
<li>如果我们想表示一个新的符号，我们就选中唯一那个和已选中的符号以及这个新的符号共组的符号。如果我们把上一步已选中的符号记作 x ，把这一步想要表示的新符号记作 u ，那么我们这一步就选中那个唯一和 x 、 u 同组的符号 y 。</li>
<li>如果我们想再表示一个新的符号，又该怎么办呢？如果这个新的符号是 x ，那么我们就选中任意一个包含 y 但不包含 x 的组里的所有符号；如果这个新的符号是 y ，那么我们就选中任意一个包含 x 但不包含 y 的组里的所有符号；如果这个新符号是除了 x 、 y 的其他符号，那么我们就把这个新符号选中，同时选中唯一那个和 x 、 y 共组的符号（即上一步表示的符号）。不管怎么样，我们都选中了四个符号，其中三个符号形成一组，单独出来的符号就是我们要表示的符号。</li>
<li>如果我们想再表示一个新的符号，又该怎么办呢？假设上一步选中的符号是 p 、 q 、 r 、 s ，其中 p 、 q 、 r 是一组， s 是上一步表示的符号。如果我们要表示 p ，就把唯一那个和 p 、 s 同组的符号选中；如果我们要表示 q ，就把唯一那个和 q 、 s 同组的符号选中；如果我们要表示 r ，就把唯一那个和 r 、 s 同组的符号选中；如果我们要表示其他的符号，那这个符号一定没被选中，我们只需把别的符号都选中，只留下这个符号不选即可。</li>
</ul>
<p>这 7 个符号当中，我们究竟选了哪些符号，这可以用 7 个 bit 来表示。例如， 0100100 就表示我们选中了 b 、 e 这两个符号，别的符号都没选。利用上面给出的方法，我们可以重复四次利用这 7 个 bit ，每次都可以表示 a 、 b 、 c 、 d 、 e 、 f 、 g 这 7 个符号当中任意一个与上次所表示的符号不同的符号。解码时，我们只需要看看这 7 个 bit 里有多少个数字 1 。</p>
<ul>
<li>如果只有 1 个数字 1 ，它表示的就是这个数字 1 所对应的符号。</li>
<li>如果有 2 个数字 1 ，它表示的就是唯一与这两个数字 1 所对应的两个符号同组的符号。</li>
<li>如果有 4 个数字 1 ，对应的四个符号中一定有三个同组，剩下的那个符号就是它所表示的符号。</li>
<li>如果有 5 个数字 1 ，对应的五个符号一定形成了两个组，同在这两个组里的符号就是它所表示的符号。</li>
<li>如果有 6 个数字 1 ，它表示的就是唯一那个数字 0 所对应的符号。</li>
</ul>
<p>有一种几何方法可以直观地表示出这 7 个符号之间的关系。这里，每个符号都用一个点表示，同一组符号所对应的点则都在一条线上（中间那个圆也是一条过三点的线）。</p>
<p class="indent"><img alt="image placeholder" >
<p>可以验证，每条线上都有三个点，每个点都引出了三条线，并且任意两点之间都有且只有一条线。由于这个结构是射影几何里的经典结构，因此 Frans Merkx 的 WOM 编码也可以看作是射影几何的妙用。</p>
			 ]]></content>
<pubDate>2015-07-23T22:36:15+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6443</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ UyHiP 趣题：几乎所有数都能分解成若干个 3x · 4y 之和 ]]></title>
<link>http://www.matrix67.com/blog/archives/6481</link>
<content><![CDATA[ 
		<p>下面这个题目来自 <a href="http://www.brand.site.co.il/riddles/201507q.html">2015 年 7 月的 Using your Head is Permitted</a> 。假设集合 S 是由所有形如 3<sup>x</sup> · 4<sup>y</sup> 的数构成的，其中 x 和 y 都是非负整数。因而，集合 S 是一个无穷集合，其中最小的几个元素依次为 1, 3, 4, 9, 12, 16, 27, … 。如果某个正整数 n 能表示成集合 S 中的一个或多个不重复的数之和，我们就说 n 是集合 S 的一个子集和。例如， 23 就是 S 的一个子集和，因为 23 可以表示成 3 + 4 + 16 。然而， 6 就不是 S 的一个子集和。</p>
<p>求证：除了有限多个正整数以外，其他所有的正整数都是集合 S 的子集和。</p>
<p><span id="more-6481"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>首先我们证明，如果 n 是一个大于 9 的正整数，那么在集合 S 中一定存在一个小于 n 但大于 n / 2 的元素。不妨假设集合 S 中不小于 n 的最小元素是 t = 3<sup>a</sup> · 4<sup>b</sup> 。如果 b &gt; 0 的话，那么 3<sup>a + 1</sup> · 4<sup>b – 1</sup> = (3 / 4) · t &gt; t / 2 ≥ n / 2 就是一个满足要求的数；如果 b = 0 的话，考虑到 t ≥ n &gt; 9 ，因此 a 肯定至少是 3 ，于是 3<sup>a – 3</sup> · 4<sup>b + 2</sup> = (16 / 27) · t &gt; t / 2 ≥ n / 2 就是一个满足要求的数。</p>
<p>这说明，我们可以从任意一个大于 9 的正整数 n 里减去 S 中的某个介于 n 和 n / 2 的数，所得结果将会小于 n / 2 ；这个过程可以不断地继续下去，每次减去的数都不重复。最后，我们会得到某个小于等于 9 的数。由于 1 、 3 、 4 也都在 S 里（并且这三个数刚才没使用过），因而容易验证，任意一个小于等于 9 的数都可以继续被减到 0 或者 1 。</p>
<p>现在，把集合 S 里的所有数全都乘以 4 ，不妨把由此得到的新的集合记作 4S 。显然，集合 4S 里的数一定都在集合 S 里，并且根据刚才的结论，我们可以从任意一个形如 4n 的正整数出发，不断减去 4S 里的数，使得最后只剩下 0 或者 4 。由于 1 和 3 都不在 4S 里，因此这两个数刚才都没有用过。因而，如果最后剩下了一个 4 ，我们再从中减去 1 和 3 ，就能让它变成 0 了。这说明，一切形如 4n 的正整数都是集合 S 的子集和。</p>
<p>对于形如 4n + 1 的数，我们可以先在它的基础上减去 9 ；对于形如 4n + 2 的数，我们可以先在它的基础上减去 9 和 81 ；对于形如 4n + 3 的数，我们可以先在它的基础上减去 27 。这样一来，这些数也都变成 4 的整倍数了。我们就能像刚才那样，把它们拆成 S 中的元素之和，并且在此过程中不会再用到 9 、 81、 27 等数。这就证明了，所有大于等于 9 + 81 = 90 的正整数都是集合 S 的子集和。</p>
<p>利用计算机不难验证，不能成为子集和的数事实上只有五个，它们是 2 、 6 、 11 、 18 、 54 。</p>
			 ]]></content>
<pubDate>2015-08-03T15:12:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6481</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Keller 猜想与 12 维空间中的神构造 ]]></title>
<link>http://www.matrix67.com/blog/archives/6487</link>
<content><![CDATA[ 
		<p>在各种令人惊讶的数学事实当中，我最喜欢的类型之一便是，某个数学命题在二维空间、三维空间甚至四维空间当中都是成立的，但偏偏到了某个维度时，命题就不成立了。 Keller 猜想就是一个这样的例子。</p>
<p>同样大小的正方形平铺整个平面（比如像下图那样），则一定存在某些边与边完全贴合的相邻正方形。</p>
<p class="indent"><img alt="image placeholder" >
<p>类似地，同样大小的正方体平铺整个空间（比如像下图那样），则一定存在某些面与面完全贴合的相邻正方体。</p>
<p class="indent"><img alt="image placeholder" >
<p>1930 年， Ott-Heinrich Keller 猜测，或许这一点对于更高维度的空间都是成立的。也就是说， Ott-Heinrich Keller 猜测，对于任意正整数 n ≥ 2 都有，同样大小的 n 维立方体平铺整个 n 维空间，则一定有两个面与面完全贴合的相邻 n 维立方体。这就是著名的 Keller 猜想。</p>
<p>1940 年， Oskar Perron 证明了，当 n = 2, 3, 4, 5, 6 时， Keller 猜想确实是正确的。一切似乎都在正轨上。然而，到了 1992 年的时候，事情出现了转折： Jeffrey Lagarias 和 Peter Shor 构造了一个 n = 12 时的反例，从而推翻了 Keller 猜想。让我们来看一看 Lagarias 和 Shor 的神构造吧。为了方便起见，下面我们直接用“立方体”一词指代 n 维的广义立方体，“立方体的面”则代表 n 维立方体的 n – 1 维面。</p>
<p><span id="more-6487"></span> </p>
<p>考虑所有只用 0 、 1 、 2 、 3 四个数组成的 n 维坐标，这样的坐标一共有 4<sup>n</sup> 个。现在，从中选择其中的 2<sup>n</sup> 个坐标，使得每两个坐标都有至少一个位置上的数相差正好为 2 。把这些坐标当作立方体的中心，作出一个个边长为 2 的立方体。容易看出，这些立方体将会满足：</p>
<ul>
<li>任意两个立方体都不会有重合的部分；</li>
<li>即使这些立方体可以沿着各坐标轴方向 4 格 4 格地任意平移，任意两个立方体也仍然不会有重合的部分（本来相差 2 个单位的维度上仍然会差至少 2 个单位）；</li>
<li>这些立方体的总体积是 2<sup>n</sup> · 2<sup>n</sup> = 4<sup>n</sup> ，正好等于一个边长为 4 的大立方体的体积。</li>
</ul>
<p>因而，把这些立方体当作一个整体，沿着各坐标轴方向 4 格 4 格地平移，就能平铺整个空间了。不过，这样得到的平铺方案中，可能存在着完全贴合的相邻立方体。然而，如果我们选出的 2<sup>n</sup> 个坐标当中，每两个坐标之间不但有某个位置上的数正好相差 2 ，还有另外至少一个位置上的数也不同的话，那么相邻立方体就都是错开的了——即使平移之后，该错开的立方体仍然是错开的，因为 0 、 1 、 2 、 3 四个数当中的任意两个不同的数，不会因为它们各自加减了某些 4 的倍数而变得相同。</p>
<p>如果两个 n 维坐标满足，它们有至少一个维度上的坐标正好相差 2 ，而且还有至少一个维度上的坐标不同，我们就说这两个 n 维坐标是相容的。因此，为了构造出一个 n 维空间中 Keller 猜测的反例，我们只需要找出 2<sup>n</sup> 个由 0 、 1 、 2 、 3 四个数组成的 n 维坐标，使得里面的任意两个坐标都是相容的，</p>
<p>为了更好地说明上面这些话的意思，让我们来看一个 n = 3 时的例子。由 0 、 1 、 2 、 3 四个数组成的三维坐标一共有 4<sup>3</sup> = 64 个，我们选择以下 2<sup>3</sup> = 8 个：</p>
<ul>
<li>(0, 0, 0)</li>
<li>(2, 0, 1)</li>
<li>(1, 2, 0)</li>
<li>(0, 1, 2)</li>
<li>(2, 0, 3)</li>
<li>(3, 2, 0)</li>
<li>(0, 3, 2)</li>
<li>(2, 2, 2)</li>
</ul>
<p class="indent"><img alt="image placeholder" >
<p>注意到，上面这 8 个坐标中，每两个坐标都有至少一个位置上的数正好相差 2 。如果以它们为中心，作出一个个边长为 2 的立方体，你会发现不管从哪个方向上看，这些立方体排成的都是紧密的两层。因此，使用这种结构的组合体，就能平铺整个空间了。只可惜，在上面这 8 个坐标中， (2, 0, 1) 和 (2, 0, 3) 虽然有一个位置上正好相差 2 ，但在其他位置上的数都是相同的。因此，这两个坐标所对应的立方体就是完全贴合的。类似的情况还有 (1, 2, 0) 和 (3, 2, 0) ，以及 (0, 1, 2) 和 (0, 3, 2) 。因此，这 8 个坐标并不构成 n = 3 时 Keller 猜想的反例。不过， Lagarias 和 Shor 却以此为基础，成功构造出了 n = 12 时 Keller 猜想的反例。让我们暂时把 (2, 0, 3) 、 (3, 2, 0) 和 (0, 3, 2) 中的 0 替换成 0′ ，并且规定 0′ 和 0 是两个数值相等的不同元素。这样赖皮之后，这 8 个坐标暂时变得两两相容了：</p>
<ul>
<li>(0, 0, 0)</li>
<li>(2, 0, 1)</li>
<li>(1, 2, 0)</li>
<li>(0, 1, 2)</li>
<li>(2, 0′, 3)</li>
<li>(3, 2, 0′)</li>
<li>(0′, 3, 2)</li>
<li>(2, 2, 2)</li>
</ul>
<p>现在，我们要把它们变成 2<sup>12</sup> = 4096 个十二维坐标，使得所有坐标仍然是两两相容，并且里面不再有 0′ 这种东西。考虑 S<sub>0</sub> 、 S<sub>0′</sub> 、 S<sub>1</sub> 、 S<sub>2</sub> 、 S<sub>3</sub> 这么五个集合，每个集合里面都有若干个四维坐标。这五个集合的具体情况如下：</p>
<table>
<tr>
<td>S<sub>0</sub>
</td>
<td>S<sub>0′</sub>
</td>
<td>S<sub>1</sub>
</td>
<td>S<sub>2</sub>
</td>
<td>S<sub>3</sub>
</td>
</tr>
<tr>
<td>(0, 0, 0, 0)</td>
<td>(0, 3, 0, 3)</td>
<td>(1, 0, 0, 0)</td>
<td>(0, 2, 1, 1)</td>
<td>(1, 2, 1, 1)</td>
</tr>
<tr>
<td>(0, 0, 1, 2)</td>
<td>(1, 0, 1, 1)</td>
<td>(1, 0, 1, 2)</td>
<td>(1, 1, 3, 2)</td>
<td>(2, 1, 3, 2)</td>
</tr>
<tr>
<td>(0, 2, 1, 3)</td>
<td>(1, 1, 1, 3)</td>
<td>(1, 2, 1, 3)</td>
<td>(2, 3, 0, 3)</td>
<td>(3, 3, 0, 3)</td>
</tr>
<tr>
<td>(0, 2, 3, 0)</td>
<td>(1, 1, 3, 0)</td>
<td>(1, 2, 3, 0)</td>
<td>(3, 0, 2, 0)</td>
<td>(0, 0, 2, 0)</td>
</tr>
<tr>
<td>(0, 3, 3, 2)</td>
<td>(1, 3, 2, 3)</td>
<td>(1, 3, 3, 2)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>(1, 0, 2, 0)</td>
<td>(1, 3, 3, 1)</td>
<td>(2, 0, 2, 0)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>(2, 1, 0, 0)</td>
<td>(2, 2, 1, 1)</td>
<td>(3, 1, 0, 0)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>(2, 1, 1, 2)</td>
<td>(3, 0, 0, 1)</td>
<td>(3, 1, 1, 2)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>(2, 2, 2, 0)</td>
<td>(3, 0, 2, 2)</td>
<td>(3, 2, 2, 0)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>(2, 3, 0, 1)</td>
<td>(3, 1, 0, 3)</td>
<td>(3, 3, 0, 1)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>(2, 3, 2, 2)</td>
<td>(3, 2, 2, 3)</td>
<td>(3, 3, 2, 2)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>(3, 1, 3, 2)</td>
<td>(3, 2, 3, 1)</td>
<td>(0, 1, 3, 2)</td>
<td> </td>
<td> </td>
</tr>
</table>
<p>可以验证，这五个集合满足以下 5 个条件。</p>
<ol>
<li>对于 S<sub>0</sub> 、 S<sub>0′</sub> 、 S<sub>1</sub> 、 S<sub>2</sub> 、 S<sub>3</sub> 中的任意一个集合，里面的所有四维坐标都是两两相容的。</li>
<li>对于 S<sub>0</sub> 、 S<sub>0′</sub> 、 S<sub>1</sub> 、 S<sub>2</sub> 、 S<sub>3</sub> 中的任意两个集合，里面都没有相同的四维坐标。</li>
<li>S<sub>0</sub> 中的每一个坐标和 S<sub>2</sub> 中的每一个坐标相比，都有一个位置上正好相差 2 。</li>
<li>S<sub>0′</sub> 中的每一个坐标和 S<sub>2</sub> 中的每一个坐标相比，都有一个位置上正好相差 2 。</li>
<li>S<sub>1</sub> 中的每一个坐标和 S<sub>3</sub> 中的每一个坐标相比，都有一个位置上正好相差 2 。</li>
</ol>
<p>这五个集合显然不是凭空构造出来的，绝大部分都是根据某些规律生成的。抓住这些规律，可以大大简化我们的验证工作。注意到， S<sub>1</sub> 可以看作是把 S<sub>0</sub> 里的每一个坐标的首位按照 {0 → 1, 1 → 2, 2 → 3, 3 → 0} 的规则进行替换后得来的， S<sub>3</sub> 也可以看作是对 S<sub>2</sub> 里的每一个坐标进行同样的变换后得来的。因此，如果 S<sub>0</sub> 中的坐标两两相容，则 S<sub>1</sub> 中的坐标也就两两相容了；如果 S<sub>2</sub> 中的坐标两两相容，则 S<sub>3</sub> 中的坐标也就两两相容了；还有，如果 S<sub>0</sub> 和 S<sub>2</sub> 满足条件 3 ，则 S<sub>1</sub> 和 S<sub>3</sub> 也一定满足条件 5 。另外， S<sub>0′</sub> 又可以看作是把 S<sub>0</sub> 里的每一个坐标的首位按照 {0 → 1, 1 → 2, 2 → 3, 3 → 0} 的规则进行替换，再把末位按照 {0 → 3, 3 → 2, 2 → 1, 1 → 0} 的规则进行替换，最后把这两位交换之后得来的。因此，如果 S<sub>0</sub> 中的坐标两两相容，则 S<sub>0′</sub> 中的坐标也就两两相容了。有趣的是，对 S<sub>2</sub> 里的所有坐标进行同样的变换后，得到的集合正好是它自己。因此， S<sub>0</sub> 和 S<sub>2</sub> 一旦满足条件 3，则 S<sub>0′</sub> 和 S<sub>2</sub> 也就自动地满足条件 4 了。最终，我们真正需要验证的就只有条件 2 和条件 3 ，以及条件 1 中的 S<sub>0</sub> 和 S<sub>2</sub> 这两个集合。如果你感兴趣的话，不妨自己验证一下。</p>
<p>还记得刚才那 8 个赖皮之后暂时变得两两相容的三维坐标吗？现在，从中任取一个坐标，将各个位置上的数都替换成对应集合里的某个四维坐标，我们就能够得到各种各样的十二维坐标了。例如， S<sub>2</sub> 里面有 4 个四维坐标， S<sub>0′</sub> 里面有 12 个四维坐标， S<sub>3</sub> 里面有 4 个四维坐标，因此从 (2, 0′, 3) 出发，一共就可以派生出 4 × 12 × 4 = 192 个十二维坐标。照这样做下去，我们一共能派生出多少个十二维坐标呢？让我们来算一算。</p>
<ul>
<li>(0, 0, 0)  →  12 × 12 × 12 = 1728</li>
<li>(2, 0, 1)  →  4 × 12 × 12 = 576</li>
<li>(1, 2, 0)  →  12 × 4 × 12 = 576</li>
<li>(0, 1, 2)  →  12 × 12 × 4 = 576</li>
<li>(2, 0′, 3)  →  4 × 12 × 4 = 192</li>
<li>(3, 2, 0′)  →  4 × 4 × 12 = 192</li>
<li>(0′, 3, 2)  →  12 × 4 × 4 = 192</li>
<li>(2, 2, 2)  →  4 × 4 × 4 = 64</li>
<li>总计： 1728 + 576 × 3 + 192 × 3 + 64 = 4096</li>
</ul>
<p>这正好等于 2<sup>12</sup> 。下面我们证明，这 2<sup>12</sup> 个十二维坐标是两两相容的。</p>
<p>容易看出，对于任意一个三维坐标来说，由它派生出来的各个十二维坐标互相之间肯定是两两相容的。这是因为，如果两个不同的十二维坐标是由同一个三维坐标派生出来的，这就说明它们的前段、中段、后段分别取材于同样的三个集合，并且至少有一段取得有所不同；条件 1 保证了单看这一段的话两者是相容的，根据相容性的定义，整个十二维坐标也就是相容的了。</p>
<p>那么，两个不同的三维坐标所派生的十二维坐标，为什么也一定是相容的呢？首先，两个不同的三维坐标当中，肯定有某一个位置上的数相差为 2 ，由条件 3 到 5 可知，这一点会被继承下去；另外，这两个三维坐标当中肯定还有另外一个位置上有不同的元素，由条件 2 可知，这一点会被继承下去。至此，我们就得到了 n = 12 时 Keller 猜想的一个完整的反例。</p>
<p>显然，低维空间中的任何反例，都可以立即变成高维空间中的反例，我们只需要把低维空间中的反例一层一层地搭起来，每一层都和前一层错开一点即可。因此， n = 12 时的 Keller 猜想被推翻了，则 n ≥ 12 时的 Keller 猜想也就全被推翻了。</p>
<p>在同一篇论文中， Jeffrey Lagarias 和 Peter Shor 紧接着构造出了 n = 10 时 Keller 猜想的反例，背后的思想基本相同。 2002 年， John Mackey 给出了一个 n = 8 时的反例。这说明， n ≥ 8 时的 Keller 猜想全是错的。至此， Keller 猜想只剩下了一个遗留问题：当 n = 7 时， Keller 猜想是否成立。这个问题至今仍未解决。</p>
			 ]]></content>
<pubDate>2015-09-07T00:36:29+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6487</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：每个小点最后都会回到自己原来的位置上吗？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6504</link>
<content><![CDATA[ 
		<p>最近，来自 <a href="http://wavegrower.tumblr.com/post/126854522925/currents-if-i-had-the-time-i-would-check-if-one-of">wavegrower</a> 的一张 gif 动画红遍了 <a href="https://www.reddit.com/r/woahdude/comments/3hys1f/try_and_follow_one/">reddit</a> 。有人提出了这么一个问题：每个小点最后都会回到自己原来的位置上吗？注意，这些小点并不是沿着一个回路在运动，而是沿着三个交替出现的回路在运动。</p>
<p class="indent"><img alt="image placeholder" >
<p><span id="more-6504"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>答案是肯定的。 math 版上的 <a href="https://www.reddit.com/r/math/comments/3hz9u9/will_each_jellyfish_in_this_gif_eventually_end_up/cubw779">OmnipotentEntity</a> 给出了一个简短的证明。假设某个地方的小点出发后永远不会回到原地。由于小点的运动规律是三步一个周期，因此每三步之后从此处出发的小点将会拥有完全相同的命运——永远不会回到原地。既然从这里出发的小点会不断地发生有去无回的情况，那么总有一个时候小点会被用光，此时就再也没有小点能从这里出发了。但这与我们看到的实际情况相矛盾：每个地方的小点都是用之不竭的。</p>
<p>熟悉群论的朋友会很快发现，这个结论几乎是显然的。小点的每一步运动都形成了一个置换，三个置换的复合本质上也还是一个置换，而这个置换的足够多次幂一定会变成单位置换。这意味着，不但每个点都能回到自己原来的位置，而且所有点能同时回到自己原来的位置（后者可能需要更长的时间）。事实上，有限群中的任意一个元素都有一个有限的阶，因而如果某类变换操作能构成一个有限群的话，不断地执行某一个操作，或者不断地循环执行某几个操作，最后总有一个时刻你会发现，一切又都重新变回了原样。拿出一副新的扑克牌，每次洗牌时都把牌分成两半并把它们完美地交叉在一起，那么不断这样洗下去之后，整副牌总会在某个时候重新变得有序。找一个复原好了的魔方，循环执行几个固定的操作，魔方很快就会被彻底打乱，但最终一定会奇迹般地再次复原。</p>
			 ]]></content>
<pubDate>2015-09-08T04:31:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6504</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 怎样把一个立方体分成 54 个小立方体？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6513</link>
<content><![CDATA[ 
		<p>大家或许都听说过一个与正方形剖分相关的非常经典的问题：对于哪些正整数 n ，我们可以把一个正方形分割成 n 个小正方形（允许出现大小相同的小正方形）？答案是，除了 n = 2, 3, 5 以外，对于其他所有的 n ，把一个正方形分割成 n 个小正方形都是有可能的。对于 n = 1, 4, 6, 7, 8 的情况，分割方案如下图所示：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>对于更大的 n 呢？注意到，每次用横竖两条线把一个小正方形分成四个更小的小正方形后，我们都会让这个图形里的正方形数目增加 3 个。因此，我们只需要在 n = 6 的方案上增加两笔，就能得到一个 n = 9 的方案；只需要在 n = 7 的方案上增加两笔，就能得到一个 n = 10 的方案；只需要在 n = 8 的方案上增加两笔，就能得到一个 n = 11 的方案；只需要在 n = 9 的方案上增加两笔，就能得到一个 n = 12 的方案……于是，其他所有的情况都被我们解决了。</p>
<p><span id="more-6513"></span> </p>
<p>不过，你有没有想过，同样的问题搬到立方体上，答案又会如何呢？换句话说，对于哪些正整数 n ，我们可以把一个立方体分割成 n 个小立方体（允许出现大小相同的小立方体）？人们已经证明了一个和刚才类似的结论：除了有限多个 n 以外，对于其他所有的 n ，这个问题都是有解的。事实上，对于所有的正整数 n ≥ 48 ，把一个立方体分割成 n 个小立方体都是有可能的。</p>
<p>证明思路和刚才一样。在任意一种立方体剖分方案中，每次把一个小立方体分割成 8 个更小的立方体，整个剖分方案中的立方体个数都会净增 7 个。因此，为了证明上面给出的结论，我们只需要构造出 n = 48, 49, 50, 51, 52, 53, 54 时的剖分方案即可。不过，究竟该怎么构造，这就要比刚才更有挑战性了。</p>
<p>n = 50 时的方案是最好构造的。从初始时的立方体出发，每次选一个小立方体并把它分成 8 份，于是我们便会得到 1 + 7 + 7 + 7 + 7 + 7 + 7 + 7 = 50 个小立方体。</p>
<p>把立方体分成 3 × 3 × 3 = 27 个小立方体，并把其中 8 个小立方体合成一个大立方体，我们便能得到 n = 20 时的方案，进而可以得到 20 + 7 + 7 + 7 + 7 = 48 个小立方体。在 n = 20 时的方案中选择一个小立方体，并套用这个方案本身把它细分成 20 份，我们便能得到 n = 39 时的方案，进而可以得到 39 + 7 + 7 = 53 个小立方体。</p>
<p class="indent"><img alt="image placeholder" >
<p>把立方体分成 4 × 4 × 4 = 64 个小立方体，并把其中 27 个小立方体合成一个大立方体，我们便能得到 n = 38 时的方案，进而可以得到 38 + 7 + 7 = 52 个小立方体。</p>
<p class="indent"><img alt="image placeholder" >
<p>真正比较困难的就是构造 n = 49, 51, 54 时的方案了。前面的几个构造或多或少地都借鉴了正方形剖分问题的解法。利用这些构造，我们可以从初始时的 1 个立方体出发，不断地执行加 7 、加 19 、加 26 、加 37 四种操作之一。然而，这无论如何也变不出 n = 49, 51, 54 时的方案。因此，我们需要另辟蹊径。 n = 49 时的方案如下，它里面有 4 个边长为 1/2 的立方体， 9 个边长为 1/3 的立方体，以及 36 个边长为 1/6 的立方体。</p>
<p class="indent"><img alt="image placeholder" >
<p>n = 51 时的方案如下，它里面有 5 个边长为 1/2 的立方体， 5 个边长为 1/3 的立方体，以及 41 个边长为 1/6 的立方体。</p>
<p class="indent"><img alt="image placeholder" >
<p>n = 54 时的方案最为复杂，很长一段时间里，人们甚至认为这样的方案根本不存在。但是最终，它还是被构造出来了。它里面有 2 个边长为 3/8 的立方体， 4 个边长为 1/4 的立方体， 6 个边长为 1/2 的立方体，以及 42 个边长为 1/8 的立方体。</p>
<p class="indent"><img alt="image placeholder" >
<p>至此，我们就完整地证明了，对于所有的 n ≥ 48 ，满足要求的立方体剖分方案都是存在的。</p>
<p> </p>
<p>显然，这个问题还可以进一步扩展到更高维的空间。对于任意正整数 d ≥ 2 ，我们都可以问：能否找到某个正整数，使得对于所有大于等于该正整数的 n ，把 d 维立方体分割成 n 个小的 d 维立方体的方案都是存在的？如果能找到这样的正整数的话，那么这样的正整数最小是多少？不妨把这个最小的满足要求的正整数记作 c(d) 。我们现在已经知道了， c(2) 等于 6 ，并且 c(3) 很可能等于 48 。</p>
<p>容易证明，不管 d 是多少， c(d) 一定都是存在的。首先，我们来证明一个经典的数论结论：若 a 和 b 是两个互质的正整数，则对于所有的正整数 n ≥ a · b ，我们都能找到适当的非负整数 p 和 q ，使得 n = p · a + q · b 。</p>
<p>注意到，对于任意一个正整数 n ≥ a · b 都有， n, n – a, n – 2 · a, n – 3 · a, …, n – (b – 1) · a 是 b 个不同的正整数，并且它们除以 b 的余数互不相同。它们是 b 个不同的正整数，这很容易看出；但是，它们除以 b 的余数为什么互不相同呢？这是因为，如果存在 0 ≤ i &lt; j ≤ b – 1 使得 n – i · a 和 n – j · a 除以 b 的余数相同，这就说明 n – i · a 和 n – j · a 之差是 b 的倍数，即 j · a – i · a = (j – i) · a 是 b 的倍数。既然 a 与 b 互质，要想让 (j – i) · a 是 b 的倍数，必然得让 j – i 是 b 的倍数。但是， i 和 j 都是 0 到 b – 1 之间的数，因而 j – i 比 b 要小，它不可能是 b 的倍数，于是产生矛盾。</p>
<p>然而，除以 b 的余数只有 b 种不同的可能。这说明， n, n – a, n – 2 · a, n – 3 · a, …, n – (b – 1) · a 除以 b 的余数取遍了所有的可能。因此，我们必然能找到某个 0 ≤ p ≤ b – 1 ，使得 n – p · a 除以 b 的余数为 0 ，即 n – p · a 是 b 的整倍数。这样一来， n 就正好能被表示成 p · a + q · b 了。</p>
<p>回到立方体剖分的问题。从初始时的立方体出发，每次把一个小立方体分割成 2<sup>d</sup> 个更小的立方体，整个剖分方案中的立方体个数都会净增 2<sup>d</sup> – 1 个；每次把一个小立方体分割成 (2<sup>d</sup> – 1)<sup>d</sup> 个更小的立方体，整个剖分方案中的立方体个数都会净增 (2<sup>d</sup> – 1)<sup>d</sup> – 1 个。因此，当 n 为任何一个形如 1 + p · (2<sup>d</sup> – 1) + q · ((2<sup>d</sup> – 1)<sup>d</sup> – 1) 的数时（其中 p 、 q 均为非负整数），剖分方案都是存在的。然而， 2<sup>d</sup> – 1 和 (2<sup>d</sup> – 1)<sup>d</sup> – 1 显然是两个互质的数（前者的某个整倍数与后者相差 1 ），由刚才的数论结论立即可得，对于所有的 n &gt; (2<sup>d</sup> – 1)((2<sup>d</sup> – 1)<sup>d</sup> – 1) ，剖分方案都是存在的。</p>
<p>但是，对于更大的 d ， c(d) 的值具体是多少，这仍然是数学当中的未解之谜。</p>
<p> </p>
<p>这个问题最早是 1946 年由 N. J. Fine 和 I. Niven 在 The American Mathematical Monthly 上提出的，题目编号为 E724 。 Fritz Herzog 、 William Scott 、 Doris Rychener 、 Christoph Meier 、 Matthew Hudelson 都对问题的解答有不同程度的贡献。 Martin Gardner 在 Fractal Music, Hypercards and More: Mathematical Recreations from Scientific American Magazine 一书中指出 c(3) 的值就是 48 ，并列出了所有不满足要求的 n 值：</p>
<blockquote><p>2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 21, 23, 24, 25, 26, 28, 30, 31, 32, 33, 35, 37, 40, 42, 44, 47</p></blockquote>
<p>这一说法的来源不明。</p>
			 ]]></content>
<pubDate>2015-09-14T20:18:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6513</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 让你看到函数图象在无穷远处的样子 ]]></title>
<link>http://www.matrix67.com/blog/archives/6533</link>
<content><![CDATA[ 
		<p>y = x<sup>2</sup> 似乎把 y = x 远远地甩在了后面，但为何当 x 无穷大时，二者能同时到达无穷？当 x 从有限大变为无限大时， 1 / x 的函数值是怎样慢慢变成 0 的？ y = e<sup>x</sup>, y = x<sup>x</sup>, y = x! ，谁的函数值最先接近无穷？ y = ln x, y = x · ln x, y = √<span style="text-decoration: overline">x</span> ，谁的函数值最后接近无穷？下面这个有趣的方法能直观地展示出函数图象在无穷远处的样子，进而回答刚才这些看似毫无意义的问题。</p>
<p>当 x 从 -π/2 连续地增加到 π/2 时， x 的正切值将会从负无穷连续地增加到正无穷。因此，为了展示出 y = f(x) 在无穷远处的样子，我们可以画出 tan(y) = f(tan(x)) 在 (-π/2, π/2) × (-π/2, π/2) 上的图象，也就是 y = arctan(f(tan(x))) 在 (-π/2, π/2) × (-π/2, π/2) 上的图象。最后得到的结果是什么样的呢？让我们一起来看看吧。</p>
<p><span id="more-6533"></span></p>
<p><img alt="image placeholder" >
<p><img alt="image placeholder" >
<p><img alt="image placeholder" >
<p><img alt="image placeholder" >
<p><img alt="image placeholder" >
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2016-02-29T20:17:03+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6533</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ UyHiP 趣题：出现次数最多的诱导子图 ]]></title>
<link>http://www.matrix67.com/blog/archives/6536</link>
<content><![CDATA[ 
		<p>下面这道题目是 <a href="http://www.brand.site.co.il/riddles/201512q.html">Using your Head is Permitted 谜题站 2015 年 12 月的题目</a>。</p>
<p>若干个顶点（vertex）以及某些顶点对之间的边（edge）就构成了一个图（graph）。下面就是这篇文章里会用到的四个图。其中，第一个图是由 2 个顶点组成的路径（path），因而我们把它称作 P<sub>2</sub> ；第二个图是由 3 个顶点组成的路径，因而我们把它称作 P<sub>3</sub> 。第三个图是由 3 个顶点组成的一个环（cycle），因而我们把它称作 C<sub>3</sub> ；第四个图是由 4 个顶点组成的一个环，因而我们把它称作 C<sub>4</sub> 。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>选取图中的一个或多个顶点，同时选出这些顶点之间的所有边，得到的就是原图的一个“诱导子图”（induced subgraph）。在这篇文章中，我们只考虑那些连通的诱导子图。下面是一个有 6 个顶点的图，右边则列出了由它可以产生出来的所有连通诱导子图。注意，由于有些诱导子图不是连通的（比如只选择正上方的两个点和右下角的两个点，或者干脆只选择最左边那个点和最右边那个点），因而它们并没有在右边列出。在这些连通诱导子图里，很多图的本质都是相同的。比方说，第一行最后三个图和第二行前面四个图的本质是一样的，它们都是刚才我们介绍过的 P<sub>2</sub> 。当然，第一行的前六个图的本质也都是一样的，即由单个顶点构成的图，有时会被人们记作 K<sub>1</sub> 。观察最后一行的倒数第二个和倒数第三个图，你能看出这两个图的本质也一样吗？只不过，它们就没有什么固定的名字了。在这些连通诱导子图里，哪一种图出现的次数最多呢？答案就是 P<sub>3</sub> ，它一共出现了 8 次。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>我们的问题是：能否构造一个图，使得里面出现次数最多的连通诱导子图是 C<sub>3</sub> ？能否构造一个图，使得里面出现次数最多的连通诱导子图是 C<sub>4</sub> ？注意，如果两种连通诱导子图出现的次数一样多，那它们都不算出现次数<strong>最</strong>多的连通诱导子图。</p>
<p><span id="more-6536"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>最左边的那个名叫 K<sub>6</sub> 的图显然满足， C<sub>3</sub> 是里面出现次数最多的连通诱导子图。这是因为，从 K<sub>6</sub> 中任意选出 3 个顶点，得到的诱导子图都是 C<sub>3</sub> ；同时，由对称性可知，当 n 为任意一个 1 到 6 之间的固定整数时，从 K<sub>6</sub> 中随便选出 n 个顶点，得到的诱导子图都是本质相同的。而 C(6, 3) 比其他 C(6, n) 的值都更大，因而 C<sub>3</sub> 的出现次数最多。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>下面我们证明， C<sub>4</sub> 不可能成为某个图里出现次数最多的连通诱导子图。假设这样的图真的是存在的，不妨把它叫作图 G 。让我们用 P(G) 来表示图 G 中的所有形如 P<sub>3</sub> 的诱导子图所构成的集合。对于 P(G) 里的每一个图 x ，让我们用 S(x) 来表示，在图 G 里再选一个顶点加入 x 中，就能把 x 扩展成一个形如 C<sub>4</sub> 的诱导子图，这一共有多少种不同的方法。最后，我们用 X<sub>i</sub> 来表示，在 P(G) 里有多少个 x 会使得 S(x) = i 。利用这些记号，我们就可以表达出诱导子图 C<sub>4</sub> 的数量了：</p>
<p class="indent">#(C<sub>4</sub>) = Σ<sub>i</sub> X<sub>i</sub> · i / 4</p>
<p>式子中除以 4 的原因是，每个诱导子图 C<sub>4</sub> 都可以用 4 种不同的方法看作是由某个 P<sub>3</sub> 扩展而来的，因而每个诱导子图 C<sub>4</sub> 都被重复算了 4 次。</p>
<p>同时，我们还能表达出其他诱导子图的数量。例如，诱导子图 P<sub>3</sub> 的数量直接就等于</p>
<p class="indent">#(P<sub>3</sub>) = Σ<sub>i</sub> X<sub>i</sub></p>
<p>另外，对于 P(G) 里的每一个 x ，选出任意两种不同的扩展成 C<sub>4</sub> 的方案，并把这两种方案合并起来，我们就能得到一个有 5 个顶点的诱导子图。由于所选的两个新顶点之间有可能有一条边，也有可能没有边，因而这个诱导子图有可能是 K<sub>2, 3</sub> ，也有可能是 T<sup>+</sup> 。于是，我们有：</p>
<p class="indent">3 #(K<sub>2, 3</sub>) + #(T<sup>+</sup>) = Σ<sub>i</sub> X<sub>i</sub> · i (i – 1) / 2</p>
<p>其中， i (i – 1) / 2 表示从 i 个元素里选出 2 个的方案数。 #(K<sub>2, 3</sub>) 的前面有个系数 3 ，这也是因为每个 K<sub>2, 3</sub> 都会被重复计算 3 次。</p>
<p>好了，现在考虑下面这个式子：</p>
<p class="indent">  #(C<sub>4</sub>) – (0.5 #(P<sub>3</sub>) + 0.375 #(K<sub>2, 3</sub>) + 0.125 #(T<sup>+</sup>))<br>
= Σ<sub>i</sub> X<sub>i</sub> (i / 4 – (1 / 2 + i (i – 1) / 16))<br>
= Σ<sub>i</sub> X<sub>i</sub> (- i<sup>2</sup> / 16  + 5 i / 16 – 1 / 2)</p>
<p>这个式子相当于是用 C<sub>4</sub> 的数量减去 P<sub>3</sub> 、 K<sub>2, 3</sub> 和 T<sup>+</sup> 的加权平均数量（并且三者的权重之和为 1 ）。如果 C<sub>4</sub> 真的是出现次数最多的连通诱导子图，那么这个式子的结果应该是正的。但是， – i<sup>2</sup> / 16  + 5 i / 16 – 1 / 2 = – (1 / 16) (i – 5 / 2)<sup>2</sup> – 7 / 64 恒为负数，因此这个式子的结果应该是负的。于是产生了矛盾。</p>
<p> </p>
<p>我们采用了颇有些曲折的办法，最终证明了，在任何一个图的所有连通诱导子图当中， P<sub>3</sub> 、 K<sub>2, 3</sub> 和 T<sup>+</sup> 里面至少有一样出现得比 C<sub>4</sub> 更多。为什么我们不直接去证明，在任何一个图的所有连通诱导子图当中，某种图 H 的出现次数总会大于等于 C<sub>4</sub> 出现的次数呢？原因很简单：因为这样的图 H 根本不存在。考虑 G<sub>1</sub> = C<sub>4</sub> ， G<sub>2</sub> = K<sub>6, 6</sub> ，其中 K<sub>6, 6</sub> 代表一个由 12 个顶点构成的图，所有顶点平分为左右两组，左边的每个顶点和右边的每个顶点之间都有一条边。在 G<sub>1</sub> 的所有连通诱导子图当中，出现次数能和 C<sub>4</sub> 相比的只有  K<sub>1</sub> 、 P<sub>2</sub> 和 P<sub>3</sub> （它们也就是 G<sub>1</sub> 中除了 C<sub>4</sub> 本身外其余的所有连通诱导子图）。但在 G<sub>2</sub> 的所有连通诱导子图当中， K<sub>1</sub> 、 P<sub>2</sub> 和 P<sub>3</sub> 出现的次数都比 C<sub>4</sub> 少。 K<sub>1</sub> 显然出现了 12 次。 P<sub>2</sub> 显然出现了 6 × 6 = 36 次。任意选择左边的 2 个顶点和右边的 1 个顶点，或者任意选择左边的 1 个顶点和右边的 2 个顶点，都能得到诱导子图 P<sub>3</sub> ，因而它一共出现了 C(6, 2) × 6 + 6 × C(6, 2) = 180 次。最后，任意选择左边的 2 个顶点和右边的 2 个顶点，都能得到诱导子图 C<sub>4</sub> ，因而它一共出现了 C(6, 2) × C(6, 2) = 225 次。</p>
<p class="indent"><img alt="image placeholder" >
			 ]]></content>
<pubDate>2016-03-01T00:12:54+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6536</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用四个数学运算符号译出 EBCDIC 编码 ]]></title>
<link>http://www.matrix67.com/blog/archives/6559</link>
<content><![CDATA[ 
		<p>ASCII 编码已经是非常直观了。 65 号字符就是大写字母 A ， 66 号字符就是大写字母 B ，以此类推， 90 号字符就是大写字母 Z 。为了看出某个编码究竟对应字母表中的第几个字母，我们只需要用下面的函数关系即可：</p>
<p><code>f(x) = x - 64</code></p>
<p>整个函数关系极其简单，里面只包含一个数学运算符号。</p>
<p>当然，历史上也出现过很多非常不直观的字符编码方式。 EBCDIC 是由 IBM 提出的一种字符编码标准，它的编码方式十分古怪，可害苦了当年的那些程序员。据说，当年的程序员没有一个不痛恨 EBCDIC 的。因此， EBCDIC 也理所当然地成为了众人调侃的对象。 Wikipedia 上的 <a href="https://en.wikipedia.org/wiki/EBCDIC">EBCDIC</a> 页面甚至还专门有一节，讲述各种与 EBCDIC 有关的笑话。有一个经典的笑话说的就是，美国政府跑去 IBM ，想要研发一种数据加密标准，于是 EBCDIC 编码就诞生了。经典游戏 Zork 中， EBCDIC 也被用来形容艰涩难懂的文字：</p>
<blockquote><p>一个大房间里，各式各样笨重的机器在呼呼作响，电阻烧焦了的味儿扑鼻而来。其中一面墙上有三个按钮，形状分别是圆形、三角形和正方形。自然，这些按钮上方的说明文字都是用 EBCDIC 书写的……</p></blockquote>
<p><span id="more-6559"></span>那么， EBCDIC 编码究竟有多诡异呢？让我们来看看大写字母 A 到 Z 在 EBCDIC 中的编码吧。</p>
<table>
<tr>
<td> </td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>192</td>
<td>193</td>
<td>194</td>
<td>195</td>
<td>196</td>
<td>197</td>
<td>198</td>
<td>199</td>
<td>200</td>
<td>201</td>
<td>202</td>
<td>203</td>
<td>204</td>
<td>205</td>
<td>206</td>
<td>207</td>
</tr>
<tr>
<td> </td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
<td>P</td>
<td>Q</td>
<td>R</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>208</td>
<td>209</td>
<td>210</td>
<td>211</td>
<td>212</td>
<td>213</td>
<td>214</td>
<td>215</td>
<td>216</td>
<td>217</td>
<td>218</td>
<td>219</td>
<td>220</td>
<td>221</td>
<td>222</td>
<td>223</td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>224</td>
<td>225</td>
<td>226</td>
<td>227</td>
<td>228</td>
<td>229</td>
<td>230</td>
<td>231</td>
<td>232</td>
<td>233</td>
<td>234</td>
<td>235</td>
<td>236</td>
<td>237</td>
<td>238</td>
<td>239</td>
</tr>
</table>
<p>首先，你会注意到，这些字母的编码并不是连续的。 Z 的编码减去 A 的编码并不等于 25 ，而是等于 40 。把基于 ASCII 编码的程序移植到基于 EBCDIC 编码的系统上，就会因为这件事儿而引起不小的麻烦。另外，编码中的两处间隙的长度甚至也不是相同的。从 I 到 J ，编码跳过了 7 个数；从 R 到 S ，编码却跳过了 8 个数。</p>
<p>如果要写出大写字母在 EBCDIC 中的编码和在字母表中的顺序之间的数学关系，这想必是非常困难的。不过，你相信吗，有一种方法可以让我们用四个数学运算符号就把这个数学关系表达出来。具体地说，存在一个只包含四个数学运算符号的函数 g(x) ，使得把上表中用到的编码代入后，所得的函数值正好表示，编码所对应的字母是字母表中的第几个字母。例如， g(193) 就等于 1 ， g(233) 就等于 26 。这是怎么做到的呢？</p>
<p>这里所说的数学运算符号包括各种有名字的、能在科学计算器上找到的运算符号，比如加、减、乘、除、乘方、开方、取整、取模、取对数、取绝对值、取较大数、取较小数、取最大公约数、取最小公倍数，甚至是阶乘、三角函数、反三角函数、双曲函数等貌似更不可能派上用场的运算符号。</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>这是一个脑筋急转弯！下面的方法非常赖皮，但却完全符合题意！这个方法的核心思想就是两个字：查表！</p>
<p><code>g(x) =             ⌊ 26 25 24<br>
23 22 21 20 19 00 00 00 00 00<br>
00 00 00 18 17 16 15 14 13 12<br>
11 10 00 00 00 00 00 00 00 09<br>
08 07 06 05 04 03 02 01 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00<br>
00 00 00 00 00 00 00 00 00 00 00 ÷ 100<sup>x</sup> ⌋ mod 100</code></p>
<p>这里，除号前面是一个 468 位的大数，之前那个表格里的所有信息都写进了这个大数里。为了便于大家观察，我们把这个大数两位两位地分成一组，每 10 组一行。符号 ⌊ ⌋ 表示取下整，即不超过某个数的最大整数。 mod 100 表示取除以 100 后的余数。</p>
<p>这个问题改编自 <a href="https://www.research.ibm.com/haifa/ponderthis/challenges/December2015.html">IBM Ponder This 谜题站 2015 年 12 月的谜题</a>。在计算机算法中允许使用任意大的数（并假设单次运算的复杂度仍为常数级别），这是不符合现实的，同时也是非常赖皮的。如果允许这样赖皮的话，很多算法的理论复杂度都能改进到非常荒谬的程度。这里有一个更有意思的例子： <a href="http://www.matrix67.com/blog/archives/1209">http://www.matrix67.com/blog/archives/1209</a> 。</p>
			 ]]></content>
<pubDate>2016-03-02T19:25:56+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6559</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：怎样向别人证明两个图不同构？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6572</link>
<content><![CDATA[ 
		<p>若干个顶点（vertex）以及某些顶点对之间的边（edge）就构成了一个图（graph）。如果图 G 和图 H 的顶点数相同，并且它们的顶点之间存在着某种对应关系，使得图 G 中的两个顶点之间有边，当且仅当图 H 中的两个对应顶点之间有边，我们就说图 G 和图 H 是同构的（isomorphism）。直观地说，两个图是同构的，意思就是它们本质上是同一个图，虽然具体的画法可能不一样。下面的两个图就是同构的。其中一种顶点对应关系是： 1 – a, 2 – c, 3 – d, 4 – b, 5 – e, 6 – g, 7 – h, 8 – f 。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>目前，人们还没有找到任何高效的算法，能迅速判断出两个图是否同构。在普通计算机上，判断两个图是否同构，这需要花费大量的时间。因此，人们经常以图的同构为例，来解释复杂度理论和现代密码学中的诸多概念。</p>
<p>假设你家里的计算机十分强大，能很快判断出两个图是否同构，还能在两个图确实同构的情况下，给出一种顶点对应关系。但你的同桌家里的计算机却非常弱，没法做什么大型运算。课堂上，老师向全班展示了两个很复杂的图，不妨把它们叫作图 G 和图 H 。老师布置了一个特别的选做题：判断出这两个图是否同构。每个同学都可以提交答案，答案里只需要写“是”或者“不是”即可。按时提交答案并答对者，期末考试会获得 5 分加分；按时提交答案但答错了的，期末考试成绩将会倒扣 30 分；不参与此活动的同学，期末考试既不加分也不扣分。显然，每个同学都不敢随意提交答案，除非百分之百地能保证自己获得的答案是正确的。回到家后，借助家里的超级计算机，你很快判断出了这两个图是同构的。你给你的同桌发送了信息：“我已经算出来了，这两个图是同构的。”但是，你的同桌却回复说：“你不会是骗我的吧？”你打算怎样说服他，这两个图确实是同构的呢？</p>
<p><span id="more-6572"></span>你只需要把两个图的顶点对应关系发送给他即可。他家里的计算机非常弱，没法找出满足要求的顶点对应关系。但若有了一个顶点对应关系，验证其确实满足要求，这是非常容易的，几乎不需要什么计算量——只需要枚举图 G 里的顶点对，看看它们之间有边是否当且仅当图 H 中的对应顶点之间有边即可。完成验证之后，他就知道了，这两个图确实是同构的。</p>
<p>总结起来，刚才我们面对的是这样的困境：</p>
<ul>
<li>你拥有无限的计算能力。</li>
<li>对方的计算能力非常有限。</li>
<li>你想要向对方证明，图 G 和图 H 确实是同构的。</li>
</ul>
<p>判断两个图是否同构可能很难，但若给出一段证据后，很容易验证两个图确实同构，上述困境也就得以解决了。这就是复杂度理论中 NP 问题的大致意思。</p>
<p>但是，如果把两个图同构的证据直接交给你的同桌，你的同桌或许又会用同样的办法去帮助别人，最后搞得班上所有人都获得了加分，这就没意思了。有没有办法说服你的同桌，这两个图确实是同构的，但却又让他无法拿到这两个图同构的证据呢？也就是说，现在我们面对的是这样的困境：</p>
<ul>
<li>你拥有无限的计算能力。</li>
<li>对方的计算能力非常有限。</li>
<li>你想要向对方证明，图 G 和图 H 确实是同构的。</li>
<li>你不想泄露这两个图的顶点之间的对应关系。</li>
</ul>
<p>这看上去似乎是不可能实现的——不把顶点之间的对应关系告诉对方，怎样说服对方两个图确实是同构的呢？然而，这竟然是能做到的。整个过程分为很多轮进行。在每一轮里，你随机生成一个与图 G 同构的图 G′ 。如果图 G 和图 H 真的同构，那显然图 G′ 也与图 H 同构。然后，你把图 G′ 发送给对方。对方可以随机提出下面两个要求之一：提供 G′ 与 G 同构的证据，或者提供 G′ 与 H 同构的证据。不管对方提出的是哪个要求，你都可以放心大胆地把证据发给对方，这不会泄露图 G 和图 H 之间的对应关系。另外，如果图 G 和图 H 不是同构的，那么这两个要求你不可能都做得到；面对对方的抽查，总能如约作答的概率是很低很低的。很多轮过去后，对方便慢慢确信，图 G 和图 H 真的是同构的了。在现代密码学中，让对方相信命题的正确性，但又不泄露任何其他的信息，这就叫作“零知识证明”（zero-knowledge proof）。</p>
<p>现在，让我们再来看一种情境。去掉上述第四点要求，但把第三点要求改一下：</p>
<ul>
<li>你拥有无限的计算能力。</li>
<li>对方的计算能力非常有限。</li>
<li>你想要向对方证明，图 G 和图 H 确实是<strong>不</strong>同构的。</li>
</ul>
<p>你打算怎么办？注意，你的办法应该普遍适用于一切情况。在某些特定的情况下，你当然可以告诉对方，“这两个图显然不同构，因为它们的边数就不一样多”，但这不适用于两个图的边数一样多的情况。</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>很简单。每次让对方随机生成一个与图 G 同构的图或者与图 H 同构的图，并把它发送给你。每次你都可以准确地告诉对方，刚才发来的图是从图 G 变过来的，还是从图 H 变过来的。多试几次，对方便能确信，这两个图确实是不一样的。</p>
<p>上述所有例子都属于“交互式证明”（interactive proof）。第一个例子是确定性的交互式证明（deterministic interactive proof）。它也是最简单的一类交互式证明。第二个例子则是带有附加条件的交互式证明。也就是说，零知识证明是一种特殊的交互式证明。第三个例子则表明，对于有些问题来说，交互式证明的存在性并不是显然的（即使没有任何附加条件）。如果利用确定性的交互式证明，你能向别人说明问题的答案是肯定的，我们就说这个问题属于 dIP 集合。很容易证明， dIP = NP 。如果利用交互式证明（包括非确定性的交互式证明），你能向别人说明问题的答案是肯定的，我们就说这个问题属于 IP 集合。交互式证明理论的一个最主要的结论就是 IP = PSPACE ，其中 PSPACE 表示所有能用多项式的空间解决的问题。</p>
<p>第一个例子和第二个例子都是我早已听说过的例子。第三个例子以及与此相关的交互式证明理论则是我最近在 Introduction to the Theory of Computation 一书中看到的。它们应该都是复杂度理论中非常经典的例子。</p>
			 ]]></content>
<pubDate>2016-03-06T17:58:12+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6572</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：用 26 次机会找出任意一张对方想要的牌 ]]></title>
<link>http://www.matrix67.com/blog/archives/6584</link>
<content><![CDATA[ 
		<p>看守打算和 A 、 B 两名囚犯做一个游戏。首先，看守从一副牌中取出大小王，将剩余的 52 张牌洗好，并在桌子上从左至右地把它们摆成一排，每张牌都是正面朝上。然后，看守让囚犯 A 来到桌前，允许囚犯 A 观察牌面，并交换其中两张牌的位置。接着，看守将囚犯 A 关回牢房，把所有牌全都翻到背面朝上（但位置不变），让囚犯 B 来到桌前。看守随便报出一张牌的花色和点数（比如“梅花 3”），要求囚犯 B 找出这张牌。囚犯 B 每次可以翻开任意一张尚未翻开的牌，但一共只有 26 次机会。如果囚犯 B 在这 26 次机会之内找到了看守想要的牌，则两名囚犯赢得游戏，无罪释放；如果囚犯 B 翻开了 26 张牌之后，还没找到看守想要的牌，则两名囚犯输掉游戏，立即死刑。在整个游戏开始之前，两名囚犯可以商量一个策略；游戏开始后，两人就不能有任何其他形式的交流。果不其然，这又是一个关满了数学天才的监狱。两名囚犯碰头后，很快就商量出了一种必胜的策略。这种必胜的策略是什么？</p>
<p><span id="more-6584"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>两名囚犯可以约定一种用 1 到 52 给扑克牌进行编号的方案。于是，桌上的扑克牌就相当于是写有 1 到 52 的卡片形成的一个排列了。假设现在所有的牌都是背面朝上的。想一想，如果你翻开某张牌，看看牌上写的是几，然后就去翻左起第几张牌，并不断地这样做下去，最后的结果是什么？最后的结果是，你迟早会回到出发点。假如你翻开了左起第 5 张牌，牌上写的是 34 ；你又翻开了左起第 34 张牌，结果牌上写的是 18 ；你又翻开了左起第 18 张牌，结果牌上写的是 13 ……总有一个时候，你会翻到一张写着 5 的牌，于是你就回到了出发点，得到了一个“圈”。这个圈并不一定涵盖了桌上的所有牌，换句话说，这个圈的长度并不一定是 52 。那么，再随便翻开一张尚未涉及到的牌，并不断根据牌上的信息翻开下一张牌，最终又会得到一个新的圈……也就是说，不管桌上的扑克牌是怎样排列的，它都可以被分解成若干个这样的圈。</p>
<p>所以，倘若看守想要的牌的编号是 15 ，那么囚犯 B 就可以翻开左起第 15 张牌，然后让牌上的数指引他继续往下翻牌。只要 15 所在的圈的长度小于等于 26 ，囚犯 B 就能在 26 步之内翻到写有 15 的牌，从而赢得游戏。而囚犯 A 的任务就是，想办法交换其中两张牌，让任何一张牌所在的圈的长度都不超过 26 。这确实是总能办到的。如果左起第 a<sub>1</sub> 张牌上写有 a<sub>2</sub> ，左起第 a<sub>2</sub> 张牌上写有 a<sub>3</sub> ，以此类推，一直到左起第 a<sub>n</sub> 张牌上写有 a<sub>1</sub> ，那么交换左起第 a<sub>1</sub> 张牌和左起第 a<sub>k</sub> 张牌，结果会怎么样呢？注意到，左起第 a<sub>1</sub> 张牌上现在写的就是 a<sub>k+1</sub> 了，左起第 a<sub>k</sub> 张牌上现在写的就是 a<sub>2</sub> 了。于是，这个长度为 n 的圈会被打断成长度分别为 n – k + 1 和 k – 1 的两个小圈：</p>
<table style="text-align: left; border: 2px solid #eee;">
<tr>
<td style="border: none; border-right: 10px solid white; background-color: #eee;">
<ul>
<li>左起第 a<sub>1</sub> 张牌上写有 a<sub>k+1</sub>
</li>
<li>左起第 a<sub>k+1</sub> 张牌上写有 a<sub>k+2</sub>
</li>
<li>…… ……</li>
<li>左起第 a<sub>n-1</sub> 张牌上写有 a<sub>n</sub>
</li>
<li>左起第 a<sub>n</sub> 张牌上写有 a<sub>1</sub>
</li>
</ul>
</td>
<td style="border: none;background-color: #eee;">
<ul>
<li>左起第 a<sub>k</sub> 张牌上写有 a<sub>2</sub>
</li>
<li>左起第 a<sub>2</sub> 张牌上写有 a<sub>3</sub>
</li>
<li>…… ……</li>
<li>左起第 a<sub>k-2</sub> 张牌上写有 a<sub>k-1</sub>
</li>
<li>左起第 a<sub>k-1</sub> 张牌上写有 a<sub>k</sub>
</li>
</ul>
</td>
</tr>
</table>
<p>1 到 52 的排列中，长度超过 26 的圈最多只能有 1 个。适当选择 k 的值，便能把它变成两个长度均小于等于 26 的小圈。这样，囚犯 B 便能保证在 26 次之内找到看守想要的牌，两人也就必胜了。</p>
<p>这个题目是我在 <a href="https://www.reddit.com/r/math/comments/44h3tu/interesting_puzzle_from_msri_newsletter_prisoners/">reddit</a> 上看到的。</p>
			 ]]></content>
<pubDate>2016-03-24T20:42:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6584</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：如果每次只增加一个区域的话 ]]></title>
<link>http://www.matrix67.com/blog/archives/6655</link>
<content><![CDATA[ 
		<p>著名的四色定理（four color theorem）告诉我们，如果一个地图由若干个连通区域构成（没有飞地），那么在给每个区域染色时，为了让相邻区域的颜色不同，最多只需要四种颜色就足够了。不过，这个结论成立有一个条件：整个地图已经事先确定了。如果我们每次只增加一个区域的话呢？具体地说，如果每次你给一个区域染色之后，我再画出下一个区域，并且之前已经染好颜色的区域不能再修改了，那么四种颜色还足够吗？这里，我们假设，在染色时，你总是遵循一个非常朴素的贪心策略：用第一个合法的颜色给每个新的区域染色。下面这个例子告诉我们，在这些假设下，四种颜色就不够了，有时五种颜色是必需的。</p>
<p class="indent"><img alt="image placeholder" >
<p>我们的问题就是，在这些假设下，五种颜色就一定够吗？有没有可能构造出某个情况，使得六种颜色是必需的？有没有可能构造出某个情况，使得七种颜色是必需的？</p>
<p><span id="more-6655"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>事实上，对于任意的正整数 n ，我们都能构造出某个情况，使得 n 种颜色是必需的。下图显示的是 n = 6 的情况，我们很容易把它扩展到任意大的正整数 n 。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>你可以在这里看到更多有关于这个问题的讨论： <a href="http://www.iread.it/map_colors.php">http://www.iread.it/map_colors.php</a></p>
			 ]]></content>
<pubDate>2016-04-21T21:40:02+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6655</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 26 个比较概率大小的问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/6665</link>
<content><![CDATA[ 
		<p>你的数学直觉怎么样？你能凭借直觉，迅速地判断出谁的概率大，谁的概率小吗？下面就是 26 个这样的问题。如果你感兴趣的话，你可以先扫一遍所有的问题，再逐一阅读答案，看看你猜对了多少。这篇文章很长，你可以考虑把它加入书签，每天看几个问题。</p>
<p> </p>
<blockquote>
<p>1．A 、 B 、 C 、 D 四人玩扑克牌游戏， A 、 C 两人同盟， B 、 D 两人同盟。将除去大小王的 52 张牌随机分发给四人（每人获得 13 张牌）后，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．A 、 C 两人手中都没有梅花<br>
B．A 、 C 两人手中囊括了所有的梅花<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>A 、 C 两人手中都没有梅花，等价于 B 、 D 两人手中囊括了所有的梅花，它的概率与 A 、 C 两人手中囊括所有梅花的概率相同。因此，这个问题的答案显然是 C 。</p>
<p><span id="more-6665"></span> </p>
<blockquote>
<p>2．我给 10 个好朋友分别写了一封信，并把这 10 个人的地址分别写在了 10 个信封上。如果我随机地将这 10 封信装进 10 个信封里（每封信都装进了一个不同的信封里），下面哪种情况的可能性更大一些？</p>
<p class="indent">A．恰好有 9 封信装进了正确的信封<br>
B．所有 10 封信都装进了正确的信封<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>你或许会以为，全都装对的可能性很低，装错一个的可能性则略高一些。然而事实上，这道题的答案是 B 。原因非常简单：恰好有 9 封信装对，这是根本不可能的——如果其中 9 封信都装对了，剩下的那一封信肯定也装对了。</p>
<p>实际上， 10 封信的排列方式一共有 10! = 3628800 种，其中装对的信有 0, 1, 2, 3, …, 9, 10 封的情况数分别为 1334961, 1334960, 667485, 222480, 55650, 11088, 1890, 240, 45, 0, 1 。可以看到，绝大多数时候，这个数列里的数都是不断递减的；也就是说，装对的信越多，概率就越低，这个直觉确实是准确的。唯一的例外，就是这个数列的最后两项，其背后的原因正如刚才所说。</p>
<p>你或许发现了一个有趣的现象：数列的第二项正好比第一项小 1 。这并不是巧合。有一个普遍的规律是，假设把 n 封信装进 n 个信封里，那么当 n 为偶数时，装对 1 封信的情况数比全都装错的情况数少 1 ，当 n 为奇数时，装对 1 封信的情况数比全都装错的情况数多 1 。我们下面就来证明这一点。</p>
<p>假设把 n 封信装进 n 个信封里，全都装错的情况有 D<sub>n</sub> 种。那么，数列 D<sub>1</sub>, D<sub>2</sub>, D<sub>3</sub>, … 满足一个非常简单的递推关系： D<sub>n</sub> = (n – 1) (D<sub>n-1</sub> + D<sub>n-2</sub>) 。为什么呢？我们慢慢来分析。由于每封信都装错了，因此第 1 封信没有装进 1 号信封。无妨假设它装进了 2 号信封。那么，第 2 封信装到哪儿去了呢？如果第 2 封信正好装进了 1 号信封，那么剩下的 n – 2 封信就有 D<sub>n-2</sub> 种可能的装法。如果第 2 封信没有装进 1 号信封呢？情况就变成了这样：第 2, 3, 4, …, n 封信装进了编号分别为 1, 3, 4, …, n 的信封里，其中第 2 封信不在 1 号信封里，第 3 封信不在 3 号信封里，第 4 封信不在 4 号信封里……总之，这 n – 1 封信中，每封信都正好有一个禁放的信封。于是，这就构成了 D<sub>n-1</sub> 种可能的装法。当然，第 1 封信也有可能装进了 3 号信封里，也有可能装进了 4 号信封里……因此，我们就有 D<sub>n</sub> = (n – 1) (D<sub>n-1</sub> + D<sub>n-2</sub>) 。</p>
<p>在这个式子的左右两边同时减去 n · D<sub>n-1</sub> ，于是得到：</p>
<p class="indent">D<sub>n</sub> – n · D<sub>n-1</sub> = – (D<sub>n-1</sub> – (n – 1) · D<sub>n-2</sub>)</p>
<p>令 A<sub>n</sub> = D<sub>n</sub> – n · D<sub>n-1</sub> ，于是 A<sub>n</sub> 满足递推关系式：</p>
<p class="indent">A<sub>n</sub> = – A<sub>n-1</sub></p>
<p>可以验证：</p>
<p class="indent">A<sub>2</sub> = D<sub>2</sub> – 2 · D<sub>1</sub> = 1 – 0 = 1</p>
<p>于是有：</p>
<p class="indent">A<sub>n</sub> = (-1)<sup>n</sup></p>
<p>即 D<sub>n</sub> – n · D<sub>n-1</sub> = (-1)<sup>n</sup> 。而 n · D<sub>n-1</sub> 正好表示把 n 封信装进 n 个信封里恰好装对 1 封信的情况数。</p>
<p> </p>
<blockquote>
<p>3．桌子上有 A 、 B 两个不透明的盒子，盒子 A 里有 m 个白色小球和 1 个黑色小球，盒子 B 里有 n 个白色小球和 1 个黑色小球。你需要先从盒子 A 里随机取出一个小球，再从盒子 B 里随机取出一个小球。如果两个小球都是黑色的，那么你就获胜了。下面哪种情况下，你获胜的概率更大一些？</p>
<p class="indent">A．m = 5，n = 5<br>
B．m = 4，n = 6<br>
C．上述两种情况的获胜概率相同</p>
</blockquote>
<p>你或许会以为，反正都是 10 个白色小球，怎么放应该没关系吧。而事实上，在 A 、 B 两种情况下，获胜的概率还真的不一样。在情况 A 中，你获胜的概率为 (1/6) × (1/6) = 1/36 ；在情况 B 中，你获胜的概率为 (1/5) × (1/7) = 1/35 。因此，这个题目的答案是 B 。</p>
<p>如果我们把规则改为，先随机选择其中一个盒子，再从这个盒子中随机取出一个小球，取到黑色小球即获胜，那么情况 B 的获胜概率仍然会更大一些。在情况 A 中，你获胜的概率为 (1/2) × (1/6) + (1/2) × (1/6) = 1/6 ；在情况 B 中，你获胜的概率为 (1/2) × (1/5) + (1/2) × (1/7) = 6/35 。</p>
<p>如果你可以自己安排每个小球的位置（但黑白小球的总数不变），那么不管是在原游戏中还是在改版后的游戏中，为了让自己的胜率达到最大，你都应该在其中一个盒子里只放 1 个黑球，在另一个盒子里放入剩下的 1 个黑球和 10 个白球。这样的话，在原游戏中，你获胜的概率将达到 1 × (1/11) = 1/11 ；在改版后的游戏中，你获胜的概率将达到 (1/2) × 1 + (1/2) × (1/11) = 6/11 。</p>
<p> </p>
<blockquote>
<p>4．不透明的盒子里有 10 个白球和 1 个黑球，你的目标是从中取出黑球。每次，你可以从中随机取出一个小球，并观察它的颜色：如果是黑球，则达到目标，结束操作；如果是白球，则将小球放回盒子里，然后继续像这样随机取球，直到取出了黑球为止。下面哪种情况的可能性更大一些？</p>
<p class="indent">A．第 1 次就取到了黑球<br>
B．到第 4 次才取到黑球<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>这个题目的答案显然应该是 A 。若每次取出黑球的概率为 p ，则第 1 次就取到黑球的概率为 p ，到第 4 次才取到黑球的概率为 (1 – p) · (1 – p) · (1 – p) · p ，后者永远比前者更低。如果我们把第 n 次才取到黑球的概率记为 P<sub>n</sub> ，那么就有：</p>
<p class="indent">P<sub>n</sub> = (1 – p)<sup>n-1</sup> · p</p>
<p>然而，把 P<sub>1</sub>, P<sub>2</sub>, P<sub>3</sub>, … 全部累加起来的结果应该为 1 ，于是我们用概率论的方法得到公式：</p>
<p class="indent">(1 + (1 – p) + (1 – p)<sup>2</sup> + (1 – p)<sup>3</sup> + …) · p = 1</p>
<p>即：</p>
<p class="indent">1 + (1 – p) + (1 – p)<sup>2</sup> + (1 – p)<sup>3</sup> + … = 1 / p</p>
<p>令 x = 1 – p ，得到：</p>
<p class="indent">1 + x + x<sup>2</sup> + x<sup>3</sup> + … = 1 / (1 – x)</p>
<p>这正是无穷等比级数的求和公式。由于实数 p 必须在 0 到 1 之间，而 x = 1 – p ，因此上式中的 x 也必须在 0 到 1 之间。</p>
<p> </p>
<blockquote>
<p>5．不透明的盒子里有 10 个白球和 1 个黑球。 A 、 B 两人轮流从盒子里取球，每个人每次只能随机从中取出一个小球（取出的小球不再放回）。谁先取到那个黑球，谁就获得游戏的胜利。如果 A 先取，那么理论上，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．A 获得游戏的胜利<br>
B．B 获得游戏的胜利<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>这个题目的答案是 A 。不妨规定，即使有人取到了黑球，两人也继续往下取，直到把所有的小球都取光。整个游戏就可以等价地看作是，两人轮流取完所有的小球后，看看谁手中有那个黑球。由于 A 先取，因此最后 A 会取到 6 个小球， B 只能取到 5 个小球。所以，黑球在 A 手中的概率更大，等于 6/11 。</p>
<p>类似地，如果不透明的盒子里有 W 个白球和 B 个黑球，不断从里面取出小球（不再放回），那么不管 i 是多少（0 &lt; i ≤ W + B），第 i 次取到的是白球的概率都是 W / (W + B) ，第 i 次取到的是黑球的概率都是 B / (W + B) 。因为，这本质上相当于把所有的小球随机地排成一排，问第 i 个小球是白色或者黑色的概率。</p>
<p> </p>
<blockquote>
<p>6．不透明的盒子里有 2 个白球和 5 个黑球。地上还有足够多的白球和黑球。每次从盒子里随机取出两个小球，放在地上。如果刚才取出的两个小球都是白球，则从地上拿一个白球放入盒子；如果刚才取出的两个小球都是黑球，则从地上拿一个白球放入盒子；如果刚才取出的两个小球是一黑一白，则从地上拿一个黑球放入盒子。不断重复，直至盒子里只剩一个小球为止。那么，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．剩下的那个小球是白球<br>
B．剩下的那个小球是黑球<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>这是一个很赖皮的题目。它的答案是 B 。事实上，出现情况 A 的概率为 0 ，出现情况 B 的概率为 100% 。原因很简单。每次操作后，黑球的数量要么不变，要么减 2 ，所以黑球的奇偶性始终保持相同。初始时盒子里有奇数个黑球，今后盒子里就永远有奇数个黑球。所以，如果最后盒子里剩了 1 个小球，那它必然是黑球。</p>
<p> </p>
<blockquote>
<p>7．在一根木棒上随机选择两个点，并在这两个点处下刀，把木棒砍成三段。下面哪种情况的可能性更大一些？</p>
<p class="indent">A．这三段木棒能拼成一个三角形<br>
B．这三段木棒不能拼成一个三角形<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>这个题目选 B 。我们可以证明，这三段木棒能拼成三角形的概率是 1/4 。不妨把这根木棒的长度设为 1 ，两个分割点的位置分别记作 x 、 y ，则 x 和 y 都是 0 到 1 之间的随机数。那么，所有可能的 (x, y) 组合就对应了正方形 (0, 1) × (0, 1) 内的所有点。三段木棒能拼成三角形，当且仅当 (x, y) 落在了阴影部分。由于阴影部分占了总面积的 1/4 ，因此这三段木棒能拼成三角形的概率就是 1/4 。</p>
<p class="indent"><img alt="image placeholder" >
<p>这个题目还有很多变种。比如，如果先把木棒随机砍成两段，再把较长的那段木棒随机砍成两段，问这三段木棒能拼成一个三角形的概率是多少。这该怎么解呢？你或许会说，为何不像刚才那样，把第一个分割点和第二个分割点的位置分别记作 x 、 y ，然后套用刚才的面积大法？这次就不行了，因为 y 的值不再能独立而均匀地分布在 0 到 1 之间。但是，我们可以令 x 为第一个分割点在整根木棒上的比例，令 y 为第二个分割点在较长的那段木棒上的比例。举个例子， (x, y) = (1/3, 1/3) 的意思就是，先把整根木棒砍成 1 : 2 两段，再把较长的那段木棒砍成 1 : 2 两段。这样一来，所有可能的 (x, y) 组合就再一次均匀地对应了正方形 (0, 1) × (0, 1) 内的所有点。最终，三段木棒能拼成三角形，当且仅当 (x, y) 落在由 x · y &lt; 1/2, (1 – x) · y &lt; 1/2, x · (1 – y) &lt; 1/2, (1 – x) · (1 – y) &lt; 1/2 组成的交集区域里。利用定积分可以求出，这部分区域的面积占整个正方形面积的 2 · ln(2) – 1 ≈ 38.63% 。这就是答案。</p>
<p class="indent"><img alt="image placeholder" >
<p>著名的 Buffon 投针问题，标准解法之一也用到了这种模型。在地板上画一系列间隔为 1 厘米的平行直线，然后把一根 1 厘米长的针扔到地板上，它与直线有交点的概率是多少？令 x 为这根针的中心到离它最近的那条直线的距离，令 y 为这根针与平行线的夹角。所有可能的针的位置，就可以用所有可能的 (x, y) 组合来表示，它们正好对应了矩形 (0, 1/2) × (0, π/2) 内的所有点。其中，合法的区域为 y &lt; arccos(2x) ，它占矩形面积的 2 / π ≈ 63.66% 。这就是答案。</p>
<p class="indent"><img alt="image placeholder" >
<p>高中数学课本把这种解决概率问题的模型叫做“几何概型”。说到几何概型，最经典的可能要算下面这个例题。 A 、 B 两人约定好晚上 6:00 到 7:00 之间在公园门口见面。每个人都会从 6:00 到 7:00 这段时间当中随机挑选一个时间，并在这个时间到达公园门口。每个人都只愿意等待 15 分钟，也就是说，如果 15 分钟之后没有看见对方，那么就立即离开。那么，两人最终能见面的概率有多大？答案是 7/16 。</p>
<p> </p>
<blockquote>
<p>8．圆周上均匀分布着 100 个点。随便选择两个点连一条线段，再随便选择另外两个点连一条线段。那么，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．两条线段相交<br>
B．两条线段不相交<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>这个题目的答案是 B 。随便选择两个点，再随便选择另外两个点，本质上相当于先随便选择四个点，再决定把这四个点配成怎样的两对。对于任意四个点 A 、 B 、 C 、 D （在圆周上按此顺序排列）来说，我们都有三种不同的配对方案：① A – B, C – D ② A – C, B – D ③ A – D, B – C 。其中，只有方案 ② 对应的两条连线才会相交。因此，两条线段相交的概率是 1/3 。</p>
<p> </p>
<blockquote>
<p>9．不透明的盒子里有 1000 张纸条，上面分别写有 1, 2, 3, …, 1000。 A 从盒子里随机取出 100 张纸条，并把这 100 张纸条上的数从小到大排成一排。然后， B 从盒子里剩下的纸条中随机取出 1 张纸条，并看看这张纸条上的数在 A 那里排第几位。例如，如果 A 手中的数有 50 个比 B 取出的大，另外 50 个比 B 取出的小，那么 B 手中的数就排第 51 位。那么，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．B 手中的数排第 1 位<br>
B．B 手中的数排第 51 位<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>很多人的直觉都是，排第 1 可能性不大，排中间可能性更大。而实际上，考虑所有 101 个数的 101! 种排列方案，或者从 1000 个数里选 101 个数所产生的 P(1000, 101) 种排列方案， B 选的那个数将会等可能地出现在各个位置。因此，这个题目的答案是 C 。</p>
<p>如果你还想不明白的话，你干脆直接想成是， A 抽了 100 个数，然后再帮 B 抽了一个数，问帮 B 抽的这个数更有可能排第几。如果你还想不明白的话，你干脆直接想成是， A 抽了 101 个数，问最后抽出的这个数更有可能排第几。如果你还想不明白的话，你干脆直接想成是， A 选了 101 个数往空中一撒，问最后一个落地的数更有可能是排第几的数。</p>
<p> </p>
<blockquote>
<p>10．把一副洗好的牌（共 52 张）背面朝上地摞成一摞，然后依次翻开每一张牌，直到翻出第一张 A 。那么，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．翻开第 3 张牌时出现了第一张 A<br>
B．翻开第 4 张牌时出现了第一张 A<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>这个题目的答案是 A 。这个答案并不出人意料。你不妨考虑一个非常极端的情况：假设一副牌里只有三张牌，其中两张是 A ，另外一张是 2 。那么，洗好牌后，三张牌的顺序有 AA2, A2A, 2AA 三种（如果把两张 A 看作是两张不同的 A ，那么三张牌的顺序有 A<sub>1</sub>A<sub>2</sub>2, A<sub>2</sub>A<sub>1</sub>2, A<sub>1</sub>2A<sub>2</sub>, A<sub>2</sub>2A<sub>1</sub>, 2A<sub>1</sub>A<sub>2</sub>, 2A<sub>2</sub>A<sub>1</sub> 六种）。翻到第 1, 2, 3 张牌时出现第一张 A 的概率分别是 2/3, 1/3, 0 。</p>
<p>至于原题为什么选 A ，我们给出一个这样的解释。洗好牌后，从前往后四张 A 所在的位置一共有 C(52, 4) 种可能的情况，分别为 (1, 2, 3, 4), (1, 2, 3, 5), (1, 2, 3, 6), …, (49, 50, 51, 52) 。其中，形如 (3, ?, ?, ?) 的情况显然比形如 (4, ?, ?, ?) 的情况更多，因为前者的问号处可以有更丰富的取值。</p>
<p> </p>
<blockquote>
<p>11．把一副洗好的牌（共 52 张）背面朝上地摞成一摞，然后依次翻开每一张牌，直到翻出第一张 A 。那么，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．再下一张牌是黑桃 A<br>
B．再下一张牌是黑桃 2<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>很多人可能会认为，下一张牌是黑桃 2 的可能性更大，因为刚才翻出的首张 A 可能就是黑桃 A 。其实这种直觉是错误的。令人吃惊的是，这道题的答案是 C 。下一张牌是黑桃 A 的概率与下一张牌是黑桃 2 的概率一样大，它们都等于 1/52 。</p>
<p>为了说明这一点，我们不妨来看一种同样能实现绝对随机的另类洗牌方式：先把一副牌中的黑桃 A 抽出来，随机洗牌打乱剩下 51 张牌的顺序，然后把黑桃 A 插回这摞牌中（包括最顶端和最底端在内，共有 52 个可以插入的位置）。显然，黑桃 A 正好插到了这摞牌的首张 A 下面有 1/52 的可能性。根据同样的道理，首张 A 下面是黑桃 2 的概率也是 1/52 。事实上，任何一张牌都有可能出现在首张 A 的下面，它们出现的概率是相等的，都等于 1/52 。</p>
<p> </p>
<blockquote>
<p>12．把一副洗好的牌（共 52 张）背面朝上地摞成一摞。翻开最上面的那张牌，记住这张牌是什么颜色（红色还是黑色），然后将它背面朝上地放回原处。随机切一次牌（即把扑克牌随机分成上下两摞，把下面这摞牌叠在上面这摞牌的上面），然后再次翻开最上面的那张牌，记住这张牌是什么颜色（红色还是黑色）。那么，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．两次看到的牌的颜色相同<br>
B．两次看到的牌的颜色不同<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>答案很简单：选 B 。这是因为，切了一次牌之后，你刚才翻开的那张牌就不可能在最上面了。换句话说，再次翻开的牌将会等可能地是剩余的 51 张牌中的任何一张，其中有 26 张牌和你第一次翻开的牌颜色不同，但只有 25 张牌和你第一次翻开的牌颜色相同。</p>
<p> </p>
<blockquote>
<p>13．同时抛掷 10 枚硬币，出现下面哪种情况的可能性更大一些？</p>
<p class="indent">A．正面朝上的硬币数量为偶数<br>
B．正面朝上的硬币数量为奇数<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>答案是 C 。事实上，把 10 换成任意正整数，这个问题的答案都不会变——正面朝上的硬币个数是奇是偶的概率一样大。</p>
<p>让我们把这个问题先修改一下：同时抛掷 5 枚硬币，正面朝上的硬币数量为偶数的概率大，还是为奇数的概率大？有趣的是，新的问题突然有了一种非常简单的解法。我们可以把同时抛掷 5 枚硬币的结果分成六大类： 0 个正面 5 个反面、 1 个正面 4 个反面、 2 个正面 3 个反面、 3 个正面 2 个反面、 4 个正面 1 个反面、 5 个正面 0 个反面。我们把这六类情况分成三组：</p>
<ul>
<li>0 正 5 反， 5 正 0 反</li>
<li>2 正 3 反， 3 正 2 反</li>
<li>4 正 1 反， 1 正 4 反</li>
</ul>
<p>注意到，每一组里的前后两类情况出现的概率总是相同的，然而前面那类总是属于有偶数个正面的情况，后面那类总是属于有奇数个正面的情况。因而总的来说，有偶数个正面的情况和有奇数个正面的情况将会概率均等地出现。</p>
<p>回到原问题。如果是 10 枚硬币的话，又该怎么办呢？大家或许想要故技重施，但却发现这回不管用了。虽然 0 正 10 反和 10 正 0 反出现的概率仍然相等，但它们都是有偶数个正面的情况，这样就没法推出奇偶两种情况各占一半的结论了。不过，我们另有奇招。把这 10 枚硬币分成两组，每一组各有 5 枚硬币。根据刚才的结论，每组硬币里面出现偶数个正面和出现奇数个正面的概率是相同的，因而，同时抛掷这两组硬币后，检查两组硬币正面朝上的数量分别有多少，会产生“偶偶”、“偶奇”、“奇偶”、“奇奇”这四种等概率的组合。在第一种情况和最后一种情况中，最终正面朝上的硬币数量为偶数；在第二种情况和第三种情况中，最终正面朝上的硬币数量为奇数。可以看到，正面朝上的硬币数量是奇是偶的概率相等。</p>
<p>我们还有另一种更简单的方法来说明，同时抛掷 10 枚硬币后，正面朝上的硬币数量是奇是偶的概率的确相同。假设你已经抛掷了 9 枚硬币，正准备抛掷最后一枚硬币。不管前 9 枚硬币抛掷成啥样，最后这枚硬币的正反都将会起到决定性的作用，具体情况分为两种，视前 9 枚硬币的抛掷结果而定：</p>
<ul>
<li>如果最后一枚硬币是正面，总的正面个数就是偶数；如果最后一枚硬币是反面，总的正面个数就是奇数；</li>
<li>如果最后一枚硬币是正面，总的正面个数就是奇数；如果最后一枚硬币是反面，总的正面个数就是偶数。</li>
</ul>
<p>容易看出，不管是上述两种情况中的哪种情况，总的正面个数是奇是偶的概率都是相等的。因此，即使上述两种情况出现的概率不相等（当然，事实上是相等的），最终总的正面个数是奇是偶的概率也是相等的。</p>
<p> </p>
<blockquote>
<p>14．A 、 B 两人在玩掷硬币游戏，每个人都抛掷 10 次硬币，最后谁抛出的正面更多，谁就获胜。几轮游戏下来后， A 都获胜了， B 有些沮丧。 A 说：“要不这样吧，我们把游戏规则改一下。我允许你多抛掷一次硬币。也就是说，我仍然抛掷 10 次硬币，你却能抛掷 11 次硬币。但是，只有你抛掷出的正面次数严格大于我抛掷出的正面次数，才算你获胜；如果我们抛掷出的正面次数相同，那也算我获胜。”新的一轮游戏开始了，按照约定， A 抛掷了 10 次硬币， B 抛掷了 11 次硬币。理论上，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．A 获得游戏的胜利<br>
B．B 获得游戏的胜利<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>题目的答案是 C 。这是一个非常经典的问题，解决它的方法也有很多。我们介绍两种方法。</p>
<p>第一种方法如下。在新版游戏中，假设两人各自都已经抛掷了 10 次硬币，只待 B 抛掷最后一次了。此时，如果 B 的正面更多，那他就胜定了，游戏可以提前结束了。如果 B 的正面更少，那他就输定了，游戏也可以提前结束了。显然，这两种情况出现的概率相同。现在，只剩一种情况有待分析，即此时 B 的正面数量与 A 相同。那么，游戏结果将完全取决于 B 的最后一次抛掷：如果 B 抛掷出正面，胜；如果 B 抛掷出反面，败。而这两种情况出现的概率也是相同的。综上所述，新的游戏是公平的。</p>
<p>第二种方法如下。既然 B 比 A 多抛掷一次，那这就说明， B 的正面和反面不可能都没 A 多（否则 B 的硬币总数不可能比 A 多）。另外，由于 B 只比 A 多抛掷一次，那这就说明， B 的正面和反面不可能都比 A 多（否则 B 的硬币总数至少比 A 大 2 ）。综上所述，要么 B 的正面比 A 更多，要么 B 的反面比 A 更多。由于硬币本身是公正的，因此这两种情况出现的几率相等，它们各为 1/2 。但是， B 的正面比 A 更多就意味着 B 获胜了， B 的反面比 A 更多就意味着 B 的正面数量不比 A 多，即 A 获胜了（别忘了，平局算 A 获胜）。所以，两人各自获胜的概率都是 1/2 。</p>
<p> </p>
<blockquote>
<p>15．魔术师把一枚正常的硬币展示给观众看，然后说：“接下来，我会抛掷这枚硬币，每次它都将正面朝上。”观众听闻后议论纷纷，魔术师趁机迅速地把这枚正常的硬币换成了一枚两面都是正面的硬币。魔术师连掷 10 次硬币，次次正面朝上，赢得观众雷鸣般的掌声。其中一个观众不服气地说：“该不会你趁我们不注意，把硬币换成了两面都是正面的特殊硬币吧！如果你有本事的话，你给我们掷出一个‘正反正反……’的序列出来！”为了保住自己的颜面，魔术师只好把那枚正常的硬币变回手中，硬着头皮开始抛掷硬币。倘若魔术师抛掷硬币没有任何技巧，每次是正是反的概率相同，那么魔术师无限地抛掷下去，第一次出错更有可能出在什么地方？</p>
<p class="indent">A．该掷正面的时候掷出了反面<br>
B．该掷反面的时候掷出了正面<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>这个题目的答案是 A 。下面我们证明，因为该掷反面的时候掷出了正面而挂掉的概率，也就是在第偶数次抛掷时挂掉的概率，精确地等于 1/3 。容易得出，第 2 次就挂了的概率就是前 2 次精确地掷出“正正”序列的概率，它等于 1 / 2<sup>2</sup> 。类似地，到第 4 次才挂的概率就是前 4 次精确地掷出“正反正正”序列的概率，它等于 1 / 2<sup>4</sup> ；而到第 6 次才挂的概率则是前 6 次精确地掷出“正反正反正正”序列的概率，它等于 1 / 2<sup>6</sup>……所以，在第偶数次挂掉的概率是：</p>
<p class="indent">  1 / 2<sup>2</sup> + 1 / 2<sup>4</sup> + 1 / 2<sup>6</sup> + 1 / 2<sup>8</sup> + …<br>
= 1 / 4 + 1 / 4<sup>2</sup> + 1 / 4<sup>3</sup> + 1 / 4<sup>4</sup> + …<br>
= (1 + 1 / 4 + 1 / 4<sup>2</sup> + 1 / 4<sup>3</sup> + 1 / 4<sup>4</sup> + …) – 1<br>
= 1 / (1 – 1 / 4) – 1<br>
= 1 / 3</p>
<p>倒数第二步用到了无穷等比级数的求和公式（见本文中的第 4 题）。</p>
<p>其实，这个答案有一个非常直观的解释。想象 A 、 B 两人玩一个掷硬币游戏。两人轮流抛掷硬币，但 A 必须掷出正面， B 必须掷出反面，谁掷错了谁就立即输掉游戏。如果 A 先抛硬币，谁输掉的概率更大？那当然是 A 输掉的概率更大，因为他先掷嘛！</p>
<p>事实上，设 A 输掉的概率为 p ，我们可以巧妙地求出 p 来。怎样的情况下 A 才会输掉呢？如果 A 第一次就掷错了，他就直接输了，这有 1/2 的概率。如果 A 第一次掷对了，那么 B 必须也跟着掷对，走到这一步有 (1/2) × (1/2) = 1/4 的概率。此时，游戏又回到了出发点， A 输掉的概率又变回了 p 。于是，我们得到：</p>
<p class="indent">p = 1/2 + (1/4) · p</p>
<p>把它当作一个关于 p 的一元一次方程，解得 p = 2/3 。这就是我们想要的答案。我们将会在很后面的几个题目里继续用到这种技巧。</p>
<p>我们还有一种非常帅的方法来说明，为什么魔术师首次出错更容易错在把正面掷成了反面。把正面看作数字 1 ，反面看作数字 0 ，那么观众要求的目标序列就变成了 101010… 。如果在前面加一个小数点，这就变成了一个 0 到 1 之间的二进制小数 0.101010… ，它等于十进制中的 2/3 。而魔术师抛掷的硬币序列，则构成了一个 0 到 1 之间的随机数。如果某一次把 0 掷成了 1 ，就说明掷出的是一个比 2/3 更大的数；如果某一次把 1 掷成了 0 ，就说明掷出的是一个比 2/3 更小的数。显然，前者的概率是 1/3 ，后者的概率是 2/3 。</p>
<p>你意识到了吗？我们相当于用一枚公正的硬币，模拟出了一枚不公正的硬币。如果你想要一枚硬币，它有 2/3 的概率正面朝上，有 1/3 的概率反面朝上，但你手中只有一枚公正的硬币，你该怎么办呢？你可以像刚才那样，不断抛掷硬币，得出一个 0 到 1 之间的随机二进制小数。一旦发现这个二进制小数小于 2/3 ，就视最终结果为“正”；一旦发现这个二进制小数大于 2/3 ，就视最终结果为“反”。</p>
<p>当然，模拟这样一枚不公正的硬币，其实远不需要这么麻烦。我们可以连续抛掷 2 次硬币，抛出“正反”或者“反正”都视最终结果为“正”，抛出“正正”则视最终结果为“反”，抛出“反反”则此轮抛掷作废，重头再来。这种“分类讨论法”能成的原因是， 2/3 是一个有理数。如果我们要模拟一枚不公正的硬币，它有 1 / π 的概率正面朝上，有 1 – 1 / π 的概率反面朝上呢？此时，“分类讨论法”就不管用了。但是，刚才的“二进制小数法”依旧有效。不断抛掷硬币并记录抛掷结果， 1 代表正面， 0 代表反面，直至某次掷出的结果与 1 / π 的二进制小数不符。如果是 1 被掷成 0 了，则视最终结果为“正”；如果是 0 被掷成 1 了，则视最终结果为“反”。</p>
<p>如何用一种硬币去模拟另一种硬币，这是一个非常有趣的话题，里面大有文章可作。比方说，我们完全可以提出一个和刚才的问题正好相反的问题：如果你手里有一枚不公正的硬币（你不知道它的正反两面朝上的概率各是多少，你甚至不知道它的哪一面朝上的概率更大），如何才能把它当作一枚公正的硬币来使？办法有很多。比方说，考虑连续抛掷两次硬币后的结果：如果结果是一正一反，那么先正后反和先反后正的概率一定是相同的（即使这枚硬币是不公平的）。借助这一点，我们就有了下面这个方案：连续抛掷两次硬币，如果两次抛掷的结果是“正反”，就视最终结果为“正”；如果两次抛掷的结果是“反正”，就视最终结果为“反”；如果是其他情况，就重新再来。</p>
<p>如果把两种甚至更多种不同的硬币组合起来使用，在某些限制条件下模拟出某些特定的概率事件，这里面的水就更深了。这里有一个与此相关的问题，感兴趣的话不妨去看看： <a href="http://www.matrix67.com/blog/archives/6151">http://www.matrix67.com/blog/archives/6151</a> 。</p>
<p> </p>
<blockquote>
<p>16． A 、 B 两人为一件小事争执不休，最后决定用抛掷硬币的办法来判断谁对谁错。不过，为了让游戏过程更刺激，两人决定采用这样一种方案：连续抛掷硬币，直到最近三次硬币抛掷结果是“正反反”或者“反反正”。如果是前者，那么 A 获胜；如果是后者，那么 B 获胜。理论上，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．A 获得游戏的胜利<br>
B．B 获得游戏的胜利<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>乍看上去， B 似乎没有什么不同意这种玩法的理由，毕竟“正反反”和“反反正”的概率是均等的。连续抛掷三次硬币可以产生 8 种不同的结果，上述两种各占其中的 1/8 。况且，序列“正反反”和“反反正”看上去又是如此对称，获胜概率怎么看怎么一样。</p>
<p>不过，实际情况究竟如何呢？实际情况是，这个游戏并不是公平的—— A 的获胜概率是 B 的 3 倍！虽然“正反反”和“反反正”在一串随机硬币正反序列中出现的频率理论上是相同的，但别忘了这两个序列之间有一个竞争的关系，它们要比赛看谁先出现。一旦抛掷硬币产生出了其中一种序列，游戏即宣告结束。这样一来， B 就处于了一个非常窘迫的位置：不管什么时候，只要掷出了一个正面，如果 B 没赢的话， B 就赢不了了——在出现“反反正”之前， A 的“正反反”必然会先出现。</p>
<p>事实上，整个游戏的前两次硬币抛掷结果就已经决定了两人最终的命运。只要前两次抛掷结果是“正正”、“正反”、“反正”中的一个， A 都必胜无疑， B 完全没有翻身的机会；只有前两次掷出的是“反反”的结果， B 才会赢得游戏的胜利。因此， A 、 B 两人的获胜概率是三比一， A 的优势绝不止是一点。所以说，这道题目的正确选项为 A 。</p>
<p>这里有对此游戏更加深入的讨论： <a href="http://www.matrix67.com/blog/archives/6015">http://www.matrix67.com/blog/archives/6015</a> 。</p>
<p>似乎是还嫌游戏双方的胜率差异不够惊人， 2010 年， Steve Humble 和 Yutaka Nishiyama 提出了上述游戏的一个加强版。去掉一副扑克牌中的大小王，洗好剩下的 52 张牌后，一张一张翻开。一旦出现连续三张牌，花色依次是红黑黑，那么玩家 A 加一分，同时把翻开了的牌都丢掉，继续一张张翻没翻开的牌；类似地，一旦出现连续三张牌恰好是黑黑红，则玩家 B 得一分，弃掉已翻开的牌后继续。</p>
<p>容易看到，加强版游戏相当于是重复多次的掷硬币游戏，因而毫无疑问，在这个新游戏中，玩家 A 的优势还会进一步放大。电脑计算显示， A 获胜的概率高达 93.54% ， B 获胜的概率则只有可怜的 2.62% 。另外 3.84% 则是两人平手的概率。然而，即使是这样，这个游戏看上去也会给人一种公平的错觉！</p>
<p>这个例子告诉我们，在赌博游戏中，直觉并不是准确的，求助概率论是很有必要的。</p>
<p>其实，概率论的诞生本来就和赌博游戏是紧紧联系在一起的。提到概率论的诞生，不得不提一位名叫 Antoine Gombaud 的法国作家。这人出生于 1607 年法国西部的一个小城市，他并不是贵族出身，但他却有着“骑士”的光辉头衔——不过那只是他自封的而已。他借用了一个自己笔下的人物形象名称，自封为 de Méré 骑士。后来，这个名字便逐渐取代了他的真名 Antoine Gombaud 。不过， de Méré 骑士并没有凭借自己的文学作品名扬天下，真正让他声名远扬的是他的赌博才能。而足以让他在历史上留名的，则是他对一个赌博游戏的思考。</p>
<p>在 17 世纪，法国赌徒间流行着一个赌博游戏：连续抛掷一颗骰子 4 次，赌里面是否会出现至少一个 6 点。这个游戏一直被视为是一个公平的赌博游戏，直到 1650 年左右， de Méré 在另一个类似的游戏中莫名其妙地输得四个荷包一样重。当时， de Méré 参加了这个赌博游戏的一个“升级版”：把两颗骰子连续抛掷 24 次，赌是否会掷出一对 6 点来。</p>
<p>de Méré 自己做了一番思考。同时抛掷两颗骰子出现一对 6 ，比抛掷一颗骰子出现 6 点要困难得多，前者的概率是后者的 1/6 。要想弥补这个减小了的概率，我们应当把两颗骰子连续抛掷 6 次。为了追上连续抛掷 4 次骰子出现一个 6 的概率，则应当把两颗骰子抛掷 24 次才行。 de Méré 果断地得出结论：在升级版游戏中出现一对 6 的概率，与传统游戏中出现一个 6 的概率是相等的，升级版游戏换汤不换药，与原来的游戏本质完全一样。</p>
<p>不过，这毕竟是不严格的直觉思维，事实情况如何还得看实战。在以前的游戏中， de Méré 总是赌“会出现 6 点”，经验告诉他这能给他带来一些细微的优势。于是这一回， de Méré 也不断押“会出现一对 6”。不料，这次他却赔得多赚得少，最终输了个精光。</p>
<p>这是怎么一回事儿呢？作为一个业余数学家， de Méré 感到里面有玄机。但是，凭借自己的数学知识，他没有能力解决这个难题。无奈之下，他只好求助当时的大数学家 Blaise Pascal 。</p>
<p>Pascal 可是真资格的数学家。他很快便意识到，这种问题的计算不能想当然，事实和直觉的出入可能会相当大。比方说， de Méré 的直觉就是有问题的：重复多次尝试确实能增大概率，但这并不是成倍地增加。抛掷一颗骰子出现 6 点的概率为 1/6 ，但这并不意味着抛掷骰子 4 次会出现一个 6 点的概率就是 1/6 的 4 倍。无妨想一个更极端的例子：按此逻辑，抛掷一颗骰子 6 次，出现至少一次 6 点的概率似乎就该是 6/6 ，也即 100% ，但这显然是不对的。如果抛掷骰子 6 次以上，出现一个 6 点的概率就会超过 100% ，这就更荒谬了。</p>
<p>看来，概率不能简单地加加减减，每一步推理都要有凭有据。 Pascal 考虑了游戏中所有可能出现的情况，算出了在新旧两种版本的游戏中，会出现一个（或一对） 6 点的概率分别是多少。</p>
<p>连续抛掷 4 次骰子，总共会产生 6<sup>4</sup> ，也就是 1296 种可能。不过在这里面，一个 6 点都没有的情况共有 5<sup>4</sup> ，也就是 625 种。反过来，至少有一个 6 点就有 1296 – 625 = 671 种情况，它占所有情况的 671 / 1296 ≈ 51.77% ，恰好比 50% 高出那么一点点。看来， de Méré 的经验是对的——众人公认的公平游戏并不公平，赌 6 点会出现确实能让他有机可乘。</p>
<p>那么，连续抛掷两颗骰子 24 次，能出现一对 6 的概率又是多少呢？这回计算的工程量就有点大了。两颗骰子的点数有 36 种组合，连抛 24 次则会有 36<sup>24</sup> ，大约是 2.245 × 10<sup>37</sup> 种情况。而 24 次抛掷中，从没产生过一对 6 点的情况数则为 35<sup>24</sup> ，大约为 1.142 × 10<sup>37</sup> 。可以算出，如果赌 24 次抛掷里会出现一对 6 ，获胜的概率是 49.14% 。又一个非常接近 50% 的数，只不过这次是比它稍小一些。</p>
<p>原来，升级版游戏并不是换汤不换药。两种游戏胜率虽然接近，但正好分居 50% 两边。这看似微不足道的差别，竟害得我们的“骑士”马失前蹄。</p>
<p>后来，这个经典的概率问题就被命名为“de Méré 问题”。在解决这个问题的过程中， Pascal 提出了不少概率的基本原理。因此， de Méré 问题常被认为是概率论的起源。</p>
<p>当然， de Méré 的故事多少都有一些杜撰的成分，大家或许会开始怀疑，在现今世界里，有没有什么还能玩得到的“伪公平游戏”呢？答案是肯定的。为了吸引玩家，赌场想尽各种花样精心设计了一个个迷魂阵一般的赌局。在那些最流行的赌博游戏中，庄家一方总是会稍占便宜；但游戏规则设计得如此之巧妙，以至于乍看上去整个游戏是完全公平，甚至是对玩家更有利的。“骰子掷好运”（chuck-a-luck）便是一例。</p>
<p>“骰子掷好运”的规则看上去非常诱人。每局游戏开始前，玩家选择 1 到 6 之间的一个数，并下 1 块钱的赌注。然后，庄家同时抛掷三颗骰子。如果这三颗骰子中都没有你选的数，你将输掉那 1 块钱；如果有一颗骰子的点数是你选的数，那么你不但能收回你的赌注，还能反赢 1 块钱；如果你选的数出现了两次，你将反赢 2 块钱；如果三颗骰子的点数都是你选的数，你将反赢 3 块钱。用赌博的行话来说，你所押的数出现了一次、两次或者三次，对应的赔率分别是 1:1 、 1:2 、 1:3 。</p>
<p>用于抛掷三颗骰子的装置很有创意。它是一个沙漏形的小铁笼子，三颗骰子已经预先装进了这个笼子里。庄家“抛掷”骰子，就只需要把整个沙漏来个 180 度大回旋，倒立过来放置即可。因此，“骰子掷好运”还有一个别名——“鸟笼”（birdcage）。</p>
<p>18 世纪英国皇家海军的水手间流行过一种叫做“皇冠和船锚”（Crown and Anchor）的赌博游戏，其规则与“骰子掷好运”一模一样。唯一不同之处只是骰子而已。普通骰子的六个面分别是 1 点到 6 点，而“皇冠和船锚”所用骰子的六个面则是六种不同的图案——扑克牌的黑、红、梅、方，再加上皇冠和船锚两种图案。之后，“赌博风”又蔓延到了商船和渔船上，“皇冠和船锚”也就逐渐走出了皇家海军的圈子。一般认为，这也就是“骰子掷好运”的起源了。现在，很多赌场都提供了“骰子掷好运”的赌博项目。</p>
<p>对玩家而言，这个游戏看上去简直是在白送钱：用三颗骰子掷出 6 个数中的一个，怎么也会有一半的概率砸中吧，那玩家起码有一半的时间是在赚钱，应当是稳赚不赔呀。其实，这是犯了和 de Méré 一样的错误——一颗骰子掷出玩家押的数有 1/6 的概率，并不意味着三颗骰子同时抛掷就会有 3/6 的概率出现此数。在抛掷三颗骰子产生的所有 6<sup>3</sup> 种情况中，玩家押的数一次没出现有 5<sup>3</sup> 种情况，所占比例大约是 57.87% 。也就是说，大多数时候玩家都是在赔钱的。</p>
<p>不过，考虑到赚钱时玩家有机会成倍地赢钱，这能否把输掉的钱赢回来呢？一些更为细致的计算可以告诉我们，即使考虑到这一点，游戏对玩家仍然是不利的：平均每赌 1 块钱就会让玩家损失大约 8 分钱。不过，我们还有另一种巧妙的方法，无需计算便可看出这个游戏对玩家是不利的。</p>
<p>这显然是一个没有任何技巧的赌博游戏，不管押什么胜率都是一样的。因此，不妨假设有 6 名玩家同时在玩这个游戏，这 6 个人分别赌 6 个不同的点数。此时玩家联盟的输赢也就足以代表单个玩家的输赢了。</p>
<p>假设每个人都只下注 1 块钱。抛掷骰子后，如果三颗骰子的点数都不一样，庄家将会从完全没猜中点数的三个人手中各赚 1 块，但同时也会赔给另外三人各 1 块钱；如果有两颗骰子点数一样，庄家会从没猜中点数的四个人那里赢得共 4 块，但会输给另外两人 3 块；如果三颗骰子的点数全一样，庄家则会赢 5 块但亏 3 块。也就是说，无论抛掷骰子的结果如何，庄家都不会赔钱！虽然一轮游戏下来有的玩家赚了，有的玩家亏了，但从整体来看这 6 名玩家是在赔钱的，因此平均下来每个玩家也是在不断输钱的。</p>
<p> </p>
<blockquote>
<p>17．同时抛掷 6 颗骰子，出现下面哪种情况的可能性更大一些？</p>
<p class="indent">A．不同数字的个数恰好为 4 个<br>
B．不同数字的个数为 1 、 2 、 3 、 5 或 6 个<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>这个题目的答案竟然是 A ，没想到吧！赌博游戏的胜率常常违反直觉，这道题目又是一个经典的例子。同时抛掷 6 颗骰子，一共会产生 6<sup>6</sup> = 46656 种情况。其中，不同数字的个数恰好为 4 个的情况有多少种呢？如果 6 颗骰子里只有 4 个不同的数字，那么有的数字出现了至少 2 次。事实上，各个数字出现的次数只有以下两种可能的分布类型：</p>
<ul>
<li>其中 1 个数字出现了 3 次，另外 3 个数字各出现了 1 次</li>
<li>其中 2 个数字各出现了 2 次，另外 2 个数字各出现了 1 次。</li>
</ul>
<p>前者一共有 C(6, 3) × C(6, 4) × 4! = 7200 种具体的情况，其中 C(6, 3) 表示出现了 3 次的数字究竟出现在了哪 3 次， C(6, 4) 表示这 4 个数字究竟是哪 4 个数字。后者一共有 C(6, 2) × C(4, 2) × C(6, 4) × 4! / 2 = 16200 种具体的情况，其中 C(6, 2) 表示第一个出现了 2 次的数字究竟出现在了哪 2 次， C(4, 2) 表示第二个出现了 2 次的数字究竟出现在了哪 2 次， C(6, 4) 表示这 4 个数字究竟是哪 4 个数字，最后的结果除以 2 的原因是，第一个出现了 2 次的数和第二个出现了 2 次的数有可能分别是我和你，也有可能分别是你和我，这被算重了。</p>
<p>因此，不同数字的个数恰好为 4 个的情况一共有 7200 + 16200 = 23400 种，它占总数的 23400 / 46656 ≈ 50.154321% 。</p>
<p> </p>
<blockquote>
<p>18．小明走进一家赌场，来到了轮盘赌跟前。轮盘赌的转盘上有 38 个格子，上面分别标着 0, 00, 1, 2, 3, …, 36 。游戏开始后，一个白色小球会逆着轮盘旋转的方向滚动，最终等概率地落入 38 个格子中的一个。小明每次可以在任意一个格子上下 1 元的赌注。如果小球落入了小明所选的格子里，则小明赢得 36 元（但那 1 元钱的赌注仍然归赌场）；如果小球落入了别的格子里，则小明什么也得不到（那 1 元也就打水漂了）。小明身上只有 105 元钱，于是，他连续赌了 105 次。那么，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．小明赚着离开了赌场<br>
B．小明亏着离开了赌场<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>花 1 元赌某一个格子，中签的概率是 1/38 ，但却只能赢来 36 元。毫无疑问，轮盘赌是一个赤裸裸的对赌场更有利的赌博游戏。所以，这道题应该选 B 咯？不对！这道题的正确答案其实是 A 。在这道题中， 105 这个数起到了比较关键的作用。让我们来实际计算一下。</p>
<p>由于每赢一次会得到 36 元，因此小明只需要赢 3 次或 3 次以上，便能实现赚着离开赌场了。小明一次没赢的概率为 (37/38)<sup>105</sup> ≈ 0.0608 ，恰好赢 1 次的概率为 C(105, 1) × (1/38) × (37/38)<sup>104</sup> ≈ 0.1725 ，恰好赢 2 次的概率为 C(105, 2) × (1/38)<sup>2</sup> × (37/38)<sup>103</sup> ≈ 0.2425 ，上述三个值加起来约为 0.4758 。所以，反过来，小明赢了 3 次或 3 次以上的概率就是 0.5242 ，这超过了 1/2 。</p>
<p>为什么在玩一个明显对赌场更有利的赌博游戏中，精确地花费 105 元钱，就能做到赚时多亏时少？如果每个人都这么做，赌场岂不是会被搞垮？这不跟游戏对赌场更有利的结论相矛盾吗？其实，赚的时候更多，并不意味着期望收益为正。虽然赚的时候多，亏的时候少，但赚的时候往往是赚小钱，亏的时候往往是亏大钱，平均算下来，玩家仍然是在不断送钱的。</p>
<p> </p>
<blockquote>
<p>19．法国有法国的轮盘赌，俄罗斯也有俄罗斯的轮盘赌。不过，战斗民族的赌博方式可不一样——不是赌钱，而是赌命。俄罗斯轮盘赌可谓是史上最酷的决斗方式。左轮手枪的转轮中有六个弹槽。在其中一个弹槽中放入一颗子弹，然后快速旋转转轮，再把它合上。参与决斗的两个人轮流对准自己的头部扣动扳机，直到其中一方死亡。这是一场真男人游戏，双方胜负的概率各占 50% ，游戏没有任何技巧可言，命运决定了一切。为了让游戏更加刺激，这一回我们稍微改变一下游戏规则。在转轮的连续三个弹槽中放入子弹，然后旋转并合上转轮。这一次，理论上，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．先开枪的人死亡<br>
B．后开枪的人死亡<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>或许有些出人意料的是，这个题目的答案为 A 。为了算出双方存活的概率，我们只需要考虑所有 6 种可能的子弹位置即可。不妨用符号 ⊙ 来表示有子弹的弹槽，用符号 ○ 来表示空的弹槽。我们便能列出下面这张表：</p>
<ul>
<li> ⊙⊙⊙○○○ → 先开枪者死 </li>
<li> ⊙⊙○○○⊙ → 先开枪者死 </li>
<li> ⊙○○○⊙⊙ → 先开枪者死 </li>
<li> ○○○⊙⊙⊙ → 后开枪者死 </li>
<li> ○○⊙⊙⊙○ → 先开枪者死 </li>
<li> ○⊙⊙⊙○○ → 后开枪者死 </li>
</ul>
<p>可见，先开枪者死亡的概率高达 2/3 ，是后开枪者死亡概率的两倍。</p>
<p>可以算出，当转轮里位置相连的子弹数分别为 1 、 2 、 3 、 4 、 5 、 6 时，先开枪者死亡的概率分别为 1/2 、 2/3 、 2/3 、 5/6 、 5/6 、 1 。看来，并不是所有游戏都是先下手为强啊。</p>
<p> </p>
<blockquote>
<p>20．小明参加某电视台的选秀节目。 A 、 B 、 C 三位导师欣赏了小明的一番激情演唱后，需要投票决定小明能否晋级。小明的表演征服了 A 、 B 两位导师，每位导师都有 4/5 的概率投出赞成票，支持小明晋级。但 C 导师则犹豫不决，不知道该如何选择。怎么办呢？节目组给出了两种方案供小明选择。第一种方案是， A 、 B 两位导师独立作出决定， C 则抛掷一枚公正的硬币，如果硬币正面朝上，则晋级与否完全以 A 的决定为准，如果硬币反面朝上，则晋级与否完全以 B 的决定为准。第二种方案是，A 、 B 两位导师独立投出赞成票或反对票， C 则抛掷一枚公正的硬币，如果硬币正面朝上，则投出赞成票，如果硬币反面朝上，则投出反对票，最后晋级与否则取决于三人中的多数票。为了提高晋级的概率，小明应该选择哪种方案？</p>
<p class="indent">A．选择第一种方案<br>
B．选择第二种方案<br>
C．两种方案的晋级概率相同</p>
</blockquote>
<p>这个题目的答案是 C 。两种方案中，小明晋级的概率是相同的，都是 4/5 。即使把题目中 4/5 这个比例换一换，答案也依旧如此。不妨假设 A 、 B 两位导师投出赞成票的概率都是 p ，那么第一种方案中小明晋级的概率显然是 (1/2) · p + (1/2) · p = p 。第二种方案呢？两位导师都投出赞成票的概率是 p<sup>2</sup> ，此时小明必然晋级； A 投出赞成票 B 投出反对票的概率是 p · (1 – p) ，此时小明有 1/2 的概率晋级（这取决于 C ）； A 投出反对票 B 投出赞成票的概率是 (1 – p) · p ，此时小明有 1/2 的概率晋级（这取决于 C ）；其他情况下小明都无法晋级。因此，第二种方案中小明晋级的概率为 p<sup>2</sup> + (1/2) · p · (1 – p) + (1/2) · (1 – p) · p ，化简的结果是一样的： p 。</p>
<p> </p>
<blockquote>
<p>21．小明上了几次象棋课，回到家得意地要和爸爸妈妈一比高低。爸爸说：“好啊，那我们来搞一次家庭挑战赛吧。比赛分三轮进行，爸爸妈妈将会作为你的对手轮番上场。如果你在任意连续的两轮比赛中获胜，你就能得到一大笔零花钱。对了，挑战赛开始前，你可以指定爸爸妈妈的出场顺序哦。”小明深知，战胜爸爸的概率更低，战胜妈妈的概率更高（事实上也的确如此）。为了提高得到零花钱的概率，小明应该怎样安排爸爸妈妈的出场顺序？</p>
<p class="indent">A．爸爸、妈妈、爸爸<br>
B．妈妈、爸爸、妈妈<br>
C．两种情况下得到零花钱的概率相同</p>
</blockquote>
<p>这是一个非常经典的问题。你或许会觉得，方案 B 更好，因为小明会更多地面对较弱的对手。而实际上，这个题的答案是 A 。这背后有一个很简单的直觉：中间那个人一定不能太强，因为中间那场输了，整个儿就没机会了。</p>
<p>我们可以定量地分析一下。假设战胜爸爸的概率是 p ，战胜妈妈的概率是 q ，根据题目假设， p &lt; q 。如果采用爸爸、妈妈、爸爸的顺序，则得到零花钱的概率等于赢了前两场输了最后一场的概率，加上赢了后两场输了第一场的概率，再加上三场都赢了的概率。最后结果是：</p>
<p class="indent">p · q · (1 – p) + (1 – p) · q · p + p · q · p = 2 · p · q – p<sup>2</sup> · q </p>
<p>类似地，如果采用妈妈、爸爸、妈妈的顺序，则得到零花钱的概率就是：</p>
<p class="indent">q · p · (1 – q) + (1 – q) · p · q + q · p · q = 2 · p · q – p · q<sup>2</sup></p>
<p>由于 p &lt; q ，因此前一个式子一定比后一个式子更大。</p>
<p> </p>
<blockquote>
<p>22．一架客机上有 100 个座位， 100 个人排队依次登机。第一个乘客把登机牌搞丢了，但他仍被允许登机。由于他不知道他的座位在哪儿，他就随机选了一个座位坐下。以后每一个乘客登机时，如果他自己的座位是空着的，那么他就在他自己的座位坐下；否则，他就随机选一个仍然空着的座位坐下。当最后一个人登机时，发生下面哪种情况的可能性更大一些？</p>
<p class="indent">A．他发现剩下的空位正好就是他的<br>
B．他发现剩下的空位不是他的<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>你或许会以为情况 A 出现的概率很小，但实际上，这个概率是 50% 。换句话说，这个题目的答案是 C 。我们可以通过一些严格而复杂的计算来说明这一点，但在这里，我更愿意给出一些直观的解释。注意到，当最后一名乘客登机时，最后一个空位要么就是他的，要么就是第一个乘客的（其他的座位如果没被别人抢占，最终也会被它真正的主人占据）。这两个位置会面对 98 个人的选择，它们的“地位”是相等的，它们的“命运”是相同的，不存在哪个概率大哪个概率小的问题。因此，它们成为最后一个空位的概率是均等的。也就是说，最后一个人发现剩下的空位正好是他的，其概率为 50% 。</p>
<p>下面是另一个有趣的解释。我们可以把问题等价地修改为，如果一个人发现自己的座位被别人占据后，他就叫这个人重新去找一个位置，自己则在这里坐下。结果你会发现，真正在飞机上跑来跑去不断换座位的人其实只有一个，就是第一个人。我们可以干脆叫他直接站在旁边，等他后面的 98 个人全部入座后，他再选个座位坐下。容易看出，他选中的座位要么是他自己的，要么是最后一个人的，这各占 50% 的概率。因此，最后一个人上来之后，正好能对号入座的概率也就是 50% 。</p>
<p> </p>
<blockquote>
<p>23．在每一代的繁殖中，每个阿米巴原虫都有 2/3 的概率分裂成两个，有 1/3 的概率死亡（而不产生下一代）。初始时只有一个阿米巴原虫，那么下面哪种情况的可能性更大一些？</p>
<p class="indent">A．阿米巴原虫在有限代之后灭绝<br>
B．阿米巴原虫无限地繁殖下去<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>注意到，这个问题是有意义的。阿米巴原虫要么在有限代之后灭绝，要么无限地繁殖下去。我们的问题就是，究竟发生哪种情况的可能性更大。</p>
<p>实际上，这个题的答案选 C 。不妨把一个阿米巴原虫能无限繁殖下去的概率设为 p 。初始时的那个阿米巴原虫怎样才能无限繁殖下去呢？首先，它得分裂为两个阿米巴原虫，这有 2/3 的概率；然后，其中至少一个阿米巴原虫要无限繁殖下去。于是，我们得到式子：</p>
<p class="indent">p = (2/3) · (1 – (1 – p)<sup>2</sup>)</p>
<p>其中， (1 – p)<sup>2</sup> 表示两个阿米巴原虫都没能无限繁殖下去的概率。把上面的式子当作一个关于 p 的一元二次方程，可解得 p = 0 或 p = 1/2 。舍去 p = 0 ，于是得到 p = 1/2 。这就说明， A 、 B 两种情况的出现概率是相同的。</p>
<p>为什么我们可以舍去 p = 0 呢？要想说服自己这一点，这还真不容易。下面是一个不严谨的思路。如果我们把每个阿米巴原虫分裂成两个的概率记作 p<sub>0</sub> （原题则相当于 p<sub>0</sub> = 2/3 时的特例），那么阿米巴原虫无限繁殖下去的概率 p 就会满足：</p>
<p class="indent">p = p<sub>0</sub> · (1 – (1 – p)<sup>2</sup>)</p>
<p>解得 p = 0 或 p = (2 · p<sub>0</sub> – 1) / p<sub>0</sub> 。那么， p 究竟是多少呢？注意到以下三点：</p>
<ol>
<li>当 p<sub>0</sub> = 1 时，问题的答案显然应该为 1 ；</li>
<li>不管 p<sub>0</sub> 是多少，问题的答案显然都应该是正数；</li>
<li>在 p<sub>0</sub> 连续变化的过程中，问题的答案也应该发生连续的变化（这个猜测是合理的，我们姑且假设它正确，不再进行论证）。</li>
</ol>
<p>为了同时满足上述三点，只有这样一种可能：当 p<sub>0</sub> = 1/2 时，问题的答案为 0 ；当 p<sub>0</sub> &lt; 1/2 时，舍去后面那个解，即问题的答案一直都是 0 ；当 p<sub>0</sub> &gt; 1/2 时，舍去前面那个解，即问题的答案为 (2 · p<sub>0</sub> – 1) / p<sub>0</sub> 。</p>
<p> </p>
<blockquote>
<p>24．一斤白酒下肚后，我醉醺醺地来到了悬崖边上。如果我再往前迈一步，就会掉下悬崖。我每过一分钟都会往前或者往后迈一步，每次有 1/3 的概率往前迈一步，有 2/3 的概率往后迈一步。假设悬崖边是一条直线，我每步方向都严格垂直于悬崖边，且步长保持一致。如果我无限地走下去，那么下面哪种情况的可能性更大一些？</p>
<p class="indent">A．我在有限步之后将会掉下悬崖<br>
B．我永远不会掉下悬崖<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>注意到，这个问题是有意义的。我要么在有限步之后掉下悬崖，要么永远不会掉下悬崖。我们的问题就是，究竟发生哪种情况的可能性更大。</p>
<p>实际上，这个题的答案也是 C 。不妨假设我在有限步之后将会掉下悬崖的概率为 p 。那么， p 等于多少呢？如果我第一步就往前迈，那就直接掉下去了。这有 1/3 的概率。在另外 2/3 的情况下，我的第一步是往后迈的。如果我最后还是掉下悬崖了，那么在此期间，我一定回过出发点。回到出发点，本质上就相当于往前净走一步，这和从出发点出发最终掉下去了一样，概率都是 p ；回到出发点后，要想真的掉下去，这又有一个 p 的概率。于是，我们得到：</p>
<p class="indent">p = 1/3 + (2/3) · p<sup>2</sup></p>
<p>解得 p = 1/2 或 p = 1 。舍去 p = 1 ，于是得到 p = 1/2 。这就说明， A 、 B 两种情况的出现概率是相同的。</p>
<p>为什么我们可以舍去 p = 1 呢？这里，我们可以使用和上一题类似的思路。如果用 p<sub>0</sub> 代替题目中的 2/3 ，则上面的式子变为了：</p>
<p class="indent">p = (1 – p<sub>0</sub>) + p<sub>0</sub> · p<sup>2</sup></p>
<p>解得 p = (1 – p<sub>0</sub>) / p<sub>0</sub> 或 p = 1 。为了保证连续性，当 p<sub>0</sub> &gt; 1/2 时，我们需要舍去 p = 1 。</p>
<p>你或许已经发现了，这一题和上一题非常相似。进一步考察两个问题的答案，你还会有更惊人的发现：在有限步之后掉下悬崖的概率是 (1 – p<sub>0</sub>) / p<sub>0</sub> ，因此永远不会掉下悬崖的概率是 1 – (1 – p<sub>0</sub>) / p<sub>0</sub> = (2 · p<sub>0</sub> – 1) / p<sub>0</sub> 。这正是上一题中阿米巴原虫无限繁殖下去的概率的表达式。</p>
<p>其实，这两道题的本质就是完全一样的。让我们把阿米巴原虫数量的变化想象成是数轴上不断左右移动的点。刚开始，这个点在 x = 1 的位置。考虑某个阿米巴原虫：如果它分裂了，那么数轴上的点会向右移动一个单位，这有 2/3 的概率；如果它死亡了，那么数轴上的点会向左移动一个单位，这有 1/3 的概率。上一题就相当于是问，数轴上的点更有可能会在有限步之后到达 x = 0 的位置，还是更有可能永远都到不了 x = 0 的位置。如果你把数轴上的点左移右移想成是在悬崖外前进后退，把 x = 0 的位置想象成掉下悬崖的位置，这就瞬间变成这一题的背景了。</p>
<p> </p>
<blockquote>
<p>25．A 、 B 两支球队之间要打 100 场比赛。初始时，两支球队的经验值都为 1 。在每一场比赛中，两支球队各自的获胜概率与它们的经验值成正比，随后获胜一方的经验值将会加 1 。那么，当 100 场比赛全部打完之后，下面哪种情况的可能性更大一些？</p>
<p class="indent">A．球队 A 在所有 100 场比赛中全部获胜<br>
B．球队 A 在所有 100 场比赛中恰好有 50 场获胜<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>这是一个强者愈强，弱者愈弱的过程，因此其中一支球队完胜另一支球队的概率并不会太低，两支球队最终打成平手的概率也并不会太高。事实上，两种情况发生的概率是相同的，都是 1/101 。也就是说，这个题目的答案是 C 。</p>
<p>让我们把 A 、 B 两支球队打比赛的过程进一步抽象成下面这样：从字符串 AB 出发，不断选择某个字母并把它分裂成两个。也就是说，初始时的字符串为 AB ，每一次你需要随机选择一个字母，如果选中了 A ，就把它变成 AA ，如果选中了 B ，就把它变成 BB 。第一次操作之后， AB 有可能变成 AAB ，也有可能变成 ABB ；如果第一次操作之后的结果是 AAB ，那么第二次操作之后，结果就会概率均等地变成 AAAB 、 AAAB 和 AABB 之一。容易看出，字母 A 、 B 数量增加的模式，与原问题中 A 、 B 两支球队经验值增加的模式是完全一致的，因而我们要求的概率值就等价地变为了： 100 次操作之后，字符串变成 AAA…AAB 的概率是多少，字符串变成 AA…AABB…BB （两种字母各半）的概率又是多少。下面我们来说明，这两个概率值都是 1/101 。</p>
<p>先来看一个似乎与此无关的东西：把 0 到 100 之间的数随机排成一行的另类方法。首先，在纸上写下数字 0 ；然后，把数字 1 写在数字 0 的左边或者右边；然后，把数字 2 写在最左边，最右边，或者 0 和 1 之间……总之，把数字 k 概率均等地放进由前面 k 个数产生的（包括最左端和最右端在内的）共 k + 1 个空位中的一个。写完 100 之后，我们就得到了所有数的一个随机排列。</p>
<p>现在，让我们假设初始时的字符串是 A<sup>0</sup>B ，并且今后每次分裂时，都在分裂得到的两个字母之间标注这是第几次分裂。也就是说，下一步产生的字符串就是 A<sup>1</sup>A<sup>0</sup>B 或者 A<sup>0</sup>B<sup>1</sup>B 之一。如果下一步产生的字符串是 A<sup>1</sup>A<sup>0</sup>B ，那么再下一步产生的字符串就会是 A<sup>2</sup>A<sup>1</sup>A<sup>0</sup>B 、 A<sup>1</sup>A<sup>2</sup>A<sup>0</sup>B 、 A<sup>1</sup>A<sup>0</sup>B<sup>2</sup>B 之一……联想前面的讨论，你会发现，第 100 次操作结束后，所有数字实际上形成了一个 0 到 100 的随机排列，也就是说最开始的数字 0 最后出现在各个位置的概率是均等的。因此，最右边那个位置上的数字就是 0 的概率是 1/101 ，正中间那个位置上的数字就是 0 的概率也是 1/101 。这其实就是我们要比较的那两个概率值。</p>
<p> </p>
<blockquote>
<p>26．从全体正整数中随机选出两个正整数，则下面哪种情况的可能性更大一些？</p>
<p class="indent">A．这两个正整数互质（没有大于 1 的公约数）<br>
B．这两个正整数不互质（有大于 1 的公约数）<br>
C．上述两种情况的出现概率相同</p>
</blockquote>
<p>这个问题的说法很不严谨。我们给出一个更加严谨的叙述方法。让我们用 P<sub>N</sub> 来表示，从 1 到 N 中随机取出两个正整数，它们互质的概率是多少。我们的问题就是，当 N 趋于无穷时， P<sub>N</sub> 的值究竟是大于 1/2 ，等于 1/2 ，还是小于 1/2 。</p>
<p>这是一个非常非常经典的问题。下面是最常见的一种解法。假设我们从全体正整数中随机选出了两个正整数 a 、 b 。其中， a 能被 2 整除的概率是 1/2 ， b 能被 2 整除的概率是 1/2 。因而，它们都能被 2 整除的概率就是 1 / 2<sup>2</sup> 。反过来，它们不都能被 2 整除的概率就是 1 – 1 / 2<sup>2</sup> 。类似地，它们不都能被 3 整除的概率就是 1 – 1 / 3<sup>2</sup> ，它们不都能被 5 整除的概率就是 1 – 1 / 5<sup>2</sup> ……于是，它们互质的概率就是：</p>
<p class="indent">(1 – 1 / 2<sup>2</sup>) · (1 – 1 / 3<sup>2</sup>) · (1 – 1 / 5<sup>2</sup>) · (1 – 1 / 7<sup>2</sup>) …</p>
<p>注意，这里用到了一个假设：如果 p 和 q 是两个质数，那么能否被 p 整除和能否被 q 整除，这是互相独立的。事实上也确实如此：一个数能被 p 整除的概率是 1 / p ，一个数能被 q 整除的概率是 1 / q ；一个数能同时被两个质数 p 和 q 整除，当且仅当它能被 p · q 整除，其概率是 1 / (p · q)。</p>
<p>为了求出上面这个式子的值，我们考虑它的倒数。 1 – 1 / 2<sup>2</sup> 的倒数是 1 / (1 – 1 / 2<sup>2</sup>) ，而由无穷等比级数的求和公式（见本文中的第 4 题），它又可以被我们写成 1 + 1 / 2<sup>2</sup> + 1 / 2<sup>4</sup> + 1 / 2<sup>6</sup> + … 。类似地，其他几项也都变成了 1 + 1 / 3<sup>2</sup> + 1 / 3<sup>4</sup> + 1 / 3<sup>6</sup> + … ，1 + 1 / 5<sup>2</sup> + 1 / 5<sup>4</sup> + 1 / 5<sup>6</sup> + … ，等等。现在，想象一下，如果把所有的括号全都展开，把所有的项全都乘开来，会得到什么？我们会既无遗漏又无重复地得到所有的 1 / n<sup>2</sup> ！</p>
<p class="indent">  (1 + 1 / 2<sup>2</sup> + 1 / 2<sup>4</sup> + 1 / 2<sup>6</sup> + … ) · (1 + 1 / 3<sup>2</sup> + 1 / 3<sup>4</sup> + 1 / 3<sup>6</sup> + … )<br>
  · (1 + 1 / 5<sup>2</sup> + 1 / 5<sup>4</sup> + 1 / 5<sup>6</sup> + … ) · …<br>
= 1 + 1 / 2<sup>2</sup> + 1 / 3<sup>2</sup> + 1 / 4<sup>2</sup> + 1 / 5<sup>2</sup> + …</p>
<p>比方说， 40 = 2 × 2 × 2 × 5 ，那么等式右边的 1 / 40<sup>2</sup> 这一项，就是由等式左边的第一个括号里的 1 / 2<sup>6</sup> ，乘以第二个括号里的 1 ，乘以第三个括号里的 1 / 5<sup>2</sup> ，乘以其余所有括号里的 1 得到的。</p>
<p>1 + 1 / 2<sup>2</sup> + 1 / 3<sup>2</sup> + 1 / 4<sup>2</sup> + 1 / 5<sup>2</sup> + … 究竟等于多少呢？我们来证明，它小于 2 。这是因为：</p>
<p class="indent">  1 + 1 / 2<sup>2</sup> + 1 / 3<sup>2</sup> + 1 / 4<sup>2</sup> + 1 / 5<sup>2</sup> + …<br>
&lt; 1 + 1 / (1 × 2) + 1 / (2 × 3) + 1 / (3 × 4) + 1 / (4 × 5) + …<br>
= 1 + 1 – 1/2 + 1/2 – 1/3 + 1/3 – 1/4 + 1/4 – 1/5 + …<br>
= 2</p>
<p>别忘了， 1 + 1 / 2<sup>2</sup> + 1 / 3<sup>2</sup> + 1 / 4<sup>2</sup> + 1 / 5<sup>2</sup> + … 是我们把所求的概率值取了倒数后的结果。因此，我们所求的概率值就应该大于 1/2 了。也就是说，这道题目的正确答案是 A 。</p>
<p>可以证明， 1 + 1 / 2<sup>2</sup> + 1 / 3<sup>2</sup> + 1 / 4<sup>2</sup> + 1 / 5<sup>2</sup> + … 实际上等于 π<sup>2</sup> / 6 。因此，任意两个正整数互质的概率就是 6 / π<sup>2</sup> ≈ 0.608 。神奇的数学常数 π 经常会出现在一些与圆形八竿子打不着的地方，比如我们之前提过的 Buffon 投针问题。而大家刚才看到互质概率问题，才是我觉得最为经典的例子之一。</p>
<p> </p>
<p>这篇文章中的题目是我长期收集而来的。大部分题目都是非常经典的题目，它们可以在 The Colossal Book of Short Puzzles and Problems 、 Mathematical Puzzles: A Connoisseur’s Collection 、 Mathematical Mind-Benders 、 Problems for Mathematicians, Young and Old 、 40 Puzzles and Problems in Probability and Mathematical Statistics 、 Fifty Challenging Problems in Probability 等书中找到。有些题目是我很早以前就写过的，此处有所改写。部分文字直接摘自《浴缸里的惊叹： 256 道让你恍然大悟的趣题》。</p>
			 ]]></content>
<pubDate>2016-04-27T17:09:35+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6665</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：两个方阵是怎样互相穿过对方的？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6750</link>
<content><![CDATA[ 
		<p>来自日本体育大学的一场“集团行动”演出被制作成 GIF 动画后迅速在网上蹿红。在动画中，一个 5 × 5 的方阵沿着某一方向整齐地匀速前行，另一个 5 × 5 的方阵朝着与之垂直的方向也在整齐地匀速前进，两者奇迹般地互相穿过了对方。问题来了：这是怎么回事？</p>
<p class="indent"><img alt="image placeholder" >
<p><span id="more-6750"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>你可以把他们想象成是不同的 10 行，他们以相同的速度前进后退。只不过，其中 5 行横着走的方向跟另外 5 行不一样，于是就形成了两个互相穿过对方的方阵。也就是说，如果每一行的人手牵着手，两个方阵照样可以传过去。</p>
<p class="indent"><img alt="image placeholder" >
<p>我是在这里看见的相关讨论： <a href="http://www.reddit.com/r/interestingasfuck/comments/4gsgyu/men_in_sync/">http://www.reddit.com/r/interestingasfuck/comments/4gsgyu/men_in_sync/</a></p>
			 ]]></content>
<pubDate>2016-04-30T11:38:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6750</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 如果把 3 · n + 1 问题改为 3x · n + 1 问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/6756</link>
<content><![CDATA[ 
		<p>Collatz 猜想也叫做 3 · n + 1 问题。这可能是数学中最为世人所知的未解之谜。它是如此初等，连小学生都能听懂它的内容；但解决它却如此之难，以至于 Paul Erdős 曾说：“或许现在的数学还没准备好去解决这样的问题。”这究竟是一个什么样的问题呢？让我们来看一下 Collatz 猜想的叙述：</p>
<blockquote><p>任意取一个正整数 n 。如果 n 是奇数，则把 n 变为 3 · n + 1 ；如果 n 是偶数，则把 n 变为 n/2 。不断重复操作，则最终一定会得到 1 。</p></blockquote>
<p>举个例子，如果 n = 26 ，那么经过下面 10 步之后，它最终变为了 1 ：</p>
<p class="indent">26 → 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</p>
<p>Collatz 猜想说的就是，这个规律对于所有正整数 n 均是如此。这个问题看起来是如此简单，以至于无数的数学家都掉进了这个坑里。光从这个问题的众多别名，便能看出这个问题害人不浅： Collatz 猜想又叫做 Ulam 猜想、 Kakutani 问题、 Thwaites 猜想、 Hasse 算法、 Syracuse 问题……研究这个问题的人很多，解决这个问题的人却一个没有。后来，人们干脆把它叫做 3 · n + 1 问题，让哪个数学家也不沾光。</p>
<p>这个问题有多难呢？我们可以从下面的这个例子中略见一斑。虽然从 26 出发只消 10 步就能变成 1 ，但若换一个数，比如 27 ，情况就大不一样了：</p>
<p class="indent">27 → 82 → 41 → 124 → 62 → 31 → 94 → 47 → 142 → 71 → 214 → 107 → 322 → 161 → 484 → 242 → 121 → 364 → 182 → 91 → 274 → 137 → 412 → 206 → 103 → 310 → 155 → 466 → 233 → 700 → 350 → 175 → 526 → 263 → 790 → 395 → 1186 → 593 → 1780 → 890 → 445 → 1336 → 668 → 334 → 167 → 502 → 251 → 754 → 377 → 1132 → 566 → 283 → 850 → 425 → 1276 → 638 → 319 → 958 → 479 → 1438 → 719 → 2158 → 1079 → 3238 → 1619 → 4858 → 2429 → 7288 → 3644 → 1822 → 911 → 2734 → 1367 → 4102 → 2051 → 6154 → 3077 → 9232 → 4616 → 2308 → 1154 → 577 → 1732 → 866 → 433 → 1300 → 650 → 325 → 976 → 488 → 244 → 122 → 61 → 184 → 92 → 46 → 23 → 70 → 35 → 106 → 53 → 160 → 80 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</p>
<p>可见，当 n 的值不同时，从 n 变到 1 的路子是很没规律的。</p>
<p>有趣的是，如果我们把 Collatz 猜想中的乘以 3 改为乘以任意一个 3<sup>x</sup> （其中 x 的值可由你自由选择），那么 Collatz 猜想就是正确的了。下面我们就来证明这一点。</p>
<p><span id="more-6756"></span></p>
<p> </p>
<p>首先我们证明一个引理：任何一个正整数都可以表示成下面这样：</p>
<p class="indent">2<sup>a<sub>1</sub></sup> × 3<sup>b<sub>1</sub></sup> + 2<sup>a<sub>2</sub></sup> × 3<sup>b<sub>2</sub></sup> + 2<sup>a<sub>3</sub></sup> × 3<sup>b<sub>3</sub></sup> + … + 2<sup>a<sub>n</sub></sup> × 3<sup>b<sub>n</sub></sup></p>
<p>其中 0 ≤ a<sub>1</sub> &lt; a<sub>2</sub> &lt; a<sub>3</sub> &lt; … &lt; a<sub>n</sub> ，并且 b<sub>1</sub> &gt; b<sub>2</sub> &gt; b<sub>3</sub> &gt; … &gt; b<sub>n</sub> ≥ 0 。举个例子， 213 = 3<sup>4</sup> + 2<sup>2</sup> × 3<sup>2</sup> + 2<sup>5</sup> × 3 就是一种合法的表示法。</p>
<p>反证，假设有的数不能用这种方法来表示，那么一定存在一个最小的不能用这种方法来表示的数，不妨把它叫做 y 。显然 y 不能是偶数，否则把 y/2 的表示法中的每一项都再乘以一个 2 ，就能得到 y 的一种合法表示了。如果 y 是奇数呢？无妨假设 3<sup>i</sup> ≤ y &lt; 3<sup>i+1</sup> ，其中 i 是某个适当的正整数。于是， y′ = y – 3<sup>i</sup> 就是一个偶数，并且 y′/2 &lt; 3<sup>i</sup> 。把 y′/2 的表示法中的每一项都再乘以一个 2 ，再在最前面加上一个 3<sup>i</sup> ，就能得到 y 的一种合法表示了。</p>
<p>下面我们就来证明，不断地执行 n → 3<sup>x</sup> · n + 1 （当 n 为奇数时）以及 n → n/2 （当 n 为偶数时）的变换，任何一个正整数最终都能变为 1 。还是以 27 为例。问题改版后，把 27 变成 1 的步骤数能大大减少：</p>
<p class="indent">(((((27 × 3<sup>2</sup> + 1) / 2<sup>2</sup> × 3 + 1) / 2<sup>3</sup> × 3<sup>2</sup> + 1) / 2<sup>4</sup> × 3 + 1) / 2<sup>3</sup> × 3 + 1) / 2<sup>4</sup> = 1</p>
<p>在这个过程中，我们一共除以了 16 个 2 。也就是说，上式中所有 2 头上的指数之和是 16 。想一想，如果等式两边同时乘以 2<sup>16</sup> ，结果会怎样？结果是，等式左边就不再有除法了：</p>
<p class="indent">27 × 3<sup>7</sup> + 3<sup>5</sup> +  2<sup>2</sup> × 3<sup>4</sup> + 2<sup>5</sup> × 3<sup>2</sup> + 2<sup>9</sup> × 3 + 2<sup>12</sup> = 2<sup>16</sup></p>
<p>其中，等式左边的 3<sup>5</sup> + … + 2<sup>12</sup> ，正好是 2<sup>16</sup> – 27 × 3<sup>7</sup> 的一个合法的表示法！</p>
<p>所以，为了证明某个正整数 n 最终能变为 1 ，我们只需要证明，存在适当的 a 和 b ，使得 2<sup>a</sup> – n · 3<sup>b</sup> 有一个合法的表示法，并且表示法第一项里 3 的指数小于 b 。</p>
<p>由于 log<sub>3</sub>2 为无理数，因而很容易看出，对于任意的正整数 n ，我们总能找到一个 b ，使得 [n · 3<sup>b</sup>, (n + 1) · 3<sup>b</sup>) 区间内包含某个 2 的整数次幂。把这个 2 的整数次幂记作 2<sup>a</sup> 。既然每一个正整数都有一个合法的表示法，那么 2<sup>a</sup> – n · 3<sup>b</sup> 也有一个合法的表示法。而 2<sup>a</sup> – n · 3<sup>b</sup> &lt; 3<sup>b</sup> ，因而它的表示法第一项里 3 的指数一定小于 b 。</p>
<p>本文最后，让我们再对上一段中第一句话的结论作出一些额外的解释。设想有一个总长为 1 的圆形轨道，轨道上有一个周长为 r 的轮子，其中 r 为某个大于 0 的无理数。在轮子上的某个位置涂一个墨点。让轮子从圆形轨道上的某一位置出发，沿着轨道往前滚动。每次墨点接触轨道时，都会在轨道上留下一个记号（轮子上的墨点不会干掉，滚过已有的记号时也不会反过来沾上墨点）。我们可以证明一个结论：轮子沿着轨道一圈一圈地滚动下去之后，轨道上的各个地方都会稠密地分布着记号。</p>
<p>首先，任意两个记号的位置都不会重合，否则某个整数倍的 r 就会等于某个整数，这与 r 的无理性相矛盾。因此，轮子转了无穷多圈之后，轨道上也会留下无穷多个记号。取任意大的正整数 N ，把轨道平均分成 N 份，每份的长度都是 1/N 。根据鸽笼原理，一定有两个记号落入了同一份里。这两个记号之间的距离 d 小于 1/N 。不妨假设轮子从先产生的那个记号出发，转了 k 圈之后来到了后产生的那个记号；那么，从此处出发再转上 k, 2k, 3k, …圈，就会继续得到一系列间隔为 d 的记号。如果正整数 N 足够大，间隔 d 就会足够小，由此产生的记号也就会足够密地分布在整个轨道上了。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>为什么对于任意的正整数 n ，我们总能找到一个 b ，使得 [n · 3<sup>b</sup>, (n + 1) · 3<sup>b</sup>) 区间内包含某个 2 的整数次幂呢？在对数尺度下，这就化为了刚才讨论的问题。 [n × 3<sup>0</sup>, n × 3<sup>1</sup>), [n × 3<sup>1</sup>, n × 3<sup>2</sup>), [n × 3<sup>2</sup>, n × 3<sup>3</sup>), … 成为了一个个等长的区间，区间的长度都是 log(3) 。而 2<sup>0</sup>, 2<sup>1</sup>, 2<sup>2</sup>, … 也就成了一系列的等距点，相邻两个点之间的距离是 log(2) 。如果把 log(3) 的长度看作 1 个单位，那么 log(2) 的长度就是 log(2) / log(3) = log<sub>3</sub>2 个单位，这是一个无理数。这就完全相当于周长为 log<sub>3</sub>2 的轮子沿着总长为 1 的圆形轨道滚动。根据刚才的结论，由此得到的标记将会稠密地分布在这些等长区间内的各种位置，当然也就会有不少标记落进了形如 [n · 3<sup>b</sup>, (n + 1) · 3<sup>b</sup>) 的区间里。</p>
<p>这个问题出自 <a href="http://www.brand.site.co.il/riddles/201508q.html">http://www.brand.site.co.il/riddles/201508q.html</a> 。</p>
			 ]]></content>
<pubDate>2016-05-02T22:52:06+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6756</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 捡石子游戏、 Wythoff 数表和一切的 Fibonacci 数列 ]]></title>
<link>http://www.matrix67.com/blog/archives/6784</link>
<content><![CDATA[ 
		<p>让我们来玩一个游戏。把某个国际象棋棋子放在棋盘上，两人遵循棋子的走法，轮流移动棋子，但只能将棋子往左方、下方或者左下方移动。谁先将棋子移动到棋盘的最左下角，谁就获胜。如果把棋子放在如图所示的位置，那么你愿意先走还是后走？显然，答案与我们放的是什么棋子有关。</p>
<p class="indent"><img alt="image placeholder" >
<p>这个游戏对于兵来说是没有意义的。在如图所示的地方放马或者放象，不管怎样都无法把它移动到棋盘的最左下角，所以我们也就不分析了。因此，我们只需要研究王、后、车三种情况。</p>
<p><span id="more-6784"></span></p>
<p>在国际象棋中，车每次可以横着或竖着走任意多格。在上述游戏中，受到规则的限制，车每次只能向左或者向下走任意多格。如果问题中的棋子是车，答案就非常简单了：你应该选择先走。你应该直接把车移到棋盘对角线上的位置（如左图所示），然后不管对方怎么走，你都把它移回到棋盘的对角线上。这样，你就能保证必胜了。</p>
<p class="indent"><img alt="image placeholder" >
<p>在国际象棋中，王每次可以横着、竖着或者斜着走一格。在上述游戏中，受到规则的限制，王每次只能向左、向下或者向左下方走一格。如果问题中的棋子是王，分析出问题的答案也不算太难：你应该选择先走。你应该直接把王移到棋盘的“奇格”里（如右图所示），然后不管对方怎么走，你都可以把它再次移到某个“奇格”里。这样，你就能保证必胜了。</p>
<p>在国际象棋中，皇后每次可以横着、竖着或者斜着走任意多格。在上述游戏中，受到规则的限制，皇后每次只能向左、向下或者向左下方走任意多格。如果问题中的棋子是皇后，那么你应该选择先走还是后走呢？这次，问题就没那么简单了。</p>
<p>这个“挪动皇后”的游戏是由 Rufus Isaacs 在 1960 年左右提出来的。给定皇后在棋盘上的初始位置，如何判断出谁有必胜策略呢？ Isaacs 给出了一个分析方法。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>首先，第一行上的所有位置，第一列上的所有位置，以及对角线上的所有位置，都能一步直接走到棋盘的最左下角。我们可以从最左下角的位置出发，画出三条射线，把这些位置全都划掉。如果皇后位于被划掉的位置上，那么先走的人就会获胜。此时，棋盘上出现了两个死角。如果皇后在这两个地方，先走的人不得不把皇后挪到刚才被划掉的位置上，因而后走的人就必胜了。因而，从这两个地方出发，画出三条射线，被划掉的位置又是先走的人就会获胜的位置，先走的人只需要把皇后挪到这两个地方即可。此时，棋盘上又会出现两个新的死角，它们又是后走的人必胜的位置……不断这样递推下去，我们就能分析出，皇后在哪些地方时先走的人必胜，皇后在哪些地方时后走的人必胜。之前我们曾问，当皇后位于标有 × 的格子时你应该选择先走还是后走，现在我们就知道答案了：你应该后走才对。</p>
<p>那么，在“挪动皇后”的游戏中，哪些位置是后走的人必胜的位置呢？</p>
<p class="indent"><img alt="image placeholder" >
<p>画出更大的棋盘，将刚才的操作再多重复几次后，我们看见了一个非常明显的规律：这些位置大致形成了两条直线。再仔细观察，你会发现，每行每列里恰好有一个这样的位置。有没有什么公式不用递推就能找出这些位置呢？它们为什么会形成这么两条直线呢？为什么每行每列里有且仅有一个这样的位置呢？看来，这里面还有很深的水。</p>
<p> </p>
<p>令 Isaacs 万万没有想到的是，这个游戏虽然是他发明的，但由此引申的问题却已经被前人解决了。 1907 年，荷兰数学家 Willem Abraham Wythoff 提出了一个双人对弈游戏，后来人们把它叫作 Wythoff 游戏。游戏规则是这样的。地上有两堆石子，其中一堆有 m 个石子，另外一堆有 n 个石子。两名玩家轮流取走石子，规定每次要么从其中一堆石子中取走任意多个石子，要么从两堆石子中取走相同数量的石子。等到谁没有石子可取了，谁就输了。也就是说，取到最后一个石子的玩家获胜。 Martin Gardner 认为， Wythoff 本人甚至也不是这个游戏最早的发明者——其实中国很早就有了这个游戏，人们把它叫作“捡石子”。</p>
<p>容易看出， Wythoff 游戏和“挪动皇后”是完全等价的。把棋盘从下到上各行依次标为 0, 1, 2, 3, …，把棋盘从左到右各列依次标为 0, 1, 2, 3, …，那么皇后移动时坐标变化的规则，正好与 Wythoff 游戏中两堆石子数量变化的规则是相同的。而两个游戏的目标也是相同的：谁先将游戏状态变为 (0, 0) ，谁就获得胜利。因此，这两个游戏完全等价。</p>
<p>由于状态 (m, n) 和 (n, m) 本质相同，因而我们可以把游戏状态看作是无序数对，并约定在书写时总把较小的数写在前面。也就是说，今后 (1, 2) 和 (2, 1) 就统一用 (1, 2) 来表示了。另外，只要数对里面至少有一个数不为 0 ，我们就说这是一个非零数对。我们的问题就是，哪些非零数对所对应的游戏状态是后行者必胜的。</p>
<p>Wythoff 给出的答案异常简单——所有这样的数对从小到大依次为：</p>
<p class="indent">([1 · φ], [1 · φ<sup>2</sup>]), ([2 · φ], [2 · φ<sup>2</sup>]), ([3 · φ], [3 · φ<sup>2</sup>]), ([4 · φ], [4 · φ<sup>2</sup>]), …</p>
<p>其中 φ = (√<span style="text-decoration: overline">5</span> + 1) / 2 ， [x] 表示不超过 x 的最大整数（当 x ≥ 0 时， [x] 可以简单地理解为取 x 的整数部分）。不妨把上述序列叫作序列 W 。稍作计算可知，序列 W 的前几项为：</p>
<p class="indent">(1, 2), (3, 5), (4, 7), (6, 10), (8, 13), …</p>
<p>对照前面那个棋盘图，我们可以看到，序列 W 还真挺靠谱。 Wythoff 证明了，序列 W 确实就是正确的答案，这是因为序列 W 满足以下三个条件：</p>
<ul>
<li>条件 1 ： W 当中的任何一个数对都无法一步变成 (0, 0)</li>
<li>条件 2 ： W 当中的任何一个数对都无法一步变成 W 当中的另一个数对</li>
<li>条件 3 ： W 之外的任何一个非零数对都可以一步变成 (0, 0) 或 W 当中的某一个数对</li>
</ul>
<p>这样的话，当游戏状态为 W 当中的数对时，先走的人只能把游戏状态变为 W 之外的非零数对，后走的人即使赢不了，也总能把游戏状态移回到 W 当中。不断这样循环下去，后走的人就赢定了。所以，如果序列 W 真的满足上面三个条件，刚才的公式就是正确的了。那么，序列 W 为什么满足上面三个条件呢？ Wythoff 进一步指出，这是因为序列 W 满足以下三个性质：</p>
<ul>
<li>性质 1 ： W 里面正好既无重复又无遗漏地包含了每一个正整数</li>
<li>性质 2 ： W 当中各项里的两数之差依次为 1, 2, 3, …</li>
<li>性质 3 ： W 当中各项里的较小数依次递增</li>
</ul>
<p>我们先来说明这三个性质为什么能推出前面的三个条件，然后再来说明这三个性质本身为什么都是成立的。性质 1 和性质 2 告诉我们： W 当中用到的数都大于 0 ，且没有重复的情况；各个数对里的两数之差也都大于 0 ，而且也没有重复的情况。这能立即推出前面的条件 1 和条件 2 。现在，假设 (a, b) 是 W 之外的某个非零数对。如果 a = 0 或者 a = b ，那么 (a, b) 可以直接变成 (0, 0) 。接下来，我们假设 0 &lt; a &lt; b 。由性质 1 可知，在 W 中，有且仅有一个数对用到了 a 这个数。如果 a 是这个数对里的较大数，或者说这个数对形如 (x, a) ，那么直接把 b 减小到 x ，一步就把 (a, b) 变到 W 里去了。例如， (7, 12) 是 W 之外的数对，把它变成 (4, 7) ，便一步变到 W 里去了。如果 a 是这个数对里的较小数，或者说这个数对是 (a, x) 呢？若 b 比 x 大，直接把 b 减小到 x ，同样能一步把 (a, b) 变到 W 里去。若 b 比 x 小，这就说明和 (a, x) 相比， (a, b) 里的两数之差更小。根据性质 2 ，在序列 W 当中，这个差值在 (a, x) 之前曾经出现过。所以，让 (a, b) 的两个数同时减小相同的量，就能把数对变到 W 里去了。为什么是同时减而不是同时加呢？这就是由性质 3 保证的。举例来说， (6, 11), (6, 12), (6, 13), …都能一步变为 (6, 10) ，而 (6, 7) 、 (6, 8) 、 (6, 9) 则能分别变成 (1, 2) 、 (3, 5) 、 (4, 7) 。</p>
<p>接下来，我们来证明序列 W 满足这三个性质。性质 1 可以直接由 Beatty-Rayleigh 定理推出。 Beatty-Rayleigh 定理说的是，若正无理数 α 和 β 满足 1 / α + 1 / β = 1 ，则数列 [1 · α], [2 · α], [3 · α], … 和 [1 · β], [2 · β], [3 · β], … 既无重复又无遗漏地包含了所有的正整数。由于 φ 和 φ<sup>2</sup> 就满足 1 / φ + 1 / φ<sup>2</sup> = 1 ，所以序列 W 里的所有数既无重复又无遗漏地包含了所有的正整数。</p>
<p>为了保持文章的完整性，我们给出 Beatty-Rayleigh 定理的证明。 Beatty-Rayleigh 定理有很多证明方法，下面这种方法是我最喜欢的一种。首先注意到，如果 x 和 y 都不是整数，那么 [x] 严格地小于 x ，[y] 严格地小于 y ，从而 [x] + [y] &lt; x + y 。另外，[x] 一定严格地大于 x – 1 ， [y] 一定严格地大于 y – 1 ，从而 [x] + [y] 一定严格地大于 x + y – 2。这说明，当 x 和 y 都不是整数时， [x] + [y] 将介于 x + y – 2 和 x + y 之间。</p>
<p>回到原问题。显然，在数列 [1 · α], [2 · α], [3 · α], … 中，小于 n 的正整数有 [n / α] 个。显然，在数列 [1 · β], [2 · β], [3 · β], … 中，小于 n 的正整数有 [n / β] 个。因此，在这两个数列中，小于 n 的正整数共有 [n / α] + [n / β] 个。由于 α 和 β 都是无理数，因此 n / α 和 n / β 不可能为整数，由刚才的结论， [n / α] + [n / β] 一定介于 n / α + n / β – 2 和 n / α + n / β 之间，即 n – 2 和 n 之间。但是， [n / α] + [n / β] 是个整数，因而它精确地等于 n – 1 。</p>
<p>这说明，前 n – 1 个正整数在两个数列中一共出现了 n – 1 次，这对于所有 n 都成立。于是，正整数 1 必须且只能出现在其中一个数列中，正整数 2 必须且只能出现在其中一个数列中，以此类推，每一个新的正整数都必须且只能出现在其中一个数列中。</p>
<p>序列 W 的性质 2 则是， W 当中各项里的两数之差依次为 1, 2, 3, … ，也就是说第 n 个数对里的两数之差恰好为 n 。这一点也是很容易看出来的。由于 φ 满足 1 + φ = φ<sup>2</sup> ，因而 n + n · φ = n · φ<sup>2</sup> ，即 n · φ 和 n · φ<sup>2</sup> 正好相差 n 。如果两个数正好相差 n ，那么这两个数的整数部分显然也就正好相差 n 。这就证明了序列 W 满足性质 2 。</p>
<p>序列 W 的性质 3 则是， W 当中各项里的较小数依次递增，即 [1 · φ], [2 · φ], [3 · φ], … 依次递增。这就更显然了：在数列 1 · φ, 2 · φ, 3 · φ, … 中，后一项总比前一项大 φ ≈ 1.618 &gt; 1 ，因此即使取整后，后一项也一定严格地大于前一项。注意到，性质 2 和性质 3 结合起来可以告诉我们， W 当中各项里的较大数也是依次递增的。</p>
<p>至此，我们就完整地证明了， Wythoff 提出的公式确实准确地给出了 Wythoff 游戏（也就是“挪动皇后”游戏）中后行者必胜的状态。这也顺便把我们之前挖的坑填上了。为什么把后行者必胜的状态标在棋盘上，会形成两条直线呢？看看序列 W 的公式，你就知道了：这是因为，每个数对里的前后两项之比（即横纵坐标之比）都是固定的。为什么棋盘的每行每列里都有且仅有一个标记呢？这其实完全是由序列 W 的性质 1 带来的结果。</p>
<p> </p>
<p>不过，故事还远远没有结束。刚才我们给出了序列 W 的前几项，那时候你或许就已经发现了什么。让我们再多往后写几项：</p>
<p class="indent">(1, 2), (3, 5), (4, 7), (6, 10), (8, 13), (9, 15), (11, 18), (12, 20), (14, 23), (16, 26), (17, 28), (19, 31), (21, 34), (22, 36), (24, 39), (25, 41), (27, 44), (29, 47), (30, 49), …</p>
<p>你发现了什么？有没有觉得， (1, 2) 、 (3, 5) 、 (8, 13) 、 (21, 34) 这几项都特别熟悉？没错，如果把 Fibonacci 数列里的数都依次写下来：</p>
<p class="indent">1, 2, 3, 5, 8, 13, 21, 34, …</p>
<p>然后把它们两个两个分成一组：</p>
<p class="indent">(1, 2), (3, 5), (8, 13), (21, 34), …</p>
<p>由此得到的所有数对都在序列 W 当中！事实上，我们还能预测出，上述数对都出现在了序列 W 当中的什么位置。 (1, 2) 后面的那个数对是 (3, 5) ，它就是 W 当中的第 2 个数对； (3, 5) 后面的那个数对是 (8, 13) ，它就是 W 当中的第 5 个数对； (8, 13) 后面的那个数对是 (21, 34) ，它就是 W 当中的第 13 个数对……所以， (21, 34) 后面的那个数对，就应该是 W 当中的第 34 个数对咯？简单算算你会发现，嘿，还真是！根据定义， W 当中的第 34 个数对为 [34 · φ], [34 · φ<sup>2</sup>] ，而 34 · φ ≈ 55.013 ，34 · φ<sup>2</sup> ≈ 89.013 ，取整后正好就是 (55, 89) 。你或许会猜测，该不会当 n 是 Fibonacci 数时， [n · φ] 和 [n · φ<sup>2</sup>] 一定就是后面两个 Fibonacci 数吧。事实上并非如此。让我们代入 n = 21 看看： 21 · φ ≈ 33.979 ， 21 · φ<sup>2</sup> ≈ 54.979 ，所得到的两个数确实很接近 21 后面的两个 Fibonacci 数，但却要偏小一些。因此，取整之后的结果是 33 和 54 ，而并不是 34 和 55 。这一切都是为什么呢？</p>
<p>这一切都是因为， Fibonacci 数列有一个神奇的通项公式： φ<sup>n</sup> / √<span style="text-decoration: overline">5</span> – (1 – φ)<sup>n</sup> / √<span style="text-decoration: overline">5</span> 。注意，这个充满无理数的通项公式生成的并不是 Fibonacci 数的近似值，它生成的真的就是一个个的 Fibonacci 数。你可以试着把 n = 1, 2, 3, 4, 5, 6 代进去，得到的值将会精确地等于 1, 1, 2, 3, 5, 8 。</p>
<p>由于 φ ≈ 1.618 ，其绝对值大于 1 ，因此随着 n 的增加， φ<sup>n</sup> / √<span style="text-decoration: overline">5</span> 的绝对值将会迅速变得非常非常大；由于 1 – φ ≈ – 0.618 ，其绝对值小于 1 ，因此随着 n 的增加， (1 – φ)<sup>n</sup> / √<span style="text-decoration: overline">5</span> 的绝对值将会迅速变得非常非常接近于 0 。最终， φ<sup>n</sup> / √<span style="text-decoration: overline">5</span> – (1 – φ)<sup>n</sup> / √<span style="text-decoration: overline">5</span> 将会无限接近于 φ<sup>n</sup> / √<span style="text-decoration: overline">5</span> ，一个以 φ 为公比的等比数列。这就解释了，为什么一个 Fibonacci 数的 φ 倍大致就等于下一个 Fibonacci 数。</p>
<p>但是，用这种方法推算出来的下一个 Fibonacci 数，究竟会偏大一些还是偏小一些呢？我们还得仔细分析一下误差。注意到 1 – φ 是个负数，因此随着 n 的增加， (1 – φ)<sup>n</sup> / √<span style="text-decoration: overline">5</span> 实际上是在正负交替地向 0 靠拢，因此 φ<sup>n</sup> / √<span style="text-decoration: overline">5</span> – (1 – φ)<sup>n</sup> / √<span style="text-decoration: overline">5</span> 实际上是在一上一下地无限接近于 φ<sup>n</sup> / √<span style="text-decoration: overline">5</span> 。下表中的第一行依次是各个 Fibonacci 数，第二行是 n = 1, 2, 3, … 时 φ<sup>n</sup> / √<span style="text-decoration: overline">5</span> 的值，第三行则是二者之间的误差。</p>
<table>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>21</td>
<td>34</td>
<td>55</td>
<td>89</td>
</tr>
<tr>
<td>0.7236</td>
<td>1.1708</td>
<td>1.8944</td>
<td>3.0652</td>
<td>4.9597</td>
<td>8.0249</td>
<td>12.9846</td>
<td>21.0095</td>
<td>33.9941</td>
<td>55.0036</td>
<td>88.9978</td>
</tr>
<tr>
<td>-0.2764</td>
<td>0.1708</td>
<td>-0.1056</td>
<td>0.0652</td>
<td>-0.0403</td>
<td>0.0249</td>
<td>-0.0154</td>
<td>0.0095</td>
<td>-0.0059</td>
<td>0.0036</td>
<td>-0.0022</td>
</tr>
</table>
<p>这就解释了，为什么 34 · φ 和 34 · φ<sup>2</sup> 正好比 55 和 89 稍大一些。 34 和 55 非常接近 φ<sup>9</sup> / √<span style="text-decoration: overline">5</span> 和 φ<sup>10</sup> / √<span style="text-decoration: overline">5</span> 的值，其中后者是前者的 φ 倍。但 34 等于 φ<sup>9</sup> / √<span style="text-decoration: overline">5</span> 加上某个很小的数， 55 等于 φ<sup>10</sup> / √<span style="text-decoration: overline">5</span> 减去某个很小的数，因而 34 的 φ 倍就会比 55 略大一些了。 34 和 89 也都非常接近 φ<sup>9</sup> / √<span style="text-decoration: overline">5</span> 和 φ<sup>11</sup> / √<span style="text-decoration: overline">5</span> 的值，其中后者是前者的 φ<sup>2</sup> 倍。但 34 等于 φ<sup>9</sup> / √<span style="text-decoration: overline">5</span> 加上某个很小的数， 89 等于 φ<sup>11</sup> / √<span style="text-decoration: overline">5</span> 加上某个更小的数，因而 34 的 φ<sup>2</sup> 倍也会比 89 略大一些。类似地， 21 · φ 和 21 · φ<sup>2</sup> 正好比 34 和 55 稍小一些，也是因为 21 等于 φ<sup>8</sup> / √<span style="text-decoration: overline">5</span> 减去某个很小的数， 34 等于 φ<sup>9</sup> / √<span style="text-decoration: overline">5</span> 加上某个很小的数， 55 等于 φ<sup>10</sup> / √<span style="text-decoration: overline">5</span> 减去某个更小的数。</p>
<p>这就回到了我们刚才观察到的现象：序列 W 中的第 2 个数对是 (3, 5) ，第 5 个数对是 (8, 13) ，第 13 个数对是 (21, 34) ，第 34 个数对是 (55, 89) ……我们也就算是证明了刚才提到的结论：把 Fibonacci 数列写下来，并且从 (1, 2) 开始，每两个数组成一个数对，则由此得到的所有数对都在序列 W 当中。</p>
<p> </p>
<p>于是，我们挖的坑又只剩最后一个了：为什么 φ<sup>n</sup> / √<span style="text-decoration: overline">5</span> – (1 – φ)<sup>n</sup> / √<span style="text-decoration: overline">5</span> 是 Fibonacci 数列的通项公式呢？这有一个非常具有启发性的推导方法。</p>
<p>让我们把满足递推式 a(n) = a(n – 1) + a(n – 2) 的数列叫作“广义 Fibonacci 数列”。而真正的 Fibonacci 数列，则可以看作是由初始条件 a(1) = 1 和 a(2) = 1 生成的。首先注意到，让广义 Fibonacci 数列里的每一项都乘上非 0 实数 c ，得到的仍然是一个广义 Fibonacci 数列。也就是说，如果数列</p>
<p class="indent">a(1), a(2), a(3), a(4), a(5), …</p>
<p>是一个由 a(1) 和 a(2) 生成的广义 Fibonacci 数列，那么</p>
<p class="indent">c · a(1), c · a(2), c · a(3), c · a(4), c · a(5), …</p>
<p>就是一个由 c · a(1) 和 c · a(2) 生成的广义 Fibonacci 数列。</p>
<p>另外，两个广义 Fibonacci 数列之和必然也是一个广义 Fibonacci 数列。也就是说，如果数列</p>
<p class="indent">a(1), a(2), a(3), a(4), a(5), …</p>
<p>是一个由 a(1) 和 a(2) 生成的广义 Fibonacci 数列，并且数列</p>
<p class="indent">b(1), b(2), b(3), b(4), b(5), …</p>
<p>是一个由 b(1) 和 b(2) 生成的广义 Fibonacci 数列，那么数列</p>
<p class="indent">a(1) + b(1), a(2) + b(2), a(3) + b(3), a(4) + b(4), a(5) + b(5), …</p>
<p>就是一个由 a(1) + b(1) 和 a(2) + b(2) 生成的广义 Fibonacci 数列。</p>
<p>最后， φ 和 1 – φ 是方程 1 + x = x<sup>2</sup> 的两根，因而数列</p>
<p class="indent">φ, φ<sup>2</sup>, φ<sup>3</sup>, φ<sup>4</sup>, φ<sup>5</sup>, φ<sup>6</sup>, …</p>
<p>和</p>
<p class="indent">1 – φ, (1 – φ)<sup>2</sup>, (1 – φ)<sup>3</sup>, (1 – φ)<sup>4</sup>, (1 – φ)<sup>5</sup>, (1 – φ)<sup>6</sup>, …</p>
<p>就成了两个非常特别的广义 Fibonacci 数列。</p>
<p>把上面三点结合起来，我们将会得出结论：对于任意的实数 k 、 l ，数列</p>
<p class="indent">k · φ + l · (1 – φ), k · φ<sup>2</sup> + l · (1 – φ)<sup>2</sup>, k · φ<sup>3</sup> + l · (1 – φ)<sup>3</sup>, k · φ<sup>4</sup> + l · (1 – φ)<sup>4</sup>, …</p>
<p>都是一个广义 Fibonacci 数列。如果我们能找出合适的 k 和 l ，使得它们同时满足</p>
<p class="indent">k · φ + l · (1 – φ) = 1, k · φ<sup>2</sup> + l · (1 – φ)<sup>2</sup> = 1</p>
<p>这两个方程，那么我们就相当于找到了 Fibonacci 数列的通项公式。解得 k = 1 / √<span style="text-decoration: overline">5</span>, l = – 1 / √<span style="text-decoration: overline">5</span> ，因而 Fibonacci 数列实际上就是</p>
<p class="indent">φ / √<span style="text-decoration: overline">5</span> – (1 – φ) / √<span style="text-decoration: overline">5</span>, φ<sup>2</sup> / √<span style="text-decoration: overline">5</span> – (1 – φ)<sup>2</sup> / √<span style="text-decoration: overline">5</span>, φ<sup>3</sup> / √<span style="text-decoration: overline">5</span> – (1 – φ)<sup>3</sup> / √<span style="text-decoration: overline">5</span>, φ<sup>4</sup> / √<span style="text-decoration: overline">5</span> – (1 – φ)<sup>4</sup> / √<span style="text-decoration: overline">5</span>, …</p>
<p>这就是 Fibonacci 数列的通项公式。容易看出，事实上，一切的广义 Fibonacci 数列都可以表示成</p>
<p class="indent">k · φ + l · (1 – φ), k · φ<sup>2</sup> + l · (1 – φ)<sup>2</sup>, k · φ<sup>3</sup> + l · (1 – φ)<sup>3</sup>, k · φ<sup>4</sup> + l · (1 – φ)<sup>4</sup>, …</p>
<p>的形式，我们只需要求解关于 k 和 l 的二元一次方程组</p>
<p class="indent">k · φ + l · (1 – φ) = a(1), k · φ<sup>2</sup> + l · (1 – φ)<sup>2</sup> = a(2)</p>
<p>即可。因此，各种广义 Fibonacci 数列也将继承 Fibonacci 数列的很多宏观特征。比方说，随着 n 的增加， k · φ<sup>n</sup> 的绝对值将会迅速变得非常非常大（即使 k 本身的绝对值很小）， l · (1 – φ)<sup>n</sup> 的绝对值将会正负交替地迅速向 0 靠拢（即使 l 本身的绝对值很大），最终 k · φ<sup>n</sup> + l · (1 – φ)<sup>n</sup> 将会一上一下地无限靠近 k · φ<sup>n</sup> 。也就是说，足够多项之后，一切广义 Fibonacci 数列都会一上一下地无限近似于一个以 φ 为公比的等比数列。</p>
<p> </p>
<p>Fibonacci 数列有很多神奇之处，它的通项公式只是其中之一。每次说到 Fibonacci 数列时，我都喜欢讲讲 Fibonacci 数列的另一个神奇之处，就是 Zeckendorf 定理。这是由比利时数学家 Edouard Zeckendorf 发现的：任何一个正整数都可以唯一地表示成若干个不相邻的 Fibonacci 之和。例如，100 可以表示成 89 + 8 + 3 。我们把正整数的这种表示方法叫作它的 Zeckendorf 表达。注意，虽然 100 也可以表示成 55 + 34 + 8 + 2 + 1 ，但 55 和 34 是相邻的 Fibonacci 数， 2 和 1 也是相邻的 Fibonacci 数，因此这不能算 100 的 Zeckendorf 表达。需要特别指出的是，由于 F<sub>1</sub> 和 F<sub>2</sub> 都是 1 ，因此选了 F<sub>1</sub> 和 F<sub>3</sub> 本质上就相当于选了 F<sub>2</sub> 和 F<sub>3</sub> ，根据规定，这也是不允许的。因此，接下来，我们假设每次选 1 的时候选的实际上都是 F<sub>2</sub> ，这不会改变问题的实质。换句话说，接下来，我们假设 F<sub>1</sub> 是不能选的。</p>
<p>为什么 Zeckendorf 表达总是存在的呢？这很容易看出来。只要不断地选取尽可能大的 Fibonacci 数，我们就能得到一个 Zeckendorf 表达。比如，如何得出 100 的一个 Zeckendorf 表达呢？不超过 100 的最大的 Fibonacci 数是 89 。从 100 里减去 89 后，剩下的部分是 11 。不超过 11 的最大的 Fibonacci 数是 8 。从 11 里减去 8 后，剩下的部分是 3 ，这已经是一个 Fibonacci 了。所以， 100 的 Zeckendorf 表达就是 89 + 8 + 3 。在这个过程中，我们肯定不会用到相邻的 Fibonacci 数。这是因为，如果正整数 N 介于 F<sub>i</sub> 和 F<sub>i+1</sub> 之间（其中 F<sub>i</sub> 表示第 i 个 Fibonacci 数），那么我们就有：</p>
<p class="indent">N – F<sub>i</sub> &lt; F<sub>i+1</sub> – F<sub>i</sub> = F<sub>i-1</sub></p>
<p>这说明，减去一个尽可能大的 Fibonacci 数，结果会比小一号的 Fibonacci 数更小。所以，在上面这种寻找 Zeckendorf 表达的过程中，我们会自动地跳过所有相邻的 Fibonacci 数。</p>
<p>Zeckendorf 定理真正最核心的，就是每一个正整数的 Zeckendorf 表达都是唯一的。为了证明这一点，让我们先来考虑两个问题。第一个问题是：从 F<sub>2</sub>, F<sub>3</sub>, …, F<sub>n</sub> 数中选出若干个不相邻的数，怎样选才能让它们的和最大呢？不断把较小的 Fibonacci 数往大了调，你会发现，和最大的选法显然就是</p>
<p class="indent">F<sub>n</sub> + F<sub>n-2</sub> + F<sub>n-4</sub> + …</p>
<p>如果 n 是偶数，上式将会以 … + F<sub>4</sub> + F<sub>2</sub> 结尾。如果 n 是奇数，上式将会以 … + F<sub>5</sub> + F<sub>3</sub> 结尾。这个数究竟等于多少呢？这个数与 F<sub>n+1</sub> 很接近。这是因为：</p>
<p class="indent">  F<sub>n+1</sub><br>
= F<sub>n</sub> + F<sub>n-1</sub><br>
= F<sub>n</sub> + F<sub>n-2</sub> + F<sub>n-3</sub><br>
= F<sub>n</sub> + F<sub>n-2</sub> + F<sub>n-4</sub> + F<sub>n-5</sub><br>
= ……</p>
<p>不断像这样展开后，根据 n 的奇偶性的不同，我们要么会得到 F<sub>n</sub> + F<sub>n-2</sub> + F<sub>n-4</sub> + … + F<sub>4</sub> + F<sub>2</sub> + F<sub>1</sub> ，要么会得到 F<sub>n</sub> + F<sub>n-2</sub> + F<sub>n-4</sub> + … + F<sub>5</sub> + F<sub>3</sub> + F<sub>2</sub> 。不管是哪种情况，这都比刚才选出的最大和多了一个 1 。也就是说，从 F<sub>2</sub>, F<sub>3</sub>, …, F<sub>n</sub> 中选出若干个不相邻的数，最大的和为 F<sub>n+1</sub> – 1 。</p>
<p>我们需要考虑的第二个问题是， n 个物体排成一排，从中选出若干个不相邻的物体（可以不选），一共有多少种不同的方案？不妨把答案记作 a(n) 。如果只有 1 个物体，我们要么选它，要么不选它，一共有 2 种选法。如果有 2 个物体，我们要么选这个，要么选那个，要么都不选，一共有 3 种选法。也就是说， a(1) = 2 ， a(2) = 3 。另外，面对 n 个物体，满足要求的选法分为两类：如果不选最后那个物体，那就完全得看前 n – 1 个物体怎么选，这里面的方案数为 a(n – 1） ；如果选了最后那个物体，那么剩下的就只能再在前 n – 2 个物体里选了，这里面的方案数为 a(n – 2) 。这说明， a(n) = a(n – 1) + a(n – 2) 。于是，数列 a(1), a(2), a(3), a(4), … 实际上就是 2, 3, 5, 8, …。换句话说， a(n) = F<sub>n + 2</sub></p>
<p>结合上面两点，我们得到了这样一个结论：从 F<sub>2</sub> 到 F<sub>n</sub> 这 n – 1 个数中选出若干个不相邻的数（可以不选），一共有 F<sub>n+1</sub> 种选法；而这些数的总和的取值范围，则在 0 到 F<sub>n+1</sub> – 1 之间。所以，我们有 F<sub>n+1</sub> 种选法，有 F<sub>n+1</sub> 种可能的取值。另一方面，我们之前证明了，每个正整数都有至少一个 Zeckendorf 表达。所以，  F<sub>n+1</sub> 种选法必须得既无重复又无遗漏地取遍 F<sub>n+1</sub> 种可能的取值。这就说明了，每一个正整数的 Zeckendorf 表达都是唯一的。</p>
<p> </p>
<p>等等，我们是怎么扯到 Zeckendorf 表达的？让我想一想啊……哦！想起来了！想起来了！我们是从棋盘游戏，扯到与之等价的 Wythoff 游戏，扯到哪些状态后行者必胜，扯到 Wythoff 所定义的序列 W ，扯到序列 W 包含了一对一对的 Fibonacci 数，扯到 Fibonacci 数列那著名的通项公式，最后扯到了正整数的 Zeckendorf 表达。</p>
<p>扯远了，扯远了。我们再把整个思路捯回去。序列 W 的公式为：</p>
<p class="indent">([1 · φ], [1 · φ<sup>2</sup>]), ([2 · φ], [2 · φ<sup>2</sup>]), ([3 · φ], [3 · φ<sup>2</sup>]), ([4 · φ], [4 · φ<sup>2</sup>]), …</p>
<p>由此算出序列 W 的前几项：</p>
<p class="indent">(1, 2), (3, 5), (4, 7), (6, 10), (8, 13), (9, 15), (11, 18), (12, 20), (14, 23), (16, 26), (17, 28), (19, 31), (21, 34), (22, 36), (24, 39), (25, 41), (27, 44), (29, 47), (30, 49), …</p>
<p>我们证明了，序列 W 满足以下三个重要的性质：</p>
<ul>
<li>性质 1 ： W 里面正好既无重复又无遗漏地包含了每一个正整数</li>
<li>性质 2 ： W 当中各项里的两数之差依次为 1, 2, 3, …</li>
<li>性质 3 ： W 当中各项里的较小数依次递增</li>
</ul>
<p>这三个性质保证了， W 当中的所有项正好是 Wythoff 游戏中后行者必胜的所有状态。然后，我们发现 W 当中有很多项里包含了 Fibonacci 数。把它们连在一起，正好就是完整的 Fibonacci 数列：</p>
<p class="indent">(1, 2), (3, 5), (8, 13), (21, 34), …</p>
<p>其中 (1, 2) 后面的 (3, 5) 正好是 W 当中的第 2 项， (3, 5) 后面的 (8, 13) 正好是 W 当中的第 5 项， (8, 13) 后面的 (21, 34) 正好是 W 当中的第 13 项，以此类推。</p>
<p>那么， W 当中的其他项呢？仔细观察 W 当中的其他项，你能看出什么端倪吗？答案是， W 当中的其他项还隐藏着别的广义 Fibonacci 数列！比方说， W 当中的</p>
<p class="indent">(4, 7), (11, 18), (29, 47), …</p>
<p>正好拼成一个以 4, 7 打头的广义 Fibonacci 数列！而且， (11, 18) 就是 W 当中的第 7 项， (29, 47) 就是 W 当中的第 18 项。来猜猜看， (76, 123) 会不会正好是 W 当中的第 47 项？计算可得 47 · φ ≈ 76.0476 ， 47 · φ<sup>2</sup> ≈ 123.048 。根据序列 W 的定义，第 47 项真的就是 (76, 123) ！</p>
<p>接下来，我们就来证明这件事：如果 (a, b) 是序列 W 中的某个数对，那么序列 W 中的第 b 项就是 (a + b, a + 2b) 。由于第 b 项里的两数之差就是 b ，因此我们只需要证明：如果 (a, b) 是序列 W 中的某个数对，那么序列 W 中的第 b 项的较小数就是 a + b 。不妨假设 (a, b) 是序列 W 中的第 n 项。根据序列 W 的定义， a 就等于 [n · φ] ， b 就等于 [n · φ<sup>2</sup>] ，而第 b 项的较小数则是 [[n · φ<sup>2</sup>] · φ] 。所以，我们真正只需要证明的就是：对于任意正整数 n ，都有 [n · φ] + [n · φ<sup>2</sup>] = [[n · φ<sup>2</sup>] · φ] 。这本质上就是证明：</p>
<p class="indent">[n · φ] + [n · φ<sup>2</sup>] ≤ [n · φ<sup>2</sup>] · φ &lt; [n · φ] + [n · φ<sup>2</sup>] + 1</p>
<p>不妨用 {x} 表示 x 的小数部分。上式就变为了</p>
<p class="indent">n · φ – {n · φ} + n · φ<sup>2</sup> – {n · φ<sup>2</sup>} ≤ (n · φ<sup>2</sup> – {n · φ<sup>2</sup>}) · φ &lt; n · φ – {n · φ} + n · φ<sup>2</sup> – {n · φ<sup>2</sup>} + 1</p>
<p>也就是：</p>
<p class="indent">n · φ – {n · φ} + n · φ<sup>2</sup> – {n · φ<sup>2</sup>} ≤ n · φ<sup>3</sup> – {n · φ<sup>2</sup>} · φ &lt; n · φ – {n · φ} + n · φ<sup>2</sup> – {n · φ<sup>2</sup>} + 1</p>
<p>然而， φ 满足 1 + φ = φ<sup>2</sup> ，也就满足 n · φ + n · φ<sup>2</sup> = n · φ<sup>3</sup> 。于是，上面的不等式进一步简化为</p>
<p class="indent">– {n · φ} – {n · φ<sup>2</sup>} ≤ – {n · φ<sup>2</sup>} · φ &lt; – {n · φ} – {n · φ<sup>2</sup>} + 1</p>
<p>即</p>
<p class="indent">{n · φ} + {n · φ<sup>2</sup>} ≥ {n · φ<sup>2</sup>} · φ &gt; {n · φ} + {n · φ<sup>2</sup>} – 1</p>
<p>最后，别忘了 φ 和 φ<sup>2</sup> 正好相差 1 ，因而 n · φ 和 n · φ<sup>2</sup> 正好相差一个整数，也就是说它们的小数部分是相等的。如果令它们的小数部分均为 r ，则上式变为</p>
<p class="indent">2 · r ≥ r · φ &gt; 2 · r – 1</p>
<p>由于 r 是一个 0 到 1 之间的数，而 φ ≈ 1.618 ，所以上式显然成立。至此，我们就证明了，对于任意正整数 n ，都有 [n · φ] + [n · φ<sup>2</sup>] = [[n · φ<sup>2</sup>] · φ] 。</p>
<p>利用取整符号和常数 φ ，我们还能构造出很多类似的恒等式。用上面的这套方法来证明这些恒等式，则显得格外有效。为了说明这一点，我打算不惜文章的连贯性，在此处穿插一个习题。这是我最近见到的一个题目。讲完这个题目的解法后，我们会立即言归正传。题目是：求证，对于任意正整数 n ，都有 [[n · φ] · φ] = [n · φ<sup>2</sup>] – 1 。</p>
<p>解法和之前的几乎如出一辙。原等式等价于</p>
<p class="indent">[n · φ<sup>2</sup>] – 1 ≤ [n · φ] · φ &lt; [n · φ<sup>2</sup>]</p>
<p>它又可以变成</p>
<p class="indent">n · φ<sup>2</sup> – {n · φ<sup>2</sup>} – 1 ≤ (n · φ – {n · φ}) · φ &lt; n · φ<sup>2</sup> – {n · φ<sup>2</sup>}</p>
<p>即</p>
<p class="indent">n · φ<sup>2</sup> – {n · φ<sup>2</sup>} – 1 ≤ n · φ<sup>2</sup> – {n · φ} · φ &lt; n · φ<sup>2</sup> – {n · φ<sup>2</sup>}</p>
<p>即</p>
<p class="indent">– {n · φ<sup>2</sup>} – 1 ≤ – {n · φ} · φ &lt; – {n · φ<sup>2</sup>}</p>
<p>即</p>
<p class="indent">{n · φ<sup>2</sup>} + 1 ≥ {n · φ} · φ &gt; {n · φ<sup>2</sup>}</p>
<p>由于 {n · φ} = {n · φ<sup>2</sup>} ，因此我们把它们都换成 r 。整个式子就变为了：</p>
<p class="indent">r + 1 ≥ r · φ &gt; r</p>
<p>同样地，由于 r 是一个 0 到 1 之间的数，而 φ ≈ 1.618 ，所以上式显然成立。</p>
<p> </p>
<p>如果序列 W 当中有 (a, b) 和 (a + b, a + 2b) 这么两项，我们就说， (a + b, a + 2b) 接在 (a, b) 后面。而我们刚才证明的实际上就是，序列 W 当中的第 [1 · φ<sup>2</sup>], [2 · φ<sup>2</sup>], [3 · φ<sup>2</sup>], … 项将会分别接在第 1, 2, 3, … 项的后面。把该接起来的数对全都接起来，我们就会得到很多链条，比如之前就已经观察到的</p>
<p class="indent">(1, 2), (3, 5), (8, 13), (21, 34), …</p>
<p>和</p>
<p class="indent">(4, 7), (11, 18), (29, 47), …</p>
<p>显然，每个链条里的数都构成了一个广义 Fibonacci 数列。而每个链条打头的数对，则是那些不能接在任何数对后面的数对，也就是第 [1 · φ<sup>2</sup>], [2 · φ<sup>2</sup>], [3 · φ<sup>2</sup>], … 项以外的数对。由 Beatty-Rayleigh 定理可知，它们正好就是 W 当中的第 [1 · φ], [2 · φ], [3 · φ], … 项。所以，我们把 W 当中的第 [1 · φ], [2 · φ], [3 · φ], … 项竖着写成一列，再不断地写出每个数对后面接着的数对，就能完整地给出 W 当中的数对产生的所有链条了。联想到 W 里面既无重复又无遗漏地包含了每一个正整数，因而我们相当于把全体正整数排成了一张无限大的数表，每个正整数都恰好只用了 1 次，使得数表中的每一行都是一个广义 Fibonacci 数列！我们把这个神奇的数表叫作 Wythoff 数表。</p>
<p class="indent">(1, 2) – (3, 5) – (8, 13) – (21, 34) – (55, 89) – (144, 233) – …<br>
(4, 7) – (11, 18) – (29, 47) – (76, 123) – (199, 322) – (521, 843) – …<br>
(6, 10) – (16, 26) – (42, 68) – (110, 178) – (288, 466) – (754, 1220) – …<br>
(9, 15) – (24, 39) – (63, 102) – (165, 267) – (432, 699) – (1131, 1830) – …<br>
(12, 20) – (32, 52) – (84, 136) – (220, 356) – (576, 932) – (1508, 2440) – …<br>
(14, 23) – (37, 60) – (97, 157) – (254, 411) – (665, 1076) – (1741, 2817) – …<br>
(17, 28) – (45, 73) – (118, 191) – (309, 500) – (809, 1309) – (2118, 3427) – …<br>
… … … … … … …</p>
<p>真正神奇的事情出现了。现在，我们约定，接下来所说的广义 Fibonacci 数列一律限定在正整数范围内。如果两个广义 Fibonacci 数列的本质完全相同，只是下标被整体平移了一下，我们就认为它们俩是同一个数列。比方说，以 2, 1 打头的广义 Fibonacci 数列（这叫作 Lucas 数列）为：</p>
<p class="indent">2, 1, 3, 4, 7, 11, 18, 29, 47</p>
<p>它就是 Wythoff 数表中的第二行。接下来，我们来证明一个非常让人震惊的事实：在这个意义下， Wythoff 数表包含了所有可能的广义 Fibonacci 数列！</p>
<p>证明方法很简单。还记得吗，我们之前曾经得出，一切广义 Fibonacci 数列最终都会一上一下地无限地近似于一个以 φ 为公比的等比数列。所以，如果 a(1), a(2), a(3), … 是一个广义 Fibonacci 数列，那么我们一定能在找到某个 n ，使得 a(n + 1) = [a(n) · φ] ，并且 a(n + 2) = [a(n) · φ<sup>2</sup>] 。然而， ([a(n) · φ], [a(n) · φ<sup>2</sup>]) 就是序列 W 当中的第 a(n) 项，它出现在了 Wythoff 数表的某一行里。这一行所对应的广义 Fibonacci 数列，本质上就是数列 a(1), a(2), a(3), … 。</p>
<p> </p>
<p>我们证明了一个如此优美的结论，将之前的所有东西都贯穿在了一起，一切都非常漂亮地完结了。再来一个简单的收尾后，这篇文章就该结束了。毕竟，我们之前挖过的所有坑都填上了，我们之前提过的所有东西都用到了。呃……是吗？</p>
<p>编故事有一个非常重要的原则，叫作“契科夫之枪”（Chekhov’s gun）。它说的是：如果你在第一章里提到了墙上挂着一把来复枪，那在第二章或者第三章里面它一定会开火，否则它就不应该挂在那里。举个例子：主人公踏上征途之前，一哥们儿给他递上一件东西并说：“把这个带上吧，没准儿能用上……”好，这玩意儿百分之百地会被用上。如果故事片里有一个镜头专门对着播报新闻的电视，记住了，这肯定和剧情有联系。如果枪战片里的人来到一个大房间，四壁都是养着鱼的大水缸……呵呵，我不说你都知道一会儿会出现啥。</p>
<p>这篇文章也挂着好几把契科夫之枪。比方说，刚才突然来的那个习题是怎么回事？在那个习题中，我们证明了 [[n · φ] · φ] = [n · φ<sup>2</sup>] – 1 恒成立。好了，现在考虑 Wythoff 数表的第 n 行，它是一个广义 Fibonacci 数列。如果再把这个数列往前推两项，会得到什么？注意到， Wythoff 数表的第 n 行是以序列 W 当中的第 [n · φ] 项打头的。也就是说， Wythoff 数表的第 n 行的头两个数是 [[n · φ] · φ], [[n · φ] · φ<sup>2</sup>] 。由于一个数的 φ 倍和 φ<sup>2</sup> 倍（以及它们同时取整后的结果）正好相差这个数本身这么多，因此 [[n · φ] · φ<sup>2</sup>] – [[n · φ] · φ] = [n · φ] ，并且 [[n · φ] · φ] – [n · φ] = [n · φ<sup>2</sup>] – 1 – [n · φ] = n – 1 。这就说明， Wythoff 数表的第 n 行可以看作是由 n – 1, [n · φ] 生成的广义 Fibonacci 数列。所以，我们得到了 Wythoff 数表的一个等价定义：在第 -1 列依次写下 0, 1, 2, 3, … ，在第 0 列对应地依次写下 [1 · φ], [2 · φ], [3 · φ], … ，于是每一行里都有两个数了；在每一行里都不断往后面写下新的数，每个数都是它的前面两个数之和，最后得到的就是 Wythoff 数表——它既无重复又无遗漏地包含了所有正整数，也既无重复又无遗漏地包含了所有广义 Fibonacci 数列。</p>
<table>
<tr>
<td style="color: #009bdf">0</td>
<td style="color: #009bdf">1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>21</td>
<td>34</td>
<td>55</td>
<td>89</td>
<td>…</td>
</tr>
<tr>
<td style="color: #009bdf">1</td>
<td style="color: #009bdf">3</td>
<td>4</td>
<td>7</td>
<td>11</td>
<td>18</td>
<td>29</td>
<td>47</td>
<td>76</td>
<td>123</td>
<td>199</td>
<td>322</td>
<td>…</td>
</tr>
<tr>
<td style="color: #009bdf">2</td>
<td style="color: #009bdf">4</td>
<td>6</td>
<td>10</td>
<td>16</td>
<td>26</td>
<td>42</td>
<td>68</td>
<td>110</td>
<td>178</td>
<td>288</td>
<td>466</td>
<td>…</td>
</tr>
<tr>
<td style="color: #009bdf">3</td>
<td style="color: #009bdf">6</td>
<td>9</td>
<td>15</td>
<td>24</td>
<td>39</td>
<td>63</td>
<td>102</td>
<td>165</td>
<td>267</td>
<td>432</td>
<td>699</td>
<td>…</td>
</tr>
<tr>
<td style="color: #009bdf">4</td>
<td style="color: #009bdf">8</td>
<td>12</td>
<td>20</td>
<td>32</td>
<td>52</td>
<td>84</td>
<td>136</td>
<td>220</td>
<td>356</td>
<td>576</td>
<td>932</td>
<td>…</td>
</tr>
<tr>
<td style="color: #009bdf">5</td>
<td style="color: #009bdf">9</td>
<td>14</td>
<td>23</td>
<td>37</td>
<td>60</td>
<td>97</td>
<td>157</td>
<td>254</td>
<td>411</td>
<td>665</td>
<td>1076</td>
<td>…</td>
</tr>
<tr>
<td style="color: #009bdf">6</td>
<td style="color: #009bdf">11</td>
<td>17</td>
<td>28</td>
<td>45</td>
<td>73</td>
<td>118</td>
<td>191</td>
<td>309</td>
<td>500</td>
<td>809</td>
<td>1309</td>
<td>…</td>
</tr>
<tr>
<td style="color: #009bdf">…</td>
<td style="color: #009bdf">…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</table>
<p>还记得 Zeckendorf 表达吗？接下来，该轮到它返场了！现在我们定义，把一个正整数的 Zeckendorf 表达里的所有 Fibonacci 数都往后移一位，得到的新的正整数就是原正整数的 “Fibonacci 后继” 。例如， 100 的 Zeckendorf 表达是 89 + 8 + 3 ，其中 89 的下一个 Fibonacci 数是 144 ， 8 的下一个 Fibonacci 数是 13 ， 3 的下一个 Fibonacci 数是 5 。那么， 100 的 Fibonacci 后继就是 144 + 13 + 5 ，也就是 162 。我们用 S(n) 来表示正整数 n 的 Fibonacci 后继。刚才我们演示的就是， S(100) = 162 。接下来，我们将证明这么一个结论：对于任意正整数 n 都有， 1 + S(n) 等于 [(n + 1) · φ] 。</p>
<p>如果 n 的 Zeckendorf 表达中各个 Fibonacci 数的下标为 i<sub>1</sub>, i<sub>2</sub>, i<sub>3</sub>, … ，令 </p>
<p class="indent">X = φ<sup>i<sub>1</sub></sup> + φ<sup>i<sub>2</sub></sup> + φ<sup>i<sub>3</sub></sup> + …</p>
<p>令</p>
<p class="indent">Y = (1 – φ)<sup>i<sub>1</sub></sup> + (1 – φ)<sup>i<sub>2</sub></sup> + (1 – φ)<sup>i<sub>3</sub></sup> + …</p>
<p>那么 n 就可以写成</p>
<p class="indent">X / √<span style="text-decoration: overline">5</span> – Y / √<span style="text-decoration: overline">5</span></p>
<p>由于 1 – φ 是一个绝对值小于 1 的负数，因而当 i<sub>1</sub>, i<sub>2</sub>, i<sub>3</sub>, … 正好是全体正偶数时， Y 的值达到最大。利用等比数列的求和公式可知， Y 的最大值是 φ – 1 ≈ 0.618 。对应地，当 i<sub>1</sub>, i<sub>2</sub>, i<sub>3</sub>, …  正好是全体大于 1 的正奇数时， Y 的值则达到最小（注意，在 Zeckendorf 表达里， Fibonacci 数的下标不能取 1 ）。利用等比数列的求和公式可知， Y 的最小值是 φ – 2 ≈ – 0.382 。当然，对于任意一个有限大的 n 来说，刚才算出的最大值和最小值都是取不到的。</p>
<p>为了把 n 变成 S(n) ，我们只需要把 X 里的每一个 φ 和 Y 里的每一个 (1 – φ) 的指数都变大一号即可。于是， 1 + S(n) 就可以表示为：</p>
<p class="indent">1 + φ · X / √<span style="text-decoration: overline">5</span> – (1 – φ) · Y / √<span style="text-decoration: overline">5</span></p>
<p>而我们要证明 1 + S(n) = [(n + 1) · φ] ，也就是</p>
<p class="indent">1 + φ · X / √<span style="text-decoration: overline">5</span> – (1 – φ) · Y / √<span style="text-decoration: overline">5</span> = [φ · X / √<span style="text-decoration: overline">5</span> – φ · Y / √<span style="text-decoration: overline">5</span> + φ]</p>
<p>由于等式左边的式子是一个整数，因此我们只需要证明等式右边的取整符号内的式子比等式左边的式子更大，但不会大 1 或更多。也就是说，我们只需要证明：</p>
<p class="indent">0 ≤ (φ · X / √<span style="text-decoration: overline">5</span> – φ · Y / √<span style="text-decoration: overline">5</span> + φ) – (1 + φ · X / √<span style="text-decoration: overline">5</span> – (1 – φ) · Y / √<span style="text-decoration: overline">5</span>) &lt; 1</p>
<p>而</p>
<p class="indent">  (φ · X / √<span style="text-decoration: overline">5</span> – φ · Y / √<span style="text-decoration: overline">5</span> + φ) – (1 + φ · X / √<span style="text-decoration: overline">5</span> – (1 – φ) · Y / √<span style="text-decoration: overline">5</span>)<br>
= (1 – φ) · Y / √<span style="text-decoration: overline">5</span> – φ · Y / √<span style="text-decoration: overline">5</span> + φ – 1<br>
= (1 – 2φ) · Y / √<span style="text-decoration: overline">5</span> + φ – 1</p>
<p>是一个关于 Y 的一次函数，且当 Y = φ – 2 时函数值为 1 ， Y = φ – 1 时函数值为 0 。这就说明，这个一次函数的函数值永远在 0 和 1 之间。至此，我们就证到了， 1 + S(n) 等于 [(n + 1) · φ] 。</p>
<p>之前我们提到了 Wythoff 数表的等价定义：在第 -1 列依次写下 0, 1, 2, 3, … ，在第 0 列对应地依次写下 [1 · φ], [2 · φ], [3 · φ], … ，然后每一行都不断往后面接着写，使得每个数都是它的前面两个数之和。由于 1 + S(n) 等于 [(n + 1) · φ] ，因此上面这个等价定义可以进一步改成：在第 -1 列依次写下 0, 1, 2, 3, … ，在第 0 列对应地依次写下 1 + S(0), 1 + S(1), 1 + S(2), … （这里，我们规定 S(0) = 0 ），然后每一行都不断往后面接着写，使得每个数都是它的前面两个数之和。</p>
<p>所以，第 1 列的数就应该依次为 0 + (1 + S(0)), 1 + (1 + S(1)), 2 + (1 + S(2)), … 。仔细想一想， n + (1 + S(n)) 究竟是什么？容易观察到， n + S(n) 的 Zeckendorf 表达与 n 的 Zeckendorf 表达有非常直接的联系。如果 n 等于 F<sub>i<sub>1</sub></sub> + F<sub>i<sub>2</sub></sub> + … + F<sub>i<sub>k</sub></sub> ，那么 S(n) 就等于 F<sub>i<sub>1</sub>+1</sub> + F<sub>i<sub>2</sub>+1</sub> + … + F<sub>i<sub>k</sub>+1</sub> ，于是 n + S(n) 就等于 F<sub>i<sub>1</sub>+2</sub> + F<sub>i<sub>2</sub>+2</sub> + … + F<sub>i<sub>k</sub>+2</sub> 。可见， n + S(n) 的 Zeckendorf 表达就是 n 的 Zeckendorf 表达中所有 Fibonacci 数都往后移两位而得的，显然它里面不包含 F<sub>2</sub> 和 F<sub>3</sub> ，最小的一项至少都是 F<sub>4</sub> 。因此，为了得到 n + (1 + S(n)) 的 Zeckendorf 表达，我们只需要在 n + S(n) 的 Zeckendorf 表达里直接添加一个 F<sub>2</sub> 就行了。</p>
<p>举个例子，如果某一行的第 -1 个数是 F<sub>2</sub> + F<sub>4</sub> + F<sub>9</sub> ，那么第 0 个数就是 1 + F<sub>3</sub> + F<sub>5</sub> + F<sub>10</sub> ，第 1 个数就是 F<sub>2</sub> + F<sub>4</sub> + F<sub>6</sub> + F<sub>11</sub> 。那么，这一行的第 2 个数是多少呢？由于第 2 个数是第 0 个数和第 1 个数之和，因此第 2 个数就是 F<sub>3</sub> + F<sub>5</sub> + F<sub>7</sub> + F<sub>12</sub> ，其中 1 和 F<sub>2</sub> 合并后得到了 F<sub>3</sub> 。类似地，由于第 3 个数是第 1 个数和第 2 个数之和，因此第 3 个数就是 F<sub>4</sub> + F<sub>6</sub> + F<sub>8</sub> + F<sub>13</sub> ；由于第 4 个数是第 2 个数和第 3 个数之和，因此第 4 个数就是 F<sub>5</sub> + F<sub>7</sub> + F<sub>9</sub> + F<sub>14</sub> ……规律已经非常明显了：在 Wythoff 数表当中，每一行的第 1 个数的 Zeckendorf 表达的最小项都是 F<sub>2</sub> ，并且今后的每一个数都是它前一个数的 Fibonacci 后继，其 Zeckendorf 表达的最小项依次升级为 F<sub>3</sub>, F<sub>4</sub>, F<sub>5</sub>, … ！</p>
<p>回想 Wythoff 数表最早最早的定义：不断把那些不能接在任何数对后面的数对拎出来打头所得的一行一行的链条。因此，每一行打头的数都是在前面从来没有出现过的数中最小的数。所以，我们有了一种另类的生成 Wythoff 数表的方式。先在第一行的开头写下 1 。在它的右边不断写下 S(1), S(S(1)), S(S(S(1))), … 此时，在所有仍未出现的数中，最小的数是 4 。接下来，我们就在第二行的开头写下 4 ，并在它的右边不断写下 S(4), S(S(4)), S(S(S(4))), … 。此时，在所有仍未出现的数中，最小的数是 6 。接下来，我们就在第三行的开头写下 6 ，并在它的右边不断写下 S(6), S(S(6)), S(S(S(6))), … 。此时，在所有仍未出现的数中，最小的数是 8 。接下来，我们就在第四行的开头写下 8 ……不断这样做下去，我们就会得到一张无限大的数表，它就是 Wythoff 数表。这是 Wythoff 数表的另一个等价定义。</p>
<p>另外， Wythoff 数表的第 -1 列为 0, 1, 2, 3, … ，第 0 列依次为 [1 · φ], [2 · φ], [3 · φ], … ，这两列都是递增的。第 1 列的数等于第 -1 列的数和第 0 列的数之和。由于大点儿的数加上大点儿的数，和肯定也会更大，所以第 1 列的数也是递增的。同理，第 2 列，第 3 列，以至于今后的每一列，都是递增的。于是， Wythoff 数表还有这么一种生成方式：在第 1 列从小到大列出所有 Zeckendorf 表达的最小项为 F<sub>2</sub> 的数，在第 2 列从小到大列出所有 Zeckendorf 表达的最小项为 F<sub>3</sub> 的数，在第 3 列从小到大列出所有 Zeckendorf 表达的最小项为 F<sub>4</sub> 的数……不断这样做下去，我们就会得到一张无限大的数表，它就是 Wythoff 数表。这是 Wythoff 数表的又一个等价定义。</p>
<p> </p>
<p>最后让我们回到“挪动皇后”和 Wythoff 游戏。 Wythoff 游戏的所有后行者必胜的状态构成了序列 W ，它的公式为：</p>
<p class="indent">([1 · φ], [1 · φ<sup>2</sup>]), ([2 · φ], [2 · φ<sup>2</sup>]), ([3 · φ], [3 · φ<sup>2</sup>]), ([4 · φ], [4 · φ<sup>2</sup>]), …</p>
<p>反过来，如果你面对的状态在序列 W 以外，那么你就是必胜的。但是，必胜的策略是什么呢？必胜的策略自然就是，把当前状态变成序列 W 当中的某个状态。但是，到时候你怎么才能算出，究竟应该变成序列 W 当中的哪个状态呢？早些时候，我们证明了，变法确实是存在的（见序列 W 所满足的第 3 个条件）。但是，利用当时的证明方法，很难得出一套固定的、易实施的具体策略，可以帮我们每次都准确地找出这个变法。毕竟，在没有高精度计算器的情况下，你甚至连 W 里的每一项具体是多少都搞不出来。然而，最后那几个 Wythoff 数表的等价定义是非常离散的，这给上述问题的解决开辟了一条新路。比如，我们可以立即得出，数对 (a, b) 在序列 W 当中，当且仅当 a 的 Zeckendorf 表达的最小项的下标是一个偶数，并且 b = S(a) 。所以，我们就有了一种判断数对是否在 W 当中的方法。刚才证明过恒等式 1 + S(n) = [(n + 1) · φ] ，据此可以推出 S(n – 1) + 1 = [n · φ] ；于是，序列 W 当中的第 n 项就是 (S(n – 1) + 1, S(S(n – 1) + 1)) 。再结合之前给出的序列 W 满足条件 3 的证明，最终得出的结论将会正好与 1977 年 Robert Silber 对 Wythoff 游戏的分析结果完全一致：若数对 (a, b) 不在序列 W 当中（其中 0 &lt; a &lt; b ），则按照下述三种情况进行分类讨论，一定能把它变成序列 W 当中的某个数对。三种情况分别如下：</p>
<ul>
<li>若 a 的 Zeckendorf 表达的最小项的下标是一个奇数，则把 b 变成 S<sup>-1</sup>(a) 。这里 S<sup>-1</sup>(x) 表示把 x 的 Zeckendorf 表达里的所有 Fibonacci 数都往前移一位之后得到的结果。</li>
<li>若 a 的 Zeckendorf 表达的最小项的下标是一个偶数，并且 b &gt; S(a) ，则 b 变成 S(a) 。</li>
<li>若 a 的 Zeckendorf 表达的最小项的下标是一个偶数，并且 b &lt; S(a) ，那该怎么办呢？先计算出 b – a 的值，不妨把它记作 n ；然后，把 (a, b) 变成 (S(n – 1) + 1, S(S(n – 1) + 1)) 即可。</li>
</ul>
<p> </p>
<p>在写这篇文章的过程中，我看了很多资料。 1907 年， Willem Abraham Wythoff 在 A Modification of the Game of Nim 一文中提出了 Wythoff 游戏。 1977 年， Robert Silber 在 Wythoff’s NIM and Fibonacci Representations 一文中给出了基于 Fibonacci 数的分析。 Martin Gardner 在 Penrose Tiles to Trapdoor Ciphers 一书中对它们做了介绍。这三位作者的名字之前都有提过。 Wythoff 数表最早是 1980 年由 David Morrison 在 A Stolarsky Array of Wythoff Pairs 一文中提出的。它和 Zeckendorf 表达的关系则可以参见 Clark Kimberling 的 The Zeckendorf Array Equals the Wythoff Array 一文。与 Zeckendorf 表达本身有关的一些证明，尤其是 Zeckendorf 定理的证明，参考了 Tamás Lengyel 的 A Counting Based Proof of the Generalized Zeckendorf’s Theorem 一文。利用取整符号和常数 φ 能够构造出很多的恒等式，其证明方法参考了 Ian Connell 的 Some Properties of Beatty Sequences I 一文。我最早是因为看了 Neil Sloane 的 My Favorite Integer Sequences 一文后，了解到 Wythoff 数表，才打算写这篇文章的。为了把这一切联系在一起，形成一篇完整的文章，我写下了很多自己的理解，甚至有些地方的证明过程也是我自己的思考。如果有不对的地方，请网友们及时提出。</p>
<p>在数学世界里，各种数学研究对象织成了一张纵横交错的大网，捡石子游戏、 Wythoff 数表和 Fibonacci 数列只是其中的三个非常小的顶点而已。 2 万多字之后，我们终于把它们之间的种种关系理了个半清。但是，它们各自还能继续向外延伸，这些恐怕再花 20 万字也说不完。 Wythoff 游戏是 Nim 游戏的一个变种，后者在组合游戏理论中占据着非常核心的地位。对 Wythoff 游戏本身进行推广，还可以得到一系列类似的游戏。例如，把两堆石子换成三堆石子、四堆石子甚至 n 堆石子，情况又会怎样？很多数学家都对此有过研究。本文提到了 Wythoff 数表的很多令人意想不到的等价定义和非常让人震撼的数学性质，但这并不是 Wythoff 数表的全部。例如，在 Wythoff 数表中，下一行的每个数的大小正好夹在上一行数的空隙之间。这背后会涉及到非常有趣的 interspersion 和 dispersion 理论。 Wythoff 数表里既无重复又无遗漏地包含了所有正整数，那么从 1 开始的每个正整数究竟出现在了 Wythoff 数表中的哪一行呢？这个问题的答案就又构成了一个数列：</p>
<p class="indent">0, 0, 0, 1, 0, 2, 1, 0, 3, 2, 1, 4, 0, 5, 3, 2, 6, 1, 7, 4, …</p>
<p>这里我们规定， Wythoff 数表的首行为第 0 行。这个数列本身又有很多可圈可点之处，例如删掉数列中的第一个 0 、第一个 1 、第一个 2 等等，剩下的数列其实就是原数列本身。因此，这个数列具有分形的特征！当然，考察每个正整数究竟出现在了 Wythoff 数表中的哪一列，我们又可以得到一个数列，它也有很多独特的性质。</p>
<p>Fibonacci 数列和 Zeckendorf 表达里面的水就更深了。我之前曾经介绍过 Hofstadter 的非线性递推数列（ <a href="http://www.matrix67.com/blog/archives/5152">http://www.matrix67.com/blog/archives/5152</a> ），里面就涉及到了它们之间的各种更深层的联系。</p>
			 ]]></content>
<pubDate>2016-06-21T23:02:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6784</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ IMO2016 趣题：Geoff 的青蛙 ]]></title>
<link>http://www.matrix67.com/blog/archives/6851</link>
<content><![CDATA[ 
		<p>2016 年 IMO 的第 6 题（也就是第二天比赛的第 3 题）非常有趣，这恐怕算得上是近十年来 IMO 的所有题目中最有趣的题目之一。平面上有 n ≥ 2 条线段，每两条线段都有一个交点，并且任意三条线段都不交于同一点。 Geoff 打算在每条线段的其中一个端点处放置一只青蛙，并让每只青蛙都朝向它所在线段的另一个端点。然后， Geoff 将会拍 n – 1 次手。每次拍手时，每只青蛙都立即向前跳到它所在线段的下一个交点处（青蛙们在跳跃过程中始终不会改变方向）。 Geoff 希望巧妙地安排初始时放置青蛙的方法，使得在整个过程中，任意两只青蛙都不会同时到达某个相同的交点。这个题目有两个小问。</p>
<ol>
<li>证明：当 n 为奇数时， Geoff 一定有办法实现他的要求。</li>
<li>证明：当 n 为偶数时， Geoff 永远无法实现他的要求。</li>
</ol>
<p><span id="more-6851"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>下图是 n = 5 时的其中一种可能的线段布局，以及其中一种满足要求的青蛙放法。你可以试一试， n = 5 时的其他放法就不见得满足要求了，而 n 为偶数时的任何一种放法都是不满足要求的。</p>
<p class="indent"><img alt="image placeholder" >
<p>注意到，在上面这种满足要求的青蛙放法中，任何两只青蛙都不在“相邻”的端点上。这不是巧合。我们接下来说明，把两只青蛙放在“相邻”的端点上，则这两只青蛙必然会相撞。这里，我们可以为“相邻”下一个更加明确的定义。将所有线段充分延长，并与一个充分大的圆相交。把每条线段的端点都改到这些交点处，于是所有线段的所有端点就变为了一个圆周上的 2n 个点。如果两个端点之间的圆弧上没有其他端点，我们就说这两个端点是相邻的。</p>
<p class="indent"><img alt="image placeholder" >
<p>现在，假设我们把两只青蛙放在了两个相邻的端点上，如上图所示。蓝色的线表示的就是这两只青蛙所走的路，其中实线部分表示这两条路相交前的部分。由于两个端点是相邻的，因此这两条蓝线之间不再夹着其他线段。所有其他线段都是横穿过这两条蓝线的，它们与两条蓝线的交点要么都在虚线部分，要么都在实线部分。这会使得两条蓝色实线上产生出相同数目的交点。于是，两只青蛙将会同时到达两条蓝线的交点处。</p>
<p>这就说明，把两只青蛙放在相邻的端点上是必死的。在一个满足要求的放法中，任何两只青蛙中间都要间隔至少 1 个端点。然而，我们一共有 n 只青蛙和 2n 个端点，因而这些青蛙必须得恰好每隔 1 个端点放一只。考虑到这一点，我们立即就把第 2 小问解决了。当 n 为偶数时，对于任意一条线段，都有 n – 1 条线段穿过它，这意味着这条线段的两个端点之间恰好隔着 n – 1 个端点（不管是算哪边的弧），这是一个奇数。所以，如果每隔 1 个端点放一只青蛙，那么这条线段的其中一端放了青蛙，另外一端也会有只青蛙。这是不符合要求的。</p>
<p class="indent"><img alt="image placeholder" >
<p>而当 n 为奇数时，每隔 1 个端点放一只青蛙，就会正好让每条线段上都有一只青蛙。容易看出，此时任意两只青蛙之间都会隔着奇数个端点。接下来，我们证明，只要两只青蛙之间隔着奇数个端点，那么这两只青蛙一定不会相撞。如上图所示，我们还是用蓝色的线表示这两只青蛙所走的路。其他的线段分成这样三类：</p>
<ol>
<li>从虚线处横穿过这两条蓝线</li>
<li>从实线处横穿过这两条蓝线</li>
<li>夹在这两条蓝线之间</li>
</ol>
<p>根据刚才的讨论，第一种类型的线段不会在两条蓝色实线上产生交点，第二种类型的线段会在两条蓝色实线上产生相同数目的交点。至于第三种类型的线段，每一条要么与这边的蓝色实线相交，要么与那边的蓝色实线相交。由于两只青蛙之间隔着奇数个端点，因此这种类型的线段有奇数条，在这边的蓝色实线产生的交点数与在那边的蓝色实线产生的交点数就必然是一奇一偶。综合这三种类型的线段，我们最终得出，这些线段在两条蓝色实线上产生的交点数目是不同的，因为数目的奇偶性都不一样。所以，两只青蛙不会相撞。</p>
<p>回想我们刚才所说的，当 n 为奇数时，间隔着放青蛙会使得每条线段上都各有一只青蛙，并且任意两只青蛙之间都会隔着奇数个端点。这就将成为一种满足要求的放法。于是，我们就完整地证明了第 1 小问的结论，整个问题也就解决了。</p>
<p>这道题背后有一个有趣的故事。现任 IMO 主席 Geoff Smith 赛前曾经说，他将会以一种特殊的形式与参赛选手互动。最终，谜底揭晓：他成为了 IMO 第 6 题的主人公。</p>
			 ]]></content>
<pubDate>2016-08-24T09:22:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6851</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：为什么偏偏是 6 格？ ]]></title>
<link>http://www.matrix67.com/blog/archives/6862</link>
<content><![CDATA[ 
		<p>无穷多个相同大小的正方形格子排成一排，向左右两边无限地延伸。每个格子里都有 0 个、 1 个或多个原子。每一次，你可以对它们做下面两种操作之一：</p>
<ul>
<li>选择某个格子，保证该格子内至少含有 1 个原子。将该格子内的其中 1 个原子分裂为 2 个，从而使得该格子内的原子数量减 1 ，两边的邻格里的原子数量分别加 1。</li>
<li>选择某个格子，保证两边的邻格里均至少含有 1 个原子。从两边的邻格里各取 1 个原子聚合起来，从而使得两边的邻格里的原子数量分别减 1 ，该格子内的原子数量加 1。</li>
</ul>
<p>初始时，某个格子里有 1 个原子。现在，你需要在若干次操作之后，让它右移 6 格。也就是说，你需要用若干次操作把下面的第一个图变成第二个图（其中，数字 1 表示该格内的原子数为 1 ）。继续阅读下去之前，你不妨自己先试一试。你可以在纸上画好格子，用硬币、大米、巧克力豆等物体代替原子。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p><span id="more-6862"></span></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>其中一种方法如下。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>你或许会觉得这里面隐藏着一些规律。我们似乎可以对上面的方法进行扩展，把初始时的那个原子移到它右边的任意一格里，比方说把初始时的那个原子移到它右边第 2 格，或者第 3 格，或者第 7 格的位置。然而，简单地试试，你会发现，这还真的不行。上述方法只适用于右移 6 格的情况。事实上，我们可以证明，如果某个格子里的 1 个原子最终可以变为另外一个格子里的 1 个原子，这两个格子的位置一定相差 6 或者 6 的整倍数。</p>
<p>让我们像下面这样，为每一个格子都赋一个值，其中 ω = (-1)<sup>1/3</sup> ，即 -1 在复数范围内的一个立方根。注意到 ω 满足 ω<sup>3</sup> + 1 = 0 ，即 (ω + 1)(ω<sup>2</sup> – ω + 1) = 0 ；而 ω + 1 ≠ 0 ，于是只能是 ω<sup>2</sup> – ω + 1 = 0 。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>对于整个棋盘上的任意一种原子排布，我们都可以把每个放有原子的格子里的值加在一起，一个格子里有几个原子，它对应的值就加几次。我们把如此得到的总和叫做此时棋盘上原子排布的特征值。例如，如果 ω<sup>-2</sup> 上有 2 个原子， ω<sup>2</sup> 上有 1 个原子， ω<sup>3</sup> 上有 4 个原子，其他格子都是空的，那么此时棋盘上原子排布的特征值就是 2 · ω<sup>-2</sup> + 1 · ω<sup>2</sup> + 4 · ω<sup>3</sup> 。</p>
<p>当位于 ω<sup>n</sup> 位置上的原子分裂时，特征值会减小一个 ω<sup>n</sup> ，但会增加一个 ω<sup>n-1</sup> 和一个 ω<sup>n+1</sup> ，所以特征值的变化量为 – ω<sup>n</sup> + ω<sup>n-1</sup> + ω<sup>n+1</sup> = ω<sup>n-1</sup> · (- ω + 1 + ω<sup>2</sup>) 。然而，之前我们说过， ω 的取值满足 ω<sup>2</sup> – ω + 1 = 0 。因此，任何一次原子分裂操作都不会改变原子排布的特征值。</p>
<p>类似地，原子聚合导致的特征值的变化量为 – ω<sup>n-1</sup> – ω<sup>n+1</sup> + ω<sup>n</sup> = ω<sup>n-1</sup> · (- 1 – ω<sup>2</sup> + ω) = 0 。因此，任何一次原子聚合操作也都不会改变原子排布的特征值。</p>
<p>如果原来整个棋盘上只有 ω<sup>n</sup> 位置上有 1 个原子，后来变得整个棋盘上只有 ω<sup>m</sup> 位置上有 1 个原子，这就意味着 ω<sup>n</sup> = ω<sup>m</sup> ，即 ω<sup>m</sup> / ω<sup>n</sup> = 1 ，即 ω<sup>m-n</sup> = 1 。考虑到 ω = (-1)<sup>1/3</sup> ，因此为了让 ω<sup>m-n</sup> = 1 ，只有可能 m – n 是 6 的整倍数。这就解答了前面提出的问题。</p>
<p>我最初是在这里看见的这个问题： <a href="http://blog.sigfpe.com/2007/09/arboreal-isomorphisms-from-nuclear.html">http://blog.sigfpe.com/2007/09/arboreal-isomorphisms-from-nuclear.html</a> 。如果你对这个问题感兴趣的话，你一定会喜欢下面这个类似的但是更经典、更精彩的问题： <a href="http://www.matrix67.com/blog/archives/4595">http://www.matrix67.com/blog/archives/4595</a> 。</p>
			 ]]></content>
<pubDate>2016-09-02T22:00:51+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6862</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ UyHiP 趣题：几个特殊的强正则图 ]]></title>
<link>http://www.matrix67.com/blog/archives/6877</link>
<content><![CDATA[ 
		<p>下面这个趣题出自 <a href="http://www.brand.site.co.il/riddles/201608q.html">Using your Head is Permitted 谜题站 2016 年 8 月的题目</a>，稍有改动。</p>
<p>屋子里有若干个人，任意两个人都有恰好 1 个共同的朋友。这有可能吗？有可能。比方说，屋子里有 9 个人，其中 8 个人正好组成 4 对朋友，第 9 个人则和前面 8 个人都是朋友。容易验证，任意两个人都有恰好 1 个共同的朋友。我们可以用下面这个图表示此时这 9 个人之间的朋友关系，其中每个点代表一个人，如果两个人是朋友，就在他们之间连一条线。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>除了上图展示的情况之外，我们还能构造出很多别的同样满足要求的情况。事实上，上述方案可以扩展到一切奇数个人的情况，比如下面这样：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p><span id="more-6877"></span></p>
<p>现在，假设屋子里有若干个人，任意两个人都有恰好 <strong>2</strong> 个共同的朋友。这有可能吗？有可能。比方说，屋子里有 4 个人，他们互相之间都是朋友。容易验证，任意两个人都有恰好 2 个共同的朋友。我们可以用下面这个图表示此时这 4 个人之间的朋友关系。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>我们的问题是，除了上图展示的情况之外，还有别的同样满足要求的情况吗？</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>有。想象屋子里有 16 个人，他们站成了一个 4 × 4 的方阵。每行里的 4 个人互相之间都是朋友，每列里的 4 个人互相之间也都是朋友。于是，对于任意两个同一行或者同一列的人来说，都恰好有 2 个共同的朋友，即这一行或者这一列的另外两个人；对于任意两个既不同行又不同列的人来说，也都恰好有 2 个共同的朋友，即与我同行与你同列的人，以及与你同行与我同列的人。我们可以用下面的这个图表示此时这 16 个人之间的朋友关系（我们把同一行的点以及同一列的点都稍微错开了一些，使得连线不会重叠在一起）。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>那么，除此之外，还有没有别的满足要求的解呢？有，比如下面这个图：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>上面这两个图有很多类似的地方：它们都有 16 个点， 48 条连线，每个点都恰好引出了 6 条连线。不过，这两个图确实是本质不同的两个图。你可以这样看出来：前面这个图中，与每个点相邻的 6 个点互相之间连成的是两个三角形；而后面这个图中，与每个点相邻的 6 个点互相之间连成的是一个“圈”。</p>
<p>任意两个人都有恰好 2 个共同的朋友，究竟有多少种可能的情况呢？现在，我们已经看到了三个解。第一个解是 4 个互相之间都有连线的点。在图论中，我们通常用 K<sub>4</sub> 来表示这个图。第二个解则是借助一个 4 × 4 的方阵构造出来的。在图论中，这个图叫做 4 × 4 rook’s graph ，因为它相当于国际象棋中的车（rook）摆成 4 × 4 的方阵后互相之间能否攻击的示意图。</p>
<p>真正神奇的就是问题的第三个解了。它叫做 Shrikhande graph 。这是由印度数学家 Sharadchandra Shankar Shrikhande 在 1959 年发现的。在图论中， Shrikhande graph 是一个非常神奇的图。</p>
<p>如果一个图的每个点都引出了相同数目的线，我们就说这个图是一个“正则图”（regular graph）。如果一个正则图有 v 个点，每个点都引出了 k 条线，并且它额外地满足，任意两个相邻的点之间都恰好有 λ 个公共邻点，任意两个不相邻的点之间都恰好有 μ 个公共邻点，我们就说这个图是一个“强正则图”（strongly regular graph），用符号 srg(v, k, λ, μ) 表示。</p>
<p>显然， n × n rook’s graph 属于强正则图 srg(n<sup>2</sup>, 2n – 2, n – 2, 2) 。那么反过来，满足 srg(n<sup>2</sup>, 2n – 2, n – 2, 2) 的图是否一定就是 n × n rook’s graph 呢？基本上是，除了唯一的一个反例：当 n = 4 时， Shrikhande graph 也满足 srg(n<sup>2</sup>, 2n – 2, n – 2, 2) 。</p>
<p>这篇文章的题目也反映出了 Shrikhande graph 的独特之处。如果任意两个点都有恰好 2 个公共邻点，那么除了 K<sub>4</sub> 和 n × n rook’s graph 以外， Shrikhande graph 是唯一满足要求的解了。也就是说，任意两个人都有恰好 2 个共同的朋友，可能的情况一共就只有 3 种。</p>
			 ]]></content>
<pubDate>2016-09-04T04:21:23+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6877</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 位换记号、排列测试与状态图：杂耍中的数学 ]]></title>
<link>http://www.matrix67.com/blog/archives/6896</link>
<content><![CDATA[ 
		<p>2016 年 7 月 30 日至 8 月 7 日，第 39 届欧洲杂耍大会（European Juggling Convention）在荷兰的阿尔梅勒举行， 8 月 3 日凌晨的搏击之夜（Fight Night）自然再度成为了众人关注的焦点——它是杂耍斗（combat juggling）这项运动最大的赛事。在杂耍斗的圈子里，有两个响当当的大名你必须要知道：德国选手 Jochen Pfeiffer 目前世界排名第二，之前拿过 6 次搏击之夜的冠军；英国选手 Luke Burrage 目前世界排名第一，之前拿过 8 次搏击之夜的冠军。这一年的比赛中，两位老将均以完胜的成绩轻松进入 32 强，并在淘汰赛阶段过关斩将，最终成功在决赛场上相遇。最终，世界排名第二的 Jochen 以 5 比 4 的成绩击败了世界排名第一的 Luke ，夺得了又一个搏击之夜的冠军。</p>
<p>杂耍斗是一种两人对战类的体育运动。比赛规则非常简单。每局比赛开始时，两名选手各自抛耍 3 个杂耍棒。任何一方都可以故意上前干扰另一方（但只能针对对方手中的或者空中的杂耍棒，不能针对对方的手臂和身体）。谁站到最后，谁就赢得该局。先赢 5 局者获得比赛的胜利。</p>
<p>典型的一局比赛大致就像下面这样。这是 Jochen 和 Luke 的第 6 局比赛。</p>
<p style="text-align: center"><video width="94%" controls><source src="http://www.matrix67.com/blogimage_2016/2016092001.mp4" type="video/mp4">Your browser does not support the video tag.</source></video></p>
<p><span id="more-6896"></span></p>
<p>这场决赛确实打得精彩，出现了很多漂亮的瞬间。比如，在第 5 局比赛中， Jochen 做出了一个非常漂亮的防守动作。注意他在最后是如何改变自己的抛耍模式，在不违规的情况下（控制至少 3 个杂耍棒且任意时刻至少有一个杂耍棒在空中）抵挡住对手进攻的。</p>
<p style="text-align: center"><video width="94%" controls><source src="http://www.matrix67.com/blogimage_2016/2016092002.mp4" type="video/mp4">Your browser does not support the video tag.</source></video></p>
<p>第 7 局比赛出现了更有意思的局面： Luke 从对方手中抢来了一个杂耍棒，于是在对方满地捡棒子时，自己居然抛耍起了 4 个杂耍棒！</p>
<p style="text-align: center"><video width="94%" controls><source src="http://www.matrix67.com/blogimage_2016/2016092003.mp4" type="video/mp4">Your browser does not support the video tag.</source></video></p>
<p>不知道有没有人仔细看过视频后，发现了一个有趣的细节： Luke 虽然抛耍起了 4 个杂耍棒，但是他的动作好赖皮呀！用哪只手抛出的杂耍棒，就用哪只手接住，任何一个杂耍棒都没有在两手之间交替。这恐怕不能叫做杂耍吧！这是不是要算违规呀？</p>
<p>还真不是。两只手各自独立地抛耍 2 个物体，确实是一种基本的杂耍模式。让我们来看三个演示动画，它们分别对应抛耍 3 个物体、抛耍 4 个物体和抛耍 5 个物体时最基本的杂耍模式：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>按照大多数人的理解，在任何一种杂耍模式中，左右两只手一定是交替地、有节拍地不断抛耍小球。也就是说，右手接住某个小球并立即把它重新抛出，片刻后就该轮到左手接住某个小球并把它抛出，再过相同的时间后就又该轮到右手接住某个小球并把它抛出……今后，我们把某只手接住并抛出某个小球叫做一次“接抛”。接抛动作将会以右手、左手、右手、左手的顺序轮流完成。我们假设每次接抛动作都是瞬间完成的，小球停留在手中的时间忽略不计。接下来，我们还会把相邻两次接抛之间的时间叫做“一拍”。我们假设杂耍过程中，每一拍的时长都是相同的。</p>
<p>上面这些杂耍模式之所以是“最基本的杂耍模式”，其实就是因为，每次接抛动作都是完全相同的。这意味着，每个小球每次都被抛到了相同的高度，都会在空中停留相同的拍数。如果每个小球都在空中停留 3 拍，结果会怎样呢？让我们画个图来分析一下：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>图中，横坐标表示时间，纵坐标表示高度，弧线则表示随着时间的流逝，小球们的高度是如何变化的。每个小球都在空中停留了 3 拍，表现在图上就是，每条弧线都横跨了 3 个区间。由图可知，这里面实际上一共有 3 个小球（我们用 3 种不同的线条分别表示出了它们的轨迹）。此时，每个小球都会交替地来到左手和右手上。</p>
<p>类似地，如果每个小球都在空中停留 5 拍，我们就需要 5 个小球，才能让双手不会闲下来。可以看到，在这种情况下，每个小球也都会交替地来到左手和右手上。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>然而，如果每个小球都在空中停留 4 拍，情况就不一样了：对于任意一个固定的小球来说，不管它被哪只手扔了出去， 4 拍之后它将回到同一只手中。可以看到，此时对应着小球数为 4 的情况，也就是上面三个动画中的中间那个动画。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>不妨用 n 来表示杂耍模式中的小球数。正因为在这种最基本的杂耍模式中， n 的奇偶性会导致如此大的区别，所以当 n 为奇数和 n 为偶数时，这种杂耍模式的俗名都是不一样的。当 n 为奇数时，所得的杂耍模式叫做“瀑泻”（cascade）；当 n 为偶数时，所得的杂耍模式叫做“喷泉”（fountain）。</p>
<p>难道当 n = 4 时，就没有什么左右手能互相传递小球的杂耍模式吗？倒也有，比方说用一种叫做“倾盆”（shower）的杂耍模式就行了。事实上，倾盆可以适用于一切的 n ，并且不管 n 是奇数还是偶数，每个小球的位置都会在左右手之间切换。不过，这种模式的问题是——它太水了，还是不像杂耍。让我们还是先来看看 n = 3, 4, 5 时倾盆的演示动画吧：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>也就是说，左手接住并水平抛出某个小球，右手立即接到该球并把它抛到更高的地方；然后左手接住并水平抛出下一个小球，右手立即接到该球并把它抛到更高的地方……倾盆也算是非常基本的一种杂耍模式了，或许你自己没事儿时也偷偷尝试过。搜索与“杂耍”有关的插图插画，画面内容基本上都是一个人把一堆小球从一只手扔到另一只手，所有小球在空中大致排成一个半圆。这表现的其实就是倾盆这种杂耍模式。不过，和瀑泻比起来，倾盆的效果确实差了一些，少了点“左右开弓”的感觉。</p>
<p>说了半天，当 n = 4 时，究竟有没有什么看起来非常爽，观赏性非常强的玩法呢？有。来看看下面三种 n = 4 时的杂耍模式：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>看了上面这三个动画，你有何感想？我估计，你的第一反应会是：“真牛逼，没想到这背后的水这么深！看着就觉得里面有好多数学原理！”接下来，你就该观察各种细节，或者该冒出各种怪异的想法了：</p>
<ul>
<li>“我操，这些动画你丫都是拿什么软件做的呀？”</li>
<li>“你这网站上写的东西今后肯定是要出书的吧？哼哼，我看到时候这篇文章的动画你怎么处理！”</li>
<li>“你说这些新的杂耍模式都是谁想出来的，都是怎么想出来的呀？”</li>
<li>“这三种杂耍模式真的是三种不同的杂耍模式吗？让我看看啊……哦，是，好像确实是不同的。”</li>
<li>“这三种杂耍模式的循环长度似乎是不一样的，最左边那个的循环长度明显要短得多。”</li>
<li>“其实中间那个杂耍模式中，右手还是出现了自己扔给自己的情况。哦，左手也出现了这种情况。咦，等等，好像这个杂耍模式中，左右手的动作是完全对称的！”</li>
<li>“最右边那个图我好像看出些名堂来了。它就是一个抛得更高的 3 球瀑泻，插进去一个简单的水平抛掷。”</li>
<li>……</li>
</ul>
<p>好吧，我先专门说一下这些动画是怎么变出来的吧，不然大家肯定又会问。以前每篇文章的图片和动画都是我用 Mathematica 做的，但这篇文章还真不是。这篇文章中所有杂耍模式的演示动画都是用一个叫做 <a href="https://sourceforge.net/projects/jugglinglab/">Juggling Lab</a> 的开源软件生成的（然后用 ImageMagick 调了一下颜色和线条的粗细）。这个软件在杂耍界里非常有名，它可以生成各种杂耍模式的 GIF 演示动画，极大地方便了人们的交流。</p>
<p>这篇文章里有这么多动画，以后真的出书时该怎么办呢？那还有啥办法，到时候出书时只能不用这篇文章了呗！所以，大家一定要体会到科技的进步。现在，向其他人展示某种杂耍模式，只需要发个 GIF 动画就行了；但在只有纸媒的时代，这将会变得非常非常困难。《杂耍者世界》（Juggler’s World）是杂耍界里颇有影响力的杂志。杂志读者曾经问道：为什么不在杂志上教大家一些新的杂耍技巧呢？于是，在 1985 年第 2 期的杂志中，编辑们用一组照片辅以数字和箭头，详细讲解了一个抛耍 4 球的新玩法。自然，效果非常糟糕，至少我看了半天都没看懂。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>就好像跳水中“5253B”表示“向后翻腾两周半转体一周半屈体”一样，要是我们有一套记号，或者说一种“语法”，可以简单有效地表示出各种杂耍模式就好了。人们不但可以借助它进行交流，或许还能通过摆弄这些符号，寻找新的杂耍模式。杂耍模式的很多特征，或许也会反映在这些符号当中。</p>
<p>刚才对瀑泻和喷泉的分析，让我们自然地想到了这样一种方案：依次记下每次扔出的球会在空中停留几拍，直到完整地记下一个循环节为止。刚才我们展示了三种非常高级的 4 球玩法，让我们仔细分析一下中间那种玩法。不妨从右手扔出最高的那一次球开始算起：这次扔出的球（由右手扔出）要过 5 下才会被接住，我们就用数字 5 来标记；下次扔出的球（由左手扔出）要过 3 下才会被接住，我们就用数字 3 来标记；第三次扔出的球（由右手扔出）要过 4 下才会被接住，我们就用数字 4 来标记……如果把小球的轨迹连同这些数字标记一并画出，大概就是这样：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>杂耍模式能永远持续下去，肯定是因为它在不停地循环。在这个例子中，我们记下的数字形成了 534 循环。我们就用 534 来表示这种杂耍模式。这就是杂耍界最通用的杂耍模式记号——“位换记号”（siteswap）。</p>
<p>位换记号最早是由谁想出来的，现在已经很难考证了。目前一般认为，位换记号起源于 1985 年左右，它的发明和传播，至少与以下三组人马有着密切的关系：来自加利福尼亚州圣克鲁斯的 Paul Klimek ，来自加利福尼亚理工学院的 Bruce Tiemann 和 Bengt Magnusson ，以及来自英国剑桥的 Michael Day 、Colin Wright 和 Adam Chalcraft 。</p>
<p>对于杂耍表演者来说，位换记号是非常直观的，因为它记录的本质上就是杂耍时的一个个接抛动作：数字 1 就表示，我应该把刚接到的球近乎水平地扔向另一只手，让另一只手在下一拍立即接到它；数字 2 就表示，我应该把刚接到的球竖直向上扔一点，使得在另一只手完成动作后，正好轮到这只手重新把它接住（实际表演时，人们通常会选择直接把这个小球握在手中停留 2 拍，因为在此期间反正这只手也不需要干别的）；数字 3 就表示，我应该把刚接到的球扔得更高一些，扔出一个抛物线，使得 3 拍之后另一只手正好能接住它……总之，数字越大，就意味着我应该把小球越得越高，并且偶数意味着应该竖直向上扔，奇数意味着应该往另一只手的方向扔。</p>
<p>事实上，位换记号只告诉了你扔出的球需要多久之后回到手中，而并没有告诉你这个球具体应该怎么扔出去。你可以从胯下扔上来，从身体背后扔过来，扔头上顶一会儿，扔地上反弹回来……只要它能在正确的时候被接住就行了。</p>
<p>注意，一个杂耍模式的位换记号往往不是唯一的。我们可以对位换记号中的数字进行“循环移位”（cyclic shift），例如把 534 变为 345 和 453 ，它们刻画的显然是同一个杂耍模式。此时，人们通常会选择使用字典序最大的那个记法（也就是说，使用第一位数字最大的记法，如果有多个第一位数字最大的，则使用它们之中第二位数字最大的记法，等等）。另外，人们通常假设，位换记号中不会有大于 9 的数字出现，因为把小球扔这么高是不太现实的。这样的话，每个杂耍模式的位换记号都是一串唯一确定并且没有歧义的数字了。</p>
<p>我们刚才介绍的那些杂耍模式，用位换记号都该怎么记呢？ 3 球瀑泻、 4 球喷泉、 5 球瀑泻的位换记号分别是 3 、 4 、 5 。果然，它们是最基本的杂耍模式。 3 球倾盆、 4 球倾盆、 5 球倾盆的位换记号分别是 51 、 71 、 91 。这也很容易看出来。</p>
<p>最后我们展示了三种 4 球玩法，其位换记号从左至右依次为 53 、 534 、 5551 。之前观察到的现象和规律，都可以从这几个位换记号中读出来。左边那个的循环长度确实是最短的，因为它的位换记号的长度就是最短的。整个杂耍模式其实就是两个动作不断重复，右手做个 5 ，左手做个 3 ，右手再做个 5 ，左手再做个 3 。中间那个的位换记号里有偶数，因此它里面就会出现“自己扔给自己”的情况。同时，它的动作是左右对称的，因为它的位换记号的长度为奇数。第一轮的 534 分别对应右、左、右，第二轮的 534 就分别对应左、右、左了。右边那个本质上就是“一个抛得更高的 3 球瀑泻，插进去一个简单的水平抛掷”，它的动作要领显然就是三个相同的大动作加上一个小动作，这不正是 5551 的意思吗？</p>
<p>不知道大家有没有发现， 53 、 534 、 5551 这几串数字有一个共同特征：数字串里所有数字的平均数都是 4 。事实上，这个规律对于其他几个杂耍模式的位换记号也都成立：位换记号中所有数字的平均数，等于这个杂耍模式中小球的个数。这就是位换记号理论中最著名的一个定理——平均数定理（the average theorem）。这个定理为什么是对的呢？我们介绍一种非常直观的证明方法。</p>
<p>每个小球每次在空中停留的时间，完全是我的手在抛出它时给予它的。这就好比每次抛出小球都是在给小球加油一样。如果位换记号里有一个数字 4，就表示此时抛出小球的动作相当于给小球加了 4 个单位的油，小球也就会在空中停留 4 个单位的时间，直到最后没油了落回手中，继续接受下一次加油。每个循环刚开始的时候，有些空中的小球消耗的还是上一个循环里加的油；每个循环快结束时，给小球加的油也有一部分会放到下个循环去用。但是，既然这些循环能够一个接一个地无限持续下去，既不会出现剩余的油越积越多的情况，也不会出现油慢慢就不够了的情况，这就说明每个循环里给小球加的油，一定都恰好等于这个循环里所有小球在空中停留的时间之和。</p>
<p>假设某个杂耍模式有 n 个小球，其位换记号的长度为 l 。在每个循环里，我的手一共给小球加了多少油呢？显然，这等于位换记号里的所有数字之和。在每个循环里，所有小球在空中总共停留了多少时间呢？由于我们有 n 个小球，每个小球都在空中停留了 l 个单位的时间，所以答案就是 n · l 。于是我们得到，位换记号里的所有数字之和等于 n · l ，即 n 等于位换记号里的所有数字之和除以 l 。这正是平均数定理的内容。</p>
<p>平均数定理有一个重要的推论：瞎写一串数字，不见得是一个合法的位换记号。比方说，如果所有数字的平均数根本就不是整数，那么这串数字就必然不是一个合法的位换记号了。然而，麻烦的是，即使所有数字的平均数是个整数，这串数字也不见得是一个合法的位换记号。比方说， 6114 这串数字满足平均数条件，但它就不是一个合法的位换记号。在 61146114… 中，第一次抛出的小球和第六次抛出的小球会“撞车”，使得杂耍模式无法持续下去。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>所以，位换记号可以很好地描述杂耍模式，但要想利用位换记号创造新的杂耍模式，还得想想办法才行。</p>
<p>不妨让我们换个思路：能否对已有的位换记号进行改造，从而得出新的杂耍模式呢？考虑之前提过的 534 模式。现在，如果把 534 改成 633 ，会出现什么有意思的结果？你会发现，整个杂耍模式的循环节长度仍然是 3 ，并且在每一个循环节中，第一次抛出的小球和第三次抛出的小球都会交换落点。所以，原来的位换记号不会出现撞车的情况，新的位换记号也不会出现撞车的情况。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>我们预言： 633 是一种新的合法的位换记号，对应于一种全新的杂耍模式！事实上确实如此：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>一般地，如果位换记号中有 a 、 b 两个数字，它们相隔 d 拍的距离，那么把 a 和 b 分别换成什么数字，就能交换它们的落点呢？看看下图，你就知道了：我们应该把 a 换成 b + d ，把 b 换成 a – d 。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>在数字串中，按此规律修改某两个数字的操作就叫做一次“位换”（site swap）。对合法的位换记号进行位换操作，得到的仍然是合法的位换记号。其实，“位换记号”这个词就是这么来的——它是一种支持位换操作的记号。注意，每次位换既不会改变位换记号的长度，也不会改变位换记号中的所有数字之和。因此，位换操作不会改变所有数字的平均数。这说明，用位换操作得到的新杂耍模式，与原杂耍模式的小球数是相同的。</p>
<p>位换操作很强大。让我们再给大家展示几个例子。如果你愿意，你甚至可以对 3 球瀑泻进行位换操作。 3 球瀑泻的位换记号是 3 ，里面就只有一个数字，这可怎么做位换呢？没关系，多补几个循环节就行了。比方说，把 3 先扩写成 333 ，然后对第一个数字和第三个数字进行位换，于是得到 531 。那么， 531 就是一个新的杂耍模式。如果我们刚才选择把 3 扩写成 3333 ，但还是对第一个和第三个数字进行位换，得到的当然就是 5313 。类似地，把 3 扩写成 33333 ，位换后还能变出 53133 来……于是，我们知道了， 531, 5313, 53133, 531333, … 都是合法的位换记号。下面三个动画展示的分别是 531 、 5313 和 53133 的玩法。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>我们还可以对位换之后的结果再做位换。比方说，对 531 的第一个和第二个数字进行位换，于是得到 441 。这就又是一种新的杂耍模式！</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>441 模式可以说是人们利用位换记号得到的最大的成果之一。以前，人们凭借想象，发明创造了各种各样的杂耍模式，并给它们起了各种各样的名字。但在位换记号提出之前，由于缺乏系统的研究工具，很多简单的玩法都没被发现。在位换记号理论的帮助下，人们找到了很多新的杂耍模式， 441 模式就是最经典的例子之一。也正因为这样， 441 模式就不再有什么别的名字了。杂耍界的人们直接管它叫 441 。</p>
<p>我们刚才是用 3 → 333 → 531 → 441 的办法生成的 441 。其实，生成 441 还有很多别的路子。比方说，还是先把 3 扩写成 333 ；接下来，对 333 的第一位和第二位进行位换，于是得到 423 ；循环移位，可以把 423 变成 342 ；再对 342 的第一位和第三位进行位换，就可以得到 441 了。当然，变出 441 并不需要那么复杂，其实 423 能直接变成 441 。这里我们只是想告诉大家，位换操作还可以和循环移位配合着使用。</p>
<p>1993 年， Allen Knutson 证明了一个非常漂亮的结论：先对某个单数字的位换记号进行扩写，再通过适当的循环移位和位换操作，就能变出一切合法的位换记号！由于循环移位和位换操作都不会改变位换记号的长度和平均数，因此为了得到位换记号长度为 l 的 n 球玩法，我们必须先把单个数字 n 扩写成 l 个数字 n 。所以，接下来我们只需要说明，任何一个位换记号长度为 l 的 n 球玩法，都能从 l 个数字 n 出发，通过循环移位和位换操作得出。</p>
<p>考虑这样一个位换记号处理算法：</p>
<ol>
<li>如果数字串里的所有数字都相同，则输出该数字串，算法结束</li>
<li>使用循环移位操作，将最大数字挪至第一位，同时使得第二位数字和第一位数字不同</li>
<li>对第一位数字和第二位数字进行位换操作，然后跳转到第 1 步</li>
</ol>
<p>把任意一个合法的、长度为 l 的、平均数为 n 的位换记号输入该算法，都会经过一系列的循环移位和位换操作，最终变成 l 个数字 n 。注意到，如果数字串 A 循环移位后能变成数字串 B ，数字串 B 显然也能通过循环移位变成数字串 A 。另外，容易验证，如果对数字串 A 做一次位换后得到数字串 B ，则在同样的位置上对数字串 B 做一次位换，又会变回成数字串 A 。既然每个合法的位换记号都能变成 l 个数字 n ，那么从 l 个数字 n 出发，也就能反过来变出每个合法的位换记号了。</p>
<p>等等，这也太简单了吧，好像我们漏掉了什么吧？嗯，是的。我们还得证明：把任意一个合法的位换记号输入该算法，该算法在有限步之后一定会终止。</p>
<p>首先注意到，由于合法的位换记号经过循环移位和位换操作后仍然是合法的，因此把任意一个合法的位换记号输入进去，算法生成的自始至终都是合法的位换记号。现在，假设在做第 3 步时，数字串的头两个数字是 a 和 b 。根据之前的算法步骤可知， a 是整个数字串中最大的数，并且 a 与 b 不相等。换句话说， a 比 b 至少大 1 。事实上， a 不可能比 b 刚好大 1 ，否则这两个地方扔出的小球会撞车，这就不是一个合法的位换记号了。因此， a 比 b 至少大 2 。第 3 步之后， a 将会变成 b + 1 ， b 将会变成 a – 1 。这说明，每过一遍第 3 步，数字串中都会有某个最大数减小了 1 ，并且不会因此而引入新的最大数。如果输入的位换记号中所有数字的平均数是 n ，那么所有数字的平均数就一直是 n 。等最大数不断减小，一直减小到 n 了，那么所有的数字都是 n 了，算法也就终止了。到此为止，我们就完整地证明了 Allen Knutson 的结论。</p>
<p>这个结论有一个非常强大的推论：对于任意一个合法的、长度为 l 的位换记号，将它的各个数字分别与 1, 2, 3, …, l 对应相加，所得的 l 个结果除以 l 的余数一定是各不相同的。由于除以 l 的余数正好也就只有 0, 1, 2, …, l – 1 这 l 种可能，因此上述推论还可以重新叙述为：按上述步骤做加法并取余，所得的 l 个结果正好构成 0, 1, 2, …, l – 1 的一个排列。举个例子，在 441 模式中， 4, 4, 1 依次与 1, 2, 3 相加，得到的结果为 5, 6, 4 ，它们除以 3 的余数分别是 2, 0, 1 ，正好是 0, 1, 2 的一个排列。再举个例子，之前我们曾经提到过 53133 模式，其中 5, 3, 1, 3, 3 依次与 1, 2, 3, 4, 5 相加，得到 6, 5, 4, 7, 8 ，它们除以 5 的余数分别为 1, 0, 4, 2, 3 ，正好是 0, 1, 2, 3, 4 的一个排列。我们就说， 441 和 53133 都能通过“排列测试”（permutation test）。</p>
<p>为什么一切合法的位换记号都能通过排列测试呢？首先，如果位换记号中所有数字都相同，那它显然能通过排列测试。既然由此出发，通过循环移位和位换操作能得出其他一切合法的位换记号，因此我们只需要说明：能通过排列测试的数字串，经过循环移位和位换操作后，也照样能通过排列测试。事实正是如此。</p>
<p>首先说循环移位。将循环移位过的数字串与 1, 2, 3, …, l 对应相加，本质上就相当于是将数字串与循环移位过的 1, 2, 3, …, l 对应相加；而后者会使得所有的余数都循环移动一下，所以如果原来可以形成排列，那么现在依然可以形成排列。比方说，假设某个数字串原本是 a, b, c, d, e ；循环移位后，数字串变成了 c, d, e, a, b 。原来， a, b, c, d, e 应该与 1, 2, 3, 4, 5 对应相加；现在， a, b, c, d, e 就应该与 4, 5, 1, 2, 3 对应相加。把 a + 1 变成 a + 4 之后，除以 5 的余数会怎么变呢？不难看出，如果原来余数是 0 ，现在就会变成 3 ；如果原来余数是 1 ，现在就会变成 4 ； 2 则会变成 0 ， 3 则会变成 1 ， 4 则会变成 2 。换句话说，余数会按照 (0, 1, 2, 3, 4) → (3, 4, 0, 1, 2) 的规律发生变化。然而，把 b + 2 变成 b + 5 ，把 c + 3 变成 c + 1 ，把 d + 4 变成 d + 2 ，把 e + 5 变成 e + 3 ，除以 5 的余数都会按照这样的规律发生变化。所以，如果原来的 5 个余数既无重复又无遗漏地包含了 0, 1, 2, 3, 4 ，按照 (0, 1, 2, 3, 4) → (3, 4, 0, 1, 2) 的规律整体一变后，新的 5 个余数仍然既无重复又无遗漏地包含了 0, 1, 2, 3, 4 。</p>
<p>然后说位换。假设我们对相隔 d 拍的两个数字 a 、 b 进行位换。如果数字 a 本来应该与 i 相加，那么数字 b 本来就应该与 i + d 相加。相加之后的结果是 a + i 和 b + i + d 。位换后，数字 a 变成了 b + d ，数字 b 变成了 a – d 。前者还是要与 i 相加，后者还是要与 i + d 的相加。相加之后的结果就是 b + d + i 和 a – d + i + d = a + i 。看出来了吧！在位换前和位换后，相加之后的结果没变，只不过颠倒了而已。自然，除以 l 的余数也不会变，只是颠倒了而已。</p>
<p>所以，我们就证明了：一切合法的位换记号都能通过排列测试。反过来，无法通过排列测试的，必然就不是合法的位换记号了。排列测试比我们之前说过的平均数定理检验法更为强大。之前我们说过， 6114 不是一个合法的位换记号，但用平均数定理却无法检验出来。不过，如果换用排列测试来检验，就能立即见效了。 6, 1, 1, 4 分别加 1, 2, 3, 4 可得 7, 3, 4, 8 ，它们除以 4 的余数是 3, 3, 0, 0 。这说明， 6114 不能通过排列测试，它也就不是合法的位换记号了。</p>
<p>有没有什么数字串，它连排列测试都通得过，但仍然不是合法的位换记号呢？答案是否定的。我们可以证明，能通过排列测试的，也一定都是合法的位换记号。这背后的道理其实很简单。不妨让我们以 l = 4 为例。假设这个长度为 4 的数字串是 a, b, c, d 。如果把数字 a 所在的位置看作第 1 次接抛，那么 a + 1, b + 2, c + 3, d + 4 分别就是这 4 次接抛的落点位置。如果这个数字串能通过排列测试，就说明这 4 个落点正好是某个循环节中的第 1 个点，某个循环节中的第 2 个点，某个循环节中的第 3 个点，以及某个循环节中的第 4 个点（不管是什么顺序）。也就是说，这 4 个落点正好涵盖了循环节中的 4 个不同的地方。把这部分示意图平铺开来，你会发现，每个点都将会恰好有一接和一抛。这就是一个正确的杂耍模式了。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>于是，我们证明了这样一个非常终极的结论：某个数字串是一个合法的位换记号，当且仅当它能通过排列测试！这又会产生很多有趣的推论。比方说，如果一个数字串能通过排列测试，那么让每个数字都增加或者减小一个相同的常数，得到的数字串显然仍能通过排列测试。因此，给一个位换记号中的每个数字都增加或者减小相同的量，就会得出新的杂耍模式。有的地方把这种改造位换记号的操作叫做“垂直移位”（vertical shift）。例如，对 441 进行垂直移位，可以依次得到 552 、 663 、 774 等，它们都是新的杂耍模式。下面三个动画分别是 552 、 663 和 774 的杂耍模式演示动画。左边那个动画是这篇文章中第一次出现的位换记号里含有数字 2 的情况。之前我们说过，在遇到数字 2 时，表演者通常会选择直接把这个小球握在手中停留 2 拍。另外，可以看到，和之前那些位换记号变换法不同的是，垂直移位可以改变杂耍模式中的小球数。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>1995 年， Martin Probert 发明了一种生成新杂耍模式的傻瓜方法，其原理也可以用排列测试来解释。如果你想要一个循环节长度为 l 、小球数为 n 的新杂耍模式，你就可以先画一个 l × l 的方阵，然后在第 i 行第 j 列填入 n + i – j 的值。这相当于是在 l × l 的方阵的最左上角填一个 n ，然后按照向右走就减 1 ，向下走就加 1 的规律填充整个方阵。例如，我想要生成一个循环节长度为 5 、小球数为 4 的新杂耍模式，我画出的方阵就应该如左图所示：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>现在，从中任意选出 5 个方格，但要保证任意两个方格既不同行也不同列，如右图所示。接下来，从左至右读出各列的数字，于是得到 45641 。那么， 45641 就是一个合法的位换记号，并且它的长度为 l ，平均数为 n 。习惯上，我们会把 45641 写作 64145 ，以符合字典序最大的原则。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>为了证明如此得到的数字串一定是合法的位换记号，我们只需要说明，如此得到的数字串一定能通过排列测试。也就是说，我们只需要说明，各列所圈的数字分别 +1, +2, …, +l ，除以 l 的余数正好取遍 0, 1, 2, …, l – 1 。为了给第 j 列所圈的数字 +j ，我们可以保持圆圈的位置不变，把这一列数整体循环上移 j 个单位，圆圈里的数就自动地 +j 了。当然，有时也不是真的 +j 了，比如把上图中的第 4 列循环上移 4 个单位，圆圈里的数会从 4 变成 3 ，而不是 8 。不过，这没关系，因为最后我们只关心它除以 l 的余数，只要它除以 l 的余数是对的就行了。然而，如果各列分别循环上移 1, 2, …, l 个单位后，方阵里的数除以 l 的余数就会形成这样的情况：一行全是 0 ，一行全是 1 ，一行全是 2 ，等等，一直到一行全是 l – 1 。所以，这些互不同行的圆圈，圈出的数除以 l 的余数正好取遍 0, 1, 2, …, l – 1 。</p>
<p>另外，我们选的这 l 个数的总和，相当于是 l 个 n 之和，再以某种顺序加上 1, 2, 3, …, l ，再以某种顺序减去 1, 2, 3, …, l 。因此，我们选的这 l 个数的平均数正好就是 n 。所以，利用 Martin Probert 的傻瓜方法，确实能够得到一个循环节长度为 l 、小球数为 n 的杂耍模式。</p>
<p>其实，如果知道了排列测试理论，我们还有更直接的办法来生成新的杂耍模式。对于任意正整数 l ，将 0, 1, 2, …, l – 1 随意地排成一排，各项依次减去 1, 2, 3, …, l ，然后每个地方都可以选择再加上任意一个 l 的整倍数（其中小于等于 0 的地方必须加到变正才行），如此得到的一定是合法的位换记号。枚举所有的可能性，我们就能得到所有合法的位换记号（可能会有重复）！可以说，我们终于有了一套描述、分析、生成杂耍模式的全套解决方案。</p>
<p>当然，位换记号并不能解决杂耍表演者会遇到的全部问题。试想，如果你玩了一段时间的 3 球瀑泻，想换一种 3 球玩法，但却不想停下重来。这就引出了一个问题：从 3 球瀑泻出发，能无缝切换到哪些其他的 3 球玩法，又该如何去切换呢？为了解决这类问题，人们发明了另一种强大的杂耍模式分析工具——状态图（state graph）。</p>
<p>让我们假设手上的小球永远是 3 个，并且位换记号涉及的数字最高到 5 （即一个小球最多在空中停留 5 拍）。我们可以认为，任何一个接抛动作完成的瞬间，所有 3 个小球就都在空中了；其中 1 个小球刚被抛起，其余小球则早已抛出，正处于上升或者下降的过程中。不管怎样，从此刻算起， 3 个小球落回手中所需要的拍数一定各不相同，并且都不会超过 5 。我们可以用一个 5 位 01 串来表示接下来这 5 拍的“占用”情况，数字 1 表示有小球会落回来，数字 0 表示没有小球会落回来。例如，如果完成某个接抛动作后， 3 个小球分别将在第 1 、 2 、 5 拍之后落回手中，我们就用 11001 来表示此时的状态。可以看出，在 3 球瀑泻中，完成任何一个接抛动作后，状态都是 11100 。</p>
<p>假设有 x 和 y 两个 01 串。把 x 的第一位去掉，再在最后面添一个数字 0 。如果此时 x 的第 h 位正好是数字 0 ，并且把它改为 1 之后，整个 01 串正好就变成 y 了，我们就说 x 可以通过动作 h 转换为 y 。它的直观意义就是，如果当前状态为 x ，那么下一个接抛动作可以是 h ，该动作完成后状态就会变成 y 。例如， 11100 可以通过动作 4 转换为 11010 ，也可以通过动作 5 转换为 11001 。</p>
<p>5 位 01 串中有 3 个数字 1 ，这一共有 C(5, 3) = 10 种可能性。让我们在纸上把这 10 种可能性全部写下来。如果某种状态能通过某个动作转换为另一种状态，我们就从前一种状态出发，画一根箭头指向后一种状态，并在路上标出动作的数值。注意，一个状态有可能转换为它本身，例如 11100 能通过动作 3 转换为它本身。我们就画一个箭头，从它出发，绕个小圈，指向它自己。另外，你会发现，以数字 0 开头的状态无法转移到任何其他状态，否则数字 1 的个数就不对了；更直观的说法则是，到了这种状态显然必死，因为下一拍就没有小球接了。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>所以，只要沿着箭头走，路上经过的数字就自动地组成了合法的动作序列！而一个合法的位换记号，比如说 3 、 51 、 441 、 531 、 5313 等等，其实就是这个图上的回路！杂耍模式之间的衔接问题，也就解决了：我们只需要看看，能否从前一个回路的某个节点出发，沿着箭头走到另一个回路里去。比方说，你本来玩着 3 球瀑泻，突然想玩 3 球倾盆了。于是，你可以用动作 4 进行衔接，按照 33…345151…51 的规律抛球。什么时候你又想回到 3 球瀑泻的玩法，你就可以用动作 2 进行衔接，按照 5151…51233…3 的规律抛球。当然，你也可以用动作 41 进行衔接，按照 5151…514133…3 的规律抛球。下图所示的就是位换记号 333451515141 （这次我们有意没按字典序最大原则对其进行重写）及其演示动画，它就是由 3 球瀑泻和 3 球倾盆组成的大循环，中间分别以 4 和 41 衔接。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>用这种方法，我们可以搞出像 333451515141 这样很长很长，很复杂很复杂，却没啥实质意义的位换记号——它仅仅是由一些更基本的位换记号拼成的。</p>
<p>在状态图中，如果一条回路经过了某个重复的节点，我们就可以把它视作两个以该节点为公共节点的小回路。如果某个小回路仍然经过了重复的节点，我们还可以继续把它分解成两个更小的回路，直到每个回路都被分到不可再分（即都分到不再经过重复的节点）。</p>
<p>如果一个位换记号在状态图中不会经过重复的状态，我们就说这是一个“素位换记号”（prime siteswap）。根据上述推理，如果一个位换记号不是素位换记号，那么它一定能看作是由若干个素位换记号组合而成的。例如， 333451515141 就是由三个 3 、三个 51 和一个 441 组成的。我们前面提到过 531333…33 的模式，其实也就是由一个 531 和任意多个 3 组成的。</p>
<p>正如化学元素按一定规律适当组合后，可以得出千千万万的物质一样，素位换记号按一定规律适当组合后，也会得出千千万万的杂耍模式。也就是说，素位换记号对应着杂耍模式的基本组成单元。从这个意义上说，寻找所有的素位换记号，比生成所有合法的位换记号更为重要。为了找出所有的素位换记号，我们只需要在状态图中找出所有不经过重复节点的回路。当小球数为 3 时，所用数字不超过 5 的素位换记号一共有 8 个，它们是：</p>
<p class="indent">3, 42, 51, 441, 522, 531, 5241, 5511</p>
<p>把它们掌握了之后，就能变幻出形形色色更复杂的杂耍模式了。</p>
<p>我们从几个最基本的杂耍模式，说到了位换记号与平均数定理，说到了排列测试与位换记号的生成方法，说到了状态图与素位换记号。但是，刚才的一切仅仅是假设，左右两只手是在交替地接抛一个又一个的小球。如果两只手是同步运作的呢？或者，如果每次可以接抛不止一个小球呢？或者，如果我们有两个杂耍者，他们互相之间还能把小球扔给对方呢？我们又应该用什么记号来表示它们呢？刚才提到的结论能否继续扩展到这些情况呢？感兴趣的朋友不妨看看 Burkard Polster 的 The Mathematics of Juggling 一书。这篇文章中的内容主要也都是从这本书里来的。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>整篇文章以视频开头，不妨让我们以视频结尾吧。下面这个视频来自 <a href="https://www.youtube.com/watch?v=e5E84ePfEOw">https://www.youtube.com/watch?v=e5E84ePfEOw</a> 。看了这个视频后你就会了解到，这篇文章探讨的，真的只是最基本最基本的杂耍而已。</p>
<p style="text-align: center"><video width="94%" controls><source src="http://www.matrix67.com/blogimage_2016/2016092041.mp4" type="video/mp4">Your browser does not support the video tag.</source></video></p>
			 ]]></content>
<pubDate>2016-10-02T13:08:47+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6896</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Lissajous 曲线的动画演示 ]]></title>
<link>http://www.matrix67.com/blog/archives/6947</link>
<content><![CDATA[ 
		<p>随着常数 m 和 n 的变化，参数方程 x = sin(m · t), y = sin(n · t) 将会画出一系列漂亮的曲线。法国物理学家 Jules Antoine Lissajous 曾在 1857 年研究过这类曲线，因此人们把它叫做 Lissajous 曲线。我在 <a href="https://www.reddit.com/r/oddlysatisfying/comments/57iff3/the_lissajous_curve/">reddit</a> 上看到了一个 Lissajous 曲线的动画演示，觉得看起来确实非常爽；但那个动画里没有解释曲线的生成方法，很多细节也有让人不太满意的地方，于是决定自己制作一个。这个动画展示的是 m = 13, n = 18 时的 Lissajous 曲线。</p>
<p style="text-align: center"><img alt="image placeholder" >
			 ]]></content>
<pubDate>2016-10-18T23:32:59+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6947</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ UyHiP 趣题：能否把一个凸四边形分成若干个凹四边形 ]]></title>
<link>http://www.matrix67.com/blog/archives/6963</link>
<content><![CDATA[ 
		<p>下面这个趣题出自 <a href="http://www.brand.site.co.il/riddles/201610a.html">Using your Head is Permitted 谜题站 2016 年 10 月的题目</a>：能否把一个凸四边形分成若干个凹四边形？</p>
<p><span id="more-6963"></span></p>
<p>答案是否定的。我们给出一个非常漂亮的证明。在下面的文字中，我们用“优角”一词来表示一个大于 180 度小于 360 度的角。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>假设某个凸四边形被分成了若干个凹四边形。容易看出，每个凹四边形的内角中都有且仅有一个优角（如果没有优角，它就不是凹四边形；如果有两个或更多的优角，就与四边形内角和为 360 度矛盾）。</p>
<p>现在，让我们把每个凹四边形的那个优角顶点涂成蓝色。容易看出，每个蓝色顶点只能成为一个凹四边形的一个优角顶点（否则汇聚于该点处的角度之和会超过 360 度）。这意味着，每个蓝色顶点都唯一地对应一个凹四边形。如果图中的蓝色顶点一共有 n 个，那么凹四边形也一共有 n 个。</p>
<p>我们用两种不同的方式来统计所有凹四边形的所有内角的度数之和。汇集在每个蓝色顶点的内角之和都是 360° ，汇集在原四边形四个顶点处的内角之和也是一个 360° ，所以我们已经有至少 n × 360° + 360° 了。考虑到其他没涂成蓝色的顶点处还有很多角，因此上面这个数目实际上还会更多。但是，我们一共有 n 个凹四边形，每个凹四边形的内角之和是 360° ，因此所有凹四边形的所有内角之和显然应该是 n × 360° 。这个矛盾说明，我们无法把一个凸四边形分成若干个凹四边形。</p>
			 ]]></content>
<pubDate>2021-09-06T00:03:12+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6963</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 称假币问题的变形：无假币与“天平机” ]]></title>
<link>http://www.matrix67.com/blog/archives/6970</link>
<content><![CDATA[ 
		<p>大家应该听说过 9 枚硬币的问题吧。9 枚硬币当中有 8 枚是真币，有 1 枚是假币。所有的真币重量都相同，假币的重量则稍重一些。怎样利用一架天平两次就找出哪一枚硬币是假币？方法是，先把 9 枚硬币分成三组，每组各 3 枚硬币。然后，把第一组放在天平左边，把第二组放在天平右边。如果天平向左倾斜，说明假币在第一组里；如果天平向右倾斜，说明假币在第二组里；如果天平平衡，说明假币在剩下的第三组里。现在，假币的嫌疑范围就被缩小到 3 枚硬币之中了。选择其中 2 枚硬币分放在天平左右两侧。类似地，如果天平左倾，就说明左边那枚硬币是假的；如果天平右倾，就说明右边那枚硬币是假的；如果天平平衡，就说明没放上去的那枚硬币是假的。</p>
<p>9 硬币问题实在是太经典了，你甚至能在人教版小学五年级下册的课本里看到它。9 硬币问题还衍生出了很多变形，其中最著名的当属 12 硬币问题了：有 12 枚硬币，其中一枚是假币，但我们不知道假币是更重一些还是更轻一些；请利用一架天平三次找出哪一枚硬币是假币，并判断出它比真币更重还是更轻。12 硬币问题的经典程度恐怕不亚于 9 硬币问题。早在 20 世纪 40 年代，12 硬币问题就已经吸引了一大批数学家和数学爱好者，甚至有人建议把这个问题扔到德国去，以削弱德国人在二战中的战斗力。如果你想知道答案，可以在网上找找，应该很容易找到。我们今天就不讨论了。</p>
<p>今天，我们真正想聊的其实是这个问题的另外一种比较少见的变形：仍然是要在 9 枚硬币当中寻找 1 枚假币，仍然假设假币的重量要稍重一些，仍然只能使用天平两次；但是这一次，你所使用的是一种“天平机”，它不会立即告诉你现在是哪边重哪边轻，而是在你两次称完后把这两次的结果一并打印给你。这下，你就没法根据天平的反馈结果随机应变了，必须事先把每次怎么放硬币全规划好。那么，你该怎么办？在本文后面的内容中，均已知假币比真币更重，直至另有说明。</p>
<p><span id="more-6970"></span><br>
答案并不复杂。你的第一步应该和刚才一样，仍然是把 9 枚硬币均分成三组，把第一组放在天平左边，把第二组放在天平右边。妙就妙在第二步。我们的原计划是，哪一组里有假币，就在哪一组里选出 2 枚硬币分放在天平两侧。但是，由于没有及时的反馈，我们根本就不知道哪一组里有假币，这该怎么办呢？其实，我们根本不用管哪一组里有假币，从每一组里都选 2 枚硬币放上去就行了，反正另外两组硬币都是真的，放上去了不会有什么影响。这有一点“并行运算”的意思。举例来说，如果第一步放在天平左右两侧的硬币编号分别是 1、2、3 和 4、5、6，那么第二步放在天平左右两侧的硬币编号就应该是 1、4、7 和 2、5、8。如果事后天平告诉我，第一次称完左边更重一些，那么我就知道了假币一定在 1、2、3 当中，于是第二次左边更重就说明 1 是假币，第二次右边更重就说明 2 是假币，第二次天平平衡就说明 3 是假币，而第二次天平上的 4、7、5、8 其实都是来“陪称”的。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>在给别人讲这个解法时，我更喜欢用下面这种等价的但更为直观的叙述方法：把 9 枚硬币摆成三行三列。在第一轮里，我们把第一行的硬币放到天平左边去，把第二行的硬币放到天平右边去；在第二轮里，我们把第一列的硬币放到天平左边去，把第二列的硬币放到天平右边去。之后，天平将把这两轮称重的结果告诉我们，本质上就相当于告诉了我们假币在第几行第几列，于是我们就能锁定假币的编号了。这段内容特别适合讲给小学五年级和初中一年级的学生，因为他们会发现，刚学的用数对表示位置的知识居然在这里派上了用场。</p>
<p>聊完 9 硬币问题的“天平机”变形后，让我们再来聊一种新的变形：可能没假币。9 枚硬币当中可能有 1 枚的假币，也有可能根本就没有假币。怎样利用一架天平两次就找出假币（如果有的话），或者确定出所有的硬币都是真币？</p>
<p>听完这个问题，你的第一反应是什么？你的第一反应或许是——这怎么可能有解呢？觉得此题无解，背后其实是有一些直觉的——原始 9 硬币问题的解法已经发挥到极致了，再多一点不确定的因素，恐怕就没有额外的手段来处理它了。这个直觉是对的。我们可以把这个直觉转化成更加严谨的语言。</p>
<p>每称一次硬币，天平都会产生三种不同的状态：向左倾斜，向右倾斜，保持平衡。接下来究竟该怎么做，取决于天平产生的状态。形象地说，此处会产生三个不同的分支剧情。在每一种分支剧情下，我们都会再使用一次天平，进而又产生三个小分支剧情。由于我们一共就只能使用两次天平，因此我们一共能得到 3 × 3 = 9 个不同的结局。若 9 枚硬币中<strong>一定</strong>有 1 枚假币，则一共有 9 种要分辨的情况：1 号硬币是假币，2 号硬币是假币，一直到 9 号硬币是假币。9 个不同的结局，正好分别对应 9 种不同的情况。然而，如果 9 枚硬币中<strong>可能</strong>有 1 枚假币，则一共有 10 种要分辨的情况：1 号硬币是假币，2 号硬币是假币，一直到 9 号硬币是假币，以及没有假币。9 个不同的结局，容纳不下 10 种不同的情况。至少有一个结局会同时对应两种或两种以上的情况，它们就无法被区分开来了。</p>
<p>上面的理论告诉我们，如果不确定有没有假币，并且只能用两次天平，顶多只能解决有 8 枚硬币的情况。那么，当硬币数为 8 的时候，问题实际上有没有解呢？有！而且方法并不难，很好想。把 8 枚硬币分为三组，前面两组都是 3 枚，第三组是 2 枚。把第一组和第二组分别放在天平的左右两边。接下来会产生两个分支剧情：</p>
<ul>
<li>如果天平不平衡，说明假币一定有，并且在较重的那一组当中。再称一次，就能把这一组中哪一枚硬币是假币给称出来。</li>
<li>如果天平平衡，说明假币要么在第三组，要么不存在。将天平清空，把第三组的两枚硬币分别放在天平两边，哪边重就说明假币在哪边，一样重就说明假币不存在。</li>
</ul>
<p>现在，我们讲了 9 硬币问题的两种变形：“天平机”变形，和“可能没假币”变形。但经过探究，我们发现后者最多只能解决 8 枚硬币的情形。或许你认为这篇文章快结束了吧。现在，好戏才刚刚开始。我们把刚才的两种变形结合在一起，构造一个真正的难题：你只能使用“天平机”，而且有可能没假币，请你用两次天平找出假币（或确定假币不存在）。在“可能没假币”的变形中，即使不加“天平机”变形，最多也只能解决 8 硬币问题；所以，在两种变形叠加的情况下，8 硬币也是一个上限。因而，我们把总硬币的数量设为 8。</p>
<p>8 枚硬币，可能没假币，用“天平机”，能搞定吗？在出现了“天平机”这样的玩意儿时，最直观而有效的分析方法还是之前的 3 × 3 方阵。事实上，两次“天平机”应该怎么用的问题，完全等价于方阵里的硬币应该怎么摆的问题。每次使用天平时，要决定的无非就是左边放哪些硬币，右边放哪些硬币；而在“天平机”的假设下，第一轮决定和第二轮决定是互相独立的。所以，设计一套解决问题的方案，无非就是为每一枚硬币指定去处：第一次是放左边、放右边还是不上天平，第二次又是放左边、放右边还是不上天平。这一切都可以借用 3 × 3 的方阵陈列出来。第一行第二列里的硬币，就是第一次放左边，第二次放右边的硬币；第二行第三列里的硬币，就是第一次放右边，第二次不上天平的硬币。</p>
<p>在摆放硬币时，有一个非常基本的原则：每个格子里最多只能放一枚硬币。这是因为，如果某个格子里放了两枚甚至更多枚硬币，说明它们自始至终一直是“捆绑”在一起的，如果其中一枚硬币是假币，我们就没法区别了。之前有 9 枚硬币，正好摆满整个方阵；这次只有 8 枚硬币，没法把方阵填满了。我们只好把它们摆成这样了：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>嘿，这样也就搞定了。先把头两行的硬币分别放在天平左右两边，第三行硬币不放上去，我们就能知道假币在哪一行；再把头两列的硬币分别放在天平左右两边，第三列硬币不放上去，我们就能知道假币在哪一列。如果天平两次都平衡，说明硬币既不在头两行，也不在头两列；然而这样的硬币根本不存在，因而可以断定此时没有假币。</p>
<p>不管是用普通天平还是用“天平机”，8 枚硬币中可能有 1 枚假币的情况，已经蕴含了 8 枚硬币中一定有 1 枚假币的情况。可能有 1 枚假币时的解法，能直接套用于一定有 1 枚假币的情况，无非就是某种小概率事件永远不会发生罢了。</p>
<p>至此，我们讨论了 9 硬币问题的 8 个具体变形：</p>
<ul>
<li>9 枚硬币，一定有假币，用普通天平</li>
<li>9 枚硬币，一定有假币，用“天平机”</li>
<li>9 枚硬币，可能没假币，用普通天平（无解）</li>
<li>9 枚硬币，可能没假币，用“天平机”（无解）</li>
<li>8 枚硬币，一定有假币，用普通天平</li>
<li>8 枚硬币，一定有假币，用“天平机”</li>
<li>8 枚硬币，可能没假币，用普通天平</li>
<li>8 枚硬币，可能没假币，用“天平机”</li>
</ul>
<p>接下去，我们是不是应该开始研究下面四个问题了？</p>
<ul>
<li>7 枚硬币，一定有假币，用普通天平</li>
<li>7 枚硬币，一定有假币，用“天平机”</li>
<li>7 枚硬币，可能没假币，用普通天平</li>
<li>7 枚硬币，可能没假币，用“天平机”</li>
</ul>
<p>此时，我似乎听见了读者们的大笑声：只见过有些题目里往上讨论越来越大的 n，还从没见过什么题目里往下讨论越来越小的 n。呵呵，谁说 n 越大题目越难了？如何把一个正方形分成 9 个小正方形，这个问题的答案大家肯定能立即想到；如何把一个正方形分成 8 个小正方形，这个事儿恐怕很多人没法立即想到答案吧！</p>
<p>类似地，7 硬币问题也有它的特殊之处，使得从某种意义上它更难一些。不管是一定有假币的情况，还是可能没假币的情况，用普通天平倒是很快能解决。把 7 枚硬币分为三组，前面两组都是 3 枚，第三组是 1 枚。把第一组和第二组分别放在天平的左右两边。接下来会产生两个分支剧情：</p>
<ul>
<li>如果天平不平衡，说明假币一定有，并且在较重的那一组当中。再称一次，就能把这一组中哪一枚硬币是假币给称出来。</li>
<li>如果天平平衡，那就说明前两组硬币肯定都是真的。从中拿其中一枚真币去跟第三组的那枚硬币比轻重，就知道第三组的那枚硬币是真是假了。</li>
</ul>
<p>麻烦的还是用“天平机”的情况。我们先考虑一定有假币的情况。是不是仿照刚才的例子，只需要把 7 枚硬币摆成这样就行了呢？</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>这次就不行了。虽然把前两行的硬币分放天平的左右两边，可以知道假币在三行中的哪一行，但把前两列的硬币分放天平的左右两边，无法知道假币在三列中的哪一列。这是因为，前两列的硬币个数不一样，其中一枚硬币较重，不见得会让它所在的这边下沉。所以，摆放硬币时，我们还得让前两行的硬币数相同，并且前两列的硬币数也相同。比方说，我们摆成这样：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>这样就能用“天平机”两次解决问题了，不管是一定有假币的情况，还是可能没假币的情况。呃……是吗？</p>
<p>事实上，7 枚硬币，可能没假币，用“天平机”，这种情况是使用两次天平无法解决的。最为关键的一点就是，和必然有假币的情况不同，在可能不存在假币的情况下，每一枚硬币都得有至少一次要上秤。这是为什么呢？道理很简单。假设我们打算把某一枚硬币丢在一边，每次都不上秤，那我们无法区别“假币就是这枚硬币”和“假币不存在”这两种可能性。这说明，把硬币摆进 3 × 3 的方阵时，最右下角的那个格子里是不能放硬币的。</p>
<p>在 3 × 3 的方阵里，除掉最右下角的格子，还剩下 8 个格子。如果要在里面放 7 枚硬币，那就恰好有 1 个格子是空的。不管空的格子是这 8 个格子中的哪一个，都会使得前两行的硬币数不一样，或者前两列的硬币数不一样。然而，在每次称硬币的时候，两边放的硬币数必须得相同，不然没有任何意义。这就说明，用“天平机” 2 次称出 7 枚硬币中的假币，在假币可能不存在的假设下，是无法办到的。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>利用硬币方阵研究此类问题能够起到事半功倍的效果。上面的硬币方阵图告诉我们，在“天平机”变形中，使用两次“天平机”，可以找出 2、3、4、5、6、7、8、9 枚硬币中的一枚假币（如果假币一定存在），虽然 2 枚硬币和 3 枚硬币的情况显然用一次“天平机”就够了；也可以找出 2、3、4、5、6、8 枚硬币中的一枚假币（如果假币不一定存在），虽然 2 枚硬币的情况显然用一次“天平机”就够了。这是因为，这些图都满足：</p>
<ul>
<li>每个格子里最多放一枚硬币</li>
<li>第一行和第二行的硬币数相同</li>
<li>第一列和第二列的硬币数相同</li>
<li>对于可能没假币的情况，最右下角的格子里没有硬币</li>
</ul>
<p>两次使用“天平机”究竟能办到哪些事情，就被我们彻底分析清楚了。</p>
<p>当然，数学研究过程中的欲望永远是无止境的。我们接下来就想问：三次使用“天平机”能办到哪些事情？大家或许会作出下面这几个看起来非常合理的猜测：</p>
<ul>
<li>一定有假币时，三次使用“天平机”除了能够解决两次使用“天平机”就能解决的问题以外，还能够解决 10 到 27 枚硬币的情况。</li>
<li>可能没假币时，三次使用“天平机”除了能够解决两次使用“天平机”就能解决的问题以外，还能够解决 9 到 26 枚（但不含 25 枚）硬币的情况。</li>
<li>可能没假币时，之前两次使用“天平机”不能解决的 7 硬币情形，三次使用“天平机”应该足够了。</li>
<li>可能没假币时，现在三次使用“天平机”不能解决的 25 硬币情形，恐怕得四次使用“天平机”才够。</li>
</ul>
<p>这些猜测显然参考了普通天平情况下的结论推广模式。这是数学归纳法的经典应用。我们简单地做个回顾。我们来证明，n 枚硬币中一定有一枚假币，要用 k 次普通天平找出这枚假币，则问题有解的充分必要条件是 n ≤ 3<sup>k</sup>。</p>
<p>必要性很容易说明，其核心思路本文一开始就已经说过了：每使用一次天平，会产生三个分支剧情；使用 k 次天平，一共会产生 3<sup>k</sup> 个不同的结局。这只够区分 3<sup>k</sup> 个不同的可能性。然而，究竟谁是假币，这一共有 n 种不同的可能性。所以，n 不能超过 3<sup>k</sup>。</p>
<p>为了证明充分性，我们只需要给出一种方案即可。数学归纳法就派上用场了。当 k = 1 时，结论显然成立。我们现在要把更大的 k 归结为 k − 1 时的情形。我们的基本策略就是，先把硬币分成三组，并且前两组硬币一样多。把前两组硬币放上天平，根据天平状态便能得知假币在哪一组。如果不管假币在哪一组，接下来都能用 k − 1 次天平找出假币就好了。这意味着，每组硬币的数量都不能超过 3<sup>k−1</sup>。因此，我们要做的无非就是，把一个不超过 3<sup>k</sup> 的数 n，分解成三个不超过 3<sup>k−1</sup> 的数之和，并且前两个数相等。由于 n ≤ 3<sup>k</sup>，因此 n÷3 ≤ 3<sup>k−1</sup>。接下来分三种情况讨论。</p>
<ul>
<li>如果 n÷3 正好是个整数，直接把 n 分成 n/3, n/3, n/3 就行了</li>
<li>如果 n÷3 等于某个整数又 1/3，那就把 n 分成 n/3 − 1/3, n/3 − 1/3, n/3 + 2/3</li>
<li>如果 n÷3 等于某个整数又 2/3，那就把 n 分成 n/3 +1/3, n/3 + 1/3, n/3 − 2/3</li>
</ul>
<p>容易验证，这些情况下的分法都满足要求。</p>
<p>如何对“天平机”情况下的结论进行推广呢？如果说两次使用“天平机”时的最佳分析工具是 3 × 3 方阵，那三次使用“天平机”时就得使用 3 × 3 × 3 的立方阵了。让我们把硬币放进立方阵。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>接下来，按照下面的原则完成后续操作。</p>
<ol>
<li>把由远至近第一个纵切片（图 1 中的红色部分）里的所有硬币放在天平左边，把由远至近第二个纵切片（图 1 中的黄色部分）里的所有硬币放在天平右边。</li>
<li>把从左到右第一个纵切片（图 2 中的红色部分）里的所有硬币放在天平左边，把从左到右第二个纵切片（图 2 中的黄色部分）里的所有硬币放在天平右边。</li>
<li>把从上往下数第一层（图 3 中的红色部分）里的所有硬币放在天平左边，把从上往下数第二层（图 3 中的黄色部分）里的所有硬币放在天平右边。</li>
</ol>
<p>如果每次放在天平两边的硬币个数相同，我们就能确定假币的三维空间坐标，谁是假币就立即揭晓了。问题就是，怎样摆放硬币，才能使得每次放在天平两边的硬币个数相同。换句话说，我们需要各个方向上的第一个切片和第二个切片都拥有相同数量的硬币。</p>
<p>普通天平的推广充分用到了数学归纳法，“天平机”变形的推广多半也跟数学归纳法脱不了干系。所以，在搭建符合要求的立体方阵时，我们可以想办法把之前那些符合要求的平面方阵给用上。比方说，我们可以让立方阵中从上往下的每一层都是一个符合要求的 3 × 3 硬币方阵图。这样一来，不管是在图 1 中，还是在图 2 中，每一层的红色部分和黄色部分都有相同数量的硬币，整个红色纵切片和整个黄色纵切片也就拥有相同数量的硬币了。为了让前两层里的硬币数也一样多，我们可以额外地要求，前两层必须是完全相同的 3 × 3 硬币方阵图。前面的图示中给出的，就是 18 枚硬币时一个符合要求的立体方阵。</p>
<p>但是，如果要把结论进一步推广到四次使用“天平机”，我们又该怎么办呢？难道真的要把三维方阵继续升级成四维方阵？不用。描述高维空间的其中一种方法就是用直角坐标系，比如四维空间中的点就与四个坐标值形成的四元组相对应。而在我们的问题中，每个维度就只有三种可能的坐标值：放左边、放右边、不放上去。我们不妨依次用 L、R、0 表示它们。我们可以用这种方式把每个小球在高维空间中的位置表示出来，哪怕是 100 维、1000 维的空间。其实，我们并不是开创了新的分析方法，而仅仅是回归到了问题的本源。一枚硬币各次的去处，本来就该用这么一串记号来表示；图形化的分析方法，则起到了一个参谋的作用。</p>
<p>如果硬币一共有 n 枚，“天平机”可以使用 k 次，那么所有硬币的各次去向可以整理成下面这样的形式：</p>
<blockquote><p>C<sub>1</sub> = (L, L, L, …, L)<br>
C<sub>2</sub> = (R, L, L, …, L)<br>
C<sub>3</sub> = (0, L, L, …, L)<br>
……<br>
C<sub>n</sub> = (0, 0, 0, …, 0)</p></blockquote>
<p>这个表格需要满足：</p>
<ul>
<li>任意两行都不能完全相同</li>
<li>每一列中 L 和 R 的个数相同</li>
<li>对于可能没假币的情况，不能有某一行全是 0</li>
</ul>
<p>设计称币方案的问题，就转化为了编排表格的问题。受之前的图形化分析结果的启发，我们有了下面的核心策略。如果硬币一共有 n 枚，“天平机”可以使用 k 次，我们就把 n 拆成 n<sub>1</sub> × 2 + n<sub>2</sub>，使得硬币有 n<sub>1</sub> 枚或者 n<sub>2</sub> 的情况下，使用 k − 1 次或更少次数的天平都能完成任务。然后，我们把两张 n<sub>1</sub> 枚 k − 1 次的表格和一张 n<sub>2</sub> 枚 k − 1 次的表格接在一起，组成一个有 n 行 k − 1 列的大表格（不足 k − 1 列的地方用 0 补足），再给前 n<sub>1</sub> 行的最末尾添一个 L，给接下来 n<sub>1</sub> 行的最末尾添一个 R，给最后 n<sub>2</sub> 行的最末尾添一个 0。这就得到了一个 n 枚 k 次时符合要求的表格。这是因为：</p>
<ul>
<li>每个小表格内部都没有重复的行，而来自不同表格的行又拥有不同的“后缀”，因而大表格中的任意两行都不重复。</li>
<li>根据构造方法，第 k 列的 L、R 个数相等。对于前面 k − 1 列中的任意一列，每个小表格的 L、R 个数都相等，那么合成的大表格显然也满足，该列的 L、R 个数相等。</li>
<li>对于可能没假币的情况，每个小表格里都不会出现某一行全是 0 的情况，整个大表格里也自然不会出现某一行全是 0 的情况。</li>
</ul>
<p>我们只剩一件事情要做：如何把 n 拆成 n<sub>1</sub> × 2 + n<sub>2</sub>。</p>
<p>对于一定有假币的情况，我们的猜想是：当 n ≤ 3<sup>k</sup> 时，使用最多 k 次“天平机”就能完成任务。因此，我们需要把 3<sup>k</sup> 以内的数，分解成三个 3<sup>k−1</sup> 以内的数之和，其中前两个数必须得相等。这件事情我们刚才已经做过一遍了。我把前面的文字原封不动地复制粘贴过来。如果 n ≤ 3<sup>k</sup>，那么 n÷3 ≤ 3<sup>k−1</sup>。</p>
<ul>
<li>如果 n÷3 正好是个整数，直接把 n 分成 n/3, n/3, n/3 就行了</li>
<li>如果 n÷3 等于某个整数又 1/3，那就把 n 分成 n/3 − 1/3, n/3 − 1/3, n/3 + 2/3</li>
<li>如果 n÷3 等于某个整数又 2/3，那就把 n 分成 n/3 +1/3, n/3 + 1/3, n/3 − 2/3</li>
</ul>
<p>对于可能没假币的情况，我们的猜想是：当 n ≤ 3<sup>k</sup> − 1 且 n ≠ 3<sup>k</sup> − 2 时，使用最多 k 次“天平机”就能完成任务。因此，我们需要把 3<sup>k</sup> − 1 以内且不为 3<sup>k</sup> − 2 的数，分解成三个 3<sup>k−1</sup> − 1 以内且不为 3<sup>k−1</sup> − 2 的数之和，其中前两个数必须得相等。事实上，前两个数正好都等于 3<sup>k−1</sup> 或者都等于 3<sup>k−1</sup> − 2 是没有关系的，因为前两个小表格可以使用一定有假币时的表格。反正最后我们会在这些行的最后面补一个 L 或者 R，即使这些行中有某一行原来全是 0，也不会破坏掉大表格的性质。分解的思路与刚才相同。如果 n ≤ 3<sup>k</sup> − 1且 n ≠ 3<sup>k</sup> − 2，那么 n÷3 ≤ 3<sup>k−1</sup> − 1/3 且 n÷3 ≠ 3<sup>k−1</sup> − 2/3。接下来分三种情况讨论。</p>
<ul>
<li>如果 n÷3 正好是个整数，直接把 n 分成 n/3, n/3, n/3 就行了</li>
<li>如果 n÷3 等于某个整数又 1/3，那就把 n 分成 n/3 − 1/3, n/3 − 1/3, n/3 + 2/3</li>
<li>如果 n÷3 等于某个整数又 2/3，那就把 n 分成 n/3 + 1/3, n/3 + 1/3, n/3 − 2/3</li>
</ul>
<p>这一回，有三个地方会出问题：</p>
<ul>
<li>如果 n/3 正好等于 3<sup>k−1</sup> − 2，即 n 正好等于 3<sup>k</sup> − 6，第一种情况就出问题了。此时，我们只需要把它分成 (3<sup>k−1</sup> − 1) × 2 + (3<sup>k−1</sup> − 4) 就行了。</li>
<li>如果 n/3 + 2/3 正好等于 3<sup>k−1</sup> − 2，即 n 正好等于 3<sup>k</sup> − 8 ，第二种情况就出问题了。此时，我们只需要把它分成 (3<sup>k−1</sup> − 2) × 2 + (3<sup>k−1</sup> − 4) 就行了。</li>
<li>如果 n/3 − 2/3 正好等于 3<sup>k−1</sup> − 2，即 n 正好等于 3<sup>k</sup> − 4 ，第三种情况就出问题了。此时，我们只需要把它分成 (3<sup>k−1</sup>) × 2 + (3<sup>k−1</sup> − 4) 就行了。</li>
</ul>
<p>至此，我们就完整地给出了各种“天平机”情况下的最优解。</p>
<p>等等……这些解真的是最优的吗？利用前面提过的思路，很容易证明，对于一定有假币的情况，当 n &gt; 3<sup>k</sup> 时问题无解，并且对于可能没假币的情况，当 n &gt; 3<sup>k</sup> − 1 时问题无解。现在我们要证明，对于可能没假币的情况，n = 3<sup>k</sup> − 2 确实无解。回想一下对于可能没假币的情况，表格</p>
<blockquote><p>C<sub>1</sub> = (L, L, L, …, L)<br>
C<sub>2</sub> = (R, L, L, …, L)<br>
C<sub>3</sub> = (0, L, L, …, L)<br>
……<br>
C<sub>n</sub> = (0, 0, 0, …, 0)</p></blockquote>
<p>需要满足的要求：</p>
<ul>
<li>任意两行都不能完全相同</li>
<li>每一列中 L 和 R 的个数相同</li>
<li>不能有某一行全是 0</li>
</ul>
<p>当 n = 3<sup>k</sup> − 2 时，上述条件确实无法全部实现。我们来证明这一点。首先，表格的每一行里都有 k 个格子，每个格子里都只能填 L、R、0 之一，因此每一行的填法一共有 3<sup>k</sup> 种不同的组合。容易看出，对于任意一个特定的格子，其中 1/3 的组合在该格子里面填了 L，另外 1/3 的组合在该格子里面填了 R，剩下 1/3 的组合在该格子里面填了 0。所以，把这 3<sup>k</sup> 种填法组合全列出来，将会满足每一列中的 L 和 R 的个数相同。除去不允许出现的 (0, 0, 0, …, 0) 以外，还有 3<sup>k</sup> − 1 种不同的组合。把这 3<sup>k</sup> − 1 种填法组合全列出来，仍然满足每一列中的 L 和 R 的个数相同。表格一共有 3<sup>k</sup> − 2 行，但填法有 3<sup>k</sup> − 1 种组合，所以我们要从中去掉一种组合。在这种组合中，至少有一个格子里填了 L 或者 R 。把该行去掉后，这个格子所在列的 L 和 R 的个数将会失衡。这就说明了，当 n = 3<sup>k</sup> − 2 时，满足要求的表格是不存在的。</p>
<p>总结一下目前我们得到的所有结果。在有 n 枚硬币，使用 k 次天平的情况下，问题有解的充分必要条件为：</p>
<ul>
<li>一定有假币，用普通天平： n ≤ 3<sup>k</sup>
</li>
<li>一定有假币，用“天平机”： n ≤ 3<sup>k</sup>
</li>
<li>可能没假币，用普通天平：………………？</li>
<li>可能没假币，用“天平机”：n ≤ 3<sup>k</sup> − 1 且 n ≠ 3<sup>k</sup> − 2</li>
</ul>
<p>那么，可能没假币，用普通天平呢？容易想到，“天平机”是更加严苛的要求，所以用“天平机”能解决的，用普通天平当然也能解决。你只需要假装普通天平的前 k − 1 次称量结果并未立即给出，它就变成“天平机”了。另外，在可能没假币的情况下，即使用普通天平，n &gt; 3<sup>k</sup> − 1 肯定也是无解的。比较关键的问题就是，普通天平能不能解决 n = 3<sup>k</sup> − 2 的情况。答案是肯定的。还记不记得，最开始的 7 硬币问题是怎么解决的？我复制粘贴过来。</p>
<blockquote><p>类似地，7 硬币问题也有它的特殊之处，使得从某种意义上它更难一些。不管是一定有假币的情况，还是可能没假币的情况，用普通天平倒是很快能解决。把 7 枚硬币分为三组，前面两组都是 3 枚，第三组是 1 枚。把第一组和第二组分别放在天平的左右两边。接下来会产生两个分支剧情。<br>
如果天平不平衡，说明假币一定有，并且在较重的那一组当中。再称一次，就能把这一组中哪一枚硬币是假币给称出来。<br>
如果天平平衡，那就说明前两组硬币肯定都是真的。从中拿其中一枚真币去跟第三组的那枚硬币比轻重，就知道第三组的那枚硬币是真是假了</p></blockquote>
<p>仿照这个思路，我们有了下面的方案。把 3<sup>k</sup> − 2 枚硬币分成 3<sup>k−1</sup>, 3<sup>k−1</sup>, 3<sup>k−1</sup> − 2 这么三组，并把前两组放到天平的左右两边。如果天平不平衡，说明假币一定有，并且在较重的那一组当中。现在的情况就变成了，其中 3<sup>k−1</sup> 枚硬币中一定有 1 枚假币，而这样的情况我们是能用 k − 1 次天平解决的。如果天平平衡，那就说明前两组硬币肯定都是真的，假币要么在第三组里，要么就根本没有。我们从前两组里借来一枚硬币，并入第三组，第三组里就有 3<sup>k−1</sup> − 1 枚硬币了，其中可能有 1 枚假币，可能没有假币，而这种情况也能用 k − 1 次天平解决。所以，我们可以补全上面的列表中缺失的行了：</p>
<ul>
<li>可能没假币，用普通天平：n ≤ 3<sup>k</sup> − 1</li>
</ul>
<p>最后还要注意的就是，在可能没假币的情况下，我们需要假设 n ≥ 2，否则问题永远无解。至此，我们终于完整地解答了称硬币问题中与无假币和“天平机”相关的所有变形。</p>
<p>其实，我们今天所讨论的仅仅是各种称硬币问题变形的冰山一角。称硬币问题的变形可谓是无奇不有。为了展示这一点，也为了满足部分或许仍然意犹未尽的读者，我们最后以三个古怪而有趣的称硬币问题，来结束今天的全部讨论吧。注意，接下来的假币就不见得更重一些了，大家阅读时稍微留心一下。</p>
<p><strong style="color: #009bdf">问题1</strong></p>
<p>有 100 枚硬币，里面有 99 枚是真币，有 1 枚是假币。所有的真币重量都相同，假币的重量则稍有差异，但你不知道是偏重了还是偏轻了。每一次，你可以选择任意数量的硬币，把其中一些放在天平的左边，把另外一些放在天平的右边，然后观察天平是左偏、右偏还是平衡。想办法只称两次来判断假币是偏轻的还是偏重的（你不需要把假币找出来）。</p>
<p><strong style="color: #009bdf">答案</strong></p>
<p>首先，选 49 枚硬币放在天平左边，再选 49 枚硬币放在天平右边。如果天平是平衡的，那么目前天平上的所有硬币都是真的，假币一定在剩下的 2 枚硬币之中。把这 2 枚硬币放在天平左边，再选 2 枚硬币放在天平右边，如果左边重就说明假币是偏重的，如果左边轻就说明假币是偏轻的。</p>
<p>如果第一次称重的结果是不平衡的呢？这说明现在天平上的所有硬币当中有 1 枚是假币，没放上天平的 2 枚硬币则都是真币。接下来，取出较轻一侧的 49 枚硬币，往里面放入 1 枚真币，于是得到了 50 枚硬币。把这 50 枚硬币分成相等的两组，分别放在天平的两侧。如果天平平衡，说明假币在刚才偏重的那 49 枚硬币当中，从而说明假币是偏重的；如果天平倾斜了，就说明假币就在刚才偏轻的这 49 枚硬币当中，从而说明假币是偏轻的。</p>
<p>显然，只称一次是不可能完成任务的，因此上述方案已经达到最优，不能再改进了。</p>
<p><strong style="color: #009bdf">问题2</strong></p>
<p>你有 14 枚硬币，其中 7 枚是真币，重量都是 10 克，另外 7 枚是假币，重量都是 9.99 克。你不知道哪些硬币是真币，哪些硬币是假币，即使人为鉴定也没法把它们区分开来。好在，你有一个无比精确的天平机器人。每一次，你可以选择任意数量的硬币，把其中一些放在天平的左边，把另外一些放在天平的右边，然后按动按钮。如果两边的总重量相同，天平机器人会如实反馈，并且归还所有的硬币；如果一边重一边轻的话，天平机器人会从重的那边随机选择一枚硬币吃掉，把剩下的硬币归还给你，然后告诉你刚才是哪边更重一些。 想一种策略可以保证你从这些硬币中确定出一枚真的（并且没有被吃掉的）硬币。你可以无限制地使用这台天平机器人。</p>
<p><strong style="color: #009bdf">答案</strong></p>
<p>从中选择 4 枚硬币，把它们分成两组，分别放在天平的两侧。如果机器人告诉你天平两侧一样重，那么重新选择 4 枚硬币并且把它们分成两组放上去，直到天平两侧的重量不相等为止。不妨把较轻一侧的两枚硬币叫做 A、B，把较重一侧的两枚硬币叫做 C、D。机器人会从重的那一边吃掉一枚硬币，无妨假设是 D，然后把剩下的 A、B、C 这 3 枚硬币还给你。接下来，把 A、B 这 2 枚硬币分别放在天平左右。如果天平倾斜的话，这说明 A、B 这 2 枚硬币是一真一假的，从而说明刚才的 C、D 都是真的。虽然 D 被吃掉了，但是 C 还在，于是你就得到了一枚还没被吃掉的真币。</p>
<p>如果天平两侧一样重的话，怎么办呢？这说明 A、B 两枚硬币都是假的。现在，把这两枚硬币扔掉，于是总共 14 枚硬币就只剩下 11 枚硬币了。这 11 枚硬币当中，真的肯定要多一些，假的肯定要少一些（实际上，有可能是 7 枚真币 4 枚假币，也有可能是 6 枚真币 5 枚假币，这取决于第一次实验时机器人吃掉的是哪种硬币）。接下来就简单了，不断地把两枚硬币分放天平两侧，直到天平两侧重量不等为止。那么，重的那一侧就是真币，可惜会被吃掉；轻的那一侧就是假币，你可以把它扔掉。这样下来，手中的硬币就少了一枚真的，少了一枚假的，剩下的硬币仍然是真的多假的少。不断这样做下去，手中的硬币越来越少，但真的硬币始终会更多一些。什么时候手里只剩下一枚硬币了，或者手中的所有硬币的重量两两相等时，就说明手里这些硬币都是真的了。</p>
<p>这个问题选自 2011 年 USAMTS 的问题。</p>
<p><strong style="color: #009bdf">问题3</strong></p>
<p>有 9 枚硬币，其中 8 枚是真币，只有 1 枚是假币。所有真币都一样重，假币则稍轻一些。同时，你还有三架天平，其中两架天平是好的，另外一架天平是坏的（但你不知道哪两架是好的，哪一架是坏的）。好的天平总会给出正确的称量结果，但坏的天平会随机给出称量结果。如何使用 4 次天平，保证找出那枚假币？</p>
<p><strong style="color: #009bdf">答案</strong></p>
<p>把硬币摆成三行三列。把第一行的硬币和第二行的硬币分别放在第一架天平的左边和右边，把第一列的硬币和第二列的硬币分别放在第二架天平的左边和右边。如果这两架天平都是好的，我们就知道了假币在哪一行，以及假币在哪一列。无妨假设前两架天平给出的结果表明，假币在第一行第一列。但是，这两架天平究竟是不是都是好的呢？为此，我们将在第一行不在第一列里的硬币（共 2 枚）放在第三架天平的左边，将在第一列不在第一行里的硬币（共 2 枚）放在第三架天平的右边。如果第三架天平平衡，那么假币就只可能是第一行第一列的那枚硬币了（否则至少两架天平的结果与实际情况不符），任务就完成了。如果第三架天平不平衡呢？若左边更轻，则第三架天平的结果与第二架天平的结果相冲突；若右边更轻，则第三架天平的结果与第一架天平的结果相冲突。不管是哪种情况，我们都知道了哪架天平肯定是好的。这架天平刚才已经用过一次了，根据这次的结果，我们已经知道哪 3 枚硬币是假币了。用这架天平再称一次，任务就完成了。</p>
<p>刚才提到，“无妨假设前两架天平给出的结果表明假币在第一行第一列”，这里的“无妨”其实没有那么“无妨”。大家可以稍微留意一下假币实际上在第三行或者第三列的情况，虽然本质相同，但是细节还是稍微有些区别。这个问题来自 2008 年 All−Russian Olympiad 试题（原题的硬币总数为 3<sup>2k</sup>，天平使用次数为 3k + 1，这里只讨论了 k = 1 时的情形）。</p>
			 ]]></content>
<pubDate>2021-09-07T00:25:16+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/6970</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：切完大饼和蛋糕，让我们切一切甜甜圈 ]]></title>
<link>http://www.matrix67.com/blog/archives/7019</link>
<content><![CDATA[ 
		<p>我正在餐桌前吃早餐。餐桌上有一张圆形的大饼，有一个方形的蛋糕，还有一个甜甜圈。我依次思考了下面三个问题。你能帮我想出它们的答案吗？</p>
<ul>
<li>3 刀切一张圆形的大饼，最多能把它分成多少块？或者说，3 条直线最多能把一个圆盘分成多少个区域？</li>
<li>4 刀切一个方形的蛋糕，最多能把它分成多少块？或者说，4 个平面最多能把一个正方体分成多少个区域？</li>
<li>3 刀切一个甜甜圈，最多能把它分成多少块？或者说，3 个平面最多能把一个（实心的）环面分成多少个区域？</li>
</ul>
<p>提示：上一个问题的答案总会为下一个问题提供线索。</p>
<p><span id="more-7019"></span></p>
<ul>
<li>3 刀切一张圆形的大饼，最多能把它分成多少块？或者说，3 条直线最多能把一个圆形分成多少个区域？</li>
</ul>
<p style="text-align: center"><img alt="image placeholder" >
<p>这是一个经典的小学问题。答案是 7 块。如图所示，事实上，当直线数分别为 1, 2, 3, 4, 5, …时，最多产生的区域数对应地是 2, 4, 7, 11, 16, …。这背后的规律是：1 条直线能把圆盘分成 2 个区域；第 2, 3, 4, 5, …条直线，则会让区域数增加 2, 3, 4, 5, …个。</p>
<p>1 条直线最多能把圆盘分成 2 个区域，这事儿很显然。为什么第 n 条直线会让区域数增加 n 呢？这背后有一个非常简单的解释。前 n − 1 条直线会与第 n 条直线产生最多 n − 1 个交点，把第 n 条直线切成最多 n 段。仔细想想第 n 条直线上的每一段意味着什么——意味着某一个原有区域被细分成了两个新的区域，它们以这条线段为公共边界，分居这条线段两侧。所以，第 n 条直线最多被切成 n 段，就说明总的区域数在原来的基础上最多会增加 n。</p>
<ul>
<li>4 刀切一个方形的蛋糕，最多能把它分成多少块？或者说，4 个平面最多能把一个正方体分成多少个区域？</li>
</ul>
<p style="text-align: center"><img alt="image placeholder" >
<p>答案是 15。其中一种构造方案如下。前 3 个平面是三个两两垂直的平面，它们交于正方体的中心。整个正方体就被切成了 8 块小正方体，其中上层有 4 块，下层有 4 块。第 4 个平面不过整个正方体的中心，并且跟前 3 个平面都不平行，如图所示。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>于是，上层的每个小正方体都被分成了两个小的区域。位于“上左前方”的那个小正方体有些特殊，它被分成 7 号、8 号区域，其中 8 号区域是一个位于内部的四面体区域，它的四个面都是新切出来的。但是，下层只有其中三个小正方体被分成了两个小的区域。第 4 个平面错过了位于“下右后方”的那个小正方体，它没有被细分成两个小的区域，在图中我们用 15 号区域来标记。</p>
<p>通过这个例子，我们看到，4 个平面有可能把正方体分成 15 个区域，但为什么这就是最多的了呢？首先，3 个平面最多把正方体分成 8 个区域，这事儿应该还是挺直观的，我们干脆就把它直接当结论了。关键的问题就是，第 4 个平面为什么最多只能让区域数增加 7。前面那个切大饼的思路和答案，在这里都会派上用场。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>分析切大饼时，我们的思路是，把目光集中在最后这条直线上；受此启发，在这里，也让我们看一看第 4 个平面上发生了什么。前 3 个平面在第 4 个平面上产生了 3 条交线，这 3 条线在该平面上最多划分出 7 个多边形（这算是直接用到了切大饼问题的答案）。每一个多边形都意味着，大正方体中原来的某个区域，现在被分成了两个小区域。有 7 个多边形，就意味着新增了 7 个区域。</p>
<p>据此容易得出，只要这 4 个平面满足任意两个平面不平行，任意两条交线不平行，且 4 个平面不过同一点，分出的区域数都能达到最大值。当然，这有个前提：这些平面必须得交在正方体内才行。</p>
<ul>
<li>3 刀切一个甜甜圈，最多能把它分成多少块？或者说，3 个平面最多能把一个（实心的）环面分成多少个区域？</li>
</ul>
<p style="text-align: center"><img alt="image placeholder" >
<p>答案是 13。其中一种构造方案如下。过位于实心部分内的某一点 P 作 3 个方向互不相同的平面，平面之间产生 3 条不同的交线，每个平面都把环面切成了两个 C 字形。这就会带来 13 个不同的区域。其中 3 号区域和 4 号区域是两个近似的小三棱锥，它们都以 P 为顶点，侧面都是新切出来的，“底面”实际上都是曲面。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>3 刀切甜甜圈的问题，和之前 4 刀切蛋糕的问题，之间有着直接的联系。事实上，前者的答案一定等于后者的答案减 2。理由很简单。我们可以把实心的环面想成是一个中间有孔的蛋糕，而这个孔又可以想象成是预先在蛋糕上切了特别粗但是没通到边儿上的一刀。所以，3 刀切甜甜圈的问题，等价于 4 刀切蛋糕的问题，只不过其中一刀没有把蛋糕切断。如果这一刀两头向外延伸，真的把蛋糕切断了，会在两头各增加一个新的区域，得到 15 个区域；但是，这一刀并没有把蛋糕切断，所以所得的区域数要减 2，只有 13 个区域。</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>切大饼和切蛋糕问题都是经典问题。我最近在<a href="https://twitter.com/fermatslibrary/status/1434170877147484165" rel="noopener" target="_blank">这里</a>看到了切甜甜圈的问题。看到这个问题之后，我的第一反应就是，切甜甜圈也是一个非常自然的问题，为什么我就没有提出来过呢？这个问题的一个比较早的出处是 Martin Gardner 所著的 The 2nd Scientific American Book of Mathematical Puzzles and Diversions。书中给出了一个 3 刀切甜甜圈切出 13 块的示意图：</p>
<p style="text-align: center"><img alt="image placeholder" >
<p>书中还给出了 n 刀切甜甜圈最多能切出多少块的公式：(n<sup>3</sup> + 3n<sup>2</sup> + 8n) / 6。但书中没有说明背后的道理。本文讲到了切甜甜圈和切蛋糕之间的神奇联系。这是我在<a href="https://oeis.org/A003600" rel="noopener" target="_blank">这里</a>看到的。利用这种联系，不难推出上述公式。这个问题显然还有很多进一步扩展、推广的空间。有空我会继续思考，并查阅更多的资料。</p>
<p>2021 年 9 月 13 日更新：其中一个插图有误，已更换<br>
2021 年 9 月 16 日更新：补充了切蛋糕问题中区域数达到最大值的条件</p>
			 ]]></content>
<pubDate>2021-09-12T20:18:56+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/7019</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
</channel>
</rss>
