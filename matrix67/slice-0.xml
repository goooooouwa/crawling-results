<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Matrix67: The Aha Moments</title>
<description></description>
<link>http://www.matrix67.com/blog</link>
<pubDate>2021-11-20T14:45:25+08:00</pubDate>
<!-- other elements omitted from this example -->
<item>
<title><![CDATA[ 谬论：所有角都是直角 ]]></title>
<link>http://www.matrix67.com/blog/archives/19</link>
<content><![CDATA[ 
		<p>    今天在cut-the-knot上看到一个东西很有意思。<br>    证明：所有钝角都是直角。</p>
<p><img alt="image placeholder" >
<p>    在线段AC上向外做射线AB、CD，使∠BAC为直角、∠ACD为钝角。下面我要证∠ACD=∠BAC。<br>    首先适当取B和D在射线上的位置使AB=CD，显然BD、 AC不平行。分别作出BD和AC的垂直平分线，交于点P。<br>    那么△PBD和△PAC就是等腰三角形了。<br>    于是，BP=DP，AP=CP，又AB=CD，所以△BAP≌△DCP。<br>    因此∠BAP=∠DCP。又∠PAC=∠PCA，所以∠ACD=∠BAC=90°，证毕。<br>    其实用同样的方法也可以证明“所有锐角都是直角”，这样，所有的角都是直角了。<br>    看完后，有人或许会说，肯定证明过程的哪一步有问题。这不是废话吗？没问题的话，所有角都是直角了，那还得了？<br>    我想起那个“所有三角形都是等腰三角形”的证明了，更经典，哪天也写出来。</p>
			 ]]></content>
<pubDate>2005-07-22T13:38:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/19</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 判定被7整除的简易方法 ]]></title>
<link>http://www.matrix67.com/blog/archives/20</link>
<content><![CDATA[ 
		<p>    判断一个数的整除性对于某些除数来说是一件非常容易的事，比如2、3、4、5、6、8、9、10、11、12、15……<br>    但是对于7来说一直是一个难题，而判定是否被7整除在数字运算中又比较常用。我刚看到一种判定能否被7整除的方法，在这里写一下。<br>    比如，我们要看86415能否被7整除。首先我们把它从个位开始往左边走两个数字一组划分开来，这样，86415就划分成8 64 15；然后，从左开始“一加一减找余数”：<br><span style="font-family:宋体"><br><span style="color:red">    6       6</span><br>    8  64  15<br><span style="color:red">        1</span><br></span><br>    看上面，6+8正好被7整除，64-1被7整除，15+6被7整除。<br>    然后把找到的余数从右往左读出来，616，现在，如果616能被7整除，那么86415就能被7整除。<br>    如果你还看不出616能被7整除的话，可以继续这样做下去：<br><span style="font-family:宋体"><br><span style="color:red">    1</span><br>    6  16<br><span style="color:red">        2</span><br></span><br>    现在很明显了吧，21能被7整除。因此，86415就能被7整除。<br>    下面我再举一个例子：6913580247。<br><span style="font-family:宋体"><br><span style="color:red">     1       5       2</span><br>    69  13  58  02  47<br><span style="color:red">         6       2</span></span></p>
<p>    22561</p>
<p><span style="color:red">    5       2</span><br>    2  25  61<br><span style="color:red">        4</span><br><br>    245能被7整除，因此6913580247能被7整除。</p>
<p>    更加奇妙的是，这个方法对于判定被11整除、被13整除同样有效。<br>    至于为什么，我没仔细研究，估计和那个有关。看到7、11、13这三个数，你难道还想不起那个吗？<br>    最后补充：比较流行的割位法对于三位数、四位数比较简便；但位数一多，显然这种方法比较简便。6913580247我们用这种方法只做了两次，用割位法要做9次！</p>
<p>    做人要厚道，转帖请注明出处。</p>
			 ]]></content>
<pubDate>2005-07-22T14:33:39+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/20</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 聆听圆周率的声音 ]]></title>
<link>http://www.matrix67.com/blog/archives/27</link>
<content><![CDATA[ 
		<p><a href="http://www.matrix67.com/blogimage/20050821.swf">http://www.matrix67.com/blogimage/20050821.swf</a></p>
			 ]]></content>
<pubDate>2005-08-21T13:50:27+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/27</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 原创科普说明文：递归 ]]></title>
<link>http://www.matrix67.com/blog/archives/30</link>
<content><![CDATA[ 
		<p>    我的语文暑假作业之一，要求写任一说明文。<br>    本人菜鸟一个，文内漏洞百出，请踊跃提出，感谢不尽。<br>    Matrix67原创，转帖请注明出处。</p>
<p><span style="font-size:18pt">
<div align="center">递归</div>
<p></p></span><br>    公认的递归(Recursion)的标准定义是非常难理解的：若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的；若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。<br>    递归一词很少有过专业的定义，因此本文不在于去解释上一段文字的意义。虽然概念抽象，但递归其本身是不难理解的。通过本文的介绍，读者不一定能深入了解递归，只要能通过具体的例子模模糊糊地知道一些递归的思想和用途就可以了。<br>    究竟什么是递归呢？其实，递归就是大鱼吃小鱼，就是一条蛇咬住自己的尾巴。递归是指一样东西自己包含了自己。对于这一点，拿“谢尔品斯基地毯”(Sierpinski Gasket)来说明是最恰当不过的了。<br>    曲线在几何学中的概念很好理解，就是只有长度而没有宽度的线条。数学中有各种各样的曲线，如圆、直线、抛物线、双曲线、正弦曲线等。它们都可以用一定的方法画出来。例如，圆可以用圆规画出来，正弦曲线也可以用机器边在纸带上往复记号边拉纸带的方法画出来。事实上却没那么麻烦，画曲线有一个最常用的“万能方法”——似乎所有的曲线都可以用“描点法”画出，因为曲线没有宽度嘛，一个一个的点连起来，随便多奇怪的曲线都应该能画出。但随着数学的发展，这一点遭到了置疑。波兰数学家谢尔品斯基就想出了一个的确是一种曲线但永远无法画出的图形。他构造这种曲线的方法就运用了递归。<br>    随便找了一个正方形，把它分成3×3规格的相等的9个小正方形，然后把正中间的那一个挖掉。现在就只剩周围的八个小正方形了。接着重复这个过程，把8个小正方形的每一个都分成更小的9份，并挖掉它中间的那个。现在得到的就有8×8=64个正方形了。把这64个正方形继续这样划分，并且无限制的继续下去。这就是递归的思想，自己包含了自己，而后面的自己又包含了规模更小的自己。这样递归下去是没完的，因此最终得到的会是没有宽度的线条。这符合曲线的定义，但显然它是没办法画出来的。<br>    在现实生活中，递归的现象也是可以见到的。如果一台电视机的屏幕正显示着摄象机拍到的东西，那么把摄象机正对着这台电视机拍摄就会形成一个简单的递归。电视机显示着摄象机拍到的内容，而摄象机又对着电视机，这也就是说，摄象机将会拍摄到自己所拍到的东西。于是，递归形成了——在电视机上会显示出一层一层电视机的轮廓，即电视机里有电视机，层层循环下去永无止境。类似的例子也有一些，比如那个永远也讲不完的古老的故事，和Linda的第二张专辑的封面。<br>    递归通常是可以无限循环下去的。因此有这样一个笑话。作为一个狂热的电脑游戏迷，如果有一天你从一个完全陌生的地方醒来，你如何判断这是虚拟空间还是在现实中？答案是，找两面镜子来，互相对着放。如果出现周围的物体运动变慢等不正常的情况，说明你是在虚拟空间中。大自然是神奇的，它能处理两面镜子相对放置时镜子里应该显示的内容；但电脑就模拟不出来，如果电脑真遇到这种情况，指定会把CPU累死。<br>    但是，一旦给一个递归过程加上一个限制条件，让它递归到某一步时就停下来不要继续循环的话，递归将会派上大用场。<br>    我举一个最简单的例子。偶数就是能被2整除的数。我也可以用递归的方法定义偶数：一个偶数加上2还是偶数。这句话似乎足以说明了全部的数字，其实不然。因为如果没有任何限制，那么这个递归过程将是永无止境的，最终不会得到任何具体的答案。我们可以加上一个条件“0是偶数”。这样，情况就变了。比如，我们要看6是否为偶数，根据“一个偶数加上2还是偶数”，我们只需要看4是不是偶数。如果4是偶数，那么4+2也是偶数。而看4是否为偶数，又要看2是否为偶数，要看2是否为偶数，又要看0是否为偶数。本来这个递归应该是像这样无限地做下去的，但我们有了一个限制条件：我们已经知道了0是偶数。于是，2就是偶数了，4和6都是偶数了。同样的，我们就可以判断一切数字的奇偶性了。这就是利用递归来进行数学上的定义。<br>    这种定义方式有什么好处呢？一个简单的例子——<br>    很多人不明白为什么0的阶乘要规定成1，其实这用阶乘的递归定义一解释就清楚了。<br>    阶乘可以这样递归地定义：<br>        1)n的阶乘等于n-1的阶乘乘以n；<br>        2)1的阶乘是1；<br>    这样，所有自然数的阶乘就可以通过上面的两句话表示了。2的阶乘就是1×2；3的阶乘就是2的阶乘乘3，即1×2×3……不仅如此，我们还可以知道0的阶乘是多少：1的阶乘应该等于0的阶乘乘以1，显然0的阶乘必须是1才行。类似的，我们还能知道，负整数的阶乘没有意义。<br>    接下来，我将用两个经典的用递归的思想解决问题的例子来结束这篇文章。<br>    法国数学家艾得渥·卢卡斯(Edouard Lucas)于1883年在一份杂志上介绍了一个引人入胜的数学谜题——汉诺塔(Tower of Hanoi)，并称这与古印度的一个传说有关。显然传说的具体内容已经不在本文论述的范围内了，但我想简单的介绍一下。<br>    相传印度有座大寺庙，它曾被认为是宇宙的中心。神庙中放置了一块上面插有三根长木钉的木板，在其中的一根木钉上，由上至下放了64片直径由小至大的圆环形金属片。古印度教的天神指示他的僧侣们将64片金属片全部移至另一根木钉上。移动规则只有两个：<br>        1.在每次的移动中，只能移动一片金属片；<br>        2.过程中任意时刻必须保证金属片小的在上，大的在下。<br>    直到有那么一天，僧侣们能将64片金属片按规则从指定的木钉上全部移至另一根木钉上，那么，世界末日即随之来到，世间的一切终将被毁灭，万物都将至极乐世界。<br>    这个传说经常被认为是卢卡斯教授为推广这个数学谜题而捏造的，但不管怎么说，卢卡斯是成功了。这玩意儿变成了家喻户晓的益智游戏之一，后来又成为了学习递归的必修课程。<br>    对汉诺塔问题的研究焦点集中在如何以最少的步骤完成全部金属片的转移这一问题上。解决这个问题的方法运用了递归的思想。<br>    我们可以这样想。64片金属片太多了，我们似乎能简化一下。假如我们已经知道了如何移动63片，我们就可以把这63片看成一个整体。那么这64片的移动过程就出来了：第一步，移动前63片到另一根木钉上；第二步，移动<br>
第64片到第三根木钉上；第三步，把那63片移回第64片上面。看到了吗？问题已经解决了，因为这形成了递归。我们可以继续对移动63片的方法进行研究：把前62片移开，移动第63片，移回前62片。继续研究62片金属的移动方法……这样下去，一直推到如何移动2片金属。而移动2片金属的方法是非常简单的，已经不需要继续讨论了，于是，全部问题到此解决。<br>    发现递归思想的实质了吗？这让我想起了一个笑话。笑话的主人公是一个反应迟钝，只具有数学思维的数学家；为了使这个笑话更形象，我们就把这个人暂且定为童明国（注：我们数学老师的名字）。<br>    童明国去做消防队员。队长问：“如果你这里起火了，你怎么办？”童明国答：“用消火栓。”<br>    “那么如果这里没有起火呢？”<br>    “很简单，先把这里点燃，然后这个问题就转化为了一个我已经解决的问题了。”<br>    我要举的下一个例子与这个有异曲同工之处。<br>    小学奥赛接触过一个叫作“报30”的游戏，就是从1开始，两人轮流报数，每个人都只能报接下来的一个数或两个数。比如，第一个人可以报1，也可以报1、 2；如果第一个人报1、2，第二个人就可以报3和3、4；然后第一个人又报；这样报下去，最先报到30的人获胜。<br>    这个游戏非常没意思，因为它有必胜策略。<br>    最先报到30的人获胜，很显然，先报到27的人一定可以胜；那么，先报到24的人就一定能胜了……递归下去，21，18，最终得到的结论就是，先报到3的人一定必胜。也就是说，后报者必胜。不管先报者报多少，后报者始终报到3的倍数，这样定能获胜。<br>    这个游戏有很多变种，但换汤不换药，万变不离其宗。比如，把规则改成“最先报到30的人就输”。这样，先报到29的人就赢了，然后同样递归，26，23，20……<br>    前几天在网上看到了这个游戏的一个较难的变种。<br>    有10枚硬币，每人轮流取硬币，可以拿一枚、两枚或四枚；取到最后一枚硬币者胜。<br>    这样还有必胜策略吗？答案是肯定的，而且同样可以运用递归的思想来解决。<br>    如果硬币的总数只有一枚，则先取者赢；<br>    如果硬币的总数是两枚，则先取者赢；<br>    如果硬币的总数是三枚，则先取者输；<br>    如果硬币的总数是四枚，则先取者赢；<br>    如果硬币的总数是五枚，则先取者赢（取两枚，对方面临三枚的情形，必输）；<br>    如果硬币的总数是六枚，则先取者输（不管取多少，对方面临的情形都是必胜的情形）；<br>    如果硬币的总数是七枚，则先取者赢（取一枚，对方面临六枚的情形，必输）；<br>    如果硬币的总数是八枚，则先取者赢（取两枚，对方面临六枚的情形，必输）；<br>    如果硬币的总数是九枚，则先取者输（不管取多少，对方面临的情形都是必胜的情形）；<br>    如果硬币的总数是十枚，则先取者赢（取一枚，对方面临九枚的情形，必输）。</p>
<p>（本文参考资料：本文  呵呵）</p>
			 ]]></content>
<pubDate>2005-08-29T00:43:44+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/30</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 非常奇妙的证明：图形必在格点之外 ]]></title>
<link>http://www.matrix67.com/blog/archives/33</link>
<content><![CDATA[ 
		<p>从cut-the-knot上看到的。</p>
<p>问题：<br>    设想一个平面上布满间距为1的横纵直线，形成由一个个1×1正方形组成的网格。任意给一个面积小于1个单位的图形，证明这个图形总能放在网格中而不包含任何一个格点。</p>
<p>   <img alt="image placeholder" >
<p>证明：<br>    我们可以这样考虑这个问题：把图形随意放在网格中，如何移动网格使每个格点都在图形外面。<br>    现在我们把给定的图形随意放在网格中。然后沿着网格线把包含有图形的网格切成1×1的小格子，从网格中拿出来。把它们重叠起来（不旋转），再想像这些格子是透明的，而图形是不透明的。从上往下看这一叠格子，你看到的会是这个图形的各部分重叠地放在一个格子中，仿佛一个沾有污渍的方块。很显然这些污渍不会布满整个方块（图形面积小于一个格子的面积），方块上总有一块干净的地方。现在我们用一颗针从一个干净的地方刺下去，把这些重起来的格子刺穿。把这些格子放回原来的网格中，你看到的会是每一个有图形的方格内都有一个针眼，这些针眼都不在图形内。现在可以把原来的网格擦掉了，这几个针眼可以看作是新网格的格点。按针眼的位置重画新的网格，那么这个图形内决不会有新网格的格点，此时，结论也就证到了。</p>
<p>做人要厚道，转帖请注明出处。</p>
			 ]]></content>
<pubDate>2005-09-03T17:49:40+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/33</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 圆比直线长？ ]]></title>
<link>http://www.matrix67.com/blog/archives/38</link>
<content><![CDATA[ 
		<p>    今天在MOP上看到一个比较有意思的东西，楼主在109楼证明了圆比直线长。<br>    任做一条直线和一个圆，把直线平移使它和圆相切。直线和圆上的点都有无数多，我们怎么比较呢？于是，想到了把直线上的每一点和圆上的每一点建立一一对应关系。对于直线上的每一个点，我们都能经过它做出圆的切线，这个切点就可以和直线上的那个点对应起来。好，现在好玩了：圆上有一个点是永远也不会切到的（就是和原直线相对的那个点）。于是结论出现了：除了这个点之外，圆上的其它点都能够找到直线上相对应的点。也就是说，圆比直线长。长多少呢？就长一个点。</p>
			 ]]></content>
<pubDate>2005-09-23T16:13:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/38</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 二分图最大匹配问题匈牙利算法 ]]></title>
<link>http://www.matrix67.com/blog/archives/39</link>
<content><![CDATA[ 
		<p>    研究了几个小时，终于明白了。说穿了，就是你从二分图中找出一条路径来，让路径的起点和终点都是还没有匹配过的点，并且路径经过的连线是一条没被匹配、一条已经匹配过，再下一条又没匹配这样交替地出现。找到这样的路径后，显然路径里没被匹配的连线比已经匹配了的连线多一条，于是修改匹配图，把路径里所有匹配过的连线去掉匹配关系，把没有匹配的连线变成匹配的，这样匹配数就比原来多1个。不断执行上述操作，直到找不到这样的路径为止。</p>
			 ]]></content>
<pubDate>2005-09-27T12:50:47+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/39</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 强烈推荐“Powers of 10” 从10亿光年到0.1飞米 ]]></title>
<link>http://www.matrix67.com/blog/archives/44</link>
<content><![CDATA[ 
		<p>震撼组图！从茫茫宇宙到原子电子……<br>http://dzh.mop.com/topic/readSub.jsp?sid=5874700<br>转载自猫扑，原出处是Eames Office的http://www.powersof10.com</p>
			 ]]></content>
<pubDate>2005-10-26T22:43:03+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/44</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 某大牛直接用机器码Debug编程 ]]></title>
<link>http://www.matrix67.com/blog/archives/46</link>
<content><![CDATA[ 
		<p>    搞信息奥赛的赶快来看看，传说某年编程一等奖的作品，居然直接用Debug编出动画了。<br>    在DOS下输入debug回车，然后把下面的代码粘贴去。<br>    不知道它想表达什么，不过看起来像一个游戏的演示动画一样。<br><code>e100 33 f6 bf 0 20 b5 10 f3 a5 8c c8 5 0 2 50 68 13 1 cb e 1f be a1 1 bf 0 1<br>e11b 6 57 b8 11 1 bb 21 13 89 7 4b 4b 48 79 f9 ad 86 e0 8b c8 bd ff ff e8 20<br>e134 0 3d 0 1 74 1a 7f 3 aa eb f3 2d ff 0 50 e8 f 0 5a f7 d8 8b d8 26 8a 1 aa<br>e14f 4a 75 f9 eb de cb 57 bb 21 13 8b c1 40 f7 27 f7 f5 8b fb ba 11 1 4f 4f 4a<br>e168 39 5 7f f9 52 8b c5 f7 25 f7 37 2b c8 95 f7 65 2 f7 37 95 2b e8 fe e fe<br>e181 10 79 6 c6 6 fe 10 7 46 d0 14 d1 d1 d1 e5 79 ec 5a b8 11 1 ff 7 4b 4b 48<br>e19b 3b d0 75 f7 5f c3 83 f7 83 a6 5d 59 82 cd b2 8 42 46 9 57 a9 c5 ca aa 1b<br>e1b4 4f 52 b4 92 3f ab 6e 9e a8 1d c6 3 fc e 6a e7 ae bb 5f 7b 10 b8 b4 f7 8<br>e1cd e2 bf 36 4e 39 9d 79 29 3f a f9 36 52 16 fb 5 e8 e5 a6 c2 e9 b0 43 d3 a3<br>e1e6 cf d3 fd fd cb d1 4c 5e e0 63 58 86 bb 3e 9 c1 20 bc cc 91 a3 47 81 70 b3<br>e1ff d6 1a 9e c2 c9 12 e7 4e ad f4 5f e3 30 e9 9 39 d7 e8 f9 f4 d2 44 e8 d7 22<br>e218 be e2 ce 88 25 cf 30 4a a8 29 ae 3f 47 c6 2d 85 e9 73 54 13 b e6 e0 34 65<br>e231 e2 50 8a 89 18 5f ce 70 99 3 5f 42 bf eb 7 ae d0 ca 5 22 8d 22 a5 b7 f0<br>e24a 90 81 bc 7a bc dc 5 db c0 6a 2 e5 57 38 be 60 cb ac ba a5 3b 9d f1 77 38<br>e263 a6 84 d1 3c af 49 d8 6a 45 a2 76 60 21 12 c0 c2 44 f2 5e bb e5 37 a9 2b<br>e27b ec 4a 8c 4c f2 f7 a9 58 71 2b ba 6d d6 6a e5 60 46 e0 da e5 b9 90 e5 a3<br>e293 f7 7f 31 60 58 f0 c4 88 10 4e 3c a3 ee 4e 11 55 8f a 92 eb db ad 7a 9c f<br>e2ac db 5a 28 96 da 87 ae 91 91 2d e3 5e ea df 6 95 71 67 71 40 ce d1 2e 31 6d<br>e2c5 c1 9c d8 6a 76 9b 4a e8 36 44 d6 76 d 30 5 ff d4 1b ac 1f 32 65 31 bf 55<br>e2de 26 b a4 55 e1 5d 5e 16 ed 97 48 6c 77 fb 81 86 e f9 18 bd d4 f4 8b de 1d<br>e2f7 ba d 47 75 3 89 4b 3e dc 27 86 1c d0 17 89 48 d1 a6 8d d4 2b 54 4e 8f b0<br>e310 2 e1 6b 1a 75 78 ea 21 91 13 c0 cf 78 a0 ab f3 35 c6 b4 c8 90 8d d7 45 e7<br>e329 c 5b a4 ba 52 10 64 f5 4a 50 b7 ec 46 22 15 23 84 30 81 5c df 61 5a 8f 67<br>e342 c4 63 57 6d f7 26 92 a3 1f e5 3 a5 0 54 41 8 48 7c 26 90 33 82 9c 91 b0<br>e35b ab 78 5d df 99 e0 b9 fc 5 36 ac d9 49 91 ab 20 a2 63 48 89 ce 5c 60 64 f0<br>e374 63 d9 a8 38 3b d3 e6 4c 8c 23 34 4e 20 51 93 5e 6d b4 7a 22 9b 4c f2 d3<br>e38c c4 f8 3 6f 47 40 f4 f8 45 9b 83 f3 83 6 31 d0 0 17 82 83 dc 67 f9 62 77<br>e3a5 90 3b d9 ec f3 55 96 b8 d9 db 79 55 f1 e5 8c 5e f2 e5 2e b0 b 6e e2 81 25<br>e3be 93 8e b5 dd 5b 46 f9 af ed 6 12 cf c9 1d f0 f7 3b 16 2d c6 58 73 8d e9 5f<br>e3d7 fd 5a b6 a1 94 4d 1a 8 ff eb b7 6 80 c7 86 83 b6 b9 fd 1c e0 c c3 2e a0<br>e3f0 2f b 3e 3 6b 29 e1 27 85 1c ea 6d df b3 a3 ed 65 4a 9a 59 3b 54 e 4b ae<br>e409 9e 27 f0 4d 3b c 4c 46 b7 e5 57 1b 1f 1f bb 80 86 f5 b7 ef 73 52 bf 2c c7<br>e422 ed a b7 81 2 f3 90 3e ee cc 6c eb f 38 1 6c 68 b1 d 45 78 b2 f f6 83 b0<br>e43c c4 33 df b1 d1 91 98 1e 81 a5 e2 59 9f f4 8c b6 72 8 a7 8c f6 e a3 b2 1f<br>e455 d9 d3 23 f0 7c 5e 5f 68 61 8b 45 da 1d 91 ec 8d 4e ea 1a 38 85 94 aa ac<br>e46d f2 4 f6 c4 e5 92 8e 9a 4e 83 e1 73 e8 cf 2a 5c 2b 7e f1 30 2 8a e6 28 1a<br>e486 3b ce bc 96 aa 7f eb 87 cd 8b 96 2d 9 59 7a a0 1a 43 62 9a 9e 4f ff 8e d9<br>e49f ce d6 a4 70 79 cd 65 fa 2e 92 14 29 f7 6c 74 4b 49 60 80 bb ff 41 bb 2d<br>e4b7 60 33 3f 98 77 9a 1 ee a6 a3 da bc ba e9 f3 72 f4 7c c3 59 2 a6 44 a4 c8<br>e4d0 c8 54 93 ce bd 69 bb b9 43 21 2c c4 ea 4a 5c 3f 75 60 f2 b4 91 ca 9 82 e3<br>e4e9 a e9 a6 20 b9 76 50 ed 47 e9 fe 6d 41 34 13 2f 28 2f 4e f4 da e 3c 78 6c<br>e502 b1 79 87 45 98 a4 d4 c3 b3 29 c2 4a 8b ed a6 54 e2 1b 31 62 60 ff 2c 1d<br>e51a 21 0 15 b2 4e 5c c 2 d 83 fa a2 f3 8a 5 12 72 4a c7 44 7c 91 d4 be b a f2<br>e535 70 52 fb b4 a2 df 89 de ff c4 96 73 c9 c ed d3 c9 8e 5c dc 8e d1 3b de 8c<br>e54e 53 a2 8b f9 e9 91 dd d6 df 6e 74 d1 dd 34 60 8f 9e 32 7f 3b ec 79 a3 83<br>e566 45 78 b4 2f 1c 50 7b 7a 97 b0 9d 2d c dd 8a 26 cd 7d 8c 4c 5a 8a 4c f9 a4<br>e57f 11 f9 2c 6c 92 e9 b5 cb 56 89 8c be f6 64 fa 25 43 fa 6f e2 c8 3a 18 a8<br>e597 f0 e9 f4 c2 86 e6 2b 44 67 4a b9 34 9 ed 5f 33 42 62 d4 8a 1e 5b 31 67 cd<br>e5b0 3d 71 6d 83 fd 36 20 69 ea 1 c3 e6 e6 de 99 aa 7 11 5b 59 8a 1f 43 83 52<br>e5c9 ea 5d 8c 6a 69 c7 3 eb 4e 3b 88 a5 5f b1 6e 27 5f 3 5c 28 c 9b 6c c3 f8<br>e5e2 e5 b9 d6 11 d6 8b fa 5c 8 c7 1 eb 45 db f3 6c 9f 16 46 61 51 ed df f bb<br>e5fb c0 c4 1e 64 68 98 4 79 30 94 72 df d4 cd 1f 7f 72 c6 82 2e 79 47 4e 8c 4b<br>e614 a2 c7 e2 36 df 76 fd a4 b6 4e db 96 40 3b 8b b5 d4 85 64 c6 0 2c ad 9d 27<br>e62d 14 99 82 4b bc 9 fa 94 b5 db 7c 98 eb b 13 a7 b0 79 1d 7e c5 45 aa 20 49<br>e646 be ff 9d 64 0 5d c ec 6 5 ad f2 38 6b ed 7a d6 b2 c7 2e 6a a6 12 4b ff 55<br>e660 20 3b a 77 f b9 0 9d 57 4a ad ce a4 d3 ff 1 4f fb 53 54 88 f 1 ed 4b 56<br>e67a 15 c8 dc 28 bf f2 72 d4 10 1f 99 42 69 9e 78 e2 47 82 93 31 d0 2d be 9f<br>e692 93 93 9a 1b 80 c0 10 c 53 78 a0 26 2a 96 4f 74 4b 16 c7 9c 8d ad ac fb 16<br>e6ab 15 c6 fd c9 a4 14 48 62 47 20 c9 41 ed 61 f8 9b f8 ff ba 39 50 65 87 ee<br>e6c3 bd ce 95 c0 fb a5 7e d8 cd 27 fd 2c 74 3 c1 1b 89 b9 51 d5 e3 da ef 9e 6<br>e6dc f0 aa a9 a7 fb 87 4c 5d cd ff 65 36 8c 73 6f 9 c6 78 9a b6 77 db df 81 68<br>e6f5 3b b8 ae 5d e1 af d4 e6 66 8c d6 a4 83 9f 37 3c 1 dc a2 a6 57 c2 20 1b 90<br>e70e 75 df cd a5 62 a5 36 79 fb 35 8a 9b b0 a0 a5 c3 37 6f 80 72 bc 52 30 8d<br>e726 9f 7a 64 d3 7 41 45 d8 68 97 f2 aa 1c a1 6c 7c 9d 32 7d ad 15 b1 53 e3 33<br>e73f 8a ed e9 49 d4 cf dc 96 22 37 36 11 9d 7f f0 4d e0 62 31 b1 c7 69 c4 79<br>e757 ac 20 1 e8 3c 6a 8c 32 cb 52 63 36 68 f4 10 2b 9c 21 4f df 5d 60 92 39 91<br>e770 e2 f9 c9 7d ca 48 3 3f 21 dd 6c f 23 2e 61 3a 9f ba c3 f9 4e 7 ea ed ef<br>e789 71 4a 72 3a ed 23 3d 77 b5 ed d5 1d f6 a4 99 fa ef 98 dd 2 98 80 b6 7c a3<br>e7a2 62 96 7b 8e bf 7b 81 9f 9a ce 3f 12 40 2e 25 db 84 16 dd 2e 86 f f4 b2 7e<br>e7bb 5e b4 14 6a f3 29 b1 a4 57 d5 a8 17 6f 87 a4 74 5b 9b 17 79 f1 ec 33 c8<br>e7d3 f0 1d b2 7e a8 4d 95 7f 5f 9 d5 1a 5a 45 f4 41 c6 d 3f eb 66 2a c0 e8 5b<br>e7ec 3c bd 50 ad f1 53 9d 2e 45 9a d8 7d 2c 17 a8 6e 15 48 13 39 53 ed 3d 78<br>e804 ad f 3a 65 a3 3e 2e fa ca 7 94 4a 1f b4 d8 7e 47 8a 8e de e7 7e 34 c1 69<br>e81d 7f 6a aa 66 58 18 31 24 72 13 22 34 8a 56 36 87 df c2 d 8e 3f 71 a2 5f 25<br>e836 8b 8d 4 78 fd c9 45 d1 55 79 c1 9f 13 84 1b c8 5 db 95 d0 7c 64 96 20 51<br>e84f c4 e0 5e ee 47 8a 11 ac fb 9 e0 bb 40 db 86 84 12 93 b9 c9 f2 9c 63 47 c9<br>e868 eb ad 1 3e fa 6d 3f a 64 5b 58 56 27 f ca 5d e0 30 bc 3e 10 5d ec 17 28<br>e881 85 5 51 8e 95 a3 94 3a a8 f1 96 f2 f 29 5c 97 dc 47 db 9d 6c 63 e8 e7 f0<br>e89a e4 a 70 f8 f1 47 54 d3 2d 32 7c ef bb 9a b4 1b 0 2b d6 dd e7 30 b a2 75<br>e8b3 c7 f5 d0 31 d7 d2 8a b0 ac 1c 6d 60 3a f7 c2 db 1e 6d 7 f6 8f 35 88 e5 7f<br>e8cc 3c 26 81 34 a0 32 a3 25 18 6e 73 b2 a0 f1 cb 86 61 e7 65 8b 76 98 19 6f<br>e8e4 c0 62 9b a3 cc 18 5e 40 12 97 2b d0 15 79 de 19 ea df 7a 59 2f b5 d7 39<br>e8fc 52 e2 6 f1 3 a0 a5 d9 1b 88 93 4d 30 c8 2d f5 db 55 ea 85 6f a 3f dc bd<br>e915 57 15 6a a3 a3 3e 8e ad 2d da a0 ca 75 7c 57 8b c5 cb b 1d 2c 8e c6 96 2e<br>e92e 6d 59 83 7d 64 72 ca 80 2e 6 a4 ff f6 f2 d5 1e 7 4 ba 34 6e 9 86 25 aa 4e<br>e948 e0 7f f5 32 47 3e 7c 43 d8 28 c4 1c 11 1d bd 33 3 b5 ca 13 43 34 2 b1 a0<br>e961 57 ed 9d 3c 23 d4 45 b2 6e 81 6e af 3e 67 90 be 59 a5 45 34 53 46 85 d1<br>e979 25 ee 7d cb a4 db 12 c3 aa 17 61 9a fb 66 40 76 fe 3a 69 96 c0 91 14 a7<br>e991 5d cc 9f f6 73 59 ee b8 55 97 20 26 ff 99 ec 72 41 b5 27 21 6e ae 8a d0<br>e9a9 e4 d3 da 6f c4 53 c5 f8 b3 a7 a1 5d 66 93 d8 b1 89 40 23 92 c0 90 fb cb<br>e9c1 e7 6b 4e 51 0 5d 57 f7 cd 1 e2 88 bf 44 9f ef c4 33 ce fa 46 46 a1 86 b<br>e9da 7a 84 66 66 b9 2 ec 10 c6 a1 d4 c1 18 33 b1 d1 2 18 ad 2f 53 e4 b9 33 59<br>e9f3 be 3c af 80 4c 8a d5 76 c 3b a7 e2 97 94 15 75 4d 17 d5 97 cf f9 4a d0 6e<br>ea0c bb 27 20 fc f1 f5 9 a8 df 4d b6 5d f0 1d 69 3b 76 35 82 a4 f3 56 64 39 5b<br>ea25 6b b3 7 e7 5 8e 82 11 22 a8 1a db c8 3e 67 4a 3 7e 72 51 d6 3d 1a 1c f6<br>ea3e b8 da 4b 18 8a 15 9d<br>
 d0 a4 84 96 3e cd 3 f9 3a 30 f3 fb 8f 6e 2 73 eb 52<br>ea57 93 95 cf dc 6f 48 fb ab d2 a9 70 b4 e2 23 8d 72 86 a8 fa 78 98 1d c5 fe<br>ea6f 8a 51 88 2b b7 58 b0 ca ae 40 8a 33 32 75 1 6 c0 d4 b7 da 2a a7 bb ad f7<br>ea88 48 98 5a bc d3 d1 e6 16 97 c3 80 ab 73 ac 32 11 41 1f d 5d aa 0 dc d9 6e<br>eaa1 fc 30 6 ef 11 60 27 a2 5f eb 5f b9 35 8 23 4 be 10 c0 85 3e 55 b3 82 fd<br>eaba f7 c3 24 9f 2d 83 94 32 36 de ff 7c 87 7f 4a 80 7 2 23 cf a4 52 eb 3e 19<br>ead3 a0 b4 a 94 1a 40 58 d9 16 6d c0 64 c4 69 ed 60 46 65 cb df 58 38 0 51 c3<br>eaec ad a0 37 e4 cf ab f7 6c 24 7d 9 48 65 4a 9f 91 ad 1c 79 a4 a1 78 55 c e8<br>eb05 44 5b d ef 51 bd ea 2d a7 42 57 ab 3a 4f 2 b 3 19 6a 4d 72 76 5c 97 0 6c<br>eb1f c5 5d bc dd e7 81 cf 8d 34 38 50 3c 98 58 cc 41 aa 99 90 af fe 4e 96 77<br>eb37 ed 54 18 ce 2c d1 5d 34 cb 79 50 ff 28 96 44 e0 51 64 6 a8 b7 6e 8c 62 c4<br>eb50 66 95 81 4f 8c f6 26 ba ea 5d d2 79 b1 e4 e9 29 fc a fd b3 85 8c e6 52 dd<br>eb69 33 bd 5d c7 39 ef 6 ef 9e a6 6a 61 9c 9f d5 54 b4 fa a1 d4 10 9b ff 7e 33<br>eb82 11 52 99 c7 26 6e a1 36 8a ad ee 48 7a 2c 7f d5 b7 27 8a 6b 37 c 71 39 85<br>eb9b 9c ba a8 a 17 b9 d0 51 56 95 c2 3b 5 a7 31 c5 8b 5c 95 6e 4c 89 6f 17 ef<br>ebb4 d4 5a a 77 65 e1 49 b2 e8 72 ac 3c f0 6b 71 fa 3 c7 ca fc ad f9 55 22 ec<br>ebcd 58 2f 1c fa 29 cf 73 b4 ad 51 5c f8 66 70 59 5d 70 3e d1 3f c4 eb ec f1<br>ebe5 7 78 6a 93 67 9f 44 fc cb 5b 95 ff 74 c0 b7 42 77 26 c9 aa 8c ed 39 a2 db<br>ebfe 9c b3 eb 3d 4a 1e 9b 89 e4 d8 a8 27 74 ef a3 ed a5 24 5d bb ab d0 fe a1<br>ec16 29 ab df 75 a a6 23 0 cc f1 14 72 9b 1a 55 7e e5 d1 da 98 dc c4 cf ab 34<br>ec2f ba 8d de 4a 59 6 13 dd d8 44 3c e bb 56 95 ae 97 e2 3b 49 e5 9a 6b a2 53<br>ec48 c1 33 35 24 1b 33 17 c3 8a 8c 12 3d 3d 4e 5b 75 22 30 67 4f a0 5d 3a 78<br>ec60 88 a 11 35 7 b1 77 42 32 a8 c3 bb 20 fb 98 5 d6 ac e7 3a 63 35 90 93 9e<br>ec79 44 24 2e 1b d7 8c aa 29 53 4d d9 ab eb e6 1 56 c4 fd 54 a3 bd 14 5b b0 8f<br>ec92 ce be 23 24 93 c4 48 18 a3 e7 4 5 4b 78 cc 79 dd 3 56 a4 ed dd 5f 98 41<br>ecab 1b 68 4c c1 bb 41 c2 1e 3e 94 8e ef 28 1e b 76 e 4f 36 b1 c 6e e2 18 17<br>ecc4 20 fc 35 40 1f e4 6d a4 18 bb bc d5 9e ea 85 86 af af 63 d4 13 66 92 c4<br>ecdc 2b 69 84 ca 23 2b d3 66 81 6b 81 73 26 4 85 36 21 4c 49 44 75 64 39 16 3c<br>ecf5 ed e0 6d 44 75 45 30 43 68 c0 78 fc d0 17 b eb 81 3e c3 ba 1b f 4d ae c5<br>ed0e 55 1f c 39 12 5d 8 65 f1 34 59 de dd 98 56 17 43 38 66 49 9a eb db c1 87<br>ed27 51 38 cc b7 5f 98 fd 43 be 2d bb 74 f3 f8 f2 36 3d a4 34 a5 7e d2 26 cc<br>ed3f 84 1f ea 56 f0 80 18 69 4d 88 41 fc 56 fd 41 3b 1e e 9 27 4f f6 3b 62 4e<br>ed58 5a 1b 2a 4e 85 8c b2 4f 79 ef 59 4e e 73 3d bd c4 ca 60 e7 4a 47 90 b5 8<br>ed71 2a f0 4e dc ba 66 ae 48 2b 31 73 a2 11 c 32 ff 54 14 77 6b d6 58 4b bf ee<br>ed8a f6 6a bc dd 1 88 d da a9 f 81 24 c5 f8 72 9a db d5 c8 2a 80 a9 16 d7 c6<br>eda3 b1 91 c0 a9 95 40 b5 b3 a8 2a 28 c6 92 16 ab 54 7d f8 93 5f 3a 17 c8 45<br>edbb a9 f0 e0 71 23 76 53 38 a5 a1 cc d4 f1 f2 3c 2b 46 43 a1 d5 ba e d7 19 7a<br>edd4 c2 e1 8f 67 1d d 98 9d a1 79 9d 1b 20 7f 4d e7 bf f9 ff fe aa 28 ab 8f c<br>eded 4d 50 33 e3 26 fc 3c 3 3a 2b 26 12 f7 1 8f ee 97 4c e6 6 2b d9 1f a1 4a<br>ee06 77 44 d4 8b b7 3e 5e 2d 18 c3 54 68 99 a8 8d 92 96 9e 9d ab 33 38 ff b8<br>ee1e ee 78 c6 7b b5 84 95 d3 6 27 ae 5d 27 38 a 38 8e f0 1 a5 96 4b d7 9b 42<br>ee37 e5 6f 57 75 4c e9 78 2d 5b ec b6 d2 29 e2 a8 92 95 9c 65 2a 3e bf 8d e0<br>ee4f bf b3 ac c8 e 7e 13 af 88 26 7d 48 5a c7 39 29 36 d2 90 e8 3b 3 d0 61 1a<br>ee68 d2 e8 a8 f ba 8e a1 9f df 12 ab 54 7 23 98 de 62 af 4c 7e d4 fb 6b 2 6e<br>ee81 40 40 37 b7 73 f2 d8 81 be 29 d2 99 c0 73 25 1a 3c 92 75 6e bd d7 79 79<br>ee99 4 14 c0 4e 99 57 66 93 74 ec b0 29 7c df 61 b0 3 3a d1 c3 fa a4 f7 f 9f<br>eeb2 d3 f 0 b9 2a 5a 3a c5 88 25 b8 b9 cc 82 3 57 3a e1 7b 51 75 70 a6 74 1a<br>eecb ca cb 3 18 68 ca 77 fe 1b ad cd 68 7f 36 85 fc b7 4f a0 11 da 69 fa 79 87<br>eee4 d6 b9 21 dd 3e 70 db dc 84 d4 6e d1 20 4 af f6 32 a2 8e d 54 25 fe 7 54<br>eefd e 7a 74 4b a0 4b f7 f4 e8 74 22 e9 98 70 fb 25 2e f4 64 57 75 28 85 45 53<br>ef16 3a 2e e2 3c 54 36 e9 29 6 67 59 43 10 7e c1 49 cd 5e f9 97 a 58 5f 8a 11<br>ef2f 4f 3d 9a e2 2b 22 58 fa be fc 69 91 7a 8c 3f 77 9f c9 3b 54 26 23 93 b3<br>ef47 85 de ae f5 bd c5 47 4c c4 cd 5e ad bc 8f ba 31 f6 e4 70 fb 6e a7 96 d5<br>ef5f ad 10 80 39 43 97 4f 10 cc 1b 8f 8d cd 4c 63 4 d8 1e 85 70 41 6c a8 eb df<br>ef78 7f 36 c5 60 a7 12 9 16 73 fe 75 3a 2d 40 29 7d aa a 5c 2 29 23 0 a6 e5 6b<br>ef92 24 6d 9b 20 e5 7 cb 40 b0 38 59 9c a7 69 6a 70 d3 38 ef e2 b2 11 3e ea 2a<br>efab f9 2b 2e 43 1d 65 cf d6 1b ef 83 5a 5f e6 c5 62 16 ca 5e 4c a6 39 e4 53<br>efc3 2d 23 d2 5e 7e 15 54 8a 8 b7 3d bb 88 59 b9 9e a2 7c 42 1f a2 77 3c 5b 9<br>efdc 6d fa 8f 21 46 1a 3e ed ce 49 56 1d 29 2d 70 3 a7 6f 75 ac 1 87 ff 27 86<br>eff5 73 49 28 85 2d 97 7a 84 e 37 3d 86 10 21 4c e2 74 62 6b 51 70 8f 15 72 f3<br>e100e 81 b2 a9 9d 8a 63 ad 1b d5 aa 8a dc 96 3c e7 47 16 51 fc 87 50 9 b7 60<br>e1026 29 33 52 fb b0 df 70 c5 65 4a 60 3b c d7 a8 29 47 51 f7 8a 77 f3 99 3f<br>e103e 38 16 60 de 68 27 b2 24 7 62 a2 fd 40 86 b2 75 c3 3c 2f 3d fa 9 d9 a9 9a<br>e1057 71 3c ce 46 94 0 f9 bc 46 7f b8 2e 85 7f 7d d3 8d ea b4 63 81 59 10 bb<br>e106f 57 d0 b6 ab e1 83 74 1e 25 d5 73 78 18 b1 60 62 c f4 76 8d 17 d5 ed 23<br>e1087 23 e4 f6 32 64 5a 61 9 63 f6 92 57 d5 29 40 d6 3b ba 63 72 18 0 25 1b 7<br>e10a0 ee 7f 25 4a fa 6 74 19 46 e3 e8 89 7a c6 56 54 a7 43 13 4e bf 97 a5 6f<br>e10b8 99 2f ac 33 4d fa 58 3a 5a a a4 1a 74 62 c8 4f 3b 78 9 d7 ee 7e ee 2d 69<br>e10d1 30 40 ea 47 82 3b 85 8e 3 23 8f 74 4e 8 35 ab 74 4 1 57 d5 85 b1 6b 1e<br>e10ea f4 7d 1e d2 1e b3 fe f3 12 10 32 39 51 48 2d 6f e5 d3 a3 8c 8 8<br>g</code></p>
			 ]]></content>
<pubDate>2005-10-30T22:44:28+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/46</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Not Pr0n 号称最难的在线解谜游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/54</link>
<content><![CDATA[ 
		<p>www.notpron.com ——The hardest riddle available on the internet<br>确实比较强——今天晚上暂时过了7关。<br>有兴趣来玩嘛，打发一下时光，而且也确实考智力。</p>
			 ]]></content>
<pubDate>2005-12-01T23:52:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/54</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 不可解问题(Undecidable Decision Problem) ]]></title>
<link>http://www.matrix67.com/blog/archives/55</link>
<content><![CDATA[ 
		<p>    看黑书介绍NP的时候有一个“不可解问题”，非常不可思议，费劲周折在网上查到了些英文资料，搞明白了，非常有意思，在这里说一下。<br>    不可解问题(Undecidable Decision Problem)指的是这样一种问题：他无论如何也不可能有一个正确的算法来解决。虽然不可思议，但这种问题被证明确实是存在的。图灵在1936年（那时还没电脑，我们的父亲是在没有设备支持的纯理论基础上提出来的，致敬）提出了第一个不可解问题的实例：The Halting Problem。<br>    The Halting Problem是问，输入一段程序代码和一个针对此程序的输入，能否编程判断运行这个程序后程序是否会终止。<br>    这个问题的答案是否定的。也就是说，不可能有一种算法可以正确判断一个指定的程序运行后，给予指定的输入，程序最后出不出得来。换句话说，The Halting Problem是一个不可解问题。<br>    虽然这感觉似乎不可能，但在严格的证明下谁也无法发言反对。<br>    证明过程非常简单，假设The Halting Problem是有解的，并且已经用程序实现了，那么我们只需要再编写一个程序Program Bug，就会发现存在矛盾。<br>    反证：既然解决The Halting Problem的算法已经实现了，那么我们一定能定义一个函数<br> <code>Function Halting(a,b:input_type):boolean;</code> <br>    其中，a是读入的程序源码，b是输入数据。这个函数的功能就是返回对于指定的程序源码和输入数据，程序是否能顺利退出。<br>    下面编写一个程序：<br> <code>Program Bug;<br>var<br>    code:input_type;<br>begin<br>   get(code);   //读入code<br>   if halting(code,code) then repeat until false<br>      else halt;<br>end.</code> <br>    好，现在运行Bug这个程序，并且输入Bug这个程序本身的代码。这样，halting(code,code)其实质就是在判断这个Bug程序本身了。如果The Halting Problem认为Bug程序会正常退出，那么就让程序进入一个死循环，否则立即退出程序。矛盾产生。<br>    //简直是在挑战表达力极限<br>    //做人要厚道，转帖请注明出处</p>
			 ]]></content>
<pubDate>2005-12-07T22:31:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/55</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 几个把平面几何问题的辅助线做到空间去的数学趣题 ]]></title>
<link>http://www.matrix67.com/blog/archives/58</link>
<content><![CDATA[ 
		<p>一、平面三圆问题1</p>
<p><img alt="image placeholder" >
<p>    问题：平面上三圆两两相交于六点。试证明三条公共弦共点。<br>    证明：把这三个圆想像为三个球的大圆。为方便叙述，我们把三个球的球心确定的平面记作 α。显然，平面 α 在三个球上的截面就是题目的这三个大圆，而 α 上的三个大圆的三条公共弦即是每两个球之间的公共小圆在 α 上的投影。我们要证明的就是三个公共小圆在平面 α 上的投影共点。注意到三个球交于两点，这两点关于平面 α 对称且这两点就是三个公共小圆的交点。把这两点也投影到平面 α 上，得证。</p>
<p>二、平面三圆问题2<br><img alt="image placeholder" >
<p>三、四人旅行问题<br>    问题：平面上四条直线，任两条不平行，任三条不共点。四个旅行者 A、B、C、D 分别匀速地走在这四条直线上（他们的速度可以不相同）。若 A 在行走过程中与 B、C、D 相遇，B 在行走过程中与 C、D 相遇（当然也遇见了 A），求证：C、D 在行走过程中相遇。<br>    证明：作垂直于平面的直线作为时间轴，建立三维直角坐标系。由于四人均匀速行走，因此他们的路程-时间图像是线形的。我们可以在空间中作出 A、B、C、D 四个人行走路程与时间关系的图像并分别命名为 La、Lb、Lc、Ld。这样，我们可以从这四条空间直线中轻易判断某一时刻四人的位置。例如，空间中 P 点 (x, y, t)在直线 Lc 上，则表明在 t 时刻 C 走到了平面(x, y)位置。好，现在强了，真的强了。A、B 不是曾经相遇过吗？这就是说，La 和 Lb 相交。这两条相交直线可以确定一个平面。C 不是与 A、B 都相遇过吗？那就是说，Lc 与 La、Lb 都相交。于是，Lc 也在这个平面上。同样地，Ld 也在这个平面上。既然全部都共面了，Lc、Ld 必然会相交，即 C、D 必相遇。得证。</p>
<p>四、三角形对称问题<br>   <img alt="image placeholder" >
<p>    问题：平面上任意三角形 ABC 和异于 A、B、C 三点的点 P。 X、Y、Z 三点分别是 P 点关于三边 BC、AC、AB 的中点的对称点。求证：AX、BY、CZ 共点。</p>
<p> <img alt="image placeholder" >
			 ]]></content>
<pubDate>2006-01-07T00:07:11+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/58</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Fibonacci数列转二进制图形的惊异发现 ]]></title>
<link>http://www.matrix67.com/blog/archives/60</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>    上面这个图是由前500多位Fibonacci数列的二进制数组成的，二进制数从左到右排列，从上到下书写，每一个“1”都用一个像素表示。下图是上图最左下角的几个像素放大后的图片，更有助于理解的。神奇的是，想来应该是乱如麻的图形竟然出现了大大小小的直角三角形，神奇啊。</p>
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2006-01-11T17:57:58+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/60</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 在线数列百科全书 ]]></title>
<link>http://www.matrix67.com/blog/archives/61</link>
<content><![CDATA[ 
		<p>The On-Line Encyclopedia of Integer Sequences:<br> http://www.research.att.com/~njas/sequences/</p>
<p>    输入数列的若干数字，查找有关的数列。<br>    什么鬼数列都有。<br>    居然连1,11,21,1211,111221,312211,13112221……也有，并起了名字叫做Look and Say sequence<br>    以后不愁做找数字规律的题了。</p>
			 ]]></content>
<pubDate>2006-01-12T23:40:35+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/61</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 切实感受四维空间 ]]></title>
<link>http://www.matrix67.com/blog/archives/65</link>
<content><![CDATA[ 
		<p>    我跟一些人描述过四维空间。但一个由八个全等立方体拼接组成的广义空间确实让活在三维世界的人难以想像。正如生活在二维空间里的人无法想像在一个扁平的面里怎么可能存在六个全等正方形互相拼接组成的立体形状。我们通常只能在一张纸上画四条射线并令它们两两互相垂直来表现四维空间。但第四维究竟在哪里？昨天我发现的两个网站可以帮助你感受到。</p>
<p>    如果你对四维立方体还不够了解，下面这个网站叙述了由二维到三维到四维的递推过程，它或许可以帮助你。<br>http://www.mathematische-basteleien.de/hypercube.htm</p>
<p>    下面两个网站的Java小程序能让人体会到一个四维立方体的存在和它绕第四维旋转的可能。</p>
<p>    首先，你的浏览器必须支持Java。你可以在网上搜索到有关内容。</p>
<p>    下面这个网站是一个通过红-蓝3D立体眼镜图或3D立体图（说穿了，就是用对眼看）能感受到的旋转的四维立方体。<br>http://dogfeathers.com/java/hyprcube.html<br>    从三维的角度而不是一张薄纸能快速感到四维立方体如何绕第四维旋转。找一个眼镜，把左边的镜片涂成红色，右边蓝色，使得你左右眼分别看到两种不同颜色的线条。戴上后你将能看到真实的立体感。在花店分别找一张红色和蓝色的玻璃纸也能轻易地做到这一点。另外，点击stereo两次后，可以用看3D立体图的方式 “对眼”去看，但效果没有那么好。</p>
<p>    下面这个网站提供了一种4D环境中的游戏。<br>http://www1.tip.nl/~t515027/hypercube.html<br>    在这个游戏中，你需要在三维或四维立方体中把球撞击到标记的位置，然后从出口出去再进来以获得另外一个标记，并尽量不要被外面的小球看到。成功撞击5次标记后游戏结束，你可以看看自己的得分。游戏分为两种：三维的和四维的。每一种游戏都可以选择是否启用立体图模式（看对眼模式）。比如，在三维的游戏中，不开启立体图模式你很难判断前后的位置关系，需要自己的空间想像能力。而开启立体图模式后，你将能清晰地看到三维空间中各物体的位置关系。你可以先试着在三维立方体中关掉立体模式玩这个游戏，就像是玩一个2D游戏一样。然后在四维立方体中开启立体模式玩，就像是玩一个3D游戏一样。过一会儿，你将会发现你能自由的在四维立方体中移动。</p>
<p>    做人要厚道，转帖请注明出处。</p>
			 ]]></content>
<pubDate>2006-02-01T14:00:04+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/65</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 大开眼界：世上最无敌的迷宫当数“分形迷宫” ]]></title>
<link>http://www.matrix67.com/blog/archives/74</link>
<content><![CDATA[ 
		<p>      <img alt="image placeholder" >
<p>    分形迷宫(Fractal Maze)是一个芯片，要求从芯片上的负极走到正极，其中A、B、C三个小芯片都是这个芯片自己的一个复制。递归，堆栈。<br>    如果你过了的话，欢迎挑战——</p>
<p>      <img alt="image placeholder" >
			 ]]></content>
<pubDate>2006-03-10T00:02:09+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/74</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 史上最强数字找规律题 ]]></title>
<link>http://www.matrix67.com/blog/archives/76</link>
<content><![CDATA[ 
		<p>考大家一道题。<br>这是一个比较著名的数列：</p>
<blockquote><p><span style="font-size:8pt">2,<br>271,<br>2718281,<br>2718281828459045235360287471352662497757247093699959574966967627724076630353547594571,<br>……</span></p></blockquote>
<p>能看出这个数列是个什么东西的人高考加20分。<br>事实上，这个规律是可以用不到一秒的时间一眼看出的（如果你对那个够熟悉）。</p>
			 ]]></content>
<pubDate>2006-03-17T22:16:55+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/76</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Java Applet平衡树演示 ]]></title>
<link>http://www.matrix67.com/blog/archives/80</link>
<content><![CDATA[ 
		<p>Treap：<br>http://www.ibr.cs.tu-bs.de/courses/ss98/audii/applets/BST/Treap-Example.html</p>
<p>Splay：<br>http://www.ibr.cs.tu-bs.de/courses/ss98/audii/applets/BST/SplayTree-Example.html</p>
<p>更多：<br>http://www.ibr.cs.tu-bs.de/courses/ss98/audii/applets/BST/index.html</p>
<p>做得无敌了</p>
			 ]]></content>
<pubDate>2006-04-12T00:18:09+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/80</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 几个很强的数列 ]]></title>
<link>http://www.matrix67.com/blog/archives/83</link>
<content><![CDATA[ 
		<p>Aronson's sequence:<br>1, 4, 11, 16, 24, 29, 33, 35, 39, 45, 47, 51, 56, 58, 62, 64, …<br>whose definition is:<br>T is the first, fourth, eleventh, … letter of this sentence</p>
<p>0, 0, 0, 0, 4, 9, 5, 1, 1, 0, 55, 55, 1, 0, 1, 9, 5, 1, 1, 0, …<br>这个比较强：把1,2,3,4,5, …写成英文<br>one, two, three, four, five, six, seven, eigth, nine, ten<br>然后删掉除c,d,i,l,m,v,x以外的字母，变成罗马数字。</p>
<p>Golomb's sequence:<br>1,2,2,3,3,4,4,4,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,9,10,10,10,10,10 …<br>定义：a(1)=1, a(n)表示n在这个数列里出现的次数</p>
<p>Emirps:<br>13, 17, 31, 37, 71, 73, 79, 97, 107, 113, 149, 157, 167, 179, 199, …<br>就是一个Prime（质数）倒过来写也是质数</p>
<p>'Eban' numbers (the letter 'e' is banned!).<br>2, 4, 6, 30, 32, 34, 36, 40, 42, 44, 46, 50, 52, 54, 56, 60, 62, 64, 66, 2000, 2002, 2004, 2006, 2030, 2032, 2034, 2036, 2040, …</p>
			 ]]></content>
<pubDate>2006-04-23T13:42:38+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/83</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 爱的方程式 ]]></title>
<link>http://www.matrix67.com/blog/archives/85</link>
<content><![CDATA[ 
		<p>  <img alt="image placeholder" >
			 ]]></content>
<pubDate>2006-05-04T21:35:48+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/85</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 《数据结构与算法分析》5000字缩写（上） ]]></title>
<link>http://www.matrix67.com/blog/archives/90</link>
<content><![CDATA[ 
		<p>    4月7日买起来看，前几天才看完。这可以说明很多问题，比如，学习很紧张，没有时间；书本身很好，很有看头；看书看得很细心，很有耐心。<br>    打算大致写一下书里的内容。<br>    Data Structures and Algorithm Analysis in C, Second Edition，机械工业出版社。封面很丑，一个黑底版，上面有些大理石花纹，正中间生硬的摆一个原版封面，同样丑。一共12章，近400页。<br>    400多页是很多的。我们必须要“把厚书读薄”，厚的变薄的，薄的变一页，一页变一行，一行变成一个字。因此，我要在有限的字数内把整本书说完。</p>
<p>    算法分析，就是复杂度的问题。复杂度只算“最要命的”，比如，执行n^2的算法前来个快排根本不拖速度，n^2多的都豁出去了不在乎区区一个nlogn。书里对复杂度进行了严格的定义，包括O()、o()、Θ()、Ω()四种符号。简单地说，O(n^2)就是顶破天了搞个n^2次；o(n^2)就是天花板不到n^2，比n^2矮一点（比如希尔排序就是o(n^2)，因为它再倒霉也达不到n^2）；Ω(n^2)就是说某个算法随便怎么至少都要耗费n^2，比如所有基于比较的排序都是Ω(nlogn)；Θ(n^2)就是说它即是O(n^2)又是Ω(n^2)，被天花板和水泥地夹在中间了，动不了了，就是它了。这里面有一个经典的例子，就是最大子序列（找数列中连续一段数之和最大）的四种算法，复杂度分别为O(n^3)、O(n^2)、O(nlogn)和O (n)。这书一个特色在于，对每种数据结构都有严格的算法复杂度证明，这往往是看上去最头痛的部分。</p>
<p>    表、栈和队列是三个基本的数据结构。说穿了表就是把数据找起来排排坐吃果果，找什么东西都来把整个队伍找一遍。栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来，就好像你看到了一个丑人不可能今天的中饭还没吐出来就先把早饭吐出来了。栈是拿来模拟多个过程的调用的（比如递归），实际点的用途就是表达式计算。队列好比堵车，先进去的先出来。先进队先买票，不能插队。常拿来实现广搜。</p>
<p>    树，是一种植物，有很多枝枝丫丫。不同的是这里的树是倒着的，树枝朝下长。最上面叫根，尖尖的地方叫树叶，生出树叶的是他爸，他爸生的是他儿子。不管是根是树叶还是儿子还是儿子他爸都叫节点。我们常常把数据储存在节点上，并且以后还要不断地插入、改变和删除数据。<br>    二叉树就是每个分叉的地方最多分两个岔，而且还分得清左右。二叉查找树就是说把数据存在节点上，而且左边的都比他爸小，右边的都比他爸大，以后要找哪个数就可以只找其中的一边，一半一半地扔掉。在二叉查找树里也可以插入一个数，删掉一个数（只有一个儿子好办，有两个就把右边的最小的一个拿来替代这个），找最小的数（一直往左走），找最大的数（一直往右走），但是容易搞着搞着的树就变畸形了，比如说左边猛起长右边萎缩导致以后往左边走要走很久。我们就需要一种方法来让树左右差不多一样多而且左边的值仍然比右边的小。事实上这种方法已经找到了，而且不只一种方法，而是一卡车的方法，比如AVL、Splay、红黑树、Treap等。几种方法都靠一个叫“旋转”的技巧，就是把几个节点怎么个一转，左边的就跑到右边去了一点。看下面这个图你就明白了。</p>
<p><span style="font-family:宋体">         ①                   ②<br>        /        旋转       /  <br>      ②   ZZ    ——&gt;    XX  ①<br>     /                        /  <br>    XX  YY                    YY  ZZ</span></p>
<p>这样一来左边就少了，如果左边的XX本来很多的话就可以往上提一层从而平衡。同样地，右边多了反过来做就是了。这只是最简单的“单旋转”，事实上还有很多其它的较复杂的旋转方法。Splay树就是把刚才访问过的节点转啊转啊转啊转转到最顶上去，Treap就是每个节点附加一个随机的数，随时通过旋转保持儿子的这些随机数比他爸大，其余的有点复杂。这些方法都能使二叉查找树相对地平衡一些，防止畸变导致的时间浪费。<br>    B-树和二叉查找树有两个不同，一个是节点不存数据，数据全在树叶子上，二个是它不一定是二叉。数据仍然左边小右边大方便查找。每个节点最多的儿子数有限制，最多三叉的叫2-3树，最多四叉的叫2-3-4树。因为只有树叶上有数据，所以可以递归地用分裂的方法处理新插入后出现的分叉比规定的最多的儿子个数时还多的情况。比如，2-3树中如果哪里分了四个岔，就把它重新分成两个两个的岔。我们还规定，除了根以外，每个节点最少的儿子数是规定的最多儿子数的一半，除不尽取上整。容易想到，删除的话可以把插入时的分裂反过来做，什么时候只剩一个儿子了就和旁边的合并起来。</p>
<p>    Hash表又叫散列表，一般用于判断有没有重复。比如我想找我们班有没有两个一天生的，我们不必每两个人都来比较一次，而是准备一个年历，让人一个一个上去在他的生日那天那里画一个圈，如果谁要画圈时发现那里已经有一个圈了，就找到了一对。这个很简单，不说了。<br>    那天班上流行一个心里测试，当时我还真发现了一个和我一天生的，女的。</p>
<p>Matrix67原创<br>做人要厚道 转帖请注明出处</p>
			 ]]></content>
<pubDate>2006-05-27T21:34:26+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/90</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 《数据结构与算法分析》5000字缩写（中） ]]></title>
<link>http://www.matrix67.com/blog/archives/91</link>
<content><![CDATA[ 
		<p>    堆，就是一陀一陀的东西。头重脚轻不算堆，要上面小下面大才算一个堆。堆是一棵二叉树，满足下面的始终比上面的大。它和二叉查找树比较起来既有好的又有不好的：好的就是要想知道数据里的最小值时根本就不用找了，直接就是最顶上的那个了；不好的就是堆除了这个以外基本上不能做别的事了。除了最顶上的那个以外，你几乎没办法控制其余的部分。当然，插入和删除数据这种基本操作还是可以做的。插入就是把数据暂时先放在最下面的某个位置，然后通过与它上面一个进行比较、交换不断往上冒直到已经到了自己的位置不能再向上为止。删除反起来，通过不断交换往下沉一直沉到底。因为是往下走，所以要考虑到一个把左边的放上来还是把右边的放上来的问题。当然，为了保证堆上小下大的性质，应该把小的一边换上来。刚才说过，由于你只能“看”到最顶上的东西，不知道中间部分是什么样，我们通常只删除最小的（最上面的）那个节点。其实堆还有一个最大的好处：容易写代码。因为我们可以有意让数据把树“排得满满的”，满到它是一行一行挨着排下来的。这叫做“完全二叉树”。我们可以给完全二叉树编个号，从上到下从左到右挨着数下来。根是1，找左儿子就乘2，找右儿子就乘2加1，找它爸就 div 2。以后叫谁就是谁，很方便。这样整个树就可以用一个数组实现了。由于堆基本上只用来找最小，因此如果某个问题要求很复杂的话，最好还是用成二叉查找树；当然，如果问题只要求插入、删除和找最小三种操作，你应该毫不犹豫地选择堆，毕竟找最小时堆方便得多，写起又简单。什么时候出现这种问题呢？比如说，我的女友排起队的，我每次要选一个最纯洁的，就是受那些的影响最小的人。每当我遇见了一个新的美女，我就把她放在这个队伍里合适的位置供我以后娱乐。这时，我只关心每次插入、取最小和删最小。这个队伍就可以用一个堆来优化。因此，堆还有一个形象的名字叫优先队列。如果谁问题目要求不找最小找最大怎么办，那人肯定是个傻子，把堆变通一下，上大下小不就完了吗？</p>
<p>    研究堆麻烦的地方就是堆的合并。如何把两个堆合并成一个堆？这个解决了很有用，至少上面的这些操作跟着全部统一了：插入就是与一个单节点的堆合并，删除根就是把根不要了，把根的左右两边（显然还是堆）合并起来。一个简单的办法就是递归地不断把根大的堆往根小的堆的右边合并，把新得到的堆替换原来的右儿子。注意递归过程中哪个根大哪个根小是不停在改变的。这样下来的结果就是典型的“右倾错误”，而且破坏了完全二叉树的完美。为此，我们想要随时保证堆的最右边尽量少。于是，干脆不要完全二叉树了，不过是多写几行代码嘛。这个不存在像二叉查找树那样“某一边越做越多”的退化问题，因为对于一个堆来说，反正我只管最顶上的东西，下面平不平衡无所谓，只要不挡我合并的道就行。于是，我们想到人为下一个能让堆尽量往左边斜的规定。这个规定就是，对于左右两个儿子来说，左边那个离它下面最近的两个儿子不全（有可能一个都没有）的节点的距离比右边那个的远。这规定看着麻烦，其实还真有效，最右边的路径的长比想像中的变得短得多。这就叫左式堆（左偏树）。这下合并倒是方便了，但合并着合并着要不了多少次右边又多了。解决的办法就是想办法随时保持左式堆的性质。办法很简单，你合并不是递归的吗？每次递归一层后再看看左右两边儿子离它下面没有两个儿子的节点哪个远，如果右边变远了就把左边右边调一下。由于我们已经没有用数组实现这玩意了，因此链表搞起很简单。这个对调左右的方法给了我们一个启发：哪里还要管什么到没有两个儿子的节点的距离嘛，既然我每次都在往右合并，我为什么不每次合并之后都把它对调到左边去呢？这种想法是可行的，事实上它还有一个另外的名字，叫斜堆。</p>
<p>    二项堆更强，它也是堆，也能合并，不过它已经超越了堆的境界了：它不是一个堆，而是满屋子的堆。也就是说，找最小值不能再一下子找到了，而是要把二项堆中的每个堆的顶部都看一下。二项堆的合并也很强，直接把根大的堆放在根小的堆的下面。这意味着二项堆的每个堆都可能不是二叉树了。这增加了编程的难度，不过可以用一个叫做“左儿子右兄弟”的技巧来解决问题。这个技巧，说穿了就是仍然用二叉树来表示多叉树：把树画好，然后规定节点的左儿子是下一层的最左边那个，右儿子就是它右边那个。就是说，左儿子才是真正的儿子，右儿子不过是一起生出来的。为了让二项堆好看些，让堆的个数和大小保持在一个能快速操作的数目和比例内，二项堆作出了一个明智的规定：每个堆的大小（总的节点个数）只能是1、2、4、8、16…中的一个，且每种大小的堆只能有一个。若干个互不相同的2的幂足以表示任意一个正整数，因此这个规定可以保证不管多大的二项堆都能表示出来。保持这个性质很简单，遇到两个大小相等的堆就合并起来成为一个大一号的堆。由于总是两个大小相等的堆在合并，因此二项堆中的每一个堆都有一个奇妙的样子，看看本文结束后下面附的一个大小为16的堆的示意图，再看一下，再看一下，你就能体会到了。图下面有一个用“左儿子右兄弟”法表示的同样的树，其中，往下走的线是左儿子，往右走的线是右儿子。</p>
<p>    最后简单说一下Fibonacci堆。保持一个跟着变的数组记录现在某个节点在堆中的位置，我们还是可以对堆里的数据进行一些操作的，至少像删除、改变数值等操作是完全可以的。但这个也需要耗费一些时间。Fibonacci堆相当开放，比二项堆更开放，它可以不花任何时间减少（只能是减少）某个节点的值。它是这样想的：你二项堆都可以养一屋子的堆，我为什么不行呢？于是，它懒得把减小了的节点一点一点地浮上去，而是直接就把它作为根拿出来当成一个新的堆。每次我要查最小值时我就再像二项堆一样（但不要求堆的大小了）一个个合并起来还原成一个堆。当然，这样的做法是有适用范围的，就是前面说的数值只能是减少。在什么时候需要一个数值只减少不增加的堆结构呢？莫过于Dijkstra一类的图论算法了。所以说，这些图论算法用Fibonacci堆优化可以进一步提速。</p>
<p><img alt="image placeholder" >
<p>Matrix67原创<br>做人要厚道 转帖请注明出处</p>
			 ]]></content>
<pubDate>2006-05-31T00:44:28+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/91</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 《数据结构与算法分析》5000字缩写（下） ]]></title>
<link>http://www.matrix67.com/blog/archives/92</link>
<content><![CDATA[ 
		<p>     有一个女人的男人很幸福。事实上，这是片面的。应该说，有不止一个女人的男人更幸福。但是，这样会坏了我的人品，而且被女的知道了也不好。两个耍得好的女人话很多，秘密在女人中传得很快。于是，我打算不同时和两个耍得好的女的耍朋友。后来我意识到，这样也不行。女人太无敌了，即使A与B耍得好，B与C耍得好，A和C的消息也是互通的。哪怕只有一个朋友关系也能把两群人联系在一起。我不得不改变策略，使得我的女朋友之间没有任何渠道传递信息。也就是说，在上面的A、B、C三个人中，虽然A和C没有直接的联系，但我也不能同时和A、C耍。不久后，我想知道，某两个女人是否可以通过某条“朋友链”传递信息。这就是所谓的等价关系——基本上算是判断一个无向图的连通性。就像很多个集合，每次选两个并成一个，而且我们随时想知道某两个元素经过前面的合并后是否在同一个集合内。怎么办呢？后来有一天，我发现那些小女生喜欢玩些认亲戚的游戏，什么谁是谁妈，谁是谁姐，谁是谁女儿之类的（不知道为什么这些疯女人喜欢搞这些）。我突然恍然大悟，我的问题可以用树结构来完成。亲戚的亲戚还是亲戚，但有一点总相同：所有亲戚的始祖总是一样的。始祖一样的都是一伙的。因此，把两个集合并在一起，只要让其中一个集合的根成为另一个集合中的某个元素的一个儿子就行了，这种家谱关系的改变将使前面的集合中所有的元素拥有和后面那个集合一样的鼻祖，而这将成为这些元素的“标志”。这个想法的灵感是来自女人世界的，因此女人还是有一定的作用。<br>    这就叫并查集，又叫不相交集。它可以合并两个集合并且查询两个元素是否在同一集合。我们有一个很有效的剪枝：递归时顺便把路上经过的祖祖辈辈全部变成根的儿子。这样的程序只用2行来解决。<br><code>function find_set(x:integer):integer;<br>   begin<br>   if x&lt;&gt;p[x] then p[x]:=find_set(p[x]);<br>   exit(p[x]);<br>end;</code><br>    p[x]表示元素x的父亲的位置。一开始，p[x]都等于x自己，表示自己一个人是一个集合。函数find_set(x)将返回x所在集合（一棵树）的根。<br>    并查集还有些其它的剪枝和一些很复杂的效率分析问题，这里不多说了。</p>
<p>    写到这里，《数据结构与算法分析》中的几个大块内容算是说清楚了。由于本文的叙述调整了原书各章节的顺序且至此还没有涉及书里的一些小问题，因此这里想把遗漏下的一些小东西提一下。<br>    有一些树结构可能要求同时满足多个要求。比如一个简单的问题：如果要求构造一个堆使得既能查找最小元素又能查找最大元素怎么办？这时，我们可以用一个特殊的方法来实现：树的单数层满足一种性质，树的双数层满足另一种性质。我们用一个叫做最小-最大堆的东西来实现前面说的问题。这个堆的双数层的数据小于它爸大于它爸的爸，单数层的数据反过来，大于它爸小于它爸的爸。用类似的方法，我们还可以设计一个二叉查找树，使得它能够支持含有2种不同类型元素的数据。在单数层按其中一种操作，在双数层按另一种操作，这样可以方便的查找同时位于两个不同类元素的指定区间内的数据。这种二叉查找树叫做2-d树。扩展2-d 树，我们可以得到k-d树。这些数据结构的具体实现方法这里不说了，书上本来也是作为一个习题介绍的。<br>    书里的第7章花了近50页介绍并分析各种排序算法，分析得很全。其中第11节花了10页介绍外部排序。所谓外部排序，就是说怎样快速地把一个根本无法全部读入内存的大文件进行排序。很多排序之所以可行是因为它们可以随意读写任意一个指定的数。但在大文件里，我们无法实现“第1234567890个元素和第 123个元素交换位置”，更无法实现递归之类的操作，而只能像磁带一样“过一遍”，从头到尾扫一遍，由于文件太大内存不能接受，因此必须要读一截扔一截。于是，外部排序产生了。不要以为这个限制会把排序速度拖得很慢。事实上，外部排序同样突破了O(n^2)的界限。它借助了归并排序中的“合并两个已经有序的数组”的思想，因为这个操作可以边读就边做。把文件先拆成两个文件，再把每个文件处理成一段一段的等长有序序列（一段多大取决于内存能一次处理多大），然后不断从两个文件中各取一段出来合并。可以看到，每段有序序列的长度变长了，变成了2倍长。过不了几次，这个长度将变成文件的总长。注意，我们必须要让每次合并时为下次合并做好准备（就是说合并后的结果仍然要是两个分了段的文件）。一个好的方法是将合并的结果交替存在两个不同的新文件中。<br>    第9章讲图论算法。讲了图的遍历（广搜和深搜）、AOV、AOE、Dijkstra、网络流、Prim、Kruskal和NP问题。在讲深搜时，我学到了两个新东西，用线性时间查找割点（去掉了的话图就不连通了的点）和强分支（有向图中的一个分支满足其中任两个点之间都可以互相到达）。后来发现黑书上也有，又觉得这个东西很不好说，因此这里不想说了。说到了黑书还想顺便补一句：黑书真的看不得——太多错误了。不是说LRJ怎么了，LRJ在真正的大问题上有他的思想和经验，但很多细节的概念他也是昏的，这不利于初学者接受知识。不信哪天我还要写一篇日志纠正黑书的错误。引用政治书上抨击“人性自私论”的经典语言：“从理论到实践都是错的”。<br>    第10章讲“算法设计技巧”，大概是些贪心啊，分治啊，动规啊，回溯啊，随机化啊之类的。调度问题、Huffman树、装箱问题近似算法、最近点距分治算法、最优二叉查找树、Floyd-Warshall、跳跃表、Miller-Rabin素性测试、博弈算法等都在这章中有讲，并且讲得相当好。由于这不是本书的重点内容，这里也不说了。<br>    第11章整章都在讲摊还分析。这是一个相当复杂的问题，是分析时间复杂度的一个有力工具。它的分析告诉我们的不是某一个操作的复杂度，而是重复执行某一个操作的平均复杂度。研究这个是很有必要的，因为我们会遇到一些“越变越慢”的退化情形和“自我保持不变”的自调整性等数据结构，单个操作并不能反映它真正的效率。</p>
<p>    到这里，这本书的所有东西都已经介绍完了。总的来说，这本书很值得一看（虽然有些地方翻译得很差）。它的理论性很强，证明过程完整（再复杂的分析它也证明得很清楚，满足那些刨根问底的人）；整本书自成一个体系，前后呼应；习题具有研究性，与课文互相补充。事实上，这些都是国外教材共有的特点。这算是我完整读过的第一本国外教材，今后我还会读一些。这几天在看《组合数学》（仍然是这个出版社出版的），看完后也打算写一下“对《组合数学》一书中部分内容的形象理解”。读一本国外教材，你会发现它与国内书籍的不同并会从中获益更多。</p>
<p>    这篇文章就写到这里了。号称是一个5000字缩写，没想到写着写着已经超过8000字了。而且，这个</p>
			 ]]></content>
<pubDate>2006-06-04T00:18:15+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/92</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 一句话证明余弦定理 ]]></title>
<link>http://www.matrix67.com/blog/archives/100</link>
<content><![CDATA[ 
		<p>   <img alt="image placeholder" >
<p>    如图，蓝色三角形ABC，以AC和BC为边向外作黄色正方形，作CP垂直于AB且CP=AB并依P的位置作出两个平行四边形，平移图中红色、蓝色部分后，黄色部分面积相等，建立等量关系。</p>
			 ]]></content>
<pubDate>2006-08-04T10:46:01+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/100</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 什么是P问题、NP问题和NPC问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/105</link>
<content><![CDATA[ 
		<p>    这或许是众多OIer最大的误区之一。<br>    你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是 NPC问题是一个多大的错误。</p>
<p>    还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n)，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于O(n^2)的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是O(a^n)的指数级复杂度，甚至O(n!)的阶乘级复杂度。不会存在O(2*n^2)的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，O (n^3+n^2)的复杂度也就是O(n^3)的复杂度。因此，我们会说，一个O(0.01*n^3)的程序的效率比O(100*n^2)的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终O(n^3)的复杂度将远远超过O(n^2)。我们也说，O(n^100)的复杂度小于O(1.01^n)的复杂度。<br>    容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是O(1),O(log(n)),O(n^a)等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p>
<p>    自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=62">The Halting Problem</a>就是一个著名的不可解问题，在我的Blog上有过专门的介绍和证明。再比如，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p>
<p>    下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。哪些问题是P类问题呢？通常NOI和NOIP不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。<br>    接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100 小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。<br>    之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。</p>
<p>    很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。<br>    NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问<br>
题，好比物理学中的大统一和数学中的歌德巴赫猜想等。<br>    目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p>
<p>    为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。<br>    简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。<br>    “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。<br>    很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。<br>    现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。<br>    当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p>
<p>    好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p>
<p>    NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。<br>    既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p>
<p>    顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p>
<p>    不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。下文即将介绍它。<br>    下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。<br>    逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。<br>    什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。<br><span style="font-family:宋体">  ┌───┐<br>  │ 输入1├─→┐    ┌──┐<br>  └───┘    └─→┤    │<br>                      │ or ├→─┐<br>  ┌───┐    ┌─→┤    │    │    ┌──┐<br>  │ 输入2├─→┤    └──┘    └─→┤    │<br> &amp;<br>
nbsp;└───┘    │                ┌─→┤AND ├──→输出<br>                └────────┘┌→┤    │<br>  ┌───┐    ┌──┐            │  └──┘<br>  │ 输入3├─→┤ NOT├─→────┘<br>  └───┘    └──┘</span><br>    这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。<br>    有输出无论如何都不可能为True的逻辑电路吗？有。下面就是一个简单的例子。<br><span style="font-family:宋体">  ┌───┐<br>  │输入1 ├→─┐    ┌──┐<br>  └───┘    └─→┤    │<br>                      │AND ├─→┐<br>                ┌─→┤    │    │<br>                │    └──┘    │  ┌──┐<br>                │                └→┤    │<br>  ┌───┐    │                    │AND ├─→输出<br>  │输入2 ├→─┤  ┌──┐      ┌→┤    │<br>  └───┘    └→┤NOT ├→──┘  └──┘<br>                    └──┘</span><br>    上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。<br>    回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。<br>    逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。</p>
<p>    有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p>
<p>Matrix67原创<br>转载请注明出处</p>
			 ]]></content>
<pubDate>2006-08-28T22:58:32+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/105</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 什么是离散化？ ]]></title>
<link>http://www.matrix67.com/blog/archives/108</link>
<content><![CDATA[ 
		<p>    如果说今年这时候OIBH问得最多的问题是二分图，那么去年这时候问得最多的算是离散化了。对于“什么是离散化”，搜索帖子你会发现有各种说法，比如“排序后处理”、“对坐标的近似处理”等等。哪个是对的呢？哪个都对。关键在于，这需要一些例子和不少的讲解才能完全解释清楚。<br>    离散化是程序设计中一个非常常用的技巧，它可以有效的降低时间复杂度。其基本思想就是在众多可能的情况中“只考虑我需要用的值”。下面我将用三个例子说明，如何运用离散化改进一个低效的，甚至根本不可能实现的算法。</p>
<p>    《算法艺术与信息学竞赛》中的计算几何部分，黄亮举了一个经典的例子，我认为很适合用来介绍离散化思想。这个问题是UVA10173(http://acm.uva.es/p/v101/10173.html)，题目意思很简单，给定平面上n个点的坐标，求能够覆盖所有这些点的最小矩形面积。这个问题难就难在，这个矩形可以倾斜放置（边不必平行于坐标轴）。<br>       <img alt="image placeholder" >
<p>    对于某些坐标虽然已经是整数（已经是离散的了）但范围极大的问题，我们也可以用离散化的思想缩小这个规模。最近搞模拟赛Vijos似乎火了一把，我就拿两道Vijos的题开刀。<br>    VOJ1056(http://www.vijos.cn/Problem_Show.asp?id=1056) 永远是离散化的经典问题。大意是给定平面上的n个矩形（坐标为整数，矩形与矩形之间可能有重叠的部分），求其覆盖的总面积。平常的想法就是开一个与二维坐标规模相当的二维Boolean数组模拟矩形的“覆盖”（把矩形所在的位置填上True）。可惜这个想法在这里有些问题，因为这个题目中坐标范围相当大（坐标范围为-10^8到10^8之间的整数）。但我们发现，矩形的数量n&lt;=100远远小于坐标范围。每个矩形会在横纵坐标上各“使用”两个值， 100个矩形的坐标也不过用了-10^8到10^8之间的200个值。也就是说，实际有用的值其实只有这么几个。这些值将作为新的坐标值重新划分整个平面，省去中间的若干坐标值没有影响。我们可以将坐标范围“离散化”到1到200之间的数，于是一个200*200的二维数组就足够了。实现方法正如本文开头所说的“排序后处理”。对横坐标（或纵坐标）进行一次排序并映射为1到2n的整数，同时记录新坐标的每两个相邻坐标之间在离散化前实际的距离是多少。这道题同样有优化的余地。<br>    最后简单讲一下计算几何以外的一个运用实例（实质仍然是坐标的离散）。才考的VOJ1238(http://www.vijos.cn/Problem_Show.asp?id=1238)中，标程开了一个与时间范围一样大的数组来储存时间段的位置。这种方法在空间上来看十分危险。一旦时间取值范围再大一点，盲目的空间开销将导致Memory Limit Exceeded。我们完全可以采用离散化避免这种情况。我们对所有给出的时间坐标进行一次排序，然后同样用时间段的开始点和结束点来计算每个时刻的游戏数，只是一次性加的经验值数将乘以排序后这两个相邻时间点的实际差。这样，一个1..n的数组就足够了。</p>
<p>    离散化的应用相当广泛，以后你会看到还有很多其它的用途。</p>
<p><span style="color:blue">2007.04.05补充：<br>VOJ1056那个例子看来还是有人不明白。<br>我发一张示意图，注意左边的10*7的数组是如何等价地转化为右边两个4*4的数组的</span><br><img alt="image placeholder" >
<p>Matrix67原创<br>转载请注明出处</p>
			 ]]></content>
<pubDate>2006-09-26T21:09:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/108</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ IOCCC近几年的获奖作品 ]]></title>
<link>http://www.matrix67.com/blog/archives/109</link>
<content><![CDATA[ 
		<p>    想起在网上找找这个是因为<a target="_blank" href="http://lakeblur.spaces.live.com/">lakeblur</a>给我发过这样一个C代码：</p>
<p><code>#include &lt;stdio.h&gt;<br>main(t,_,a)<br>char *a;<br>{<br>return!0&lt;t?t&lt;3?main(-79,-13,a+main(-87,1-_,main(-86,0,a+1)+a)):<br>1,t&lt;_?main(t+1,_,a):3,main(-94,-27+t,a)&amp;&amp;t==2?_&lt;13?<br>main(2,_+1,"%s %d %dn"):9:16:t&lt;0?t&lt;-72?main(_,t,<br>"@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l+,/n{n+,/+#n+,/#<br>;#q#n+,/+k#;*+,/'r :'d*'3,}{w+K w'K:'+}e#';dq#'l <br>q#'+d'K#!/+k#;q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# <br>){nl]!/n{n#'; r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#n'wk nw' <br>iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c <br>;;{nl'-{}rw]'/+,}##'*}#nc,',#nw]'/+kd'+e}+;#'rdq#w! nr'/ ') }+}{rl#'{n' ')#<br>}'+}##(!!/")<br>  :t&lt;-50?_==*a?putchar(31[a]):main(-65,_,a+1):main((*a=='/')+t,_,a+1)<br>    :0&lt;t?main(2,2,"%s"):*a=='/'||main(0,main(-61,*a,<br>"!ek;dc i@bK'(q)-[w]*%n+r3#l,{}:nuwloca-O;m .vpbks,fxntdCeghiry"),a+1);<br>}</code></p>
<p>    程序编译运行后不可思议地打印出一长段超过源代码长度的文字，而这些字串竟然根本没有在源代码中出现过。我知道C代码可以写得很怪，而且看这个程序估计还用了不少递归；但从没有想过还有如此荒唐的源代码，看上去基本上就是乱码。刚才我搜索到，这段代码是IOCCC的一个获奖作品。</p>
<p>    IOCCC即International Obfuscated C Code Contest，比谁的C代码写得最乱最读不懂。<br>    这个比赛已经举办了17年了，下面是近几年的一些获奖作品。<br>    你可以在http://www.au.ioccc.org/years.html看到更多，但很多需要在Linux环境下编译运行。比较有趣的又能够在windows环境下运行都已经在下面了。<br>    我们假设你编译后的文件名都是abc.exe。</p>
<p>编译后在dos下输入<br><code>abc "ash nazg durhbatuluhk, ash nazg gimbatul, ash nazg thrakatuluhk, agh burzhumh-ishi krimpatul." &gt;abc.pgm</code><br>然后用图片编辑器查看abc.pgm</p>
<p><code>                                  #include<br>                                  &lt;stdio.h&gt;<br>                     #include                &lt;stdlib.h&gt;<br>                     #include                &lt;string.h&gt;<br>                    #define w "Hk~HdA=Jk|Jk~LSyL[{M[wMcxNksNss:"<br>                   #define r"Ht@H|@=HdJHtJHdYHtY:HtFHtF=JDBIl"<br>                  "DJTEJDFIlMIlM:HdMHdM=I|KIlMJTOJDOIlWITY:8Y"<br>                 #define S"IT@I\@=HdHHtGH|KILJJDIJDH:H|KID"<br>                "K=HdQHtPH|TIDRJDRJDQ:JC?JK?=JDRJLRI|UItU:8T"<br>               #define _(i,j)L[i=2*T[j,O[i=O[j-R[j,T[i=2*<br>              R[j-5*T[j+4*O[j-L[j,R[i=3*T[j-R[j-3*O[j+L[j,<br>             #define t"IS?I\@=HdGHtGIDJILIJDIItHJTFJDF:8J"<br>    #define y                  yy(4),yy(5),                yy(6),yy(7)<br>  #define yy(              i)R[i]=T[i],T[i ]            =O[i],O[i]=L [i]<br>#define Y _(0          ], 4] )_ (1 ], 5] )_ (2      ], 6] )_ (3 ], 7] )_=1<br>#define v(i)(      (( R[ i ] * _ + T [ i ]) * _ + O [ i ]) * _ + L [ i ]) *2<br>double b = 32  ,l ,k ,o ,B ,_ ; int Q , s , V , R [8 ], T[ 8] ,O [8 ], L[ 8] ;<br>#define q( Q,R ) R= *X ++ % 64 *8 ,R |= *X /8 &amp;7 ,Q=*X++%8,Q=Q*64+*X++%64-256,<br># define  p      "G\QG\P=GLPGTPGdMGdNGtOGlOG"   "dSGdRGDPGLPG\LG\LHtGHtH:"<br>#  define W         "Hs?H{?=HdGH|FI\II\GJlHJ"    "lFL\DLTCMlAM\@Ns}Nk|:8G"<br># define   U           "EDGEDH=EtCElDH{~H|AJk}"       "Jk?LSzL[|M[wMcxNksNst:"<br>#  define u                  "Hs?H|@=HdFHtEI"             "\HI\FJLHJTD:8H"<br>char  *   x                   ,*X , ( * i )[               640],z[3]="4_",<br>*Z = "4,8O4.8O4G" r U "4M"u S"4R"u t"4S8CHdDH|E=HtAIDAIt@IlAJTCJDCIlKI\K:8K"U<br> "4TDdWDdW=D\UD\VF\FFdHGtCGtEIDBIDDIlBIdDJT@JLC:8D"t"4UGDNG\L=GDJGLKHL<br>FHLGHtEHtE:"p"4ZFDTFLT=G|EGlHITBH|DIlDIdE:HtMH|M=JDBJLDKLAKDALDFKtFKdMK<br>\LJTOJ\NJTMJTM:8M4aGtFGlG=G|HG|H:G\IG\J=G|IG|I:GdKGlL=G|JG|J:4b"W<br>S"4d"W t t"4g"r w"4iGlIGlK=G|JG|J:4kHl@Ht@=HdDHtCHdPH|P:HdDHdD=It<br>BIlDJTEJDFIdNI\N:8N"w"4lID@IL@=HlIH|FHlPH|NHt^H|^:H|MH|N=J\D<br>J\GK\OKTOKDXJtXItZI|YIlWI|V:8^4mHLGH\G=HLVH\V:4n" u t t<br>"4p"W"IT@I\@=HdHHtGIDKILIJLGJLG:JK?JK?=JDGJLGI|MJDL:8M4<br>rHt@H|@=HtDH|BJdLJTH:ITEI\E=ILPILNNtCNlB:8N4t"W t"4u"<br>p"4zI[?Il@=HlHH|HIDLILIJDII|HKDAJ|A:JtCJtC=JdLJtJL<br>THLdFNk|Nc|<br>:8K"; main (<br>int C,char**        A) {for(x=A[1],i=calloc(strlen(x)+2,163840);<br>C-1;C&lt;3?Q=_=       0,(z[1]=*x++)?((*x++==104?z[1]^=32:--x), X =<br>strstr(Z,z))      &amp;&amp;(X+=C++):(printf("P2 %d 320 4 ",V=b/2+32),<br>V*=2,s=Q=0,C     =4):C&lt;4?Q--&gt;0?i[(int)((l+=o)+b)][(int)(k+=B)<br>]=1:_?_-=.5/    256,o=(v(2)-(l=v(0)))/(Q=16),B=(v(3)-(k=v(1)<br>))/Q:*X&gt;60?y   ,q(L[4],L[5])q(L[6],L[7])*X-61||(++X,y,y,y),<br>Y:*X&gt;57?++X,  y,Y:*X &gt;54?++X,b+=*X++%64*4:--C:pri<br>
ntf("%d "<br>,i[Q][s]+i[Q ][s+1]+i[Q+1][s]+i[Q+1][s+1])&amp;&amp;(Q+=2)&lt;V||(Q=<br>0,s+=2)&lt;640<br>||(C=1));}</code></p>
<p>编译后在dos下输入abs &gt; ioccc_ray.ppm，生成一个图片（等得可能有点久）</p>
<p><code>X=1024; Y=768; A=3;<br>J=0;K=-10;L=-7;M=1296;N=36;O=255;P=9;_=1&lt;&lt;15;E;S;C;D;F(b){E="1""111886:6:??AAF"<br>"FHHMMOO55557799@@&gt;&gt;&gt;BBBGGIIKK"[b]-64;C="C@=::C@@==@=:C@=:C@=:C5""31/513/5131/"<br>"31/531/53"[b ]-64;S=b&lt;22?9:0;D=2;}I(x,Y,X){Y?(X^=Y,X*X&gt;x?(X^=Y):0,  I (x,Y/2,X<br>)):(E=X);      }H(x){I(x,    _,0);}p;q(        c,x,y,z,k,l,m,a,          b){F(c<br>);x-=E*M     ;y-=S*M           ;z-=C*M         ;b=x*       x/M+         y*y/M+z<br>*z/M-D*D    *M;a=-x              *k/M     -y*l/M-z        *m/M;    p=((b=a*a/M-<br>b)&gt;=0?(I    (b*M,_      ,0),b    =E,      a+(a&gt;b      ?-b:b)):     -1.0);}Z;W;o<br>(c,x,y,     z,k,l,    m,a){Z=!    c?      -1:Z;c     &lt;44?(q(c,x         ,y,z,k,<br>l,m,0,0     ),(p&gt;      0&amp;&amp;c!=     a&amp;&amp;        (p&lt;W         ||Z&lt;0)          )?(W=<br>p,Z=c):     0,o(c+         1,    x,y,z,        k,l,          m,a)):0     ;}Q;T;<br>U;u;v;w    ;n(e,f,g,            h,i,j,d,a,    b,V){o(0      ,e,f,g,h,i,j,a);d&gt;0<br>&amp;&amp;Z&gt;=0? (e+=h*W/M,f+=i*W/M,g+=j*W/M,F(Z),u=e-E*M,v=f-S*M,w=g-C*M,b=(-2*u-2*v+w)<br>/3,H(u*u+v*v+w*w),b/=D,b*=b,b*=200,b/=(M*M),V=Z,E!=0?(u=-u*M/E,v=-v*M/E,w=-w*M/<br>E):0,E=(h*u+i*v+j*w)/M,h-=u*E/(M/2),i-=v*E/(M/2),j-=w*E/(M/2),n(e,f,g,h,i,j,d-1<br>,Z,0,0),Q/=2,T/=2,       U/=2,V=V&lt;22?7:  (V&lt;30?1:(V&lt;38?2:(V&lt;44?4:(V==44?6:3))))<br>,Q+=V&amp;1?b:0,T                +=V&amp;2?b        :0,U+=V    &amp;4?b:0)     :(d==P?(g+=2<br>,j=g&gt;0?g/8:g/     20):0,j    &gt;0?(U=     j    *j/M,Q      =255-    250*U/M,T=255<br>-150*U/M,U=255    -100    *U/M):(U    =j*j     /M,U&lt;M           /5?(Q=255-210*U<br>/M,T=255-435*U           /M,U=255    -720*      U/M):(U       -=M/5,Q=213-110*U<br>/M,T=168-113*U    /       M,U=111               -85*U/M)      ),d!=P?(Q/=2,T/=2<br>,U/=2):0);Q=Q&lt;    0?0:      Q&gt;O?     O:          Q;T=T&lt;0?    0:T&gt;O?O:T;U=U&lt;0?0:<br>U&gt;O?O:U;}R;G;B    ;t(x,y     ,a,    b){n(M*J+M    *40*(A*x   +a)/X/A-M*20,M*K,M<br>*L-M*30*(A*y+b)/Y/A+M*15,0,M,0,P,  -1,0,0);R+=Q    ;G+=T;B   +=U;++a&lt;A?t(x,y,a,<br>b):(++b&lt;A?t(x,y,0,b):0);}r(x,y){R=G=B=0;t(x,y,0,0);x&lt;X?(printf("%c%c%c",R/A/A,G<br>/A/A,B/A/A),r(x+1,y)):0;}s(y){r(0,--y?s(y),y:y);}main(){printf("P6n%i %in255"<br>"n",X,Y);s(Y);}</code></p>
<p>编译后输入abc 0 0 1可以画出x^2的函数图像，输入abc -1 0 0 1可以画出x^3-1的图像。你也可以试试其它的。</p>
<p><code>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;math.h&gt;<br>#define _   ;double<br>#define void   x,x<br>#define case(break,default) break[O]:default[O]:<br>#define switch(bool)   ;for(;x&lt;bool;<br>#define do(if,else)  inIine(else)&gt;int##if?<br>#define true   (--void++)<br>#define false   (++void--)<br>char*O=" &lt;60&gt;!?\n"_ doubIe[010]_ int0,int1 _ Iong=0 _ inIine(int eIse){int<br>O1O=!O _ l=!O;for(;O1O&lt;010;++O1O)l+=(O1O[doubIe]*pow(eIse,O1O));return l;}int<br>main(int booI,char*eIse[]){int I=1,x=-*O;if(eIse){for(;I&lt;010+1;I++)I[doubIe-1]<br>=booI&gt;I?atof(I[eIse]):!O switch(*O)x++)abs(inIine(x))&gt;Iong&amp;&amp;(Iong=abs(inIine(x<br>)));int1=Iong;main(-*O&gt;&gt;1,0);}else{if(booI&lt;*O&gt;&gt;1){int0=int1;int1=int0-2*Iong/0<br>[O]switch(5[O]))putchar(x-*O?(int0&gt;=inIine(x)&amp;&amp;do(1,x)do(0,true)do(0,false)<br>case(2,1)do(1,true)do(0,false)6[O]case(-3,6)do(0,false)6[O]-3[O]:do(1,false)<br>case(5,4)x?booI?0:6[O]:7[O])+*O:8[O]),x++;main(++booI,0);}}}</code></p>
<p>高精度开方。这个有点意思，已经发到OIBH上了。<br>输入abc 01524157875019052100试试。<br>你输入的数字需要有偶数位，否则自行添加前导0补足。</p>
<p><code>#include &lt;stdio.h&gt;<br>int l;int main(int o,char **O,<br>int I){char c,*D=O[1];if(o&gt;0){<br>for(l=0;D[l              ];D[l<br>++]-=10){D   [l++]-=120;D[l]-=<br>110;while   (!main(0,O,l))D[l]<br>+=   20;   putchar((D[l]+1032)<br>/20   )   ;}putchar(10);}else{<br>c=o+     (D[I]+82)%10-(I&gt;l/2)*<br>(D[I-l+I]+72)/10-9;D[I]+=I&lt;0?0<br>:!(o=main(c/10,O,I-1))*((c+999<br>)%10-(D[I]+92)%10);}return o;}</code></p>
<p>画一个月亮</p>
<p><code>#include &lt;stdio.h&gt;<br>#include &lt;math.h&gt;<br>double l;main(_,o,O){return putchar((_--+22&amp;&amp;_+44&amp;&amp;main(_,-43,_),_&amp;&amp;o)?(main(-43,++o,O),((l=(o+21)/sqrt(3-O*22-O*O),l*l&lt;4&amp;&amp;(fabs(((time(0)-607728)%2551443)/405859.-4.7+acos(l/2))&lt;1.57))[" #"])):10);}</code></p>
<p>类似于hangman的猜单词游戏</p>
<p><code>#ifndef int<br>#ifdef while<br>char s[234],d[56],*p=s,m='m';<br>#define int typedef (*define)();<br> define O [6]={getc,putchar,(y)memmove,(y)printf,(y)n,(y)l};<br>#include __FILE__<br>signed short n(short bz){<br> short pb=0,Md=1,ih=2,sfp=3,sjs=4,fo,u=5,scp=6,t,gq=7,oh,r=8,pcf=9,rs=10;<br> char o=1,i=1,l,pc=i,b=r+o/2,_f=6,m=7,s=8,g,q,od=o*rs+4^s,js=_f/*3-m*'c',bs='g';<br>return 1; }<br>#y FILE c[a]+s,p[c],r[m]+u[i+4*o|f]-r[wob][wad]+s*f-!w|o,L+x     |  cut<br>;}int main(i,love_unix){*/;}int main(i,love_unix){/*;}int main(i,love_unix){*;}|  here */<br>while(FILE)for(;9-(i=0[O](f)););<br>for(;32-(i=0[O](f));0&amp;&amp; 3[O]("--&gt;%s&lt;--", "gxdgbtgxsxpcctvpixktedhiedcte"));<br>for(;'n<br>
'-(i=O[0](f));)(i&gt;='a'&amp;&amp;i&lt;'z')?*<br>#include __FILE__<br>                                  "Demonic Smiley" );}  /* &lt;g&gt; */<br>#else<br>#define while(int) short c=0;int*f=fopen(__##int##__,"r");for(i=0;i&lt;25;i _)i[d]='A'+(13+i)%26;main:<br>#define y define<br>#define _ ++<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;time.h&gt;<br>#include __FILE__<br>#endif<br>#elif defined(signed)<br>(p _)=(i-'a')[d]:!(i-'z')?*(p _)=32:(i&gt;='A'&amp;&amp;i&lt;='Z')&amp;&amp;((3&amp;8|2)[O](d+1,d,24L),*(p _)=0[d]=i);/*<br>#y FILE t,ra|js+t*gj,at[qdd]-=K,is _,qv _,veb _,ti _,ao[mqht] _*/<br>if(c _&lt;6) goto main; 5[O](<br>#else<br>#define signed short l(){char q='_';p=s+4*(time(NULL)%24)*2,m=(char)p+1;<br>*(p+8)=0; for(d[3]=10,d[33]=3[d]-10;d[3]&lt;18;3[d] _) d[3][p]=q;3[d][p]=0;<br>hell:  printf("t[%s]n",p+10);if(!m) goto stoned;<br>froze: d[8]=(scanf("%c",&amp;(2[d+__STDC__])),2[d+!NULL])&amp;223;if(!(3[d+5]-'n')) goto froze;<br>for(m=1[d]=0;d[1]&lt;8;2[d-1] _) (p[d[1]]-d[8]||(p[3[d-2]+10]=4[d+4]))+(p[d[1]+10]-q||m _);<br>goto hell;stoned:;}<br>FILE *X(FILE s){ char i,iev,jmqhu,xqht,mqh,ujek,sxydw,kdj,yjb,utou,qhre,eamy,jxxe,bt;}<br>#endif</code></p>
			 ]]></content>
<pubDate>2006-09-29T01:05:40+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/109</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 最长公共上升子序列的另一个O(mn)的算法 ]]></title>
<link>http://www.matrix67.com/blog/archives/112</link>
<content><![CDATA[ 
		<p>    我在这个帖子里说过nlogn求最长上升子序列的方法：<br>    http://www.oibh.org/bbs/viewthread.php?tid=10682<br>    下面引用我自己的发言：</p>
<blockquote><p>     f表示长度为i的上升子序列最后一个数最小是多少。显然数组f是单增的。<br>     读到一个新的数x后，找到某个i使得x&gt;f[i]且x&lt;=f[i+1]，于是用x去更新f[i+1]；特别地，如果所有的f[i]都小于x，则增加f的长度。<br>     最后看f数组有多长就行了。<br>     由于f单增，所以查找i时可以用二分查找，因此时间复杂度为O(nlogn)。<br>     举个例子，假如序列为 3 2 8 6 7 4 5 7 3，则f数组的变化过程如下：<br>     3<br>     2<br>     2 8<br>     2 6<br>     2 6 7<br>     2 4 7<br>     2 4 5<br>     2 4 5 7<br>     2 3 5 7<br>     最后，f的长度达到4，因此答案为4。<br>     注意，最后的f数组不一定是最长上升子序列的一个方案。</p></blockquote>
<p>    这里要说的这个算法利用了nlogn的最长上升子序列(LIS)的技巧：用f[k]表示长度为k的上升子序列最后一个数最小是多少。<br>    在最长公共上升子序列中，令f[i,j][k]表示A串前i个数字，B串前j个数字，长度为k的公共上升子序列中，最后一个数最小是多少。</p>
<p>    当A[i]=B[j]时，像nlogn的最长上升子序列一样把A[i]插入到f[i-1,j]中，这需要线性的时间扫一遍f[i,j]；<br>    当A[i]&lt;&gt;B[j]时，我们需要合并f[i-1,j]和f[i,j-1]，使得对于每个k满足f[i,j][k]:=min{ f[i-1,j][k],f[i,j-1][k] }。这需要线性的时间扫一边f[i-1,j]和f[i,j-1]并取k相同时的较小值。<br>    最后输出f[n,m]的长度（使f[n,m][k]有意义的最大的k）。<br>    这样的复杂度是三方的，我们需要优化。</p>
<p>    考虑A[i]=B[j]的情况。当i固定时，随着j的增加，插入的位置一定也在后移，因为同样是插入的A[i]，但j的增加（B串长度的增加）使得f [i,j]更优，因此可以更新的值就更靠后。于是，对于每个i，我们可以按照k的顺序扫描f[i-1,j][k] 并在A[i]可以插入f[i-1][j]的k位置时增加j，从而预处理所有A[i]=B[j]时A[i]应该插入的位置。<br>    再考虑A[i]&lt;&gt;B[j]的情况。从定义看，f[i-1,j-1]和f[i-1,j]只有一个地方不一样，因为多一个数最多只能造成一个k 的值变小；同样地，f[i-1,j-1]和f[i,j-1]也只有一个地方不一样。因此，f[i-1,j]和f[i,j-1]最多只有两个k所对应的值不相同，且当有两个不同的值时，总是f[i-1,j]中的某个值较小，f[i,j-1]中的某个值较小。这给我们优化的余地。在每次处理完f[i,j]时，我们可以记录一个值x[i,j]表示f[i,j][k]与f[i-1,j][k]中值不一样的k是多少，在A[i]=B[j]时直接赋值为插入的位置，在 A[i]&lt;&gt;B[j]时待后文说明。以后合并时，先让f[i,j]:=f[i-1,j]（由于此时的f[i-1,j]已经没有别的用处了，因此可以用滚动数组记录，直接令f[i-1,j]是f[i,j]，避免实际的赋值操作），然后将新的f[i,j]中的，使f[i,j-1][k]比f[i- 1, j][k]小的k所对应值更新。这个k是多少呢？显然应该是x[i,j-1]。这样的操作同时可以确定x[i,j]=x[i,j-1]。<br>    这样，复杂度就达到了平方。</p>
<p>    附参考的资料（原来从这篇论文里学到的，不知道有没有此类的中文资料，估计没有才在这里写了一个，感兴趣的话可以下载附件仔细研究）</p>
<p><a href="http://www.matrix67.com/data/2005_IPL_LCIS.pdf" target="_blank">点击下载此文件</a> </p>
<p>Matrix67原创<br>转载请注明出处</p>
			 ]]></content>
<pubDate>2006-10-18T15:36:11+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/112</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ KMP算法详解 ]]></title>
<link>http://www.matrix67.com/blog/archives/115</link>
<content><![CDATA[ 
		<p>    如果机房马上要关门了，或者你急着要和MM约会，请直接跳到第六个自然段。</p>
<p>    我们这里说的KMP不是拿来放电影的（虽然我很喜欢这个软件），而是一种算法。KMP算法是拿来处理字符串匹配的。换句话说，给你两个字符串，你需要回答，B串是否是A串的子串（A串是否包含B串）。比如，字符串A="I'm matrix67"，字符串B="matrix"，我们就说B是A的子串。你可以委婉地问你的MM：“假如你要向你喜欢的人表白的话，我的名字是你的告白语中的子串吗？”<br>    解决这类问题，通常我们的方法是枚举从A串的什么位置起开始与B匹配，然后验证是否匹配。假如A串长度为n，B串长度为m，那么这种方法的复杂度是O (mn)的。虽然很多时候复杂度达不到mn（验证时只看头一两个字母就发现不匹配了），但我们有许多“最坏情况”，比如，A= "aaaaaaaaaaaaaaaaaaaaaaaaaab"，B="aaaaaaaab"。我们将介绍的是一种最坏情况下O(n)的算法（这里假设 m&lt;=n），即传说中的KMP算法。<br>    之所以叫做KMP，是因为这个算法是由Knuth、Morris、Pratt三个提出来的，取了这三个人的名字的头一个字母。这时，或许你突然明白了AVL 树为什么叫AVL，或者Bellman-Ford为什么中间是一杠不是一个点。有时一个东西有七八个人研究过，那怎么命名呢？通常这个东西干脆就不用人名字命名了，免得发生争议，比如“3x+1问题”。扯远了。<br>    个人认为KMP是最没有必要讲的东西，因为这个东西网上能找到很多资料。但网上的讲法基本上都涉及到“移动(shift)”、“Next函数”等概念，这非常容易产生误解（至少一年半前我看这些资料学习KMP时就没搞清楚）。在这里，我换一种方法来解释KMP算法。</p>
<p>    假如，A="abababaababacb"，B="ababacb"，我们来看看KMP是怎么工作的。我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前 j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]&lt;&gt;B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。</p>
<p><span style="font-family:宋体">    i = 1 2 3 4 <span style="color:#ff0000">5</span> 6 7 8 9 ……<br>    A = a b a b <span style="color:#ff0000">a</span> b a a b a b …<br>    B = a b a b <span style="color:#ff0000">a</span> c b<br>    j = 1 2 3 4 <span style="color:#ff0000">5</span> 6 7</span></p>
<p>    此时，A[6]&lt;&gt;B[6]。这表明，此时j不能等于5了，我们要把j改成比它小的值j'。j'可能是多少呢？仔细想一下，我们发现，j'必须要使得B[1..j]中的头j'个字母和末j'个字母完全相等（这样j变成了j'后才能继续保持i和j的性质）。这个j'当然要越大越好。在这里，B [1..5]="ababa"，头3个字母和末3个字母都是"aba"。而当新的j为3时，A[6]恰好和B[4]相等。于是，i变成了6，而j则变成了 4：</p>
<p><span style="font-family:宋体">    i = 1 2 3 4 5 <span style="color:#ff0000">6</span> 7 8 9 ……<br>    A = a b a b a <span style="color:#ff0000">b</span> a a b a b …<br>    B =     a b a <span style="color:#ff0000">b</span> a c b<br>    j =     1 2 3 <span style="color:#ff0000">4</span> 5 6 7</span></p>
<p>    从上面的这个例子，我们可以看到，新的j可以取多少与i无关，只与B串有关。我们完全可以预处理出这样一个数组P[j]，表示当匹配到B数组的第j个字母而第j+1个字母不能匹配了时，新的j最大是多少。P[j]应该是所有满足B[1..P[j]]=B[j-P[j]+1..j]的最大值。<br>    再后来，A[7]=B[5]，i和j又各增加1。这时，又出现了A[i+1]&lt;&gt;B[j+1]的情况：</p>
<p><span style="font-family:宋体">    i = 1 2 3 4 5 6 <span style="color:#ff0000">7</span> 8 9 ……<br>    A = a b a b a b <span style="color:#ff0000">a</span> a b a b …<br>    B =     a b a b <span style="color:#ff0000">a</span> c b<br>    j =     1 2 3 4 <span style="color:#ff0000">5</span> 6 7</span></p>
<p>    由于P[5]=3，因此新的j=3：</p>
<p><span style="font-family:宋体">    i = 1 2 3 4 5 6 <span style="color:#ff0000">7</span> 8 9 ……<br>    A = a b a b a b <span style="color:#ff0000">a</span> a b a b …<br>    B =         a b <span style="color:#ff0000">a</span> b a c b<br>    j =         1 2 <span style="color:#ff0000">3</span> 4 5 6 7</span></p>
<p>    这时，新的j=3仍然不能满足A[i+1]=B[j+1]，此时我们再次减小j值，将j再次更新为P[3]：</p>
<p><span style="font-family:宋体">    i = 1 2 3 4 5 6 <span style="color:#ff0000">7</span> 8 9 ……<br>    A = a b a b a b <span style="color:#ff0000">a</span> a b a b …<br>    B =             <span style="color:#ff0000">a</span> b a b a c b<br>    j =             <span style="color:#ff0000">1</span> 2 3 4 5 6 7</span></p>
<p>    现在，i还是7，j已经变成1了。而此时A[8]居然仍然不等于B[j+1]。这样，j必须减小到P[1]，即0：</p>
<p><span style="font-family:宋体">    i = 1 2 3 4 5 6 <span style="color:#ff0000">7</span> 8 9 ……<br>    A = a b a b a b <span style="color:#ff0000">a</span> a b a b …<br>    B =               a b a b a c b<br>    j =             <span style="color:#ff0000">0</span> 1 2 3 4 5 6 7</span></p>
<p>    终于，A[8]=B[1]，i变为8，j为1。事实上，有可能j到了0仍然不能满足A[i+1]=B[j+1]（比如A[8]="d"时）。因此，准确的说法是，当j=0了时，我们增加i值但忽略j直到出现A[i]=B[1]为止。<br>    这个过程的代码很短（真的很短），我们在这里给出：</p>
<p><code>j:=0;<br>for i:=1 to n do<br>begin<br>   while (j&gt;0) and (B[j+1]&lt;&gt;A[i]) do j:=P[j];<br>   if B[j+1]=A[i] then j:=j+1;<br>   if j=m then<br>   begin<br>      writeln('Pattern occurs with shift ',i-m);<br>      j:=P[j];<br>   end;<br>end;</code></p>
<p>    最后的j:=P[j]是为了让程序继续做下去，因为我们有可能找到多处匹配。<br>    这个程序或许比想像中的要简单，因为对于i值的不断增加，代码用的是for循环<br>
。因此，这个代码可以这样形象地理解：扫描字符串A，并更新可以匹配到B的什么位置。</p>
<p>    现在，我们还遗留了两个重要的问题：一，为什么这个程序是线性的；二，如何快速预处理P数组。<br>    为什么这个程序是O(n)的？其实，主要的争议在于，while循环使得执行次数出现了不确定因素。我们将用到时间复杂度的摊还分析中的主要策略，简单地说就是通过观察某一个变量或函数值的变化来对零散的、杂乱的、不规则的执行次数进行累计。KMP的时间复杂度分析可谓摊还分析的典型。我们从上述程序的j 值入手。每一次执行while循环都会使j减小（但不能减成负的），而另外的改变j值的地方只有第五行。每次执行了这一行，j都只能加1；因此，整个过程中j最多加了n个1。于是，j最多只有n次减小的机会（j值减小的次数当然不能超过n，因为j永远是非负整数）。这告诉我们，while循环总共最多执行了n次。按照摊还分析的说法，平摊到每次for循环中后，一次for循环的复杂度为O(1)。整个过程显然是O(n)的。这样的分析对于后面P数组预处理的过程同样有效，同样可以得到预处理过程的复杂度为O(m)。<br>    预处理不需要按照P的定义写成O(m^2)甚至O(m^3)的。我们可以通过P[1],P[2],…,P[j-1]的值来获得P[j]的值。对于刚才的B="ababacb"，假如我们已经求出了P[1],P[2],P[3]和P[4]，看看我们应该怎么求出P[5]和P[6]。P[4]=2，那么P [5]显然等于P[4]+1，因为由P[4]可以知道，B[1,2]已经和B[3,4]相等了，现在又有B[3]=B[5]，所以P[5]可以由P[4] 后面加一个字符得到。P[6]也等于P[5]+1吗？显然不是，因为B[ P[5]+1 ]&lt;&gt;B[6]。那么，我们要考虑“退一步”了。我们考虑P[6]是否有可能由P[5]的情况所包含的子串得到，即是否P[6]=P[ P[5] ]+1。这里想不通的话可以仔细看一下：</p>
<p><span style="font-family:宋体">        1 2 3 4 5 6 7<br>    B = a b a b a c b<br>    P = 0 0 1 2 3 ?</span></p>
<p>    P[5]=3是因为B[1..3]和B[3..5]都是"aba"；而P[3]=1则告诉我们，B[1]、B[3]和B[5]都是"a"。既然P[6]不能由P[5]得到，或许可以由P[3]得到（如果B[2]恰好和B[6]相等的话，P[6]就等于P[3]+1了）。显然，P[6]也不能通过P[3]得到，因为B[2]&lt;&gt;B[6]。事实上，这样一直推到P[1]也不行，最后，我们得到，P[6]=0。<br>    怎么这个预处理过程跟前面的KMP主程序这么像呢？其实，KMP的预处理本身就是一个B串“自我匹配”的过程。它的代码和上面的代码神似：</p>
<p><code>P[1]:=0;<br>j:=0;<br>for i:=2 to m do<br>begin<br>   while (j&gt;0) and (B[j+1]&lt;&gt;B[i]) do j:=P[j];<br>   if B[j+1]=B[i] then j:=j+1;<br>   P[i]:=j;<br>end;</code></p>
<p>    最后补充一点：由于KMP算法只预处理B串，因此这种算法很适合这样的问题：给定一个B串和一群不同的A串，问B是哪些A串的子串。</p>
<p>    串匹配是一个很有研究价值的问题。事实上，我们还有后缀树，自动机等很多方法，这些算法都巧妙地运用了预处理，从而可以在线性的时间里解决字符串的匹配。我们以后来说。</p>
<p>    昨天发现一个特别晕的事，知道怎么去掉BitComet的广告吗？把界面语言设成英文就行了。<br>    还有，金山词霸和Dr.eye都可以去自杀了，Babylon素王道。</p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2006-11-29T20:02:37+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/115</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 二分图最大匹配的König定理及其证明 ]]></title>
<link>http://www.matrix67.com/blog/archives/116</link>
<content><![CDATA[ 
		<p>    如果你看不清楚第二个字母，下面有一个大号字体版本：</p>
<p><span style="font-size:18pt">二分图最大匹配的König定理及其证明</span></p>
<p>    本文将是这一系列里最短的一篇，因为我只打算把König定理证了，其它的废话一概没有。<br>    以下五个问题我可能会在以后的文章里说，如果你现在很想知道的话，网上去找找答案：<br>    1. 什么是二分图；<br>    2. 什么是二分图的匹配；<br>    3. 什么是匈牙利算法；(http://www.matrix67.com/blog/article.asp?id=41)<br>    4. König定理证到了有什么用；<br>    5. 为什么o上面有两个点。</p>
<p>    König定理是一个二分图中很重要的定理，它的意思是，一个二分图中的最大匹配数等于这个图中的最小点覆盖数。如果你还不知道什么是最小点覆盖，我也在这里说一下：假如选了一个点就相当于覆盖了以它为端点的所有边，你需要选择最少的点来覆盖所有的边。比如，下面这个图中的最大匹配和最小点覆盖已分别用蓝色和红色标注。它们都等于3。这个定理相信大多数人都知道，但是网络上给出的证明并不多见。有一些网上常见的“证明”明显是错误的。因此，我在这里写一下这个定理的证明，希望对大家有所帮助。</p>
<p><img alt="image placeholder" >
<p>    假如我们已经通过匈牙利算法求出了最大匹配（假设它等于M），下面给出的方法可以告诉我们，选哪M个点可以覆盖所有的边。<br>    匈牙利算法需要我们从右边的某个没有匹配的点，走出一条使得“一条没被匹配、一条已经匹配过，再下一条又没匹配这样交替地出现”的路（交错轨，增广路）。但是，现在我们已经找到了最大匹配，已经不存在这样的路了。换句话说，我们能寻找到很多可能的增广路，但最后都以找不到“终点是还没有匹配过的点”而失败。我们给所有这样的点打上记号：从右边的所有没有匹配过的点出发，按照增广路的“交替出现”的要求可以走到的所有点（最后走出的路径是很多条不完整的增广路）。那么这些点组成了最小覆盖点集：右边所有没有打上记号的点，加上左边已经有记号的点。看图，右图中展示了两条这样的路径，标记了一共6个点（用 “√”表示）。那么，用红色圈起来的三个点就是我们的最小覆盖点集。<br>    首先，为什么这样得到的点集点的个数恰好有M个呢？答案很简单，因为每个点都是某个匹配边的其中一个端点。如果右边的哪个点是没有匹配过的，那么它早就当成起点被标记了；如果左边的哪个点是没有匹配过的，那就走不到它那里去（否则就找到了一条完整的增广路）。而一个匹配边又不可能左端点是标记了的，同时右端点是没标记的（不然的话右边的点就可以经过这条边到达了）。因此，最后我们圈起来的点与匹配边一一对应。<br>    其次，为什么这样得到的点集可以覆盖所有的边呢？答案同样简单。不可能存在某一条边，它的左端点是没有标记的，而右端点是有标记的。原因如下：如果这条边不属于我们的匹配边，那么左端点就可以通过这条边到达（从而得到标记）；如果这条边属于我们的匹配边，那么右端点不可能是一条路径的起点，于是它的标记只能是从这条边的左端点过来的（想想匹配的定义），左端点就应该有标记。<br>    最后，为什么这是最小的点覆盖集呢？这当然是最小的，不可能有比M还小的点覆盖集了，因为要覆盖这M条匹配边至少就需要M个点（再次回到匹配的定义）。<br>    证完了。<br>  <br>Matrix67原创<br>做人要厚到 转贴请注明出处</p>
			 ]]></content>
<pubDate>2006-12-02T21:00:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/116</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 什么是生成函数？ ]]></title>
<link>http://www.matrix67.com/blog/archives/120</link>
<content><![CDATA[ 
		<p>    我们年级有许多漂亮的MM。一班有7个左右吧，二班大概有4个，三班最多，16个，四班最可怜，一个漂亮的MM都没有，五班据说有1个。如果用一个函数“f(班级)=漂亮MM的个数”，那么我们可以把上述信息表示成：f(1)=7,f(2)=4,f(3)=16,f(4)=0,f(5)=1,等等。<br>    生成函数（也有叫做“母函数”的，但是我觉得母函数不太好听）是说，构造这么一个多项式函数g(x)，使得x的n次方系数为f(n)。于是，上面的f函数的生成函数g(x)=7x+4x^2+16x^3+x^5+…。这就是传说中的生成函数了。关键是，这个有什么用呢？一会儿要慢慢说。我敢打赌这绝对会是我写过的最长的一篇文章。</p>
<p>    生成函数最绝妙的是，某些生成函数可以化简为一个很简单的函数。也就是说，不一定每个生成函数都是用一长串多项式来表示的。比如，这个函数f(n)=1 （n当然是属于自然数的），它的生成函数就应该是g(x)=1+x+x^2+x^3+x^4+…（每一项都是一，即使n=0时也有x^0系数为1，所以有常数项）。再仔细一看，这就是一个有无穷多项的等比数列求和嘛。如果-1&lt;x&lt;1，那么g(x)就等于1/(1-x)了。在研究生成函数时，我们都假设级数收敛，因为生成函数的x没有实际意义，我们可以任意取值。于是，我们就说，f(n)=1的生成函数是g(x)=1/(1-x)。</p>
<p>    我们举一个例子说明，一些具有实际意义的组合问题也可以用像这样简单的一个函数全部表示出来。<br>    考虑这个问题：从二班选n个MM出来有多少种选法。学过简单的排列与组合的同学都知道，答案就是C(4,n)。也就是说。从n=0开始，问题的答案分别是1,4,6,4,1,0,0,0,…（从4个MM中选出4个以上的人来方案数当然为0喽）。那么它的生成函数g(x)就应该是g(x)=1+4x+6x^2+4x^3+x^4。这不就是……二项式展开吗？于是，g(x)=(1+x)^4。<br>    你或许应该知道，(1+x)^k=C(k,0)x^0+C(k,1)x^1+…+C(k,k)x^k；但你或许不知道，即使k为负数和小数的时候，也有类似的结论：(1+x)^k=C(k,0)x^0+C(k,1)x^1+…+C(k,k)x^k+C(k,k+1)x^(k+1)+C(k,k+2)x^(k+2)+…（一直加到无穷；式子看着很别扭，自己写到草稿纸上吧，毕竟这里输入数学式子很麻烦）。其中，广义的组合数C(k,i)就等于k(k-1)(k-2)…(k-i+1)/i!，比如C(4,6)=4*3*2*1*0*(-1)/6!=0，再比如C(-1.4,2)=(-1.4)*(-2.4)/2!=1.68。后面这个就叫做牛顿二项式定理。当k为整数时，所有i&gt;k时的C(k,i)中分子都要“越过”0这一项，因此后面C(k,k+1),C(k,k+2)之类的都为0了，与我们的经典二项式定理结论相同；不同的是，牛顿二项式定理中的指数k可以是任意实数。</p>
<p>    我们再举一个例子说明一些更复杂的生成函数。n=x1+x2+x3+…+xk有多少个非负整数解？这道题是学排列与组合的经典例题了。把每组解的每个数都加1，就变成n+k=x1+x2+x3+…+xk的正整数解的个数了。教材上或许会出现这么一个难听的名字叫“隔板法”：把n+k个东西排成一排，在n+k-1个空格中插入k-1个“隔板”。答案我们总是知道的，就是C(n+k-1,k-1)。它就等于C(n+k-1,n)。它关于n的生成函数是g(x)=1/(1-x)^k。这个生成函数是怎么来的呢？其实，它就是(1-x)的-k次方。把(1-x)^(-k)按照刚才的牛顿二项式展开，我们就得到了x^n的系数恰好是C(n+k-1,n)，因为C(-k,n)*(-x)^n=[(-1)^n*C(n+k-1,n)]*[(-1)^n*x^n]=C(n+k-1,n)x^n。这里看晕了不要紧，后文有另一种方法可以推导出一模一样的公式。事实上，我们有一个纯组合数学的更简单的解释方法。因为我们刚才的几何级数1+x+x^2+x^3+x^4+…=1/(1-x)，那么(1+x+x^2+x^3+x^4+…)^k就等于1/(1-x)^k。仔细想想k个(1+x+x^2+x^3+x^4+…)相乘是什么意思。(1+x+x^2+x^3+x^4+…)^k的展开式中，n次项的系数就是我们的答案，因为它的这个系数是由原式完全展开后k个指数加起来恰好等于n的项合并起来得到的。</p>
<p>    现在我们引用《组合数学》上暴经典的一个例题。很多书上都会有这类题。<br>    我们要从苹果、香蕉、橘子和梨中拿一些水果出来，要求苹果只能拿偶数个，香蕉的个数要是5的倍数，橘子最多拿4个，梨要么不拿，要么只能拿一个。问按这样的要求拿n个水果的方案数。<br>    结合刚才的k个(1+x+x^2+x^3+x^4+…)相乘，我们也可以算出这个问题的生成函数。<br>
</p>
<blockquote><span style="font-family:宋体">g(x)=(1+x^2+x^4+…)(1+x^5+x^10+..)(1+x+x^2+x^3+x^4)(1+x)<br>    =[1/(1-x^2)]*[1/(1-x^5)]*[(1-x^5)/(1-x)]*(1+x) （前两个分别是公比为2和5的几何级数，<br>                                                     第三个嘛，(1+x+x^2+x^3+x^4)*(1-x)不就是1-x^5了吗）<br>    =1/(1-x)^2   （约分，把一大半都约掉了）<br>    =(1-x)^(-2)=C(1,0)+C(2,1)x+C(3,2)x^2+C(4,3)x^3…   （参见刚才对1/(1-x)^k的展开）<br>    =1+2x+3x^2+4x^3+5x^4+….</span></blockquote>
<p>    于是，拿n个水果有n+1种方法。我们利用生成函数，完全使用代数手段得到了答案！<br>    如果你对1/(1-x)^k的展开还不熟悉，我们这里再介绍一个更加简单和精妙的手段来解释1/(1-x)^2=1+2x+3x^2+4x^3+5x^4+….。<br>    1/(1-x)=1+x+x^2+x^3+x^4+…是前面说过的。我们对这个式子等号两边同时求导数。于是，1/(1-x)^2=1+2x+3x^2+4x^3+5x^4+….。一步就得到了我们所需要的东西！不断地再求导数，我们同样可以得到刚才用复杂的牛顿二项式定理得到的那个结论（自己试试吧）。生成函数还有很多其它的处理手段，比如等式两边同时乘以、除以常数（相当于等式右边每一项乘以、除以常数），等式两边同时乘以、除以一个x（相当于等式右边的系数“移一位”），以及求微分积分等。神奇的生成函数啊。<br>    我们用两种方法得到了这样一个公式：1/(1-x)^n=1+C(n,1)x^1+C(n+1,2)x^2+C(n+2,3)x^3+…+C(n+k-1,k)x^k+…。这个公式非常有用，是把一个生成函数还原为数列的武器。而且还是核武器。</p>
<p>    接下来我们要演示如何使用生成函数求出Fibonacci数列的通项公式。<br>    Fibonacci数列是这样一个递推数列：f(n)=f(n-1)+f(n-2)。现在我们需要求出它的生成函数g(x)。g(x)应该是一个这样的函数：<br>    g(x)=x+x^2+2x^3+3x^4+5x^5+8x^6+13x^7+…<br>    等式两边同时乘以x，我们得到：<br>    x*g(x)=x^2+x^3+2x^4+3x^5+5x^6+8x^7+…<br>    就像我们前面说过的一样，这相当于等式右边的所有系数向右移动了一位。<br>    现在我们把前面的式子和后面的式子相加，我们得到：<br>    g(x)+x*g(x)=x+2x^2+3x^3+5x^4+8x^5+…<br>    把这最后一个式子和第一个式子好好对比一下。如果第一个式子的系数往左边移动一位，然后把多余的“1”去掉，就变成了最后一个式子了。由于递推函数的性质，我们神奇地得到了：g(x)+x*g(x)=g(x)/x-1。也就是说，g(x)*x^2+g(x)*x-g(x)=-x。把左边的g(x)提出来，我们有：g(x)(x^2+x-1)=-x。于是，我们得</p>
			 ]]></content>
<pubDate>2006-12-23T03:49:33+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/120</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 位运算讲解系列文章（目录） ]]></title>
<link>http://www.matrix67.com/blog/archives/122</link>
<content><![CDATA[ 
		<p>你现在所看到的日志已于07年7月重新整理，下面是新的位运算系列文章目录。</p>
<p><a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=311">位运算简介及实用技巧（一）：基础篇</a><br><a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=312">位运算简介及实用技巧（二）：进阶篇(1)</a><br><a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=314">位运算简介及实用技巧（三）：进阶篇(2)</a><br><a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=316">位运算简介及实用技巧（四）：实战篇</a></p>
			 ]]></content>
<pubDate>2006-12-26T23:29:58+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/122</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 关于套套：最近流行的一道智力题 ]]></title>
<link>http://www.matrix67.com/blog/archives/127</link>
<content><![CDATA[ 
		<p>    最近流行这样一道智力题，我觉得比较有意思，在这里写一下：<br>    两个男的两个女的都有性病。现在只有两个套套，问怎么才能让两个男的分别和两个女的搞（就是说总共要搞4次）而不交叉感染。任两个人之间有间接的XX都算要感染。套套可以重复用（就是说可以不射）。</p>
<p>    为了让大家理解题意，这里再说明一下传统的方法为什么是错的。如果让两个男的各套各的套，依次搞两个女的，那么两个女的就要交叉感染，因为同一个套套接触过两个女的。</p>
<p>    答案在下面，白的。</p>
<p><span style="color:#E5E5E5">    让第一个男的同时戴两个套套（这样很爽的:-) ），把第一个女的干了，然后把外面那层套套取出来给第二个男的戴上，让第二个男的也把第一个女的搞了；第一个男的接着（用他里面那个套套）把剩下的那个MM做了，然后把套套取下来给第二个男的套在外面（第二个男的就套了两个套了），让第二个男的操第二个女的。</span></p>
			 ]]></content>
<pubDate>2007-01-05T05:32:17+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/127</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ A Variety of Captcha 各式各样的验证码 ]]></title>
<link>http://www.matrix67.com/blog/archives/129</link>
<content><![CDATA[ 
		<p>    最近OIBH被众多群发机器加入到了被害者列表中，验证码那一关显然已经被搞破了（有漏洞还是识别的？如果是识别的话就有点佩服了）。后来我在网上胡乱搜索了一下关于验证码和验证码识别的对抗，有意思的东西还很多。下面这些有创意的验证码大家见过吗？</p>
<p>Tencent的中文验证码：<br>    <img alt="image placeholder" >
<p>gif动画干扰的验证码：<br>    <img alt="image placeholder" >
<p>“雪花牌电视机”（FireFox下浏览最佳）：<br>    <img alt="image placeholder" >
<p>3D验证码：<br>    <img alt="image placeholder" >
<p>迷宫式验证码：<br>  <img alt="image placeholder" >
<p>极限验证码：<br>  <img alt="image placeholder" >
<p>flash验证码：<br>    http://www.glowchart.com/index.cfm?submit<br>音频验证码（记得MSN注册时就可以选择声音验证）：<br>    http://www.notonebit.com/projects/killbot/kbaudio.php<br>图片分类式的验证码：<br>    http://gs264.sp.cs.cmu.edu/cgi-bin/esp-pix<br>WordPress的Did You Pass Math插件：<br>    http://blogs.herod.net/steven/archives/93（注意下面Leave a Reply的时候需要填写什么）<br>这里也有一个Do the Math脚本：<br>    http://www.hamidof.com/Downloads/PHP_Scripts/Simple_Captcha_Script/<br>问答式验证码（Discuz!插件）：<br>    http://www.bbsplug.com/register.php</p>
<p>Matrix67搜集整理<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-01-10T19:14:23+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/129</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 质数单词表 ]]></title>
<link>http://www.matrix67.com/blog/archives/135</link>
<content><![CDATA[ 
		<p>    我们可以使用36进制将所有的单词转化为数字。比如，(ADD)36 = (10×36^2+13×36+13)10 = (13,441)10。而13441是一个质数，因此我们说ADD是一个质数单词。<br>    下面列出了几乎所有的质数单词。<br><span style="font-family:arial"><span style="font-size:8pt"><br>A</span></span></p>
<p>AAH ABANDON ABDOMEN ABDUCTED ABERRATION ABJURED ABLEST ABLUTION ABOLISH ABOMINATED ABORT ABORTIONIST ABOUNDED ABRIDGED ABRUPT ABSORB ABSTENTION ABSTRACT ABUTTED ACCEPT ACCEPTED ACCESSED ACCIDENT ACCLIMATIZATION ACCOMMODATION ACCREDITED ACID ACORN ACOUSTICIAN ACT ACTED ACUTEST AD ADAMANT ADD ADDUCTION ADJOINED ADMIXED ADORN ADULTHOOD ADVOCATED ADZ AERATED AFFORDED AFORESAID AFTERTHOUGHT AGNIZED AGRONOMIST AHEAD AIRED AIRIEST AIRMEN AKRON ALBEIT ALDERMEN ALEVIN ALLAYED ALLEGATION ALLEGED ALLERTON ALSIP ALVIN AMAH AMAZED AMENDED AMERINDIAN AMOEBOID AMPHIPLOID AN ANAPEST ANEROID ANGERED ANGOLAN ANIMATED ANIMATION ANNISTON ANNUALIZED ANODIZATION ANOINT ANTEED ANTICIPATED ANTITOXIN ANTITRUST AORIST APOGEAN APPALLED APPOSED AQUEDUCT ARCH ARGUMENT ARIGHT AROUND ARRAIGN ARROWHEAD ARTICLED ARYAN ASAP ASSASSIN ASSERT ASSERTED ASSESSED ASSEVERATED ASSN ASSUAGED ASSUMPTION ASTEROID ASTOUND AT ATHIRST ATOP ATT ATTENUATED ATTITUDINIZED ATTRACT ATTRIBUTION ATTRITED AUCTION AUDIENT AUDITED AUTOSUGGESTION AVANT AVIARIST AVIATION AVOCATION AVOIDED AVOUCH AVOWED AWED AWKWARD</p>
<p>B</p>
<p>B BABOONISH BACKDrop BAD BADINAGED BAGGIEST BAH BAIT BALANCED BALLOONIST BAN BANED BANGLADESH BANTERED BARB BARD BAREBACKED BAROGRAPH BARONET BASALT BASEBOARD BASILICAN BASINED BASSOON BATH BATON BATTEMENT BATTEN BATTENED BEACHHEAD BEAMIEST BEATEN BEATIFIED BECKON BECLOUDED BEETLED BEFUDDLEMENT BEGGARED BEGOT BEGUILED BEHOLDEN BEHOOVED BELAYED BELLIGERENT BEMUSEMENT BEN BENEATH BENNINGTON BEQUEATHED BERRIED BERWYN BESEECHED BETAKEN BETH BETTERED BEWITCHMENT BIBBED BIDDEFORD BIFURCATED BIGHEARTED BIKED BILKED BILLET BIPARTITION BIPED BIRTH BISCUIT BISECTION BITCH BITTED BITTEREST BIVOUACKED BLAB BLACKBIRD BLADED BLAH BLAIN BLIND BLINDED BLINDFOLDED BLITHEST BLONDEST BLOODIED BLOODSHOT BLOODSTAIN BLOWOUT BLOWZIEST BLUED BLUEFIELD BLUEPRINT BOB BOLD BOND BONNET BOOBED BOOED BOOKSHOP BOOST BOOT BOOZED BORON BORROWED BORSCHT BOSOMED BOTCH BOUNDED BOUT BOWED BRAGGED BRAN BRASH BRASHEST BRAWN BREAKFAST BREED BRIDLED BRIGHT BROADCASTED BROOD BROODIEST BROOKLYN BROTH BROWN BROWNED BUCKET BUD BUDDHIST BUILDUP BUILT BULKHEAD BULLETIN BULLHEAD BULLISH BULRUSH BUMP BUMPIEST BUN BUNION BURBLED BURIEN BURP BURRED BURT BUSHELED BUSIED BUSSED BUTTERFLIED</p>
<p>C</p>
<p>CAB CABARET CABIN CABINET CACHED CAESAREAN CAJOLEMENT CAKED CALMEST CALUMET CANAAN CANDID CANED CANON CAP CAPPED CARD CARET CARNATION CARP CARROLTON CARTLOAD CASEMENTED CATALOGED CATALOGUED CATALYST CATCHWORD CATECHIST CATECHIZED CATENATION CELLIST CEREBRATION CHAINED CHAMP CHAMPAIGN CHAMPION CHANSON CHAPLET CHATTED CHAUFFEURED CHEAP CHEAPENED CHEAPEST CHEAPIST CHECKED CHEVRON CHEWIEST CHICKWEED CHIFFON CHILD CHILDBIRTH CHINTZ CHIRRUP CHISELLED CHLORINATION CHOP CHOPPIEST CHORTLED CHRONOLOGIST CHUNKIEST CHURCHMANSHIP CHURNED CIRCUITED CIT CLACKED CLAMPED CLAP CLEARED CLEAT CLENCH CLERGYMEN CLINCH CLINGIEST CLOSEMOUTHED CLOTHESPIN CLOUDED CLUMPIEST CLUTCH CLUTCHED COAGULATED COALITION COARSEST COAXED COB COBWEB COBWEBBED COFFEEPOT COGNITION COIL-START COITION COLLATERALIZED COLLIMATED COMB COMMANDANT COMMENCED COMMENT COMMISSION COMMITTEEMEN COMMUNION COMPANION COMPENSATED COMPLAISANT COMPLIMENTED COMPOSITION CONCERNMENT CONCERT CONCESSION CONCOCTED CONCUSSION CONDEMNED CONDITIONED CONDUCT CONED CONFECTION CONFIDANT CONFINED CONFLICTION CONFOUNDED CONFUCIAN CONGEALMENT CONGEST CONGESTED CONGRATULATION CONGREGATED CONJOIN CONJURED CONNED CONSECRATION CONSENT CONSOLIDATED CONSTITUTED CONSUMED CONTEMPLATED CONTEST CONTEXT CONTINUATION CONTRIVED CONVOLVED COOKOUT COON COOPERATED COPENHAGEN COPILOT CORDON CORELATED CORINTHIAN CORNISH CORP CORRELATION COSMONAUT COSTUMED COUGH COULDN'T COUNCILMEN COUNTERFEITED COUNTERMAND COVENANT COVERT COWBIRD COWMAN COZ CP CRAWFISH CREMATION CREPT CRIB CRIMPED CRITERION CROTCH CROWD CRT CRUCIFIED CRUD CRUMPET CRUSHED CT CULT CUMQUAT CUP CURATORSHIP CURBED CURED CUSHIONED CUT CUTEST CYAN CYST CZ</p>
<p>D</p>
<p>D DAFFIEST DAMN DAMOCLEAN DAMPEN DAN DANDIFICATION DANDIFIED DANISH DANKEST DARTED DARWINIST DAUB DAVIT DAWN DAZZLED DB DEADBEST DEBAUCH DEBAUCHED DECADENT DECAPOD DECEIVED DECOMPRESSED DECOYED DEFERRED DEFIED DEFLATED DEFLECT DEFOREST DEGENERATED DEIST DELTOID DEMANDED DEMOLISHED DEMON DEMONSTRATION DENOMINATION DENT DENTED DEODORANT DEPARTMENT DEPEND DEPICT DEPOLARIZATION DEPORTATION DERELICT DERVISH DESICCATED DESOLATED DESPONDENT DESTINATION DETACHED DETERMINANT DETERRED DETONATION DEVEST DEVESTED DEVOTION DEVOURED DEVOUT DID DILAPIDATION DILATED DILATION DIMMEST DIMOUT DIMWIT DIN DINED DINT DIPLOMAT DIRTIEST DISALLOWED DISASSOCIATION DISCIPLESHIP DISCOMFORT DISENCHANT DISENTANGLEMENT DISFRANCHISED DISFRANCHISEMENT DISGUST DISHEARTENMENT DISINTEREST DISINTERMENT DISMOUNTED DISOBLIGED DISPATCHED DISPUTATION DISRESPECT DISSIPATION DISTAIN DISTRAIN DISTRICTED DIVED DIVVIED DIXIELAND DJ DOBERMAN DOCKETED DOCUMENTATION DODGED DOESN'T DOGFISH DOGSLED DOLLIED DOLPHIN DOMINATION DON'T DOORSTEP DOTHAN DOUBTED DOWDIEST DOWNIEST DOWNRIGHT DOWNWARD DOYEN DOZ DOZEN DRAB DRABBED DRAFT DRAFTSMAN DRAMATIST DRAT DRIEST DRIFT DROWSED DRUID DRUNKARD DUB DUCAT DUCKED DUET DUMONT DUMPED DURST DWARFED DWELT DYED DYNAST DYSFUNCTION DZ</p>
<p>E</p>
<p>EAGLET EARTH EASED EAST ECLAT ECOLOGIST EDEN EERIEST EFFERENT EFFORT EFT EH EIGHTH EIGHTIETH EJECTION ELAN ELECTROPLATED ELEVATION ELIZABETHAN ELOQUENT EMASCULATION EMBALMED EMBALMMENT EMBOLDENED EMBRACEMENT EMIGRANT EMIT EMITTED EMPATHIZED EMPTIEST ENAMELED ENCODED ENCORED ENCRYPT ENDICOTT ENERGIZED ENFIELD ENGENDERED ENGROSSED ENHANCEMENT ENID ENLIVENMENT ENNOBLED ENROLMENT ENSCONCED ENSHRINED ENTOMB ENTRAP ENTREAT ENTRENCHED ENWIND ENWRAPPED EON EPITOMIZED ERSATZ ESCHEAT ESCROWED EST ETCHED EVACUANT EVALUATED EVANESCENT EVENT EVICT EVICTION EVOLUTION EVOLVEMENT EXCLAIMED EXCLAMATION EXCUSED EXECRATED EXEMPLIFIED EXEMPT EXHILARATED EXHILARATION EXILED EXISTED EXIT EXITED EXPECTORATION EXPENDED EXPIRED EXPLOIT EXPORT EXPORTATION EXPRESSION EXPURGATED EXTERMINATION EXTINCTION EXTOLMENT EXTORT EXTROVERSION EXTRUSION EYEWASH</p>
<p>F</p>
<p>FABRICATED FACT FACTIONALIST FAD FAIR-TRADED FAIRYLAND FAITH FAKED FALSIFIED FASCINATED FASTED FASTEST FAUN FEINT FELON FERGUSON FERMAT FERMENTED FERRIED FERVID FETID FETISH FEZ FICKLEST FID FIERIEST FILL-IN FILLIP FINNED FIORD FIREBOAT FIREFIGHT FIREPROOFED FIRMED FISTED FIT FIXED FLAB FLATBED FLATBOAT FLATTED FLATTOP FLESHED FLIED FLIP FLIPPANT FLIT FLITTED FLOCCULENT FLOODLIGHT FLOWERPOT FLOYD FLUID FLUORIDATED FOCALIZATION FOLD FONDANT FOOD FOOTSTEP FORECAST FOREMEN FORESTED FOREWARN FOREWARNED FORFEITED FORMALIZATION FORMAT FORNICATION FORSOOTH FORTIETH FOURFOLD FOXED FRAGMENTED FRANKLIN FRAUGHT FRAYED FRENCHMAN FREON FREQUENT FRESH FRESHEST FRINGIEST FRIZZIEST FROGMAN FROGMEN FRONT FROTHIEST FROWNED FRUCTIFIED FT FUD FUELLED FUN FUNDED FUNNED FUNNELLED FUSSED FUSTIEST</p>
<p>G</p>
<p>GAB GADSDEN GALLIVANT GALLOP GALVANIZATION GAMIEST GAMUT GANGED GANGLAND GAP GARAGED GARISH GARMENT GARRET GASIFIED GASP GAUD GAUGED GAUNTEST GELATIN GELD GENT GEORGIAN GERALD GERARD GERRYMANDERED GERUND GET GETUP GHETTOIZED GHZ GIGGED GIGGLED GILBERT GIMP GIN GIRTH GLARED GLEN GLOP GLUT GNAT GNAWN GNP GOAT GOB GOD GONAD GOODHEARTED GORDON GOUT GP GRAD GRAINED GRANDILOQUENT GRANDSON GRAPHED GRAVELED GRAVEN GREAT GREEN GRID GRIDDED GRIND GRISTLIEST GROOVED GROSSEST GROT GROTON GROUPED GROWNUP GRUDGED GUARANTEED GUARD GUARDSMEN GUDGEON GUEST GUIDED GUIDON GUMMIEST GUMPTION GUN GUNMAN GUNSMITH GUTTED</p>
<p>H</p>
<p>H HACKLED HADN'T HAGGISH HAH HAIRED HALLOWEEN HALOED HAMMERHEAD HAMPERED HANDGUN HAND-ME-DOWN HANDOUT HANDWOVEN HANDYMEN HARD HARDHEADED HARPSICHORD HART HARTFORD HARVEST HASN'T HASTED HATBAND HAUNCH HAVERFORD HAWAIIAN HAWKWEED HAYWARD HEARKENED HEART HEARTBURN HEARTEN HEAVENWARD HEBRON HECATOMB<br>
 HE'D HEDGED HEFTED HEIGHT HELEN HELLBROTH HELLCAT HELMETED HEMMED HEMOSTAT HENCEFORTH HERBERT HERD HEREIN HICCUP HIGH HIGHEST HIGHHANDED HIGH-PRESSURED HIGHT HILLCREST HILLIEST HIND HINDERED HINDSIGHT HINGED HINT HIT HOARSEN HOB HOCKSHOP HOED HOGSHEAD HOGWASH HOISTED HOLDOUT HOLLAND HOLLOWED HOMEBOUND HOMEGROWN HOMESTRETCH HOMIEST HONEYCOMBED HONIED HOOCH HOP HOPPED HORSED HORTICULTURIST HOTCHPOT HOTHEAD HOUNDED HOUSEBOAT HOUSEBROKEN HT HUDDLED HUFFED HUFFIEST HUGGED HULLED HUMANKIND HUMBLEST HUMPH HUNCHBACKED HUNT HURLED HURRAH HURT HUSH HUSTLED HUTCHINSON HYPED HYPERTROPHIED HYPNOTIST HZ</p>
<p>I</p>
<p>IAMB IB ICELAND ICONOCLAST ID IDIOT ILLUMINATED ILLUSION IMITATED IMMOLATION IMMURED IMPAIRMENT IMPALED IMPART IMPERSONATED IMPLEMENT IMPORTANT IMPOTENT IMPRINT INACTIVATED INCRUST INCUBATION INDEMNIFIED INDIRECTION INDUCED INEDITED INEXISTENT INFANT INFLECT INFLECTED INFRACT INFRACTION INGROWN INHERIT INHIBIT INKBLOT INKSTAND INMOST INN INNERVATED INPUTTED INSCRIBED INSECT INSIST INSTRUMENTALIST INSULTED INTERACT INTERBRED INTERCEPT INTERCEPTED INTERCONNECTION INTERDEPENDENT INTERESTED INTERFERON INTERLARDED INTERLOCUTION INTERRUPT INTIMIDATED INVEIGH INVERSION INVIGORATED INVIGORATION INVOKED IRAN IRRELIGION IRRIGATED IRRITATION IRRUPTED IT IVAN</p>
<p>J</p>
<p>J JABBED JABOT JACKETED JANGLED JAUNDICED JAUNT JAUNTED JAVELIN JAWED JAZZ JEEP JERKIN JILT JINN JOAN JOCUND JOHNSON JOLT JOSTLED JOYPOP JUDGMENT JUICED JUKED JULIAN JUMP JUNCTION JUT</p>
<p>K</p>
<p>KAPH KAPUT KAT KEELBOAT KEELSON KEEN KENTWOOD KENYON KETCH KEYPUNCHED KIBBLED KILOBIT KIN KIND KINDLED KINGBOLT KINGLET KINGPIN KINSHIP KIRKLAND KIT KITED KLATCH KLUDGED KNELT KNISH KNOBBIEST KNOWN KNUCKLEHEADED KOBOLD KOLITSCH KRUGERRAND KUMQUAT KURT</p>
<p>L</p>
<p>LAGOON LAID LAIN LAKED LAMBASTED LANDED LASED LASERJET LASHED LATIN LAUREATION LAYTON LEAFIEST LEAFLET LEAPT LEAST LED LEEBOARD LEERED LEEWARD LEGALIZATION LEGGIEST LEGION LEGITIMIZED LEND-LEASED LENGTHIEST LENSED LENTEN LEOTARD LEPRECHAUN LESSEN LEST LET LEV LEVERED LIAISON LIBBED LIBYAN LIED LIEN LIFE-SIZED LIKENED LILT LIMB LIMIT LIMPET LINDENWOLD LINEAMENT LINEMAN LINEN LINEUP LINNAEAN LIONIZED LIPPED LISP LIST LIT LIVID LOBATED LOCATED LOGAN LOLLED LOMBARD LONGED LONGWOOD LORDSHIP LOST LOT LOTION LOUD LOUSIEST LUCKIEST LUGLUGGED LUMBERTON LURID LUST LYNNWOOD</p>
<p>M</p>
<p>MAIDENHOOD MAIMED MAJORED MALLARD MANDATED MANIFEST MANSION MARKED MARKET MARMOSET MARRIED MARSH MARSHIEST MASHED MAT MATURATION MAUDLIN MAXIMALIST MAYWOOD MAZED MAZIEST MEADOWSWEET MELIORATED MELTED MENTION MERCHANTMAN MERCURATED MERGED MESHED MESMERIST MESSIAH MESSIEST METED MICHIGAN MICROFILMED MID MIDMOST MIGHT MIGRATION MILBURN MILEPOST MILKMAID MILKMAN MILQUETOAST MILTON MISANTHROPIST MISCEGENATION MISCONDUCT MISCONSTRUED MISCREANT MISDIRECT MISFILED MISGUIDED MISQUOTED MISTRUST MISTYPED MISUSED MOAN MOB MOD MODELED MOIST MOISTEN MOLDED MON MONETIZED MONGOLIAN MONIST MONITION MONITORED MONKEYED MONOVALENT MOOED MOON MOONLIGHT MOONLIGHTED MOP MORTON MOTH MOTTLED MOUNT MOUSIEST MOUTHED MOUTHWASH MOWN MPH MT MULCT MULISH MULLION MULTIMILLION MULTIPLICAND MULTIPRONGED MUNCH MURED MUSHED MUSHIEST MUSTERED MUTANT MYCOLOGIST MYELIN MYOSIN</p>
<p>N</p>
<p>N NAT NATION NAUGHTIEST NEAP NEAPOLITAN NEED NEGLIGENT NEST NET NEUROLOGIST NIB NIGGARD NIGH NIGHTSHIRT NIMCOMPOOP NOBBIEST NOBBLED NOBELWOMAN NOBLEWOMAN NONACID NONACQUISITION NONCITIZEN NONCONSIDERATION NONDESCRIPT NONFAT NONMEMBERSHIP NONRESISTANT NONSLIP NORMALIZATION NORMAN NOSH NOURISH NOV NOVEMDECILLION NTH NUDIST NUN NURTURED NV</p>
<p>O</p>
<p>OARED OBEISANT OBFUSCATED OBJECT OBSCURANTIST OBSOLESCENT OBSTETRICIAN OBTRUSION OCCULT OCCULTATION OCHERED OCTANT OCTET OCTODECILLIONTH OD ODIN OFFERED OFFHAND OFFPRINT OH OILBIRD OLD OLDEST OLDISH OMELET OMIT ON ONRUSH ONSET ONSLAUGHT OPENED OPPRESSED OPTION OPULENT orBITED orCHESTRATED orCHID orDAINED orDERED orEGON orLAND OTHERWORLD OUCH OUST OUT OUTCROP OUTFITTED OUTLAST OUTLASTED OUTPUT OUTSHOUT OUTSIT OUTSMARTED OUTSPEND OVEN OVERCONFIDENT OVERDRIVEN OVERINDULGED OVERMATCHED OVERRAN OVERSKIRT OVERSOFT OVERTRUMP OXEN OXYHEMOGLOBIN</p>
<p>P</p>
<p>PACED PACKED PAGED PAGINATED PAIN PAINED PAIRED PALEONTOLOGIST PALLED PALMIST PALTRIEST PAMPHLET PAN PANNED PARATROOP PARCELLED PARCHMENT PARKLAND PARRED PARRIED PARROT PARROTED PARTED PAST PASTELIST PAT PATCH PATIENT PATRON PATRONIZED PAWTUCKET PAYED PAYLOAD PEALED PEANUT PEAT PEBBLED PECTIN PECULATION PEDANT PEDESTALLED PEDIATRIST PEELED PEEN PEERED PEEVED PELLET PELLETED PELT PELTED PENDED PENETRATION PEOPLED PEPPERED PERAMBULATION PERFORMED PERILED PEROXIDED PERSIST PERSON PERSUASION PERVERT PET PETULANT PHONED PHONETICIAN PHYSIOGNOMIST PIGGED PIN PINED PINFISH PINIONED PINKEST PINNACLED PINNED PINPOINTED PIP PISTOLLED PITCHOUT PITH PLAID PLAIT PLANCHET PLANET PLANTAIN PLANTATION PLASTID PLATTED PLAYFIELD PLAYPEN PLOD PLUMB PLURALIZED PLUSH POET POINTED POLAND POLAROID POLLINATION POLYGAMIST POMADED POMP POMPON POMPTON POOCH POP PORIFERAN PORTENT POSED POSIT POSTPAID POSTULATION POTION POTTSTOWN POULTICED POWERED PREDICAMENT PREDICATION PREDISPOSED PREDOMINATED PREEXIST PREEXISTENT PREFECT PREFERRED PREFIGURED PREHEAT PRESERVED PRETTIEST PREVAILED PREVARICATION PREVIEWED PRIED PRIMETEST PRIMMED PROCTOLOGIST PROCURED PROD PROHIBIT PROMOTION PRONOUN PROSED PROSPECT PROSTRATED PROTON PROTRACT PROVOKED PROWLED PT PUBESCENT PULLED PULLMAN PULP PULVERIZED PUMPKIN PUN PUNISH PUNNED PURDAH PURIST PUTOUT PUTT PYTHON</p>
<p>Q</p>
<p>QED QUIESCENT QUIET QUIETEST QUINTUPLED QUIP QUOIN QUOIT</p>
<p>R</p>
<p>RABBET RACIST RADICALIZED RADIOCARBON RADIOLOGIST RADON RAFT RAGGED RAGOUT RAID RAIN RAINSPOUT RAMBLED RAMJET RAMMED RANKED RAPPED RAT RATION RATLIN RATTRAP RAUNCHIEST RAVELMENT RAVISH REACT READIED READOPT READORN REAPPEARED REARMED REARRANGEMENT REATTACH REATTEMPT REBIND REBOUNDED REBUILD REBUTTED RECALCITRANT RECALCULATION RECALLED RECLAIMED RECOIN RECOLORED RECONFIRMATION RECONSIDERATION RECOUNTED RECRUDESCENT RED REDD REDEMANDED REDESCEND REDIRECTION REDOUBLED REDSKIN REED REEDIEST REEKED REENACT REFITTED REFLOURISH REFORMED REFRACTION REFRAIN REFROZEN REFURNISH REFUSED REFUTATION REGENERATED REGIMENT REGIMENTATION REGRANT REGRETTED REHEATED REIMPLANTED REIN REInsertED REINSTALLED REINVITED RELAPSED RELICT RELIGHT RELOCATION RELUCTATED REMANDED RENT REP REPAINTED REPAIRMAN REPASSED REPLANTATION REPLENISH REPOLISH REPORT REPROACH REPROBATION REPUBLISH REPUTATION REPUTED RERUN RESECTED RESH RESINATED RESONANT RESORTED RESOWED RESPECT RESPECTED RESPIRED RESTART RESTAURANT RESTRICTION RESURGENT RETAIN RETCH RETEST RETOOLED RETRACED RETRIEVED RETURNED REUNIFICATION REV REVALUATION REVAMPED REVELED REVERT REVIVED REVOLT RHEUMATOID RHOMB RHYMED RICHLAND RICHMOND RIDERSHIP RIDGEFIELD RIND RIVED RIVEN RIVETED ROD ROILED ROILIEST RON RONALD ROOKED ROOSTED ROOTED ROUGH ROUGHEN ROUNDEST ROUNDLET ROUTED ROVED ROWELLED RUB RUBICUND RUDIMENT RUDOLPH RUFFED RUGGED RUNAROUND RUNDOWN RUNT RUSHIEST RUSSET RUTH RUTHANN RUTTED</p>
<p>S</p>
<p>SACRED SADDEN SAFEGUARD SAGGED SAILED SALAD SALESWOMAN SALT SAMOAN SAN SANDBLAST SANDED SANDWORT SAPPIEST SASH SAT SAUNTERED SAWFISH SAXHORN SB SCABBED SCAFFOLD SCALLION SCALP SCAN SCARFPIN SCATTERED SCHMALTZ SCHMALTZIEST SCHOOLED SCOOP SCOOTED SCORECARD SCOT SCOTSMAN SCRAGGIEST SCRAMMED SCRAPED SCREECHIEST SCREED SCRUBBED SCRUNCH SCULLED SCULPTED SCULPTURED SCUMBLED SCUMMED SCUTCH SD SEABIRD SEALSKIN SECTARIAN SEDATED SEEDED SENSATIONALIST SENTIENT SEQUENCED SERIALIST SERIALIZED SERVICED SESAMOID SET SEVENTY-SIXTH SEXAGENARIAN SEXTANT SEXTILLION SEXTUPLED SHAH SHAN SHAPEUP SHARED SHEEN SHELVED SHIP SHIRTWAIST SHOD SHOED SHOPPED SHORED SHOREFRONT SHORTEN SHORTHAND SHOTTEN SHOVELLED SHOWN SHREWD SHRIVELLED SHUDDERED SHUNNED SHUNT SHUT SIB SIDEBOARD SIDEMAN SIDESPIN SIEGED SIEVED SIGNALMAN SIGNET SIGNPOST SILKEN SILKIEST SILUROID SILVERSMITH SINEWED SIPPED SIRRAH SIZZLED SKEIN SKID SKILLET SKIN SKINTIGHT SKULKED SKYLIGHT SLAGGED SLANDERED SLAVISH SLED SLEDDED SLEEKEN SLENDEREST SLIPKNOT SLIPPED SLITHERED SLOPPIEST SLOT SLOVEN SLUBBED SLUGGED SLUICED SLUMPED SLURP SMART SMEARED SMIDGEN SMILED SMI<br>
RCH SMITH SMOKED SMUT SNAP SNATH SNEAKED SNIGGERED SNITCH SNOUT SNUB SOAPED SOAPIEST SOARED SOBERED SOBERIZED SOCIALIZED SOFT SOLARIZATION SOLATION SOLD SOLEMN SOLEMNIZED SONANT SONNETIZED SORPTION SORT SOT SOWN SPACEBAND SPACKLED SPARKIEST SPARTAN SPAT SPEARMAN SPECIATED SPECTATED SPELTZ SPEND SPHEROID SPIKELET SPILT SPLINTERED SPOKED SPOOLED SPOONED SPORRAN SPOT SPOUSED SPREAD SPRINGIEST SPURT SQUALID SQUAT SQUEALED SQUEEGEED SQUELCH SQUIB SQUIBBED SQUIFFED SQUIRISH SQUIRRELED STABBED STALINIST STALLED STALLION STALWART STAMPED STANCHION STANDARD STANDPOINT STAPHYLINID STEADFAST STEADIEST STEPCHILDREN STERILANT STERN STICKMAN STICKUP STIMULATED STIRRED STOCKIST STODGIEST STOLEN STOMATILOGIST STONEWALLED STOUTENED STOUTEST STP STRAGGLIEST STRAIT STRANGEST STRAPPED STRAWBOARD STREAMWOOD STREET STREWN STRIDENT STRIKEBOUND STRINGBOARD STRIPT STROLLED STRONGMAN STROWN STUDENTSHIP STUFFIEST STULTIFICATION STUMPIEST STYED SUB SUBEDIT SUBINFEUDATED SUBJACENT SUBLATION SUBREGION SUBSCRIBED SUBSTANDARD SUBTENANT SUBTITLED SUCKED SUDSIEST SUET SUFFRAGIST SUGARED SULFONATED SULFURETED SUMMARIZED SUMMED SUNDERED SUNKEN SUNLAMP SUPERADDITION SUPERCONDUCT SUPERINTEND SUPERMARKET SUPERVENTION SUPINATION SUPPOSED SUPPRESSED SUPPURATION SURROUNDED SUSPECT SUSPECTED SWAB SWAGMAN SWAIN SWAMP SWAN SWANNED SWASHBUCKLED SWATH SWAYED SWEETEST SWERVED SWIRLED SWITCH SWOT SYMBOLED SYNCH SYNCOPATED SYNOD</p>
<p>T</p>
<p>T TABBED TABLESPOON TACH TAD TAGSTART TAINT TAJ TALKATHON TALLISH TAMP TAMPION TAN TANKED TANTALIZATION TANZANIAN TARBUSH TARGETED TARN TARPAULIN TARTLET TAUNTED TAUTENED TAVERN TAXED TAXICAB TAXIDERMIST TEARDrop TECHED TECHNICALIZATION TEENIEST TEGUMENT TELEGRAPH TELEOSTEAN TELETYPED TENANT TENET TENSION TENTED TEPID TERREPLEIN TERRORIZED TESSERACT TEUTON TH THEGN THEORIST THEURGIST THEY'D THIEVED THIEVISH THIN THINCLAD THIRDHAND THISTLEDOWN THOUGHT THOUSAND THREADIEST THRIVEN THRUMMED THYROCALCITONIN THYROID TICKETED TICKLED TIDBIT TIFFED TIGERISH TILT TILTH TIMBERED TIMEOUT TIMIDEST TINCT TINGED TINIEST TINKLED TIT TOAD TOADIED TOASTIEST TOBOGGANIST TOD TODDLED TOEHOLD TOFT TOLERANT TOLERATED TOMCOD TONED TONSURED TOOTHBRUSH TOPNOTCH TORRENT TORRID TOTALITARIAN TOTIPOTENT TOURED TOWBOAT TOWHEADED TOWN TOWNSWOMAN TOXICANT TOYON TRACTION TRADESMAN TRAINBAND TRAIPSED TRAMMELED TRANSECT TRANSFIXION TRANSHIP TRANSPORT TRANSPOSED TRAUMATIZED TRAVAILED TRENCHANT TRESPASSED TRICKISH TRICORNERED TRIDENT TRIFLURALIN TRIGGERMAN TRIGLYPH TRIJET TRILLED TRIPLICATED TRIPLICATION TRISTEARIN TRIVET TROLLEYED TROLLOP TROOP TROOPED TROUBLED TRUCKLED TRUCKMAN TRUDGED TRUEST TRUMPET TRUST TUBIFICID TUCKERED TUCKET TUFT TUGBOAT TURBINATED TURBORAMJET TURD TURNED TURNOUT TURRET TURRETED TUSCAN TUSSAH TUT TWENTY-FIRST TWIGGED TWILLED TWIN TWIXT TYPESET TYROCIDIN TYROTHRICIN</p>
<p>U</p>
<p>UCB UGLIFICATION UMBILICATION UMLAUT UMPTEEN UN UNABBREVIATED UNABSORBED UNACCOMMODATED UNACCOMPLISHED UNACCUSTOMED UNAMAZED UNAMBIVALENT UNAMPLIFIED UNANELED UNANIMATED UNAPPRECIATION UNASSUAGED UNATTESTED UNAVOWED UNAWED UNBAKED UNBARBED UNBEKNOWNST UNBELT UNBIGOTED UNBLOWN UNBLUNTED UNBOLT UNBURNISHED UNBURNT UNCAGED UNCILIATED UNCOFFINED UNCOMPLETED UNCONCERN UNCOUPLED UNCREASED UNCRITICIZED UNCROSSED UNCROWDED UNCURDLED UNDEAD UNDEEDED UNDEFACED UNDEFENDED UNDELIVERED UNDERACT UNDERBRED UNDERFED UNDERVALUED UNDERWEIGHT UNDIAGNOSED UNDIGESTED UNDIGNIFIED UNDILATED UNDISTRACTED UNDIVERSIFIED UNDOCKED UNDOCUMENTED UNDULATED UNENGAGED UNENTANGLED UNENVIED UNESCORTED UNEXAGGERATED UNEXPIRED UNFANNED UNFATHERED UNFEDERATED UNFETTERED UNFLAWED UNFLEXED UNFRIEND UNFROZEN UNFUSED UNGIRD UNGIRT UNGLAMORIZED UNGLAZED UNGRASPED UNHANGED UNHARMED UNHEARD UNHIRED UNHUNTED UNIMAGINED UNIMFLECTED UNIMPLEMENTED UNIMPROVED UNINTERESTED UNION UNIONIZED UNIONTOWN UNISON UNITIZATION UNIV UNJADED UNJOINT UNJUST UNLADED UNLEVIED UNLICKED UNLINED UNLIST UNLIT UNLOAD UNLOOSENED UNMAN UNMARRED UNMENTIONED UNMONEYED UNMOVED UNNOTED UNOBLITERATED UNPADDED UNPARALYZED UNPARDONED UNPARTED UNPARTITIONED UNPERVERTED UNPLASTERED UNPRACTICED UNPRESSED UNPRINCIPLED UNPROSTITUTED UNPURGED UNQUESTIONED UNRATED UNRECLAIMED UNREDEEMED UNREELED UNREEVED UNRESERVED UNREVEALED UNRIVALED UNROASTED UNSCATHED UNSETTLEMENT UNSHELLED UNSNAP UNSOPHISTICATED UNSPLIT UNSPOKEN UNSTAINED UNSTUDIED UNSWEPT UNTAMED UNTAPPED UNTHATCHED UNTORN UNTREAD UNUSED UNUTTERED UNWEARIED UNWEDDED UNWISH UNWOVEN UNWROUGHT UPPED UPSHIFT UPSHOT URINATION UROCHORD UROPOD USURPED UT UTAH UTMOST UTOPIAN</p>
<p>V</p>
<p>V VACUOLATED VACUUMED VALANCED VALUATED VAN VAPID VAPORIZATION VAPORIZED VASOTOCIN VAULT VAULTED VAWARD VD VEHEMENT VELD VENDITION VENERATION VENTED VERSIFICATION VERT VESICATION VESTIBULED VET VETERINARIAN VEXILLOLOGIST VICED VIDICON VILLAIN VINEGARISH VINELAND VIP VISAED VISED VISION VISITANT VITIATED VIVANT VIVERRID VIVID VOLANT VOMITED VOTED</p>
<p>W</p>
<p>WAFTED WAILED WAIN WAISTCOATED WALKOUT WAMBLED WANGLED WANT WANTON WARED WARIEST WARRANT WASH WASHBOARD WASHWOMAN WATCHBAND WATCHED WATERIEST WATERWORN WEEN WELKIN WELT WEN WEND WESLEYAN WESTERN WESTFIELD WESTPORT WETLAND WHALED WHAT WHEATEN WHELP WHINED WHIP WHIRRED WHIST WHITEHEAD WHITETHROAT WHOLESALED WIDEST WIDTH WIEFERICH WIENERWURST WIFEHOOD WIGEON WIGGED WILDWOOD WINCH WIND WINDBURNED WINDSCREEN WINESHOP WIREMAN WITCH WITHOUT WITTIEST WOAD WOLCOTT WOMAN WOMB WON WONDERMENT WONT WOODENHEAD WOODLOT WOOLSHED WORKMEN WORKUP WORRYWART WORSEN WORSTED WORTHINGTON WOULDN'T WOULDST WRESTED WRETCH WRIT WT WYLIECOAT WYND</p>
<p>X</p>
<p>XENOLITH XYLOGRAPH</p>
<p>Y</p>
<p>YACKED YAMEN YAP YARDMAN YARN YD YEASTIEST YELLED YIDDISH YIELDED YOGHURT YOU'D</p>
<p>Z</p>
<p>ZEN ZENITH ZEST ZONATED ZOOPLANKTON<br></p>
<p>参见：http://primes.utm.edu/notes/words.html</p>
			 ]]></content>
<pubDate>2007-02-02T01:14:01+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/135</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 信息学竞赛中可能有用的概率学知识 ]]></title>
<link>http://www.matrix67.com/blog/archives/136</link>
<content><![CDATA[ 
		<p>    说到概率，有些好玩的东西不得不提。比如，你知道吗，23个人中至少两个人生日相同的概率竟然超过了1/2；假如你们班上有50个人的话，那更不得了，至少两人生日相同的概率达到97% ！如果你会计算这个概率问题的话，你可以亲自证实这一点。本文适宜的读者是知道上述问题怎么算的高中朋友，上述问题也是高中阶段学的一些基本概率知识。<br>    上面的问题都是简单概率，它包含了一个最基本的原则，即使没有系统地学习过，平常人们也都在无形之中使用它：概率等于你要算的东西除以总的数目。比如。我们要计算23个人中任何两个人都不在同一天生的概率。假设2月29日与其它日期出现概率相同的话（这是为了便于计算我们做出的假设，它有悖于常理），那么它的概率为A(366,23)/366^23。它约为0.493677。因此，至少两人在同一天生的概率为1-0.493677=0.506323。当然，对于“你要算的东西除以总的数目”的认识是片面的，比如“投两个骰子出现的数字和从2到12共有11种可能，问数字和大于10的概率”这一问题的答案并不是2/11，因为这11个点数和出现的概率不是相等的，我们只能从投出的两个数字共6*6=36种情况中进行统计，可能的情况只有(5,6)、(6,5)和(6,6) （不会有人说还有(6,7)之类的吧），答案应该是3/36=1/12。这些都是废话，我不细说了。<br>    但是，你有想过这个问题吗：要是这些数目是无穷的怎么办？换句话说，统计的东西不是“离散”的怎么办？比如看这样一个问题。明天早上我要和MM约会，但是具体见面时间我忘了，好像是8:00-9:00的某个时候。那么我随便在这个时段中选一个时间去等MM，最多等她半个小时，正好能见到MM的概率是多少（假设MM先到的话不会等我）。这个问题和我们平时见到的问题不同的地方在于，它的“情况”是连续的，不是离散的，不能逐一统计数目。咋办呢？我们注意到，我的时间随机取一个，MM的时间随机取一个，对于某些组合我们是有缘分的（这些组合无穷多）。这些组合正好对应了平面区域上的点。就是说，搞一个横坐标表示我的时间，纵坐标表示MM的时间，那么肯定能画出那么一块区域，区域里的所有点(x,y)对应所有我和MM可能相见的组合。任何一个时间组合有多大的可能落在这个区域呢？由于在矩形区域内点(x,y)是均匀分布的，我们只需要计算一个面积之比就行了。下图中显而易见，答案是3/8。<br>   <img alt="image placeholder" >
<p>    一个类似的问题是Buffon投针实验。有一个人，叫Buffon。他在地板上画了很多间隔相同的平行线，然后叫了一帮狐朋狗友来，把一些长度相同的针扔在地上。然后，他统计有多少针和地板上的线相交，并宣称可以得到圆周率π的值。换句话说，一根针投到间隔相同的平行线中，与平行线相交的概率和π有关。我们时常感到数学的神奇之处，比如当这个π在很多不该出现的场合莫明其妙的出现时。例如，Stirling近似公式（黑书上的这个公式写错了）出现了π值：n!≈sqrt(2πn) * (n/e)^n （sqrt是开方的意思）。再比如，两个整数互质的概率是6/(π^2)，而无穷级数1+1/4+1/9+1/16+…=(π^2)/6。当然，还有最神奇的e^(πi)+1=0。现在，π又出现在了这样一个看似与圆周率更加没有关系的概率问题中：针与线相交的概率为两倍针的长度除以平行线的间隔再除以π。这个结论的证明和刚才我等MM的问题是一样的。建立这样一个坐标系，x轴是针的中点到离它最近的那根平行线的距离，y轴是针与平行线的夹角。我们一定能做出这样一块“可行区域”，这块可行区域中的点(x,y)所对应的针的位置和平行线相交。然而，这块区域的面积并不像刚才那么简单，它是由一些方程围出来的图形，求这块区域的面积需要使用定积分。这里就不再接着说了，反正能求出来。<br>    当然，涉及无穷的概率问题还有很多其它的统计方法，这里不说明了。</p>
<p>    有这么一个笑话。据说一个飞机上有炸弹的概率为十万分之一，但某人并不认为这个概率很小。概率小毕竟意味者可能，每天航班这么多，十万分之一确实不是一个小数目。因此，这个人从来不敢坐飞机。有一次，他居然和朋友上了飞机，朋友吃惊地问，你咋不害怕了。他说，飞机上有一个炸弹的概率不是十万分之一么？那么飞机上同时有两个炸弹的概率就是一百亿分之一了，对吧。朋友说，对，一百亿分之一已经很小了。这人说，那好，我自己已经带了一颗炸弹上来。<br>    从没听过这个笑话的人或许会笑笑说那人真傻，但仔细想想似乎自己解释一下也很困难。这涉及到了条件概率，这在高中课本里（至少在我的高中课本里）没有说过，你把书翻烂了都找不到。<br>    条件概率，顾名思义，就是有条件的概率。比如，有两个炸弹的概率和知道已经有一个炸弹后存在两个炸弹的概率是不同的。假如我们把有两个炸弹的概率记作P(两个炸弹)=百亿分之一，那么后一个问题就是P(两个炸弹|已经有一个炸弹了)。记号P(A|B)就表示在B已经发生了的情况下，A的概率是多少。后面我们可以知道，它仍然等于十万分之一。<br>    换一个问题。还记得最前面我们说的“投两个骰子出现的数字和大于10的概率”这个问题吗？它的答案是3/36。现在改一下，如果我们事先就知道至少有一个骰子是6点。那么概率变成多少了（或者问概率变了没有）？很显然，多了一个条件，概率肯定变大了，笨蛋都知道如果有一个骰子搞出那么大一个点数，那赢的几率肯定增加了。关键在于，前面分析过数字和大于10的情况只有(5,6)、(6,5)和(6,6)，它们本来就含有6啊，为什么概率变了。仔细思考发现，原来是总的情况变少了。原来总的情况是36种，但如果知道其中一个骰子是6点的话，情况数就只有11种了。概率变成了3/11，大了不少。我们还需要补充，如果把我们“至少有一个骰子是6点”换成“至少有一个骰子是5点”的话，总的情况数还是11，但3/11将变成2/11，因为有一种情况(6,6)不满足我的已知条件。我们可以纯粹用概率来描述这一个思考过程。如果P(E)表示点数和大于10的概率，P(F)表示至少有一个5点的概率，那么我们要求的是P(E|F)，即已知F发生了，求E发生的概率。于是P(E|F)=P(E∩F)/P(F)。这就是条件概率的公式。简单说明一下就是，E∩F表示满足E的情况和满足F的情况的交集，即同时满足E和F的所有情况。P(E∩F)就是E和F同时发生的概率。这个公式使用原来的非条件概率（总情况数目还是36时的概率）之比来表示条件概率（相当于分式同时除以一个数，就如P(E|F)=2/11=(2/36)/(11/36)）。回到炸弹问题上，P(A|B)就应该等于出现两个炸弹的概率除以出现一个炸弹，他仍然等于一个炸弹的概率。<br>    高中课本里对“独立事件”的定义是模糊的。其实，现在我们可以很好地给独立事件下定义。如果事件E和事件F独立，那么F就不能影响E，于是P(E|F)=P(E)。把P(E|F)展开，就成了P(E∩F)/P(F)=P(E)，也即P(E∩F)=P(E)*P(F)。这不就是“两个独立事件同时发生的概率”的计算公式么。</p>
<p> <br>
   条件概率的应用很广泛，下面举个例子。<br>    有两个人，他们每三句话只有一句是真的（说真话的概率是1/3）。其中一个人说，Matrix67是女的。另一个人说，对。那么，Matrix67的确属于女性的概率是多少？<br>    这是一个条件概率问题。如果P(E)表示Matrix67是女性的概率，P(F)表示第二个人说“对”的概率，那么我们要求的就是P(E|F)，即在第二个人回答后的情况下第一个人说的话属实的概率。按照公式，它等于P(E∩F)/P(F)。P(E∩F)是说，Matrix67是女的，第二个人也说对，表示的实际意义是两个人都说的真话，他的概率是1/3 * 1/3=1/9。P(F)表示第二个人说“对”的概率，这有两种情况，有可能他说对是因为真的是对的（也即他们俩都说真话），概率仍是1/9；还有一种可能是前一个人撒谎，第二个人也跟着撒谎。他们都说谎的可能性是2/3 * 2/3 =4/9。没有别的情况会使第二个人说“对”了，因此P(F)=1/9+4/9=5/9。按照条件概率的公式，P(E|F)=P(E∩F)/P(F)=(1/9) / (5/9)=1/5。后面我们接着说，这其实是Bayes定理的一个非常隐蔽的形式。</p>
<p>    你或许看过我的这篇日志：http://www.matrix67.com/blog/article.asp?id=87。我用相当长的篇幅介绍了Monty Hall问题。下面所要讲的东西与这个有关，建议你先去看看那篇日志。不看也没啥，我把题目意思在下面引用一下。<br>
</p>
<blockquote>    这个问题最初发表在美国的一个杂志上。美国有一个比较著名的杂志叫Parade，它的官方网站是http://www.parade.com。这个杂志里面有一个名字叫做Ask Marylin的栏目，是那种“有问必答”之类的一个Q&amp;A式栏目。96年的时候，一个叫Craig.F.Whitaker的人给这个栏目写了这么一个问题。这个问题被称为Monty Hall Dilemma问题。他这样写到：
<p>    Suppose you're on a game show, and you're given the choice of three doors. Behind one door is a car, behind the others, goats. You pick a door, say number 1, and the host, who knows what's behind the doors, opens another door, say number 2, which has a goat. He says to you, "Do you want to pick door number 3?" Is it to your advantage to switch your choice of doors?</p>
<p>    这个问题翻译过来，就是说，在一个游戏中有三个门，只有一个门后面有车，另外两个门后面是羊。你想要车，但你不知道哪一个门后面有车。主持人让你随便选了一个门。比如说，你选择了1号门。但你还不知道你是否选到了车。然后主持人打开了另一扇门，比如2号。你清楚地看到2号门后面是一只羊。现在主持人给你一个改变主意的机会。请问你是否会换选成3号门？<br>    对于这个问题，Marylin的回答是：应该换，而且换了后得到车的概率是不换的2倍。</p>
</blockquote>
<p>    对于这个问题，十年来涌现出了无数总也想不通的人，有一些冲在最前线的战士以宗教般的狂热传播他们的思想。为了说服这些人，人们发明创造了十几种说明答案的方法，画表格，韦恩图，决策树，假设法，捆绑法（我的那篇日志里也提到一种最常见的解释方法），但是都没用。这群人就是不相信换了拿到车的概率是2/3。他们始终坚定地认为，换与不换的概率同为1/2。下面，我们用一个更科学的方法来计算换了一个门后有车的概率。我们使用刚才学习的条件概率。</p>
<p>   <img alt="image placeholder" >
<p>    我们最后看一个问题。这个问题是条件概率的终极应用，是概率学中一个最重要，应用最广的东西。把下面这个问题搞明白了，从此对概率学的学习就真正入门，可以摆脱“初级”、“菜鸟”的称号了。这就是传说中的Bayes定理。我已经写了五千字了，不想再写了，这保证是我想说的最后一个东西。<br>    首先你得知道，P(A|B)和P(B|A)是截然不同的两个概念。有些条件概率，正着算P(A|B)容易，把条件反过来算P(B|A)却无从下手，而人们往往更加关心P(B|A)。生活中有很多这样的例子，我们小举一个。<br>    某个地区性病传播飞快，性病患者高达15%。医院临床实验表明，对有性病的人检测，有95%的人显阳性；对没有性病的人检测，有2%的人阳性。现在，假如某个人搞了一个小MM，突然有点担心，跑到医院去检测，查出了阳性。那么他确实有性病的概率是多少？<br>    假如事件A是显阳性，B是有性病，我们可以看到在现实生活中P(A|B)比P(B|A)更容易得到。P(A|B)表示对有性病的人进行检测搞出阳性的概率，这可以通过医院里的抽样统计得到，题目中已经说了是95%。但是，P(B|A)就不好说了，它表示对于某个人来说，显阳性意味者真的有性病的概率是多少。这是针对个人的，统计资料通常没有这一项，但人们却往往更关心这个问题。事实上，我们可以通过已有的条件把P(B|A)算出来。把P(B|A)展开，它等于P(B∩A)/P(A)，而因为P(A|B)=P(A∩B)/P(B)，把P(B)乘过去，得到P(B∩A)=P(A∩B)=P(A|B)*P(B)。我们把分子的部分转换成了已知量P(A|B)和P(B)的乘积，它等于95% * 15%。那么P(A)怎么算呢？P(A)是由两种情况构成的，可能是有性病的人显的阳性，即P(A∩B)；也可能是没有性病的人显的阳性，即P(A∩～B)。～B表示B的补集，也可以在B上面画一条横线表示，我这里画不出来，算了。～B就是没有病的人，它的概率是1-15%=85%。P(A∩B)和P(A∩～B)都可以用已有的概率算出来，分别是刚才得到的P(A|B)*P(B)，以及用类似的方法得到的P(A|～B)*P(～B)。。因此整个概率就等于(95% * 15%)/(95% * 15% + 2% * 85%)≈0.8934。这就是Bayes定理的一个具体应用。<br>    在上面的题里，我们求P(A)时把“显阳性”按照“是否有病”分成了两个不相交的部分，并分别求<br>
出概率后再求和。事实上，对于事件A可以按照B的属性分成多个不相交的部分。此时再完整地叙述一下Bayes定理，大家就不难理解了。如果B1、B2、B3一直到Bn是n个互不相交的事件，而且这n个事件是“一个完整的分类”（即并集是全集，包含了所有可能的情况），那么有公式：</p>
<p>P(B1|A)=[ P(A|B1)*P(B1) ]/[P(A|B1)*P(B1) + P(A|B2)*P(B2) + …+ P(A|Bn)*P(Bn)]</p>
<p>    下面再举一个例子。这个例子和前一个例子非常相似。事实上，它也和前面说我是女的的那个例子如出一辙。它将是我们的最后一个例子，并且我不给解答，写完例子立马走人。解决这个问题有助于理解和联系前面这两个例子。<br>    我经常约同学单独出去玩。据统计，和一个女同学出去玩的概率高达85%，和一个男同学出去的概率只有15%。现在，某人宣称他看到昨天我和某某男在外面玩。长期观察表明，这人的可信度（说真话的概率）为80%。那么，我昨天真和一个男的出去玩的概率是多少？</p>
<p>Matrix67原创<br>做人要厚道，转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-02-06T19:43:32+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/136</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 无限小却无限大的集合 & 阶梯状的连续函数 ]]></title>
<link>http://www.matrix67.com/blog/archives/137</link>
<content><![CDATA[ 
		<p>    康托集合是闭区间[0,1]的子集，它的定义如下：给定区间[0,1]，把这个区间分成三段，去掉中间那一端（即去掉(1/3,2/3)），然后把剩下的两段中每一段都按照刚才的方法再进行操作，然后再分，再分，就这样一直挖洞挖下去。在第二次操作后，剩下的区间是[0,1/9]∪[2/9,1/3]∪[2/3,7/9]∪[8/9,1]，再操作一次后区间将由8段构成。最后剩下来的东西是什么呢？你能找到存在于这个集合中的某个具体的元素吗（不包括形如x/(3^n)的端点）？<br>    我们看到，n次操作后，区间的总长度为(2/3)^n，当n趋于无穷时，区间长度趋于0。但是这并不能说明这个区间里没有任何元素。事实上，我们可以找到至少一个元素。比如，下图中绿色的点表示三等分点，如果P满足AP/AB=A'P/A'B'的话，那么P点始终以比例相同的位置留在某一段上，这样的话即使无限地分下去也不会把它挖掉。<br>       <img alt="image placeholder" >
<p>做人要厚道<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-02-06T22:30:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/137</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 用Cena评测答案提交类题目的另类方法 ]]></title>
<link>http://www.matrix67.com/blog/archives/138</link>
<content><![CDATA[ 
		<p>    这几天组织了几次省选模拟赛，遇到了答案提交类的题目和交互式的题目。我一直使用Cena进行评测，现在希望把这两种类型的题目方便地加入Cena的评测结果中。交互式的题目使用Cena评测非常简单，只需要在库函数运行时输出一个以得分情况为内容的文件作为选手输出即可（http://www.matrix67.com/blog/article.asp?id=179）。但答案提交类的题目却遇到了麻烦，因为Cena肯定不允许程序访问外部文件（因此不能另写程序读入提交的答案并作为选手输出文件输出），而每个选手提交的答案文件所在位置又不确定（不知道文件夹名），不能把这些文件加入Cena的评测中。后来，我想到了这样一个解决方案。我可以用程序生成一个程序来生成选手输出文件（真他妈的绕口）。</p>
<p>    假设测试点共10个，所有的输入文件名为name.?.in，输出文件名为name.?.out，其中?取1到10中的数。那么下列程序可以生成一个printer.pas作为选手程序。以下程序将选手提交的答案写入pas源代码“printer.pas”中，它可以根据输入文件恰当地进行输出操作。“printer”将被设置为该题的源程序文件名。<br>    评测时所用的输入文件只有一个整数，标识这是第几个测试点。程序的输出（即选手提交的答案）可以和标准输出比较或另写Checker评分。</p>
<p><code>program print;<br>const<br>   fname='name';<br>var<br>   i:integer;<br>   st:string;</code></p>
<p>procedure init;<br>begin<br>   writeln('program printer;');<br>   writeln('var n:integer;');<br>   writeln;<br>   writeln('begin');<br>   writeln('   assign(input,'+#39+fname+'.in'+#39+');');<br>   writeln('   reset(input);');<br>   writeln('   readln(n);');<br>   writeln('   close(input);');<br>   writeln('   assign(output,'+#39+fname+'.out'+#39+');');<br>   writeln('   rewrite(output);');<br>   writeln;<br>end;</p>
<p>begin<br>   assign(output,'printer.pas');<br>   rewrite(output);<br>   init;<br>   for i:=1 to 10 do<br>   begin<br>      str(i,st);<br>      {$i-}<br>      assign(input,'name.'+st+'.out');<br>      reset(input);<br>      {$i+}<br>      if ioresult&lt;&gt;0 then continue;<br>      writeln('   if n=',i,' then begin');<br>      repeat<br>         readln(st);<br>         writeln('      writeln(',#39,st,#39,');');<br>      until eof;<br>      writeln('   end;');<br>      writeln;<br>   end;<br>   writeln('   close(output);');<br>   writeln('end.');<br>   close(output);<br>end.</p>
<p>    采取一些工具软件可以在不同的选手文件夹下批处理运行该程序。</p>
<p>    过几天我可能又要思考如何评测循环赛类型的题目了。</p>
<p>做人要厚道<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-02-11T20:49:50+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/138</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 编写一个最简单的交互式题目 ]]></title>
<link>http://www.matrix67.com/blog/archives/141</link>
<content><![CDATA[ 
		<p>    最近无聊学着编了一下交互式类型的题目。平常网上交互式题目的库文件源码并不多见，在这里把我写的一个题目分享给大家，希望对大家能够有帮助。</p>
<p>    题目是一个经典问题，下面所引用的内容是全部的题目描述：<br>
</p>
<blockquote>Problem : famous<br>谁是名人
<p>问题描述<br>    Matrix67所在的小镇上有N(2&lt;=N&lt;=1000)个人，它们从1到N编号。在小镇中，一些人认识另一些人，这种认识的关系是单向的。一个人是名人当且仅当小镇上所有的人都认识他，而除他之外的所有N-1个人他都不认识。假设这个小镇上有且只有一个名人，而你只能询问诸如“A是否认识B”这样的关系。请用不超过2000次的询问找到这个名人。</p>
<p>交互方法<br>    这个题目是一个交互式的题目。我们不提供输入文件，同时也不需要任何输出文件。你需要调用一个我们准备好的库函数来完成所有的操作。你可以得到libfam.ppu和libfam.o两个文件。你需要把这两个文件放在和你的源程序相同的目录下，并在源程序里加入“uses libfam”完成对库文件的引用。我们的库文件提供了以下两个函数和一个过程：<br>      function init:longint;<br>      function know(a,b:longint):boolean;<br>      procedure submit(sol:longint);</p>
<p>    init函数只能调用一次。这个函数仅在程序开始时调用，他将返回N值，代表小镇上的人数。<br>    函数know(a,b)返回一个布尔值，它告知了编号为a的人与编号为b的人的关系。如果该函数返回true，则你获得了“a认识b”这一信息；如果该函数返回false，则你获得了“a不认识b”这一信息。该函数可以多次调用，每调用一次称做为一次询问。你的询问次数不能超过2000次，也就是说，该函数最多被调用2000次。<br>    submit过程只能调用一次。这个过程仅在程序结束时调用，用于提交你得到的答案，所带的参数即是名人的编号。调用这个过程将终止你的程序，你可以在日志文件中看到反馈信息。</p>
<p>一个成功交互的例子<br>    下面这一程序代码说明了如何进行正确的操作。除了解释如何使用交互库之外，这个代码不具有任何意义。它不具有提示你询问方法的作用。</p>
<p>program famous;<br>uses libfam;</p>
<p>var<br>   n:longint;<br>   foo,bar:boolean;<br>begin<br>   n:=init;         //初始化，得到N的值<br>   foo:=know(1,3);  //询问1是否认识3<br>   bar:=know(n-1,4);  //询问n-1是否认识4<br>   submit(2);       //所提交的答案为2<br>end.</p>
<p>你如何测试自己的程序<br>    我们为选手准备了一种自我测试的方法。你需要在程序所在目录下建立test.in文件并在此文件下输入相关信息。该文件的构成应该如下：<br>    第一行：一个整数N，代表人数；<br>    第二行到第N+1行：输入一个01矩阵，数字与数字间用空格分隔。其中，第i行的第j个数字表示i是否认识j，“1”表示认识，“0”表示不认识。当i和j相等时，该位置上的0或1没有意义。<br>    一个合法的test.in文件内容可能如下：<br>3<br>1 1 0<br>0 0 0<br>1 1 1<br>    容易看出，该输入文件表明N=3时的情况，其中第2个人是名人。</p>
<p>    你的程序运行时将读取该文件的相关信息并作为此次测试的数据。<br>    程序退出后该目录将生成一个名为famous.log的文件。该文件是日志文件，它详细记录了你的程序与库的交互过程。一些可能出现的情况如下（部分语句较长，用…省略）：<br><span style="font-family:宋体">    Init called more than once.  表明你的程序调用init函数超过1次。<br>    File not exist.              表明目录里找不到test.in文件或无法打开该文件。<br>    Error reading N.             读入数字N时出错。该位置可能有其它字符。<br>    N must between 2 and 1000.   test.in中输入的N范围不正确。N应该在2到1000之间。<br>    Error reading the matrix.    读入01矩阵时出错。该位置可能有其它字符。<br>    Numbers in matrix should…  矩阵中出现了除0和1以外的数字。<br>    No famous person found…    你的输入数据中没有名人。<br>    Init called successfully.    程序调用init成功，继续运行。<br>    Too many queries…          你的询问次数超过2000次，程序被迫终止。<br>    Person # not exist.          你所询问的人不存在。可能你的参数大于了n或小于1。<br>    You asked a same person: #.  你的程序询问了两个相同的人的关系。<br>    No.# : # # TRUE/FALSE        依次说明这是第几次询问、询问的两个编号和返回的结果。<br>    Submitted after # queries.   你的程序成功地提交了答案。同时你可以看到你的总询问次数。<br>    Your answer: #               这是你提交的答案。<br>    Congrats, Your answer…     你提交的答案是正确的。你的程序通过了这次测试。<br>    Oops, Your answer is wrong…你提交的答案是错误的。同时你可以看到正确的答案是多少。</span></p>
<p>评分方法<br>    当你提交的答案与我们的正确答案相符时得10分。我们一共将有10次测试，总共100分。<br>    出现以下情况均不给分：<br>      程序提交的答案错误或没有提交答案；<br>      程序运行时间超过1秒；<br>      程序使用内存空间超过64M；<br>      程序询问次数超过2000次；<br>      程序崩溃或意外退出；<br>      错误访问库导致测试库出错；<br>      程序访问了其它外部文件。</p>
<p>数据规模<br>    对于30%的数据，N&lt;=40；<br>    对于50%的数据，N&lt;=50；<br>    对于70%的数据，N&lt;=200；<br>    对于100%的数据，N&lt;=1000。</p>
</blockquote>
<p>    下面是这个题目的库文件代码：<br><code>unit libfam;</code></p>
<p>interface</p>
<p>function init:longint;<br>function know(a,b:longint):boolean;<br>procedure submit(sol:longint);</p>
<p>implementation</p>
<p>const<br>   limit=2000;</p>
<p>var<br>   map:array[1..1000,1..1000]of longint;<br>   n,ans:longint;<br>   query:longint=0;<br>   flog:text;<br>   inited:boolean=false;</p>
<p>procedure die(msg:string);<br>begin<br>   append(flog);<br>   writeln(flog,msg);<br>   close(flog);<br>   halt(1);<br>end;</p>
<p>procedure wrt(msg:string);<br>begin<br>   append(flog);<br>   writeln(flog,msg);<br>   close(flog);<br>end;</p>
<p>function init:longint;<br>var<br>   i,j:longint;<br>   flag:boolean;<br>begin<br>   if inited then die('Init called more than once.');</p>
<p>   assign(flog, 'famous.log');<br>   rewrite(flog);<br>   close(flog);</p>
<p>   {$i-}<br>   assign(input,'test.in');<br>   reset(input);<br>   if ioresult&lt;&gt;0 then die('File not exist.');<br>   {$i+}</p>
<p>   {$i-}<br>   readln(n);<br>   {$i+}<br>   if ioresult&lt;&gt;0 then die('Error reading N.');<br>   if (n&lt;=1) or (n&gt;1000) then die('N must between 2 and 1000.');</p>
<p>   for i:=1 to n do<br>   for j:=1 to n do<br>   begin<br>      {$i-}<br>      read(map[i,j]);<br>      {$i+}<br>      if ioresult&lt;&gt;0 then die('Error reading the matrix.');<br>      if (map[i,j]&lt;&gt;0) and (map[i,j]&lt;&gt;1) then die('Numbers in matrix should be 0 or 1.');<br>   end;<br>   close(input);</p>
<p>   ans:=-1;<br>   for i:=1 to n do<br>   begin<br>      flag:=true;<br>      for j:=1 to n do if (i&lt;&gt;j) and (map[i,j]=1) then flag:=false;<br>      for j:=1 to n do if (i&lt;&gt;j) and (map[j,i]=0) then flag:=false;<br>      if flag then ans:=i;<br>   end;<br>   if ans=-1 then die('No famous person found in your input data.');</p>
<p>   wrt('Init called successfully.');<br>   inited:=true;<br>   init:=n;<br>end;</p>
<p>function know(a,b:longint):boolean;<br>var<br>   sta,stb,stq:string;<br>begin<br>   inc(query);<br>   str(a,sta);<br>   str(b,stb);<br>   str(query,stq);</p>
<p>   if query&gt;limit then die('Too many queries...');<br>   if (a&lt;1) or (a&gt;n) then die('Person '+sta+' not exist.');<br>   if (b&lt;1) or (b&gt;n) then die('Person '+stb+' not exist.');<br>   if a=b then die('You asked a same person: '+sta+'.');</p>
<p>   if map[a,b]=1 then wrt('No.'+stq+': '+sta+' '+stb+' TRUE')<br>                 else wrt('No.'+stq+': '+sta+' '+stb+' FALSE');<br>   know:=(map[a,b]=1);<br>end;</p>
<p>procedure submit(sol:longint);<br>var<br>   sts,stq,sta:string;<br>begin<br>   str(sol,sts);<br>   str(query,stq);<br>   str(ans,sta);<br>   wrt('');<br>   wrt('Submitted after '+stq+' queries.');<br>   wrt('Your answer: '+sts);<br>   if sol=ans then wrt('Congrats, Your answer is correct!')<br>              else wrt('Oops, Your answer is wrong! The answer should be '+sta+'.');<br>   halt(0);<br>end;</p>
<p>end.</p>
<p>    下面是一个数据生成器。在实际测试中使用的数据文件名并不是“test.in”，防止选手直接读入数据。因此，库的代码中读入部分也要做相应的改动。数据未经过加密，因此这种方法不能彻底防止选手作弊。使用Cena测试时，测试库需要放在Cena目录的compilersbin下。测试库还需要一些其它的改动，比如log文件可以改为只输出该测试点是否得分的信息（在Cena中设置成用答案正确时应该输出的log文件与实际输出的log文件进行对比）。<br><code>const<br>   c:array[0..9]of longint=<br>   (2,30,40,47,50,172,200,532,797,1000);<br>var<br>   a:array[1..1000,1..1000]of longint;<br>   i,j,k,n,t:longint;<br>begin<br>   randseed:=13875;<br>   for k:=0 to 9 do<br>   begin<br>      assign(output,'fam23z.'+chr(k+48)+'.in');<br>      rewrite(output);<br>      n:=c[k];<br>      for i:=1 to n do<br>      for j:=1 to n do a[i,j]:=random(2);<br>      t:=random(n)+1;<br>      for i:=1 to n do a[i,t]:=1;<br>      for i:=1 to n do a[t,i]:=0;<br>      writeln(n);<br>      for i:=1 to n do<br>      begin<br>         for j:=1 to n do write(a[i,j],' ');<br>         writeln;<br>      end;<br>      close(output);<br>   end;<br>end.</code></p>
<p>一个满分程序的代码可能如下：<br><code>uses libfam;<br>var<br>   i,t,n:integer;<br>begin<br>   n:=init;<br>   t:=1;<br>   for i:=2 to n do if know(t,i) then t:=i;<br>   submit(t);<br>end.</code></p>
<p>Matrix67原创<br>转载请注明出处</p>
			 ]]></content>
<pubDate>2007-02-14T22:04:27+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/141</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 2.14 送大家一个我很喜欢的图片 ]]></title>
<link>http://www.matrix67.com/blog/archives/143</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
			 ]]></content>
<pubDate>2007-02-14T22:13:43+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/143</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 我见过的最大的Flash游戏，最有意思的Puzzle类游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/146</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
<p>一个30M的Flash游戏让我入迷。<br>http://www.handmadegame.com/Game_Rooms.htm</p>
<p>    现在的智力游戏非常令人失望，不是什么三个三个的消除，就是什么单词拼写之类的东西。有创意的解谜游戏也见到过，但可玩性不高，不一会儿就搞烦了。今天看到了一个叫做Rooms的游戏，实在让我眼前一亮。或许是神秘的气氛吸引了我，或许是谜题设计很有意思，我很喜欢。<br>    在Rooms中，你处在一个时空混乱的地方，你可以从游戏的背景音乐中感受到《The Lost Room》般的神秘感觉。每一次谜题初始时你都在其中一个房间中，你需要使用各种工具到达那个有出口大门的房间。你可以把你所在的房间当作滑块来移动，也可以使用房间里或者自己携带的各种物品。这个游戏有多么奇妙我完全无法解释，因此给大家看一个完整的过关过程。大家可以看一看其中一关我的解法。</p>
<p><img alt="image placeholder" >
<p>Step 1: 初始状态。我在那个有天空的房间里，我要想办法到右下角去；<br>Step 2: 对我所在的房间进行操作，把这个房间滑动到右边去；<br>Step 3: 房间滑过来了；<br>Step 4: 爬梯子上去，到另外一个写有“Exit”的房间；</p>
<p><img alt="image placeholder" >
<p>Step 5: 把我现在所在的（写有“Exit”的房间）移动到我初始时的位置，然后顺着梯子下去；<br>Step 6: 使用这个房间的道具——电话，像The Matrix一样瞬移到另外一个房间里；<br>Step 7: 瞬移过来了；<br>Step 8: 把这个房间移动上去，然后打电话回来；</p>
<p><img alt="image placeholder" >
<p>Step 9: 瞬移过来后顺着楼梯爬上去，把写有“Exit”的房间移动到大门的正上方；<br>Step 10: 爬楼梯下去；<br>Step 11: Stage Clear With一个很酷的转身动作。</p>
<p>做人要厚道<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-02-23T21:04:00+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/146</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 非传统题型练习：三道答案提交类题目 ]]></title>
<link>http://www.matrix67.com/blog/archives/150</link>
<content><![CDATA[ 
		<p>    不少人可能为找不到非传统题型的练习题而头疼。这几天我专门发出一些用于省选集训的题目供大家参考。</p>
<p><strong>Problem 1: cell 手机<br>题目来源：USACO Contest FEB06 Gold (Translated by Matrix67)</strong></p>
<blockquote>
<p>问题描述<br>    奶牛们已经开始使用手机交流了，但它们发现手机的按键设计不适合它们的蹄子。它们想设计一个新的手机，让它的按键更少，但是更大。<br>    它们喜欢普通手机的一个功能：词语联想。每个按键都有一些字母和它对应，打出一个单词只需要按对应的按键。因为一个按键可能对应多个字母，因此某些单词可能会发生“歧意”。不过，大多数时候这种歧意可以通过用字典判断的方法来消除。<br>    考虑到奶牛们在自定义一款新的手机，它们还需要用奶牛字母表替换英文字母表。神奇的是，奶牛字母表中的字母恰好是英语字母表中的前L个字母，即使顺序也一样。它们想知道如何把这些字母分配给B个按键(1&lt;=B&lt;=L)使得在字典中不会产生歧意的单词最多。就像普通的手机一样，他们希望每个按钮上的字母都是字母表中一段连续的字母。</p>
<p>    这是一个答案提交类的题目。你只需要在你自己的计算机上计算出你的答案，然后把输出文件提交上来。与输入文件cell.3.in相对应的输出文件应该为cell.3.out，这里“3”表示你提交的答案是第3个输入文件的解。当然，其它输出文件需要把这个3替换成相应的数字。你不需要提交任何其它的文件。</p>
<p>输入数据<br>    第一行：一个整数N，表示这是第N个输入文件。<br>    第二行：两个用空格隔开的整数：B和L<br>    第三行：D，字典中的单词数(1&lt;=D&lt;=1000)<br>    第四行到第D+3行：每一行包含一个字典中的单词，用1到10个大写字母表示。这些单词按照字典序给出，并且保证没有重复。</p>
<p>输出数据<br>    第一行：字典中具有唯一的按钮序列的单词数。<br>    第二行到第B+1行：其中的第n行包含有第n个按钮上的字母，用大写的字母按照字典的顺序表示。所有行必须按照字典序排列，每个字母出现恰好一次。如果有多个最优解，选用第一个按键上字母最多的解。如果最优解仍然不唯一，考虑第二个按键上字母最多，依此类推。</p>
<p>样例输入(cell.1.in)<br>1<br>3 13<br>11<br>ALL<br>BALL<br>BELL<br>CALK<br>CALL<br>CELL<br>DILL<br>FILL<br>FILM<br>ILL<br>MILK</p>
<p>样例输出(cell.1.out)<br>7<br>AB<br>CDEFGHIJK<br>LM</p>
<p>样例说明<br>    第一个按键上只有AB两个字母，第二个按键上含有C到K，第三个按键上为LM。单词CELL、DILL、FILL和FILM的输入都是2233，其它7个单词的输入都是唯一的。</p>
</blockquote>
<p>题解(Ctrl+A)：<span style="color:#E5E5E5"><br>    这道题目……搜索，乱搞。</span></p>
<p><strong>Problem 2: selfstr 自描述序列<br>题目来源：Matrix67根据经典问题改编</strong></p>
<blockquote>
<p>问题描述<br>    “这句话里有1个数字零，2个数字一，1个数字二，0个数字三”。</p>
<p>    在N(N&gt;=2)进制中只允许0到N-1这N个数字出现。一个N位的N进制数（允许有前导0）可以由另一个同样多位的数来描述。我们定义一个N位N进制数的描述序列为：左起第i个数字为原数中数字i-1出现的次数。<br>    例如，在4进制中，0023的描述序列为2011，因为0023中有2个0，0个1，1个2和1个3。<br>    我们惊奇地发现，4进制数1210的描述序列是它本身！我们称这样的数叫做“自描述序列”。</p>
<p>    你需要编写程序计算出在某个进制下的自描述序列。一个进制下的自描述序列可能有很多个，你只需要给出其中一个即可。<br>    这是一个答案提交类的问题。你只需要在你自己的计算机上计算出你的答案，然后把输出文件提交上来。与输入文件selfstr.3.in相对应的输出文件应该为selfstr.3.out，这里“3”表示你提交的答案是第3个输入文件的解。当然，其它输出文件需要把这个3替换成相应的数字。你不需要提交任何其它的文件。</p>
<p>输入格式<br>    输入数据只有一个正整数N</p>
<p>输出格式<br>    输出N个字符，它表示N进制下的自描述序列。在高于10的进位制下，大于9的数字请用大写字母表示。<br>    如果有多种可能的解，你只需要输出其中一个。<br>    如果该进制下无解，请输出“NONE”。</p>
<p>样例输入(selfstr.1.in)<br>4</p>
<p>样例输出(selfstr.1.out)<br>1210</p>
</blockquote>
<p>题解：<span style="color:#E5E5E5"><br>    这道题太有意思了！首先，你需要先算几个小数据。你会发现，算到N&gt;=6后，渐渐有规律了：</span></p>
<p><span style="font-family:宋体"><br>   N   N进制下的自描述序列<br>   4    1210 or 2020<br>   5    21200<br>   6    NONE<br>   7    3211000<br>   8    42101000<br>   9    521001000</span></p>
<p>    事实上，这道题目就是考你当搜索到一些解后能不能找到规律得到所有解。这里我们发现，对所有N&gt;6，至少存在一个解为R21(0…0)1000，其中R=N-4，中间0的个数为N-7。结论显然正确。<br>    有可能除了这个之外存在其它的解，因此我们仍然需要写一个check来核对答案。</p>
<p><strong>Problem 3: relation 大小关系<br>题目来源：Matrix67根据经典问题改编</strong></p>
<blockquote>
<p>问题描述<br>    用关系“ &lt; ”和“ = ”将3个数a、b、c依次序排列时，有13种不同的序列关系：<br>      a=b=c, a=b&lt;c, a&lt;b=c, a&lt;b&lt;c, a&lt;c&lt;b<br>      a=c&lt;b, b&lt;a=c, b&lt;a&lt;c, b&lt;c&lt;a, b=c&lt;a<br>      c&lt;a=b, c&lt;a&lt;b, c&lt;b&lt;a</p>
<p>    用这两种关系连接N个数有多少种不同的方案？</p>
<p>    这是一个答案提交类的问题。所有选手将得到10个输入数据，你只需要在你自己的计算机上计算出你的答案，然后把你的答案提交上来。与输入文件relation.x.in相对应的输出文件应该为relation.x.out，这里x表示一个1到10之间的数。</p>
<p>输入格式<br>    输入一个整数，表示N。</p>
<p>输出格式<br>    输出用小于和等于符号将N个数进行有序排列的方案数。</p>
<p>样例输入(relation.1.in)<br>3</p>
<p>样例输出(relation.1.out)<br>13</p>
</blockquote>
<p>题解：<span style="color:#E5E5E5"><br>    组合数学+高精度。由于数据规模很小，我就直接搞成了答案提交类的题目。<br>    下面给出两种递推方法：<br>    Solution 1: N个数中必然存在一个最大的“等价类”，如果这个等价类里有k个数，那么剩下的数就有F(N-k)种排列方案。别忘了我们需要枚举这k个数是哪k个数。于是，F(N)<br>
=C(N,1)F(N-1)+C(N,2)F(N-2)+C(N,3)F(N-3)+ … +C(N,N)F(0)<br>    Solution 2: 用F[ i, j]表示 i个数中有j 个等价类的排列方案（就是说有j-1个小于符号）。第 i个数有可能并入了F[i-1, j]中的 j个等价类中的一个，也有可能不与任何一个已有的数相等，独自成为一个等价类插入F[i-1, j-1]里产生的 j个空位中。于是，F[ i,j ]=F[i-1, j]*j + F[i-1,j-1]*j。</span></p>
<p>其它问题：<br>    如何用Cena评测答案提交类问题？<br>        见http://www.matrix67.com/blog/article.asp?id=176<br>    这些题的数据哪里有？<br>        第一题：http://ace.delos.com/FEB06，GOLD DIVISION里面的第三个<br>        第二题：自己写check，不需要数据<br>        第三题：http://www.research.att.com/~njas/sequences/b000670.txt，吓死你</p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-03-06T14:06:35+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/150</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 非传统题型练习：三道交互式题目 ]]></title>
<link>http://www.matrix67.com/blog/archives/152</link>
<content><![CDATA[ 
		<p><strong>Problem 1: famous 谁是名人<br>题目来源：Matrix67根据经典问题改编</strong></p>
<p>    题目和测试库源码直接见http://www.matrix67.com/blog/article.asp?id=179</p>
<p>题解：<br>    <span style="color:#E5E5E5">显然名人最多有一个。问两个还没有问过的人A和B。如果A认识B，那么A肯定不是名人；如果A不认识B，那么B肯定不是名人。总之，结果无论是什么，总有一个人要排除。由于题目说了一定有名人，那么只需要询问n-1次，每次排除一个人，剩下的肯定就是名人了。</span></p>
<p><strong>Problem 2: meandian 中等工资<br>题目来源：CEOI 2006 有细节改动 (Translated by Matrix67)</strong></p>
<blockquote>
<p>问题描述<br>    一些公司不愿意透露员工的工资，这样可以防止工会的领导者知道员工的报酬有多低，从而避免烦人的涨工资的谈判。不过，有时公司很乐意为统计和市场目的透露一些消息。<br>    其中一个公司愿意回答的问题是这样的形式：“员工A、B、C、D的中等工资是多少”。四个数的“中等值”定义为中间的两个值的算术平均数。更明确的，a,b,c,d的中等值按这样的方式得到：首先对这四个数排序，然后计算排序后的第二个数x和第三个数y的平均数(x+y)/2。你的目标是通过询问一些这种形式的问题来得到员工具体的工资数。注意有一些员工的工资有可能永远不能推出（比如工资最低的那个人）即使所有可能的问题都被问过。<br>    该公司有N(4&lt;=N&lt;=100)名员工，分别用1到N标记。每个员工的工资是一个小于等于100 000的正偶数，且没有两个员工的工资相同。<br>    你将得到一个实现中等值的询问的库。给出四个不同的整数A,B,C,D (1&lt;=A,B,C,D&lt;=N)，这个函数可以返回员工A、B、C、D的中等工资。<br>    写一个程序访问测试库，找出所有员工准确的工资数（除了永远不能确定的以外）。你的程序最多允许询问1000次问题。</p>
<p>交互方法<br>    你将获得的测试库提供了以下三个函数或过程：<br>       function init:longint;<br>       function meandian(a,b,c,d:longint):longint;<br>       procedure solution(var sol:array of longint);<br>    Init：调用该函数不带参数。这个函数必须在程序开头调用且只能调用一次。它将返回一个整数N，即公司的员工数。<br>    Meandian：这个函数被调用时需要带四个参数A、B、C、D。这四个数应该是从1到N的四个不同的数（包括1和N）。它返回一个整数，是员工A、B、C、D的中等工资。<br>    Solution：这个函数应该在程序结尾调用。你需要用一个表示员工工资的整数数组来作为它的参数。如果某个员工的工资不能确定，数组中对应的值应该为-1。<br>    注意这个数组必须从0开始。也就是说员工1的工资应该在数组的0位置，员工2应该在1的位置，依此类推。</p>
<p>    你的源程序在声明处必须包含“uses libmean”。<br>    编译时，你需要把库文件和源文件放在同一个目录。</p>
<p>一个成功交互的例子<br>    下面是一个程序代码的片段。它完全不能解决我们的问题，但它可以告诉你如何使用库函数。</p>
<p>uses libmean;<br>var i, n : integer;<br>    arr : array[0..99] of longint;<br>    foo, bar, quux : integer;<br>begin<br>   n := Init;<br>   foo := Meandian(1, 2, 3, 4);<br>   bar := Meandian(4, 2, 3, 1);<br>   quux := Meandian(n, n-1, n-2, n-3);<br>   for i := 1 to n do<br>      arr[i-1] := 2*i;<br>   arr[3] := -1;<br>   Solution(arr);<br>end.</p>
<p>你如何测试自己的程序<br>    我们提供的库允许你通过标准输入读进数字N和N个偶数来测试你的程序。<br>    这个库将输出一个信息告诉你你的答案是否正确。它同时产生一个包含有你的程序运行的详细信息的文本文件meandian.log。<br>    下面的例子告诉你如何为你的程序输入数据。测试库将告诉你你的答案的正确性。<br>10<br>100 500 200 400 250 300 350 600 550 410</p>
<p>评分方法<br>    当你提交的答案与我们的正确答案相符时得10分。我们一共将有10次测试，总共100分。<br>    出现以下情况均不给分：<br>      程序提交的答案错误或没有提交答案；<br>      程序运行时间超过<span style="color:red">0.1</span>秒；<br>      程序使用内存空间超过64M；<br>      程序询问次数超过1000次；<br>      程序崩溃或意外退出；<br>      错误访问库导致测试库出错；<br>      程序访问了其它外部文件。</p>
<p>数据规模<br>    对于30%的数据，N&lt;=10；<br>    对于50%的数据，N&lt;=50；<br>    对于100%的数据，N&lt;=100。</p>
</blockquote>
<p>题解：<br>    当时我做同步赛时，只有这道题AC了，因此对这道题情有独钟。<br>    <span style="color:#E5E5E5">如果N=4，那么显然一个都问不出来。那么N=5呢？通过下面的方法可以问出这5个人中工资排在中间的那个人是谁，并且知道他的具体工资数。假如这5个人按工资从低到高排序分别为A、B、C、D、E，那么问ABCD和ABCE将得到两个相等的小值（BC的平均数），问ACDE和BCDE将得到两个相等的大值（CD的平均数）。剩下的结果由ABDE产生，其值介于前面两者之间（BD的平均数）。换句话说，把5种问法问个遍，那么得数最大的就是CD的平均数，得数最小的是BC的平均数，剩下的那个就是BD的平均数。根据这三个式子，我们就可以算出BCD的值是什么了。但我们只知道了三个人的工资数，还不知道哪个人对应哪个人。你会发现，你不能确定B和D具体是哪个人，但C是谁我们肯定知道。C所对应的人就是问出BD的平均数的那一次询问里没有被问到的人。<br>    询问5个人可以问出一个人来，那么我们就不断地找5个都还不知道的人重复这个过程。我们不必真的去“找”工资还没确定的人，只需要用一个新的人来代替前一个5人组中问出来了的那个人。这样下去我们只需要不到500次就可以问出N-4个人的具体工资。这种方法不能确定工资最小的两个人和工资最大的两个人。<br>    事实上，我们可以证明这4个人永远不可能被问出来。假如把工资最小的两个人它们对应的工资数交换一下，你会发现所有可能问到的问题答案仍然不变，因此这两个人不能判断谁是谁。对于工资最大的两个人道理相同。</span></p>
<p><strong>Problem 3: gf 谁是我的女友<br>题目来源：Matrix67根据经典问题改编</strong></p>
<blockquote>
<p>问题描述<br>    我们学校有M个男生，N个女生（M&lt;=N&lt;=1000）。每个男生都在这些女生中找到了一个知己。每个男生都恰有一个女友，不同的男生有不同的女友（有N-M</p>
			</blockquote> ]]></content>
<pubDate>2007-03-09T22:15:56+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/152</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 非传统题型练习：解析一道循环赛题目 ]]></title>
<link>http://www.matrix67.com/blog/archives/153</link>
<content><![CDATA[ 
		<p><strong>Problem: game 取数游戏<br>题目来源：Matrix67根据经典问题改编</strong></p>
<blockquote>
<p>问题描述<br>    选数游戏是一个两人游戏。两人将轮流从1到9这九个数字中取数，取过的数不能再取。我们规定，谁取到的数里能找到三个数，使得这三个数的和为15，谁就获得了这次游戏的胜利。如果A取了1、6、7三个数，B取了2、3、5，若这时该A继续取数，则A取8可以获得胜利，因为当A获得了数字8后，出现了1+6+8=15。<br>    在游戏的每一着中，你可以得到此时游戏的状态。请你编程选择一种赢得游戏的最佳策略。</p>
<p>输入格式<br>    第一行输入若干个用空格隔开的数，表示你已经取了的数。这些数递增排列。<br>    第二行输入若干个用空格隔开的数，表示对手已经取了的数。这些数递增排列。<br>    当某一行没有数字（某个游戏者还没有选数）时，该行仍然会留出位置。</p>
<p>输出格式<br>    输出你认为此时你的最佳选择。</p>
<p>样例输入<br>1 6 7<br>2 3 5</p>
<p>样例代码<br>    下面的代码演示了游戏的这样一个策略：每一次总是选择最大的没有被取过的数。</p>
<p>program game;<br>var<br>   hash:array[1..9]of boolean;<br>   i:integer;<br>begin<br>   assign(input,'game.in');<br>   reset(input);<br>   repeat<br>      read(i);<br>      hash[i]:=true;<br>   until eof;<br>   close(input);</p>
<p>   for i:=9 downto 1 do<br>      if not hash[i] then break;<br>   assign(output,'game.out');<br>   rewrite(output);<br>   writeln(i);<br>   close(output);<br>end.</p>
<p>评分方法<br>    该题目将通过选手之间的循环赛进行评分。<br>    在某两个选手对抗时，测试程序将导入这两个选手的源程序并进行编译，然后轮流为选手编写输入文件实时描述对战情况。选手的输出文件将作为此次选手的决策提交上来。当游戏已经出现获胜方或无法继续进行时，测试程序自动结束。每两个选手比赛时将分两场进行，一场对抗后先行者将进行交换。任一次对抗中，选手胜一场得2分，负一场得-2分，平一场得0分（这个分数不是选手该题的最后得分）。对比赛得分进行排名后，若总选手数为n，你的排名为i，那么你的得分为(n-i+1)*100/n。得分为小数则取下整。排名相同则平分该段得分。<br>    选手程序出现以下情况将作为该次对抗的负者处理：<br>        选手程序单着运行时间超过1秒；<br>        选手内存占用超过64M；<br>        选手程序未输出决策或输出错误；<br>        选手程序非正常退出；<br>        选手程序发生错误导致评测程序非法退出。</p>
</blockquote>
<p>    大家有没有看出来，这个游戏就是一个井字棋游戏。3个数加起来等于15一共有8种情况，而这8种情况恰好对应一个3阶幻方中的三个横行、三个纵列和两个对角线。也就是说，如果把这个游戏想成在下面的棋盘中进行，那就和井字棋游戏没什么两样了。</p>
<p><span style="font-family:宋体">   +—+—+—+<br>   | 8 | 1 | 6 |<br>   +—+—+—+<br>   | 3 | 5 | 7 |<br>   +—+—+—+<br>   | 4 | 9 | 2 |<br>   +—+—+—+</span></p>
<p>    关于井字棋游戏，之前我曾有过研究。<br>    原来学博弈论之类的东西时，我曾写过一个程序，计算井字棋游戏的最佳策略。但不管我怎么搞，这个程序总是先走最角落的位置，这是十分可笑的。我一直在想，我的程序哪点儿有问题。后来我想到了。我的程序没有任何问题，而是人的习惯性思考出的错。我的程序计算出来的结果是对的，在井字棋游戏中开局占领一个角的胜算最大。</p>
<p>    比如说，现在我占了最左下角的那一个位置。那么下一步如果你走的是画了“X”的位置，你就输了。</p>
<p><span style="font-family:宋体">   +—+—+—+<br>   | X | X | X |<br>   +—+—+—+<br>   | X |   | X |<br>   +—+—+—+<br>   | O | X | X |<br>   +—+—+—+</span></p>
<p>    下面的图1到图4这四个棋谱，它包含了除第二步走中间以外所有的分支情况。可以看出，如果你第二步不占领中间的话，你是必败的。<br>    图5告诉我们，即使对手占住了中间，第四步棋也有2/6个陷阱可以置他于死地。而另外4/6将导致棋局最终打平。假设每一步对方都是随机走的话，打到图6的情况概率为(1/8) * (4/6)，约为8.33%。反过来，我的胜算超过了90%。这在理论上可能是最大的了。<br>    当然，对手没有那么傻。面对这种情况，理智的人第二步总会想要占领中间的格子。考虑到这一点的话，胜算或许不到50%。</p>
<div align="center"><img alt="image placeholder" >
<p>    仔细思考，你会发现，如果你第一步占领了中间的话，胜算是可以达到50%的。图7表明了这样一种情况，如果你第一步走中间，而对手不小心走到了边上，那么他就完了。比起前面的那些来，这里的陷阱可能更隐蔽一些。<br>    剩下的三个图表明，对手走了4个角中的一个后，最终结果必然是平局。</p>
<p>    至于以上这么多棋谱到底该选用哪一个，这个决策是属于自己的。</p>
<p>    我们考虑自己先行的所有情况的同时，也看清了自己作为后行者可能遇到的陷阱。对照以上棋谱，我们可以轻易获得平局的结果。</p>
<p>    由于井字棋游戏的总的情况数也只有那么多，变数不大，因此这个东西是一个非常入门级的东西。实际写程序的时候，分类讨论的效果比博弈树更好。</p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-03-11T01:52:27+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/153</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 令人称奇的简单证明：五种方法证明根号2是无理数 ]]></title>
<link>http://www.matrix67.com/blog/archives/156</link>
<content><![CDATA[ 
		<p>    我喜欢各种各样的证明。有史以来我见过的最诡异的证明写在http://www.matrix67.com/blog/article.asp?id=34。人们很难想到这样一些完全找不到突破口的东西竟然能够证明得到。说“没有突破口”还不够确切。准确地说，有些命题多数人认为“怎么可能能够证明”却用了一些技巧使得证明变得非常简单。我看了五色定理的证明，定理宣称若要对地图进行染色使得相邻区域不同色，五种颜色就够了。没看证明之前，我一直在想这个玩意儿可以怎么来证明。直到看了证明过程后才感叹居然如此简单，并且立即意识到四色定理基本上也是这种证明方法。还有，像“一个单位正方形里不可能包含两个互不重叠且边长和超过1的小正方形”这样的命题竟然完全用初中学的那些平面几何知识证明到了，简单得不可思议。关键是，我们能够读懂证明过程，但只有牛人才能想到这个证明过程。<br>    今天在OIBH上看到了<a target="_blank" href="http://www.oibh.org/bbs/thread-14336-1-1.html">这个帖子</a>，帖子中<a target="_blank" href="http://yangzheshare.spaces.live.com">哲牛</a>分享的一篇文章<a target="_blank" href="http://www.cs.toronto.edu/~mackay/abstracts/conway.html">The Power Of Mathematics</a>恰好说明了这一点。文章中包含有一个推翻“万物皆数”的新思路，相当有启发性。今天我想把我已经知道的四种证明连同新学到的这一个一起写下来。</p>
<p>    <strong>如何证明存在一种不能表示为两个整数之比的数？</strong><br>    古希腊曾有“万物皆数”的思想，这种认为“大自然的一切皆为整数之比”的思想统治了古希腊数学相当长的一段时间，许多几何命题都是根据这一点来证明的。当时的很多数学证明都隐性地承认了“所有数都可以表示为整数之比”，“万物皆数”的思想是古希腊数学发展的奠基。直到有一天，毕达哥拉斯的学生Hippasus告诉他，单位正方形的对角线长度不能表示为两个整数之比。被人们公认的假设被推翻了，大半命题得证的前提被认定是错的，古希腊时代的数学大厦轰然倒塌，数学陷入了历史上的第一次危机。最后，Eudoxus的出现奇迹般地解决了这次危机。今天我们要看的是，为什么单位正方形的对角线长度不能表示为两个整数之比。<br>       <img alt="image placeholder" >
<p>    根号2是无理数，我们证明到了。根号3呢？根号5呢？你可能偶尔看到过，Theodorus曾证明它们也是无理数。但Theodorus企图证明17的平方根是无理数时却没有继续证下去了。你可以在网上看到，Theodorus对数学的贡献之一就是“证明了3到17的非平方数的根是无理数”。这给后人留下了一个疑问：怪了，为什么证到17就不证了呢？一个俄国的数学历史家“猜”到了原因。<br>    他猜测，当时Theodorus就是用类似上面的方法证明的。比如，要证明根号x不是有理数，于是p^2=x*q^2。我们已经证过x=2的情况了，剩下来的质数都是奇数。如果x是奇数且p/q已经不能再约分，那么显然p和q都是奇数。一个奇数2n+1的平方应该等于4(n^2+n)+1，也即8 * n(n+1)/2 + 1，其中n(n+1)/2肯定是一个整数。如果p=2k+1，q=2m+1，把它们代进p^2=x*q^2，有8[k(k+1)/2 – x*m(m+1)/2] = x-1。于是x-1必须是8的倍数。如果当时Theodorus是这么证明的，那么他可以得到这样一个结论，如果x-1不能被8整除，那么它不可能被表示成(p/q)^2。好了，现在3、5、7、11、13减去1后都不是8的倍数，它们的平方根一定不是有理数。在x=9时发生了一次例外，但9是一个平方数。而当x=17时这种证明方法没办法解释了，于是Theodorus就此打住。</p>
<p>    实际上，我们上面说的这么多，在古希腊当时的数学体系中是根本不可能出现的。毕达哥拉斯时代根本没有发展出代数这门学科来，它们掌握的只是纯粹的几何。因此，Hippasus当时的证明不可能像我们现在这样搞点什么奇数x偶数y之类的高科技东西。事实上，Hippasus当时完全运用的平面几何知识来证明他的结论。有人觉得奇怪了，既然当时没有代数，古希腊人是怎么提出“所有数都可以表示为整数之比”的呢？其实古希腊人根本没有提出什么整数之比，这是后人的一个误解。当时毕达哥拉斯学派提出的，叫做“公度单位”。<br>    两条线段的公度单位，简单的说就是找一个公度量，使得两条线段的长度都是这个公度量的整倍数（于是这个公度量就可以同时作为两条线段的单位长度并用于测量）。寻找公度量的方法相当直观，就是不断把较长的那个线段减去短的那个线段，直到两个线段一样长。熟悉数论的同学一下就明白了这就是欧几里德的辗转相除算法求最大公约数。第一次数学危机的根结就在于，古希腊人理所当然地相信不断地截取线段，总有一个时候会截到两个线段一样长。后来，Hippasus画了这么一张图，告诉大家了一个反例：有可能这个操作会无穷尽地进行下去。<br>       <img alt="image placeholder" >
<p>    有发现上面的代数证明和几何证明之间的共同点吗？它们都是这样的一个思路：假设我已经是满足这个性质的最小的那个了，那么我就可以用一种方法找出更小的一个来，让你无限循环下去，数目越来越小，永</p>
			 ]]></content>
<pubDate>2007-03-14T02:38:45+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/156</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ OIer好帮手：graphviz功能演示 ]]></title>
<link>http://www.matrix67.com/blog/archives/160</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
<p>    原来我经常在想，要是有软件能帮我把图论题的数据画出来就好了。后来我想到一个制作这种软件的方法，就是把所有的点的位置设定为圆周上的等分点，这样可以最大限度的保证图象不致于太乱。我没想到居然有程序可以智能地决定哪个点、哪条边放在哪里更好看。<br>    我在OIBH的<a target="_blank" href="http://www.oibh.org/bbs/viewthread.php?tid=14035">这个帖子</a>里找到了这个好东西，它可以帮助OIer将大规模的图论题数据转化为图便于观察。今天我又用到了几次，突然想到把它介绍在我的Blog上。<br>    graphviz的主页设在http://www.graphviz.org，你可以在<a target="_blank" href="http://www.graphviz.org/Download_windows.php">这里</a>下载到最新的Windows版本，目前最新版本的安装程序为graphviz-2.12.exe。安装后你可以在dos下（任何目录中）调用它的命令行模式。<br>    这里，我们使用<a target="_blank" href="http://www.graphviz.org/doc/info/lang.html">dot语言</a>。官方网站上有关于dot语言的<a target="_blank" href="http://www.graphviz.org/Documentation/dotguide.pdf">详细的用户手册</a>，这里我只把常用的一些功能做一下演示。你可以在这篇日志的三个截图中掌握足够的知识来应用graphviz。<br>    先说明一下最顶上的Hello World程序。dot是程序名，参数-Tgif表示以gif格式输出，参数-O表示输出文件的方式设为默认（在当前目录下输出名为noname的文件，其后缀名与参数-T???所设定的类型相同）。下面一行输入的是graphviz所用的dot语言，digraph G表示有向图，花括号里描述图的内容。这样就生成了一个最简单的图。</p>
<p>    下面一个例子说明了如何输出一个边上有权值的无向图。这是OIer经常要用的东西。size=4,4指定了图的大小，单位为英寸。如果没有这一句的话，默认的图要大得多。你可以另外写一个程序把你的数据按图中的格式转化为dot代码。虽然graphviz可以从外部文件中读入这段代码，但我觉得粘贴进dos窗口更方便一些。</p>
<p>        <img alt="image placeholder" >
<p>    下面这个例子包含更多的参数，展示了graphviz更多的功能。输出为ps文件更好看一些，因为输出ps文件可以反锯齿（应该是矢量的）。
</p>
<div align="center"><img alt="image placeholder" >
			 ]]></content>
<pubDate>2007-03-20T03:35:23+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/160</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 分享三道题目的代码+JavaScript Syntax Highlight测试 ]]></title>
<link>http://www.matrix67.com/blog/archives/161</link>
<content><![CDATA[ 
		<p>    寒假时没事写了这几个代码，算是我几个月后重操键盘了。这是几道经典题目，可能有人需要，再加上昨天搞JavaScript改过去改过来把PJBlog改得面目全非终于实现了代码高亮忍不住想Show一下，于是把这些代码（连同题目）发了上来。</p>
<p><strong>标准的网络流题目代码</strong><br>
</p>
<blockquote>Problem : goods<br>货物运输
<p>问题描述<br>    你第一天接手一个大型商业公司就发生了一件倒霉的事情：公司不小心发送了一批次品。很不幸，你发现这件事的时候，这些次品已经进入了送货网。这个送货网很大，而且关系复杂。你知道这批次品要发给哪个零售商，但是要把这批次品送到他手中有许多种途径。送货网由一些仓库和运输卡车组成，每辆卡车都在各自固定的两个仓库之间单向运输货物。在追查这些次品的时候，有必要保证它不被送到零售商手里，所以必须使某些运输卡车停止运输，但是停止每辆卡车都会有一定的经济损失。你的任务是，在保证次品无法送到零售商的前提下，制定出停止卡车运输的方案，使损失最小。</p>
<p>输入格式<br>    第一行：两个用空格分开的整数N(0&lt;=N&lt;=200)和M(2&lt;=M&lt;=200)。N为运输卡车的数目，M为仓库的数目。1号仓库是公司发货的出口，仓库M属于零售商。<br>    第二行到第N+1行：每行有三个整数，Si、Ei和Ci。Si和Ei(1&lt;=Si,Ei&lt;=M)分别表示这辆卡车的出发仓库和目的仓库，Ci(0&lt;=Ci&lt;=10,000,000)是让这辆卡车停止运输的损失。</p>
<p>输出格式<br>    输出一个整数，即最小的损失数。</p>
<p>样例输入<br>5 4<br>1 2 40<br>1 4 20<br>2 4 20<br>2 3 30<br>3 4 10</p>
<p>样例输出<br>50</p>
<p>样例说明<br><span style="font-family:宋体">         40<br>      1——&gt;2<br>      |      /|<br>      |     / |<br>    20|    /  |30<br>      |  20   |<br>      |  /    |<br>      | /     |<br>      /_     V <br>      4&lt;——3<br>          10</span></p>
<p>    如图，停止1-&gt;4、2-&gt;4、3-&gt;4三条卡车运输线路可以阻止货物从仓库1运输到仓库4，代价为20+20+10=50。</p>
<p>数据规模<br>    对于50%的数据，N,M&lt;=25<br>    对于100%的数据，N,M&lt;=200</p>
</blockquote>
<p><code>program goods;</code></p>
<p>const<br>   MaxN=200;<br>   MaxM=200;<br>   Infinite=Maxlongint;</p>
<p>type<br>   rec=record<br>         node,father:integer;<br>         minf:longint;<br>       end;</p>
<p>var<br>   f,c:array[1..MaxN,1..MaxN]of longint;<br>   queue:array[1..MaxN]of rec;<br>   hash:array[1..MaxN]of boolean;<br>   n,m,closed,open:integer;</p>
<p>procedure readp;<br>var<br>   i,x,y:integer;<br>   t:longint;<br>begin<br>   readln(m,n);<br>   for i:=1 to m do<br>   begin<br>      readln(x,y,t);<br>      c[x,y]:=c[x,y]+t;<br>   end;<br>end;</p>
<p>function FindPath:boolean;</p>
<p>   procedure Init;<br>   begin<br>      fillchar(hash,sizeof(hash),0);<br>      fillchar(queue,sizeof(queue),0);<br>      closed:=0;<br>      open:=1;<br>      queue[1].node:=1;<br>      queue[1].father:=0;<br>      queue[1].minf:=Infinite;<br>      hash[1]:=true;<br>   end;</p>
<p>   function min(a,b:longint):longint;<br>   begin<br>      if a&lt;b then min:=a<br>      else min:=b;<br>   end;</p>
<p>var<br>   i,NodeNow:integer;<br>begin<br>   Init;<br>   repeat<br>      inc(closed);<br>      NodeNow:=queue[closed].node;<br>      for i:=1 to n do if not hash[i] then<br>         if (f[NodeNow,i]&lt;c[NodeNow,i]) then<br>         begin<br>            inc(open);<br>            queue[open].node:=i;<br>            queue[open].father:=closed;<br>            queue[open].minf:=min(queue[closed].minf,c[NodeNow,i]-f[NodeNow,i]);<br>            hash[i]:=true;<br>            if i=n then exit(true);<br>         end;<br>   until closed&gt;=open;<br>   exit(false);<br>end;</p>
<p>procedure AddPath;<br>var<br>   i,j:integer;<br>   delta:longint;<br>begin<br>   delta:=queue[open].minf;<br>   i:=open;<br>   repeat<br>      j:=queue[i].father;<br>      inc(f[queue[j].node,queue[i].node],delta);<br>      dec(f[queue[i].node,queue[j].node],delta);<br>      i:=j;<br>   until i=0;<br>end;</p>
<p>procedure writep;<br>var<br>   i:integer;<br>   ans:longint=0;<br>begin<br>   for i:=1 to n do<br>      ans:=ans+f[1,i];<br>   writeln(ans);<br>end;</p>
<p>{====main====}<br>begin<br>   assign(input,'goods.in');<br>   reset(input);<br>   readp;<br>   close(input);</p>
<p>   while FindPath do AddPath;</p>
<p>   assign(output,'goods.out');<br>   rewrite(output);<br>   writep;<br>   close(output);<br>end.</p>
<p><strong>统计逆序对 Treap版</strong><br>
</p>
<blockquote>Problem : inverse<br>逆序对
<p>问题描述<br>    在一个排列中，前面出现的某个数比它后面的某个数大，即当Ai&gt;Aj且i&lt;j时，则我们称Ai和Aj为一个逆序对。给出一个1到N的排列，编程求出逆序对的个数。</p>
<p>输入格式<br>    第一行输入一个正整数N；<br>    第二行有N个用空格隔开的正整数，这是一个1到N的排列。</p>
<p>输出格式<br>    输出输入数据中逆序对的个数。</p>
<p>样例输入<br>4<br>3 1 4 2</p>
<p>样例输出<br>3</p>
<p>样例说明<br>    在输入数据中，(3,1)、(3,2)和(4,2)是仅有的三个逆序对。</p>
<p>数据规模<br>    对于30%的数据，N&lt;=1000；<br>    对于100%的数据，N&lt;=100 000。<br><code>program inverse;</code></p>
<p>const<br>   MaxH=Maxlongint;<br>   <br>type<br>   p=^rec;<br>   rec=record<br>          v,s,h:longint;<br>          left,right:p;<br>       end;</p>
<p>var<br>   header:p=nil;<br>   ans:int64=0;</p>
<p>procedure CalcuS(var w:p);<br>begin<br>   w^.s:=1;<br>   if w^.right&lt;&gt;nil then inc(w^.s,w^.right^.s);<br>   if w^.left&lt;&gt;nil then inc(w^.s,w^.left^.s);<br>end;</p>
<p>function RotateLeft(w:p):p;<br>var<br>   tmp:p;<br>begin<br>   tmp:=w^.left;<br>   w^.left:=tmp^.right;<br>   tmp^.right:=w;<br>   exit(tmp);<br>end;</p>
<p>function RotateRight(w:p):p;<br>var<br>   tmp:p;<br>begin<br>   tmp:=w^.right;<br>   w^.right:=tmp^.left;<br>   tmp^.left:=w;<br>   exit(tmp);<br>end;</p>
<p>function Insert(a:longint;w:p):p;<br>begin<br>  if w=nil then<br>  begin<br>     new(w);<br>     w^.v:=a;<br>     w^.h:=random(MaxH);<br>     w^.s:=1;<br>     w^.left:=nil;<br>     w^.right:=nil;<br>  end</p>
<p>  else if a&lt;w^.v then<br>  begin<br>     ans:=ans+1;<br>     if w^.right&lt;&gt;nil then ans:=ans+w^.right^.s;<br>     w^.left:=Insert(a,w^.left);<br>     if w^.left^.h&lt;w^.h then<br>     begin<br>        w:=RotateLeft(w);<br>        CalcuS(w^.right);<br>     end else<br>        CalcuS(w^.left);<br>  end</p>
<p>  else if a&gt;w^.v then<br>  begin<br>     w^.right:=Insert(a,w^.right);<br>     if w^.right^.h&lt;w^.h then<br>     begin<br>        w:=RotateRight(w);<br>        CalcuS(w^.left);<br>     end else<br>        CalcuS(w^.right);<br>  end;</p>
<p>  exit(w);<br>end;</p>
<p>{====main====}<br>var<br>   n,i,t:longint;<br>begin<br>   randseed:=2910238;<br>   <br>   assign(input,'inverse.in');<br>   reset(input);<br>   readln(n);<br>   for i:=1 to n do<br>   begin<br>      read(t);<br>      header:=Insert(t,header);<br>   end;<br>   close(input);</p>
<p>   assign(output,'inverse.out');<br>   rewrite(output);<br>   writeln(ans);<br>   close(output);<br>end.</p>
<p><strong>USACO经典题目：矩形颜色（离散化+扫描）</strong><br>
</p>
<blockquote>Problem : rect<br>矩形颜色
<p>问题描述<br>　　N个不同颜色的不透明长方形(1&lt;=N&lt;=1000)被放置在一张宽为A长为B的白纸上。这些长方形被放置时，保证了它们的边与白纸的边缘平行。所有的长方形都放置在白纸内，所以我们会看到不同形状的各种颜色。坐标系统的原点(0,0)设在这张白纸的左下角，而坐标轴则平行于边缘。</p>
<p>输入数据<br>    每行输入的是放置长方形的方法。第一行输入的是那个放在最底下的长方形（即白纸）。<br>    第一行：A、B和N，由空格分开(1&lt;=A,B&lt;=10,000)<br>    第二到N+1行：每行为五个整数llx,lly,urx,ury,color。这是一个长方形的左下角坐标，右上角坐标和颜色。颜色1和底部白纸的颜色相同。</p>
<p>输出数据<br>    输出文件应该包含一个所有能被看到的颜色连同该颜色的总面积的清单（即使颜色的区域不是连续的），按color的增序顺序。<br>    不要打印出最后不能看到的颜色。</p>
<p>样例输入<br>20 20 3<br>2 2 18 18 2<br>0 8 19 19 3<br>8 0 10 19 4</p>
<p>样例输出<br>1 91<br>2 84<br>3 187<br>4 38</p>
<p>数据规模<br>    对于50%的数据，A,B&lt;=300，N&lt;=60；<br>    对于100%的数据，A,B&lt;=10000，N&lt;=1000。</p>
</blockquote>
<p><code>program rect;</code></p>
<p>const<br>   MaxN=1000;       { Rect number in the Worst Case }<br>   MaxCol=1000;     { Color number in the Worst Case }<br>   Infinity=Maxint; { Set to be Heap[0] }</p>
<p>type<br>   RecSeg=record<br>            y,x1,x2,order:integer;<br>          end;<br>var<br>   xar,heap:array[0..MaxN*2+2]of integer; { Array of All X-Value and Heap, respectively }<br>   color:array[1..MaxN+1]of integer;      { Index of Color corresponding to order}<br>   ans:array[1..MaxCol]of longint;        { Answers to be print }<br>   seg:array[0..MaxN*2+2]of RecSeg;       { Horizontal Segments }<br>   hash:array[1..MaxN*2+2]of boolean;     { Determine if a Segment has been scanned }<br>   n,HeapSize:integer;</p>
<p>procedure SwapInt(var a,b:integer);<br>var<br>   tmp:integer;<br>begin<br>   tmp:=a;<br>   a:=b;<br>   b:=tmp;<br>end;</p>
<p>procedure SwapRec(var a,b:RecSeg);<br>var<br>   tmp:RecSeg;<br>begin<br>   tmp:=a;<br>   a:=b;<br>   b:=tmp;<br>end;</p>
<p>procedure DataInsert(start,x1,y1,x2,y2,col,order:integer);<br>var<br>   tmp:RecSeg;<br>begin<br>   xar[start]:=x1;<br>   xar[start+1]:=x2;<br>   color[start div 2+1]:=col;</p>
<p>   tmp.order:=order;<br>   tmp.y:=y1;<br>   tmp.x1:=x1;<br>   tmp.x2:=x2;<br>   seg[start]:=tmp;</p>
<p>   tmp.y:=y2;<br>   seg[start+1]:=tmp;<br>end;</p>
<p>procedure Readp;<br>var<br>   a,b,x1,x2,y1,y2,col,i:integer;<br>begin<br>   readln(a,b,n);<br>   n:=n+1;<br>   DataInsert(1,0,0,a,b,1,1);<br>   for i:=2 to n do<br>   begin<br>      readln(x1,y1,x2,y2,col);<br>      DataInsert(2*i-1,x1,y1,x2,y2,col,i);<br>   end;<br>end;</p>
<p>procedure SortXar;<br>var<br>   i,j:integer;<br>begin<br>   for i:=1 to 2*n do<br>   for j:=1 to 2*n-1 do<br>      if xar[j]&gt;xar[j+1] then SwapInt(xar[j],xar[j+1]);<br>end;</p>
<p>procedure SortSeg;<br>var<br>   i,j:integer;<br>begin<br>   for i:=1 to 2*n do<br>   for j:=1 to 2*n-1 do<br>      if seg[j].y&gt;seg[j+1].y then SwapRec(seg[j],seg[j+1]);<br>end;</p>
<p>procedure HeapInsert(x:integer);<br>var<br>   w:integer;<br>begin<br>   inc(HeapSize);<br>   w:=HeapSize;<br>   while Heap[w shr 1]&lt;x do<br>   begin<br>      Heap[w]:=Heap[w shr 1];<br>      w:=w shr 1;<br>   end;<br>   Heap[w]:=x;<br>end;</p>
<p>procedure HeapDelete;<br>var<br>&amp;n<br>
bsp;  x:integer;<br>   w:integer=1;<br>begin<br>   x:=Heap[HeapSize];<br>   dec(HeapSize);<br>   while w shl 1&lt;=HeapSize do<br>   begin<br>      w:=w shl 1;<br>      if (w&lt;&gt;HeapSize) and (Heap[w+1]&gt;Heap[w]) then inc(w);<br>      if Heap[w]&gt;x then Heap[w shr 1]:=Heap[w]<br>      else begin<br>         w:=w shr 1;<br>         break;<br>      end;<br>   end;<br>   Heap[w]:=x;<br>end;</p>
<p>procedure Scan(x1,x2:integer);<br>var<br>   i:integer;<br>   j:integer=0;<br>begin<br>   for i:=1 to 2*n do if (seg[i].x1&lt;=x1) and (seg[i].x2&gt;=x2) then<br>   begin<br>      inc(ans[Color[Heap[1]]],(x2-x1)*(seg[i].y-seg[j].y));<br>      hash[seg[i].order]:=not hash[seg[i].order];<br>      if hash[seg[i].order] then HeapInsert(seg[i].order)<br>         else while (HeapSize&gt;0) and not hash[Heap[1]] do HeapDelete;<br>      j:=i;<br>   end;<br>end;</p>
<p>procedure Solve;<br>var<br>   i:integer;<br>begin<br>   for i:=1 to 2*n-1 do if xar[i]&lt;xar[i+1] then<br>   begin<br>      fillchar(Heap,Sizeof(Heap),0);<br>      fillchar(hash,Sizeof(hash),0);<br>      HeapSize:=0;<br>      Heap[0]:=Infinity;<br>      Scan(xar[i],xar[i+1]);<br>   end;<br>end;</p>
<p>procedure Writep;<br>var<br>   i:integer;<br>begin<br>   for i:=1 to MaxCol do<br>      if ans[i]&gt;0 then writeln(i,' ',ans[i]);<br>end;</p>
<p>{====main====}<br>begin<br>   assign(input,'rect.in');<br>   reset(input);<br>   assign(output,'rect.out');<br>   rewrite(output);</p>
<p>   Readp;<br>   SortXar;<br>   SortSeg;<br>   Solve;<br>   Writep;</p>
<p>   close(input);<br>   close(output);<br>end.</p>
<p>    这几天大家发现我改PJBlog改错了什么东西导致Bug的话麻烦帮忙报告一下。事实上很有可能有人发现有Bug但是不能报告，因为我很有可能把验证码系统也搞坏了。<br>    如果这几天大家没有发现问题的话，我把这几天我的PJBlog个性修改方法和心得写出来分享一下（越来越喜欢搞Web Design了）。</p>
<p>做人要厚道<br>转贴请注明出处<br>（这篇日志没什么技术含量，感觉写上这两句很别扭）</p>
			</blockquote> ]]></content>
<pubDate>2007-03-21T21:15:40+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/161</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 从零开始学算法：十种排序算法介绍（上） ]]></title>
<link>http://www.matrix67.com/blog/archives/166</link>
<content><![CDATA[ 
		<p>    今天我正式开始按照<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=188">我的目录</a>写我的OI心得了。我要把我所有学到的OI知识传给以后千千万万的OIer。以前写过的一些东西不重复写了，但我最后将会重新整理，使之成为一个完整的教程。<br>    按照我的目录，讲任何东西之前我都会先介绍时间复杂度的相关知识，以后动不动就会扯到这个东西。这个已经写过了，你可以在<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=134">这里</a>看到那篇又臭又长的文章。在讲排序算法的过程中，我们将始终围绕时间复杂度的内容进行说明。<br>    我把这篇文章称之为“从零开始学算法”，因为排序算法是最基础的算法，介绍算法时从各种排序算法入手是最好不过的了。</p>
<p>    给出n个数，怎样将它们从小到大排序？下面一口气讲三种常用的算法，它们是最简单的、最显然的、最容易想到的。选择排序(Selection Sort)是说，每次从数列中找出一个最小的数放到最前面来，再从剩下的n-1个数中选择一个最小的，不断做下去。插入排序(Insertion Sort)是，每次从数列中取一个还没有取出过的数，并按照大小关系插入到已经取出的数中使得已经取出的数仍然有序。冒泡排序(Bubble Sort)分为若干趟进行，每一趟排序从前往后比较每两个相邻的元素的大小（因此一趟排序要比较n-1对位置相邻的数）并在每次发现前面的那个数比紧接它后的数大时交换位置；进行足够多趟直到某一趟跑完后发现这一趟没有进行任何交换操作（最坏情况下要跑n-1趟，这种情况在最小的数位于给定数列的最后面时发生）。事实上，在第一趟冒泡结束后，最后面那个数肯定是最大的了，于是第二次只需要对前面n-1个数排序，这又将把这n-1个数中最小的数放到整个数列的倒数第二个位置。这样下去，冒泡排序第i趟结束后后面i个数都已经到位了，第i+1趟实际上只考虑前n-i个数（需要的比较次数比前面所说的n-1要小）。这相当于用数学归纳法证明了冒泡排序的正确性：实质与选择排序相同。上面的三个算法描述可能有点模糊了，没明白的话网上找资料，代码和动画演示遍地都是。<br><img alt="image placeholder" >
<p>    我们来算一下最坏情况下三种算法各需要多少次比较和赋值操作。<br>    选择排序在第i次选择时赋值和比较都需要n-i次（在n-i+1个数中选一个出来作为当前最小值，其余n-i个数与当前最小值比较并不断更新当前最小值），然后需要一次赋值操作。总共需要n(n-1)/2次比较与n(n-1)/2+n次赋值。<br>    插入排序在第i次寻找插入位置时需要最多i-1次比较（从后往前找到第一个比待插入的数小的数，最坏情况发生在这个数是所有已经取出的数中最小的一个的时候），在已有数列中给新的数腾出位置需要i-1次赋值操作来实现，还需要两次赋值借助临时变量把新取出的数搬进搬出。也就是说，最坏情况下比较需要n(n-1)/2次，赋值需要n(n-1)/2+2n次。我这么写有点误导人，大家不要以为程序的实现用了两个数组哦，其实一个数组就够了，看看上面的演示就知道了。我只说算法，一般不写如何实现。学算法的都是强人，知道算法了都能写出一个漂亮的代码来。<br>    冒泡排序第i趟排序需要比较n-i次，n-1趟排序总共n(n-1)/2次。给出的序列逆序排列是最坏的情况，这时每一次比较都要进行交换操作。一次交换操作需要3次赋值实现，因此冒泡排序最坏情况下需要赋值3n(n-1)/2次。<br>    按照渐进复杂度理论，忽略所有的常数，三种排序的最坏情况下复杂度都是一样的：O(n^2)。但实际应用中三种排序的效率并不相同。实践证明（政治考试时每道大题都要用这四个字），插入排序是最快的（虽然最坏情况下与选择排序相当甚至更糟），因为每一次插入时寻找插入的位置多数情况只需要与已有数的一部分进行比较（你可能知道这还能二分）。你或许会说冒泡排序也可以在半路上完成，还没有跑到第n-1趟就已经有序。但冒泡排序的交换操作更费时，而插入排序中找到了插入的位置后移动操作只需要用赋值就能完成（你可能知道这还能用move）。本文后面将介绍的一种算法就利用插入排序的这些优势。</p>
<p>    我们证明了，三种排序方法在最坏情况下时间复杂度都是O(n^2)。但大家想过吗，这只是最坏情况下的。在很多时候，复杂度没有这么大，因为插入和冒泡在数列已经比较有序的情况下需要的操作远远低于n^2次（最好情况下甚至是线性的）。抛开选择排序不说（因为它的复杂度是“死”的，对于选择排序没有什么“好”的情况），我们下面探讨插入排序和冒泡排序在特定数据和平均情况下的复杂度。<br>    你会发现，如果把插入排序中的移动赋值操作看作是把当前取出的元素与前面取出的且比它大的数逐一交换，那插入排序和冒泡排序对数据的变动其实都是相邻元素的交换操作。下面我们说明，若只能对数列中相邻的数进行交换操作，如何计算使得n个数变得有序最少需要的交换次数。<br>    我们定义逆序对的概念。假设我们要把数列从小到大排序，一个逆序对是指的在原数列中，左边的某个数比右边的大。也就是说，如果找到了某个i和j使得i&lt;j且Ai&gt;Aj，我们就说我们找到了一个逆序对。比如说，数列3,1,4,2中有三个逆序对，而一个已经有序的数列逆序对个数为0。我们发现，交换两个相邻的数最多消除一个逆序对，且冒泡排序（或插入排序）中的一次交换恰好能消除一个逆序对。那么显然，原数列中有多少个逆序对冒泡排序（或插入排序）就需要多少次交换操作，这个操作次数不可能再少。<br>    若给出的n个数中有m个逆序对，插入排序的时间复杂度可以说是O(m+n)的，而冒泡排序不能这么说，因为冒泡排序有很多“无用”的比较（比较后没有交换），这些无用的比较超过了O(m+n)个。从这个意义上说，插入排序仍然更为优秀，因为冒泡排序的复杂度要受到它跑的趟数的制约。一个典型的例子是这样的数列：8, 2, 3, 4, 5, 6, 7, 1。在这样的输入数据下插入排序的优势非常明显，冒泡排序只能哭着喊上天不公。<br>    然而，我们并不想计算排序算法对于某个特定数据的效率。我们真正关心的是，对于所有可能出现的数据，算法的平均复杂度是多少。不用激动了，平均复杂度并不会低于平方。下面证明，两种算法的平均复杂度仍然是O(n^2)的。<br>    我们仅仅证明算法需要的交换次数平均为O(n^2)就足够了。前面已经说过，它们需要的交换次数与逆序对的个数相同。我们将证明，n个数的数列中逆序对个数平均O(n^2)个。<br>    计算的方法是十分巧妙的。如果把给出的数列反过来（从后往前倒过来写），你会发现原来的逆序对现在变成顺序的了，而原来所有的非逆序对现在都成逆序了。正反两个数列的逆序对个数加起来正好就是数列所有数对的个数，它等于n(n-1)/2。于是，平均每个数列有n(n-1)/4个逆序对。忽略常数，逆序对平均个数O(n^2)。<br>    上面的讨论启示我们，要想搞出一个复杂度低于平方级别的排序算法，我们需要想办法能把离得老远的两个数进行操作。</p>
<p>    人们想啊想啊想啊，怎么都想不出怎样才能搞出复杂度低于平方的算法。后来，英雄出现了，Donald Shell发明了一种新的算法，我们将证明它的复杂度最坏情况下也没有O(n^2) （似乎有人不喜欢研究正确性和复杂度的证明，我会用实例告诉大家，这些证明是非常有意思的）。他把这种算法叫做Shell增量排序算法（大家常说的希尔排序）。<br>    Shell排序算法依赖一种称之为“排序增量”的数列，不同的增量将导致不同的效率。假如我们对20个数进行排序，使用的增量为1,3,7。那么，我们首先对这20个数进行“7-排序”(7-sortedness)。所谓7-排序，就是按照位置除以7的余数分组进行排序。具体地说，我们将把在1、8、15三个位置上的数进行排序，将第2、9、16个数进行排序，依此类推。这样，对于任意一个数字k，单看A(k), A(k+7), A(k+14), …这些数是有序的。7-排序后，我们接着又进行一趟3-排序（别忘了我们使用的排序增量为1,3,7）。最后进行1-排序（即普通的排序）后整个Shell算法完成。看看我们的例子：</p>
<p><span style="font-family:宋体">  3 7 9 0 5 1 6 8 4 2 0 6 1 5 7 3 4 9 8 2  &lt;– 原数列<br>  3 3 2 0 5 1 5 7 4 4 0 6 1 6 8 7 9 9 8 2  &lt;– 7-排序后<br>  0 0 1 1 2 2 3 3 4 4 5 6 5 6 8 7 7 9 8 9  &lt;– 3-排序后<br>  0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9  &lt;– 1-排序后（完成）</span></p>
<p>    在每一趟、每一组的排序中我们总是使用插入排序。仔细观察上面的例子你会发现是什么导致了Shell排序的高效。对，每一趟排序将使得数列部分有序，从而使得以后的插入排序很快找到插入位置。我们下面将紧紧围绕这一点来证明Shell排序算法的时间复杂度上界。<br>    只要排序增量的第一个数是1，Shell排序算法就是正确的。但是不同的增量将导致不同的时间复杂度。我们上面例子中的增量(1, 3, 7, 15, 31, …, 2^k-1)是使用最广泛的增量序列之一，可以证明使用这个增量的时间复杂度为O(n√n)。这个证明很简单，大家可以参看一些其它的资料，我们今天不证明它。今天我们证明，使用增量1, 2, 3, 4, 6, 8, 9, 12, 16, …, 2^p*3^q，时间复杂度为O(n*(log n)^2)。<br>    很显然，任何一个大于1的正整数都可以表示为2x+3y，其中x和y是非负整数。于是，如果一个数列已经是2-排序的且是3-排序的，那么对于此时数列中的每一个数A(i)，它的左边比它大的只有可能是A(i-1)。A2绝对不可能比A12大，因为10可以表示为两个2和两个3的和，则A2&lt;A4&lt;A6&lt;A9&lt;A12。那么，在这个增量中的1-排序时每个数找插入位置只需要比较一次。一共有n个数，所以1-排序是O(n)的。事实上，这个增量中的2-排序也是O(n)，因为在2-排序之前，这个数列已经是4-排序且6-排序过的，只看数列的奇数项或者偶数项（即单看每一组）的话就又成了刚才的样子。这个增量序列巧妙就巧妙在，如果我们要进行h-排序，那么它一定是2h-排序过且3h-排序过，于是处理每个数A(i)的插入时就只需要和A(i-h)进行比较。这个结论对于最开始几次（h值较大时）的h-排序同样成立，当2h、3h大于n时，按照定义，我们也可以认为数列是2h-排序和3h-排序的，这并不影响上述结论的正确性（你也可以认为h太大以致于排序时每一组里的数字不超过3个，属于常数级）。现在，这个增量中的每一趟排序都是O(n)的，我们只需要数一下一共跑了多少趟。也就是说，我们现在只需要知道小于n的数中有多少个数具有2^p*3^q的形式。要想2^p*3^q不超过n，p的取值最多O(log n)个，q的取值最多也是O(log n)个，两两组合的话共有O(logn*logn)种情况。于是，这样的增量排序需要跑O((log n)^2)趟，每一趟的复杂度O(n)，总的复杂度为O(n*(log n)^2)。早就说过了，证明时间复杂度其实很有意思。<br>    我们自然会想，有没有能使复杂度降到O(nlogn)甚至更低的增量序列。很遗憾，现在没有任何迹象表明存在O(nlogn)的增量排序。但事实上，很多时候Shell排序的实际效率超过了O(nlogn)的排序算法。</p>
<p>    后面我们将介绍三种O(nlogn)的排序算法和三种线性时间的排序算法。最后我们将以外部排序和排序网络结束这一章节。</p>
<p>    很多人问到我关于转贴的问题。我欢迎除商业目的外任何形式的转贴（论坛、Blog、Wiki、个人网站、PodCast，甚至做成ppt、pdf），但一定要注明出处，最好保留原始链接。我的网站需要点反向链接才能在网络中生存下去，大家也都可以关注并且推广这个Blog。我一直支持cc版权协议，因此发现了文章中的问题或者想要补充什么东西尽管提出来，好让更多的人学习到好东西。我昨天看Blog上原来写的一些东西，居然连着发现了几个错误式子和错别字，好奇大家居然没有提出来。发现了问题真的要告诉我，即使格式有点问题也要说一下，决不能让它那么错着。另外有什么建议或想法也请说一下，我希望听到不同的声音不同的见解，好让我决定这类文章以后的发展方向。</p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-03-31T23:23:40+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/166</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 终于AC了：用BrainFuck语言过SPOJ测试题 ]]></title>
<link>http://www.matrix67.com/blog/archives/168</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
<p>    SPOJ的多语言确实很牛，竟然连WhiteSpace语言也支持（很早就听说过这种语言，它的代码仅仅包含空格、Tab和回车三个字符，其余字符一律不认）。今天，我在提交语言的列表里看到了另一个叫brainf**k的语言，顿时来了兴趣。<br>    brainf**k=BrainFuck。如果哪天我发明一种语言叫“太他妈的牛逼了”，矜持一点的OJ也会称呼它“太XXX牛B语言”。这种语言符合图灵机模型，语法暴简单，通篇8种字符，一看就会：<br>
</p>
<blockquote>&gt;  指针加一<br>&lt;  指针减一<br>+  指针指向的字节的值加一<br>–  指针指向的字节的值减一<br>.  输出指针指向的单元内容(ASCII码)<br>,  输入内容到指针指向的单元(ASCII码)<br>[  如果指针指向的单元值为零，向前跳转到对应的]指令的次一指令处<br>]  如果指针指向的单元值不为零，向回跳转到对应的[指令的次一指令处</blockquote>
<p>比如，下面这段代码可以在屏幕上打印出“Hello World!”：<br><code>++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]<br>&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.<br>&gt;.+++.------.--------.&gt;+.&gt;.</code></p>
<p>    后来，我看了看SPOJ的第一题，读一串数，读什么你就输出什么，直到你读到一个数字42位置。这个题目出得比A+B Prob要好，因为几乎所有的语言都可以AC。我决定用BrainFuck把这道题过了。我仔细想了一下，主要是在想如何用这个语言来表示and运算。后来调试了一会儿，发现了几个错误，最终成功AC了。给大家看一下我的AC代码：<br><code>&gt;&gt;,&gt;,<br>&lt; &lt;&lt;++++++[&gt;&gt;--------&lt;&lt;-]&gt;&gt;---- [&gt;&gt;+&gt;]&lt;[&lt;]&gt; &lt;&lt;++++++[&gt;&gt;++++++++&lt;&lt;-]&gt;&gt;++++<br>&gt; &lt;&lt;++++++[&gt;&gt;--------&lt;&lt;-]&gt;&gt;-- [&gt;+&gt;]&lt;[&lt;]&gt;&gt; &lt;&lt;++++++[&gt;&gt;++++++++&lt;&lt;-]&gt;&gt;++ &gt;<br>[&lt;&lt;. [-]&gt;[-&lt;+&gt;],&gt;[-]&lt;&lt;<br>&lt;&lt;++++++[&gt;&gt;--------&lt;&lt;-]&gt;&gt;---- [&gt;&gt;+&gt;]&lt;[&lt;]&gt; &lt;&lt;++++++[&gt;&gt;++++++++&lt;&lt;-]&gt;&gt;++++<br>&gt;&lt;&lt;++++++[&gt;&gt;--------&lt;&lt;-]&gt;&gt;-- [&gt;+&gt;]&lt;[&lt;]&gt;&gt; &lt;&lt;++++++[&gt;&gt;++++++++&lt;&lt;-]&gt;&gt;++ &gt;]</code></p>
<p>    后来我看到了SPOJ论坛上的一个标程，虽然标程比我的代码长得多，但也漂亮的多。<br><code>+[&gt;&gt;----------<br>[++++++++++&lt;,----------]<br>&gt;--------------------------------------------------<br>&gt;----------------------------------------------------<br>&gt;</code></p>
<p>[<br>&lt;++++++++++++++++++++++++++++++++++++++++++++++++++++<br>&lt;++++++++++++++++++++++++++++++++++++++++++++++++++<br>[&gt;]&lt;<br>[.&lt;]++++++++++.----------&gt;<br>[&gt;]&gt;&gt;<br>]&lt;</p>
<p>[++++++++++++++++++++++++++++++++++++++++++++++++++++<br>&lt;++++++++++++++++++++++++++++++++++++++++++++++++++<br>[&gt;]&lt;<br>[.&lt;]++++++++++.----------&gt;<br>[&gt;]&gt;<br>]&lt;</p>
<p>[&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++<br>&lt;++++++++++++++++++++++++++++++++++++++++++++++++++<br>[&gt;]&lt;<br>[.&lt;]++++++++++.----------&gt;<br>[&gt;]<br>]&lt;</p>
<p>] </p>
<p>    任何一个领域里总是有牛人出现。我在网上看到，居然还有BrainFuck编程比赛。比如，有一次比赛题目叫大家用BrainFuck语言编写3x+1问题。输入一串数，你需要编程求出这些数按照3x+1变换规则进入循环各自需要多少步。标程短得惊人：<br><code>&gt;,[<br>    [<br>        ----------[<br>            &gt;&gt;&gt;[&gt;&gt;&gt;&gt;]+[[-]+&lt;[-&gt;&gt;&gt;&gt;++&gt;&gt;&gt;&gt;+[&gt;&gt;&gt;&gt;]++[-&gt;+&lt;&lt;&lt;&lt;&lt;]]&lt;&lt;&lt;]<br>            ++++++[&gt;------&lt;-]&gt;--[&gt;&gt;[-&gt;&gt;&gt;&gt;]+&gt;+[&lt;&lt;&lt;&lt;]&gt;-],&lt;<br>        ]&gt;<br>    ]&gt;&gt;&gt;++&gt;+&gt;&gt;[<br>        &lt;&lt;[&gt;&gt;&gt;&gt;[-]+++++++++&lt;[&gt;-&lt;-]+++++++++&gt;[-[&lt;-&gt;-]+[&lt;&lt;&lt;&lt;]]&lt;[&gt;+&lt;-]&gt;]<br>        &gt;[&gt;[&gt;&gt;&gt;&gt;]+[[-]&lt;[+[-&gt;&gt;&gt;&gt;]&gt;+&lt;]&gt;[&lt;+&gt;[&lt;&lt;&lt;&lt;]]+&lt;&lt;&lt;&lt;]&gt;&gt;&gt;[-&gt;&gt;&gt;&gt;]+&gt;+[&lt;&lt;&lt;&lt;]]<br>        &gt;[[&gt;+&gt;&gt;[&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;-]&gt;]&lt;&lt;&lt;&lt;[-]&gt;[-&lt;&lt;&lt;&lt;]]&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>    ]&gt;&gt;+[[-]++++++&gt;&gt;&gt;&gt;]&lt;&lt;&lt;&lt;[[&lt;++++++++&gt;-]&lt;.[-]&lt;[-]&lt;[-]&lt;]&lt;,<br>]</code></p>
<p>    这种语言语法之简单，还产生出很多有意思的东西。比如，你可以想到用c语言或者pascal语言完全可以编写一个不到50行的BrainFuck编译器。还有，我们也可以用BrainFuck语言来写一个BrainFuck的编译器。事实上，有人真的也写出来了，我也看到代码了。太牛B了。</p>
<p>做人要厚道<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-04-02T20:22:24+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/168</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 比比谁更无聊：Whitespace语言 ]]></title>
<link>http://www.matrix67.com/blog/archives/169</link>
<content><![CDATA[ 
		<p>    我们已经见过了<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=139">满篇没有一句人话的代码</a>，我们也见过了<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=209">没有字母数字只有一堆符号的代码</a>。还有比这个更牛B的吗？下面介绍满篇全是空白的代码——Whitespace语言。dd说它的<a target="_blank" href="http://tianyi.iyublog.com/raise-level-of-abstraction/">信息学竞赛中的软件工程学系列</a>很无聊，我倒觉得介绍这种疯狂的语言更无聊一些。<br>    Whitespace语言只接受三种字符：空格、Tab和回车。其余的字符该语言一律忽略。它的语法比前面说过的BrainFuck语言略复杂，但不知比现在我们常用的语言简单到哪儿去了。BrainFuck语言对一个线性表进行操作，而Whitespace语言对一个栈进行操作。它的语法主要可以实现这些操作：
</p>
<ul>
<li>压入一个数字或字母</li>
<li>弹出一个元素</li>
<li>把指定元素的值复制到栈顶</li>
<li>交换栈顶两个元素</li>
<li>对栈顶两个元素进行加减乘除，并把他们替换成运算结果</li>
<li>在代码当前位置做一个标记</li>
<li>跳到一个指定的标记</li>
<li>当栈顶为0时跳到一个指定的标记</li>
<li>当栈顶为负数时跳到一个指定的标记</li>
<li>读入字母或数字到指定的位置</li>
<li>输出栈顶字母或数字</li>
</ul>
<p>    数字和字母(ASCII)都用二进制表示，空格表示0，Tab表示1。你可以在<a target="_blank" href="http://compsoc.dur.ac.uk/whitespace/tutorial.php">这里</a>看到详细的教学。</p>
<p>    很多人会问，这个有什么用呢？<br>    确实没啥用。不过也确实很好玩。根据它的特点怎么也能编出一些不太靠谱儿的“用途”来。比如，和BrainFuck一样，这种语言要写注释就方便了，写的注释根本不需要标识，编译器直接跳过你写的文字信息。还有，我们完全可以在满篇空白的代码中插入一篇文章，从而在看起来完全无关的文章中隐藏一段代码。对于间谍工作来说这种语言帮助很大，因为它可以防止别人把代码打印出来拿走（还记得24的EMP那一集吗？）。</p>
<p>    下面这段代码将在屏幕上打印“Hello World!”。<br><code>    <br>                <br>                <br>                      <br>                 <br>                      <br>                    <br>                      <br>                  <br>                            <br>                     <br>                  <br>                     <br>            <br>                        <br>                            <br>                   <br>                            <br>                      <br>                      <br>                      <br>                      <br>                         <br>                   <br>                      <br>            <br>                         <br>                            <br>                         <br>                      <br>                            <br>            <br>                    <br>                         <br>                       <br>                   <br>                       <br>                   <br>                          <br>                      <br>                       <br>                      <br>                          <br>                         <br>       <br>
60;                  <br>               <br>                             <br>    <br>             </code></p>
<p>                                                                                                               </p>
<p>                                                                                                                                                             </p>
<p>                                                     <br>       <br>    </p>
<p>                                                                                                            </p>
<p>              </p>
<p>                                                                                                                                                                                                     <br>    <br>         <br>       </p>
<p>                                                                                                          </p>
<p>                                                                                                                                                                                                  </p>
<p>    </p>
<p>                                                                            </p>
<p>  <br>     <br>                  <br>              <br>          <br>                                                                                                                                                                     </p>
<p>       <br>       </p>
<p>                                                <br>
0;                         </p>
<p>                                                                                                                                                                  </p>
<p>       <br>           <br>         <br>    </p>
<p>                                                                                                                                                          <br>             <br>                <br>    <br>      <br>  <br>    <br></p>
<p>做人要厚道<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-04-03T16:19:05+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/169</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 从零开始学算法：十种排序算法介绍（中） ]]></title>
<link>http://www.matrix67.com/blog/archives/172</link>
<content><![CDATA[ 
		<p>    本文被华丽的分割线分为了四段。对于O(nlogn)的排序算法，我们详细介绍归并排序并证明归并排序的时间复杂度，然后简单介绍堆排序，之后给出快速排序的基本思想和复杂度证明。最后我们将证明，O(nlogn)在理论上已经达到了最优。学过OI的人一般都学过这些很基础的东西，大多数OIer们不必看了。为了保持系列文章的完整性，我还是花时间写了一下。</p>
<p>    首先考虑一个简单的问题：如何在线性的时间内将两个有序队列合并为一个有序队列（并输出）？</p>
<p>A队列：<span style="color:red">1</span> 3 5 7 9<br>B队列：<span style="color:red">1</span> 2 7 8 9</p>
<p>    看上面的例子，AB两个序列都是已经有序的了。在给出数据已经有序的情况下，我们会发现很多神奇的事，比如，我们将要输出的第一个数一定来自于这两个序列各自最前面的那个数。两个数都是1，那么我们随便取出一个（比如A队列的那个1）并输出：</p>
<p><span style="font-family:宋体">A队列：<s>1</s> <span style="color:red">3</span> 5 7 9<br>B队列：<span style="color:red">1</span> 2 7 8 9<br> 输出：1</span></p>
<p>    注意，我们取出了一个数，在原数列中删除这个数。删除操作是通过移动队首指针实现的，否则复杂度就高了。<br>    现在，A队列打头的数变成3了，B队列的队首仍然是1。此时，我们再比较3和1哪个大并输出小的那个数：</p>
<p><span style="font-family:宋体">A队列：<s>1</s> <span style="color:red">3</span> 5 7 9<br>B队列：<s>1</s> <span style="color:red">2</span> 7 8 9<br> 输出：1 1</span></p>
<p>    接下来的几步如下：</p>
<p><span style="font-family:宋体">A队列：<s>1</s> 3 5 7 9         A队列：<s>1 3</s> 5 7 9         A队列：<s>1 3 5</s> 7 9          A队列：<s>1 3 5 7</s> 9<br>B队列：<s>1 2</s> 7 8 9   ==&gt;   B队列：<s>1 2</s> 7 8 9   ==&gt;   B队列：<s>1 2</s> 7 8 9    ==&gt;   B队列：<s>1 2</s> 7 8 9     ……<br> 输出：1 1 2              输出：1 1 2 3            输出：1 1 2 3 5           输出：1 1 2 3 5 7</span></p>
<p>    我希望你明白了这是怎么做的。这个做法显然是正确的，复杂度显然是线性。</p>
<p>    归并排序(Merge Sort)将会用到上面所说的合并操作。给出一个数列，归并排序利用合并操作在O(nlogn)的时间内将数列从小到大排序。归并排序用的是分治(Divide and Conquer)的思想。首先我们把给出的数列平分为左右两段，然后对两段数列分别进行排序，最后用刚才的合并算法把这两段（已经排过序的）数列合并为一个数列。有人会问“对左右两段数列分别排序时用的什么排序”么？答案是：用归并排序。也就是说，我们递归地把每一段数列又分成两段进行上述操作。你不需要关心实际上是怎么操作的，我们的程序代码将递归调用该过程直到数列不能再分（只有一个数）为止。<br>    初看这个算法时有人会误以为时间复杂度相当高。我们下面给出的一个图将用非递归的眼光来看归并排序的实际操作过程，供大家参考。我们可以借助这个图证明，归并排序算法的时间复杂度为O(nlogn)。</p>
<p><span style="font-family:宋体">[3] [1] [4] [1] [5] [9] [2] [7]<br>  \ /     \ /     \ /     \ /<br> [1 3]   [1 4]   [5 9]   [2 7]<br>     \   /           \   /<br>   [1 1 3 4]       [2 5 7 9]<br>           \       /<br>       [1 1 2 3 4 5 7 9]</span></p>
<p>    上图中的每一个“ \ / ”表示的是上文所述的线性时间合并操作。上图用了4行来图解归并排序。如果有n个数，表示成上图显然需要O(logn)行。每一行的合并操作复杂度总和都是O(n)，那么logn行的总复杂度为O(nlogn)。这相当于用递归树的方法对归并排序的复杂度进行了分析。假设，归并排序的复杂度为T(n)，T(n)由两个T(n/2)和一个关于n的线性时间组成，那么T(n)=2*T(n/2)+O(n)。不断展开这个式子我们可以同样可以得到T(n)=O(nlogn)的结论，你可以自己试试。如果你能在线性的时间里把分别计算出的两组不同数据的结果合并在一起，根据T(n)=2*T(n/2)+O(n)=O(nlogn)，那么我们就可以构造O(nlogn)的分治算法。这个结论后面经常用。我们将在计算几何部分举一大堆类似的例子。<br>    如果你第一次见到这么诡异的算法，你可能会对<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=29">这个</a>感兴趣。分治是递归的一种应用。这是我们第一次接触递归运算。下面说的快速排序也是用的递归的思想。递归程序的复杂度分析通常和上面一样，主定理(Master Theory)可以简化这个分析过程。主定理和本文内容离得太远，我们以后也不会用它，因此我们不介绍它，大家可以自己去查。有个名词在这里的话找学习资料将变得非常容易，我最怕的就是一个东西不知道叫什么名字，半天找不到资料。</p>
<p>    归并排序有一个有趣的副产品。利用归并排序能够在O(nlogn)的时间里计算出给定序列里逆序对的个数。你可以用任何一种平衡二叉树来完成这个操作，但用归并排序统计逆序对更方便。我们讨论逆序对一般是说的一个排列中的逆序对，因此这里我们假设所有数不相同。假如我们想要数1, 6, 3, 2, 5, 4中有多少个逆序对，我们首先把这个数列分为左右两段。那么一个逆序对只可能有三种情况：两个数都在左边，两个数都在右边，一个在左一个在右。在左右两段分别处理完后，线性合并的过程中我们可以顺便算出所有第三种情况的逆序对有多少个。换句话说，我们能在线性的时间里统计出A队列的某个数比B队列的某个数大有多少种情况。</p>
<p><span style="font-family:宋体">A队列：1 3 6         A队列：<s>1</s> 3 6         A队列：<s>1</s> 3 6         A队列：<s>1 3</s> 6         A队列：<s>1 3</s> 6<br>B队列：2 4 5   ==&gt;   B队列：2 4 5   ==&gt;   B队列：<s>2</s> 4 5   ==&gt;   B队列：<s>2</s> 4 5   ==&gt;   B队列：<s>2 4</s> 5   ……<br> 输出：               输出：1              输出：1 2            输出：1 2 3          输出：1 2 3 4</span></p>
<p>    每一次从B队列取出一个数时，我们就知道了在A队列中有多少个数比B队列的这个数大，它等于A队列现在还剩的数的个数。比如，当我们从B队列中取出2时，我们同时知道了A队列的3和6两个数比2大。在合并操作中我们不断更新A队列中还剩几个数，在每次从B队列中取出一个数时把当前A队列剩的数目加进最终答案里。这样我们算出了所有“大的数在前一半，小的数在后一半”的情况，其余情况下的逆序对在这之前已经被递归地算过了。</p>
<p>============================华丽的分割线============================</p>
<p>    堆排序(Heap Sort)利用了堆(Heap)这种数据结构（<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=115">什么是堆？</a>）。堆的插入操作是平均常数的，而删除一个根节点需要花费O(log n)的时间。因此，完成堆排序需要线性时间建立堆（把所有元素依次插入一个堆），然后用总共O(nlogn)的时间不断取出最小的那个数。只要堆会搞，堆排序就会搞。堆在那篇日志里有详细的说明，因此这里不重复说了。</p>
<p>============================华丽的分割线============================</p>
<p>    快速排序(Quick Sort)也应用了递归的思想。我们想要把给定序列分成两段，并对这两段分别进行排序。一种不错的想法是，选取一个数作为“关键字”，并把其它数分割为两部分，把所有小于关键字的数都放在关键字的左边，大于关键字的都放在右边，然后递归地对左边和右边进行排序。把该区间内的所有数依次与关键字比较，我们就可以在线性的时间里完成分割的操作。完成分割操作有很多有技巧性的实现方法，比如最常用的一种是定义两个指针，一个从前往后找找到比关键字大的，一个从后往前找到比关键字小的，然后两个指针对应的元素交换位置并继续移动指针重复刚才的过程。这只是大致的方法，具体的实现还有很多细节问题。快速排序是我们最常用的代码之一，网上的快速排序代码五花八门，各种语言，各种风格的都有。大家可以随便找一个来看看，我说过了我们讲算法但不讲如何实现。NOIp很简单，很多人NOIp前就背了一个快速排序代码就上战场了。当时我把快速排序背完了，抓紧时间还顺便背了一下历史，免得晚上听写又不及格。<br>    不像归并排序，快速排序的时间复杂度很难计算。我们可以看到，归并排序的复杂度最坏情况下也是O(nlogn)的，而快速排序的最坏情况是O(n^2)的。如果每一次选的关键字都是当前区间里最大（或最小）的数，那么这样将使得每一次的规模只减小一个数，这和插入排序、选择排序等平方级排序没有区别。这种情况不是不可能发生。如果你每次选择关键字都是选择的该区间的第一个数，而给你的数据恰好又是已经有序的，那你的快速排序就完蛋了。显然，最好情况是每一次选的数正好就是中位数，这将把该区间平分为两段，复杂度和前面讨论的归并排序一模一样。根据这一点，快速排序有一些常用的优化。比如，我们经常从数列中随机取一个数当作是关键字（而不是每次总是取固定位置上的数），从而尽可能避免某些特殊的数据所导致的低效。更好的做法是随机取三个数并选择这三个数的中位数作为关键字。而对三个数的随机取值反而将花费更多的时间，因此我们的这三个数可以分别取数列的头一个数、末一个数和正中间那个数。另外，当递归到了一定深度发现当前区间里的数只有几个或十几个时，继续递归下去反而费时，不如返回插入排序后的结果。这种方法同时避免了当数字太少时递归操作出错的可能。</p>
<p>    下面我们证明，快速排序算法的平均复杂度为O(nlogn)。不同的书上有不同的解释方法，这里我选用算法导论上的讲法。它更有技巧性一些，更有趣一些，需要转几个弯才能想明白。<br>    看一看快速排序的代码。正如我们提到过的那种分割方法，程序在经过若干次与关键字的比较后才进行一次交换，因此比较的次数比交换次数更多。我们通过证明一次快速排序中元素之间的比较次数平均为O(nlogn)来说明快速排序算法的平均复杂度。证明的关键在于，我们需要算出某两个元素在整个算法过程中进行过比较的概率。<br>    我们举一个例子。假如给出了1到10这10个数，第一次选择关键字7将它们分成了{1,2,3,4,5,6}和{8,9,10}两部分，递归左边时我们选择了3作为关键字，使得左部分又被分割为{1,2}和{4,5,6}。我们看到，数字7与其它所有数都比较过一次，这样才能实现分割操作。同样地，1到6这6个数都需要与3进行一次比较（除了它本身之外）。然而，3和9决不可能相互比较过，2和6也不可能进行过比较，因为第一次出现在3和9，2和6之间的关键字把它们分割开了。也就是说，两个数A(i)和A(j)比较过，当且仅当第一个满足A(i)&lt;=x&lt;=A(j)的关键字x恰好就是A(i)或A(j) （假设A(i)比A(j)小）。我们称排序后第i小的数为Z(i)，假设i&lt;j，那么第一次出现在Z(i)和Z(j)之间的关键字恰好就是Z(i)或Z(j)的概率为2/(j-i+1)，这是因为当Z(i)和Z(j)之间还不曾有过关键字时，Z(i)和Z(j)处于同一个待分割的区间，不管这个区间有多大，不管递归到哪里了，关键字的选择总是随机的。我们得到，Z(i)和Z(j)在一次快速排序中曾经比较过的概率为2/(j-i+1)。<br>    现在有四个数，2,3,5,7。排序时，相邻的两个数肯定都被比较过，2和5、3和7都有2/3的概率被比较过，2和7之间被比较过有2/4的可能。也就是说，如果对这四个数做12次快速排序，那么2和3、3和5、5和7之间一共比较了12*3=36次，2和5、3和7之间总共比较了8*2=16次，2和7之间平均比较了6次。那么，12次排序中总的比较次数期望值为36+16+6=58。我们可以计算出单次的快速排序平均比较了多少次：58/12=29/6。其实，它就等于6项概率之和，1+1+1+2/3+2/3+2/4=29/6。这其实是与期望值相关的一个公式。<br>    同样地，如果有n个数，那么快速排序平均需要的比较次数可以写成下面的式子。令k=j-i，我们能够最终得到比较次数的期望值为O(nlogn)。<br>   <img alt="image placeholder" >
<p>    在三种O(nlogn)的排序算法中，快速排序的理论复杂度最不理想，除了它以外今天说的另外两种算法都是以最坏情况O(nlogn)的复杂度进行排序。但实践上看快速排序效率最高（不然为啥叫快速排序呢），原因在于快速排序的代码比其它同复杂度的算法更简洁，常数时间更小。</p>
<p>    快速排序也有一个有趣的副产品：快速选择给出的一些数中第k小的数。一种简单的方法是使用上述任一种O(nlogn)的算法对这些数进行排序并返回排序后数组的第k个元素。快速选择(Quick Select)算法可以在平均O(n)的时间完成这一操作。它的最坏情况同快速排序一样，也是O(n^2)。在每一次分割后，我们都可以知道比关键字小的数有多少个，从而确定了关键字在所有数中是第几小的。我们假设关键字是第m小。如果k=m，那么我们就找到了答案——第k小元素即该关键字。否则，我们递归地计算左边或者右边：当k&lt;m时，我们递归地寻找左边的元素中第k小的；当k&gt;m时，我们递归地寻找右边的元素中第k-m小的数。由于我们不考虑所有的数的顺序，只需要递归其中的一边，因此复杂度大大降低。复杂度平均线性，我们不再具体证了。<br>    还有一种算法可以在最坏O(n)的时间里找出第k小元素。那是我见过的所有算法中最没有实用价值的算法。那个O(n)只有理论价值。</p>
<p>============================华丽的分割线============================</p>
<p>    我们前面证明过，仅仅依靠交换相邻元素的操作，复杂度只能达到O(n^2)。于是，人们尝试交换距离更远的元素。当人们发现O(nlogn)的排序算法似乎已经是极限的时候，又是什么制约了复杂度的下界呢？我们将要讨论的是更底层的东西。我们仍然假设所有的数都不相等。<br>    我们总是不断在数与数之间进行比较。你可以试试，只用4次比较绝对不可能给4个数排出顺序。每多进行一次比较我们就又多知道了一个大小关系，从4次比较中一共可以获知4个大小关系。4个大小关系共有2^4=16种组合方式，而4个数的顺序一共有4!=24种。也就是说，4次比较可能出现的结果数目不足以区分24种可能的顺序。更一般地，给你n个数叫你排序，可能的答案共有n!个，k次比较只能区分2^k种可能，于是只有2^k&gt;=n!时才有可能排出顺序。等号两边取对数，于是，给n个数排序至少需要log2(n!)次。注意，我们并没有说明一定能通过log2(n!)次比较排出顺序。虽然2^5=32超过了4!，但这不足以说明5次比较一定足够。如何用5次比较确定4个数的大小关系还需要进一步研究。第一次例外发生在n=12的时候，虽然2^29&gt;12!，但现已证明给12个数排序最少需要30次比较。我们可以证明log(n!)的增长速度与nlogn相同，即log(n!)=Θ(nlogn)。这是排序所需要的最少的比较次数，它给出了排序复杂度的一个下界。log(n!)=Θ(nlogn)的证明也附在本文最后。<br>    <a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=191">这篇日志</a>的第三题中证明log2(N)是最优时用到了几乎相同的方法。那种“用天平称出重量不同的那个球至少要称几次”一类题目也可以用这种方法来解决。事实上，这里有一整套的理论，它叫做信息论。信息论是由香农(Shannon)提出的。他用对数来表示信息量，用熵来表示可能的情况的随机性，通过运算可以知道你目前得到的信息能够怎样影响最终结果的确定。如果我们的信息量是以2为底的，那信息论就变成信息学了。从根本上说，计算机的一切信息就是以2为底的信息量(bits=<u>bi</u>nary digi<u>ts</u>)，因此我们常说香农是数字通信之父。信息论和热力学关系密切，比如熵的概念是直接从热力学的熵定义引申过来的。和这个有关的东西已经严重偏题了，这里不说了，有兴趣可以去看《信息论与编码理论》。我对这个也很有兴趣，半懂不懂的，很想了解更多的东西，有兴趣的同志不妨加入讨论。物理学真的很神奇，利用物理学可以解决很多纯数学问题，我有时间的话可以举一些例子。我他妈的为啥要选文科呢。<br>    后面将介绍的三种排序是线性时间复杂度，因为，它们排序时根本不是通过互相比较来确定大小关系的。</p>
<p>附1：Σ(1/n)=Θ(log n)的证明<br>    首先我们证明，Σ(1/n)=O(log n)。在式子1+1/2+1/3+1/4+1/5+…中，我们把1/3变成1/2，使得两个1/2加起来凑成一个1；再把1/5,1/6和1/7全部变成1/4，这样四个1/4加起来又是一个1。我们把所有1/2^k的后面2^k-1项全部扩大为1/2^k，使得这2^k个分式加起来是一个1。现在，1+1/2+…+1/n里面产生了几个1呢？我们只需要看小于n的数有多少个2的幂即可。显然，经过数的扩大后原式各项总和为log n。O(logn)是Σ(1/n)的复杂度上界。<br>    然后我们证明，Σ(1/n)=Ω(log n)。在式子1+1/2+1/3+1/4+1/5+…中，我们把1/3变成1/4，使得两个1/4加起来凑成一个1/2；再把1/5,1/6和1/7全部变成1/8，这样四个1/8加起来又是一个1/2。我们把所有1/2^k的前面2^k-1项全部缩小为1/2^k，使得这2^k个分式加起来是一个1/2。现在，1+1/2+…+1/n里面产生了几个1/2呢？我们只需要看小于n的数有多少个2的幂即可。显然，经过数的缩小后原式各项总和为1/2*logn。Ω(logn)是Σ(1/n)的复杂度下界。</p>
<p>附2：log(n!)=Θ(nlogn)的证明<br>    首先我们证明，log(n!)=O(nlogn)。显然n!&lt;n^n，两边取对数我们得到log(n!)&lt;log(n^n)，而log(n^n)就等于nlogn。因此，O(nlogn)是log(n!)的复杂度上界。<br>    然后我们证明，log(n!)=Ω(nlogn)。n!=n(n-1)(n-2)(n-3)….1，把前面一半的因子全部缩小到n/2，后面一半因子全部舍去，显然有n!&gt;(n/2)^(n/2)。两边取对数，log(n!)&gt;(n/2)log(n/2)，后者即Ω(nlogn)。因此，Ω(nlogn)是log(n!)的复杂度下界。</p>
<p>今天写到这里了，大家帮忙校对哦<br>Matrix67原创<br>转贴请注明出处]]</p>
			 ]]></content>
<pubDate>2007-04-06T13:52:46+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/172</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Think Outside the Box: 一道原创智力题 ]]></title>
<link>http://www.matrix67.com/blog/archives/173</link>
<content><![CDATA[ 
		<p>    七等分正方形，四笔串连3×3的点阵，12根火柴棍摆出面积为1的封闭图形，这些题目见多了，再整人已经没用了。今天我第一次自己想了一个好玩的这类题目。<br>    <a target="_blank" href="http://www.vijos.cn/Problem_Show.asp?id=1005">有个OI题</a>的大意是，给你一个不超过200位的字符串，请问它第一次出现在串"1234567891011121314…"的什么位置。这道题可以用O(n^3)的枚举AC。<br>    今天和arthas聊天时突然想到一个问题，使得输出结果最大的字符串（最坏情况下的输入数据）是什么样的。<br>    你的答案是什么？想好答案前请先别往下看。</p>
<p><span style="color:gray"><br>    我起初以为是9999999…，但是9999999….可以从中间分开来。比如，六个数字9有可能出现在899999,900000中。我开始怀疑，是否所有的串都可以像这样分开来。</span></p>
<p>    后来我想到是900000000…，这样就不能从中间分开来了（否则有前导0）。然而这仍然不是最坏的情况。<br>    很少有人想到正确答案吧：<span style="color:#E5E5E5">0000000000…. (200个0)</span>  <span style="color:gray">这个答案显然是正确的。我也是后来才突然想到，因为</span><span style="color:#E5E5E5">我们忽略了输入是字符串，习惯性地以为输入数据是一个数，而且这个数越大越好</span><span style="color:gray">。</span></p>
<p>做人要厚道<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-04-09T16:46:53+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/173</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 从零开始学算法：十种排序算法介绍（下） ]]></title>
<link>http://www.matrix67.com/blog/archives/178</link>
<content><![CDATA[ 
		<p>    那么，有什么方法可以不用比较就能排出顺序呢？借助Hash表的思想，多数人都能想出这样一种排序算法来。<br>    我们假设给出的数字都在一定范围中，那么我们就可以开一个范围相同的数组，记录这个数字是否出现过。由于数字有可能有重复，因此Hash表的概念需要扩展，我们需要把数组类型改成整型，用来表示每个数出现的次数。<br>    看这样一个例子，假如我们要对数列3 1 4 1 5 9 2 6 5 3 5 9进行排序。由于给定数字每一个都小于10，因此我们开一个0到9的整型数组T[i]，记录每一个数出现了几次。读到一个数字x，就把对应的T[x]加一。</p>
<p><span style="font-family:宋体">  A[]= 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9<br>               +—+—+—+—+—+—+—+—+—+—+<br>      数字 i： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>               +—+—+—+—+—+—+—+—+—+—+<br>出现次数T[i]： | 0 | 2 | 1 | 2 | 1 | 3 | 1 | 0 | 0 | 2 |<br>               +—+—+—+—+—+—+—+—+—+—+</span></p>
<p>    最后，我们用一个指针从前往后扫描一遍，按照次序输出0到9，每个数出现了几次就输出几个。假如给定的数是n个大小不超过m的自然数，显然这个算法的复杂度是O(m+n)的。</p>
<p>    我曾经以为，这就是线性时间排序了。后来我发现我错了。再后来，我发现我曾犯的错误是一个普遍的错误。很多人都以为上面的这个算法就是传说中的计数排序。问题出在哪里了？为什么它不是线性时间的排序算法？原因是，这个算法根本不是排序算法，它根本没有对原数据进行排序。</p>
<p><strong>问题一：为什么说上述算法没有对数据进行排序？</strong><br><span style="color:red">STOP! You should think for a while.</span></p>
<p>    我们班有很多MM。和身高相差太远的MM在一起肯定很别扭，接个吻都要弯腰才行（<a target="_blank" href="http://fayecatshome.spaces.live.com">小猫</a>矮死了）。为此，我希望给我们班的MM的身高排序。我们班MM的身高，再离谱也没有超过2米的，这很适合用我们刚才的算法。我们在黑板上画一个100到200的数组，MM依次自曝身高，我负责画“正”字统计人数。统计出来了，从小到大依次为141, 143, 143, 147, 152, 153, …。这算哪门子排序？就一排数字对我有什么用，我要知道的是哪个MM有多高。我们仅仅把元素的属性值从小到大列了出来，但我们没有对元素本身进行排序。也就是说，我们需要知道输出结果的每个数值对应原数据的哪一个元素。下文提到的“排序算法的稳定性”也和属性值与实际元素的区别有关。</p>
<p><strong>问题二：怎样将线性时间排序后的输出结果还原为原数据中的元素？</strong><br><span style="color:red">STOP! You should think for a while.</span></p>
<p>    同样借助Hash表的思想，我们立即想到了类似于开散列的方法。我们用链表把属性值相同的元素串起来，挂在对应的T[i]上。每次读到一个数，在增加T[i]的同时我们把这个元素放进T[i]延伸出去的链表里。这样，输出结果时我们可以方便地获得原数据中的所有属性值为i的元素。</p>
<p><span style="font-family:宋体">  A[]= 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9<br>               +—+—+—+—+—+—+—+—+—+—+<br>      数字 i： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>               +—+—+—+—+—+—+—+—+—+—+<br>出现次数T[i]： | 0 | 2 | 1 | 2 | 1 | 3 | 1 | 0 | 0 | 2 |<br>               +—+o–+-o-+-o-+-o-+-o-+–o+—+—+-o-+<br>                    |    |   |   |   |    |          |<br>                 +–+  +-+   |   |   +-+  +—+      |<br>                 |     |   A[1]  |     |      |     A[6]<br>               A[2]  A[7]    |  A[3]  A[5]   A[8]    |<br>                 |           |         |            A[12]<br>               A[4]        A[10]      A[9]<br>                                       |<br>                                      A[11]</span></p>
<p>    形象地说，我们在地上摆10个桶，每个桶编一个号，然后把数据分门别类放在自己所属的桶里。这种排序算法叫做桶式排序(Bucket Sort)。本文最后你将看到桶式排序的另一个用途。<br>    链表写起来比较麻烦，一般我们不使用它。我们有更简单的方法。</p>
<p><strong>问题三：同样是输出元素本身，你能想出不用链表的其它算法么？</strong><br><span style="color:red">STOP! You should think for a while.</span></p>
<p><span style="font-family:宋体">  A[]= 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9<br>               +—+—+—+—+—+—+—+—+—+—+<br>      数字 i： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>               +—+—+—+—+—+—+—+—+—+—+<br>出现次数T[i]： | 0 | 2 | 1 | 2 | 1 | 3 | 1 | 0 | 0 | 2 |<br>               +—+—+—+—+—+—+—+—+—+—+<br>修改后的T[i]： | 0 | 2 | 3 | 5 | 6 | 9 | 10| 10| 10| 12|<br>               +—+—+—+—+—+—+—+—+—+—+</span></p>
<p>    所有数都读入后，我们修改T[i]数组的值，使得T[i]表示数字i可能的排名的最大值。比如，1最差排名第二，3最远可以排到第五。T数组的最后一个数应该等于输入数据的数字个数。修改T数组的操作可以用一次线性的扫描累加完成。<br>   &amp;<br>
nbsp;我们还需要准备一个输出数组。然后，我们从后往前扫描A数组，依照T数组的指示依次把原数据的元素直接放到输出数组中，同时T[i]的值减一。之所以从后往前扫描A数组，是因为这样输出结果才是稳定的。我们说一个排序算法是稳定的(Stable)，当算法满足这样的性质：属性值相同的元素，排序后前后位置不变，本来在前面的现在仍然在前面。不要觉得排序算法是否具有稳定性似乎关系不大，排序的稳定性在下文的某个问题中将变得非常重要。你可以倒回去看看前面说的七种排序算法哪些是稳定的。<br>    例子中，A数组最后一个数9所对应的T[9]=12，我们直接把9放在待输出序列中的第12个位置，然后T[9]变成11（这样下一次再出现9时就应该放在第11位）。</p>
<p><span style="font-family:宋体">A[]= 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9 &lt;–<br>T[i]= 0, 2, 3, 5, 6, 9, 10, 10, 10, <span style="color:red">11</span><br>Ans = _ _ _ _ _ _ _ _ _ _ _ 9</span></p>
<p>    接下来的几步如下：</p>
<p><span style="font-family:宋体">A[]= 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5 &lt;–<br>T[i]= 0, 2, 3, 5, 6, <span style="color:red">8</span>, 10, 10, 10, 11<br>Ans = _ _ _ _ _ _ _ _ 5 _ _ 9</span></p>
<p>A[]= 3, 1, 4, 1, 5, 9, 2, 6, 5, 3 &lt;–<br>T[i]= 0, 2, 3, <span style="color:red">4</span>, 6, 8, 10, 10, 10, 11<br>Ans = _ _ _ _ 3 _ _ _ 5 _ _ 9</p>
<p>A[]= 3, 1, 4, 1, 5, 9, 2, 6, 5 &lt;–<br>T[i]= 0, 2, 3, 4, 6, <span style="color:red">7</span>, 10, 10, 10, 11<br>Ans = _ _ _ _ 3 _ _ 5 5 _ _ 9</p>
<p>    这种算法叫做计数排序(Counting Sort)。正确性和复杂度都是显然的。</p>
<p><strong>问题四：给定数的数据范围大了该怎么办？</strong><br><span style="color:red">STOP! You should think for a while.</span></p>
<p>    前面的算法只有在数据的范围不大时才可行，如果给定的数在长整范围内的话，这个算法是不可行的，因为你开不下这么大的数组。Radix排序(Radix Sort)解决了这个难题。<br>    昨天我没事翻了一下初中（9班）时的同学录，回忆了一下过去。我把比较感兴趣的MM的生日列在下面（绝对真实）。如果列表中的哪个MM有幸看到了这篇日志（几乎不可能），左边的Support栏有我的电子联系方式，我想知道你们怎么样了。排名不分先后。
</p>
<ul>
<li>19880818</li>
<li>19880816</li>
<li>19890426</li>
<li>19880405</li>
<li>19890125</li>
<li>19881004</li>
<li>19881209</li>
<li>19890126</li>
<li>19890228</li>
</ul>
<p>    这就是我的数据了。现在，我要给这些数排序。假如我的电脑只能开出0..99的数组，那计数排序算法最多对两位数进行排序。我就把每个八位数两位两位地分成四段（图1），分别进行四次计数排序。地球人都知道月份相同时应该看哪一日，因此我们看月份的大小时应该事先保证日已经有序。换句话说，我们先对“最不重要”的部分进行排序。我们先对所有数的最后两位进行一次计数排序（图2）。注意观察1月26号的MM和4月26号的MM，本次排序中它们的属性值相同，由于计数排序是稳定的，因此4月份那个排完后依然在1月份那个的前头。接下来我们对百位和千位进行排序（图3）。你可以看到两个26日的MM在这一次排序中分出了大小，而月份相同的MM依然保持日数有序（因为计数排序是稳定的）。最后我们对年份排序（图4），完成整个算法。大家都是跨世纪的好儿童，因此没有图5了。</p>
<p>       <img alt="image placeholder" >
<p>    这种算法显然是正确的。它的复杂度一般写成O(d*(n+m))，其中n表示n个数，m是我开的数组大小（本例中m=100），d是一个常数因子（本例中d=4）。我们认为它也是线性的。</p>
<p><strong>问题五：这样的排序方法还有什么致命的缺陷？</strong><br><span style="color:red">STOP! You should think for a while.</span></p>
<p>    即使数据有30位，我们也可以用d=5或6的Radix算法进行排序。但，要是给定的数据有无穷多位怎么办？有人说，这可能么。这是可能的，比如给定的数据是小数（更准确地说，实数）。基于比较的排序可以区分355/113和<span style="font-family:宋体">π</span>哪个大，但你不知道Radix排序需要精确到哪一位。这下惨了，实数的出现把貌似高科技的线性时间排序打回了农业时代。这时，桶排序再度出山，挽救了线性时间排序悲惨的命运。</p>
<p><strong>问题六：如何对实数进行线性时间排序？</strong><br><span style="color:red">STOP! You should think for a while.</span></p>
<p>    我们把问题简化一下，给出的所有数都是0到1之间的小数。如果不是，也可以把所有数同时除以一个大整数从而转化为这种形式。我们依然设立若干个桶，比如，以小数点后面一位数为依据对所有数进行划分。我们仍然用链表把同一类的数串在一起，不同的是，每一个链表都是有序的。也就是说，每一次读到一个新的数都要进行一次插入排序。看我们的例子：</p>
<p><span style="font-family:宋体">      A[]= 0.12345, 0.111, 0.618, 0.9, 0.99999<br>               +—+—+—+—+—+—+—+—+—+—+<br>      十分位： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |<br>               +—+-o-+—+—+—+—+-o-+—+—+-o-+<br>                     |                   |           |<br>                   A[2]<span style="color:gray">=0.111</span>          A[3]<span style="color:gray">=0.618</span>   A[4]<span style="color:gray">=0.9</span><br>                     |                               |<br>                   A[1]<span style="color:gray">=0.12345</span>                     A[5]<span style="color:gray">=0.99999</span></span></p>
<p>    假如再下一个读入的数是0.122222，这个数需要插入到十分位为1的那个链表里适当的位置。我们需要遍历该链表直到找到第一个比0.122222大的数，在例子中则应该插入到链表中A[2]和A[1]之间。最后，我们按顺序遍历所有链表，依次输出每个链表中的每个数。<br>    这个算法显然是正确的，但复杂度显然不是线性。事实上，这种算法最坏情况下是O(n^2)的，因为当所有数的十分位都相同时算法就是一个插入排序。和原来一样，我们下面要计算算法的平均时间复杂度，我们希望这种算法的平均复杂度是线性的。<br>    这次算平均复杂度我们用最笨的办法。我们将算出<br>
所有可能出现的情况的总时间复杂度，除以总的情况数，得到平均的复杂度是多少。<br>    每个数都可能属于10个桶中的一个，n个数总的情况有10^n种。这个值是我们庞大的算式的分母部分。如果一个桶里有K个元素，那么只与这个桶有关的操作有O(K^2)次，它就是一次插入排序的操作次数。下面计算，在10^n种情况中，K0=1有多少种情况。K0=1表示，n个数中只有一个数在0号桶，其余n-1个数的十分位就只能在1到9中选择。那么K0=1的情况有C(n,1)*9^(n-1)，而每个K0=1的情况在0号桶中将产生1^2的复杂度。类似地，Ki=p的情况数为C(n,p)*9^(n-p)，复杂度总计为C(n,p)*9^(n-p)*p^2。枚举所有K的下标和p值，累加起来，这个算式大家应该能写出来了，但是这个……怎么算啊。别怕，我们是搞计算机的，拿出点和MO不一样的东西来。于是，Mathematica 5.0隆重登场，我做数学作业全靠它。它将帮我们化简这个复杂的式子。<br><img alt="image placeholder" >
<p>    我们遗憾地发现，虽然常数因子很小（只有0.1），但算法的平均复杂度仍然是平方的。等一下，1/10的那个10是我们桶的个数吗？那么我们为什么不把桶的个数弄大点？我们干脆用m来表示桶的个数，重新计算一次：<br><img alt="image placeholder" >
<p>    化简出来，操作次数为O(n+n^2/m)。发现了么，如果m=Θ(n)的话，平均复杂度就变成了O(n)。也就是说，当桶的个数等于输入数据的个数时，算法是平均线性的。<br>    我们将在Hash表开散列的介绍中重新提到这个结论。</p>
<p>    且慢，还有一个问题。10个桶以十分位的数字归类，那么n个桶用什么方法来分类呢？注意，分类的方法需要满足，一，一个数分到每个桶里的概率相同（这样才有我们上面的结论）；二，所有桶里容纳元素的范围必须是连续的。根据这两个条件，我们有办法把所有数恰好分为n类。我们的输入数据不是都在0到1之间么？只需要看这些数乘以n的整数部分是多少就行了，读到一个数后乘以n取整得几就插入到几号桶里。这本质上相当于把区间[0,1)平均分成n份。</p>
<p><strong>问题七：有没有复杂度低于线性的排序算法</strong><br><span style="color:red">STOP! You should think for a while.</span></p>
<p>    我们从O(n^2)走向O(nlogn)，又从O(nlogn)走向线性，每一次我们都讨论了复杂度下限的问题，根据讨论的结果提出了更优的算法。这次总算不行了，不可能有比线性还快的算法了，因为——你读入、输出数据至少就需要线性的时间。排序算法之旅在线性时间复杂度这一站终止了，所有十种排序算法到这里介绍完毕了。</p>
<p>    文章有越写越长的趋势了，我检查起来也越来越累了。我又看了三遍，应该没问题了。群众的眼睛是雪亮的，恳请大家帮我找错。</p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-04-13T04:09:04+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/178</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ OI之外的一些东西：简单谈谈排序网络 ]]></title>
<link>http://www.matrix67.com/blog/archives/185</link>
<content><![CDATA[ 
		<p>    我们之前所有的排序算法都是给定了数据再进行排序，排序的效率很大程度上取决于数据的好坏。我们今天所介绍的是一个完全不同的排序方法，它可以在“暗箱”里对数据进行排序（即你不必知道实际数据是什么），换句话说这种排序方法不依赖于数据(Data-Independent)，所有比较操作都与数据无关。你甚至可以立即忘掉前面的比较结果，因为对于所有可能的数据这类排序算法都能得到正确答案并且排序步骤完全相同。本文结束后再回过头来看这段话你将有更深的认识。<br>  <img alt="image placeholder" >
<p>    现在，我们的第一个问题是，是否存在比较网络。就是说，有没有可能使得任意数据通过同一组比较器都能输出有序的结果。我们最初的想法当然是，把我们已知的什么排序算法改成这种形式。把原来那十种排序又翻出来看一遍，找一找哪些排序的比较操作是无条件的。运气不错，我们所学的第一个算法——冒泡排序，它的比较就是无条件的，不管数据怎样冒泡排序都是不断比较相邻元素并把较小的放到前面。冒泡排序是一个彻头彻尾的排序网络模型，我们可以立即画出冒泡排序所对应的排序网络（图4）。这是我们得到的第一个排序网络。我们通常不认为插入排序是排序网络，因为插入排序的比较次数取决于数据的有序程度。<br>  <img alt="image placeholder" >
<p>    给出一个比较网络，怎样判断它是不是一个排序网络？很遗憾，现在还没有找到一种好的算法。事实上，这个问题是一个NPC问题。<span style="color:gray">注：这种说法是不准确的，因为目前还没有迹象表明这个问题是NP问题。准确的说法应该是，“判断某比较网络为排序网络”是Co-NP Complete，而“判断某比较网络不是排序网络”（即找到一个反例）才是NP Complete。</span><br>    传统的做法是枚举所有n的排列来验证，一共要考虑n!种情况。下面我们介绍排序网络理论里最重要的结论：0-1原理(0-1 Principle)。使用这个原理来验证排序网络只需要考虑2^n种情况。0-1原理告诉我们，如果所有的01序列能够通过比较网络排出顺序，那么这足以说明该网络为排序网络。证明过程很简单。为了证明这个结论，我们证明它的逆否命题（逆否命题与原命题同真假）：如果一个比较网络不是排序网络，那么至少存在一个01序列不能被排序。我们给出一种算法，这个算法可以把任何一个不能被排序的输入数据转化为一个不能被排序的01序列。<br>    在最初的例子（图3）中，输入数据3,1,4,2的输出为1,3,2,4，没有成功地排出顺序，从而判断出该网络不是排序网络。这说明，输出结果中存在逆序对（左边某个数大于右边的某个数）。我们从输出结果中找出一个逆序对来。例子中，(3,2)就是我们要找的数。现在，我们把输入中所有小于数字3（左边那个数）的数都变成0，把所有大于等于3的数都变成1。这样，3,1,4,2就变成了1,0,1,0。显然，把得到的这个01序列输入进去，原来曾经发生过交换的地方现在仍然会交换，原来不曾交换的地方现在也同样不会发生交换（当两个0或两个1进行比较时，我们既可以认为它们不交换，也可以看成它们要互相交换，反正都一样）。最后，该01序列输出的结果中，本来3的位置现在还是1，原来2的位置现在仍然是0，逆序对仍然存在。因此，只要一个比较网络不是排序网络，那么总可以找到一个01序列不能被排序。等价地，如果所有的01序列都能被排序了，这个比较网络也就是排序网络了。</p>
<p>    我们用0-1原理来证明奇偶移项排序的正确性。我们对n进行数学归纳证明。n=2时（一个“工”字）显然是排序网络。<br>    图中是n=8的情况。我们假设对于所有n&lt;=7，奇偶移项排序网络都是正确的。我们同时假定所有输入数字非0即1，下面我们说明n=8时所有的01序列都能被正确排序。<br>    假设最后一个数是1（图7，在前面的），那么这个1将始终排在最后不参与任何交换操作，对前面7个数没有任何影响。除去无用的灰色部分，剩下的就是n=7这一规模较小的子排序网络，由归纳假设则n=8也是排序网络；<br>  <img alt="image placeholder" >
<p>    接下来，我们提出一些比较器个数为O(n*logn*logn)的排序网络。其中一种就是之前提到过的<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=207">2^p*3^q增量Shell排序</a>。这种增量排序的特点是每一趟排序中的每个数只与前面的数比较一次，因此它可以非常方便地转化为排序网络。图9就是一个n=8的Shell排序网络。Bitonic排序也可以做到<br>
O(n*logn*logn)的比较器个数，今天不介绍它。下面详细介绍奇偶归并排序网络。<br>  <img alt="image placeholder" >
<p>    菜鸟献丑，漏洞百出。如果我有什么错误，各位大牛请指正。<br>    Matrix67原创，转载请注明出处。</p>
<p>  外部排序(External Sort)已经在<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=116">这里</a>提到过，不再说了。<br>  所有排序的知识到这里说完了，下次再发布的就是数论相关内容了。数论部分将从进位制开始谈起。<br>  我会一直写下去，本人活到什么时候写到什么时候写完为止。不过，这几天缓一下，我计划做一个PJBlog的单版面论坛模块。</p>
			 ]]></content>
<pubDate>2007-04-23T00:00:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/185</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 又一个比较诡异的悖论 ]]></title>
<link>http://www.matrix67.com/blog/archives/191</link>
<content><![CDATA[ 
		<p>    不知道大家见过没有，我今天偶然看到，在这里写一下。<br>    箱子里有两个信封：“一个信封里有1元钱，另一个有10元”有1/2的概率；“一个信封里有10元钱，另一个有100元”有1/4的概率；“一个信封里有100元钱，另一个有1000元”有1/8的概率……也就是说，有1/2^n的概率发生这样的事情，一个信封里有10^(n-1)元钱，另一个信封里有10^n元钱。现在你拿到一个信封，看到了里面有x元钱。给你一次机会换成另外那个信封，问你换不换。<br>    举个例子，假如我们拿到了100元钱的信封，那么换一个信封得到1000元的概率是得到10元的概率的一半。也就是说，如果我们拿到了x元钱，换一个信封的话有1/3的概率多得9x元，有2/3的概率失去0.9x元。它的期望值是增加2.4x元，这告诉了我们换一个信封显然更好。<br>    现在的问题是，既然总是换个信封好些，那么为什么我们不一开始就选择另外那个信封呢？</p>
<p>大家可以在下面讨论<br>我就不参与讨论了，虽然我也不知道是怎么回事</p>
<p>    这个问题让我想到了Newcomb悖论，说有个妖精可以预言你将拿一个箱子还是两个箱子，大家一定见过。<br>
</p>
<blockquote>    A highly superior being from another part of the galaxy presents you with two boxes, one open and one closed. In the open box there is a thousand-dollar bill. In the closed box there is either one million dollars or there is nothing. You are to choose between taking both boxes or taking the closed box only. But there's a catch.<br>    The being claims that he is able to predict what any human being will decide to do. If he predicted you would take only the closed box, then he placed a million dollars in it. But if he predicted you would take both boxes, he left the closed box empty. Furthermore, he has run this experiment with 999 people before, and has been right every time.<br>    What do you do?<br>    On the one hand, the evidence is fairly obvious that if you choose to take only the closed box you will get one million dollars, whereas if you take both boxes you get only a measly thousand. You'd be stupid to take both boxes.<br>    On the other hand, at the time you make your decision, the closed box already is empty or else contains a million dollars. Either way, if you take both boxes you get a thousand dollars more than if you take the closed box only. </blockquote>
<p>    Newcomb悖论是很荒唐的，很不具有数学的科学性。但这篇日志介绍的悖论在科学性上是可以承认的。</p>
			 ]]></content>
<pubDate>2007-05-03T23:16:32+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/191</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Matrix67生日邀请赛顺利结束 题目内容在此发布 ]]></title>
<link>http://www.matrix67.com/blog/archives/197</link>
<content><![CDATA[ 
		<p><span style="color:blue">07年5月12日晚我举办了一次OI生日邀请赛，比赛已经顺利结束。下面是这次比赛的全部试题：</span></p>
<p>题目一览<br><span style="font-family:宋体"><br>题目名称    为什么最少            身高控制计划        狼的复仇          和MM逛花园<br>题目类型    传统                  传统                传统              传统<br>源文件名称  whyleast.(pas/c/cpp)  height.(pas/c/cpp)  wolf.(pas/c/cpp)  garden.(pas/c/cpp)<br>输入文件名  whyleast.in           height.in           wolf.in           garden.in<br>输出文件名  whyleast.out          height.out          wolf.out          garden.out<br>时间限制    1秒                   1秒                 1秒               <span style="color:red">0.1秒</span><br>内存限制    64M                   64M                 64M               64M<br>测试点      10个                  10个                10个              10个<br>分值        100分                 100分               100分             100分<br></span></p>
<p><strong>Problem 1: whyleast<br>为什么最少</strong></p>
<p>问题描述<br>    时间过得真快，16号就是我的19岁生日了。为了让自己在新的一岁里人品加加，本菜鸟特地准备了原创菜题大餐供各位大牛享乐，希望大家人人400分。我们今天的第一题巨菜无比，此题乃经典的Hanoi塔问题。在1号塔上有n个盘子，你需要按照Hanoi塔的要求把所有的盘子都移动到3号塔上。<br>    我一直想不通的是，为什么那些智力题总是要求人们用最少的步骤完成题目中的要求。为什么非要最少呢？这次我们来点特别的，我希望你的程序能够用最多的步数达到要求，而且在此过程中不重复出现任何一种状态。</p>
<p>输入数据<br>    输入数据只有一个正整数n，表示Hanoi塔问题的金片个数。</p>
<p>输出数据<br>    第一行输出在不重复出现状态的情况下完成n阶Hanoi塔的最多步数。<br>    以下若干行依次表示你的操作步骤，每一行两个数a,b表示在这一步应该把a号柱最顶上的金片移动到b号柱上。<br>    如果有多种方案，你只需要输出其中一种即可。评测系统可以判断你的方案的正确性。</p>
<p>样例输入<br>2</p>
<p>样例输出<br>8<br>1 2<br>2 3<br>1 2<br>3 2<br>2 1<br>2 3<br>1 2<br>2 3</p>
<p>数据规模<br>    对于所有数据，n&lt;=12。</p>
<p>附：Hanoi塔问题简介（摘自http://www.matrix67.com/blog/article.asp?id=29）<br>
</p>
<blockquote>    法国数学家艾得渥·卢卡斯(Edouard Lucas)于1883年在一份杂志上介绍了一个引人入胜的数学谜题——汉诺塔(Tower of Hanoi)，并称这与古印度的一个传说有关。显然传说的具体内容已经不在本文论述的范围内了，但我想简单的介绍一下。<br>    相传印度有座大寺庙，它曾被认为是宇宙的中心。神庙中放置了一块上面插有三根长木钉的木板，在其中的一根木钉上，由上至下放了64片直径由小至大的圆环形金属片。古印度教的天神指示他的僧侣们将64片金属片全部移至另一根木钉上。移动规则只有两个：<br>        1.在每次的移动中，只能移动一片金属片；<br>        2.过程中任意时刻必须保证金属片小的在上，大的在下。<br>    直到有那么一天，僧侣们能将64片金属片按规则从指定的木钉上全部移至另一根木钉上，那么，世界末日即随之来到，世间的一切终将被毁灭，万物都将至极乐世界。<br>    这个传说经常被认为是卢卡斯教授为推广这个数学谜题而捏造的，但不管怎么说，卢卡斯是成功了。这玩意儿变成了家喻户晓的益智游戏之一，后来又成为了学习递归的必修课程。</blockquote>
<p><strong>Problem 2: height<br>身高控制计划</strong></p>
<p>问题描述<br>    不要总以为MM只担心自己的体重。经过Matrix67的观察，他发现他身边的MM们更关注自己的身高。MM们都希望自己能长高一些但不要长得太高。如果两个MM的身高相差不多，矮的MM会羡慕较高的MM，希望能长得和她一样修长；如果两个MM的身高相差太大，高的MM反而会想变得和较矮的MM一样娇小。Matrix67为了控制GF们的身高，采取了一项身高控制计划：任意两个女生A和B之间，假设A要比B高一些，如果A高出B的1/4，则A应该以B的身高为目标；相反，如果A的身高小于等于B的1.25倍（但仍然比B高），则B应该努力向A的身高看齐。我们假设不存在身高相等的MM。这样，Matrix67的n个MM之间产生了n(n-1)/2个单向的“榜样”关系。<br>    之后，Matrix67发现，这样的关系设定存在一个问题：有可能出现A以B为学习目标，B以C为学习目标，C又以A为学习目标的情况。这不相当于自己是自己的榜样么？这样的循环非常可笑，显然是不科学的。Matrix67希望调整一些关系的方向从而消除所有的循环。Matrix67每次改变其中一对MM之间的关系方向，你需要写程序判断，每一次改变后n个MM之间的“榜样”关系是否存在循环。</p>
<p>输入数据<br>    第一行输入两个用空格隔开的正整数n和m，分别表示MM的个数和改变方向的总次数。<br>    以下n行每行一个数，其中第i行表示编号为i的MM的身高。为了避免身高相等的情况，高度值已经被“放大”过，所有高度均为不超过2 000 000 000的正整数。<br>    接下来的m行里每行有用空格隔开的两个不相等的正整数A, B，表示Matrix67对编号为A的MM和编号为B的MM之间的单向关系进行反向。</p>
<p>输出数据<br> &amp;nbs<br>
p;  对于Matrix67的每一次操作，你需要输出是否存在某个MM以自己为学习目标的情况（即关系图中是否存在循环）。如果是，则输出“YES”，如果不是，请输出“NO”。<br>    你的输出应该有m行。</p>
<p>样例输入<br>4 3<br>10<br>7<br>8<br>9<br>3 4<br>1 2<br>4 1</p>
<p>样例输出<br>YES<br>NO<br>YES</p>
<p>样例说明<br>        <img alt="image placeholder" >
<p>数据规模：<br>    对于30%的数据，n&lt;=10, m&lt;=100；<br>    对于50%的数据，n&lt;=100, m&lt;=1000；<br>    对于70%的数据，n&lt;=1000, m&lt;=100 000；<br>    对于100%的数据，n&lt;=100 000, m&lt;=100 000。</p>
<p><strong>Problem 3: wolf<br>狼的复仇</strong></p>
<p>问题描述<br>    山谷里有n座森林，这些森林从1到n编号。某些森林之间有小路相连，总共m条小路连通了这n座森林，任意两座森林之间都有至少一条路径可以互相到达。<br>    很久很久以前，这里是狼的家园。在每一座森林里都有一匹狼，每一匹狼都静静地守护着它所在的森林。直到有一天，人类出现了。它们疯狂地开垦1号森林，并且杀死了1号森林的狼。以后，这座森林就好像属于人类了一样，不时有人来到1号森林。其余的n-1匹狼不愿看到悲剧再次发生，它们希望集合它们的力量，为种族，为大自然报仇。<br>    机会来了。一次偶然的机会，大灰狼们获得了一个重要的情报——有一个小MM经常独自游荡于1号森林。消息传遍了整个狼群，小MM细腻的皮肤和鲜嫩的肉令它们的血液沸腾起来，每一匹狼都幻想着能扑上前去撕裂MM的身体，舔拭那温热的血液。唯一的问题是，它们需要尽快察觉小MM的出现并快速奔向目的地。但由于山谷地形复杂，在第一时间里观察到小MM的出现谈何容易。因此，狼群计划在某些森林建立瞭望塔。当小MM再次出现在1号森林里时，所在的森林里有瞭望塔的狼可以立即发现这一情况，并且沿着最短路径奔向MM。有时最短路不止一条，在途中每当有多条路可以选择时，狼总会选择前往编号较小的森林。这些狼的行动将唤起最短路上沿途经过的狼，这些最短路上的狼将会闻声而起，一同对MM发起进攻。每匹狼都有自己的攻击力，最终对小MM的攻击力即是所有到达1号森林的狼的攻击力总和。注意攻击力的值有可能为负数，因为有一些狼很可能会“拖后腿”，对整个种族的复仇计划反而不利。<br>    由于森林的地形不同，在不同的地方建造瞭望塔需要的材料不同。现在狼群里一共有k个单位的建筑材料，并且它们已经计算出在n-1座森林中建造瞭望塔各自需要的材料数目。请你来计算一下，在哪些森林里建造瞭望塔可以使得最终到达1号森林的狼群攻击力总和最大。当然，建筑材料不一定要全部用完，但你的方案所需要的建筑材料不能超过总的材料数k。</p>
<p>输入数据<br>    第一行输入三个用空格隔开的正整数k, n, m，分别表示材料的总数量，森林的数量和小路的数量。1号森林总是MM出没的地方，其余n-1座森林是狼所在的地方。<br>    第二行到第n行每行有两个用空格隔开的整数，依次表示2号森林到n号森林里的狼的攻击力和在这里建造瞭望塔所需要的材料数。狼的攻击力绝对值不超过10000（可能为负数），每个瞭望塔的材料耗费都是不超过100的正整数。<br>    接下来m行每行有三个用空格隔开的数x,y,d，表示在x森林和y森林之间存在一条长度为d的路。路的长度是不超过10000的正整数。</p>
<p>输出数据<br>    输出在满足材料数限制下建造瞭望塔，最多可以给MM带去多大的攻击力。</p>
<p>样例输入<br>8 7 10<br>1 4<br>1 2<br>2 4<br>-3 5<br>9 4<br>2 1<br>1 4 2<br>4 3 4<br>2 3 3<br>5 1 2<br>2 4 1<br>1 2 3<br>6 7 1<br>2 7 4<br>2 6 8<br>5 6 5</p>
<p>样例输出<br>10</p>
<p>样例说明<br>    输入数据如下图所示，我们用AP来表示攻击力，用cost来表示瞭望塔的材料花费。在涂有蓝色的节点上建造瞭望塔花费仅为7，由于7&lt;=8，因此这种方案未超过材料预算。我们下面计算这种方案所带来的攻击力。<br>        <img alt="image placeholder" >
<p>数据规模<br>    对于30%的数据， k&lt;=1, n&lt;=10, m&lt;=100<br>    对于50%的数据， k&lt;=10, n&lt;=100, m&lt;=1000<br>    对于100%的数据，k&lt;=100, n&lt;=1000, m&lt;=10000</p>
<p>Matrix67提醒各位女同学：独自外出时请注意安全。</p>
<p><strong>Problem 4: garden<br>和MM逛花园</strong></p>
<p>问题描述<br>    花园设计强调，简单就是美。Matrix67常去的花园有着非常简单的布局：花园的所有景点的位置都是“对齐”了的，这些景点可以看作是平面坐标上的格点。相邻的景点之间有小路相连，这些小路全部平行于坐标轴。景点和小路组成了一个“不完整的网格”。<br>    一个典型的花园布局如左图所示。花园布局在6行4列的网格上，花园的16个景点的位置用红色标注在了图中。黑色线条表示景点间的小路，其余灰色部分实际并不存在。<br>        <img alt="image placeholder" >
<p>    Matrix67的生日那天，他要带着他的MM在花园里游玩。Matrix67不会带MM两次经过同一个景点，因此每个景点最多被游览一次。他和他的MM边走边聊，他们是如此的投入以致于他们从不会“主动地拐弯”。也就是说，除非前方已没有景点或是前方的景点已经访问过，否则他们会一直往前走下去。当前方景点不存在或已游览过时，Matrix67会带MM另选一个方向继续前进。由于景点个数有限，访问过的景点将越来越多，迟早会出现不能再走的情况（即四个方向上的相</p>
			 ]]></content>
<pubDate>2007-05-12T00:01:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/197</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Matrix67生日邀请赛 比赛成绩公布 ]]></title>
<link>http://www.matrix67.com/blog/archives/198</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
<p>注：<br>1. 名称后带有(1)、(2)的是多次提交相同文件名，系统自动重命名的结果<br>2. 里面的那个“matrix67”不是我，是另外的人在捣乱（我就不说是谁了: ) ）。</p>
<p>更多消息：http://www.oibh.org/bbs/thread-14911-1-1.html<br>详细的题解近期发布</p>
			 ]]></content>
<pubDate>2007-05-13T01:23:09+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/198</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Matrix67生日邀请赛 完全题解发布 ]]></title>
<link>http://www.matrix67.com/blog/archives/199</link>
<content><![CDATA[ 
		<p>题目在这里：http://www.matrix67.com/blog/article.asp?id=241</p>
<p>如果机房马上要关门了，或者你急着要和MM约会，请看简要题解：<br>
</p>
<blockquote>1. 用类似于传统hanoi的递归方法可以做到3^n-1次。这显然是最多的了，因为总的状态数也只有3^n个。<br>2. 可以证明，竞赛图中不存在环当且仅当所有顶点的出度从小到大排列依次为0, 1, 2, … , n-1 。<br>3. 在最短路树上做树状DP，需要多叉转二叉。注意几种需要输出0的情况。<br>4. 搜索，算是练基本功了。用位运算优化，不加任何剪枝就能过。</blockquote>
<p>否则，请慢慢阅读——</p>
<p><strong>Problem 1: 为什么最少</strong><br>    如果你还不熟悉Hanoi塔的解法，去题目中提到的那篇日志看看吧。如果你已经熟悉Hanoi塔的解法，你会立刻想到这道题的解法：依然是递归地解决。至于怎么递归，样例已经告诉我们了：把前n-1个金片从1号柱搬到3号柱，把第n片移到2号柱，又把那n-1片从3号柱搬回1号柱，再把第n片搬到3号柱，最后把那n-1个金片又搬过来，完成整个操作。<br>    我们下面解决三个问题：为什么这样不会重复出现状态，这样的移动步数是多少，为什么这样的操作步数是最多的。<br>    为什么这样不会出现重复的状态呢？因为我们假设前n-1个金片的移动过程中没有重复状态，而三次对n-1的调用时整个状态由于第n个金片的位置不同而不同。<br>    这样的方法获得的操作步数是多少呢？答案是3^n-1。我们可以用数学归纳法证明，n=1时步数为2显然正确，而f(n+1)=3f(n)+2=3*(3^n-1)+2=3^(n+1)-1。<br>    为什么这样的操作步数是最多的呢？废话，这样的操作步数当然是最多的，因为总的状态数也只有3^n个（每个金片的三种可能的位置确定了一种状态），你的移动步骤能比这个数目还多就见鬼了。</p>
<p>    这道题有人用了math库，没有提供math库导致无法编译是我的失误，向大家道歉。</p>
<p>    Hanoi问题的变种太多了，比如多根柱子、单向移动、双色金片等等。dd上次不是也出了一题么。</p>
<p>    这题代码很短，我公布在下面。<br><code>program whyleast;</code></p>
<p>procedure solve(t,a,b:integer);<br>begin<br>   if t=0 then exit else<br>   begin<br>      solve(t-1,a,b);<br>      writeln(a,' ',2);<br>      solve(t-1,b,a);<br>      writeln(2,' ',b);<br>      solve(t-1,a,b);<br>   end;<br>end;</p>
<p>{====main====}<br>var<br>   n,i:integer;<br>   ans:longint=1;<br>begin<br>   assign(input,'whyleast.in');<br>   reset(input);<br>   assign(output,'whyleast.out');<br>   rewrite(output);<br>   <br>   readln(n);<br>   for i:=1 to n do ans:=ans*3;<br>   writeln(ans-1);<br>   solve(n,1,3);<br>   <br>   close(input);<br>   close(output);<br>end.</p>
<p><strong>Problem 2: 身高控制计划</strong><br>    一个竞赛图是指任两个点之间都有一条有向边的图。竞赛图有很多奇妙的性质，比如一个竞赛图必然存在一条经过所有节点的路等等。<br>    下面我们证明，竞赛图中不存在环当且仅当所有顶点的出度从小到大排列依次为0, 1, 2, … , n-1 ：<br>    如果一个有向图的所有点出度都至少为1，那么这个图一定有环，因为在找到环之前DFS总可以找到新的节点。如果有向图无环，必然存在一个点没有出度。由于任两点之间都有有向边，那么其它所有点都要连一条边指向它，这样其它所有点的出度都至少为1了。删掉这个出度为0的点后剩下的图仍然无环，不断对剩下的图继续上面的过程就得到了我们的结论。<br>    现在我们的算法就很明确了，首先统计初始状态下的出度，然后设计某种数据结构完成两种操作：改变一个数（加一减一），询问所有数是否恰好为0, 1, 2, … , n-1 。<br>    统计初始状态下的出度方法有很多，这里介绍两个。首先对身高排序，然后对于每个人进行二分，寻找有序数列中该数的4/5和5/4各在什么地方。还有一种方法也是先排序，然后从左到右扫描整个序列，并保持两个指针始终指向4/5和5/4处。每次开始处理一个新的数时都把两个指针适当地右移直到超出了这个数的4/5或5/4为止。两种方法都是O(nlogn)。别以为第二种方法是线性的哦，线性算法之前还有一个排序呢。<br>    操作的处理也有不少方法。最简单的方法就是统计当前图中出度的数目有多少种。就是说，用a[i]表示出度为i的点有多少个，然后不断更新a[i]&gt;0的有多少个。当这个数目等于n时我们就认为图中没有环（因为出度可能的取值只有从0到n-1共n种）。<br>    注意，由于同一条边可能被操作多次，因此需要一个Hash表（开散列）来判重。具体地说，你需要判断这条边以前被操作过奇数次还是偶数次，以决定哪边的出度要增加，哪边的出度要减小。</p>
<p><strong>Problem 3: 狼的复仇</strong><br><img alt="image placeholder" >
			 ]]></content>
<pubDate>2007-05-15T02:45:46+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/199</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Matrix67生日邀请赛 标程公布 ]]></title>
<link>http://www.matrix67.com/blog/archives/201</link>
<content><![CDATA[ 
		<p>之所以没公布标程，是因为个人觉得标程写得比较丑。<br>既然有人需要就发布一下吧，标程丑总比没有标程好。</p>
<p><strong>Problem 1</strong><br><code>program whyleast;</code></p>
<p>procedure solve(t,a,b:integer);<br>begin<br>   if t=0 then exit else<br>   begin<br>      solve(t-1,a,b);<br>      writeln(a,' ',2);<br>      solve(t-1,b,a);<br>      writeln(2,' ',b);<br>      solve(t-1,a,b);<br>   end;<br>end;</p>
<p>{====main====}<br>var<br>   n,i:integer;<br>   ans:longint=1;<br>begin<br>  assign(input,'whyleast.in');<br>  reset(input);<br>  assign(output,'whyleast.out');<br>  rewrite(output);<br>  <br>  readln(n);<br>  for i:=1 to n do ans:=ans*3;<br>  writeln(ans-1);<br>  solve(n,1,3);<br>  <br>  close(input);<br>  close(output);<br>end.</p>
<p><strong>Problem 2</strong><br><code>program height;</code></p>
<p>const<br>   OutputString:array[boolean]of string=('YES','NO');</p>
<p>type<br>   rec1=record<br>          h,p:longint;<br>        end;</p>
<p>   pointer=^rec2;<br>   rec2=record<br>          x,y:longint;<br>          dir:boolean;<br>          next:pointer;<br>        end;<br>var<br>   orderHeight : array[1..100000]of longint;<br>   SortHeight  : array[1..100000]of rec1;<br>   Deg,DegHash : array[0..100000]of longint;<br>   EdgeHash    : array[1..100000]of pointer;<br>   n,m,DegCount:longint;</p>
<p>procedure SwapRec(var t1,t2:rec1);<br>var<br>   t3:rec1;<br>begin<br>   t3:=t1;<br>   t1:=t2;<br>   t2:=t3;<br>end;</p>
<p>procedure SwapInt(var t1,t2:longint);<br>var<br>   t3:longint;<br>begin<br>   t3:=t1;<br>   t1:=t2;<br>   t2:=t3;<br>end;</p>
<p>function InsertEdgeHash(x,y:longint):integer;<br>var<br>   newp:pointer;<br>begin<br>   new(newp);<br>   newp^.x:=x;<br>   newp^.y:=y;</p>
<p>   if orderHeight[x] &gt; orderHeight[y] then<br>      newp^.dir:=( 1.25*OrderHeight[y] &lt;= orderHeight[x] )<br>   else newp^.dir:=( 1.25*OrderHeight[x] &gt; orderHeight[y] );<br>   newp^.dir:=not newp^.dir;</p>
<p>   newp^.next:=EdgeHash[x];<br>   EdgeHash[x]:=newp;<br>   exit( ord( newp^.dir ) );<br>end;</p>
<p>function FindEdgeHash(x,y:longint):integer;<br>         { -1: Not Found;  0: x--&gt;y  1: x&lt;--y<br>            x Always Smaller than y }<br>var<br>   now:pointer;<br>begin<br>   now:=EdgeHash[x];<br>   while now&lt;&gt;nil do<br>   begin<br>      if now^.y=y then<br>      begin<br>         now^.dir:=not now^.dir;<br>         exit( ord( now^.dir ) );<br>      end;<br>      now:=now^.next;<br>   end;<br>   exit(-1);<br>end;</p>
<p>procedure UpdateDeg(t,c:longint);<br>begin<br>   if deg[t]&lt;&gt;c then<br>   begin<br>     dec(DegHash[Deg[t]]);<br>     if DegHash[Deg[t]]=0 then dec(DegCount);<br>     inc(DegHash[c]);<br>     if DegHash[c]=1 then inc(DegCount);<br>     Deg[t]:=c;<br>   end;<br>end;</p>
<p>procedure ReadHeight;<br>var<br>   i:longint;<br>begin<br>   readln(n,m);<br>   for i:=1 to n do<br>   begin<br>      readln(OrderHeight[i]);<br>      SortHeight[i].h:=OrderHeight[i];<br>      SortHeight[i].p:=i;<br>   end;<br>end;</p>
<p>procedure Sort(l,r:longint);<br>var<br>   i,j,mid:longint;<br>begin<br>   i:=l;<br>   j:=r;<br>   mid:=SortHeight[(i+j)div 2].h;<br>   repeat<br>      while SortHeight[i].h&lt;mid do inc(i);<br>      while SortHeight[j].h&gt;mid do dec(j);<br>      if i&lt;=j then<br>      begin<br>         SwapRec(SortHeight[i],SortHeight[j]);<br>         inc(i);<br>         dec(j);<br>      end;<br>   until i&gt;j;<br>   if l&lt;j then Sort(l,j);<br>   if i&lt;r then Sort(i,r);<br>end;</p>
<p>procedure Init;<br>var<br>   low:longint=1;<br>   high:longint=1;<br>   i:longint;<br>begin<br>   DegHash[0]:=n;<br>   DegCount:=1;<br>   for i:=1 to n do<br>   begin<br>      while SortHeight[low].h*1.25 &lt; SortHeight[i].h do inc(low);<br>      while ( high&lt;n ) and ( SortHeight[i].h*1.25 &gt;= SortHeight[high+1].h ) do inc(high);<br>      UpdateDeg( SortHeight[i].p, high+low-i );<br>   end;<br>end;</p>
<p>procedure Solve;<br>var<br>   i,x,y:longint;<br>   dir:integer;<br>   newp:pointer;<br>begin<br>   for i:=1 to m do<br>   begin<br>      readln(x,y);<br>      if x&gt;y then SwapInt(x,y);<br>      dir:=FindEdgeHash(x,y);<br>      if dir=-1 then dir:=InsertEdgeHash(x,y);<br>      if dir=0 then SwapInt(x,y);<br>      UpdateDeg(x,Deg[x]+1);<br>      UpdateDeg(y,Deg[y]-1);<br>      writeln( OutputString[DegCount=n] );<br>   end;<br>end;</p>
<p>{====main====}<br>begin<br>   assign(input,'height.in');<br>   reset(input);<br>   assign(output,'height.out');<br>   rewrite(output);</p>
<p>   ReadHeight;<br>   Sort(1,n);<br>   Init;<br>   Solve;</p>
<p>   close(input);<br>   close(output);<br>end.</p>
<p><strong>Problem 3</strong><br><code>program wolf;</code></p>
<p>type<br>   rec=record<br>          left,right:integer;<br>       end;</p>
<p>const<br>   infinite=maxlongint div 3-100000;<br>   //Make sure no overflows occur</p>
<p>var<br>   k,n,m  : integer;<br>   map    : array[1..1000,1..1000]of longint;<br>   dist   : array[1..1000]of longint;<br>   hash   : array[1..1000]of boolean;<br>   father : array[1..1000]of longint;</p>
<p>&amp;nbsp<br>
;  tree : array[1..1000]of rec;<br>   attk : array[1..1000]of longint;<br>   cost : array[1..1000]of integer;<br>   minf : array[1..1000,0..100]of longint;</p>
<p>procedure readp;<br>var<br>   i,x,y,d:longint;<br>begin<br>   readln(k,n,m);<br>   for i:=2 to n do<br>      readln(attk[i],cost[i]);<br>   for i:=1 to m do<br>   begin<br>      readln(x,y,d);<br>      map[x,y]:=d;<br>      map[y,x]:=d;<br>   end;<br>end;</p>
<p>procedure init;<br>var<br>   i,j:longint;<br>begin<br>   for i:=2 to n do dist[i]:=infinite;<br>   for i:=2 to n do hash[i]:=false;<br>   dist[1]:=0;<br>   hash[1]:=true;</p>
<p>   for i:=1 to n do<br>   for j:=1 to n do<br>      if map[i,j]=0 then map[i,j]:=infinite;</p>
<p>   for i:=1 to n do<br>   for j:=1 to k do<br>      minf[i,j]:=-infinite;<br>end;</p>
<p>procedure sssp;<br>var<br>   i,j:longint;<br>   min:longint=0;<br>   minj:longint=1;<br>begin<br>   for i:=1 to n-1 do<br>   begin<br>      for j:=1 to n do if not hash[j] then<br>      begin<br>         if ( min+map[minj,j] = dist[j] ) and ( father[j] &gt; minj ) then<br>           father[j]:=minj<br>         else if min+map[minj,j] &lt; dist[j] then<br>         begin<br>           dist[j]:=min + map[minj,j];<br>           father[j]:=minj;<br>         end;<br>      end;</p>
<p>      min:=infinite;<br>      for j:=1 to n do if not hash[j] and (dist[j]&lt;min) then<br>      begin<br>         minj:=j;<br>         min:=dist[j];<br>      end;</p>
<p>      tree[ minj ].right:=tree[ father[minj] ].left;<br>      tree[ father[minj] ].left:=minj;<br>      hash[ minj ]:=true;<br>   end;<br>end;</p>
<p>function solve(x,y:longint):longint;  //(node,cost)</p>
<p>   procedure update(var t1:longint;t2:longint);<br>   begin<br>      if t1&lt;t2 then t1:=t2;<br>   end;</p>
<p>var<br>   ans:longint=-infinite;<br>   i,t:longint;<br>begin<br>   if minf[x,y]&lt;&gt;-infinite then exit(minf[x,y]);<br>   if y&gt;=cost[x] then ans:=attk[x];</p>
<p>   if tree[x].left&gt;0 then update(ans,solve(tree[x].left,y)+attk[x]);<br>   <br>   if tree[x].right&gt;0 then<br>   begin<br>      update(ans,solve(tree[x].right,y));<br>      if y-cost[x]&gt;0 then<br>         update(ans,solve(tree[x].right,y-cost[x])+attk[x]);<br>   end;<br>   <br>   if (tree[x].left&gt;0) and (tree[x].right&gt;0) then<br>      for i:=1 to y-1 do<br>         update(ans,solve(tree[x].left,i)+solve(tree[x].right,y-i)+attk[x]);</p>
<p>   minf[x,y]:=ans;<br>   exit(minf[x,y]);<br>end;</p>
<p>procedure writep;<br>var<br>   ans:longint=-infinite;<br>   i,j:integer;<br>begin<br>   for i:=0 to k do<br>     if solve(1,i)&gt;ans then ans:=solve(1,i);<br>   writeln(ans);<br>   <br>   {===For Debug===<br>   for i:=1 to n do<br>   begin<br>      for j:=1 to k do write(minf[i,j]:3);<br>      writeln;<br>   end;<br>   for i:=1 to n do writeln(tree[i].left,' ',tree[i].right);<br>   }<br>end;</p>
<p>{====main====}<br>begin<br>   assign(input,'wolf.in');<br>   reset(input);<br>   assign(output,'wolf.out');<br>   rewrite(output);</p>
<p>   readp;<br>   init;<br>   sssp;<br>   writep;</p>
<p>   close(input);<br>   close(output);<br>end.</p>
<p><strong>Problem 4</strong><br><code>program garden;</code></p>
<p>const<br>   dir:array[1..4,1..2]of integer=<br>     ((1,0),(0,1),(-1,0),(0,-1));</p>
<p>type<br>   arr=array[1..10]of integer;<br>   rec=record x,y:integer;end;</p>
<p>var<br>   map:array[0..11,0..11]of boolean;<br>   ans:array[1..100]of rec;<br>   n,m,max:integer;<br>   step:integer=1;<br>   state:arr;</p>
<p>procedure readp;<br>var<br>   i,j:integer;<br>   ch:char;<br>begin<br>   readln(m,n);<br>   for i:=1 to n do<br>   begin<br>      for j:=1 to m do<br>      begin<br>         read(ch);<br>         map[i,j]:=(ch='1');<br>         inc(max,ord( map[i,j] ))<br>      end;<br>   readln;<br>   end;<br>end;</p>
<p>procedure writep;<br>var<br>   i:integer;<br>begin<br>   for i:=1 to step do<br>      writeln( '(' , ans[i].x , ',' , ans[i].y , ')' );<br>end;</p>
<p>procedure solve(x,y:integer);<br>var<br>   tx,ty,d:integer;<br>   step_cache:integer;<br>   state_cache:arr;<br>begin<br>   step_cache:=step;<br>   state_cache:=state;<br>   if step=max then<br>   begin<br>      writep;<br>      exit;<br>   end;</p>
<p>   for d:=1 to 4 do<br>   begin<br>      tx:=x+dir[d,1];<br>      ty:=y+dir[d,2];<br>      while map[tx,ty] and ( not state[tx] and(1 shl (ty-1) )&gt;0) do<br>      begin<br>         inc(step);<br>         ans[step].x:=tx;<br>         ans[step].y:=ty;<br>         state[tx]:=state[tx] or ( 1 shl (ty-1) );<br>         tx:=tx+dir[d,1];<br>         ty:=ty+dir[d,2];<br>      end;</p>
<p>      tx:=tx-dir[d,1];<br>      ty:=ty-dir[d,2];<br>      if (tx&lt;&gt;x) or (ty&lt;&gt;y) then solve(tx,ty);<br>      state:=state_cache;<br>      step:=step_cache;<br>   end;<br>end;</p>
<p>{====main====}<br>var<br>   i,j:integer;<br>begin<br>   assign(input,'garden.in');<br>   reset(input);<br>   assign(output,'garden.o<br>
ut');<br>   rewrite(output);</p>
<p>   readp;<br>   for i:=1 to n do<br>   for j:=1 to m do<br>     if map[i,j] then<br>     begin<br>        ans[1].x:=i;<br>        ans[1].y:=j;<br>        state[i]:=1 shl (j-1);<br>        solve(i,j);<br>        state[i]:=0;<br>     end;</p>
<p>   close(input);<br>   close(output);<br>end.</p>
<p>依然欢迎大家来挑错</p>
			 ]]></content>
<pubDate>2007-05-16T14:39:48+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/201</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 漫话进位制 ]]></title>
<link>http://www.matrix67.com/blog/archives/202</link>
<content><![CDATA[ 
		<p>    人有十个手指，用手指的伸屈来计数非常方便。但一旦对象的数目超过10个了，手指头就不够用了。当然，有人会想到还有脚趾头。搬弄脚趾头是不现实的，数手指头只需要站着比划一下就可以了，数脚趾头还需要坐下来慢慢研究。一种好的方法是每次数完了十个指头后在什么地方做一个标记，比如在地上放一个木棒。人们可以把这根木棒想像成一个“大指头”，它相当于十个指头。这样，我有37个MM就被表示成了地上3个木棒加上我7个手指头。哈哈，你的MM数只有两根木棒加4个手指头，于是我的MM比你的多。久而久之，人们就只接受0到9这十个数字了，再大的数就用几个数字合起来表示。这种“满十进一”的数字系统就叫做十进位制。<br>    如果人只有八个手指头又会怎样呢？那我们现在很可能正在使用八进制，数学发展起来后我们最终只接受八个数字，而大于8的数字就用更高一级的计量单位表示。代表这八个数字的很可能是些星际之门里的怪符号，这里为了便于叙述，我们仍然使用阿拉伯数字的0到7来表示。于是，人类数数的方式将变为：0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17,20,…。这里，数字8被记作10，数字64则用100代替。在这个数学世界里，6+5=13，因为6+1得到的数已经是一位数中最大的了，再加的话只能“进一位”了。“满八进一”将成为数学运算的基本法则。<br>    如果人有12根手指，12进制将成为更难想像的事。在12进制中，人类会把10和11直接想成是一个“数字”。研究的进位制大于10时，大于9的数字我们习惯上用大写字母ABC来表示。这样，自然数序列里将多出两个符号A和B来，数数的方式变为…,8,9,A,B,10,11,12,…。</p>
<p>    我们自然会想，人类生活中究竟有没有其它的进位制呢？当然有。比如，时间和角度就是60进位制，60秒=1分。还有更怪的，计算机的储存容量单位是1024进制的，1MB=1024KB。当然，这也是有原因的。我们在研究几何时常常需要用到1/2，1/3，1/4或者1/6，我们希望这些分数在角度进制下恰好都是整数以便于运算。于是，角度的进位制就变成了60。为什么时间也是60进位制呢？因为时间和角度密切相关，你看看你的手表就知道了（别告诉我你的手表是数字型的）。为什么钟和手表又要用圆形表盘的方式来表示时间呢？其实人自古以来计算时间都是用的圆形盘面，因为地球绕太阳旋转和地球的自转使得时间具有了周期性。<br>    计算机使用二进制，因为计算机元件只有两种状态（开和关，或者说通电和断电），因此计算机只认0和1两个数字。1024是2的幂，又比较接近1000符合人的习惯，因此把1024当成了计算机容量的进位制。</p>
<p>    前段时间有人在OIBH上问，为什么纸币的面值都是1*10^n、2*10^n、5*10^n呢。有人回答说这样的货币系统可以使得某种贪心方法正确。确实有这个结论，这样的货币系统使得解决“凑钱和找零时最少使用多少张纸币”这一问题的贪心算法（不断拿最大面额的纸币）是正确。但用这一点来解释我们的问题显然是可笑的，人们首先考虑的并不是如何方便地使用最少纸币，而是如何方便地得到总面额。一个只有1元纸币和7元纸币的货币系统同样满足贪心性质，但显然傻子才会设计出这种别扭的货币系统来。因此，我的回答是“纸币的面值取10的约数，这样的话凑钱和找零最方便”。但是，有人会问，要是我们使用的进位制不是10怎么办？换句话说，如果我们使用的是23进位制，除1和本身外没有其它约数的话，又该怎样设置货币系统呢。答案非常出人意料，如果我们使用的是23进位制的话，我们很可能根本发展不出数学这门学科来。10=1+2+3+4，是前四个正整数的和；10又是2和5的积；这样的进位制非常适合数学的发展。同样地，6=1+2+3，6=2*3，因此可能正在使用六进制的昆虫们很容易发展出数学来（六足动物的数学非常强，不是有人发现了蜜蜂蜂巢的六边形样式设计是最科学的么）。大家看过《计算机中的上帝》(Calculating God)吗？那里面构造了这样一种生物：他有23根手指。这种别扭的数字最多只能让人联想到乔丹和染色体，除此之外没有任何特性。这给这种生物的数学发展带来不可逾越的困难。而事实上，这种生物恰好又没有发展数学的必要性。他就好像人类一样，对较小的物体个数具有直接感知的能力。人类可以直接感知的物体数量一般不超过6。也就是说，如果你眼前有3个，或者5个东西，你不需要数，看一眼就知道有多少个；但当你眼前出现的物体数目达到7个或者8个时，你就必须要数一数才知道个数了。而我们所说的生物面对的物体数目多达46个时仍然可以一眼分辨出多少来，数目超过46后就统称为“很多”了。直接感知数目达到50甚至60多的生物个体就扮演着该种族中的僧侣角色。46这个数字对于种族的生存已经完全足够了，他们在组建部落时总会保证部落的个体数不超过这个数字。因此，这种生物不需要数数的能力，他们也就无须发展数学了。他们不知道30加30等于多少，从某种意义上说他们甚至不知道一加一等于几，因为他们头脑中根本没有数字这个概念。作为一种补偿，他们对事物的感知能力相当敏锐。他们甚至直接凭直觉感知到了相对论，因为他们的思维不受演绎逻辑的束缚。</p>
<p>    下文将介绍两套进制转换的方法，然后介绍这两套方法在小数转换上的应用。更多的进位制相关应用你可以在文后的习题部分中体会到。</p>
<p>    在讲进位制时，大多数教材会教大家二进制和十进制如何互换。今天我就偏不这样讲，我要和那些教材讲得一样了我还不如不写今天这些东西。二进制虽然常用，但比较特殊，很可能会了二进制但仍然不会其它进制；我们今天当一回蜜蜂，看看六进制和十进制怎么互相转换。学会这个后，任意进制间的转换你就应该都会了。<br>    说起进位制时往往要回到最根本的一些计数方法上。这篇日志是我第237篇日志。数字“237”表示两个百，加上三个十，加上七个单位一。我们把它们分别叫百位、十位和个位，同一个数字在不同数位上表示的实际数量不同。用一个式子表示上面的意思就是，237=2*100+3*10+7。这就是进位制的实际意义。<br>    现在，假如我是一只勤劳的蜜蜂。我写237篇日志是肯定不可能的了，因为我的数学世界里根本没有7这个数字。那就说我写了235篇日志吧。结合前面所说的东西，“十位”上的数表示有多少个6，“百位”上的数表示有多少个36（后面提到的十位、百位打引号表明这不是十进制中的“十”和“百”）。于是，六进制下的235就应该等于2*6^2+3*6+5。这个算式你用什么进制算出答案就相当于把六进制中的235转换为了什么进制。不过你要把这个式子当成别的进制算是不大可能的，算之前你估计得重新背一遍乘法口诀表（注意我为什么不说是“九九”乘法口诀表）。这就是我们为什么一般只研究十进制与其它进制互换的原因。我们用熟悉的十进制进行计算，得出2*6^2+3*6+5=72+18+5=95。这是按定义进行进制转换的方法。六进制的235等于十进制的95，我们记作(<br>
235)6=(95)10。那个6和10是下标，应该像H2O的2一样小小地写在下面。我就懒得排版了，反正转贴个几次就成Plain Text了。<br>    下面的任务是，考虑怎么把(95)10变回(235)6。使用六进制计算13*10+5可以得到235（十位上的9相当于六进制中的13），但我们说过六进制计算很麻烦。下面我们给出一种把十进制转换为六进制的方法，仔细思考你会发现这种方法显然是正确的。我们把所有6的幂从小到大写出来：1,6,36,216,…。216远远超过95了，因此95的六进制不可能是四位数。95里面有两个36，因此在最高位上写个“2”。去掉两个36，95里只剩23。23里有三个6，数字3将填写在第二位上，去掉这三个6最后所剩的5留给最末位。换句话说，我们不断寻找最大的x使得6^x不超过当前数，当前数减去6^x并在右起第x+1位上加一。这事实上是前面六进制转十进制的逆过程。<br>    上面的进制互换方法是一套方法，这是我们所介绍的第一套方法。这套方法的特点是正确性很显然，但是计算比较复杂，又费马达又费电。我们需要一个计算更方便的进制转换方法。下面介绍的就是进制转换的第二套方案。</p>
<p>    再一次回到一个很基础的问题：在十进制中，为什么乘以10相当于在数的末尾加一个0？我们同样会联想到位运算：为什么二进制左移一位（末尾加一个0）相当于乘以2？事实上，这个结论普遍存在于所有进位制中：k进制数的末尾加个0，相当于该数乘以k。证明方法非常简单，乘以一个k就相当于进位制展开式的每个指数都加一，也就相当于所有数字左移一位。六进制235=2*6^2+3*6+5，乘以6的话式子将变为2*6^3+3*6^2+5*6，也即2350。利用这个性质，六进制235可以很快转为十进制：235相当于2后面添0，加上3，再添一个0，再加上5，写为算式即(2*6+3)*6+5=95。把(2*6+3)*6+5展开来，得到的式子和前面的那种计算方法(2*6^2+3*6+5)一模一样，但这里的计算方式更简便一些。如果写成程序，六进制字符串t转为十进制数a只需要一句话就可以完成：<br><code>for i:=1 to length(t) do a:=a*6+ord(t[i])-48;</code><br>    使用这种方法将十进制变回六进制是一个彻头彻尾的逆向操作：当前数不断除以6并把余数作为新的最高位。比如，95除以6等于15余5，余数5就是个位，15除以6的余数3作为“十位”，最终的商2是“百位”。这叫做短除法，是最常见的方法，网上随处可见。</p>
<p>    下面说一下进位制中的小数。前面的东西如果理解了，小数进制的转换将顺理成章地进行下去。六进制中的0.1相当于十进制的1/6，因为六进制中的0.1、0.2、0.3、0.4、0.5五个数把区间0到1均分为了6分。同样地，(0.05)6=(5/36)10。你会发现，一个“十分位”代表1/6，一个“百分位”代表1/6^2，之前的很多结论仍然成立。六进制小数12.345就等于1*6^1+2*6^0+3*6^(-1)+4*6^(-2)+5*6^(-3)，通过负指数把进制转换的整数部分和小数部分联系在了一起。(12.345)6转为十进制后居然变成了无限小数，其实这并不奇怪，这只是一个约数的问题：同样是三分之一，在我的六进制下正好分干净(0.2)，但在你十进制下就总也分不完，总要剩一点留给下一位(0.333333…)。<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=175">这里</a>有一些小数进制转换的实例。可以看到，一个进制下的有限小数很可能是另一个进制下的无限循环小数。另一个有趣的例子在<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=251">这里</a>。<br>    既然前面所说的第一套方法中六进制转十进制对于小数仍然成立，那么第一套方法的十进制转六进制也可以直接在小数上使用。如果你嫌无限小数很别扭，用分数进行操作是一种不错的选择。具体操作方法和前文叙述一模一样。针对纯小数的进制转换，我们把前文的描述换种方法再说一遍：不断寻找最小的正整数x使得1/6^x不超过当前数，当前数减去1/6^x并在小数点后第x位上加一。我就不再举例子了，下面主要讨论第二套方法在小数上的应用。<br>    我们曾说过，在k进制末尾加0相当于该数乘以k。可惜这对小数没有用，小数后你加它八百个“0”这个数仍然不变。其实，“末尾加0”只是这种性质反映在整数上的一种现象而已，我们还需要看到更本质的东西（还记得高二哲学么）。考虑到小数的乘k和除k，不难想到这种性质的实质是小数点的移动，整数的末尾加0其实是小数点向右移动一位的结果。显然小数也有类似的结论：将k进制小数的小数点左移一位，相当于该数除以k。比如，十进制中3.14除以10就变成了0.314。结论的证明和原来完全相同：除以k后展开式中的指数全部减一，相当于所有数右移一位。有了这个结论，我们的方法就出来了。来看六进制12.345如何转换为十进制。由于这种方法对整数和小数的处理方法有一些不同，转进制时我们通常对整数部分和小数部分分别进行操作。先把12转成十进制的8，然后单独考虑小数部分。0.345可以看作是数字“5”的小数点左移，加上4后小数点再次左移，再加上3并最后一次左移小数点；写成算式即((5/6+4)/6+3)/6。展开这个式子，实质与前面的方法仍然一样。小数部分十进制转六进制依然是彻头彻尾的逆向操作：当前数不断乘以6并取出整数部分写下来。<br>    这里有一个实例供大家参考，这个例子中的进制转换保证不涉及无限循环小数。1/4在十进制和六进制下的表示肯定都是有限小数，因为4的唯一一个因子2同样也是10和6的因子。先看0.25怎么变成六进制：0.25*6=1.5，取出1，留下0.5；0.5*6=3，没有小数部分了，因此(0.25)10就等于(0.13)6。现在我再把它变回去：(3/6+1)/6=(0.5+1)/6=1.5/6=0.25。这不是彻头彻尾的逆操作吗？</p>
<p>    每年NOIp前总有人问负进位制。事实上，如果你搞清了上面的问题，负进位制将非常好理解。负进位制有一个非常奇特的功能：它可以表示出负数但不需要用负号。一个负进制数可能是负数，也可能是正数。比如，负六进制下的12等于十进制下的-4，而负六进制下的123等于1*(-6)^2+2*(-6)^1+3，即十进制下的27。是正是负取决于位数的奇偶：若该数有偶数位，则该数为负数；若有奇数位，则该数为正数。原因很简单，小数点每右移一位，相当于这个数乘以-6；从一位数开始，乘奇数次后该数的位数变成偶数且值为负，乘偶数次该数仍有奇数位且值仍为正。由于末尾添0的性质（小数点移位的性质）仍然成立，负六进制与十进制的转换依然是上面的方法：(123)-6=(1*(-6)+2)*(-6)+3=(27)10。十进制转负六进制？还是那句话：彻头彻尾的逆操作。找到最小的非负整数x使得当前数减x能被6整除，这个x将作为新的最高位写到结果中，然后当前数减去x再除以-6。在这里我不说“余数”这个词，因为当除数为负数时对余数的定义很模糊。不再举例子了，例子都举烦了，自己把(123)-6=…=(27)10那一行倒过去看就是例子了。<br>    当然，还有更神奇的：-1+i进制可以表示出复数来，因为-1+i的幂有时含有虚数有时不含虚数。运算和转换依然和上面这些东西一样，我也就不多说了。</p>
<p>    进位制的问题结束了。我们这里是以六进制为例进行的说明，但是不要忘</p>
			 ]]></content>
<pubDate>2007-05-20T02:22:39+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/202</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 考验你的思维能力：一类含有if P then Q句式的逻辑问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/203</link>
<content><![CDATA[ 
		<p>    今天回学校，有人说我智商降低了。我仔细想了一下，这段时间的数理思考确实少了些；但也不能说我完全废了，我还出了一次模拟赛的题呢。摆脱应试教育的思维模式后，不知道我的智商是上升了还是下降了。我开始在想如何检测我的思维是否还和原来一样敏捷。<br>    刚才看到OIBH上又在讨论数理逻辑，然后网上找到了这几道逻辑题来想。实践证明，我的思维能力仍然还不错。我把这些题目写在下面大家可以试一下。<br>    这是一类问题，这类问题的命题中包含有条件判断的形式。</p>
<blockquote>
<p>Following are several problem from the island of knights and knaves where knights always tell truth whereas knaves always lie.</p>
<p>   1. A makes the following statement: "If I am a knight then so is B." What are A and B?<br>   2. Someone asks A, "Are you a knight?" He replies, "If I am a knight then I'll eat my hat". Must he eat his hat?<br>   3. A says, "If I am a knight then 2+2=4." Is A a knave or a knight?<br>   4. A says, "If B is a knight then I am a knave." What are A and B?</p>
</blockquote>
			 ]]></content>
<pubDate>2007-05-21T13:21:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/203</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：哪条线段最长，哪条线段最短 ]]></title>
<link>http://www.matrix67.com/blog/archives/204</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
<p>    最近cut-the-knot上的一些新东西比较有意思。今天下午没事干，我翻译一些我觉得好玩的和大家分享。<br>    上图显示了用直线将一个四分之一圆分为面积相等的两份的三种方法。这三条线段中，哪一个最长，哪一个最短？<br>    答案在下面。</p>
<div align="center"><img alt="image placeholder" >
<p>    第一种方案的线段长度等于圆的半径；<br>    第二种方案的线段长度显然大于半径，因为红色线段和半径长度相等，但它还不足以平分扇形面积。<br>    第三种方案的线段长度显然小于半径。</p>
<p>因此，线段长度为②&gt;①&gt;③。</p>
			 ]]></content>
<pubDate>2007-05-21T15:07:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/204</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：阿米巴的生存 ]]></title>
<link>http://www.matrix67.com/blog/archives/205</link>
<content><![CDATA[ 
		<p>    在每一代的繁殖中，单个的阿米巴原虫有3/4的概率分裂成两个，有1/4的概率死亡（而不产生下一代）。初始时只有一个阿米巴原虫，求阿米巴原虫会无限繁殖下去的概率。<br>    答案在下面。</p>
<p>    解答：令p为单个阿米巴原虫分裂的概率（题目中等于3/4），令P为我们要求的概率（无限繁殖的概率）。<br>    初始时的那个阿米巴原虫有p的概率分裂为两个，至少有一个可以无限生存下去的概率为1-(1-P)^2。那么，我们得到式子：<br>      P = p*( 1 – (1-P)^2 )</p>
<p>    化简后得到：<br>      p*P^2 + (1 – 2p)P = 0</p>
<p>    或者写成：<br>      P * ( pP + ( 1-2p ) ) = 0</p>
<p>    由于P≠0，因此pP+(1-2p) = 0，即P = (2p-1)/p</p>
<p>    可以看到，如果一个阿米巴原虫分裂的概率没超过1/2，那么它<del datetime="2008-08-14T15:28:00+00:00">不可能永远生存下去</del>无限生存下去的概率为0。在我们的题目中，p=3/4，因此阿米巴原虫无限繁殖的概率为2/3。</p>
			 ]]></content>
<pubDate>2007-05-21T15:28:12+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/205</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 又一种证明根号2是无理数的方法 ]]></title>
<link>http://www.matrix67.com/blog/archives/206</link>
<content><![CDATA[ 
		<p>    今天的最后一篇日志了，仍然是翻译的cut-the-knot。发完我就睡觉去了。</p>
<p>    <a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=196">这里</a>已经有五种证明根号2是无理数的方法了。现在我们算是介绍第六种方法了。<br>    一个有限小数的平方绝对不可能变成整数，因为小数部分不可能消失。观察有限小数的小数部分最后一个数字你会发现结论是显然的，平方后它总会产生新的“最后一位”。<br>    下面证明，(n/m)^2不可能等于2。n/m不可能是整数，于是把它写成小数形式，而有限小数的平方不可能是整数。如果n/m不是有限小数的话，可以把它转换成另外的进制使得n/m是有限小数，因而上面的结论仍然成立。<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=246">一个进制下的无限小数可能是另一个进制下的有限小数</a>。比如，把分数n/m转化为m进制，得到的小数肯定是有限小数。</p>
			 ]]></content>
<pubDate>2007-05-21T17:12:18+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/206</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ What's Special About This Number? ]]></title>
<link>http://www.matrix67.com/blog/archives/209</link>
<content><![CDATA[ 
		<p>偶然发现的一个网页，希望大家别说我火星。<br>http://www.stetson.edu/~efriedma/numbers.html</p>
			 ]]></content>
<pubDate>2007-05-25T01:18:28+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/209</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 绝非PS：今天我用硬纸板做出了一个不可能几何体 ]]></title>
<link>http://www.matrix67.com/blog/archives/210</link>
<content><![CDATA[ 
		<p><strong>手工制作完成图：</strong>
</p>
<div align="center"><img alt="image placeholder" >
<p><strong>所使用的材料：</strong>
</p>
<div align="center"><img alt="image placeholder" >
<p>我想应该有人知道我是怎么做的，但是从来没有实践过吧。<br>今天我实践了一下，嗯~貌似效果不错。</p>
			 ]]></content>
<pubDate>2007-05-25T15:34:31+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/210</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 讲个故事：一切都是数字 – Numb3rs S01Ep01 ]]></title>
<link>http://www.matrix67.com/blog/archives/212</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
<p>
</p>
<blockquote>We all use math everyday: to forecast weather, to tell time, to handle money; we also use math to analyze crime, reveal patterns, predict behavior. Using numbers we can solve the biggest mysteries we know.</blockquote>
<p>    上面这个图片我非常喜欢，是美剧Numb3rs的一个经典画面，展示出一个数学家眼前的世界。上面这段话也非常经典，它告诉我们数学无处不在。这部单元剧讲述一个数学家帮助FBI破案的故事，开篇第一集（下文有些许改动）给我印象最深。</p>
<p>
</p>
<div align="center"><img alt="image placeholder" >
<p>    一个城市里发生了连环杀人事件，FBI探员Don Eppes负责调查此案。Eppes工作非常忙，为了充分利用时间，他把案件的资料带回了家。他的天才弟弟Charlie看到了其中一份案件资料——一张标有13个受害人被害地点的地图。Charlie是一个应用数学家，他告诉他哥，我可以帮助你。Don回答，虽然你曾帮助我破过几次经济案件，但这次的案件与数字无关，你帮不上忙。Charlie说你错了，数学无处不在，Everything is numbers。他把他哥带到屋外灌溉草坪用的喷水器旁边说，我们知道喷水器的位置，并且测量出水压、气压、风力等一切参数，那么我们完全可以计算出每个水滴精确的落点；反过来，如果我们已经知道每个水滴落地的时间和位置，我们可以用数学方法推算出喷水器的位置，并预测下一个水滴将出现在什么地方。同样地，连环杀手犯案的时间和地点也受到地形、街道、人口、警力部署和他自身心理等等的影响。这些参数可以从FBI的资料中得到，比如我们可以从被害者的伤口形状和深浅看出凶手当时的心理状态。建立适当的数学模型，我可以推算出他的居住地和下一次凶案发生的地点。</p>
<p>
</p>
<div align="center"><img alt="image placeholder" >
<p>    应用数学家Charlie就这样开始了案件分析。Charlie从以往的资料中找到了一般连环杀手选择凶案地点的模式：凶案现场不会离他家太近以免遭到警方嫌疑，同时凶手也不会走得太远；凶手会潜意识地避免在大致相同的地点犯案，以免产生固定的模式。根据这些假设，Charlie推算出了凶手所住的地方。故事总是一波三折，FBI的调查表明Charlie算出的地点是错误的。这个模型哪里有问题？</p>
<p>
</p>
<div align="center"><img alt="image placeholder" >
<p>    几天的思考后，Charlie带着他的新发现来到FBI办公室。他说，我的模型是正确的，但数据错了。假设凶手确实住在那里，我构造的一个新算法可以返回去算出某时某地发生凶案的概率。对于已经发生的这十几起凶杀案，算法得到的概率几乎都大于70%；而其中一个案件却不符合这个模式，被害者在那里遇害只有2%的可能。看来你们需要重新调查这个案件，目击者很可能隐瞒了什么。<br>    FBI再次拜访目击证人，证实了Charlie的猜想。目击者确实撒了慌，因为她不想让她的未婚夫知道她去哪里了。她说出了案件发生的真实地点，这个地点完全符合凶手的模式。这是Charlie的数学模型第一次发挥了作用。重新应用Charlie的模型，FBI得到了一个新的“可疑区域”，这个区域里的人数比较多，需要一个一个调查。</p>
<p>
</p>
<div align="center"><img alt="image placeholder" >
<p>    但很快，区域中的所有人都排除了嫌疑，FBI决定在更大的范围内搜寻目标。这预示着Charlie的模型还有问题。是哪里有问题？算法错了？计算错了？直到他走进了他的办公室才恍然大悟，骂自己笨得居然没有想到这个：普通人的活动范围并不只是以居住地为中心，大多数人都过着两点一线的生活。凶手很可能在工作和家之间来往。模型和算法都没错，只是最初的假设错了——喷水器不是一个，而是两个。被害者遇害地点的模式并不只是由一个中心点决定的，而是由一个“工业区—居住区”的哑铃形区域确定。</p>
<p>
</p>
<div align="center"><img alt="image placeholder" >
<p>    新的结果很快打印了出来。根据新的可疑区域，FBI找到了凶手的住处和新的作案地点，并及时救出受害者，证实了Charlie的这一想法。Charlie再一次感叹，Everything is numbers。 Numbers, numbers, numbers… 屏幕上的画面随着似有似无的回声淡出。</p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-05-30T02:22:14+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/212</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ C语言速成手册（三）：数组、字符串、结构 ]]></title>
<link>http://www.matrix67.com/blog/archives/220</link>
<content><![CDATA[ 
		<p><strong>一维数组的定义、初始化和使用</strong><br>    定义一个一维数组的格式如下：<br><code>类型 数组名[数组大小];</code><br>    数组的下标范围总是从0开始（因此下标最大为数组大小减一）。下面一行语句定义了一个大小为10的长整型数组：<br><code>long value[10];</code><br>    这相当于下面的Pascal语句：<br><code>var value:array[0..9]of longint;</code><br>    C语言的数组范围左端点不能自定义，它的数组下标只能从0开始。</p>
<p>    下面几种方式可以在定义数组的同时进行初始化：<br><code>long value[10] = { 0, 8, 2, 0, 3 } ;</code><br><code>long value[10] = { [1]=8, [2]=2, [4]=3 } ;</code><br>    上面两个语句是等价的。其中前一种方法依次对数组的前5个数进行初始赋值，后一种方法仅对数组的其中三个位置进行初始化。初始化中没有涉及到的下标所对应的数值自动被设为0。<br>    C语言允许数组的大小为一个变量，但这样的数组在定义时不能像上面一样进行初始化。<br>    这种初始化方法只在定义数组时用，不能用于程序中的赋值。数组之间也不能直接赋值，你不能把数组a整个赋值给数组b。</p>
<p>    程序中使用数组的方法和Pascal一样。下面的程序将输出1000以内的素数：<br><code>#include &lt;stdio.h&gt;<br>#include &lt;stdbool.h&gt;<br>int main()<br>{<br>   bool isPrime[1000];<br>   int i,j;<br>   <br>   for(i=2;i&lt;1000;i=i+1)<br>      isPrime[i]=true;<br>      <br>   for(i=2;i&lt;1000;i=i+1)<br>   {<br>      if (isPrime[i])<br>      {<br>          printf("%d ",i);<br>          for(j=2*i;j&lt;1000;j=j+i)<br>             isPrime[j]=false;   <br>      }<br>   }<br>   <br>   return 0;<br>}</code><br>    当一维数组作为函数参数时，数组大小可以不写，以适应不同长度的数组。通常你还需要另一个参数告诉函数你的数组有多大。下面这个函数返回数组中的最大值：<br><code>long maxValue ( long length, long array[] )<br>{<br>   long i, max = 0;<br>   for ( i=0; i&lt;length; i=i+1)<br>      if (array[i]&gt;max) max = array[i];<br>   return max;<br>}</code><br>    下面的代码合法地调用了上面的函数。<br><code>long a[5] = { 1, 5, 7, 3, 4 };<br>printf( "%d" , maxValue( 5,a ) );</code></p>
<p><strong>C语言中的字符串</strong><br>    C语言也使用字符数组作为字符串。定义一个char a[20]，就相当于定义了一个长度不超过20的字符串。Pascal中使用a[0]记录字符串的长度，字符串内容从a[1]开始；但C语言并不直接记录字符串长度，a[0]表示字符串的第一个字符，最后以ASCII码0（或写成字符'</p> ]]></content>
<pubDate>2007-06-08T02:03:04+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/220</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 爱的方程式（加强版） ]]></title>
<link>http://www.matrix67.com/blog/archives/223</link>
<content><![CDATA[ 
		<p>你或许还记得<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=107">爱的方程式</a>是什么。<br>今天我看到了一个加强版，(x^2 + (9/4)y^2 + z^2 – 1)^3 – x^2z^3 – (9/80)y^2z^3 == 0。<br>下面是本人亲自用Mathematica绘的图，发出来给大家看看。</p>
<p>图片为Matrix67原创<br>转贴请注明出处</p>
<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2007-06-09T22:21:52+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/223</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ C语言速成手册（四）：指针、动态内存分配、标准输入 ]]></title>
<link>http://www.matrix67.com/blog/archives/225</link>
<content><![CDATA[ 
		<p><strong>指针的定义</strong><br>    定义一个指针的方法如下：<br><code>类型名 *指针名;</code><br>    例如，下面的语句定义了一个指针：<br><code>int *pointer;</code><br>    这样，pointer就是一个指针，它指向的是一个int类型的数据。</p>
<p>    一个指针可以是一个合法的内存地址，也可以为0（通常写成NULL）。<br>    你可以用printf语句输出一个指针，对应的标识为"%p"。下面的代码可以输出上面定义的指针指向的地址。<br><code>printf("%p",p);</code></p>
<p><strong>取地址与引用</strong><br>    假如a是一个变量，p是一个指针，那么&amp;a返回该变量的地址，*p返回该指针所指的内容（称做“引用”）。<br>    阅读下面的代码片段：<br><code>int *p;<br>int a = 520;<br>p = &amp;a;<br>printf( "%p -&gt; %dn", p, *p );<br>*p = 1314;<br>printf( "%p -&gt; %dn", p, *p );<br>printf( "a = %d", a );</code><br>    程序输出如下。当执行了p=&amp;a后，存取*p就相当于是存取变量a了。<br><code>0022FF78 -&gt; 520<br>0022FF78 -&gt; 1314<br>a = 1314</code></p>
<p><strong>动态内存分配</strong><br>    首先介绍sizeof函数（准确地说是一个运算符），它的参数为一个变量名或类型名，返回的是它所占内存空间的大小。下面的代码输出1 8 800 4 1 。<br><code>long long a;<br>double b[100];<br>_Bool *c;<br>printf( "%d " , sizeof(char) );<br>printf( "%d " , sizeof(a) );<br>printf( "%d " , sizeof(b) );<br>printf( "%d " , sizeof(c) );<br>printf( "%d " , sizeof(*c) );</code></p>
<p>    下面介绍四种动态内存分配函数，使用它们前需要在程序最前面包含头文件stdlib.h。四种函数的格式分别为：<br><code>void *malloc ( size );<br>void *calloc ( n, size );<br>void free ( pointer );<br>void *realloc( pointer, size );</code><br>    函数malloc将在内存里寻找一个大小为size的连续空间，把分配到的内存地址作为一个指向void类型的指针（默认的无类型指针）返回。如果空间分配失败，函数返回NULL。<br>    函数calloc将在内存里寻找一个大小为n * size的连续空间，并且把这段内存的数据全部清0，返回数据和malloc一样。如果空间分配失败，函数返回NULL。<br>    函数free用于释放内存空间，释放后的空间被回收，可以用于以后的malloc或calloc操作。<br>    函数realloc在保证已有数据不变的情况下改变已有指针的空间大小，返回重新分得的空间的内存地址（有可能和原来不同）。如果空间重新分配失败，函数返回NULL。<br>    Pascal中的new语句可以用前两个函数代替，free语句则相当于Pascal中的dispose。</p>
<p>    注意，malloc和calloc函数所返回的指针还没确定类型，理论上需要用类型转换。下面的程序合法地为p指针分配空间：<br><code>int *p;<br>p = (int *) malloc( sizeof(int) );<br>*p = 520;</code><br>    事实上，由于赋值时C语言自动转换类型，因此那个类型转换是没有必要的（去掉(int *)没有影响）。</p>
<p><strong>指针与结构</strong><br>    一个指针可以指向一个结构，一个结构也可以包含一个指针。结构里包含一个指向结构的指针就构成了链表：<br><code>struct node{<br>   int value;<br>   struct node *next;<br>}</code><br>    这样，定义struct node *a，则(*a).next就是另一个指向node结构的指针。在C语言中，(*x).y的句型很常用，因此有一个专门的记号x-&gt;y来代替(*x).y这样繁杂的写法。<br>    你可以从下面的程序中看到链表的使用。<br><code>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>    <br>struct node<br>{<br>   int value;<br>   struct node *next;<br>};</code></p>
<p>int main()<br>{<br>    struct node *head = NULL;<br>    int i;</p>
<p>    for(i=1;i&lt;=10;i=i+1)<br>    {        <br>        struct node *newNode;<br>        newNode = malloc( sizeof(struct node) );<br>        newNode-&gt;value = i;<br>        newNode-&gt;next = head;<br>        head = newNode;<br>    }<br>    <br>    struct node *p = head;<br>    while (p)<br>    {<br>        printf( "%dn", p-&gt;value );<br>        p = p-&gt;next;<br>    }<br>    return 0;<br>}</p>
<p><strong>指针与函数</strong><br>    前面说过，C语言中的函数参数和变量只能够供该函数使用。<br>    下面四个程序代码的输出分别是什么？</p>
<p>    代码一：<br><code>#include &lt;stdio.h&gt;<br>void swap( int a, int b )<br>{<br>   int c = a;<br>   a = b;<br>   b = c;<br>}<br>int main()<br>{<br>   int a = 520, b = 1314;<br>   swap( a , b );<br>   printf( "%d %d", a, b );<br>   return 0;<br>}</code></p>
<p>    代码二：<br><code>#include &lt;stdio.h&gt;<br>int a = 520, b = 1314;<br>void swap( int a, int b )<br>{<br>   int c = a;<br>   a = b;<br>   b = c;<br>}<br>int main()<br>{<br>   swap( a , b );<br>   printf( "%d %d", a, b );<br>   return 0;<br>}</code></p>
<p>    代码三：<br><code>#include &lt;stdio.h&gt;<br>int a = 520, b = 1314;<br>void swap()<br>{<br>   int c = a;<br>   a = b;<br>   b = c;<br>}<br>int main()<br>{<br>   swap();<br>   printf( "%d %d", a, b );<br>   return 0;<br>}</code></p>
<p>    代码四：<br><code>#include &lt;stdio.h&gt;<br>void swap( int *a, int *b )<br>{<br>   int c = *a;<br>   *a = *b;<br>   *b = c;<br>}<br>int main()<br>{<br>   int a = 520, b = 1314;<br>   swap( &amp;a, &amp;b);<br>   printf( "%d %d", a, b );<br>   return 0;<br>}</code></p>
<p>    答案：前两个程序输出520 1314，后两个程序输出1314 520。<br>    前两个程序中，待交换的两个数（即使是全局变量）作为参数传给了swap函数，该函数里的操作对函数外无影响。<br>    第三个程序中，swap函数对全局变量直接进行操作，其影响是全局的。<br>    最后一个程序巧妙地应用了指针来实现两数交换。函数的参数是指针类型，这个函数不能改变指针本身，但可以改变指针所指的内容。这是写此类函数通常所用的方法。<br>    为了强调函数void swap( int *a, int *b )中的指针本身不发生改变，很多地方喜欢写成void swap(const int *a, const int *b ) 。</p>
<p><strong>指针与数组</strong><br>    数组由内存的连续空间构成，因此可以用指</p>
			 ]]></content>
<pubDate>2007-06-13T21:40:34+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/225</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Google US Puzzle Championship即将开始 热身赛已发布 ]]></title>
<link>http://www.matrix67.com/blog/archives/227</link>
<content><![CDATA[ 
		<p>    订阅这个Blog的人可能不止OIer，或许有一些喜欢数学谜题或者智力游戏的人。<a target="_blank" href="http://www.google.com/puzzles/">Google US Puzzle Championship</a>即将开始了，不知道是否有人感兴趣。<br>    四道测试题已经发布，我翻译一下放在这里。</p>
<p>================= 我是性感的分割线 =================</p>
<p><strong>Puzzle #1 – Arrow Sudoku</strong><br>    数独加强版：每个圆圈里的数必须要等于对应箭头标识的路径上的数之和。</p>
<p>       <img alt="image placeholder" >
<p><strong>Puzzle #2 – Card Trick (Cihan Altay)</strong><br>    14张写有数字的卡片放在了3×3的格子里，每行每列的数字之和已经给出。拿起其中两张卡片，放回格子中的任意位置，使得六个总和相等。</p>
<p>       <img alt="image placeholder" >
<p><strong>Puzzle #3 – Point Pairs (Cihan Altay)</strong><br>    用13条直线段将图中的点成对地连起来，使得这些线段的长度正好是1到13中的13个数。每个点只能用一次；线段与线段间可以交叉，但线段上不能有其它点。</p>
<p>       <img alt="image placeholder" >
<p><strong>Puzzle #4 – First Name Basis (Shawn Kennedy)</strong>
</p>
<ul>
<li>ADA</li>
<li>ALDOS</li>
<li>ALEX</li>
<li>ANN</li>
<li>BYRON</li>
<li>ELIJAH</li>
<li>ELLA</li>
<li>HANS</li>
<li>HESS</li>
<li>ISABEL</li>
<li>JOYCE</li>
<li>LANCE</li>
<li>LEAH</li>
<li>LENA</li>
<li>REX</li>
<li>SOL</li>
</ul>
<p>     把上面的16个名字放在下面的格子中（每格放一个字母），使得每一行、每一列恰好出现一个名字（中间允许有空格出现）。<br>    <img alt="image placeholder" >
<p>    下面的例子演示了有12个单词的情况，其中横向的单词为WOOD, INCH, LATE, PUN, TERSE, STEW，纵向的单词为WILT, NAPS, OCTET, OUR, DENSE, HEW。<br>    <img alt="image placeholder" >
<p>================= 我是性感的分割线 =================</p>
<p>    这些题的答案都还很“正常”，第二题除外。第二题的答案打死你都想不到：<span style="color:#E5E5E5">把右边的1覆盖在下边的2上，把左上角的9当成6放回去，这样所有的和都是27</span>。</p>
			 ]]></content>
<pubDate>2007-06-14T21:24:30+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/227</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 推荐： The Hundred Greatest Theorems ]]></title>
<link>http://www.matrix67.com/blog/archives/228</link>
<content><![CDATA[ 
		<p>经常在网上看到小说Top 100，电影Top 250，AV女优Top 10之类的东西，有想过给数学定理排名吗？<br>99年的一次数学大会上有人给出了“百大数学定理”列表，附有定理证明的时间和证明者。<br>http://personal.stevens.edu/~nkahl/Top100Theorems.html</p>
<p>其中，排名前十位的数学定理如下：<br>1. <a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=196">根号2是无理数</a><br>2. 代数基本定理<br>3. 有理数集是可数集<br>4. 勾股定理<br>5. 素数定理<br>6. 歌德尔不完备定理<br>7. 二次互反律<br>8. 不可能尺规三等分角和倍立方体<br>9. 圆的面积<br>10. <a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=280">费马小定理的欧拉推广</a></p>
			 ]]></content>
<pubDate>2007-06-16T02:11:58+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/228</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ C语言速成手册（五）：其它运算符、文件操作、其它函数 ]]></title>
<link>http://www.matrix67.com/blog/archives/230</link>
<content><![CDATA[ 
		<p><strong>条件运算符</strong><br>    条件运算符的格式如下：<br><code>表达式1 ? 表达式2 : 表达式3</code><br>    它表示：若表达式1为真（非0），则返回表达式2，否则返回表达式3。</p>
<p>    下面的函数返回两个数中较小的一个：<br><code>long min( long a, long b)<br>{<br>   return (a&lt;b)?a:b;<br>}</code><br>    很多地方都可能用到条件运算符。再比如求平均数时你可能会这样写：<br><code>average = (n&gt;0) ? sum/n : 0;</code></p>
<p><strong>自加、自减</strong><br>    a=a+1可以写成a++或++a，a=a-1可以写成a–或–a 。例如，你会经常看到这样的写法：<br><code>for ( i=1; i&lt;=10; i++ )<br>{<br>}</code><br>    如果自加自减不是单独成句，而是放在其它语句中的话，那么a++和++a是有区别的。a++表示“用了后再加”，++a表示“加了后再用”。a–和–a的区别同理。下面的代码输出0 1 1 1。<br><code>int a=0;<br>printf("%d ",a++);<br>printf("%d ",a);</code></p>
<p>int b=0;<br>printf("%d ",++b);<br>printf("%d",b);</p>
<p><strong>其它运算符</strong><br>    下面所有的a和b均为整型，则：<br><span style="font-family:宋体">C语言  |  Pascal语言<br>——-+————-<br>a &amp; b  |  a and b<br>a | b  |  a or b<br>a ^ b  |  a xor b<br>a &lt;&lt; b |  a shl b<br>a &gt;&gt; b |  a shr b</span></p>
<p>  简写 |    含义<br>——-+————-<br>a += b |  a = a + b<br>a -= b |  a = a – b<br>a *= b |  a = a * b<br>a /= b |  a = a / b<br>a %= b |  a = a % b<br>a &amp;= b |  a = a &amp; b<br>a |= b |  a = a | b<br>a ^= b |  a = a ^ b<br>a &lt;&lt;= b|  a = a &lt;&lt; b<br>a &gt;&gt;= b|  a = a &gt;&gt; b</p>
<p><strong>各种标准输入输出函数</strong><br>    下列函数都是stdio.h提供的。stdio.h还提供了一个EOF常量（其实就是-1），用来标识输入数据结束。<br><span style="font-family:宋体">         函数                |                    用途<br>—————————–+———————————————————-<br>int scanf(str,arg1,…,argn) | 按指定格式读入数据，返回成功被赋值的变量个数。如果已无输入或出错则返回EOF<br>int printf(str,arg1,…,argn)| 按指定格式输出数据，返回成功输出的字符个数。<br>int getchar()                | 返回标准输入的下一个字符，如果已无输入或出错则返回EOF。<br>int putchar(c)               | 向屏幕输出一个字符c，同时返回这个字符，如果出错则返回EOF。<br>char *gets(str)              | 把这一行输入数据存入字符串str并返回该字符串，如果已无输入或出错则返回NULL<br>int puts(str)                | 输出字符串并自动输出一个换行符，如果出错则返回EOF。</span></p>
<p><strong>内存输入输出操作</strong><br>    stdio.h中提供的sscanf和sprintf两个函数可以把一个字符串当作输入输出对象，其用法与scanf和printf差不多，只不过要多一个参数。你需要把目标字符数组作为函数的第一个参数。<br>    使用sscanf和sprintf可以方便地进行数字和字符串互转，并实现各种字符串操作。看下面的程序代码：<br><code>#include &lt;stdio.h&gt;<br>int main()<br>{<br>    char st[80]="5:43:04";<br>    int h,m,s;<br>    <br>    sscanf(st, "%d:%d:%d", &amp;h, &amp;m, &amp;s);<br>    printf("Hour:%d Minute:%d Second:%dn", h, m, s);<br>    <br>    sprintf(st, "My birthday is %d-%d-%d", 1988, 5, 16);<br>    printf("%s",st);<br>    <br>    return 0;<br>}</code><br>    输出为：<br><code>Hour:5 Minute:43 Second:4<br>My birthday is 1988-5-16</code></p>
<p><strong>文件输入输出操作</strong><br>    stdio.h还提供了FILE类型，用于定义文件指针。例如，下面的语句定义了两个待操作的文件：<br><code>FILE *in, *out;</code><br>    打开一个文件使用fopen函数，该函数的参数为两个字符串。前一个参数指定文件名，后一个参数指定打开模式("r"=读, "w"=写, "a"=在已有文件后继续写 )。函数返回一个文件指针作为此文件的标识供以后使用。</p>
<p>    和文件操作相关的函数有：<br><span style="font-family:宋体">         函数                      |                    用途<br>———————————–+———————————————————-<br>int fscanf(file,str,arg1,…,argn) | 从file指针对应的文件中读入数据，具体行为同scanf<br>int fprintf(file,str,arg1,…,argn)| 向file指针对应的文件中输出数据，具体行为同printf<br>int fgetc(file)                    | 从file指针对应的文件中读入数据，具体行为同getchar<br>int fputc(c,file)                  | 向file指针对应的文件中输出数据，具体行为同putchar<br>char *fgets(str,n,file)            | 从file指针对应的文件中读入数据到str字符串，读到第n个字符为止<br>int fputs(str,file)                | 向file指针对应的文件中输出数据，具体行为同puts<br>int fflush(file)                   | 立即写入文件，同Pascal中的flush<br>int feof(file)                     | 文件是否结束，同Pascal中的eof<br>int fclose(file)                   | 关闭文件，同Pascal中的close</span></p>
<p>    下面的程序是文件操作版A+B问题，你可以看到文件操作具体的实现方法。<br><code>#include &lt;stdio.h&gt;<br>int main()<br>{<br>    FILE *in, *out;<br>    long a, b;<br>    <br>    in = fopen("test.in","r");<br>    fscanf(in, "%d%d", &amp;a, &amp;b);<br>    fclose(in);<br>    <br>    out = fopen("test.out","w");<br>    fprintf(out, "%d", a+b);<br>    fclose(out);<br>    <br>    return 0;<br>}</code></p>
<p><strong>整型上下限</strong><br>    Pascal可以用maxlongint来表示longint类型的最大值。C语言中也有类似的定义可以直接使用。使用C语言中的相关定义需要在程序代码前加上#include &lt;limits.h&gt;。</p>
<p><span style="font-family:宋体">   定义    |    表示<br>———–+—————————–<br>CHAR_MAX   | char类型大小上限<br>CHAR_MIN   | char类型大小下限<br>SHRT_MAX   | short类型的大小上限<br>SHRT_MIN   | short类型的大小下限<br>USHRT_MAX  | unsigned short类型的大小上限<br>INT_MAX    | int类型的大小上限<br>INT_MIN    | int类型的大小下限<br>UINT_MAX   | unsigned int类型的大小上限<br>LONG_MAX   | long类型的大小上限<br>LONG_MIN   | long类型的大小下限<br>ULONG_MAX  | unsigned long类型的大小上限<br>LLONG_MAX  | long long类型的大小上限<br>LLONG_MIN  | long long类型的大小下限<br>ULLONG_MAX | unsigned long long类型的大小上限</span></p>
<p><strong>常用数学函数</strong><br>    使用下面的函数需要在程序代码前加上#include &lt;math.h&gt;。</p>
<p><span style="font-family:宋体">   函数             |     用途<br>——————–+—————–<br>double sin(x)       |  正弦<br>double cos(x)       |  余弦<br>double tan(x)       |  正切<br>double asin(x)      |  反正弦<br>double acos(x)      |  反余弦<br>double atan(x)      |  反正切<br>double sqrt(x)      |  开平方<br>double pow(x,y)     |  x的y次方<br>double exp(x)       |  e的x次方<br>double exp2(x)      |  2的x次方<br>double log(x)       |  以e为底的对数<br>double log2(x)      |  以2为底的对数<br>double log10(x)     |  以10为底的对数<br>double fabs(x)      |  x的绝对值<br>double fmod(x,y)    |  小数版的mod<br>double floor(x)     |  小于等于x的最大整数<br>double ceil(x)      |  大于等于x的最小整数<br>double trunc(x)     |  舍弃小数部分<br>double round(x)     |  小数部分四舍五入<br>long lround(x)      |  小数部分四舍五入，返回long<br>long long llround(x)|  小数部分四舍五入，返回long long</span></p>
<p><strong>常用字符串函数</strong><br>    使用以下函数需要在程序代码前加上#include &lt;string.h&gt;。<br>    参数s1和s2总是两个字符串，参数c总是一个字符。</p>
<p><span style="font-family:宋体">    函数               |        用途<br>———————–+—————————–<br>int strlen(s1)         | 返回s1的长度<br>char *strcpy(s1,s2)    | 把s2赋值给s1，返回s1<br>char *strcat(s1,s2)    | 将s2连接到s1后面，返回s1<br>int strcmp(s1,s2)      | 比较两字符串，s1小则返回负数，相等返回0，s1大返回正数<br>char *strchr(s1,c)     | 寻找s1第一次出现c的位置，找到则返回指向该位置的指针，没找到则返回NULL<br>char *strstr(s1,s2)    | 寻找s2第一次出现在s1的位置，找到则返回指向该位置的指针，没找到则返回NULL<br>char *strpbrk(s1,s2)   | 寻找s2中的任意字符第一次出现在s1的位置，找到则返回指向该位置的指针，没找到则返回NULL</span></p>
<p>观察下面的程序：<br><code>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>int main()<br>{<br>    char st[80]="matrix67";<br>    strcat(st,".com");<br>    printf( "%sn", st );<br>    printf( "%dn", strlen(st) );<br>    printf( "%dn", strcmp(st,"my blog") );<br>    printf( "%cn", *strchr(st,'i') );<br>    printf( "%sn", strpbrk(st,"3.1415927") );<br>    printf( "%dn", strstr(st,"x6")-st );</code></p>
<p>    return 0;<br>}<br>输出为：<br><code>matrix67.com<br>12<br>-1<br>i<br>7.com<br>5</code></p>
<p><strong>内存操作函数</strong><br>    下面的一些函数主要用于字符串操作，因此属于string.h 。假设m1和m2都是void *类型。</p>
<p><span style="font-family:宋体">         函数                |            用途<br>—————————–+———————————–<br>int memcmp (m1, m2, n)     |  比较m1和m2的头n个字节，相同返回0，m1小返回负数，m2小返回正数<br>void *memmove (m1, m2, n)    |  把m2的前n个字节复制到m1的位置，相当于Pascal中的move<br>void *memset (m1, c, n)      |  把m1的前n个字节全部设为c，相当于Pascal中的fillchar</span></p>
<p>    下面这段代码的结果是把st字符串变成了"Matrix67, I love UUUUUUUUUUUU…"。<br><code>char st[80]="Matrix67, I love someone else...";<br>memset(st+17,'U',12);</code><br>    当然memset更常用的是初始化数组。例如动态规划前初始化f数组：<br><code>long f[1000][1000];<br>memset( f, 0, sizeof(f) );</code></p>
<p><strong>stdlib.h提供的其它函数</strong><br><span style="font-family:宋体">    函数                 |                        用途<br>————————-+————————————————-<br>int abs(n)               |  取绝对值，适用于int<br>long labs(n)             |  取绝对值，适用于long<br>long long llabs(n)       |  取绝对值，适用于long long<br>double atof(str)         |  把字符串str转化为数字，返回double类型<br>int atoi(str)       &amp;n<br>
bsp;    |  把字符串str转化为数字，返回int类型<br>long atol(str)           |  把字符串str转化为数字，返回long类型<br>long long atoll(str)     |  把字符串str转化为数字，返回long long类型<br>void exit(n)             |  退出程序，返回的错误代码为n（0=正常），相当于Pascal的halt<br>int rand()               |  产生一个随机数，范围在stdlib.h中指定（通常最小为0，最大为int的上限）<br>void srand(n)            |  设置随机数发生器的种子为n<br>void qsort(arr,n,size,fn)|  快排，四个参数分别为数组，长度，类型大小，比较函数。</span></p>
<p>    比较函数的格式应该为<br><code>int 函数名(const void *参数1, const void *参数2)</code><br>    如果参数1小于参数2，则该函数返回负数，等于则返回0，大于则正数。因此，你可以自己给“大小”下定义。<br>    下面的程序合法地调用了qsort函数。注意随机函数后的取余运算，这是生成某个范围内的随机数的常用手段。<br><code>#include &lt;stdlib.h&gt;<br>int comp(const void *i, const void *j)<br>{<br>    return *(long *)i - *(long *)j;<br>}</code></p>
<p>int main()<br>{<br>    long n=1000, i, a[n];<br>    for (i=0; i&lt;n; i++) a[i]=rand()%10000;<br>    qsort(a, n, sizeof(long), comp);<br>    return 0;<br>}</p>
<p><strong>利用assert帮助调试</strong><br>    assert可以在程序不满足某个条件时输出错误信息并立即终止运行，这对调试很有帮助。使用assert语句需要包含头文件assert.h。观察下面的程序代码：<br><code>#include &lt;stdio.h&gt;<br>#include &lt;assert.h&gt;</code></p>
<p>int main()<br>{<br>    int n;<br>    scanf("%d",&amp;n);<br>    assert(n!=0);<br>    printf("%f",1.0/n);<br>    return 0;<br>}<br>    当读入的数是0时，程序执行printf前就会提前终止，并且输出错误信息。这可以保证后面的语句正常执行，避免异常错误。这显然比用if语句排除异常错误更好一些。在每一个潜在的异常错误前加上assert，当程序出错时你可以很快确定是哪里的问题。</p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-06-17T07:05:08+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/230</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 借用点其它的东西，你或许可以三等分角 ]]></title>
<link>http://www.matrix67.com/blog/archives/231</link>
<content><![CDATA[ 
		<p>    大家都知道，我们永远不可能尺规三等分任意角。借助一些其它的工具是可以办到的，即使所借助的东西“微不足道”，“几乎可以不算”。下面提供四种比较简单的方法。</p>
<p><strong>ONE~~~~~~~~~</strong><br>    至今仍有不少人认为这种方法可以推翻“三等分角不可能”的结论。而事实上，这种方法仍然算借用了外物。<br>    尺规不能三等分角，但可以三等分圆（自己试）。也就是说，只用直尺和圆规可以画出120度的角来。现在给你一个任意角，那么你可以把它对应的扇形卷成一个圆锥，三等分这个圆锥底面的圆。还原成扇形后，你会看到这个角所对应的圆弧已经被平分为三份了。</p>
<p><strong>TWO~~~~~~~~~</strong><br>       <img alt="image placeholder" >
<p><strong>THREE~~~~~~~</strong><br>       <img alt="image placeholder" >
<p><strong>FOUR~~~~~~~~</strong><br>       <img alt="image placeholder" >
<p>做人要厚道<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-06-19T01:44:47+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/231</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 几个有趣的免费小游戏 ]]></title>
<link>http://www.matrix67.com/blog/archives/232</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
<p>    在<a target="_blank" href="http://digg.com/pc_games/100_of_the_Best_Legal_Full_Version_Games_You_Can_Download_Online">digg</a>上看到了一份列表介绍<a target="_blank" href="http://downloadfullversionpcgames.com/blog/2007/06/17/100-of-the-best-legal-full-version-games-you-can-download-online">100个免费游戏</a>，其中有很多都是开源的。不管你信不信，我访问了列表里所有的网站，看遍所有游戏的介绍和截屏。其中有大量的第一人称射击、即时战略等大型3D游戏，也有不少的网游(MMO)。除去那些一群人砍过来砍过去的游戏，下面的几个显然更有意思一些。</p>
<p>http://phackett.com/rumblebox/<br>    有意思的空间格斗。所有的人物都是由几何体拼接而成的，打倒一个人后那个人就像散了架的积木一样摊在地上。你需要和N多个电脑格斗。除拳打脚踢外你还可以把别人抓起来再扔出去砸人。游戏目标也很有创意：打足够多的敌人使得地上堆积的废立方体足够高，然后踩着这些废立方体逃出围墙。</p>
<p>http://www.golfquestionmark.com/<br>    3D高尔夫球游戏，画面有点科幻的味道，高尔夫球的轨迹描绘很漂亮。我的机器上运行这个太慢了。</p>
<p>http://www.puzzlepirates.com/puzzles.xhtml<br>    一系列Puzzle类游戏。</p>
<p>http://www.asahi-net.or.jp/~cs8k-cyu/index_e.html<br>    小日本的一系列小游戏，大多是用简单的几何图形描绘的飞行或射击游戏，画面类似于<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=199">GridWars</a>。</p>
<p>http://icculus.org/neverball/<br>    在规定时间内控制小球收集金币，然后达到目的地。Ballance的成功让这类游戏犹如雨后春笋般冒出；不过这个有点不同，你需要通过倾斜地面来控制小球的移动。一开始可能很不习惯。</p>
<div align="center"><img alt="image placeholder" >
<p>http://www.plasmapong.com/<br>    强烈推荐的一个PONG类游戏，加入了对流因素使得游戏更有趣，更刺激，画面也更加华丽，保证你从来没见过。那个背景音乐笑死我了。<br>    鼠标左键发射气流，右键蓄力收回小球并发出冲击波。<br>    Sandbox模式是游戏引擎的一个有趣的副产品，可以拿给MM去玩。</p>
<p>http://www.ominousdev.com/games.htm<br>    有意思的单键游戏(One-Switch Game)，整个游戏过程只需要用到一个键。屏幕上有一个飞船，在各个物体间来回碰撞。按空格键开启重力模式后周围的物体立即对飞船产生引力。你需要控制飞船穿过屏幕上方的出口。这个游戏玩久了就觉得没意思了。<br>    最经典的单键游戏要数Cave类游戏了（就是那种按键上升，不按键则下落的横版飞行游戏）。</p>
<p>http://skinflake.com/games<br>    这里有四个游戏，其中两个是国内曾风靡一时的撞人游戏，想必大家都玩过。另外两个游戏分别是Pogo Sticker和Racing Pitch。<br>    Pogo Sticker是一个考验操作技巧的小游戏，你需要控制小人到达目的地。和其它游戏不同的是，你的小人必须保持跳跃状态。一旦小人停止跳跃或头部受撞击则任务失败。操作方式非常诡异，很不好控制。<br>    Racing Pitch是一个很有创意的赛车游戏，看看官方网站上对它的介绍你就彻底服了：<br>
</p>
<blockquote>You must use a microphone to mimic the engine sound, which the game will listen and set you blazing forward accordingly.</blockquote>
<p>http://toblo.csnation.net/<br>    <s>看起来很有意思，不知道是个啥游戏，本来想装来试试的，看到这句话就放弃了：</s><br><s>System Requirements</s><br>  <s>* 2.0 GHz Processor</s><br>  <s>* DirectX 9.0c-compatible graphics card w/ 128MB RAM, Shader 2.0 support</s><br>    <s>谁玩了在下面评论一下</s><br>    要求的配置其实不高，我的破本本上运行流畅。<br>    非常好玩，是一个团队合作对战的3D游戏。游戏设定在一个积木搭建的世界里，你可以拾起地上的积木，或者拆掉积木搭建的建筑，然后把手中的积木扔出去砸死对手。被砸到的人要过几秒种后才再次出现继续游戏。游戏目标是悄悄地把对方基地里所有标有旗子的积木搬回自己基地。支持联网对战，机房里几个人玩这个游戏肯定比CS有趣，到时候一定会听见不断有人跳起来大叫“有人在偷我们旗子”、“我看到他在哪里了”、“小心他手中有个炸弹”。音效非常可爱。</p>
<p>http://satansam.co.uk/blog/?page_id=11<br>    看样子是一个2D的Jump 'n' Run游戏。</p>
<p>http://home.comcast.net/~shadowman131/ShadowArmada.htm<br>    回合制空战游戏，看起来很复杂的样子。可以联网对战。</p>
<p>    另外推荐一个不在此列表中的开源游戏：<a target="_blank" href="http://smw.72dpiarmy.com">Super Mario War</a>。超级玛丽PK赛，支持最多四个人挤在同一台电脑前对打。我还没有和人对打过，一直和白痴AI玩。估计多人对打会很有意思。</p>
<p>做人要厚道<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-06-19T08:24:15+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/232</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 数论部分第一节：素数与素性测试 ]]></title>
<link>http://www.matrix67.com/blog/archives/234</link>
<content><![CDATA[ 
		<p>    一个数是素数（也叫质数），当且仅当它的约数只有两个——1和它本身。规定这两个约数不能相同，因此1不是素数。对素数的研究属于数论范畴，你可以看到许多数学家没事就想出一些符合某种性质的素数并称它为某某某素数。整个数论几乎就围绕着整除和素数之类的词转过去转过来。对于写代码的人来说，素数比想像中的更重要，Google一下BigPrime或者big_prime你总会发现大堆大堆用到了素数常量的程序代码。平时没事时可以记一些素数下来以备急用。我会选一些好记的素数，比如4567, 124567, 3214567, 23456789, 55566677, 1234567894987654321, 11111111111111111111111 (23个1)。我的手机号前10位是个素数。我的网站域名的ASCII码连起来(77 97 116 114 105 120 54 55 46 99 111 109)也是个素数。还有，我的某个MM的八位生日也是一个素数。每次写Hash函数之类的东西需要一个BigPrime常量时我就取她的生日，希望她能给我带来好运。偶尔我叫她素MM，没人知道是啥意思，她自己也不知道。<br>    素数有很多神奇的性质。我写5个在下面供大家欣赏。</p>
<p><strong>1. 素数的个数无限多（不存在最大的素数）</strong><br>  证明：反证法，假设存在最大的素数P，那么我们可以构造一个新的数2 * 3 * 5 * 7 * … * P + 1（所有的素数乘起来加1）。显然这个数不能被任一素数整除（所有素数除它都余1），这说明我们找到了一个更大的素数。</p>
<p><strong>2. 存在任意长的一段连续数，其中的所有数都是合数（相邻素数之间的间隔任意大）</strong><br>  证明：当0&lt;a&lt;=n时，n!+a能被a整除。长度为n-1的数列n!+2, n!+3, n!+4, …, n!+n中，所有的数都是合数。这个结论对所有大于1的整数n都成立，而n可以取到任意大。</p>
<p><strong>3. 所有大于2的素数都可以唯一地表示成两个平方数之差。</strong><br>  证明：大于2的素数都是奇数。假设这个数是2n+1。由于(n+1)^2=n^2+2n+1，(n+1)^2和n^2就是我们要找的两个平方数。下面证明这个方案是唯一的。如果素数p能表示成a^2-b^2，则p=a^2-b^2=(a+b)(a-b)。由于p是素数，那么只可能a+b=p且a-b=1，这给出了a和b的唯一解。</p>
<p><strong>4. 当n为大于2的整数时，2^n+1和2^n-1两个数中，如果其中一个数是素数，那么另一个数一定是合数。</strong><br>  证明：2^n不能被3整除。如果它被3除余1，那么2^n-1就能被3整除；如果被3除余2，那么2^n+1就能被3整除。总之，2^n+1和2^n-1中至少有一个是合数。</p>
<p><strong>5. 如果p是素数，a是小于p的正整数，那么a^(p-1) mod p = 1。</strong><br>  这个证明就有点麻烦了。<br>    首先我们证明这样一个结论：如果p是一个素数的话，那么对任意一个小于p的正整数a，a, 2a, 3a, …, (p-1)a除以p的余数正好是一个1到p-1的排列。例如，5是素数，3, 6, 9, 12除以5的余数分别为3, 1, 4, 2，正好就是1到4这四个数。<br>    反证法，假如结论不成立的话，那么就是说有两个小于p的正整数m和n使得na和ma除以p的余数相同。不妨假设n&gt;m，则p可以整除a(n-m)。但p是素数，那么a和n-m中至少有一个含有因子p。这显然是不可能的，因为a和n-m都比p小。<br>    用<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=282">同余式</a>表述，我们证明了：<br>(p-1)! ≡ a * 2a * 3a * … * (p-1)a (mod p)<br>    也即：<br>(p-1)! ≡ (p-1)! * a^(p-1) (mod p)<br>    两边同时除以(p-1)!，就得到了我们的最终结论：<br>1 ≡ a^(p-1) (mod p)</p>
<p>    可惜最后这个定理最初不是我证明的。这是大数学家Fermat证明的，叫做Fermat小定理(Fermat's Little Theorem)。Euler对这个定理进行了推广，叫做Euler定理。Euler一生的定理太多了，为了和其它的“Euler定理”区别开来，有些地方叫做Fermat小定理的Euler推广。Euler定理中需要用一个函数f(m)，它表示小于m的正整数中有多少个数和m互素（两个数只有公约数1称为互素）。为了方便，我们通常用记号φ(m)来表示这个函数（称作Euler函数）。Euler指出，如果a和m互素，那么a^φ(m) ≡ 1 (mod m)。可以看到，当m为素数时，φ(m)就等于m-1（所有小于m的正整数都与m互素），因此它是Fermat小定理的推广。定理的证明和Fermat小定理几乎相同，只是要考虑的式子变成了所有与m互素的数的乘积：m_1 * m_2 … m_φ(m) ≡ (a * m_1)(a * m_2) … (a * m_φ(m)) (mod m)。我为什么要顺便说一下Euler定理呢？因为下面一句话可以增加我网站的PV：这个定理出现在了<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=274">The Hundred Greatest Theorems</a>里。</p>
<p>    谈到Fermat小定理，数学历史上有很多误解。很长一段时间里，人们都认为Fermat小定理的逆命题是正确的，并且有人亲自验证了a=2, p&lt;300的所有情况。国外甚至流传着一种说法，认为中国在孔子时代就证明了这样的定理：如果n整除2^(n-1)-1，则n就是素数。后来某个英国学者进行考证后才发现那是因为他们翻译中国古文时出了错。1819年有人发现了Fermat小定理逆命题的第一个反例：虽然2的340次方除以341余1，但341=11*31。后来，人们又发现了561, 645, 1105等数都表明a=2时Fermat小定理的逆命题不成立。虽然这样的数不多，但不能忽视它们的存在。于是，人们把所有能整除2^(n-1)-1的合数n叫做伪素数(pseudoprime)，意思就是告诉人们这个素数是假的。<br>    不满足2^(n-1) mod n = 1的n一定不是素数；如果满足的话则多半是素数。这样，一个比试除法效率更高的素性判断方法出现了：制作一张伪素数表，记录某个范围内的所有伪素数，那么所有满足2^(n-1) mod n = 1且不在伪素数表中的n就是素数。之所以这种方法更快，是因为我们可以使用二分法快速计算2^(n-1) mod n 的值，这在计算机的帮助下变得非常容易；在计算机中也可以用二分查找有序数列、Hash表开散列、构建Trie树等方法使得查找伪素数表效率更高。<br>    有人自然会关心这样一个问题：伪素数的个数到底有多少？换句话说，如果我只计算2^(n-1) mod n的值，事先不准备伪素数表，那么素性判断出错的概率有多少？研究这个问题是很有价值的，毕竟我们是OIer，不可能背一个长度上千的常量数组带上考场。统计表明，在前10亿个自然数中共有50847534个素数，而满足2^(n-1) mod n = 1的合数n有5597个。这样算下来，算法出错的可能性约为0.00011。这个概率太高了，如果想免去建立伪素数表的工作，我们需要改进素性判断的算法。</p>
<p>    最简单的想法就是，我们刚才只考虑了a=2的情况。对于式子a^(n-1) mod n，取不同的a可能导致不同的结果。一个合数可能在a=2时通过了测试，但a=3时的计算结果却排除了素数的可能。于是，人们扩展了伪素数的定义，称满足a^(n-1) mod n = 1的合数n叫做以a为底的伪素数(pseudoprime to base a)。前10亿个自然数中同时以2和3为底的伪素数只有1272个，这个数目不到刚才的1/4。这告诉我们如果同时验证a=2和a=3两种情况，算法出错的概率降到了0.000025。容易想到，选择用来测试的a越多，算法越准确。通常我们的做法是，随机选择若干个小于待测数的正整数作为底数a进行若干次测试，只要有一次没有通过测试就立即把<br>
这个数扔回合数的世界。这就是Fermat素性测试。<br>    人们自然会想，如果考虑了所有小于n的底数a，出错的概率是否就可以降到0呢？没想到的是，居然就有这样的合数，它可以通过所有a的测试（这个说法不准确，详见我在地核楼层的回复）。Carmichael第一个发现这样极端的伪素数，他把它们称作Carmichael数。你一定会以为这样的数一定很大。错。第一个Carmichael数小得惊人，仅仅是一个三位数，561。前10亿个自然数中Carmichael数也有600个之多。Carmichael数的存在说明，我们还需要继续加强素性判断的算法。</p>
<p>    Miller和Rabin两个人的工作让Fermat素性测试迈出了革命性的一步，建立了传说中的Miller-Rabin素性测试算法。新的测试基于下面的定理：如果p是素数，x是小于p的正整数，且x^2 mod p = 1，那么要么x=1，要么x=p-1。这是显然的，因为x^2 mod p = 1相当于p能整除x^2-1，也即p能整除(x+1)(x-1)。由于p是素数，那么只可能是x-1能被p整除(此时x=1)或x+1能被p整除(此时x=p-1)。<br>    我们下面来演示一下上面的定理如何应用在Fermat素性测试上。前面说过341可以通过以2为底的Fermat测试，因为2^340 mod 341=1。如果341真是素数的话，那么2^170 mod 341只可能是1或340；当算得2^170 mod 341确实等于1时，我们可以继续查看2^85除以341的结果。我们发现，2^85 mod 341=32，这一结果摘掉了341头上的素数皇冠，面具后面真实的嘴脸显现了出来，想假扮素数和我的素MM交往的企图暴露了出来。<br>    这就是Miller-Rabin素性测试的方法。不断地提取指数n-1中的因子2，把n-1表示成d*2^r（其中d是一个奇数）。那么我们需要计算的东西就变成了a的d*2^r次方除以n的余数。于是，a^(d * 2^(r-1))要么等于1，要么等于n-1。如果a^(d * 2^(r-1))等于1，定理继续适用于a^(d * 2^(r-2))，这样不断开方开下去，直到对于某个i满足a^(d * 2^i) mod n = n-1或者最后指数中的2用完了得到的a^d mod n=1或n-1。这样，Fermat小定理加强为如下形式：<br>    尽可能提取因子2，把n-1表示成d*2^r，如果n是一个素数，那么或者a^d mod n=1，或者存在某个i使得a^(d*2^i) mod n=n-1 ( 0&lt;=i&lt;r ) （注意i可以等于0，这就把a^d mod n=n-1的情况统一到后面去了）<br>    Miller-Rabin素性测试同样是不确定算法，我们把可以通过以a为底的Miller-Rabin测试的合数称作以a为底的强伪素数(strong pseudoprime)。第一个以2为底的强伪素数为2047。第一个以2和3为底的强伪素数则大到1 373 653。<br>    Miller-Rabin算法的代码也非常简单：计算d和r的值（可以用位运算加速），然后二分计算a^d mod n的值，最后把它平方r次。程序的代码比想像中的更简单，我写一份放在下边。虽然我已经转C了，但我相信还有很多人看不懂C语言。我再写一次Pascal吧。函数IsPrime返回对于特定的底数a，n是否是能通过测试。如果函数返回False，那说明n不是素数；如果函数返回True，那么n极有可能是素数。<strong>注意这个代码的数据范围限制在longint，你很可能需要把它们改成int64或高精度计算。</strong><br><code>function pow( a, d, n:longint ):longint;<br>begin<br>   if d=0 then exit(1)<br>   else if d=1 then exit(a)<br>   else if d and 1=0 then exit( pow( a*a mod n, d div 2, n) mod n)<br>   else exit( (pow( a*a mod n, d div 2, n) * a) mod n);<br>end;</code></p>
<p>function IsPrime( a,n:longint ):boolean;<br>var<br>   d,t:longint;<br>begin<br>   if n=2 then exit(true);<br>   if (n=1) or (n and 1=0) then exit(false);<br>   d:=n-1;<br>   while d and 1=0 do d:=d shr 1;<br>   t:=pow( a, d, n );<br>   while ( d&lt;&gt;n-1 ) and ( t&lt;&gt;1 ) and ( t&lt;&gt;n-1 ) do<br>   begin<br>      t:=(t * t)mod n;<br>      d:=d shl 1;<br>   end;<br>   exit( (t=n-1) or (d and 1=1) );<br>end;<br>    对于大数的素性判断，目前Miller-Rabin算法应用最广泛。一般底数仍然是随机选取，但当待测数不太大时，选择测试底数就有一些技巧了。比如，如果被测数小于4 759 123 141，那么只需要测试三个底数2, 7和61就足够了。当然，你测试的越多，正确的范围肯定也越大。如果你每次都用前7个素数(2, 3, 5, 7, 11, 13和17)进行测试，所有不超过341 550 071 728 320的数都是正确的。如果选用2, 3, 7, 61和24251作为底数，那么10^16内唯一的强伪素数为46 856 248 255 981。这样的一些结论使得Miller-Rabin算法在OI中非常实用。通常认为，Miller-Rabin素性测试的正确率可以令人接受，随机选取k个底数进行测试算法的失误率大概为4^(-k)。</p>
<p>    Miller-Rabin算法是一个RP算法。RP是时间复杂度的一种，主要针对判定性问题。一个算法是RP算法表明它可以在多项式的时间里完成，对于答案为否定的情形能够准确做出判断，但同时它也有可能把对的判成错的（错误概率不能超过1/2）。RP算法是基于随机化的，因此多次运行该算法可以降低错误率。还有其它的素性测试算法也是概率型的，比如Solovay-Strassen算法。另外一些素性测试算法则需要预先知道一些辅助信息（比如n-1的质因子），或者需要待测数满足一些条件（比如待测数必须是2^n-1的形式）。前几年AKS算法轰动世界，它是第一个多项式的、确定的、无需其它条件的素性判断算法。当时一篇论文发表出来，题目就叫PRIMES is in P，然后整个世界都疯了，我们班有几个MM那天还来了初潮。算法主要基于下面的事实：n是一个素数当且仅当(x-a)^n≡(x^n-a) (mod n)。注意这个x是多项式中的未知数，等式两边各是一个多项式。举个例子来说，当a=1时命题等价于如下结论：当n是素数时，杨辉三角的第n+1行除两头的1以外其它的数都能被n整除。</p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-06-22T10:36:00+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/234</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 同余运算及其基本性质 ]]></title>
<link>http://www.matrix67.com/blog/archives/236</link>
<content><![CDATA[ 
		<p>    100除以7的余数是2，意思就是说把100个东西七个七个分成一组的话最后还剩2个。余数有一个严格的定义：假如被除数是a，除数是b（假设它们均为正整数），那么我们总能够找到一个小于b的自然数r和一个整数m，使得a=bm+r。这个r就是a除以b的余数，m被称作商。我们经常用mod来表示取余，a除以b余r就写成a mod b = r。<br>    如果两个数a和b之差能被m整除，那么我们就说a和b对模数m同余（关于m同余）。比如，100-60除以8正好除尽，我们就说100和60对于模数8同余。它的另一层含义就是说，100和60除以8的余数相同。a和b对m同余，我们记作a≡b(mod m)。比如，刚才的例子可以写成100≡60(mod 8)。你会发现这种记号到处都在用，比如和数论相关的书中就经常把a mod 3 = 1写作a≡1(mod 3)。<br>    之所以把同余当作一种运算，是因为同余满足运算的诸多性质。比如，同余满足等价关系。具体地说，它满足自反性（一个数永远和自己同余）、对称性（a和b同余，b和a也就同余）和传递性（a和b同余，b和c同余可以推出a和c同余）。这三个性质都是显然的。<br>    同余运算里还有稍微复杂一些的性质。比如，同余运算和整数加减法一样满足“等量加等量，其和不变”。小学我们就知道，等式两边可以同时加上一个相等的数。例如，a=b可以推出a+100=b+100。这样的性质在同余运算中也有：对于同一个模数m，如果a和b同余，x和y同余，那么a+x和b+y也同余。在我看来，这个结论几乎是显然的。当然，我们也可以严格证明这个定理。这个定理对减法同样有效。</p>
<p>    <strong>性质：如果a≡b(mod m)，x≡y(mod m)，则a+x≡b+y(mod m)。</strong><br>    证明：条件告诉我们，可以找到p和q使得a-mp = b-mq，也存在r和s使得x-mr = y-ms。于是a-mp + x-mr = b-mq + y-ms，即a+x-m(p+r) = b+y-m(q+s)，这就告诉我们a+x和b+y除以m的余数相同。</p>
<p>    容易想到，两个同余式对应相乘，同余式两边仍然相等：<br>    <strong>如果a≡b(mod m)，x≡y(mod m)，则ax≡by(mod m)。</strong><br>    证明：条件告诉我们，a-mp = b-mq，x-mr = y-ms。于是(a-mp)(x-mr) = (b-mq)(y-ms)，等式两边分别展开后必然是ax-m(…) = by-m(…)的形式，这就说明ax≡by(mod m)。</p>
<p>    现在你知道为什么<a target="_blank" href="http://www.vijos.cn/Problem_Show.asp?id=1093">有的题</a>要叫你“输出答案mod xxxxx的结果”了吧，那是为了避免高精度运算，因为这里的结论告诉我们在运算过程中边算边mod和算完后再mod的结果一样。假如a是一个很大的数，令b=a mod m，那么(a * 100) mod m和(b * 100) mod m的结果是完全一样的，这相当于是在a≡b (mod m)的两边同时乘以100。这些结论其实都很显然，因为同余运算只关心余数（不关心“整的部分”），完全可以每一次运算后都只保留余数。因此，整个运算过程中参与运算的数都不超过m，避免了高精度的出现。</p>
<p>    在证明<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=280">Fermat小定理</a>时，我们用到了这样一个定理：<br>    <strong>如果ac≡bc(mod m)，且c和m互质，则a≡b(mod m)</strong> （就是说同余式两边可以同时除以一个和模数互质的数）。<br>    证明：条件告诉我们，ac-mp = bc-mq，移项可得ac-bc = mp-mq，也就是说(a-b)c = m(p-q)。这表明，(a-b)c里需要含有因子m，但c和m互质，因此只有可能是a-b被m整除，也即a≡b(mod m)。</p>
<p>    可能以后还要用到更多的定理，到时候在这里更新。</p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-06-25T02:23:58+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/236</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 超真实声音及声音错觉 ]]></title>
<link>http://www.matrix67.com/blog/archives/238</link>
<content><![CDATA[ 
		<p>火星文一则，若看过莫见怪，今天偶然看到后感觉真的很神奇。<br>播放时请务必戴上耳机，耳机音质越高越好。</p>
<p><a target="_blank" href="http://gs.matrix67.googlepages.com/virtualhaircut.mp3">虚拟理发店</a>：超级真实的听觉体验。理发师会告诉你这背后的科学知识。<br><a target="_blank" href="http://gs.matrix67.googlepages.com/matchbox.mp3">火柴盒</a>：你会听到一个人在你周围各个地方摇动火柴盒，让你感到浑身不自在</p>
<p><a target="_blank" href="http://gs.matrix67.googlepages.com/endless.mp3">Shepard悖论</a>：你会感觉音调不断在上升，但事实上这段声音的开头和结尾音调是一样的。如果不断重复播放这段声音，音调似乎在永无止境地上升。非常神奇。<br><a target="_blank" href="http://gs.matrix67.googlepages.com/falling.mp3">坠落的铃铛</a>：你会感觉音调在不断下降，但事实上音调在不断上升（从开头重新播放来证实这一点）<br><a target="_blank" href="http://gs.matrix67.googlepages.com/beat.mp3">加速击打</a>：你会觉得打击声速度在加快，但事实上开头和结尾的速度是一样的（我咋没啥感觉呢）</p>
<p>后面三个声音错觉来自http://www.noah.org/science/audio_paradox，你也可以在那里找到下载的地方</p>
			 ]]></content>
<pubDate>2007-06-27T21:45:37+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/238</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ C语言速成手册（六）：其它问题、后记 ]]></title>
<link>http://www.matrix67.com/blog/archives/240</link>
<content><![CDATA[ 
		<p><strong>预处理指令</strong><br>    以一个井号开头的行都叫做预处理指令。除了#include指令外，我们还经常用到#define指令。#define指令可以告诉编译器，编译时把代码中出现的特定标识当作什么来处理。例如，我们可以这样写：<br><code>#define NAME_OF_MY_POTENTIAL_GF "ZPR"</code><br>    这样，编译器会在编译前把代码中出现NAME_OF_MY_POTENTIAL_GF的地方全部替换成"ZPR"。这种替换是无条件的，但是有一个例外：当指定的标识属于某个字符串（被引号引起来）时替换不会发生。例如，下面两行代码会输出NAME_OF_MY_POTENTIAL_GF defined as: ZPR<br><code>printf("NAME_OF_MY_POTENTIAL_GF defined as: ");<br>printf(NAME_OF_MY_POTENTIAL_GF);</code><br>    其中，后面那个NAME_OF_MY_POTENTIAL_GF被自动替换为"ZPR"。如果哪一天ZPR不要我了，我就可以非常方便地让整个程序适用于另一个MM。</p>
<p>    C语言中通常会用#define代替const。例如，下面的代码假设了输入数据n&lt;=2000。<br><code>#include &lt;stdio.h&gt;<br>#define MAX 2000</code></p>
<p>int main()<br>{<br>   int f[MAX][MAX];<br>   int i,j,n;<br>   scanf("%d",&amp;n);<br>   for ( i=0; i&lt;n; i++ )<br>   {<br>      for ( j=0; j&lt;=i; j++ )<br>      {<br>          f[i][j] = j ? (f[i-1][j] + f[i-1][j-1]) % 10000 : 1;<br>          printf( "%5d" , f[i][j] );<br>      }<br>      printf("n");<br>   }</p>
<p>   return 0;<br>}</p>
<p>    下面的这些指令也是合法的：<br><code>#define begin {<br>#define end }<br>#define and &amp;&amp;<br>#define or ||</code><br>    #define定义的指令允许带参数。例如，下面的定义也是合法的：<br><code>#define sqr(x) x*x</code><br>    观察下面的这个程序：<br><code>#include &lt;stdio.h&gt;<br>#define begin {<br>#define end }<br>#define writeln(num) printf("%dn",num)<br>#define sqr(x) x*x</code></p>
<p>int main()<br>begin<br>   writeln(sqr(100));<br>   writeln(sqr(10+2));<br>end<br>    程序输出：<br><code>10000<br>32</code><br>    为什么第二个输出的数是32不是144？不要忘了sqr中的x不是一个变量，编译器仅仅是把x替换为10+2，因此sqr(10+2)的结果是10+2*10+2，当然是32咯。为了避免这种情况，这样写就没问题了：<br><code>#define sqr(x) ( (x) * (x) )</code><br>    下面这个定义很常用：<br><code>#define MAX(a,b) ( ((a) &gt; (b)) ? (a) : (b) )</code></p>
<p>    如果你想写出一个<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=139">很有个性的C代码</a>，反复使用#define是一个不错的选择。例如，<a target="_blank" href="http://www.ioccc.org/1995/savastio.c">这段代码</a>就极具个性，一个光棍的形象跃然于屏幕上。然而，真正把#define发挥得淋漓尽致的，还是要数<a target="_blank" href="http://www.ioccc.org/1990/dg.c">这段代码</a>。</p>
<p><strong>static声明</strong><br>    在函数中的变量声明前加一个static可以使这个变量具有“记忆性”。观察下面的程序：<br><code>#include &lt;stdio.h&gt;<br>void printNum()<br>{<br>   int a=1;<br>   static int b=1;<br>   printf("%d %dn", a++, b++);<br>}<br>int main()<br>{<br>   int i;<br>   for ( i=1; i&lt;=5; i++ )<br>       printNum();<br>   return 0;<br>}</code><br>    程序输出：<br><code>1 1<br>1 2<br>1 3<br>1 4<br>1 5</code></p>
<p><strong>short类型和int类型的范围</strong><br>    最初我们列出的C语言类型和Pascal类型的对比只能提供一个参考。事实上不同的编译器中short和int的范围可能不同。你可以查一下前面说过的limits.h来确定这些类型的实际范围。通常short是16位整数，long是32位整数。在Windows下Dev-C++中int类型是32位。</p>
<p><strong>对64位整型的处理</strong><br>    和Free Pascal一样，对64位整数类型的处理总是比较麻烦。<br>    首先，对long long赋值很可能会发生错误，你可以在常数后添加一个LL表明这是long long类型。其次，C语言中有些函数是要区分数据类型的，你需要根据数据类型选用恰当的函数。最后，long long类型的输出很可能也有问题，此时你可以用"%lld"来替换"%d"，表明输出的是一个long long类型。在Windows下总要装点怪，我在Windows编译时非要用"%I64d"才行。<br>    下面的程序代码在Windows下Dev-C++中一切正常。<br><code>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;</code></p>
<p>int main()<br>{<br>    long long a;<br>    a = -5841314520LL;<br>    a = llabs(a);<br>    a = a + 1;<br>    printf("%I64d",a);<br>    return 0;<br>}</p>
<p><strong>查漏补缺</strong><br>    这个系列到这里就结束了。还有我没有说到的语法点吗？欢迎大家补充。</p>
<p><strong>后记</strong><br>    C语言速成手册到这里就结束了。这很可能是网上现有的原创C语言教材中讲解最快，篇幅最短的，因为它只适合已经学过其它语言，了解程序设计基础知识的人。这一系列的文章略过了大量的概念讲解、示例代码和习题，你可以自己在网上阅读一些C语言程序作为补充。以后我可能还会写一些类似的文章介绍其它语言。下一步我计划写C与C++的区别，对象和类的介绍以及C++的新特性。再以后我可能会向Java或者Ruby的方向发展。<br>    祝各位努力转C的OIer暑假愉快。</p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-06-29T04:41:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/240</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 神奇的分形艺术（一）：无限长的曲线可能围住一块有限的面积 ]]></title>
<link>http://www.matrix67.com/blog/archives/243</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
<p>    很多东西都是吹神了的，其中麦田圈之谜相当引人注目。上个世纪里人们时不时能听见某个农民早晨醒了到麦田地一看立马吓得屁滚尿流的故事。上面这幅图就是97年在英国Silbury山上发现的麦田圈，看上去大致上是一个雪花形状。你或许会觉得这个图形很好看。看了下面的文字后，你会发现这个图形远远不是“好看”可以概括的，它的背后还有很多东西。</p>
<p>    在说明什么是分形艺术前，我们先按照下面的方法构造一个图形。看下图，首先画一个线段，然后把它平分成三段，去掉中间那一段并用两条等长的线段代替。这样，原来的一条线段就变成了四条小的线段。用相同的方法把每一条小的线段的中间三分之一替换为等边三角形的两边，得到了16条更小的线段。然后继续对16条线段进行相同的操作，并无限地迭代下去。下图是这个图形前五次迭代的过程，可以看到这样的分辨率下已经不能显示出第五次迭代后图形的所有细节了。这样的图形可以用Logo语言很轻松地画出来。
</p>
<div align="center"><img alt="image placeholder" >
<p>    你可能注意到一个有趣的事实：整个线条的长度每一次都变成了原来的4/3。如果最初的线段长为一个单位，那么第一次操作后总长度变成了4/3，第二次操作后总长增加到16/9，第n次操作后长度为(4/3)^n。毫无疑问，操作无限进行下去，这条曲线将达到无限长。难以置信的是这条无限长的曲线却“始终只有那么大”。</p>
<p>        <img alt="image placeholder" >
<p>    分形这一课题提出的时间比较晚。Koch曲线于1904年提出，是最早提出的分形图形之一。我们仔细观察一下这条特别的曲线。它有一个很强的特点：你可以把它分成若干部分，每一个部分都和原来一样（只是大小不同）。这样的图形叫做“自相似”图形(self-similar)，它是分形图形(fractal)最主要的特征。自相似往往都和递归、无穷之类的东西联系在一起。比如，自相似图形往往是用递归法构造出来的，可以无限地分解下去。一条Koch曲线中包含有无数大小不同的Koch曲线。你可以对这条曲线的尖端部分不断放大，但你所看到的始终和最开始一样。它的复杂性不随尺度减小而消失。另外值得一提的是，这条曲线是一条连续的，但处处不光滑（不可微）的曲线。曲线上的任何一个点都是尖点。</p>
<p>    分形图形有一种特殊的计算维度的方法。我们可以看到，在有限空间内就可以达到无限长的分形曲线似乎已经超越了一维的境界，但说它是二维图形又还不够。Hausdorff维度就是专门用来对付这种分形图形的。简单地说，Hausdorff维度描述分形图形中整个图形的大小与一维大小的关系。比如，正方形是一个分形图形，因为它可以分成四个一模一样的小正方形，每一个小正方形的边长都是原来的1/2。当然，你也可以把正方形分成9个边长为1/3的小正方形。事实上，一个正方形可以分割为a^2个边长为1/a的小正方形。那个指数2就是正方形的维度。矩形、三角形都是一样，给你a^2个同样的形状才能拼成一个边长为a倍的相似形，因此它们都是二维的。我们把这里的“边长”理解为一维上的长度，那个1/a则是两个相似形的相似比。如果一个自相似形包含自身N份，每一份的一维大小都是原来的1/s，则这个相似形的Hausdorff维度为log(N)/log(s)。一个立方体可以分成8份，每一份的一维长度都是原来的一半，因此立方体的维度为log(8)/log(2)=3。同样地，一个Koch曲线包含四个小Koch曲线，大小两个Koch曲线的相似比为1/3，因此Koch曲线的Hausdorff维度为log(4)/log(3)。它约等于1.26，是一个介于1和2之间的实数。</p>
<p>    我们常说分形图形是一门艺术。把不同大小的Koch雪花拼接起来可以得到很多美丽的图形。如果有MM看了前面的文字一句也不懂，下面这些图片或许会让你眼前一亮。</p>
<p>放图前留下一句话：<br>Matrix67原创<br>转贴请注明出处</p>
<div align="center"><img alt="image placeholder" >
<div align="center"><img alt="image placeholder" >
			 ]]></content>
<pubDate>2007-07-05T09:45:35+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/243</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 经典谬论：用复数来证明1=2 ]]></title>
<link>http://www.matrix67.com/blog/archives/247</link>
<content><![CDATA[ 
		<p>    从来没有见到过一个纯数学的东西在<a target="_blank" href="http://digg.com/general_sciences/1_2_A_Proof_using_Complex_Numbers">digg</a>上这么受欢迎，我也转上来。</p>
<p>    大家肯定都见过用除以零、平方根、无穷级数等“技巧”去“证明”类似的结论，但我第一次看到这个用虚数来玩的戏法。大家看看哪里错了：</p>
<p>Step 1: -1/1 = 1/-1<br>Step 2: 两边同时开方：sqrt( -1/1 ) = sqrt( 1/-1 )<br>Step 3: 化简得：sqrt(-1)/sqrt(1) = sqrt(1)/sqrt(-1)<br>Step 4: 也就是说，i/1 = 1/i<br>Step 5: 那么，i / 2 = 1 / (2i)<br>Step 6: 两边同时加一个数：i/2 + 3/(2i) = 1/(2i) + 3/(2i)<br>Step 7: 同时乘以一个数：i (i/2 + 3/(2i) ) = i ( 1/(2i) + 3/(2i) )<br>Step 8: 展开：(i^2)/2 + (3i)/(2i) = i/(2i) + (3i)/(2i)<br>Step 9: 于是有：(-1)/2 + 3/2 = 1/2 + 3/2<br>Step 10: 这说明1=2</p>
<p>    如果你也被搞晕了，去<a target="_blank" href="http://www.math.toronto.edu/mathnet/falseProofs/second1eq2.html">这里</a>看看吧。这对于我这种<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=99">课本上根本没有讲虚数</a>，只是道听途说知道一些东西的文科生来说尤其具有迷惑性。</p>
			 ]]></content>
<pubDate>2007-07-10T12:04:52+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/247</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 免费3D小游戏推荐：Counterclockwise ]]></title>
<link>http://www.matrix67.com/blog/archives/248</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
<p>    给自己的Blog内容添加了一个类别，专门发布程序开发、网页设计等相关内容。然后我需要找一个该类别的图标，一阵狂搜后偶然闯入<a target="_blank" href="http://www.16x16.org">16×16.org</a>这个网站。16×16.org是一个游戏开发小组，和图标没有任何关系。网站上的唯一一个游戏名字叫“逆时针”，是一个很抽象的3D空间飞行游戏，看上去很吸引人。玩了一下觉得非常有意思，在这里推荐一下。<br>    游戏中你需要控制一个飞行器，飞行器总是沿三维坐标飞行，转弯时只能转90度直角。飞行中你需要尽量避免撞上障碍物，否则你的护盾值将减低。游戏目标是攻击一个像核弹头一样的东西，你可以点击鼠标发射子弹来射击目标，也可以按回车键释放EMP。子弹数、EMP个数和护盾都是有限的，你需要不断做一些高难度动作来增加它们的值。当护盾降为0时游戏结束。<br>    和之前推荐的<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=278">免费小游戏</a>不同，这个游戏只有Windows版的。<a target="_blank" href="http://www.16x16.org/games/ccw/download.php">这里</a>是游戏的下载页面。</p>
<p>    P.S. 玩了一个多小时后，退出来继续干正事，终于找到了一套完美的<a target="_blank" href="http://www.famfamfam.com/lab/icons/">16×16小图标</a>，可以满足各种需求。Blog侧边栏的类别图标全部换了一套，自己觉得还不错。</p>
			 ]]></content>
<pubDate>2007-07-11T16:31:00+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/248</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 神奇的分形艺术（二）：一条连续的曲线可以填满整个平面 ]]></title>
<link>http://www.matrix67.com/blog/archives/249</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
<p>    虽然有些东西似乎是显然的，但一个完整的定义仍然很有必要。比如，大多数人并不知道函数的连续性是怎么定义的，虽然大家一直在用。有人可能会说，函数是不是连续的一看就知道了嘛，需要定义么。事实上，如果没有严格的定义，你很难把下面两个问题说清楚。<br>    你知道吗，除了常函数之外还存在其它没有最小正周期的周期函数。考虑一个这样的函数：它的定义域为全体实数，当x为有理数时f(x)=1，当x为无理数时f(x)=0。显然，任何有理数都是这个函数的一个<del datetime="2008-09-03T13:34:33+00:00">最小正</del>周期，因为一个有理数加有理数还是有理数，而一个无理数加有理数仍然是无理数。因此，该函数的最小正周期可以任意小。如果非要画出它的图象，大致看上去就是两根直线。请问这个函数是连续函数吗？如果把这个函数改一下，当x为无理数时f(x)=0，当x为有理数时f(x)=x，那新的函数是连续函数吗？<br>    Cauchy定义专门用来解决这一类问题，它严格地定义了函数的连续性。Cauchy定义是说，函数f在x=c处连续当且仅当对于一个任意小的正数ε，你总能找到一个正数δ使得对于定义域上的所有满足c-δ&lt; x &lt;c+δ的x都有f(c)-ε&lt;f(x)&lt;f(c)+ε。直观地说，如果函数上有一点P，对于任意小的ε，P点左右一定范围内的点与P的纵坐标之差均小于ε，那么函数在P点处连续。这样就保证了P点两旁的点与P无限接近，也就是我们常说的“连续”。这又被称作为Epsilon-Delta定义，可以写成“ε-δ定义”。<br>    有了Cauchy定义，回过头来看前面的问题，我们可以推出：第一个函数在任何一点都不连续，因为当ε&lt; 1时，δ范围内总存在至少一个点跳出了ε的范围；第二个函数只在x=0处是连续的，因为此时不管ε是多少，只需要δ比ε小一点就可以满足ε-δ定义了。<br>    在拓扑学中，也有类似于ε-δ的连续性定义。假如一个函数f(t)对应空间中的点，对于任意小的正数ε，总能找到一个δ使得定义域(t-δ,t+δ)对应的所有点与f(t)的距离都不超过ε，那么我们就说f(t)所对应的曲线在点f(t)处连续。</p>
<div align="center"><img alt="image placeholder" >
<p>    回到我们的话题，如何构造一条曲线使得它可以填满整个平面。在这里我们仅仅说明存在一条填满单位正方形的曲线就够了，因为将此单位正方形平铺在平面上就可以得到填满整个平面的曲线。大多数人可能会想到下面这种构造方法：先画一条单位长的曲线，然后把它变成一个几字形，接着把每一条水平的小横线段变成一个几字形，然后不断迭代下去，最后得到的图形一定可以填满整个单位正方形。我们甚至可以递归地定义出一个描述此图形的函数：将定义域平均分成五份，第二和第四份对应两条竖直线段上的点，并继续对剩下的三个区间重复进行这种操作。这个函数虽然分布得有些“不均匀”，但它确实是一个合法的函数。最后的图形显然可以填充一个正方形，但它是不是一条曲线我们还不知道呢。稍作分析你会发现这条“曲线”根本不符合前面所说的ε-δ定义，考虑任何一个可以无限细分的地方（比如x=1/2处），只要ε&lt;1/2，δ再小其范围内也有一条竖线捅破ε的界线。这就好像当n趋于无穷时sin(nx)根本不是一条确定的曲线一样，因为某个特定的函数值根本不能汇聚到一点。考虑到这一点，我们能想到的很多可以填满平面的“曲线”都不是真正意义上的连续曲线。为了避免这样的情况出现，这条曲线必须“先把自己周围填满再延伸出去”，而填满自己周围前又必须先填满“更小规模的周围”。这让我们联想到分形图形。</p>
<div align="center"><img alt="image placeholder" >
<p>    德国数学家David Hilbert发现了这样一种可以填满整个单位正方形的分形曲线，他称它为Hilbert曲线。我们来看一看这条曲线是怎么构造出来的。首先，我们把一个正方形分割为4个小正方形，然后从左下角的那个小正方形开始，画一条线经过所有小正方形，最后到达右下角。现在，我们把这个正方形分成16个小正方形，目标同样是从左下角出发遍历所有的格子最后到达右下角。而在这之前我们已经得到了一个2×2方格的遍历方法，我们正好可以用它。把两个2×2的格子原封不动地放在上面两排，右旋90度放在左下，左旋90度放在右下，然后再补三条线段把它们连起来。现在我们得到了一种从左下到右下遍历4×4方格的方法，而这又可以用于更大规模的图形中。用刚才的方法把四个4×4的方格放到8×8的方格中，我们就得到了一条经过所有64个小方格的曲线。不断地这样做下去，无限多次地迭代后，每个方格都变得无穷小，最后的图形显然经过了方格上所有的点，它就是我们所说的Hilbert曲线。下图是一个迭代了n多次后的图形，大致上反映出Hilbert曲线的样子。<br>         <img alt="image placeholder" >
<p>    根据上面这种方法，我们可以构造出函数f(t)使它能映射到单位正方形中的所有点。Hilbert曲线首先经过单位正方形左下1/4的所有点，然后顺势北上，东征到右上角，最后到达东南方的1/4正方形，其中的每一个阶段都是一个边长缩小了一半的“小Hilbert曲线”。函数f(t)也如此定义：[0,1/4]对应左下角的小正方形中所有的点，[1/4,1/2]就对应左上角，依此类推。每个区间继续划分为四份，依次对应面积为1/16的正方形，并无限制地这么细分下去。注意这里的定义域划分都是闭区间的形式，这并不会发生冲突，因为所有m/4^n处的点都是两个小Hilbert曲线的“交接处”。比如那个f(1/4)点就是左上左下两块1/4正方形共有的，即单位正方形正左边的那一点。这个函数是一条根正苗红的连续曲线，完全符合ε-δ定义，因为f(t-δ)和f(t+δ)显然都在f(t)的周围。<br>    Hilbert曲线是一条经典的分形曲线。它违背了很多常理。比如，把Hilbert曲线平铺在整个平面上，它就成了一条填满整个平面的曲线。两条Hilbert曲线对接可以形成一个封闭曲线，而这个封闭曲线竟然没有内部空间。回想我们上次介绍的Hausdorff维度，你会发现这条曲线是二维的，因为它包含自身4份，每一份的一维大小都是原来的一半，因此维度等于log(4)/log(2)。这再一次说明了它可以填满整个平面。</p>
<p>    Hilbert曲线的价值在于建立一维空间与二维空间一一对应的关系。Hilbert曲线可以看作是一个一维空间到二维空间的映射，也就是说我们证明了直线上的点和平面上的点一样多（集合的势相同）。Hilbert曲线也是一种遍历二维格点的方法，它同样可以用来证明自然数和有理数一样多。如果你已经知道此结论的Cantor证明，你会立刻明白Hilbert遍历法的证明，这里就不再多说了。当然，Hilbert曲线也可以扩展到三维空间，甚至更高维的空间，从而建立一维到任意多维的映射关系。下图就是一个三维Hilbert曲线（在迭代</p>
			 ]]></content>
<pubDate>2007-07-11T23:21:22+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/249</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 又是黑色星期五！为什么总是黑色星期五呢？ ]]></title>
<link>http://www.matrix67.com/blog/archives/251</link>
<content><![CDATA[ 
		<p>    你是否还记得，<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=220">今年的4月13日</a>是黑色星期五。短短三个月后，黑色星期五再次现身！为什么这一天老是出现呢？<br>    恐怕心理原因是最好的解释。人们对黑色星期五的出现记忆更深刻，给人一种黑色星期五常常出现的错觉。有趣的是，仔细算一算，你会发现13日是星期五的次数真的要多一些。<br>    很多人以为现在实行的历法是4年一循环，这是不对的。现在实行的历法以400年为一个循环。大家很容易忽略整百年的问题。一个很有意思的智力题就是问一个人是否可能连续5年不过生日。有个笑话说文科MM感叹她等了她男友4年，整整1460天，学理科的好友脱口而出“难道你男友是1900年的”。我们可以算一下在这400年中共有多少天：365*303+366*97=146097。这个数正好能被7整除。换句话说，现在与400年后的星期数不变，日历完全相同。在这400年里一共有4800个月，利用Zeller公式（见<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=266">这里</a>的最后一小节）可以编程统计出13日是星期几的次数最多，这对于OIer们再熟悉不过了，因为USACO有一道题就是干这种无聊的事情。下面就是程序运行后的结果：<br><span style="font-family:宋体">
<ul>
<li>Sunday     687</li>
<li>Monday     685</li>
<li>Tuesday    685</li>
<li>Wednesday  687</li>
<li>Thursday   684</li>
<li>Friday     688</li>
<li>Saturday   684</li>
</ul>
<p></p></span><br>    可以看到，事实上13日是星期五的概率确实是最高的。<br>    另外，注意到了么，利用“400年一周期”这个结论我们可以对USACO的那个题进行扩展，出一个Friday the Thirteenth数据加强版。<br>    做人要厚道，转贴不注明出处者将受到黑色星期五的诅咒。</p>
			 ]]></content>
<pubDate>2007-07-13T00:25:20+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/251</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 十大另类程序语言（上） ]]></title>
<link>http://www.matrix67.com/blog/archives/253</link>
<content><![CDATA[ 
		<div align="center"><img alt="image placeholder" >
<p><strong>10. LOLCODE语言</strong> http://lolcode.com/<br>    国外流行一种lolcat图片，经常出现在论坛的头像和签名图里。lolcat图片里有一只很乖的小动物（通常是小猫），旁边写几句很可爱的话（比如故意的语法错误、拼写错误、近似发音或者网络缩略语）。很多web 2.0的宕机页面就是一张lolcat图片。LOLCODE就是用这种可爱的猫猫语言来写程序。LOLCODE的代码通俗易懂，写起来非常可爱，小MM一定会喜欢。比如看看下面这段代码：<br><code>HAI<br>CAN HAS STDIO?<br>I HAS A VAR<br>GIMMEH VAR<br>IZ VAR BIGGER THAN 10?<br>    YARLY<br>        BTW this is true<br>        VISIBLE "BIG NUMBER!"<br>    NOWAI<br>        BTW this is false<br>        VISIBLE "LITTLE NUMBER!"<br>    KTHX<br>KTHXBYE</code></p>
<p><strong>9. BrainFuck语言</strong> http://www.muppetlabs.com/~breadbox/bf<br>    BrainFuck语言是最简单的程序语言之一，只有8个有效字符，每个字符都有一个特定的含义。这8个字符控制一个指针在线性表里进行移动、读写、循环等操作。所有其它的字符都当作注释处理。我的Blog里曾对BrainFuck有过专门的<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=209">介绍</a>。<br>    我很喜欢这个语言，甚至下载了它的编译器，写出不少BrainFuck程序。例如，下面这段代码可以输出我的网站域名“matrix67.com”：<br><code>++++++++++[&gt;+++++++++++&lt;-]&gt;-.<br>&lt;+++[&gt;----&lt;-]&gt;.&lt;+++++[&gt;++++&lt;-]&gt;-.--.<br>&lt;+++[&gt;---&lt;-]&gt;.&lt;+++++[&gt;+++&lt;-]&gt;.<br>&gt;+++++[&gt;+++++++++++&lt;-]&gt;-.+.&lt;+++[&gt;---&lt;-]&gt;.&lt;&lt;<br>&lt;+++++[&gt;----&lt;-]&gt;-.&lt;+++[&gt;++++&lt;-]&gt;.--.</code><br>    BrainFuck语言有很多扩展。用不同的单词来代替这8个符号可以得到更多好玩的程序语言，有一些语言竟是把BrainFuck程序编码成图片或音乐作为程序代码。</p>
<p><strong>8. Malbolge语言</strong> http://www.lscheffer.com/malbolge.shtml<br>    Malbolge是最早的一个以代码丑陋为目标而设计出的程序语言，你几乎不可能读懂Malbolge的代码。它共有8条指令，所有运算都基于3进制，控制程序流的唯一指令是无条件跳转。它的Hello World程序如下：<br><code> (=&lt;`:9876Z4321UT.-Q+*)M'&amp;%$H"!~}|Bzy?=|{z]KwZY44Eq0/{mlk**<br> hKs_dG5[m_BA{?-Y;;Vb'rR5431M}/.zHGwEDCBA@986543W10/.R,+O&lt;</code></p>
<p><strong>7. Whitespace语言</strong> http://compsoc.dur.ac.uk/whitespace/<br>    很多语言在编译时都会自动忽略空格、换行和Tab，而Whitespace语言正好相反，这个语言的有效字符只有三个（就是前面提到的三个空白符号），其它字符一律当作注释处理。这个语言对于机密工作者尤其有用，你可以把一个完整的Whitespace程序插入到一篇普通的文章中，谁也不会知道这里面竟然隐藏了一个机密代码。Whitespace也可以防止别人打印出源代码盗走。Whitespace源码的扩展名为.ws，<a target="_blank" href="http://compsoc.dur.ac.uk/whitespace/hworld.ws">这里</a>是一个Whitespace的Hello World程序。我的Blog里也曾经<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=210">介绍过Whitespace</a>。</p>
<p><strong>6. Befunge语言</strong> http://quadium.net/funge/spec98.html<br>    Befunge的代码是二维的。它用 &lt; &gt; v ^ 这四个符号来控制一个指针在代码中移动，指针经过一个字符或数字则把它压入一个栈，四则运算符号的功能就是弹出栈顶两个元素进行计算后把结果压回去。用 _ 和 | 来表示有条件的方向选择：当栈顶元素为0时向右（上）走，否则向左（下）走。&amp; 和 ~ 分别用于读入数字或字符并压入栈，句号和逗号分别表示将栈顶元素作为整数或字符输出。最后以一个@符号表示程序结束。Befunge代码的注释不需要任何符号标明，你可以把注释写在程序的任何地方，只要运行时指针不会经过它就行了。你甚至可以把注释写在程序正中间，然后写代码时绕开注释写成一圈。Befunge的Hello World程序如下：<br><code>                 v<br>&gt;v"Hello world!"0&lt;<br>,:<br>^_25*,@</code></p>
<p>    看一个复杂的例子。我找了一个算圆周率的Befunge程序，看起来非常壮观。<br><code>aa*          v                  +------------------------+<br>vp*9920p*9930&lt;                  | Pi generator in Bef-97 |<br>&gt;:09a*pa*3/1+19a*p09a*g:09b*v   |                        |<br>v_@# g*b90 p*b910        &lt; p&lt;   | 7/2/1997, Kevin Vigor  |<br>&gt;19a*g:+1-29b*p19a*g::09v       +------------------------+<br>v*a90g*b90*g*b91: _v#p*9&lt;<br>&gt;g-#v_ 2a*+$  v  :$<br>    &gt;1-aa*ga*+v  p<br>v1:/g*b92p*991:&lt;  *<br>&gt;9b*p29b*g*199*gv9<br>v*b92p*aa-1g*990-&lt;9<br>&gt;g2-29b*p099*g1-:0^<br>v -9p*b92:%ag*991  &lt;<br>&gt;#v_ 299*g1+299*p&gt;       ^<br>  &gt;09b*g:#v_$v<br>v93p*b90-1&lt;<br>&gt;9*g199*ga/+.v<br>     v:g*992 &lt;p*9 92-&lt;<br>    v_29b*g399*p ^<br>    &gt;09b*g:#v_v      1<br>vp*b90-1    &lt; $      g<br>&gt;199*g9`#v_'9,v      *<br>         &gt;'0, &gt;' ,299^</code><br>    通常认为Befunge是第一个基于“二维控制流”的语言，后来衍生出的一大批类似的语言都是受的Befunge影响。例如PingPong语言就是把Befunge的四种箭头符号换成正反斜杠，控制指针移动方向90度旋转，起一个反弹的作用。</p>
<p>Matrix67收集整理<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-07-15T16:43:54+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/253</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 十大另类程序语言（下） ]]></title>
<link>http://www.matrix67.com/blog/archives/255</link>
<content><![CDATA[ 
		<p><strong>5. TMMLPTEALPAITAFNFAL语言</strong> http://p-nand-q.com/humor/programming_languages/tmmlpteal.html<br>    你没看错，上面这一排毫无意义的字母是一个语言的名称。它是The Multi-Million Language Project To End All Language Projects And Isn't That A Fine Name For A Language的缩写。TMMLPTEALPAITAFNFAL语言没有固定的语法规则，每一天都是不同的语法。例如，2000年10月13日你可以使用DIV但不能使用MOD；到了10月14日时你可以使用MOD了但DIV又不能用了。因此，你今天写的程序运行起来完全正常，但是到了明天就无法编译了。下面是一个TMMLPTEALPAITAFNFAL的Hello World程序，当然现在已经无法编译了。<br><code>    DECLARE CELL 100 AS READPOS<br>    DECLARE 10 AS NEWLINE<br>    WRITE CHAR NEWLINE<br>    COPY "Hello, World" TO CELL 0<br>    COPY 0 TO READPOS<br>    WHILE READPOS INDIRECT DO GOSUB 300<br>    WRITE CHAR NEWLINE<br>    RETURN<br>LINE 300: WRITE CHAR READPOS INDIRECT<br>    ADD 1 TO READPOS<br>    RETURN</code></p>
<p><strong>4. l33t语言</strong> http://web.archive.org/web/20050329085620/http://electrod.ifreepages.com/l33t.htm<br>    Leetspeak是国外网络上曾经流行的一种字母书写方式，就像<a target="_blank" href="http://www.google.com/intl/xx-hacker/">这个样子</a>。很多电影和美剧的名字也是Leetspeak，比如se7en、numb3rs、s1m0ne等等。l33t程序的代码故意仿照这种风格。它的代码中只有0到9这九个数字是有意义的，其它的字符都没用。因此，你可以先写好一篇文章，然后依次把里面出现的字母替换成你的l33t代码，让一段Leetspeak文字中隐藏一个小程序。下面就是一个Hello World示例程序：<br><code>   // "Hello World" by Stephen McGreal.<br>   // Note that the views expressed in this source code do not necessarily coincide with those of the author :o)<br>   <br>   Gr34t l33tN3$$?<br>   M3h...<br>   iT 41n't s0 7rIckY.<br>   <br>   l33t sP33k is U8er keWl 4nD eA5y wehn u 7hink 1t tHr0uGh.<br>   1f u w4nn4be UB3R-l33t u d3f1n1t3lY w4nt in 0n a b4d4sS h4xX0r1ng s1tE!!!;p<br>   w4r3Z c0ll3cT10n2 r 7eh l3Et3r!<br>   <br>   Qu4k3 cL4nS r 7eh bE5t tH1ng 1n teh 3nTIr3 w0rlD!!!<br>   g4m3s wh3r3 u g3t to 5h00t ppl r 70tAl1_y w1cK1d!!<br>   I'M teh fr4GM4stEr aN I'lL t0t41_1Ly wIpE teh phr34k1ng fL00r ***j3d1 5tYlE*** wItH y0uR h1dE!!!!L0L0L0L!<br>   t3lEphR4gG1nG l4m3rs wit mY m8tes r34lLy k1kK$ A$$<br>   <br>   l33t hAxX0r$ CrE4t3 u8er- k3wL 5tUff lIkE n34t pR0gR4mm1nG lAnguidGe$...<br>   s0m3tIm3$ teh l4nGu4gES l00k jUst l1k3 rE41_ 0neS 7o mAkE ppl Th1nk th3y'r3 ju$t n0rMal lEE7 5pEEk but th3y're 5ecRetLy c0dE!!!!<br>   n080DY unDer5tAnD$ l33t SpEaK 4p4rT fr0m j3d1!!!!!<br>   50mE kId 0n A me$$4gEb04rD m1ghT 8E a r0xX0r1nG hAxX0r wH0 w4nT2 t0 bR34k 5tuFf, 0r mAyb3 ju5t sh0w 7eh wAy5 l33t ppl cAn 8E m0re lIkE y0d4!!! hE i5 teh u8ER!!!!<br>   1t m1ght 8E 5omE v1rus 0r a Pl4ySt4tI0n ch34t c0dE.<br>   1t 3v3n MiTe jUs7 s4y "H3LL0 W0RLD!!!" u ju5t cAn'T gu3s5.<br>   tH3r3's n3v3r anY p0iNt l00KiNg sC3pT1c4l c0s th4t, be1_1Ev3 iT 0r n0t, 1s whAt th1s 1s!!!!!<br>   <br>   5uxX0r5!!!L0L0L0L0L!!!!!!!</code></p>
<p><strong>3. Java2K语言</strong> http://p-nand-q.com/humor/programming_languages/java2k.html<br>    Java2K是一种非确定性的语言，程序正常运行是有一定概率的。很多时候程序并不能按照你的意愿去运行，即使是系统函数也不会总是去做它该做的事。所有的函数都有两种不同的解释，程序运行时会随机选择一个作为实际调用的函数。<br>    几乎所有的系统函数返回正确结果都只有90%的可能性，因此程序运行的最终结果或多或少都和预期结果不同。写出正确率尽量高的Java2K程序是一个非常有趣的挑战。</p>
<p><strong>2. Chef语言</strong> http://www.dangermouse.net/esoteric/chef.html<br>    一个完整的Chef程序代码分为三个部分：程序名、变量声明和一系列栈操作。所有的操作都写成食谱的样子。例如，Put x into the mixing bowl就表示把变量x压入栈中，而Stir for 2 minutes则表示把栈顶元素向下移两格。下面的程序打印出前100个Fibonacci数。<br><code>Fibonacci Numbers with Caramel Sauce.</code></p>
<p>Ingredients.<br>100 g flour<br>250 g butter<br>1 egg</p>
<p>Method.<br>Sift the flour. Put flour into mixing bowl. Serve with caramel sauce. Stir for 2 minutes. Remove egg. Rub the flour until sifted. Stir for 2 minutes. Fold the butter into the mixing bowl. Pour contents of the mixing bowl into the baking dish.</p>
<p>Serves 1.</p>
<p>Caramel Sauce.</p>
<p>Ingredients.<br>1 cup white sugar<br>1 cup brown sugar<br>1 vanilla bean</p>
<p>Method.<br>Fold white sugar into mixing bowl. Put white sugar into mixing bowl. Fold brown sugar into mixing bowl. Clean mixing bowl. Put white sugar into mixing bowl. Remove vanilla bean. Fold white sugar into mixing bowl. Melt white sugar. Put vanilla bean into mixing bowl. Refrigerate. Heat white sugar until melted. Put white sugar into mixing bowl. Remove vanilla bean. Fold white sugar into mixing bowl. Caramelise white sugar. Put vanilla bean into mixing bowl. Refrigerate. Cook white sugar until caramelised. Put white sugar into mixing bowl. Serve with caramel sauce. Fold brown sugar into mixing bowl. Put white sugar into mixing bowl. Add vanilla bean. Serve with caramel sauce. Add brown sugar.</p>
<p><strong>1. Shakespeare语言</strong> http://shakespearelang.sourceforge.net/<br>    在所有的另类语言中，Shakespeare语言可能是最搞笑的了，并且难以置信的是它居然是SourceForge.net的一个项目。Shakespeare的代码完全模仿莎士比亚的戏剧。它也是一个基于栈的程序语言，程序中出场的每一个人物都代表一个栈。Shakespeare的代码自由度很高，因此同一个程序你可以写出完全不同的代码出来。Shakespeare的Hello World代码如下：<br><code>The Infamous Hello World Program.</code></p>
<p>Romeo, a young man with a remarkable patience.<br>Juliet, a likewise young woman of remarkable grace.<br>Ophelia, a remarkable woman much in dispute with Hamlet.<br>Hamlet, the flatterer of Andersen Insulting A/S.</p>
<p>                    Act I: Hamlet's insults and flattery.</p>
<p>                    Scene I: The insulting of Romeo.</p>
<p>[Enter Hamlet and Romeo]</p>
<p>Hamlet:<br> You lying stupid fatherless big smelly half-witted coward!<br> You are as stupid as the difference between a handsome rich brave<br> hero and thyself! Speak your mind!</p>
<p> You are as brave as the sum of your fat little stuffed misused dusty<br> old rotten codpiece and a beautiful fair warm peaceful sunny summer's<br> day. You are as healthy as the difference between the sum of the<br> sweetest reddest rose and my father and yourself! Speak your mind!</p>
<p> You are as cowardly as the sum of yourself and the difference<br> between a big mighty proud kingdom and a horse. Speak your mind.</p>
<p> Speak your mind!</p>
<p>[Exit Romeo]</p>
<p>                    Scene II:<br>
The praising of Juliet.</p>
<p>[Enter Juliet]</p>
<p>Hamlet:<br> Thou art as sweet as the sum of the sum of Romeo and his horse and his<br> black cat! Speak thy mind!</p>
<p>[Exit Juliet]</p>
<p>                    Scene III: The praising of Ophelia.</p>
<p>[Enter Ophelia]</p>
<p>Hamlet:<br> Thou art as lovely as the product of a large rural town and my amazing<br> bottomless embroidered purse. Speak thy mind!</p>
<p> Thou art as loving as the product of the bluest clearest sweetest sky<br> and the sum of a squirrel and a white horse. Thou art as beautiful as<br> the difference between Juliet and thyself. Speak thy mind!</p>
<p>[Exeunt Ophelia and Hamlet]</p>
<p>                    Act II: Behind Hamlet's back.</p>
<p>                    Scene I: Romeo and Juliet's conversation.</p>
<p>[Enter Romeo and Juliet]</p>
<p>Romeo:<br> Speak your mind. You are as worried as the sum of yourself and the<br> difference between my small smooth hamster and my nose. Speak your<br> mind!</p>
<p>Juliet:<br> Speak YOUR mind! You are as bad as Hamlet! You are as small as the<br> difference between the square of the difference between my little pony<br> and your big hairy hound and the cube of your sorry little<br> codpiece. Speak your mind!</p>
<p>[Exit Romeo]</p>
<p>                    Scene II: Juliet and Ophelia's conversation.</p>
<p>[Enter Ophelia]</p>
<p>Juliet:<br> Thou art as good as the quotient between Romeo and the sum of a small<br> furry animal and a leech. Speak your mind!</p>
<p>Ophelia:<br> Thou art as disgusting as the quotient between Romeo and twice the<br> difference between a mistletoe and an oozing infected blister! Speak<br> your mind!</p>
<p>[Exeunt]</p>
<p></p>
<p>Matrix67收集整理<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-07-16T13:15:12+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/255</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ J.J. Abrams的神秘电影 & 一个解谜网站 ]]></title>
<link>http://www.matrix67.com/blog/archives/258</link>
<content><![CDATA[ 
		<p>    Transformers冷下来后，本该Harry Potter大显身手，但一个神秘电影却引起了更多人的关注。<br>    <a target="_blank" href="http://www.apple.com/trailers/paramount/11808/">这个预告片</a>出现在了北美Transformers放映前，是abc的热门美剧Lost制作人J.J. Abrams的一个新电影。从预告片上看，这部电影将从一小群人的角度讲述一个怪物袭击美国城市，应该是一个耗资巨大的科幻片。但神奇的是，规模如此大的电影在预告片放映前竟然没有半点风声！J.J. Abrams几乎是把Lost的神秘色彩带进了真实世界，因为现在人们甚至还不知道这个电影的名字是什么。预告片中没有影片标题，imdb的标题是Untitled J.J. Abrams Project，电影制作时所用的代号叫做Cloverfield，而官方网站则是预告片中提到的首映日期<a target="_blank" href="http://www.1-18-08.com/">1-18-08.com</a>。明年1月就要上映的电影，Paramount却几乎没有发布任何消息，没有新闻发言稿，没有剧照，没有海报，没有Tagline，甚至连电影名称都还不知道，这在电影史上十分罕见。官方网站上只有三张照片，照片一角显示的拍摄时间都是01/18/2008。人们开始猜想，08年1月18日到底要发生什么。<br>    与此相关的一个网站是<a target="_blank" href="http://www.ethanhaaswasright.com/">ethanhaaswasright.com</a>。虽然J.J. Abrams已经亲自确认了这个网站和无名电影没有任何联系，但网友们坚信网站里隐藏有一些关于无名电影的提示信息，因为Paramount曾要求YouTube把来自该网站的一些视频删除。这个网站是一个很华丽的Flash解谜站点，喜欢Puzzle的朋友们这个假期又有事情干了。<br>    P.S. 这个网站我Firefox浏览时始终不能完全载入，不知道是不是什么插件的问题</p>
			 ]]></content>
<pubDate>2007-07-18T15:29:28+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/258</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 重庆晨报新闻一则：你还会做初三数学题吗 ]]></title>
<link>http://www.matrix67.com/blog/archives/259</link>
<content><![CDATA[ 
		<p>    本想找份假期家教工作，没想到却被家长的一道数学题考倒了。昨日下午，重庆邮电大学大二学生小王显得非常郁闷，而出题面试的家长刘先生却称这是选择家教的有效标准。</p>
<p><strong>先解初三数学题</strong><br>    小王说，昨日上午经同学介绍，他到家住南坪的刘先生家，应聘当家教。没想到见面后，刘先生拿出了一张写有试题的白纸，说这是读初三的女儿暑假作业上的一道题，做出来了才能当家教。<br>    题目为：如果a+b+c=0，1/(a+1)+1/(b+2)+1/(c+3)=0，那么(a+1)^2+(b+2)^2+(c+3)^2的值为多少。小王说，当时他做了十多分钟，都没有做出来，感觉有点丢脸，便主动告辞了。<br>    “不过我还是很不服，回来给几个同学做了，也没有做出来。”小王说，这种题以前读书时也做过，解这种题需要特殊的方法，这么多年没做了当然不记得了。不过这并不代表能力不行，家长用这种方法太武断了。</p>
<p><strong>家长称并非刁难</strong><br>    随后，记者通过电话联系上了刘先生，他表示这并不是存心刁难，而是有个判断的标准。<br>    刘先生说，这题目是从女儿假期作业中挑的一道难题，就是想通过试题来测试出应聘大学生的水平。现在假期当家教的大学生很多，但素质却并不一定都好，以前给孩子也请过大学生当家教，效果并不理想，所以现在才想出了这个方法。</p>
<p>不会做的自觉在下面留言<br><span style="color:#E5E5E5">设x=a+1, y=b+2, z=c+3，则x+y+z=6，(x+y+z)^2=36，即x^2 + y^2 + z^2 + 2(xy+yz+xz) =36。<br>又 1/x + 1/y + 1/z = 0，即xy + yz + xz = 0，因此x^2 + y^2 + z^2 = 36</span></p>
			 ]]></content>
<pubDate>2007-07-20T12:58:41+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/259</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Yuor bairn is samtrer tahn you tnhik ]]></title>
<link>http://www.matrix67.com/blog/archives/260</link>
<content><![CDATA[ 
		<blockquote><p>Aoccdrnig to a rscheearch at Cmabrigde Uinervtisy, the oredr of letetrs in a wrod dosen't mttaer, the olny thnig thta's iopmrantt is that the frsit and lsat ltteer of eevry word is in the crcreot ptoision. The rset can be jmbueld and one is stlil able to raed the txet wiohtut dclftfuiiy. Tihs is bcuseae the huamn mnid deos not raed ervey lteter by istlef, but the wrod as a wlohe.</p></blockquote>
<p>Dnot konw if you gyus hvae alerday seen it berfoe</p>
			 ]]></content>
<pubDate>2007-07-20T13:07:41+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/260</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 位运算简介及实用技巧（一）：基础篇 ]]></title>
<link>http://www.matrix67.com/blog/archives/263</link>
<content><![CDATA[ 
		<p>    去年年底写的关于<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=153">位运算</a>的日志是这个Blog里少数大受欢迎的文章之一，很多人都希望我能不断完善那篇文章。后来我看到了不少其它的资料，学习到了更多关于位运算的知识，有了重新整理位运算技巧的想法。从今天起我就开始写这一系列位运算讲解文章，与其说是原来那篇文章的follow-up，不如说是一个remake。当然首先我还是从最基础的东西说起。</p>
<p><strong>什么是位运算？</strong><br>    程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算说穿了，就是直接对整数在内存中的二进制位进行操作。比如，and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）：<br><span style="font-family:宋体">     110<br>AND 1011<br>———-<br>    0010  –&gt;  2</span><br>    由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。当然有人会说，这个快了有什么用，计算6 and 11没有什么实际意义啊。这一系列的文章就将告诉你，位运算到底可以干什么，有些什么经典应用，以及如何用位运算优化你的程序。</p>
<p><strong>Pascal和C中的位运算符号</strong><br>    下面的a和b都是整数类型，则：<br><span style="font-family:宋体">C语言  |  Pascal语言<br>——-+————-<br>a &amp; b  |  a and b<br>a | b  |  a or b<br>a ^ b  |  a xor b<br>  ~a   |   not a<br>a &lt;&lt; b |  a shl b<br>a &gt;&gt; b |  a shr b</span><br>    注意C中的逻辑运算和位运算符号是不同的。520|1314=1834，但520||1314=1，因为逻辑运算时520和1314都相当于True。同样的，!a和~a也是有区别的。</p>
<p><strong>各种位运算的使用</strong><br>    === 1. and运算 ===<br>    and运算通常用于二进制取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数.</p>
<p>    === 2. or运算 ===<br>    or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。</p>
<p>    === 3. xor运算 ===<br>    xor运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：0和1异或0都不变，异或1则取反。<br>    xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。xor运算可以用于简单的加密，比如我想对我MM说1314520，但怕别人知道，于是双方约定拿我的生日19880516作为密钥。1314520 xor 19880516 = 20665500，我就把20665500告诉MM。MM再次计算20665500 xor 19880516的值，得到1314520，于是她就明白了我的企图。<br>    下面我们看另外一个东西。定义两个符号#和@（我怎么找不到那个圈里有个叉的字符），这两个符号互为逆运算，也就是说(x # y) @ y = x。现在依次执行下面三条命令，结果是什么？<br><code>x &lt;- x # y<br>y &lt;- x @ y<br>x &lt;- x @ y</code><br>    执行了第一句后x变成了x # y。那么第二句实质就是y &lt;- x # y @ y，由于#和@互为逆运算，那么此时的y变成了原来的x。第三句中x实际上被赋值为(x # y) @ x，如果#运算具有交换律，那么赋值后x就变成最初的y了。这三句话的结果是，x和y的位置互换了。<br>    加法和减法互为逆运算，并且加法满足交换律。把#换成+，把@换成-，我们可以写出一个不需要临时变量的swap过程(Pascal)。<br><code>procedure swap(var a,b:longint);<br>begin<br>   a:=a + b;<br>   b:=a - b;<br>   a:=a - b;<br>end;</code><br>    好了，刚才不是说xor的逆运算是它本身吗？于是我们就有了一个看起来非常诡异的swap过程：<br><code>procedure swap(var a,b:longint);<br>begin<br>   a:=a xor b;<br>   b:=a xor b;<br>   a:=a xor b;<br>end;</code></p>
<p>    === 4. not运算 ===<br>    not运算的定义是把内存中的0和1全部取反。使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用$0000到$FFFF依次表示的。下面的两个程序（仅语言不同）均返回65435。<br><code>var<br>   a:word;<br>begin<br>   a:=100;<br>   a:=not a;<br>   writeln(a);<br>end.</code><br><code>#include &lt;stdio.h&gt;<br>int main()<br>{<br>    unsigned short a=100;<br>    a = ~a;<br>    printf( "%dn", a );    <br>    return 0;<br>}</code><br>    如果not的对象是有符号的整数，情况就不一样了，稍后我们会在“整数类型的储存”小节中提到。</p>
<p>    === 5. shl运算 ===<br>    a shl b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 shl 2 = 400。可以看出，a shl b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。<br>    通常认为a shl 1比a * 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替。<br>    定义一些常量可能会用到shl运算。你可以方便地用1 shl 16 – 1来表示65535。很多算法和数据结构要求数据规模必须是2的幂，此时可以用shl来定义Max_N等常量。</p>
<p>    === 6. shr运算 ===<br>    和shl相似，a shr b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们也经常用shr 1来代替div 2，比如二分查找、堆的插入操作等等。想办法用shr代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60%。</p>
<p><strong>位运算的简单应用</strong><br>    有时我们的程序需要一个规模不大的Hash表来记录状态。比如，做数独时我们需要27个Hash表来统计每一行、每一列和每一个小九宫格里已经有哪些数了。此时，我们可以用27个小于2^9的整数进行记录。例如，一个只填了2和5的小九宫格就用数字18表示（二进制为000010010），而某一行的状态为511则表示这一行已经填满。需要改变状态时我们不需要把这个数转成二进制修改后再转回去，而是直接进行位操作。在搜索时，把状态表示成整数可以更好地进行判重等操作。<a target="_blank" href="http://www.vijos.cn/Problem_Sho%0Aw.asp?id=1197">这道题</a>是在搜索中使用位运算加速的经典例子。以后我们会看到更多的例子。<br>    下面列举了一些常见的二进制位的变换操作。</p>
<p><span style="font-family:宋体">    功能              |           示例            |    位运算<br>———————-+—————————+——————–<br>去掉最后一位          | (101101-&gt;10110)           | x shr 1<br>在最后加一个0         | (101101-&gt;1011010)         | x shl 1<br>在最后加一个1         | (101101-&gt;1011011)         | x shl 1+1<br>把最后一位变成1       | (101100-&gt;101101)          | x or 1<br>把最后一位变成0       | (101101-&gt;101100)          | x or 1-1<br>最后一位取反          | (101101-&gt;101100)          | x xor 1<br>把右数第k位变成1      | (101001-&gt;101101,k=3)      | x or (1 shl (k-1))<br>把右数第k位变成0      | (101101-&gt;101001,k=3)      | x and not (1 shl (k-1))<br>右数第k位取反         | (101001-&gt;101101,k=3)      | x xor (1 shl (k-1))<br>取末三位              | (1101101-&gt;101)            | x and 7<br>取末k位               | (1101101-&gt;1101,k=5)       | x and (1 shl k-1)<br>取右数第k位           | (1101101-&gt;1,k=4)          | x shr (k-1) and 1<br>把末k位变成1          | (101001-&gt;101111,k=4)      | x or (1 shl k-1)<br>末k位取反             | (101001-&gt;100110,k=4)      | x xor (1 shl k-1)<br>把右边连续的1变成0    | (100101111-&gt;100100000)    | x and (x+1)<br>把右起第一个0变成1    | (100101111-&gt;100111111)    | x or (x+1)<br>把右边连续的0变成1    | (11011000-&gt;11011111)      | x or (x-1)<br>取右边连续的1         | (100101111-&gt;1111)         | (x xor (x+1)) shr 1<br>去掉右起第一个1的左边 | (100101000-&gt;1000)         | x and (x xor (x-1))</span></p>
<p>    最后这一个在树状数组中会用到。</p>
<p><strong>Pascal和C中的16进制表示</strong><br>    Pascal中需要在16进制数前加$符号表示，C中需要在前面加0x来表示。这个以后我们会经常用到。</p>
<p><strong>整数类型的储存</strong><br>    我们前面所说的位运算都没有涉及负数，都假设这些运算是在unsigned/word类型（只能表示正数的整型）上进行操作。但计算机如何处理有正负符号的整数类型呢？下面两个程序都是考察16位整数的储存方式（只是语言不同）。<br><code>var<br>   a,b:integer;<br>begin<br>   a:=$0000;<br>   b:=$0001;<br>   write(a,' ',b,' ');<br>   a:=$FFFE;<br>   b:=$FFFF;<br>   write(a,' ',b,' ');<br>   a:=$7FFF;<br>   b:=$8000;<br>   writeln(a,' ',b);<br>end.</code><br><code>#include &lt;stdio.h&gt;<br>int main()<br>{<br>    short int a, b;<br>    a = 0x0000;<br>    b = 0x0001;<br>    printf( "%d %d ", a, b );<br>    a = 0xFFFE;<br>    b = 0xFFFF;<br>    printf( "%d %d ", a, b );<br>    a = 0x7FFF;<br>    b = 0x8000;<br>    printf( "%d %dn", a, b );<br>    return 0;<br>}</code><br>    两个程序的输出均为0 1 -2 -1 32767 -32768。其中前两个数是内存值最小的时候，中间两个数则是内存值最大的时候，最后输出的两个数是正数与负数的分界处。由此你可以清楚地看到计算机是如何储存一个整数的：计算机用$0000到$7FFF依次表示0到32767的数，剩下的$8000到$FFFF依次表示-32768到-1的数。32位有符号整数的储存方式也是类似的。稍加注意你会发现，二进制的第一位是用来表示正负号的，0表示正，1表示负。这里有一个问题：0本来既不是正数，也不是负数，但它占用了$0000的位置，因此有符号的整数类型范围中正数个数比负数少一个。对一个有符号的数进行not运算后，最高位的变化将导致正负颠倒，并且数的绝对值会差1。也就是说，not a实际上等于-a-1。这种整数储存方式叫做“补码”。</p>
<p><strong>最后还有两句话</strong><br>    Matrix67原创<br>    转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-07-23T04:39:08+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/263</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 位运算简介及实用技巧（二）：进阶篇(1) ]]></title>
<link>http://www.matrix67.com/blog/archives/264</link>
<content><![CDATA[ 
		<p>=====   真正强的东西来了！   =====</p>
<p><strong>二进制中的1有奇数个还是偶数个</strong><br>    我们可以用下面的代码来计算一个32位整数的二进制中1的个数的奇偶性，当输入数据的二进制表示里有偶数个数字1时程序输出0，有奇数个则输出1。例如，1314520的二进制101000000111011011000中有9个1，则x=1314520时程序输出1。<br><code>var<br>   i,x,c:longint;<br>begin<br>   readln(x);<br>   c:=0;<br>   for i:=1 to 32 do<br>   begin<br>      c:=c + x and 1;<br>      x:=x shr 1;<br>   end;<br>   writeln( c and 1 );<br>end.</code><br>    但这样的效率并不高，位运算的神奇之处还没有体现出来。<br>    同样是判断二进制中1的个数的奇偶性，下面这段代码就强了。你能看出这个代码的原理吗？<br><code>var<br>   x:longint;<br>begin<br>   readln(x);<br>   x:=x xor (x shr 1);<br>   x:=x xor (x shr 2);<br>   x:=x xor (x shr 4);<br>   x:=x xor (x shr 8);<br>   x:=x xor (x shr 16);<br>   writeln(x and 1);<br>end.</code><br>    为了说明上面这段代码的原理，我们还是拿1314520出来说事。1314520的二进制为101000000111011011000，第一次异或操作的结果如下：</p>
<p><span style="font-family:宋体">    00000000000101000000111011011000<br>XOR  0000000000010100000011101101100<br>—————————————<br>    00000000000111100000100110110100</span></p>
<p>    得到的结果是一个新的二进制数，其中右起第i位上的数表示原数中第i和i+1位上有奇数个1还是偶数个1。比如，最右边那个0表示原数末两位有偶数个1，右起第3位上的1就表示原数的这个位置和前一个位置中有奇数个1。对这个数进行第二次异或的结果如下：</p>
<p><span style="font-family:宋体">    00000000000111100000100110110100<br>XOR   000000000001111000001001101101<br>—————————————<br>    00000000000110011000101111011001</span></p>
<p>    结果里的每个1表示原数的该位置及其前面三个位置中共有奇数个1，每个0就表示原数对应的四个位置上共偶数个1。一直做到第五次异或结束后，得到的二进制数的最末位就表示整个32位数里有多少个1，这就是我们最终想要的答案。</p>
<p><strong>计算二进制中的1的个数</strong><br>    同样假设x是一个32位整数。经过下面五次赋值后，x的值就是原数的二进制表示中数字1的个数。比如，初始时x为1314520（网友抓狂：能不能换一个数啊），那么最后x就变成了9，它表示1314520的二进制中有9个1。<br><code>x := (x and $55555555) + ((x shr 1) and $55555555); <br>x := (x and $33333333) + ((x shr 2) and $33333333); <br>x := (x and $0F0F0F0F) + ((x shr 4) and $0F0F0F0F); <br>x := (x and $00FF00FF) + ((x shr 8) and $00FF00FF); <br>x := (x and $0000FFFF) + ((x shr 16) and $0000FFFF); </code><br>    为了便于解说，我们下面仅说明这个程序是如何对一个8位整数进行处理的。我们拿数字211（我们班某MM的生日）来开刀。211的二进制为11010011。</p>
<p><span style="font-family:宋体">+—+—+—+—+—+—+—+—+<br>| 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 |   &lt;—原数<br>+—+—+—+—+—+—+—+—+<br>|  1 0  |  0 1  |  0 0  |  1 0  |   &lt;—第一次运算后<br>+——-+——-+——-+——-+<br>|    0 0 1 1    |    0 0 1 0    |   &lt;—第二次运算后<br>+—————+—————+<br>|        0 0 0 0 0 1 0 1        |   &lt;—第三次运算后，得数为5<br>+——————————-+</span></p>
<p>    整个程序是一个分治的思想。第一次我们把每相邻的两位加起来，得到每两位里1的个数，比如前两位10就表示原数的前两位有2个1。第二次我们继续两两相加，10+01=11，00+10=10，得到的结果是00110010，它表示原数前4位有3个1，末4位有2个1。最后一次我们把0011和0010加起来，得到的就是整个二进制中1的个数。程序中巧妙地使用取位和右移，比如第二行中$33333333的二进制为00110011001100….，用它和x做and运算就相当于以2为单位间隔取数。shr的作用就是让加法运算的相同数位对齐。</p>
<p><strong>二分查找32位整数的前导0个数</strong><br>    这里用的C语言，我直接Copy的Hacker's Delight上的代码。这段代码写成C要好看些，写成Pascal的话会出现很多begin和end，搞得代码很难看。程序思想是二分查找，应该很简单，我就不细说了。<br><code>int nlz(unsigned x)<br>{<br>   int n;</code></p>
<p>   if (x == 0) return(32);<br>   n = 1;<br>   if ((x &gt;&gt; 16) == 0) {n = n +16; x = x &lt;&lt;16;}<br>   if ((x &gt;&gt; 24) == 0) {n = n + 8; x = x &lt;&lt; 8;}<br>   if ((x &gt;&gt; 28) == 0) {n = n + 4; x = x &lt;&lt; 4;}<br>   if ((x &gt;&gt; 30) == 0) {n = n + 2; x = x &lt;&lt; 2;}<br>   n = n - (x &gt;&gt; 31);<br>   return n;<br>}</p>
<p><strong>只用位运算来取绝对值</strong><br>    这是一个非常有趣的问题。大家先自己想想吧，Ctrl+A显示答案。<br>    <span style="color:#E5E5E5">答案：假设x为32位整数，则x xor (not (x shr 31) + 1) + x shr 31的结果是x的绝对值<br>    x shr 31是二进制的最高位，它用来表示x的符号。如果它为0（x为正），则not (x shr 31) + 1等于$00000000，异或任何数结果都不变；如果最高位为1（x为负），则not (x shr 31) + 1等于$FFFFFFFF，x异或它相当于所有数位取反，异或完后再加一。</span></p>
<p><strong>高低位交换</strong><br>    <a target="_blank" href="http://www.vijos.cn/Problem_Show.asp?id=1201">这个题</a>实际上是我出的，做为学校内部NOIp模拟赛的第一题。题目是这样：<br>
</p>
<blockquote>    给出一个小于2^32的正整数。这个数可以用一个32位的二进制数表示（不足32位用0补足）。我们称这个二进制数的前16位为“高位”，后16位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。<br>　　例如，数1314520用二进制表示为0000 0000 0001 0100 0000 1110 1101 1000（添加了11个前导0补足为32位），其中前16位为高位，即0000 0000 0001 0100；后16位为低位，即0000 1110 1101 1000。将它的高低位进行交换，我们得到了一个新的二进制数0000 1110 1101 1000 0000 0000 0001 0100。它即是十进制的249036820。</blockquote>
<p>    当时几乎没有人想到用一句位操作来代替冗长的程序。使用位运算的话两句话就完了。<br><code>var<br>   n:dword;<br>begin<br>   readln( n );<br>   writeln( (n shr 16) or (n  shl 16) );<br>end.</code><br>    而事实上，Pascal有一个系统函数swap直接就可以用。</p>
<p><strong>二进制逆序</strong><br>    下面的程序读入一个32位整数并输</p>
			 ]]></content>
<pubDate>2007-07-24T02:42:13+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/264</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 位运算简介及实用技巧（三）：进阶篇(2) ]]></title>
<link>http://www.matrix67.com/blog/archives/266</link>
<content><![CDATA[ 
		<p>今天我们来看两个稍微复杂一点的例子。</p>
<p><strong>n皇后问题位运算版</strong><br>    n皇后问题是啥我就不说了吧，学编程的肯定都见过。下面的十多行代码是n皇后问题的一个高效位运算程序，看到过的人都夸它牛。初始时，upperlim:=(1 shl n)-1。主程序调用test(0,0,0)后sum的值就是n皇后总的解数。拿这个去交USACO，0.3s，暴爽。<br><code>procedure test(row,ld,rd:longint);<br>var<br>      pos,p:longint;<br>begin</code></p>
<p>{ 1}  if row&lt;&gt;upperlim then<br>{ 2}  begin<br>{ 3}     pos:=upperlim and not (row or ld or rd);<br>{ 4}     while pos&lt;&gt;0 do<br>{ 5}     begin<br>{ 6}        p:=pos and -pos;<br>{ 7}        pos:=pos-p;<br>{ 8}        test(row+p,(ld+p)shl 1,(rd+p)shr 1);<br>{ 9}     end;<br>{10}  end<br>{11}  else inc(sum);</p>
<p>end;<br>    乍一看似乎完全摸不着头脑，实际上整个程序是非常容易理解的。这里还是建议大家自己单步运行一探究竟，实在没研究出来再看下面的解说。</p>
<p><img alt="image placeholder" >
<p>    ~~~~====~~~~=====   华丽的分割线   =====~~~~====~~~~</p>
<p><strong>Gray码</strong><br>    假如我有4个潜在的GF，我需要决定最终到底和谁在一起。一个简单的办法就是，依次和每个MM交往一段时间，最后选择给我带来的“满意度”最大的MM。但看了<a target="_blank" href="http://tianyi.yo2.cn/go/89403.html">dd牛的理论</a>后，事情开始变得复杂了：我可以选择和多个MM在一起。这样，需要考核的状态变成了2^4=16种（当然包括0000这一状态，因为我有可能是玻璃）。现在的问题就是，我应该用什么顺序来遍历这16种状态呢？<br>    传统的做法是，用二进制数的顺序来遍历所有可能的组合。也就是说，我需要以0000-&gt;0001-&gt;0010-&gt;0011-&gt;0100-&gt;…-&gt;1111这样的顺序对每种状态进行测试。这个顺序很不科学，很多时候状态的转移都很耗时。比如从0111到1000时我需要暂时甩掉当前所有的3个MM，然后去把第4个MM。同时改变所有MM与我的关系是一件何等巨大的工程啊。因此，我希望知道，是否有一种方法可以使得，从没有MM这一状态出发，每次只改变我和一个MM的关系（追或者甩），15次操作后恰好遍历完所有可能的组合（最终状态不一定是1111）。大家自己先试一试看行不行。<br>    解决这个问题的方法很巧妙。我们来说明，假如我们已经知道了n=2时的合法遍历顺序，我们如何得到n=3的遍历顺序。显然，n=2的遍历顺序如下：</p>
<p> 00<br> 01<br> 11<br> 10</p>
<p>    你可能已经想到了如何把上面的遍历顺序扩展到n=3的情况。n=3时一共有8种状态，其中前面4个把n=2的遍历顺序照搬下来，然后把它们对称翻折下去并在最前面加上1作为后面4个状态：</p>
<p> <span style="color:blue">0</span><span style="color:red">00</span><br> <span style="color:blue">0</span><span style="color:red">01</span><br> <span style="color:blue">0</span><span style="color:red">11</span><br> <span style="color:blue">0</span><span style="color:red">10</span>  ↑<br> ——–<br> <span style="color:blue">1</span><span style="color:red">10</span>  ↓<br> <span style="color:blue">1</span><span style="color:red">11</span><br> <span style="color:blue">1</span><span style="color:red">01</span><br> <span style="color:blue">1</span><span style="color:red">00</span></p>
<p>    用这种方法得到的遍历顺序显然符合要求。首先，上面8个状态恰好是n=3时的所有8种组合，因为它们是在n=2的全部四种组合的基础上考虑选不选第3个元素所得到的。然后我们看到，后面一半的状态应该和前面一半一样满足“相邻状态间仅一位不同”的限制，而“镜面”处则是最前面那一位数不同。再次翻折三阶遍历顺序，我们就得到了刚才的问题的答案：</p>
<p> 0000<br> 0001<br> 0011<br> 0010<br> 0110<br> 0111<br> 0101<br> 0100<br> 1100<br> 1101<br> 1111<br> 1110<br> 1010<br> 1011<br> 1001<br> 1000</p>
<p>    这种遍历顺序作为一种编码方式存在，叫做Gray码（写个中文让蜘蛛来抓：格雷码）。它的应用范围很广。比如，n阶的Gray码相当于在n维立方体上的Hamilton回路，因为沿着立方体上的边走一步，n维坐标中只会有一个值改变。再比如，Gray码和Hanoi塔问题等价。Gray码改变的是第几个数，Hanoi塔就该移动哪个盘子。比如，3阶的Gray码每次改变的元素所在位置依次为1-2-1-3-1-2-1，这正好是3阶Hanoi塔每次移动盘子编号。如果我们可以快速求出Gray码的第n个数是多少，我们就可以输出任意步数后Hanoi塔的移动步骤。现在我告诉你，Gray码的第n个数（从0算起）是n xor (n shr 1)，你能想出来这是为什么吗？先自己想想吧。</p>
<p>    下面我们把二进制数和Gray码都写在下面，可以看到左边的数异或自身右移的结果就等于右边的数。</p>
<p><span style="font-family:宋体"> 二进制数   Gray码<br>   000       000<br>   001       001<br>   010       011<br>   011       010<br>   100       110<br>   101       111<br>   110       101<br>   111       100</span></p>
<p>    从二进制数的角度看，“镜像”位置上的数即是对原数进行not运算后的结果。比如，第3个数010和倒数第3个数101的每一位都正好相反。假设这两个数分别为x和y，那么x xor (x shr 1)和y xor (y shr 1)的结果只有一点不同：后者的首位是1，前者的首位是0。而这正好是Gray码的生成方法。这就说明了，Gray码的第n个数确实是n xor (n shr 1)。</p>
<p>&amp;nbsp<br>
;   今年四月份<a target="_blank" href="http://failedshuo.spaces.live.com/">mashuo</a>给我看了<a target="_blank" href="http://acm.sgu.ru/problem.php?contest=0&amp;problem=249">这道题</a>，是二维意义上的Gray码。题目大意是说，把0到2^(n+m)-1的数写成2^n * 2^m的矩阵，使得位置相邻两数的二进制表示只有一位之差。答案其实很简单，所有数都是由m位的Gray码和n位Gray码拼接而成，需要用左移操作和or运算完成。完整的代码如下：<br><code>var<br>   x,y,m,n,u:longint;<br>begin<br>   readln(m,n);<br>   for x:=0 to 1 shl m-1 do begin<br>      u:=(x xor (x shr 1)) shl n; //输出数的左边是一个m位的Gray码<br>      for y:=0 to 1 shl n-1 do<br>         write(u or (y xor (y shr 1)),' '); //并上一个n位Gray码<br>      writeln;<br>   end;<br>end.</code></p>
<p>Matrix67原创<br>转贴请注明出处</p>
			 ]]></content>
<pubDate>2007-07-26T00:51:00+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/266</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 位运算简介及实用技巧（四）：实战篇 ]]></title>
<link>http://www.matrix67.com/blog/archives/268</link>
<content><![CDATA[ 
		<p>    下面分享的是我自己写的三个代码，里面有些题目也是我自己出的。这些代码都是在我的Pascal时代写的，恕不提供C语言了。代码写得并不好，我只是想告诉大家位运算在实战中的应用，包括了搜索和状态压缩DP方面的题目。其实大家可以在网上找到更多用位运算优化的题目，这里整理出一些自己写的代码，只是为了原创系列文章的完整性。这一系列文章到这里就结束了，希望大家能有所收获。<br>    Matrix67原创，转贴请注明出处。</p>
<blockquote>
<p>Problem : 费解的开关</p>
<p><a target="_blank" href="http://www.vijos.cn/Problem_Show.asp?id=1197">题目来源</a><br>    06年NOIp模拟赛（一） by Matrix67 第四题</p>
<p>问题描述<br>    你玩过“拉灯”游戏吗？25盏灯排成一个5×5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。<br>    我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态</p>
<p>10111<br>01101<br>10111<br>10000<br>11011</p>
<p>    在改变了最左上角的灯的状态后将变成：</p>
<p>01111<br>11101<br>10111<br>10000<br>11011</p>
<p>    再改变它正中间的灯后状态将变成：</p>
<p>01111<br>11001<br>11001<br>10100<br>11011</p>
<p>    给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。</p>
<p>输入格式<br>    第一行有一个正整数n，代表数据中共有n个待解决的游戏初始状态。<br>    以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。<br>    对于30%的数据，n&lt;=5；<br>    对于100%的数据，n&lt;=500。</p>
<p>输出格式<br>    输出数据一共有n行，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。<br>    对于某一个游戏初始状态，若6步以内无法使所有灯变亮，请输出“-1”。</p>
<p>样例输入<br>3<br>00111<br>01011<br>10001<br>11010<br>11100</p>
<p>11101<br>11101<br>11110<br>11111<br>11111</p>
<p>01111<br>11111<br>11111<br>11111<br>11111</p>
<p>样例输出<br>3<br>2<br>-1</p>
</blockquote>
<p>程序代码<br><code>const<br>   BigPrime=3214567;<br>   MaxStep=6;<br>type<br>   pointer=^rec;<br>   rec=record<br>         v:longint;<br>         step:integer;<br>         next:pointer;<br>       end;</code></p>
<p>var<br>   total:longint;<br>   hash:array[0..BigPrime-1]of pointer;<br>   q:array[1..400000]of rec;</p>
<p>function update(a:longint;p:integer):longint;<br>begin<br>   a:=a xor (1 shl p);<br>   if p mod 5&lt;&gt;0 then a:=a xor (1 shl (p-1));<br>   if (p+1) mod 5&lt;&gt;0 then a:=a xor (1 shl (p+1));<br>   if p&lt;20 then a:=a xor (1 shl (p+5));<br>   if p&gt;4 then a:=a xor (1 shl (p-5));<br>   exit(a);<br>end;</p>
<p>function find(a:longint;step:integer):boolean;<br>var<br>   now:pointer;<br>begin<br>   now:=hash[a mod BigPrime];<br>   while now&lt;&gt;nil do<br>   begin<br>      if now^.v=a then exit(true);<br>      now:=now^.next;<br>   end;</p>
<p>   new(now);<br>   now^.v:=a;<br>   now^.step:=step;<br>   now^.next:=hash[a mod BigPrime];<br>   hash[a mod BigPrime]:=now;<br>   total:=total+1;<br>   exit(false);<br>end;</p>
<p>procedure solve;<br>var<br>   p:integer;<br>   close:longint=0;<br>   open:longint=1;<br>begin<br>   find(1 shl 25-1,0);<br>   q[1].v:=1 shl 25-1;<br>   q[1].step:=0;<br>   repeat<br>      inc(close);<br>      for p:=0 to 24 do<br>         if not find(update(q[close].v,p),q[close].step+1) and (q[close].step+1&lt;MaxStep) then<br>         begin<br>            open:=open+1;<br>            q[open].v:=update(q[close].v,p);<br>            q[open].step:=q[close].step+1;<br>         end;<br>   until close&gt;=open;<br>end;</p>
<p>procedure print(a:longint);<br>var<br>   now:pointer;<br>begin<br>   now:=hash[a mod BigPrime];<br>   while now&lt;&gt;nil do<br>   begin<br>      if now^.v=a then<br>      begin<br>         writeln(now^.step);<br>         exit;<br>      end;<br>      now:=now^.next;<br>   end;<br>   writeln(-1);<br>end;</p>
<p>procedure main;<br>var<br>   ch:char;<br>   i,j,n:integer;<br>   t:longint;<br>begin<br>   readln(n);<br>   for i:=1 to n do<br>   begin<br>      t:=0;<br>      for j:=1 to 25 do<br>      begin<br>         read(ch);<br>         t:=t*2+ord(ch)-48;<br>         if j mod 5=0 then readln;<br>      end;<br>      print(t);<br>      if i&lt;n then readln;<br>   end;<br>end;</p>
<p>begin<br>   solve;<br>   main;<br>end.</p>
<p><strong>=======================  性感的分割线  =======================</strong></p>
<blockquote>
<p>Problem : garden / 和MM逛花园</p>
<p>题目来源<br>    <a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=241">07年Matrix67生日邀请赛</a>第四题</p>
<p>问题描述<br>    花园设计强调，简单就是美。Matrix67常去的花园有着非常简单的布局：花园的所有景点的位置都是“对齐”了的，这些景点可以看作是平面坐标上的格点。相邻的景点之间有小路相连，这些小路全部平行于坐标轴。景点和小路组成了一个“不完整的网格”。<br>    一个典型的花园布局如左图所示。花园布局在6行4列的网格上，花园的16个景点的位置用红色标注在了图中。黑色线条表示景点间的小路，其余灰色部分实际并不存在。<br>        <img alt="image placeholder" >
<p>    Matrix67 的生日那天，他要带着他的MM在花园里游玩。Matrix67不会带MM两次经过同一个景点，因此每个景点最多被游览一次。他和他</p>
			</blockquote> ]]></content>
<pubDate>2007-07-26T01:47:44+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/268</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 令人敬畏的十维空间 ]]></title>
<link>http://www.matrix67.com/blog/archives/269</link>
<content><![CDATA[ 
		<p><img alt="image placeholder" >
			 ]]></content>
<pubDate>2007-07-27T19:54:10+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/269</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Art of Problem Solving: Proof without Words ]]></title>
<link>http://www.matrix67.com/blog/archives/271</link>
<content><![CDATA[ 
		<p>    <a target="_blank" href="http://www.artofproblemsolving.com/index.php">ArtOfProblemSolving.com</a>是一个数学社区网站。网站里有10个展示数学解题艺术的flash动画，每次打开首页时侧边栏会随机选择一个播放。这10个flash用简陋的动画证明了10个经典结论，整个证明过程只有动画演示，没有用一句话。这些经典证明哪些你已经见过？哪些你一看就懂？你最喜欢哪个？</p>
<p><a href="http://www.matrix67.com/blogimage/2007072901.swf">http://www.matrix67.com/blogimage/2007072901.swf</a><br><a href="http://www.matrix67.com/blogimage/2007072902.swf">http://www.matrix67.com/blogimage/2007072902.swf</a><br><a href="http://www.matrix67.com/blogimage/2007072903.swf">http://www.matrix67.com/blogimage/2007072903.swf</a><br><a href="http://www.matrix67.com/blogimage/2007072904.swf">http://www.matrix67.com/blogimage/2007072904.swf</a><br><a href="http://www.matrix67.com/blogimage/2007072905.swf">http://www.matrix67.com/blogimage/2007072905.swf</a><br><a href="http://www.matrix67.com/blogimage/2007072906.swf">http://www.matrix67.com/blogimage/2007072906.swf</a><br><a href="http://www.matrix67.com/blogimage/2007072907.swf">http://www.matrix67.com/blogimage/2007072907.swf</a><br><a href="http://www.matrix67.com/blogimage/2007072908.swf">http://www.matrix67.com/blogimage/2007072908.swf</a><br><a href="http://www.matrix67.com/blogimage/2007072909.swf">http://www.matrix67.com/blogimage/2007072909.swf</a><br><a href="http://www.matrix67.com/blogimage/2007072910.swf">http://www.matrix67.com/blogimage/2007072910.swf</a></p>
			 ]]></content>
<pubDate>2007-07-29T01:50:52+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/271</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ Puzzleup新一轮比赛8月1日开始 ]]></title>
<link>http://www.matrix67.com/blog/archives/272</link>
<content><![CDATA[ 
		<p>    <a target="_blank" href="http://www.puzzleup.com">Puzzleup</a>网站上每年都会举行一次数学谜题比赛。07年的比赛将于8月1日开始（由于时差原因，我们这里可能要晚一些）。比赛共进行20个星期，每个星期网站上会发布一道数学谜题，题目涉及代数、几何、概率、组合数学等各个领域。你需要把你得到的答案提交上去。题目描述十分简单，人人都懂；但真要想起来却没那么容易。比赛结束后，前十名将收到Puzzleup的证书，想来是一件很酷的事情。<br>    我参加了06年的比赛，可以负责任地告诉大家题目会是你喜欢的类型。遗憾的是由于各种原因，最后我没有坚持做到比赛结束。这里我翻译一下去年比赛的前5期题目，让感兴趣的同学先看看Puzzleup的题目类型。</p>
<p>1. 有五张红色的牌和五张蓝色的牌，分别从1到5编号。把这10张牌排成一圈，同时满足下面两个条件的排列方案有多少种？<br>     – 任两张相邻的牌颜色不同<br>     – 任两张相邻的牌编号不同<br>   如果这个问题是问的3张红牌和3张蓝牌，那么答案应该是12。</p>
<p>2. 沿着对角线把一个八边形分割为三角形共有多少种方法？<br>   如果这个问题问的是五边形，答案应该是5。</p>
<p>3. 老师叫学生们写下他们曾经去过的国家。每个学生独立地在自己的答卷上写下国家的名字。所有学生的答卷上共包含10个国家的名字，每张答卷都不相同，任两张答卷至少含有一个相同的名字。学生最多有多少个？</p>
<p>4. 16枚硬币摆成4×4的正方形。另一枚硬币贴着它们转一圈最后回到原位。请问这枚硬币自转了多少圈？</p>
<p>5. 在标准的8×8棋盘上摆放棋子，有多少种放法使得每个格子的相邻格子中正好有奇数个棋子？<br>   注意：相邻格子是指上下左右相邻，角上相邻的格子和格子自身不算。</p>
<p>更多的题目可以在<a target="_blank" href="http://2006.puzzleup.com/archive/">这里</a>找到</p>
			 ]]></content>
<pubDate>2007-07-31T00:10:03+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/272</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 趣题：非常具有启发性的概率问题 ]]></title>
<link>http://www.matrix67.com/blog/archives/273</link>
<content><![CDATA[ 
		<p>    问题：桌子上有10件东西。你随机取走几件，请问你手上的物体个数是奇数的可能性大还是偶数的可能性大？所谓“随机取物”，是说每一个物体被取走的概率都是1/2。因此，你有可能取走所有的物体，也有可能一样都没拿。</p>
<p>    继续看下去之前，请你先思考一下。</p>
<p>    把桌子上的物品个数换成5个，你的答案又是多少？</p>
<p>    继续看下去之前，请你先思考一下。</p>
<p>    显然，当桌子上物品数为5时，取走物品的个数是奇是偶概率一样，因为取0件和取5件的概率是相同的，取1件和取4件的概率也是相同的，取2件和取3件的概率还是相同的，最终算下来取奇数件和取偶数件的概率相同。现在再回过头去想想物品数为10的情况，仍然坚持你原来的答案吗？或者有什么新的想法？</p>
<p>    继续看下去之前，请你先思考一下。</p>
<p>    当桌子上有10件物品时，取走物品的个数是奇是偶概率仍然一样。把这10件物品平分成两堆，左边5件，右边5件，那么你会发现：左边和右边所取物品的个数有四种概率相等的组合：奇偶、偶奇、奇奇、偶偶。前两种情况下总的数目是奇数，后两种情况下总的数目是偶数。奇数和偶数的概率仍然相同。</p>
			 ]]></content>
<pubDate>2007-08-01T02:49:46+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/273</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 十个利用矩阵乘法解决的经典题目 ]]></title>
<link>http://www.matrix67.com/blog/archives/276</link>
<content><![CDATA[ 
		<p>    好像目前还没有这方面题目的总结。这几天连续看到四个问这类题目的人，今天在这里简单写一下。这里我们不介绍其它有关矩阵的知识，只介绍矩阵乘法和相关性质。<br>    不要以为数学中的矩阵也是黑色屏幕上不断变化的绿色字符。在数学中，一个矩阵说穿了就是一个二维数组。一个n行m列的矩阵可以乘以一个m行p列的矩阵，得到的结果是一个n行p列的矩阵，其中的第i行第j列位置上的数等于前一个矩阵第i行上的m个数与后一个矩阵第j列上的m个数对应相乘后所有m个乘积的和。比如，下面的算式表示一个2行2列的矩阵乘以2行3列的矩阵，其结果是一个2行3列的矩阵。其中，结果的那个4等于2*2+0*1：<br>     <img alt="image placeholder" >
<p>    矩阵乘法的两个重要性质：一，矩阵乘法<strong>不满足</strong>交换律；二，矩阵乘法满足结合律。为什么矩阵乘法不满足交换律呢？废话，交换过来后两个矩阵有可能根本不能相乘。为什么它又满足结合律呢？仔细想想你会发现这也是废话。假设你有三个矩阵A、B、C，那么(AB)C和A(BC)的结果的第i行第j列上的数都等于所有A(ik)*B(kl)*C(lj)的和（枚举所有的k和l）。</p>
<p><strong>经典题目1 给定n个点，m个操作，构造O(m+n)的算法输出m个操作后各点的位置。操作有平移、缩放、翻转和旋转</strong><br>    这里的操作是对所有点同时进行的。其中翻转是以坐标轴为对称轴进行翻转（两种情况），旋转则以原点为中心。如果对每个点分别进行模拟，那么m个操作总共耗时O(mn)。利用矩阵乘法可以在O(m)的时间里把所有操作合并为一个矩阵，然后每个点与该矩阵相乘即可直接得出最终该点的位置，总共耗时O(m+n)。假设初始时某个点的坐标为x和y，下面5个矩阵可以分别对其进行平移、旋转、翻转和旋转操作。预先把所有m个操作所对应的矩阵全部乘起来，再乘以(x,y,1)，即可一步得出最终点的位置。<br>     <img alt="image placeholder" >
<p><strong>经典题目2 给定矩阵A，请快速计算出A^n（n个A相乘）的结果，输出的每个数都mod p。</strong><br>    由于矩阵乘法具有结合律，因此A^4 = A * A * A * A = (A*A) * (A*A) = A^2 * A^2。我们可以得到这样的结论：当n为偶数时，A^n = A^(n/2) * A^(n/2)；当n为奇数时，A^n = A^(n/2) * A^(n/2) * A （其中n/2取整）。这就告诉我们，计算A^n也可以使用二分快速求幂的方法。例如，为了算出A^25的值，我们只需要递归地计算出A^12、A^6、A^3的值即可。根据<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=282">这里</a>的一些结果，我们可以在计算过程中不断取模，避免高精度运算。</p>
<p><strong>经典题目3 <a target="_blank" href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3233">POJ3233</a></strong> (感谢<a target="_blank" href="http://hi.baidu.com/rangemq/blog/item/cd0b9534a57f6ab6d1a2d32b.html">rmq</a>)<br>    题目大意：给定矩阵A，求A + A^2 + A^3 + … + A^k的结果（两个矩阵相加就是对应位置分别相加）。输出的数据mod m。k&lt;=10^9。<br>    这道题两次二分，相当经典。首先我们知道，A^i可以二分求出。然后我们需要对整个题目的数据规模k进行二分。比如，当k=6时，有：<br>    A + A^2 + A^3 + A^4 + A^5 + A^6 =<u>(A + A^2 + A^3)</u> + A^3*<u>(A + A^2 + A^3)</u><br>    应用这个式子后，规模k减小了一半。我们二分求出A^3后再递归地计算A + A^2 + A^3，即可得到原问题的答案。</p>
<p><strong>经典题目4 <a target="_blank" href="http://www.vijos.cn/Problem_Show.asp?id=1049">VOJ1049</a></strong><br>    题目大意：顺次给出m个置换，反复使用这m个置换对初始序列进行操作，问k次置换后的序列。m&lt;=10, k&lt;2^31。<br>    首先将这m个置换“合并”起来（算出这m个置换的乘积），然后接下来我们需要执行这个置换k/m次（取整，若有余数则剩下几步模拟即可）。注意任意一个置换都可以表示成矩阵的形式。例如，将1 2 3 4置换为3 1 2 4，相当于下面的矩阵乘法：<br>     <img alt="image placeholder" >
<p><strong>经典题目5 《算法艺术与信息学竞赛》207页（2.1代数方法和模型，[例题5]细菌，版次不同可能页码有偏差）</strong><br>    大家自己去看看吧，书上讲得很详细。解题方法和上一题类似，都是用矩阵来表示操作，然后二分求最终状态。</p>
<p><strong>经典题目6 给定n和p，求第n个Fibonacci数mod p的值，n不超过2^31</strong><br>    根据前面的一些思路，现在我们需要构造一个2 x 2的矩阵，使得它乘以(a,b)得到的结果是(b,a+b)。每多乘一次这个矩阵，这两个数就会多迭代一次。那么，我们把这个2 x 2的矩阵自乘n次，再乘以(0,1)就可以得到第n个Fibonacci数了。不用多想，这个2 x 2的矩阵很容易构造出来：<br>     <img alt="image placeholder" >
<p><strong>经典题目7 <a target="_blank" href="http://www.vijos.cn/Problem_Show.asp?id=1067">VOJ1067</a></strong><br>    我们可以用上面的方法二分求出任何一个线性递推式的第n项，其对应矩阵的构造方法为：在右上角的(n-1)*(n-1)的小矩阵中的主对角线上填1，矩阵第n行填对应的系数，其它地方都填0。例如，我们可以用下面的矩阵乘法来二分计算f(n) = 4f(n-1) – 3f(n-2) + 2f(n-4)的第k项：<br>     <img alt="image placeholder" >
<p><strong>经典题目8 给定一个有向图，问从A点恰好走k步（允许重复经过边）到达B点的方案数mod p的值</strong><br>    把给定的图转为邻接矩阵，即A(i,j)=1当且仅当存在一条边i-&gt;j。令C=A*A，那么C(i,j)=ΣA(i,k)*A(k,j)，实际上就等于从点i到点j恰好经过2条边的路径数（枚举k为中转点）。类似地，C*A的第i行第j列就表示从i到j经过3条边的路径数。同理，如果要求经过k步的路径数，我们只需要二分求出A^k即可。</p>
<p><strong>经典题目9 用1 x 2的多米诺骨牌填满M x N的矩形有多少种方案，M&lt;=5，N&lt;2^31，输出答案mod p的结果</strong><br>     <img alt="image placeholder" >
			 ]]></content>
<pubDate>2007-08-04T04:01:04+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/276</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 花了我五秒钟才反应过来，笑死我了～～～ ]]></title>
<link>http://www.matrix67.com/blog/archives/278</link>
<content><![CDATA[ 
		<p>3×12=36<br>2×12=24<br>1×12=12<br>0x12=18</p>
			 ]]></content>
<pubDate>2007-08-06T13:53:29+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/278</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
<item>
<title><![CDATA[ 神奇的分形艺术（三）：Sierpinski三角形 ]]></title>
<link>http://www.matrix67.com/blog/archives/280</link>
<content><![CDATA[ 
		<p>    在所有的分形图形中，Sierpinski三角形可能是大家最熟悉的了，因为它在OI题目中经常出现，<a target="_blank" href="http://acm.zju.edu.cn/show_problem.php?pid=1975">OJ上的题目</a>和<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=186">省选题目</a>中都有它的身影。这篇文章将简单介绍Sierpinski三角形的几个惊人性质。如果你以前就对Sierpinski三角形有一些了解，这篇文章带给你的震撼将更大，因为你会发现Sierpinski三角形竟然还有这些用途。</p>
<p><strong>Sierpinski三角形的构造</strong><br>       <img alt="image placeholder" >
<p>    Sierpinski三角形的另一种构造方法如下图所示。把正方形分成四等份，去掉右下角的那一份，并且对另外三个正方形递归地操作下去。挖个几次后把脑袋一歪，你就可以看到一个等腰直角的Sierpinski三角形。</p>
<p>       <img alt="image placeholder" >
<p>    Sierpinski三角形有一个神奇的性质：如果某一个位置上有点（没被挖去），那么它与原三角形顶点的连线上的中点处也有点。这给出另一个诡异的Sierpinski三角形构造方法：给出三角形的三个顶点，然后从其中一个顶点出发，每次随机向任意一个顶点移动1/2的距离（走到与那个顶点的连线的中点上），并在该位置作一个标记；无限次操作后所有的标记就组成了Sierpinski三角形。下面的程序演示了这一过程，程序在fpc 2.0下通过编译。对不起用C语言的兄弟了，我不会C语言的图形操作。<br><code>{$ASSERTIONS+}</code></p>
<p>uses graph,crt;</p>
<p>const<br>   x1=320;  y1=20;<br>   x2=90;   y2=420;<br>   x3=550;  y3=420;<br>   density=2500;<br>   timestep=10;</p>
<p>var<br>   gd,gm,i,r:integer;<br>   x,y:real;</p>
<p>begin<br>   gd:=D8bit;<br>   gm:=m640x480;<br>   InitGraph(gd,gm,'');<br>   Assert(graphResult=grOk);</p>
<p>   x:=x1;<br>   y:=y1;<br>   for i:=1 to density do<br>   begin<br>      r:=random(3);<br>      if r=0 then<br>      begin<br>         x:=(x+x1)/2;<br>         y:=(y+y1)/2;<br>      end<br>      else if r=1 then<br>      begin<br>         x:=(x+x2)/2;<br>         y:=(y+y2)/2;<br>      end<br>      else begin<br>         x:=(x+x3)/2;<br>         y:=(y+y3)/2;<br>      end;<br>      PutPixel(round(x),round(y),white);<br>      Delay(timestep);<br>   end;<br>   CloseGraph;<br>end.</p>
<p><strong>Sierpinski三角形与杨辉三角</strong><br>    第一次发现Sierpinski三角形与杨辉三角的关系时，你会发现这玩意儿不是一般的牛。写出8行或者16行的杨辉三角，然后把杨辉三角中的奇数和偶数用不同的颜色区别开来，你会发现杨辉三角模2与Sierpinski三角形是等价的。也就是说，二项式系数（组合数）的奇偶性竟然可以表现为一个分形图形！在感到诧异的同时，冷静下来仔细想想，你会发现这并不难理解。<br>       <img alt="image placeholder" >
<p><strong>Sierpinski三角形与Hanoi塔</strong><br>    有没有想过，把Hanoi塔的所有状态画出来，可以转移的状态间连一条线，最后得到的是一个什么样的图形？二阶Hanoi塔反正也只有9个节点，你可以自己试着画一下。不断调整节点的位置后，得到的图形大概就像这个样子：<br>       <img alt="image placeholder" >
<p><strong>Sierpinski三角形与<a target="_blank" href="http://www.matrix67.com/blog/article.asp?id=311">位运算</a></strong><br>    编程画出Sierpinski三角形比想象中的更简单。下面的两个代码（实质相同，仅语言不同）可以打印出一个Sierpinski三角形来。<br><code>const<br>   n=1 shl 5-1;<br>var<br>   i,j:integer;<br>begin<br>   for i:=0 to n do<br>   begin<br>      for j:=0 to n do<br>         if i and j = j then write('#')<br>         else write(' ');<br>      writeln;<br>   end;<br>   readln;<br>end.</code><br><code>#include &lt;stdio.h&gt;<br>int main()<br>{<br>    const int n=(1&lt;&lt;5)-1;<br>    int i,j;<br>    for (i=0; i&lt;=n; i++)<br>    {<br>        for (j=0; j&lt;=n; j++)<br>           printf( (i&amp;j)==j ? "#" : " ");<br>        printf("n");<br>    }    <br>    getchar();<br> &amp;n<br>
bsp;  return 0;<br>}</code><br>    上面两个程序是一样的。程序将输出：<br><code>#                               <br>##                              <br># #                             <br>####                            <br>#   #                           <br>##  ##                          <br># # # #                         <br>########                        <br>#       #                       <br>##      ##                      <br># #     # #                     <br>####    ####                    <br>#   #   #   #                   <br>##  ##  ##  ##                  <br># # # # # # # #                 <br>################                <br>#               #               <br>##              ##              <br># #             # #             <br>####            ####            <br>#   #           #   #           <br>##  ##          ##  ##          <br># # # #         # # # #         <br>########        ########        <br>#       #       #       #       <br>##      ##      ##      ##      <br># #     # #     # #     # #     <br>####    ####    ####    ####    <br>#   #   #   #   #   #   #   #   <br>##  ##  ##  ##  ##  ##  ##  ##  <br># # # # # # # # # # # # # # # # <br>################################</code></p>
<p>    这个程序告诉我们：在第i行第j列上打一个点当且仅当i and j=j，这样最后得到的图形就是一个Sierpinski三角形。这是为什么呢？其实原因很简单。把i和j写成二进制（添加前导0使它们位数相同），由于j不能大于i，因此只有下面三种情况：<br>    情况一：<br>    i = 1?????<br>    j = 1?????<br>    问号部分i大于等于j<br>    i的问号部分记作i'，j的问号部分记作j'。此时i and j=j当且仅当i' and j'=j'</p>
<p>    情况二：<br>    i = 1?????<br>    j = 0?????<br>    问号部分i大于等于j<br>    i的问号部分记作i'，j的问号部分记作j'。此时i and j=j当且仅当i' and j'=j'</p>
<p>    情况三：<br>    i = 1?????<br>    j = 0?????<br>    问号部分i小于j<br>    此时i and j永远不可能等于j。i' &lt; j'意味着i'和j'中首次出现数字不同的那一位上前者为0，后者为1，那么i和j做and运算时这一位的结果是0，与j不等。</p>
<p>    注意到，去掉一个二进制数最高位上的“1”，相当于从这个数中减去不超过它的最大的2的幂。观察每一种情况中i,j和i',j'的实际位置，不难发现这三种情况递归地定义出了整个Sierpinski三角形。<br>    嘿！发现没有，我通过Sierpinski三角形证明了这个结论：组合数C(N,K)为奇数当且仅当N and K=K。这篇文章很早之前就计划在写了，前几天有人问到这个东西，今天顺便也写进来。<br>    另外，把i and j=j 换成i or j=n也可以打印出Sierpinski三角形来。i and j=j表示j的二进制中有1的位置上i也有个1，那么此时i or (not j)结果一定全为1（相当于程序中的常量n），因此打印出来的结果与原来的输出正好左右镜像。</p>
<p>Matrix67原创<br>转贴请注明出处</p>
<p>网友Voldemort在12楼和13楼很辛苦地帖了一个杨辉三角模2问题的扩展，大家可以看看</p>
			 ]]></content>
<pubDate>2007-08-08T07:59:46+00:00</pubDate>
<guid>http://www.matrix67.com/blog/archives/280</guid>
<author><![CDATA[ 顾森 ]]></author>
</item>
</channel>
</rss>
